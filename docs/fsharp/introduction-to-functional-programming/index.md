---
title: F# 函式程式設計簡介
description: '瞭解 F # 中功能性程式設計的基本概念。'
ms.date: 10/29/2018
ms.openlocfilehash: fc2aebe80de16b92942c3557c0e03c198883dde1
ms.sourcegitcommit: ecd9e9bb2225eb76f819722ea8b24988fe46f34c
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 12/05/2020
ms.locfileid: "96740324"
---
# <a name="introduction-to-functional-programming-in-f"></a>F 中的功能程式設計簡介\#

功能性程式設計是一種程式設計樣式，強調函式和不可變數據的使用。 具型別函式程式設計是指將函式程式設計與靜態類型（例如 F #）結合。 一般情況下，功能程式設計會強調下列概念：

* 作為您使用之主要結構的函式
* 運算式而非語句
* 變數上的不可變值
* 命令式程式設計的宣告式程式設計

在本系列中，您將探索使用 F # 的功能性程式設計概念和模式。 在過程中，您也將學習一些 F #。

## <a name="terminology"></a>術語

功能性程式設計（如同其他程式設計架構）隨附的詞彙，您最終將需要學習。 以下是您將會看到的一些常見詞彙：

* **函數** -函式是一種結構，會在指定輸入時產生輸出。 更正式來說，它會將某個專案從一個集合 _對應_ 到另一個集合。 這項形式在許多方面都是以實體方式來完成，特別是在使用資料集合的函式時。 這是功能性程式設計中最基本的 (和重要的) 概念。
* **運算式** -運算式是在產生值的程式碼中的結構。 在 F # 中，必須系結或明確忽略此值。 運算式可以完整由函式呼叫取代。
* **純度** -純度是函數的屬性，因此相同的引數的傳回值一律相同，而且其評估沒有任何副作用。 純虛擬函式完全取決於其引數。
* **參考透明度** -參考透明度是運算式的屬性，可將它們取代為其輸出，而不會影響程式的行為。
* **永久性** -永久性表示無法就地變更值。 這與可以就地變更的變數相比較。

## <a name="examples"></a>範例

下列範例示範這些核心概念。

### <a name="functions"></a>函式

函式程式設計中最常見的基本結構是函數。 以下是將1加到整數的簡單函式：

```fsharp
let addOne x = x + 1
```

其類型簽章如下所示：

```fsharp
val addOne: x:int -> int
```

簽章可以讀取為「 `addOne` 接受 `int` 已命名 `x` 且將會產生」 `int` 。 更正式 `addOne` 來說，是將一組整數的值 _對應_ 至整陣列。 `->`Token 表示此對應。 在 F # 中，您通常可以查看函式簽章，以瞭解其用途。

那麼，為什麼簽章很重要？ 在具型別函式程式設計中，函數的執行通常比實際的型別簽章更不重要！ `addOne`將值1加入至整數的事實在執行時間很有趣，但是當您在建立程式時，它接受並傳回的事實 `int` 就是通知您實際使用此函式的方式。 此外，一旦您正確地使用此函式 (相對於其類型簽章) ，則診斷任何問題只能在函式主體內進行 `addOne` 。 這是具類型的功能性程式設計背後的促成。

### <a name="expressions"></a>運算式

運算式是評估為值的結構。 相較于執行動作的語句，運算式可以考慮執行可傳回值的動作。 運算式幾乎一律用於函式程式設計中的語句。

請考慮先前的函數 `addOne` 。 的主體 `addOne` 為運算式：

```fsharp
// 'x + 1' is an expression!
let addOne x = x + 1
```

這是定義函數結果型別的運算式結果 `addOne` 。 例如，組成此函式的運算式可能會變更為不同的類型，例如 `string` ：

```fsharp
let addOne x = x.ToString() + "1"
```

函數的簽章現在是：

```fsharp
val addOne: x:'a -> string
```

由於 F # 中的任何型別都可以 `ToString()` 呼叫它，因此的型別已 `x` 成為泛型 (稱為 [自動一般化](../language-reference/generics/automatic-generalization.md)) ，而結果型別為 `string` 。

運算式不只是函數的主體。 您可以有運算式來產生您在其他地方使用的值。 其中一個常見的情況是 `if` ：

```fsharp
// Checks if 'x' is odd by using the mod operator
let isOdd x = x % 2 <> 0

let addOneIfOdd input =
    let result =
        if isOdd input then
            input + 1
        else
            input

    result
```

`if`運算式會產生名為的 `result` 值。 請注意，您可以 `result` 完全省略，讓 `if` 運算式成為 `addOneIfOdd` 函數主體。 要記住運算式的重點在於它們會產生一個值。

有一種特殊的型 `unit` 別，會在沒有要傳回的專案時使用。 例如，請考慮這個簡單的函式：

```fsharp
let printString (str: string) =
    printfn $"String is: {str}"
```

簽章看起來像這樣：

```fsharp
val printString: str:string -> unit
```

`unit`型別指出沒有傳回實際值。 當您的常式必須「執行工作」，但因為該工作不會傳回任何值時，這非常有用。

這與命令式程式設計相反，其中對等的 `if` 結構是語句，而產生值通常是透過變動變數來完成。 例如，在 c # 中，程式碼的撰寫方式可能如下所示：

```csharp
bool IsOdd(int x) => x % 2 != 0;

int AddOneIfOdd(int input)
{
    var result = input;

    if (IsOdd(input))
    {
        result = input + 1;
    }

    return result;
}
```

值得注意的是，c # 和其他 C 樣式的語言都支援 [三元運算式](../../csharp/language-reference/operators/conditional-operator.md)，這種運算式允許以運算式為基礎的條件式程式設計。

在功能性程式設計中，使用語句來改變值是很罕見的。 雖然有些功能性語言支援語句和變化，但是在功能性程式設計中使用這些概念並不常見。

### <a name="pure-functions"></a>純虛擬函式

如先前所述，純虛擬函式是函式，其功能如下：

* 針對相同的輸入，一律評估為相同的值。
* 沒有副作用。

在此內容中考慮數學函數很有説明。 在數學中，函式只會依賴其引數，而且沒有任何副作用。 在數學函數中 `f(x) = x + 1` ，的值 `f(x)` 只取決於的值 `x` 。 函式程式設計中的純虛擬函式是一樣的。

撰寫純虛擬函式時，函式只能相依于其引數，而不會執行任何會產生副作用的動作。

以下是非純虛擬函式的範例，因為它相依于全域、可變動的狀態：

```fsharp
let mutable value = 1

let addOneToValue x = x + value
```

此函式 `addOneToValue` 很清楚地 impure，因為 `value` 可以隨時變更為具有不同于1的值。 這種以全域值為依據的模式，可避免在功能性程式設計中使用。

以下是非純虛擬函式的另一個範例，因為它會執行副作用：

```fsharp
let addOneToValue x =
    printfn $"x is %d{x}"
    x + 1
```

雖然此函式不會相依于全域值，但它會將的值寫入 `x` 程式的輸出。 雖然這樣做並不會發生任何錯誤，但這表示此函式不是單純的。 如果程式的另一個部分相依于程式外部的某個專案，例如輸出緩衝區，則呼叫此函式會影響程式的其他部分。

移除 `printfn` 語句會讓函數成為單純的：

```fsharp
let addOneToValue x = x + 1
```

雖然此函式在本質上並不 _優於_ 使用語句的舊版 `printfn` ，但它確實保證此函式確實會傳回值。 每次呼叫此函式會產生相同的結果：它只會產生值。 由純度提供的可預測性，是許多功能程式設計人員致力於的一些功能。

### <a name="immutability"></a>不變性

最後，具型別函式程式設計的其中一個最基本概念是永久性。 在 F # 中，所有值預設都是不可變的。 這表示，除非您將它們明確地標示為可變動，否則它們無法就地變動。

在實務上，使用不可變的值表示您將程式設計的方法從「我需要變更一些東西」變更為「我需要產生新的值」。

例如，將1加1值表示產生新的值，而不會變更現有的值：

```fsharp
let value = 1
let secondValue = value + 1
```

在 F # 中，下列程式碼 **不會** 改變 `value` 函數; 相反地，它會執行相等檢查：

```fsharp
let value = 1
value = value + 1 // Produces a 'bool' value!
```

有些功能性程式設計語言並不支援變動。 在 F # 中，它是支援的，但它不是值的預設行為。

此概念甚至進一步延伸至資料結構。 在功能性程式設計中，不可變的資料結構，例如 set (以及許多) 有不同于一開始預期的不同執行。 就概念而言，將專案加入至集合中的專案並不會變更集合，它會產生具有新增值的 _新_ 集合。 在幕後，這通常是透過不同的資料結構來完成，讓您能夠有效率地追蹤值，以便將資料的適當標記法提供給結果。

這種使用值和資料結構的樣式是很重要的，因為它會強制您將修改某些事物的任何作業視為建立新的版本。 這可讓您的程式中的等號和可比較性等專案保持一致。

## <a name="next-steps"></a>後續步驟

下一節將徹底涵蓋函式，探索可在功能性程式設計中使用這些功能的不同方式。

[第](first-class-functions.md) 一級函式探索更深層的函式，並示範如何在各種內容中使用這些函數。

## <a name="further-reading"></a>進階閱讀

[思考功能](https://fsharpforfunandprofit.com/posts/thinking-functionally-intro/)系列是另一項絕佳的資源，可瞭解如何使用 F # 進行功能性程式設計。 它涵蓋功能性程式設計的基本概念，並使用 F # 功能來說明概念，以提供實用且容易閱讀的方式。
