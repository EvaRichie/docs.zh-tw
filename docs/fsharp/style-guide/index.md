---
title: F# 樣式指南
description: '瞭解良好 F # 程式碼的五個原則。'
ms.date: 12/10/2018
ms.openlocfilehash: 9f47257626e04b09b546de2ae315d48d791678be
ms.sourcegitcommit: 67ebdb695fd017d79d9f1f7f35d145042d5a37f7
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 10/20/2020
ms.locfileid: "92223652"
---
# <a name="f-style-guide"></a><span data-ttu-id="7573d-103">F# 樣式指南</span><span class="sxs-lookup"><span data-stu-id="7573d-103">F# style guide</span></span>

<span data-ttu-id="7573d-104">下列文章說明格式化 F # 程式碼的指導方針，以及語言功能和其使用方式的主題指引。</span><span class="sxs-lookup"><span data-stu-id="7573d-104">The following articles describe guidelines for formatting F# code and topical guidance for features of the language and how they should be used.</span></span>

<span data-ttu-id="7573d-105">本指南的設計是根據在大型程式碼基底中使用 F # 搭配不同的程式設計人員群組。</span><span class="sxs-lookup"><span data-stu-id="7573d-105">This guidance has been formulated based on the use of F# in large codebases with a diverse group of programmers.</span></span> <span data-ttu-id="7573d-106">本指引通常會在程式的需求隨著時間而變更時，導致成功使用 F # 並將挫折降到最低。</span><span class="sxs-lookup"><span data-stu-id="7573d-106">This guidance generally leads to successful use of F# and minimizes frustrations when requirements for programs change over time.</span></span>

## <a name="five-principles-of-good-f-code"></a><span data-ttu-id="7573d-107">優質 F # 程式碼的五個準則</span><span class="sxs-lookup"><span data-stu-id="7573d-107">Five principles of good F# code</span></span>

<span data-ttu-id="7573d-108">當您撰寫 F # 程式碼時，請記住下列原則，特別是在將隨著時間變更的系統中。</span><span class="sxs-lookup"><span data-stu-id="7573d-108">Keep the following principles in mind any time you write F# code, especially in systems that will change over time.</span></span> <span data-ttu-id="7573d-109">進一步文章中的每一項指導方針都是來自這五個重點。</span><span class="sxs-lookup"><span data-stu-id="7573d-109">Every piece of guidance in further articles stems from these five points.</span></span>

1. <span data-ttu-id="7573d-110">**良好的 F # 程式碼簡潔、易懂且可組合**</span><span class="sxs-lookup"><span data-stu-id="7573d-110">**Good F# code is succinct, expressive, and composable**</span></span>

    <span data-ttu-id="7573d-111">F # 有許多功能可讓您以較少的程式碼來表達動作，並重複使用一般功能。</span><span class="sxs-lookup"><span data-stu-id="7573d-111">F# has many features that allow you to express actions in fewer lines of code and reuse generic functionality.</span></span> <span data-ttu-id="7573d-112">F # 核心程式庫也包含許多實用的型別和函式，可用來處理常見的資料集合。</span><span class="sxs-lookup"><span data-stu-id="7573d-112">The F# core library also contains many useful types and functions for working with common collections of data.</span></span> <span data-ttu-id="7573d-113">撰寫您自己的函式，以及 F # 核心程式庫中的函式 (或其他程式庫) 屬於常式慣用 F # 程式設計的一部分。</span><span class="sxs-lookup"><span data-stu-id="7573d-113">Composition of your own functions and those in the F# core library (or other libraries) is a part of routine idiomatic F# programming.</span></span> <span data-ttu-id="7573d-114">一般來說，如果您可以用較少的程式碼來表達問題的解決方案，其他開發人員 (或未來的自我) 將會令人激賞。</span><span class="sxs-lookup"><span data-stu-id="7573d-114">As a general rule, if you can express a solution to a problem in fewer lines of code, other developers (or your future self) will be appreciative.</span></span> <span data-ttu-id="7573d-115">此外，強烈建議您在需要執行重要工作時使用程式庫（例如 Fsharp.core）、執行 F # 的 [大型 .net 程式庫](../../../api/index.md) ，或 [NuGet](https://www.nuget.org/) 上的協力廠商套件。</span><span class="sxs-lookup"><span data-stu-id="7573d-115">It's also highly recommended that you use a library such as FSharp.Core, the [vast .NET libraries](../../../api/index.md) that F# runs on, or a third-party package on [NuGet](https://www.nuget.org/) when you need to do a nontrivial task.</span></span>

2. <span data-ttu-id="7573d-116">**良好的 F # 程式碼可互通**</span><span class="sxs-lookup"><span data-stu-id="7573d-116">**Good F# code is interoperable**</span></span>

    <span data-ttu-id="7573d-117">交互操作可採用多種形式，包括使用不同語言的程式碼。</span><span class="sxs-lookup"><span data-stu-id="7573d-117">Interoperation can take multiple forms, including consuming code in different languages.</span></span> <span data-ttu-id="7573d-118">與其他呼叫端交互操作的程式碼界限是很重要的部分，即使呼叫端也在 F # 中也是一樣。</span><span class="sxs-lookup"><span data-stu-id="7573d-118">The boundaries of your code that other callers interoperate with are critical pieces to get right, even if the callers are also in F#.</span></span> <span data-ttu-id="7573d-119">在撰寫 F # 時，您應該一律考慮其他程式碼如何呼叫您所撰寫的程式碼，包括從另一種語言（例如 c #）。</span><span class="sxs-lookup"><span data-stu-id="7573d-119">When writing F#, you should always be thinking about how other code will call into the code you're writing, including if they do so from another language like C#.</span></span> <span data-ttu-id="7573d-120">[F # 元件設計指導方針](component-design-guidelines.md)會詳細描述互通性。</span><span class="sxs-lookup"><span data-stu-id="7573d-120">The [F# Component Design Guidelines](component-design-guidelines.md) describe interoperability in detail.</span></span>

3. <span data-ttu-id="7573d-121">**良好的 F # 程式碼會使用物件程式設計，而不是物件方向**</span><span class="sxs-lookup"><span data-stu-id="7573d-121">**Good F# code makes use of object programming, not object orientation**</span></span>

    <span data-ttu-id="7573d-122">F # 具有在 .NET 中使用物件進行程式設計的完整支援，包括 [類別](../language-reference/classes.md)、 [介面](../language-reference/interfaces.md)、 [存取](../language-reference/access-control.md)修飾詞、 [抽象類別](../language-reference/abstract-classes.md)等等。</span><span class="sxs-lookup"><span data-stu-id="7573d-122">F# has full support for programming with objects in .NET, including [classes](../language-reference/classes.md), [interfaces](../language-reference/interfaces.md), [access modifiers](../language-reference/access-control.md), [abstract classes](../language-reference/abstract-classes.md), and so on.</span></span> <span data-ttu-id="7573d-123">針對更複雜的功能程式碼（例如必須是內容感知的函式），物件可以輕鬆地以函式不能的方式封裝內容資訊。</span><span class="sxs-lookup"><span data-stu-id="7573d-123">For more complicated functional code, such as functions that must be context-aware, objects can easily encapsulate contextual information in ways that functions cannot.</span></span> <span data-ttu-id="7573d-124">[選擇性參數和選擇性](../language-reference/members/methods.md#optional-arguments)地使用多[載的功能，可讓](../language-reference/members/methods.md#overloaded-methods)呼叫者更容易使用這項功能。</span><span class="sxs-lookup"><span data-stu-id="7573d-124">Features such as [optional parameters](../language-reference/members/methods.md#optional-arguments) and careful use of [overloading](../language-reference/members/methods.md#overloaded-methods) can make consumption of this functionality easier for callers.</span></span>

4. <span data-ttu-id="7573d-125">**良好的 F # 程式碼順利執行而不會公開變化**</span><span class="sxs-lookup"><span data-stu-id="7573d-125">**Good F# code performs well without exposing mutation**</span></span>

    <span data-ttu-id="7573d-126">這不是撰寫高效能程式碼的秘密，您必須使用變化。</span><span class="sxs-lookup"><span data-stu-id="7573d-126">It's no secret that to write high-performance code, you must use mutation.</span></span> <span data-ttu-id="7573d-127">這就是電腦的運作方式。</span><span class="sxs-lookup"><span data-stu-id="7573d-127">It's how computers work, after all.</span></span> <span data-ttu-id="7573d-128">這類程式碼通常很容易出錯，因此很難正確取得。</span><span class="sxs-lookup"><span data-stu-id="7573d-128">Such code is often error-prone and difficult to get right.</span></span> <span data-ttu-id="7573d-129">避免對呼叫端公開變化。</span><span class="sxs-lookup"><span data-stu-id="7573d-129">Avoid exposing mutation to callers.</span></span> <span data-ttu-id="7573d-130">相反地，請 [建立一個功能介面，以](conventions.md#performance) 在效能很重要時隱藏以變化為基礎的實作為基礎。</span><span class="sxs-lookup"><span data-stu-id="7573d-130">Instead, [build a functional interface that hides a mutation-based implementation](conventions.md#performance) when performance is critical.</span></span>

5. <span data-ttu-id="7573d-131">**Toolable 良好的 F # 程式碼**</span><span class="sxs-lookup"><span data-stu-id="7573d-131">**Good F# code is toolable**</span></span>

    <span data-ttu-id="7573d-132">工具很適合用於大型程式碼基底，而且您可以撰寫 F # 程式碼，以便使用 F # 語言工具來更有效地使用它。</span><span class="sxs-lookup"><span data-stu-id="7573d-132">Tools are invaluable for working in large codebases, and you can write F# code such that it can be used more effectively with F# language tooling.</span></span> <span data-ttu-id="7573d-133">其中一個範例是確保您不會以無點的程式設計方式來濫用這個方法它，如此就可以使用偵錯工具來檢查中繼值。</span><span class="sxs-lookup"><span data-stu-id="7573d-133">One example is making sure you don't overdo it with a point-free style of programming, so that intermediate values can be inspected with a debugger.</span></span> <span data-ttu-id="7573d-134">另一個範例是使用 [XML 檔批註](../language-reference/xml-documentation.md) 來描述結構，讓編輯器中的工具提示可以在呼叫位置顯示這些批註。</span><span class="sxs-lookup"><span data-stu-id="7573d-134">Another example is using [XML documentation comments](../language-reference/xml-documentation.md) describing constructs such that tooltips in editors can display those comments at the call site.</span></span> <span data-ttu-id="7573d-135">請務必考慮其他程式設計人員如何使用其工具來讀取、流覽、調試和操作您的程式碼。</span><span class="sxs-lookup"><span data-stu-id="7573d-135">Always think about how your code will be read, navigated, debugged, and manipulated by other programmers with their tools.</span></span>

## <a name="next-steps"></a><span data-ttu-id="7573d-136">後續步驟</span><span class="sxs-lookup"><span data-stu-id="7573d-136">Next steps</span></span>

<span data-ttu-id="7573d-137">[F # 程式碼格式設定指導方針](formatting.md)提供有關如何格式化程式碼以方便閱讀的指引。</span><span class="sxs-lookup"><span data-stu-id="7573d-137">The [F# code formatting guidelines](formatting.md) provide guidance on how to format code so that it is easy to read.</span></span>

<span data-ttu-id="7573d-138">[F # 編碼慣例](conventions.md)提供 f # 程式設計慣用語的指引，可協助長期維護較大的 f # 程式碼基底。</span><span class="sxs-lookup"><span data-stu-id="7573d-138">The [F# coding conventions](conventions.md) provide guidance for F# programming idioms that will help the long-term maintenance of larger F# codebases.</span></span>

<span data-ttu-id="7573d-139">[F # 元件設計指導方針](component-design-guidelines.md)提供撰寫 F # 元件的指引，例如程式庫。</span><span class="sxs-lookup"><span data-stu-id="7573d-139">The [F# component design guidelines](component-design-guidelines.md) provide guidance for authoring F# components, such as libraries.</span></span>
