---
title: 非同步工作流程
description: '深入瞭解 F # 程式設計語言的支援，以便以非同步方式執行計算，而不需封鎖執行其他工作。'
ms.date: 05/16/2016
ms.openlocfilehash: 3bc24639b329401a8f944488e974f0739d4680df
ms.sourcegitcommit: c37e8d4642fef647ebab0e1c618ecc29ddfe2a0f
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/06/2020
ms.locfileid: "87855461"
---
# <a name="asynchronous-workflows"></a><span data-ttu-id="317ad-103">非同步工作流程</span><span class="sxs-lookup"><span data-stu-id="317ad-103">Asynchronous workflows</span></span>

<span data-ttu-id="317ad-104">本文說明 F # 中以非同步方式執行計算的支援，也就是不會封鎖其他工作的執行。</span><span class="sxs-lookup"><span data-stu-id="317ad-104">This article describes support in F# for performing computations asynchronously, that is, without blocking execution of other work.</span></span> <span data-ttu-id="317ad-105">例如，當應用程式執行其他工作時，可以使用非同步計算來撰寫應用程式，使其具有可回應使用者的 Ui。</span><span class="sxs-lookup"><span data-stu-id="317ad-105">For example, asynchronous computations can be used to write applications that have UIs that remain responsive to users as the application performs other work.</span></span>

> [!NOTE]
> <span data-ttu-id="317ad-106">F # 的 docs.microsoft.com API 參考不完整。</span><span class="sxs-lookup"><span data-stu-id="317ad-106">The docs.microsoft.com API reference for F# is not complete.</span></span> <span data-ttu-id="317ad-107">如果您遇到任何中斷的連結，請改為參考[F # 核心程式庫檔](https://fsharp.github.io/fsharp-core-docs/)。</span><span class="sxs-lookup"><span data-stu-id="317ad-107">If you encounter any broken links, reference [F# Core Library Documentation](https://fsharp.github.io/fsharp-core-docs/) instead.</span></span>

## <a name="syntax"></a><span data-ttu-id="317ad-108">語法</span><span class="sxs-lookup"><span data-stu-id="317ad-108">Syntax</span></span>

```fsharp
async { expression }
```

## <a name="remarks"></a><span data-ttu-id="317ad-109">備註</span><span class="sxs-lookup"><span data-stu-id="317ad-109">Remarks</span></span>

<span data-ttu-id="317ad-110">在先前的語法中，所代表的計算 `expression` 會設定為以非同步方式執行，也就是在執行非同步睡眠作業、i/o 和其他非同步作業時，不會封鎖目前的計算執行緒。</span><span class="sxs-lookup"><span data-stu-id="317ad-110">In the previous syntax, the computation represented by `expression` is set up to run asynchronously, that is, without blocking the current computation thread when asynchronous sleep operations, I/O, and other asynchronous operations are performed.</span></span> <span data-ttu-id="317ad-111">非同步計算通常會在背景執行緒上啟動，同時繼續在目前的執行緒上執行。</span><span class="sxs-lookup"><span data-stu-id="317ad-111">Asynchronous computations are often started on a background thread while execution continues on the current thread.</span></span> <span data-ttu-id="317ad-112">運算式的類型是 `Async<'T>` ，其中 `'T` 是使用關鍵字時，運算式所傳回的類型 `return` 。</span><span class="sxs-lookup"><span data-stu-id="317ad-112">The type of the expression is `Async<'T>`, where `'T` is the type returned by the expression when the `return` keyword is used.</span></span> <span data-ttu-id="317ad-113">這類運算式中的程式碼稱為*非同步區塊*或*非同步區塊*。</span><span class="sxs-lookup"><span data-stu-id="317ad-113">The code in such an expression is referred to as an *asynchronous block*, or *async block*.</span></span>

<span data-ttu-id="317ad-114">有各種不同的非同步程式設計方式，而類別則 [`Async`](https://msdn.microsoft.com/library/03eb4d12-a01a-4565-a077-5e83f17cf6f7) 提供支援數種案例的方法。</span><span class="sxs-lookup"><span data-stu-id="317ad-114">There are a variety of ways of programming asynchronously, and the [`Async`](https://msdn.microsoft.com/library/03eb4d12-a01a-4565-a077-5e83f17cf6f7) class provides methods that support several scenarios.</span></span> <span data-ttu-id="317ad-115">一般的方法是建立 `Async` 物件，以代表您想要以非同步方式執行的計算或計算，然後使用其中一個觸發函數來啟動這些計算。</span><span class="sxs-lookup"><span data-stu-id="317ad-115">The general approach is to create `Async` objects that represent the computation or computations that you want to run asynchronously, and then start these computations by using one of the triggering functions.</span></span> <span data-ttu-id="317ad-116">各種觸發函式提供不同方式來執行非同步計算，而您使用哪一個方法取決於您要使用目前的執行緒、背景執行緒或 .NET Framework 工作物件，以及在計算完成時是否應該執行接續函數。</span><span class="sxs-lookup"><span data-stu-id="317ad-116">The various triggering functions provide different ways of running asynchronous computations, and which one you use depends on whether you want to use the current thread, a background thread, or a .NET Framework task object, and whether there are continuation functions that should run when the computation finishes.</span></span> <span data-ttu-id="317ad-117">例如，若要在目前的執行緒上啟動非同步計算，您可以使用 [`Async.StartImmediate`](https://msdn.microsoft.com/library/2f71d1cc-187f-48cf-ac66-e7fda41c46e3) 。</span><span class="sxs-lookup"><span data-stu-id="317ad-117">For example, to start an asynchronous computation on the current thread, you can use [`Async.StartImmediate`](https://msdn.microsoft.com/library/2f71d1cc-187f-48cf-ac66-e7fda41c46e3).</span></span> <span data-ttu-id="317ad-118">當您從 UI 執行緒啟動非同步計算時，不會封鎖處理使用者動作（例如按鍵和滑鼠活動）的主要事件迴圈，讓您的應用程式保持回應。</span><span class="sxs-lookup"><span data-stu-id="317ad-118">When you start an asynchronous computation from the UI thread, you do not block the main event loop that processes user actions such as keystrokes and mouse activity, so your application remains responsive.</span></span>

## <a name="asynchronous-binding-by-using-let"></a><span data-ttu-id="317ad-119">使用 let 的非同步綁定</span><span class="sxs-lookup"><span data-stu-id="317ad-119">Asynchronous Binding by Using let!</span></span>

<span data-ttu-id="317ad-120">在非同步工作流程中，某些運算式和作業是同步的，有些則是設計來以非同步方式傳回結果的較長計算。</span><span class="sxs-lookup"><span data-stu-id="317ad-120">In an asynchronous workflow, some expressions and operations are synchronous, and some are longer computations that are designed to return a result asynchronously.</span></span> <span data-ttu-id="317ad-121">當您以非同步方式呼叫方法，而不是一般的系結時 `let` ，您會使用 `let!` 。</span><span class="sxs-lookup"><span data-stu-id="317ad-121">When you call a method asynchronously, instead of an ordinary `let` binding, you use `let!`.</span></span> <span data-ttu-id="317ad-122">的作用 `let!` 是在執行計算時，讓其他計算或執行緒繼續執行。</span><span class="sxs-lookup"><span data-stu-id="317ad-122">The effect of `let!` is to enable execution to continue on other computations or threads as the computation is being performed.</span></span> <span data-ttu-id="317ad-123">在系結的右側傳回之後 `let!` ，非同步工作流程的其餘部分會繼續執行。</span><span class="sxs-lookup"><span data-stu-id="317ad-123">After the right side of the `let!` binding returns, the rest of the asynchronous workflow resumes execution.</span></span>

<span data-ttu-id="317ad-124">下列程式碼顯示和之間的 `let` 差異 `let!` 。</span><span class="sxs-lookup"><span data-stu-id="317ad-124">The following code shows the difference between `let` and `let!`.</span></span> <span data-ttu-id="317ad-125">使用的程式程式碼 `let` 只會建立異步計算，做為您稍後可以使用來執行的物件，例如 `Async.StartImmediate` 或 [`Async.RunSynchronously`](https://msdn.microsoft.com/library/0a6663a9-50f2-4d38-8bf3-cefd1a51fd6b) 。</span><span class="sxs-lookup"><span data-stu-id="317ad-125">The line of code that uses `let` just creates an asynchronous computation as an object that you can run later by using, for example, `Async.StartImmediate` or [`Async.RunSynchronously`](https://msdn.microsoft.com/library/0a6663a9-50f2-4d38-8bf3-cefd1a51fd6b).</span></span> <span data-ttu-id="317ad-126">使用的程式程式碼會 `let!` 啟動計算，然後執行緒會暫停直到結果可供使用為止，此時就會繼續執行。</span><span class="sxs-lookup"><span data-stu-id="317ad-126">The line of code that uses `let!` starts the computation, and then the thread is suspended until the result is available, at which point execution continues.</span></span>

```fsharp
// let just stores the result as an asynchronous operation.
let (result1 : Async<byte[]>) = stream.AsyncRead(bufferSize)
// let! completes the asynchronous operation and returns the data.
let! (result2 : byte[])  = stream.AsyncRead(bufferSize)
```

<span data-ttu-id="317ad-127">除了之外 `let!` ，您還可以使用 `use!` 來執行非同步系結。</span><span class="sxs-lookup"><span data-stu-id="317ad-127">In addition to `let!`, you can use `use!` to perform asynchronous bindings.</span></span> <span data-ttu-id="317ad-128">和之間的差異與 `let!` `use!` 和之間的差異相同 `let` `use` 。</span><span class="sxs-lookup"><span data-stu-id="317ad-128">The difference between `let!` and `use!` is the same as the difference between `let` and `use`.</span></span> <span data-ttu-id="317ad-129">若是 `use!` ，物件會在目前範圍結束時處置。</span><span class="sxs-lookup"><span data-stu-id="317ad-129">For `use!`, the object is disposed of at the close of the current scope.</span></span> <span data-ttu-id="317ad-130">請注意，在目前的 F # 語言版本中，不 `use!` 允許將值初始化為 null，即使這樣也一樣 `use` 。</span><span class="sxs-lookup"><span data-stu-id="317ad-130">Note that in the current release of the F# language, `use!` does not allow a value to be initialized to null, even though `use` does.</span></span>

## <a name="asynchronous-primitives"></a><span data-ttu-id="317ad-131">非同步基本專案</span><span class="sxs-lookup"><span data-stu-id="317ad-131">Asynchronous Primitives</span></span>

<span data-ttu-id="317ad-132">執行單一非同步工作並傳回結果的方法稱為「*非同步基本*」，而且這些都是特別設計來搭配使用 `let!` 。</span><span class="sxs-lookup"><span data-stu-id="317ad-132">A method that performs a single asynchronous task and returns the result is called an *asynchronous primitive*, and these are designed specifically for use with `let!`.</span></span> <span data-ttu-id="317ad-133">F # 核心程式庫中定義了數個非同步基本類型。</span><span class="sxs-lookup"><span data-stu-id="317ad-133">Several asynchronous primitives are defined in the F# core library.</span></span> <span data-ttu-id="317ad-134">這兩種 Web 應用程式的方法都是在模組中定義 [`Microsoft.FSharp.Control.WebExtensions`](https://msdn.microsoft.com/library/95ef17bc-ee3f-44ba-8a11-c90fcf4cf003) ： [`WebRequest.AsyncGetResponse`](https://msdn.microsoft.com/library/09a60c31-e6e2-4b5c-ad23-92a86e50060c) 和 [`WebClient.AsyncDownloadString`](https://msdn.microsoft.com/library/8a85a9b7-f712-4cac-a0ce-0a797f8ea32a) 。</span><span class="sxs-lookup"><span data-stu-id="317ad-134">Two such methods for Web applications are defined in the module [`Microsoft.FSharp.Control.WebExtensions`](https://msdn.microsoft.com/library/95ef17bc-ee3f-44ba-8a11-c90fcf4cf003): [`WebRequest.AsyncGetResponse`](https://msdn.microsoft.com/library/09a60c31-e6e2-4b5c-ad23-92a86e50060c) and [`WebClient.AsyncDownloadString`](https://msdn.microsoft.com/library/8a85a9b7-f712-4cac-a0ce-0a797f8ea32a).</span></span> <span data-ttu-id="317ad-135">這兩個原始物件會在指定 URL 的情況下，從網頁下載資料。</span><span class="sxs-lookup"><span data-stu-id="317ad-135">Both primitives download data from a Web page, given a URL.</span></span> <span data-ttu-id="317ad-136">`AsyncGetResponse`產生 `System.Net.WebResponse` 物件，並 `AsyncDownloadString` 產生代表網頁 HTML 的字串。</span><span class="sxs-lookup"><span data-stu-id="317ad-136">`AsyncGetResponse` produces a `System.Net.WebResponse` object, and `AsyncDownloadString` produces a string that represents the HTML for a Web page.</span></span>

<span data-ttu-id="317ad-137">模組中包含數個非同步 i/o 作業的基本專案 [`Microsoft.FSharp.Control.CommonExtensions`](https://msdn.microsoft.com/library/2edb67cb-6814-4a30-849f-b6dbdd042396) 。</span><span class="sxs-lookup"><span data-stu-id="317ad-137">Several primitives for asynchronous I/O operations are included in the [`Microsoft.FSharp.Control.CommonExtensions`](https://msdn.microsoft.com/library/2edb67cb-6814-4a30-849f-b6dbdd042396) module.</span></span> <span data-ttu-id="317ad-138">這些類別的擴充方法 `System.IO.Stream` 為 [`Stream.AsyncRead`](https://msdn.microsoft.com/library/85698aaa-bdda-47e6-abed-3730f59fda5e) 和 [`Stream.AsyncWrite`](https://msdn.microsoft.com/library/1b0a2751-e42a-47e1-bd27-020224adc618) 。</span><span class="sxs-lookup"><span data-stu-id="317ad-138">These extension methods of the `System.IO.Stream` class are [`Stream.AsyncRead`](https://msdn.microsoft.com/library/85698aaa-bdda-47e6-abed-3730f59fda5e) and [`Stream.AsyncWrite`](https://msdn.microsoft.com/library/1b0a2751-e42a-47e1-bd27-020224adc618).</span></span>

<span data-ttu-id="317ad-139">您也可以藉由定義函式，其完整主體會包含在非同步區塊中，來撰寫您自己的非同步基本專案。</span><span class="sxs-lookup"><span data-stu-id="317ad-139">You can also write your own asynchronous primitives by defining a function whose complete body is enclosed in an async block.</span></span>

<span data-ttu-id="317ad-140">若要在使用 F # 非同步程式設計模型之其他非同步模型的 .NET Framework 中使用非同步方法，您可以建立可傳回 F # 物件的函式 `Async` 。</span><span class="sxs-lookup"><span data-stu-id="317ad-140">To use asynchronous methods in the .NET Framework that are designed for other asynchronous models with the F# asynchronous programming model, you create a function that returns an F# `Async` object.</span></span> <span data-ttu-id="317ad-141">F # 程式庫具有可讓您輕鬆執行此動作的函式。</span><span class="sxs-lookup"><span data-stu-id="317ad-141">The F# library has functions that make this easy to do.</span></span>

<span data-ttu-id="317ad-142">這裡包含一個使用非同步工作流程的範例：在檔中，[非同步類別](https://msdn.microsoft.com/library/03eb4d12-a01a-4565-a077-5e83f17cf6f7)的方法有許多其他功能。</span><span class="sxs-lookup"><span data-stu-id="317ad-142">One example of using asynchronous workflows is included here; there are many others in the documentation for the methods of the [Async class](https://msdn.microsoft.com/library/03eb4d12-a01a-4565-a077-5e83f17cf6f7).</span></span>

<span data-ttu-id="317ad-143">這個範例示範如何使用非同步工作流程，以平行方式執行計算。</span><span class="sxs-lookup"><span data-stu-id="317ad-143">This example shows how to use asynchronous workflows to perform computations in parallel.</span></span>

<span data-ttu-id="317ad-144">在下列程式碼範例中，函式會 `fetchAsync` 取得 Web 要求所傳回的 HTML 文字。</span><span class="sxs-lookup"><span data-stu-id="317ad-144">In the following code example, a function `fetchAsync` gets the HTML text returned from a Web request.</span></span> <span data-ttu-id="317ad-145">函 `fetchAsync` 式包含非同步程式碼區塊。</span><span class="sxs-lookup"><span data-stu-id="317ad-145">The `fetchAsync` function contains an asynchronous block of code.</span></span> <span data-ttu-id="317ad-146">當對非同步基本物件的結果進行系結時，在此情況下 [`AsyncDownloadString`](https://msdn.microsoft.com/library/8a85a9b7-f712-4cac-a0ce-0a797f8ea32a) ，請讓！</span><span class="sxs-lookup"><span data-stu-id="317ad-146">When a binding is made to the result of an asynchronous primitive, in this case [`AsyncDownloadString`](https://msdn.microsoft.com/library/8a85a9b7-f712-4cac-a0ce-0a797f8ea32a), let!</span></span> <span data-ttu-id="317ad-147">會使用，而不是 let。</span><span class="sxs-lookup"><span data-stu-id="317ad-147">is used instead of let.</span></span>

<span data-ttu-id="317ad-148">您可以使用函 [`Async.RunSynchronously`](https://msdn.microsoft.com/library/0a6663a9-50f2-4d38-8bf3-cefd1a51fd6b) 式來執行非同步作業，並等候其結果。</span><span class="sxs-lookup"><span data-stu-id="317ad-148">You use the function [`Async.RunSynchronously`](https://msdn.microsoft.com/library/0a6663a9-50f2-4d38-8bf3-cefd1a51fd6b) to execute an asynchronous operation and wait for its result.</span></span> <span data-ttu-id="317ad-149">例如，您可以搭配函式一起使用函式，以平行方式執行多個非同步作業 [`Async.Parallel`](https://msdn.microsoft.com/library/aa9b0355-2d55-4858-b943-cbe428de9dc4) `Async.RunSynchronously` 。</span><span class="sxs-lookup"><span data-stu-id="317ad-149">As an example, you can execute multiple asynchronous operations in parallel by using the [`Async.Parallel`](https://msdn.microsoft.com/library/aa9b0355-2d55-4858-b943-cbe428de9dc4) function together with the `Async.RunSynchronously` function.</span></span> <span data-ttu-id="317ad-150">函式 `Async.Parallel` 會取得物件的清單 `Async` 、設定每個工作物件的程式碼 `Async` 以平行方式執行，並傳回 `Async` 代表平行計算的物件。</span><span class="sxs-lookup"><span data-stu-id="317ad-150">The `Async.Parallel` function takes a list of the `Async` objects, sets up the code for each `Async` task object to run in parallel, and returns an `Async` object that represents the parallel computation.</span></span> <span data-ttu-id="317ad-151">就像單一作業一樣，您可以呼叫 `Async.RunSynchronously` 來開始執行。</span><span class="sxs-lookup"><span data-stu-id="317ad-151">Just as for a single operation, you call `Async.RunSynchronously` to start the execution.</span></span>

<span data-ttu-id="317ad-152">函式 `runAll` 會平行啟動三個非同步工作流程，並等待它們全部完成。</span><span class="sxs-lookup"><span data-stu-id="317ad-152">The `runAll` function launches three asynchronous workflows in parallel and waits until they have all completed.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-2/snippet8003.fs)]

## <a name="see-also"></a><span data-ttu-id="317ad-153">另請參閱</span><span class="sxs-lookup"><span data-stu-id="317ad-153">See also</span></span>

- [<span data-ttu-id="317ad-154">F # 語言參考</span><span class="sxs-lookup"><span data-stu-id="317ad-154">F# Language Reference</span></span>](index.md)
- [<span data-ttu-id="317ad-155">計算運算式</span><span class="sxs-lookup"><span data-stu-id="317ad-155">Computation Expressions</span></span>](computation-expressions.md)
- [<span data-ttu-id="317ad-156">控制項 Async 類別</span><span class="sxs-lookup"><span data-stu-id="317ad-156">Control.Async Class</span></span>](https://msdn.microsoft.com/visualfsharpdocs/conceptual/control.async-class-%5bfsharp%5d)
