---
title: 可靠性最佳作法
description: 請參閱 .NET 主機型伺服器應用程式（例如 SQL Server）中可靠性的最佳做法。 防止它們流失資源或關閉。
ms.date: 03/30/2017
helpviewer_keywords:
- marking locks
- rebooting databases
- denial of service attacks
- back-out code
- SQL Server [.NET Framework], reliability
- synchronization, reliability
- single-threaded COM components
- slow leaks
- suspending threads
- asynchronous exception handling
- leaked resources [.NET Framework]
- unmanaged memory
- memory, reliability
- threading [.NET Framework], reliability
- process-wide domain shared states
- shared states
- SafeHandle class, reliability
- reliability contracts [.NET Framework]
- cleanup operations
- constrained execution regions
- CERs
- finalizers, reliability
- reliability [.NET Framework]
- blocks, reliability
- finally clauses
- cross-application domain shared states
- catch blocks
- identifying locks
- writing reliable code
- impersonation
- GC.KeepAlive method
- managed threading
- locks, reliability
- STA-dependent features
- fibers
ms.assetid: cf624c1f-c160-46a1-bb2b-213587688da7
ms.openlocfilehash: 134b71153f95dffd4525f307d291ce4389e0ce60
ms.sourcegitcommit: cf5a800a33de64d0aad6d115ffcc935f32375164
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 07/20/2020
ms.locfileid: "86474237"
---
# <a name="reliability-best-practices"></a><span data-ttu-id="05703-104">可靠性最佳作法</span><span class="sxs-lookup"><span data-stu-id="05703-104">Reliability Best Practices</span></span>

<span data-ttu-id="05703-105">下列可靠性規則會導向至 SQL Server；不過，它們也會套用至任何主機型伺服器應用程式。</span><span class="sxs-lookup"><span data-stu-id="05703-105">The following reliability rules are oriented to SQL Server; however, they also apply to any host-based server application.</span></span> <span data-ttu-id="05703-106">SQL Server 這類伺服器絕對不能流失資源，也不能關閉。</span><span class="sxs-lookup"><span data-stu-id="05703-106">It is extremely important that servers such as SQL Server not leak resources and not be brought down.</span></span>  <span data-ttu-id="05703-107">不過，撰寫每個改變物件狀態之方法的退出程式碼，無法完成該作業。</span><span class="sxs-lookup"><span data-stu-id="05703-107">However, that cannot be done by writing back-out code for every method that alters an object’s state.</span></span>  <span data-ttu-id="05703-108">目標不是撰寫 100% 可靠的 Managed 程式碼，來復原每個具有退出程式碼的位置中的任何錯誤。</span><span class="sxs-lookup"><span data-stu-id="05703-108">The goal is not to write 100 percent reliable managed code that will recover from any errors in every location with back-out code.</span></span>  <span data-ttu-id="05703-109">這會是成功機率很低的煩人工作。</span><span class="sxs-lookup"><span data-stu-id="05703-109">That would be a daunting task with little chance of success.</span></span>  <span data-ttu-id="05703-110">Common Language Runtime (CLR) 無法輕易地強烈保證 Managed 程式碼可撰寫可行的完美程式碼。</span><span class="sxs-lookup"><span data-stu-id="05703-110">The common language runtime (CLR) cannot easily provide strong enough guarantees to managed code to make writing perfect code feasible.</span></span>  <span data-ttu-id="05703-111">請注意，與 ASP.NET 不同，SQL Server 只會使用一個無法回收的處理序，而不需要關閉資料庫一段無法接受的時間。</span><span class="sxs-lookup"><span data-stu-id="05703-111">Note that unlike ASP.NET, SQL Server uses only one process that cannot be recycled without taking a database down for an unacceptably long time.</span></span>

<span data-ttu-id="05703-112">有了這些較弱的保證並執行單一處理序之後，必要時，可靠性是以終止中執行緒或回收中應用程式定義域為基礎，並採取預防措施來確保作業系統資源，例如控制代碼或記憶體未流失。</span><span class="sxs-lookup"><span data-stu-id="05703-112">With these weaker guarantees and running in a single process, reliability is based on terminating threads or recycling application domains when necessary and taking precautions to ensure operating system resources such as handles or memory are not leaked.</span></span>  <span data-ttu-id="05703-113">即使使用這個較簡單的可靠性條件約束，還是會有明顯的可靠性需求：</span><span class="sxs-lookup"><span data-stu-id="05703-113">Even with this simpler reliability constraint, there is still a significant reliability requirement:</span></span>

- <span data-ttu-id="05703-114">絕不會流失作業系統資源。</span><span class="sxs-lookup"><span data-stu-id="05703-114">Never leak operating system resources.</span></span>

- <span data-ttu-id="05703-115">識別所有形式的 CLR 中的所有 Managed 鎖定。</span><span class="sxs-lookup"><span data-stu-id="05703-115">Identify all managed locks in all forms to the CLR.</span></span>

- <span data-ttu-id="05703-116">永遠不會中斷跨應用程式定義域共用狀態，並允許 <xref:System.AppDomain> 回收順暢地運作。</span><span class="sxs-lookup"><span data-stu-id="05703-116">Never break cross-application domain shared state, allowing <xref:System.AppDomain> recycling to function smoothly.</span></span>

<span data-ttu-id="05703-117">雖然理論上可能會撰寫 Managed 程式碼來處理 <xref:System.Threading.ThreadAbortException>、<xref:System.StackOverflowException> 和 <xref:System.OutOfMemoryException> 例外狀況，但是開發人員必須撰寫整個應用程式的這類強固程式碼十分不合理。</span><span class="sxs-lookup"><span data-stu-id="05703-117">Although it is theoretically possible to write managed code to handle <xref:System.Threading.ThreadAbortException>, <xref:System.StackOverflowException>, and <xref:System.OutOfMemoryException> exceptions, expecting developers to write such robust code throughout an entire application is unreasonable.</span></span>  <span data-ttu-id="05703-118">基於這個原因，頻外例外狀況會導致終止執行中執行緒；如果已終止的執行緒處於編輯中共用狀態 (可由執行緒是否持有鎖定來判斷)，則會卸載 <xref:System.AppDomain>。</span><span class="sxs-lookup"><span data-stu-id="05703-118">For that reason, out-of-band exceptions result in the executing thread being terminated; and if the terminated thread was editing shared state, which can be determined by whether the thread holds a lock, then the <xref:System.AppDomain> is unloaded.</span></span>  <span data-ttu-id="05703-119">終止正在編輯共用狀態的方法時，狀態會損毀，因為無法撰寫共用狀態更新的可靠退出程式碼。</span><span class="sxs-lookup"><span data-stu-id="05703-119">When a method that is editing shared state is terminated, the state will be corrupt because it is not possible to write reliable back-out code for updates to shared state.</span></span>

<span data-ttu-id="05703-120">在 .NET Framework 2.0 版中，唯一需要可靠性的主機是 SQL Server。</span><span class="sxs-lookup"><span data-stu-id="05703-120">In the .NET Framework version 2.0, the only host that requires reliability is SQL Server.</span></span>  <span data-ttu-id="05703-121">如果將在 SQL Server 上執行您的組件，則應該針對該組件的每個部分執行可靠性工作，即使具有已在資料庫中執行時停用的特定功能也是一樣。</span><span class="sxs-lookup"><span data-stu-id="05703-121">If your assembly will be run on SQL Server you should do the reliability work for every part of that assembly, even if there are specific features that are disabled when running in the database.</span></span>  <span data-ttu-id="05703-122">這是必要的，因為程式碼分析引擎會檢查組件層級的程式碼，而且無法區分已停用的程式碼。</span><span class="sxs-lookup"><span data-stu-id="05703-122">This is required because the code analysis engine examines code at the assembly level and cannot differentiate disabled code.</span></span> <span data-ttu-id="05703-123">另一個 SQL Server 程式設計考量是 SQL Server 在一個處理序中執行所有項目，而 <xref:System.AppDomain> 回收用於清除所有資源，例如記憶體和作業系統控制代碼。</span><span class="sxs-lookup"><span data-stu-id="05703-123">Another SQL Server programming consideration is that SQL Server runs everything in one process, and <xref:System.AppDomain> recycling is used for cleaning up all resources such as memory and operating system handles.</span></span>

<span data-ttu-id="05703-124">您無法取決於完成項或解構函式或是退出程式碼的 `try/finally` 區塊。</span><span class="sxs-lookup"><span data-stu-id="05703-124">You cannot depend on finalizers or destructors or `try/finally` blocks for back-out code.</span></span> <span data-ttu-id="05703-125">它們可能是已中斷或未呼叫。</span><span class="sxs-lookup"><span data-stu-id="05703-125">They might be interrupted or not called.</span></span>

<span data-ttu-id="05703-126">非同步例外狀況可能會在非預期的位置擲回，可能是每個電腦指令：<xref:System.Threading.ThreadAbortException>、<xref:System.StackOverflowException> 和 <xref:System.OutOfMemoryException>。</span><span class="sxs-lookup"><span data-stu-id="05703-126">Asynchronous exceptions can be thrown in unexpected locations, possibly every machine instruction: <xref:System.Threading.ThreadAbortException>, <xref:System.StackOverflowException>, and <xref:System.OutOfMemoryException>.</span></span>

<span data-ttu-id="05703-127">Managed 執行緒不一定是 SQL 中的 Win32 執行緒；它們可能是 Fiber。</span><span class="sxs-lookup"><span data-stu-id="05703-127">Managed threads are not necessarily Win32 threads in SQL; they might be fibers.</span></span>

<span data-ttu-id="05703-128">整個處理序或跨應用程式定義域可變動共用狀態很難安全地進行改變，應該盡可能避免。</span><span class="sxs-lookup"><span data-stu-id="05703-128">Process-wide or cross-application domain mutable shared state is extremely difficult to alter safely and should be avoided whenever possible.</span></span>

<span data-ttu-id="05703-129">在 SQL Server 中，經常發生記憶體不足的情況。</span><span class="sxs-lookup"><span data-stu-id="05703-129">Out-of-memory conditions are not rare in SQL Server.</span></span>

<span data-ttu-id="05703-130">如果 SQL Server 中所裝載的程式庫未正確更新其共用狀態，則除非已重新啟動資料庫，否則極有可能不會復原程式碼。</span><span class="sxs-lookup"><span data-stu-id="05703-130">If libraries hosted in SQL Server do not correctly update their shared state, there is a high probability that the code will not recover until the database has been restarted.</span></span>  <span data-ttu-id="05703-131">此外，在某些極端的情況下，這可能會導致 SQL Server 處理序失敗，因而重新啟動資料庫。</span><span class="sxs-lookup"><span data-stu-id="05703-131">Additionally, in some extreme cases, it is possible this might cause the SQL Server process to fail, causing the database to reboot.</span></span>  <span data-ttu-id="05703-132">重新啟動資料庫可以關閉網站或影響公司作業，進而損及可用性。</span><span class="sxs-lookup"><span data-stu-id="05703-132">Rebooting the database can take down a Web site or affect company operations, hurting availability.</span></span>  <span data-ttu-id="05703-133">作業系統資源 (例如記憶體或控制代碼) 的緩慢流失可能會讓伺服器最後無法配置控制代碼並且無法進行復原，或者伺服器的效能可能會下降並降低客戶的應用程式可用性。</span><span class="sxs-lookup"><span data-stu-id="05703-133">A slow leak of operating system resources such as memory or handles may cause the server to eventually fail allocating handles with no possibility of recovery, or potentially the server may slowly degrade in performance and reduces a customer’s application availability.</span></span>  <span data-ttu-id="05703-134">很明顯，我們會想要避免這些狀況。</span><span class="sxs-lookup"><span data-stu-id="05703-134">Clearly we want to avoid these scenarios.</span></span>

## <a name="best-practice-rules"></a><span data-ttu-id="05703-135">最佳做法規則</span><span class="sxs-lookup"><span data-stu-id="05703-135">Best practice rules</span></span>

<span data-ttu-id="05703-136">簡介著重於必須擷取在伺服器中執行之 Managed 程式碼的程式碼檢閱，來增加架構的穩定性和可靠性。</span><span class="sxs-lookup"><span data-stu-id="05703-136">The introduction focused on what the code review for the managed code that runs in the server would have to catch to increase the stability and reliability of the framework.</span></span> <span data-ttu-id="05703-137">所有這些檢查一般都是不錯的做法，而且在伺服器上絕對必須進行。</span><span class="sxs-lookup"><span data-stu-id="05703-137">All these checks are good practice in general and an absolute must on the server.</span></span>

<span data-ttu-id="05703-138">面對死結或資源條件約束時，SQL Server 將中止執行緒或卸除 <xref:System.AppDomain>。</span><span class="sxs-lookup"><span data-stu-id="05703-138">In the face of a dead lock or resource constraint, SQL Server will abort a thread or tear down an <xref:System.AppDomain>.</span></span>  <span data-ttu-id="05703-139">發生這種情況時，保證執行限制的執行區域 (CER) 中的退出程式碼。</span><span class="sxs-lookup"><span data-stu-id="05703-139">When this happens, only back-out code in a constrained execution region (CER) is guaranteed to be run.</span></span>

### <a name="use-safehandle-to-avoid-resource-leaks"></a><span data-ttu-id="05703-140">使用 SafeHandle 避免資源流失</span><span class="sxs-lookup"><span data-stu-id="05703-140">Use SafeHandle to avoid resource leaks</span></span>

<span data-ttu-id="05703-141">如果是 <xref:System.AppDomain> 卸載，則無法取決於所執行的 `finally` 區塊或完成項，因此一定要透過 <xref:System.Runtime.InteropServices.SafeHandle> 類別來擷取所有作業系統資源存取，而不是 <xref:System.IntPtr>、<xref:System.Runtime.InteropServices.HandleRef> 或類似的類別。</span><span class="sxs-lookup"><span data-stu-id="05703-141">In the case of an <xref:System.AppDomain> unload, you cannot depend on `finally` blocks or finalizers being executed, so it is important to abstract all operating system resource access through the <xref:System.Runtime.InteropServices.SafeHandle> class rather than <xref:System.IntPtr>, <xref:System.Runtime.InteropServices.HandleRef>, or similar classes.</span></span> <span data-ttu-id="05703-142">這甚至可讓 CLR 追蹤和關閉您在 <xref:System.AppDomain> 終止程式碼案例中使用的控制代碼。</span><span class="sxs-lookup"><span data-stu-id="05703-142">This allows the CLR to track and close the handles you use even in the <xref:System.AppDomain> tear-down case.</span></span>  <span data-ttu-id="05703-143"><xref:System.Runtime.InteropServices.SafeHandle> 將使用 CLR 一律會執行的重要完成項。</span><span class="sxs-lookup"><span data-stu-id="05703-143"><xref:System.Runtime.InteropServices.SafeHandle> will be using a critical finalizer which the CLR will always run.</span></span>

<span data-ttu-id="05703-144">作業系統控制代碼除非予以釋放，否則在建立時即會儲存在安全控制代碼中。</span><span class="sxs-lookup"><span data-stu-id="05703-144">The operating system handle is stored in the safe handle from the moment it is created until the moment it is released.</span></span>  <span data-ttu-id="05703-145">沒有時間範圍，而在此時間範圍可能發生遺漏控制代碼的 <xref:System.Threading.ThreadAbortException>。</span><span class="sxs-lookup"><span data-stu-id="05703-145">There is no window during which a <xref:System.Threading.ThreadAbortException> can occur to leak a handle.</span></span>  <span data-ttu-id="05703-146">此外，平台叫用也會計算控制代碼的參考計數，以緊密追蹤控制代碼的存留期，防止 `Dispose` 與目前使用控制代碼之方法間的競爭條件安全性問題。</span><span class="sxs-lookup"><span data-stu-id="05703-146">Additionally, platform invoke will reference-count the handle, which allows close tracking of the lifetime of the handle, preventing a security issue with a race condition between `Dispose` and a method that is currently using the handle.</span></span>

<span data-ttu-id="05703-147">目前的完成項只能清除作業系統控制代碼的大部分類別都將不再需要完成項。</span><span class="sxs-lookup"><span data-stu-id="05703-147">Most classes that currently have a finalizer to simply clean up an operating system handle will not need the finalizer anymore.</span></span> <span data-ttu-id="05703-148">相反地，完成項會在 <xref:System.Runtime.InteropServices.SafeHandle> 衍生類別上。</span><span class="sxs-lookup"><span data-stu-id="05703-148">Instead, the finalizer will be on the <xref:System.Runtime.InteropServices.SafeHandle> derived class.</span></span>

<span data-ttu-id="05703-149">請注意，<xref:System.Runtime.InteropServices.SafeHandle> 不是 <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> 的取代項目。</span><span class="sxs-lookup"><span data-stu-id="05703-149">Note that <xref:System.Runtime.InteropServices.SafeHandle> is not a replacement for <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>.</span></span>  <span data-ttu-id="05703-150">仍然可能具有資源爭用和效能優點，可明確地處置作業系統資源。</span><span class="sxs-lookup"><span data-stu-id="05703-150">There are still potential resource contention and performance advantages to explicitly dispose operating system resources.</span></span>  <span data-ttu-id="05703-151">您只需要了解，明確處置資源的 `finally` 區塊可能未執行，無法完成。</span><span class="sxs-lookup"><span data-stu-id="05703-151">Just realize that `finally` blocks that do explicitly dispose of resources may not execute to completion.</span></span>

<span data-ttu-id="05703-152"><xref:System.Runtime.InteropServices.SafeHandle> 可讓您實作自己的 <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> 方法，以執行控制代碼釋放工作，例如將狀態傳遞至作業系統控制代碼釋放常式，或釋放迴圈中的一組控制代碼。</span><span class="sxs-lookup"><span data-stu-id="05703-152"><xref:System.Runtime.InteropServices.SafeHandle> allows you to implement your own <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method that performs the work to free the handle, such as passing state to an operating system handle freeing routine or freeing a set of handles in a loop.</span></span>  <span data-ttu-id="05703-153">CLR 保證會執行此方法。</span><span class="sxs-lookup"><span data-stu-id="05703-153">The CLR guarantees that this method is run.</span></span>  <span data-ttu-id="05703-154"><xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> 實作作者必須負責確保在所有情況下釋放控制代碼。</span><span class="sxs-lookup"><span data-stu-id="05703-154">It is the responsibility of the author of the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> implementation to ensure that the handle is released in all circumstances.</span></span> <span data-ttu-id="05703-155">無法這麼做會導致控制代碼流失，這通常會造成與控制代碼建立關聯之原生資源的流失。</span><span class="sxs-lookup"><span data-stu-id="05703-155">Failure to do so will cause the handle to be leaked, which often results in the leakage of native resources associated with the handle.</span></span> <span data-ttu-id="05703-156">因此，請務必建構 <xref:System.Runtime.InteropServices.SafeHandle> 衍生類別，這樣 <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> 實作就不需要配置任何可能無法在叫用期間使用的資源。</span><span class="sxs-lookup"><span data-stu-id="05703-156">Therefore it is critical to structure <xref:System.Runtime.InteropServices.SafeHandle> derived classes such that the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> implementation does not require the allocation of any resources that may not be available at invocation time.</span></span> <span data-ttu-id="05703-157">請注意，允許呼叫在 <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> 實作內失敗的方法，前提是您的程式碼可以處理這類失敗，並且完成合約來釋放原生控制代碼。</span><span class="sxs-lookup"><span data-stu-id="05703-157">Note that it is permissible to call methods that may fail within the implementation of <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> provided that your code can handle such failures and complete the contract to release the native handle.</span></span> <span data-ttu-id="05703-158">為了進行偵錯，如果發生導致無法釋放資源的重大錯誤，則 <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> 的 <xref:System.Boolean> 傳回值可能設定為 `false`。</span><span class="sxs-lookup"><span data-stu-id="05703-158">For debugging purposes, <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> has a <xref:System.Boolean> return value which may be set to `false` if a catastrophic error is encountered which prevents release of the resource.</span></span> <span data-ttu-id="05703-159">這麼做會啟用 [releaseHandleFailed](../debug-trace-profile/releasehandlefailed-mda.md) MDA (啟用時)，協助識別問題。</span><span class="sxs-lookup"><span data-stu-id="05703-159">Doing so will activate the [releaseHandleFailed](../debug-trace-profile/releasehandlefailed-mda.md) MDA, if enabled, to aid in identifying the problem.</span></span> <span data-ttu-id="05703-160">它不會透過任何其他方法影響執行階段；將不會針對相同的資源再次呼叫<xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>，因此控制代碼將流失。</span><span class="sxs-lookup"><span data-stu-id="05703-160">It does not affect the runtime in any other way; <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> will not be called again for the same resource and consequently the handle will be leaked.</span></span>

<span data-ttu-id="05703-161">在特定內容中，不適合使用 <xref:System.Runtime.InteropServices.SafeHandle>。</span><span class="sxs-lookup"><span data-stu-id="05703-161"><xref:System.Runtime.InteropServices.SafeHandle> is not appropriate in certain contexts.</span></span>  <span data-ttu-id="05703-162">因為 <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> 方法可以在 <xref:System.GC> 完成項執行緒上執行，所以任何需要在特定執行緒上釋放的控制代碼不應該包裝在 <xref:System.Runtime.InteropServices.SafeHandle> 中。</span><span class="sxs-lookup"><span data-stu-id="05703-162">Since the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method can be run on a <xref:System.GC> finalizer thread, any handles that are required to be freed on a particular thread should not be wrapped in a <xref:System.Runtime.InteropServices.SafeHandle>.</span></span>

<span data-ttu-id="05703-163">CLR 不需要額外的程式碼就可以清除執行階段可呼叫包裝函式 (RCW)。</span><span class="sxs-lookup"><span data-stu-id="05703-163">Runtime callable wrappers (RCWs) can be cleaned by the CLR without additional code.</span></span>  <span data-ttu-id="05703-164">針對使用平台叫用並將 COM 物件視為 `IUnknown*` 或 <xref:System.IntPtr> 的程式碼，應該重寫程式碼以使用 RCW。</span><span class="sxs-lookup"><span data-stu-id="05703-164">For code that uses platform invoke and treats a COM object as an `IUnknown*` or an <xref:System.IntPtr>, the code should be rewritten to use an RCW.</span></span>  <span data-ttu-id="05703-165"><xref:System.Runtime.InteropServices.SafeHandle> 對此案例而言可能不足，因為可能會將 Unmanaged 發行方法回呼至 Managed 程式碼。</span><span class="sxs-lookup"><span data-stu-id="05703-165"><xref:System.Runtime.InteropServices.SafeHandle> may not be adequate for this scenario due to the possibility of an unmanaged release method calling back into managed code.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="05703-166">程式碼分析規則</span><span class="sxs-lookup"><span data-stu-id="05703-166">Code analysis rule</span></span>

<span data-ttu-id="05703-167">使用 <xref:System.Runtime.InteropServices.SafeHandle> 來封裝作業系統資源。</span><span class="sxs-lookup"><span data-stu-id="05703-167">Use <xref:System.Runtime.InteropServices.SafeHandle> to encapsulate operating system resources.</span></span> <span data-ttu-id="05703-168">請不要使用 <xref:System.Runtime.InteropServices.HandleRef> 或是類型 <xref:System.IntPtr> 的欄位。</span><span class="sxs-lookup"><span data-stu-id="05703-168">Do not use <xref:System.Runtime.InteropServices.HandleRef> or fields of type <xref:System.IntPtr>.</span></span>

### <a name="ensure-finalizers-do-not-have-to-run-to-prevent-leaking-operating-system-resources"></a><span data-ttu-id="05703-169">確保完成項不需要執行，以防止作業系統資源流失</span><span class="sxs-lookup"><span data-stu-id="05703-169">Ensure finalizers do not have to run to prevent leaking operating system resources</span></span>

<span data-ttu-id="05703-170">請小心地檢閱完成項，確保即使它們未執行，重要作業系統資源也不會流失。</span><span class="sxs-lookup"><span data-stu-id="05703-170">Review your finalizers carefully to ensure that even if they do not run, a critical operating system resource is not leaked.</span></span>  <span data-ttu-id="05703-171">與應用程式以穩定狀態執行或 SQL Server 這類伺服器關閉時的一般 <xref:System.AppDomain> 卸載不同，在突然 <xref:System.AppDomain> 卸載期間不會完成物件。</span><span class="sxs-lookup"><span data-stu-id="05703-171">Unlike a normal <xref:System.AppDomain> unload when the application is executing in a steady state or when a server such as SQL Server shuts down, objects are not finalized during an abrupt <xref:System.AppDomain> unload.</span></span>  <span data-ttu-id="05703-172">因為無法保證應用程式正確性，所以請確定資源未在突然卸載時流失，但必須透過未流失資源來維護伺服器完整性。</span><span class="sxs-lookup"><span data-stu-id="05703-172">Ensure resources are not leaked in the case of an abrupt unload, since an application's correctness cannot be guaranteed, but the integrity of the server must be maintained by not leaking resources.</span></span>  <span data-ttu-id="05703-173">使用 <xref:System.Runtime.InteropServices.SafeHandle> 來釋放任何作業系統資源。</span><span class="sxs-lookup"><span data-stu-id="05703-173">Use <xref:System.Runtime.InteropServices.SafeHandle> to free any operating system resources.</span></span>

### <a name="ensure-that-finally-clauses-do-not-have-to-run-to-prevent-leaking-operating-system-resources"></a><span data-ttu-id="05703-174">請確定 finally 子句不需要執行，以防止作業系統資源流失</span><span class="sxs-lookup"><span data-stu-id="05703-174">Ensure that finally clauses do not have to run to prevent leaking operating system resources</span></span>

<span data-ttu-id="05703-175">`finally` 子句不一定會在 CER 外部執行，需要程式庫開發人員不依賴 `finally` 區塊內的程式碼來釋放 Unmanaged 資源。</span><span class="sxs-lookup"><span data-stu-id="05703-175">`finally` clauses are not guaranteed to run outside of CERs, requiring library developers to not rely on code within a `finally` block to free unmanaged resources.</span></span>  <span data-ttu-id="05703-176">使用 <xref:System.Runtime.InteropServices.SafeHandle> 是建議的解決方案。</span><span class="sxs-lookup"><span data-stu-id="05703-176">Using <xref:System.Runtime.InteropServices.SafeHandle> is the recommended solution.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="05703-177">程式碼分析規則</span><span class="sxs-lookup"><span data-stu-id="05703-177">Code analysis rule</span></span>

<span data-ttu-id="05703-178">請使用 <xref:System.Runtime.InteropServices.SafeHandle> 來清除作業系統資源，而非 `Finalize`。</span><span class="sxs-lookup"><span data-stu-id="05703-178">Use <xref:System.Runtime.InteropServices.SafeHandle> for cleaning up operating system resources instead of `Finalize`.</span></span> <span data-ttu-id="05703-179">請不要使用 <xref:System.IntPtr>；請使用 <xref:System.Runtime.InteropServices.SafeHandle> 來封裝資源。</span><span class="sxs-lookup"><span data-stu-id="05703-179">Do not use <xref:System.IntPtr>; use <xref:System.Runtime.InteropServices.SafeHandle> to encapsulate resources.</span></span> <span data-ttu-id="05703-180">如果必須執行 finally 子句，請將它放在 CER 中。</span><span class="sxs-lookup"><span data-stu-id="05703-180">If the finally clause must run, place it in a CER.</span></span>

### <a name="all-locks-should-go-through-existing-managed-locking-code"></a><span data-ttu-id="05703-181">所有鎖定都應該通過現有的受控鎖定程式碼</span><span class="sxs-lookup"><span data-stu-id="05703-181">All locks should go through existing managed locking code</span></span>

<span data-ttu-id="05703-182">CLR 必須知道程式碼何時處於鎖定，才能知道要卸除 <xref:System.AppDomain>，而不只是中止執行緒。</span><span class="sxs-lookup"><span data-stu-id="05703-182">The CLR must know when code is in a lock so that it will know to tear down the <xref:System.AppDomain> rather than just aborting the thread.</span></span>  <span data-ttu-id="05703-183">中止執行緒可能十分危險，因為執行緒所操作的資料可能處於不一致的狀態。</span><span class="sxs-lookup"><span data-stu-id="05703-183">Aborting the thread could be dangerous as the data operated on by the thread could be left in an inconsistent state.</span></span> <span data-ttu-id="05703-184">因此，必須回收整個 <xref:System.AppDomain>。</span><span class="sxs-lookup"><span data-stu-id="05703-184">Therefore, the entire <xref:System.AppDomain> has to be recycled.</span></span>  <span data-ttu-id="05703-185">無法識別鎖定的結果可以是發生死結或結果不正確。</span><span class="sxs-lookup"><span data-stu-id="05703-185">The consequences of failing to identify a lock can be either deadlocks or incorrect results.</span></span> <span data-ttu-id="05703-186">使用 <xref:System.Threading.Thread.BeginCriticalRegion%2A> 和 <xref:System.Threading.Thread.EndCriticalRegion%2A> 方法來識別鎖定區域。</span><span class="sxs-lookup"><span data-stu-id="05703-186">Use the methods <xref:System.Threading.Thread.BeginCriticalRegion%2A> and <xref:System.Threading.Thread.EndCriticalRegion%2A> to identify lock regions.</span></span>  <span data-ttu-id="05703-187">它們是 <xref:System.Threading.Thread> 類別上只套用至目前執行緒的靜態方法，有助於防止某個執行緒編輯另一個執行緒的鎖定計數。</span><span class="sxs-lookup"><span data-stu-id="05703-187">They are static methods on the <xref:System.Threading.Thread> class that only apply to the current thread, helping to prevent one thread from editing another thread’s lock count.</span></span>

<span data-ttu-id="05703-188"><xref:System.Threading.Monitor.Enter%2A> 和 <xref:System.Threading.Monitor.Exit%2A> 內建此 CLR 通知，以建議使用它們，以及使用可使用這些方法的 [lock 陳述式](../../csharp/language-reference/keywords/lock-statement.md)。</span><span class="sxs-lookup"><span data-stu-id="05703-188"><xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> have this CLR notification built in, so their usage is recommended as well as the use of the [lock Statement](../../csharp/language-reference/keywords/lock-statement.md), which uses these methods.</span></span>

<span data-ttu-id="05703-189">微調鎖定和 <xref:System.Threading.AutoResetEvent> 這類其他鎖定機制必須呼叫這些方法，向 CLR 通知將進入重要區段。</span><span class="sxs-lookup"><span data-stu-id="05703-189">Other locking mechanisms such as spin locks and <xref:System.Threading.AutoResetEvent> must call these methods to notify the CLR that a critical section is being entered.</span></span>  <span data-ttu-id="05703-190">這些方法不會取得任何鎖定；它們會向 CLR 通知程式碼正在重要區段中執行，而且中止執行緒會讓共用狀態不一致。</span><span class="sxs-lookup"><span data-stu-id="05703-190">These methods do not take any locks; they inform the CLR that code is executing in a critical section and aborting the thread could leave shared state inconsistent.</span></span>  <span data-ttu-id="05703-191">如果您已經定義自己的鎖定類型 (例如自訂 <xref:System.Threading.ReaderWriterLock> 類別)，請使用這些鎖定計數方法。</span><span class="sxs-lookup"><span data-stu-id="05703-191">If you have defined your own lock type, such as a custom <xref:System.Threading.ReaderWriterLock> class, use these lock count methods.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="05703-192">程式碼分析規則</span><span class="sxs-lookup"><span data-stu-id="05703-192">Code analysis rule</span></span>

<span data-ttu-id="05703-193">使用 <xref:System.Threading.Thread.BeginCriticalRegion%2A> 和 <xref:System.Threading.Thread.EndCriticalRegion%2A> 來標示並識別所有鎖定。</span><span class="sxs-lookup"><span data-stu-id="05703-193">Mark and identify all locks using <xref:System.Threading.Thread.BeginCriticalRegion%2A> and <xref:System.Threading.Thread.EndCriticalRegion%2A>.</span></span> <span data-ttu-id="05703-194">請不要在迴圈中使用 <xref:System.Threading.Interlocked.CompareExchange%2A>、<xref:System.Threading.Interlocked.Increment%2A> 和 <xref:System.Threading.Interlocked.Decrement%2A>。</span><span class="sxs-lookup"><span data-stu-id="05703-194">Do not use <xref:System.Threading.Interlocked.CompareExchange%2A>, <xref:System.Threading.Interlocked.Increment%2A>, and <xref:System.Threading.Interlocked.Decrement%2A> in a loop.</span></span>  <span data-ttu-id="05703-195">請不要對這些方法的 Win32 變體執行平台叫用。</span><span class="sxs-lookup"><span data-stu-id="05703-195">Do not do a platform invoke of the Win32 variants of these methods.</span></span>  <span data-ttu-id="05703-196">請不要在迴圈中使用 <xref:System.Threading.Thread.Sleep%2A>。</span><span class="sxs-lookup"><span data-stu-id="05703-196">Do not use <xref:System.Threading.Thread.Sleep%2A> in a loop.</span></span>  <span data-ttu-id="05703-197">請不要使用 Volatile 欄位。</span><span class="sxs-lookup"><span data-stu-id="05703-197">Do not use volatile fields.</span></span>

### <a name="cleanup-code-must-be-in-a-finally-or-a-catch-block-not-following-a-catch"></a><span data-ttu-id="05703-198">清除程式碼必須位於 finally 或 catch 區塊中，而不是在 catch 之後</span><span class="sxs-lookup"><span data-stu-id="05703-198">Cleanup code must be in a finally or a catch block, Not following a catch</span></span>

<span data-ttu-id="05703-199">清除程式碼的後面絕對不應該是 `catch` 區塊；它應該位在 `finally` 或 `catch` 區塊本身中。</span><span class="sxs-lookup"><span data-stu-id="05703-199">Cleanup code should never follow a `catch` block; it should be in a `finally` or in the `catch` block itself.</span></span> <span data-ttu-id="05703-200">這應該是一般不錯的做法。</span><span class="sxs-lookup"><span data-stu-id="05703-200">This should be a normal good practice.</span></span> <span data-ttu-id="05703-201">一般偏好使用 `finally` 區塊，因為它在擲回例外狀況以及正常發現 `try` 區塊結尾時執行相同的程式碼。</span><span class="sxs-lookup"><span data-stu-id="05703-201">A `finally` block is generally preferred because it runs the same code both when an exception is thrown and when the end of the `try` block is normally encountered.</span></span>  <span data-ttu-id="05703-202">如果擲回未預期的例外狀況 (例如 <xref:System.Threading.ThreadAbortException>)，則不會執行清除程式碼。</span><span class="sxs-lookup"><span data-stu-id="05703-202">In the event of an unexpected exception being thrown, for example a <xref:System.Threading.ThreadAbortException>, the cleanup code will not run.</span></span>  <span data-ttu-id="05703-203">在理想狀況下，任何將在 `finally` 中清除的 Unmanaged 資源都應該包裝在 <xref:System.Runtime.InteropServices.SafeHandle> 中，以防止外洩。</span><span class="sxs-lookup"><span data-stu-id="05703-203">Any unmanaged resources that you would clean up in a `finally` should ideally be wrapped in a <xref:System.Runtime.InteropServices.SafeHandle> to prevent leaks.</span></span>  <span data-ttu-id="05703-204">請注意，可以有效地使用 C# `using` 關鍵字來處置物件，包含控制代碼。</span><span class="sxs-lookup"><span data-stu-id="05703-204">Note the C# `using` keyword can be used effectively to dispose of objects, including handles.</span></span>

<span data-ttu-id="05703-205">雖然 <xref:System.AppDomain> 回收可以清除完成項執行緒上的資源，但還是需要將清除程式碼放在正確的位置。</span><span class="sxs-lookup"><span data-stu-id="05703-205">Although <xref:System.AppDomain> recycling can clean up resources on the finalizer thread, it is still important to put cleanup code in the correct place.</span></span> <span data-ttu-id="05703-206">請注意，如果執行緒收到非同步例外狀況，但未持有鎖定，則 CLR 會嘗試結束執行緒本身，而不需要回收 <xref:System.AppDomain>。</span><span class="sxs-lookup"><span data-stu-id="05703-206">Note that if a thread receives an asynchronous exception without holding a lock, the CLR attempts to end the thread itself without having to recycle the <xref:System.AppDomain>.</span></span>  <span data-ttu-id="05703-207">確保更快清除資源而不是更慢清除資源會有所幫助，原因是提供更多資源，而且更恰當地管理存留期。</span><span class="sxs-lookup"><span data-stu-id="05703-207">Ensuring that resources are cleaned up sooner rather than later helps by making more resources available, and by better managing the lifetime.</span></span> <span data-ttu-id="05703-208">如果您未在某個錯誤碼路徑中明確地關閉檔案的控制代碼，則請等待 <xref:System.Runtime.InteropServices.SafeHandle> 完成項將它清除。程式碼下次執行時可能會失敗。如果尚未執行完成項，請嘗試存取完全相同的檔案。</span><span class="sxs-lookup"><span data-stu-id="05703-208">If you do not explicitly close a handle to a file in some error code path then wait for the <xref:System.Runtime.InteropServices.SafeHandle> finalizer to clean it up, the next time your code runs it may fail trying to access the exact same file if the finalizer has not already run.</span></span>  <span data-ttu-id="05703-209">基於這個原因，確保清除程式碼已存在並且正確運作，協助更乾淨且更快速地復原失敗，即使不是絕對必要也是一樣。</span><span class="sxs-lookup"><span data-stu-id="05703-209">For this reason, ensuring that cleanup code exists and works correctly will help recover from failures more cleanly and quickly, even though it is not strictly necessary.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="05703-210">程式碼分析規則</span><span class="sxs-lookup"><span data-stu-id="05703-210">Code analysis rule</span></span>

<span data-ttu-id="05703-211">`catch` 後面的清除程式碼需要位在 `finally` 區塊中。</span><span class="sxs-lookup"><span data-stu-id="05703-211">Cleanup code after `catch` needs to be in a `finally` block.</span></span> <span data-ttu-id="05703-212">將處置呼叫放在 finally 區塊中。</span><span class="sxs-lookup"><span data-stu-id="05703-212">Place calls to dispose in a finally block.</span></span> <span data-ttu-id="05703-213">`catch` 區塊應該結束於 throw 或 rethrow 中。</span><span class="sxs-lookup"><span data-stu-id="05703-213">`catch` blocks should end in a throw or rethrow.</span></span> <span data-ttu-id="05703-214">雖然會有一些例外狀況，例如偵測是否可在可能收到任何大量例外狀況的位置建立網路連線的程式碼，但是在正常情況下需要攔截數個例外狀況的任何程式碼都應該指出應測試程式碼確認它是否成功。</span><span class="sxs-lookup"><span data-stu-id="05703-214">While there will be exceptions, such as code detecting whether a network connection can be established where you might get any of a large number of exceptions, any code that requires the catching of a number of exceptions under normal circumstances should give an indication that the code should be tested to see if it will succeed.</span></span>

### <a name="process-wide-mutable-shared-state-between-application-domains-should-be-eliminated-or-use-a-constrained-execution-region"></a><span data-ttu-id="05703-215">應用程式域之間的整個進程可變動共用狀態應會被排除，或使用限制的執列區域</span><span class="sxs-lookup"><span data-stu-id="05703-215">Process-Wide mutable shared state between application domains should be eliminated or use a constrained execution region</span></span>

<span data-ttu-id="05703-216">如簡介中所述，可能很難撰寫 Managed 程式碼，以可靠方式監視跨應用程式定義域的整個處理序共用狀態。</span><span class="sxs-lookup"><span data-stu-id="05703-216">As described in the introduction, it can be very difficult to write managed code that monitors process-wide shared state across application domains in a reliable manner.</span></span>  <span data-ttu-id="05703-217">整個處理序共用狀態是在 Win32 程式碼中、CLR 內或使用遠端處理的 Managed 程式碼中應用程式定義域之間共用的任何一種資料結構。</span><span class="sxs-lookup"><span data-stu-id="05703-217">Process-wide shared state is any sort of data structure shared between application domains, either in Win32 code, inside the CLR, or in managed code using remoting.</span></span>  <span data-ttu-id="05703-218">很難使用 Managed 程式碼正確撰寫任何可變動共用狀態，而且撰寫任何靜態共用狀態都必須特別小心。</span><span class="sxs-lookup"><span data-stu-id="05703-218">Any mutable shared state is very difficult to correctly write in managed code, and any static shared state might be done only with great care.</span></span>  <span data-ttu-id="05703-219">如果您有整個處理序或整部電腦共用狀態，請找到某種方法，以使用限制的執行區域 (CER) 排除它或保護共用狀態。</span><span class="sxs-lookup"><span data-stu-id="05703-219">If you have process-wide or machine-wide shared state, find some way to eliminate it or protect the shared state using a constrained execution region (CER).</span></span>  <span data-ttu-id="05703-220">請注意，具有未識別和更正之共用狀態的任何程式庫都可能會讓需要全新 <xref:System.AppDomain> 卸載的主機 (例如 SQL Server) 當機。</span><span class="sxs-lookup"><span data-stu-id="05703-220">Note that any library with shared state that is not identified and corrected could cause a host, such as SQL Server, that requires clean <xref:System.AppDomain> unloading to crash.</span></span>

<span data-ttu-id="05703-221">如果程式碼使用 COM 物件，請避免在應用程式定義域之間共用該 COM 物件。</span><span class="sxs-lookup"><span data-stu-id="05703-221">If code uses a COM object, avoid sharing that COM object between application domains.</span></span>

### <a name="locks-do-not-work-process-wide-or-between-application-domains"></a><span data-ttu-id="05703-222">鎖定無法整個進程或在應用程式域之間工作。</span><span class="sxs-lookup"><span data-stu-id="05703-222">Locks do not work process-wide or between application domains.</span></span>

<span data-ttu-id="05703-223">過去，使用 <xref:System.Threading.Monitor.Enter%2A> 和 [lock 陳述式](../../csharp/language-reference/keywords/lock-statement.md)來建立全域處理序鎖定。</span><span class="sxs-lookup"><span data-stu-id="05703-223">In the past, <xref:System.Threading.Monitor.Enter%2A> and the [lock Statement](../../csharp/language-reference/keywords/lock-statement.md) have been used to create global process locks.</span></span>  <span data-ttu-id="05703-224">例如，鎖定 <xref:System.AppDomain> 敏捷式類別時會發生這種情況，例如非共用組件中的 <xref:System.Type> 執行個體、<xref:System.Threading.Thread> 物件、實習字串，以及使用遠端處理跨應用程式定義域共用的一些字串。</span><span class="sxs-lookup"><span data-stu-id="05703-224">For example, this occurs when locking on <xref:System.AppDomain> agile classes, such as <xref:System.Type> instances from non-shared assemblies, <xref:System.Threading.Thread> objects, interned strings, and some strings shared across application domains using remoting.</span></span>  <span data-ttu-id="05703-225">這些鎖定不再是針對整個處理序。</span><span class="sxs-lookup"><span data-stu-id="05703-225">These locks are no longer process-wide.</span></span>  <span data-ttu-id="05703-226">若要識別整個處理序應用程式間網域鎖定的目前狀態，請判斷鎖定內的程式碼是否使用任何外部持續性資源，例如磁碟上或可能是資料庫上的檔案。</span><span class="sxs-lookup"><span data-stu-id="05703-226">To identify the presence of a process-wide interapplication domain lock, determine if the code within the lock uses any external, persisted resource such as a file on disk or possibly a database.</span></span>

<span data-ttu-id="05703-227">請注意，如果受保護程式碼使用外部資源，則在 <xref:System.AppDomain> 內鎖定可能會導致問題，因為該程式碼可能會跨多個應用程式定義域同時執行。</span><span class="sxs-lookup"><span data-stu-id="05703-227">Note that taking a lock within an <xref:System.AppDomain> might cause problems if the protected code uses an external resource because that code may run simultaneously across multiple application domains.</span></span>  <span data-ttu-id="05703-228">寫入至一個記錄檔或是繫結至整個處理序的通訊端時，這可能會造成問題。</span><span class="sxs-lookup"><span data-stu-id="05703-228">This can be a problem when writing to one log file or binding to a socket for the entire process.</span></span>  <span data-ttu-id="05703-229">這些變更表示沒有簡單的方式可使用 Managed 程式碼來取得處理序全域鎖定，而非使用具名 <xref:System.Threading.Mutex> 或 <xref:System.Threading.Semaphore> 執行個體。</span><span class="sxs-lookup"><span data-stu-id="05703-229">These changes mean there is no easy way, using managed code, to get a process-global lock, other than using a named <xref:System.Threading.Mutex> or <xref:System.Threading.Semaphore> instance.</span></span>  <span data-ttu-id="05703-230">同時建立未在兩個應用程式定義域中執行的程式碼，或使用 <xref:System.Threading.Mutex> 或 <xref:System.Threading.Semaphore> 類別。</span><span class="sxs-lookup"><span data-stu-id="05703-230">Create code that does not run in two application domains simultaneously, or use the <xref:System.Threading.Mutex> or <xref:System.Threading.Semaphore> classes.</span></span>  <span data-ttu-id="05703-231">如果無法變更現有程式碼，請不要使用 Win32 具名 Mutex 來達成這項同步處理，因為以 Fiber 模式執行表示您無法保證相同的作業系統執行緒會取得和釋放 Mutex。</span><span class="sxs-lookup"><span data-stu-id="05703-231">If existing code cannot be changed, do not use a Win32 named mutex to achieve this synchronization because running in fiber mode means you cannot guarantee the same operating system thread will acquire and release a mutex.</span></span>  <span data-ttu-id="05703-232">您必須使用 Managed <xref:System.Threading.Mutex> 類別或具名 <xref:System.Threading.ManualResetEvent>、<xref:System.Threading.AutoResetEvent> 或 <xref:System.Threading.Semaphore> 透過 CLR 所知的方式來同步處理程式碼鎖定，而不是使用 Unmanaged 程式碼來同步處理鎖定。</span><span class="sxs-lookup"><span data-stu-id="05703-232">You must use the managed <xref:System.Threading.Mutex> class, or a named <xref:System.Threading.ManualResetEvent>, <xref:System.Threading.AutoResetEvent>, or a <xref:System.Threading.Semaphore> to synchronize the code lock in a manner that the CLR is aware of instead of synchronizing the lock using unmanaged code.</span></span>

#### <a name="avoid-locktypeofmytype"></a><span data-ttu-id="05703-233">避免 lock(typeof(MyType))</span><span class="sxs-lookup"><span data-stu-id="05703-233">Avoid lock(typeof(MyType))</span></span>

<span data-ttu-id="05703-234">跨所有應用程式定義域只共用一份程式碼之共用組件中的私用和公用 <xref:System.Type> 物件也會產生問題。</span><span class="sxs-lookup"><span data-stu-id="05703-234">Private and public <xref:System.Type> objects in shared assemblies with only one copy of the code shared across all application domains also present problems.</span></span>  <span data-ttu-id="05703-235">針對共用組件，一個處理序只有一個 <xref:System.Type> 執行個體，這表示多個應用程式定義域會共用完全相同的 <xref:System.Type> 執行個體。</span><span class="sxs-lookup"><span data-stu-id="05703-235">For shared assemblies, there is only one instance of a <xref:System.Type> per process, meaning that multiple application domains share the exact same <xref:System.Type> instance.</span></span>  <span data-ttu-id="05703-236">鎖定 <xref:System.Type> 執行個體會採用影響整個處理序的鎖定，而不只是 <xref:System.AppDomain>。</span><span class="sxs-lookup"><span data-stu-id="05703-236">Taking a lock on a <xref:System.Type> instance takes a lock that affects the entire process, not just the <xref:System.AppDomain>.</span></span>  <span data-ttu-id="05703-237">如果有一個 <xref:System.AppDomain> 取得 <xref:System.Type> 物件上的鎖定，然後該執行緒突然中止，則不會釋放鎖定。</span><span class="sxs-lookup"><span data-stu-id="05703-237">If one <xref:System.AppDomain> takes a lock on a <xref:System.Type> object then that thread gets abruptly aborted, it will not release the lock.</span></span>  <span data-ttu-id="05703-238">此鎖定接著可能會讓其他應用程式定義域發生死結。</span><span class="sxs-lookup"><span data-stu-id="05703-238">This lock then may cause other application domains to deadlock.</span></span>

<span data-ttu-id="05703-239">鎖定靜態方法的不錯方式包含將靜態內部同步處理物件新增至程式碼。</span><span class="sxs-lookup"><span data-stu-id="05703-239">A good way to take locks in static methods involves adding a static internal synchronization object to the code.</span></span>  <span data-ttu-id="05703-240">如果已有類別建構函式，則這可以在其中進行初始化，但如果沒有，則可以如下進行初始化：</span><span class="sxs-lookup"><span data-stu-id="05703-240">This could be initialized in the class constructor if one is present, but if not it can be initialized like this:</span></span>

```csharp
private static Object s_InternalSyncObject;
private static Object InternalSyncObject
{
    get
    {
        if (s_InternalSyncObject == null)
        {
            Object o = new Object();
            Interlocked.CompareExchange(
                ref s_InternalSyncObject, o, null);
        }
        return s_InternalSyncObject;
    }
}
```

<span data-ttu-id="05703-241">然後，採用鎖定時，請使用 `InternalSyncObject` 屬性來取得要鎖定的物件。</span><span class="sxs-lookup"><span data-stu-id="05703-241">Then when taking a lock, use the `InternalSyncObject` property to obtain an object to lock on.</span></span>  <span data-ttu-id="05703-242">如果您已經在類別建構函式中初始化內部同步處理物件，則不需要使用此屬性。</span><span class="sxs-lookup"><span data-stu-id="05703-242">You do not need to use the property if you have initialized the internal synchronization object in your class constructor.</span></span>  <span data-ttu-id="05703-243">重複檢查鎖定初始化程式碼應該與此範例類似：</span><span class="sxs-lookup"><span data-stu-id="05703-243">The double checking lock initialization code should look like this example:</span></span>

```csharp
public static MyClass SingletonProperty
{
    get
    {
        if (s_SingletonProperty == null)
        {
            lock(InternalSyncObject)
            {
                // Do not use lock(typeof(MyClass))
                if (s_SingletonProperty == null)
                {
                    MyClass tmp = new MyClass(…);
                    // Do all initialization before publishing
                    s_SingletonProperty = tmp;
                }
            }
        }
        return s_SingletonProperty;
    }
}
```

#### <a name="a-note-about-lockthis"></a><span data-ttu-id="05703-244">關於鎖定的注意事項（this）</span><span class="sxs-lookup"><span data-stu-id="05703-244">A note about lock(this)</span></span>

<span data-ttu-id="05703-245">通常可以接受鎖定可公開存取的個別物件。</span><span class="sxs-lookup"><span data-stu-id="05703-245">It is generally acceptable to take a lock on an individual object that is publicly accessible.</span></span>  <span data-ttu-id="05703-246">不過，如果物件是可能造成整個子系統發生死結的單一物件，也請考慮使用上述設計模式。</span><span class="sxs-lookup"><span data-stu-id="05703-246">However, if the object is a singleton object that might cause an entire subsystem to deadlock, consider using the above design pattern as well.</span></span>  <span data-ttu-id="05703-247">例如，一個 <xref:System.Security.SecurityManager> 物件上的鎖定可能會造成 <xref:System.AppDomain> 內發生死結，導致整個 <xref:System.AppDomain> 無法使用。</span><span class="sxs-lookup"><span data-stu-id="05703-247">For example, a lock on the one <xref:System.Security.SecurityManager> object could cause a deadlock within the <xref:System.AppDomain> making the entire <xref:System.AppDomain> unusable.</span></span> <span data-ttu-id="05703-248">最好不要鎖定這類型的可公開存取物件。</span><span class="sxs-lookup"><span data-stu-id="05703-248">It is good practice to not take a lock on a publicly accessible object of this type.</span></span>  <span data-ttu-id="05703-249">不過，鎖定個別集合或陣列通常應該不會產生問題。</span><span class="sxs-lookup"><span data-stu-id="05703-249">However a lock on an individual collection or array should generally not present a problem.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="05703-250">程式碼分析規則</span><span class="sxs-lookup"><span data-stu-id="05703-250">Code analysis rule</span></span>

<span data-ttu-id="05703-251">請不要鎖定跨應用程式定義域使用的類型，或不要有強烈的身分識別感。</span><span class="sxs-lookup"><span data-stu-id="05703-251">Do not take locks on types that might be used across application domains or do not have a strong sense of identity.</span></span> <span data-ttu-id="05703-252">請不要在 <xref:System.Type>、<xref:System.Reflection.MethodInfo>、<xref:System.Reflection.PropertyInfo>、<xref:System.String>、<xref:System.ValueType>、<xref:System.Threading.Thread> 或任何衍生自 <xref:System.MarshalByRefObject> 的物件上呼叫 <xref:System.Threading.Monitor.Enter%2A>。</span><span class="sxs-lookup"><span data-stu-id="05703-252">Do not call <xref:System.Threading.Monitor.Enter%2A> on a <xref:System.Type>, <xref:System.Reflection.MethodInfo>, <xref:System.Reflection.PropertyInfo>, <xref:System.String>, <xref:System.ValueType>, <xref:System.Threading.Thread>, or any object that derives from <xref:System.MarshalByRefObject>.</span></span>

### <a name="remove-gckeepalive-calls"></a><span data-ttu-id="05703-253">移除 GC。KeepAlive 呼叫</span><span class="sxs-lookup"><span data-stu-id="05703-253">Remove GC.KeepAlive calls</span></span>

<span data-ttu-id="05703-254">大量的現有程式碼不會在應該使用時使用 <xref:System.GC.KeepAlive%2A>，或在不適當時使用它。</span><span class="sxs-lookup"><span data-stu-id="05703-254">A significant amount of existing code either does not use <xref:System.GC.KeepAlive%2A> when it should or uses it when it is not appropriate.</span></span>  <span data-ttu-id="05703-255">轉換至 <xref:System.Runtime.InteropServices.SafeHandle> 之後，類別不需要呼叫 <xref:System.GC.KeepAlive%2A>，並假設它們沒有完成項但依賴 <xref:System.Runtime.InteropServices.SafeHandle> 來完成作業系統控制代碼。</span><span class="sxs-lookup"><span data-stu-id="05703-255">After converting to <xref:System.Runtime.InteropServices.SafeHandle>, classes do not need to call <xref:System.GC.KeepAlive%2A>, assuming they do not have a finalizer but rely on <xref:System.Runtime.InteropServices.SafeHandle> to finalize the operating system handles.</span></span>  <span data-ttu-id="05703-256">雖然重新訓練 <xref:System.GC.KeepAlive%2A> 呼叫的效能成本可能微不足道，但感知 <xref:System.GC.KeepAlive%2A> 呼叫是必要的或足以解決可能不再存在的存留期問題，都會讓程式碼更難維護。</span><span class="sxs-lookup"><span data-stu-id="05703-256">While the performance cost of retaining a call to <xref:System.GC.KeepAlive%2A> may be negligible, the perception that a call to <xref:System.GC.KeepAlive%2A> is either necessary or sufficient to solve a lifetime issue that may no longer exist makes the code more difficult to maintain.</span></span>  <span data-ttu-id="05703-257">不過，使用 COM Interop CLR 可呼叫包裝函式 (RCW) 時，程式碼仍然需要 <xref:System.GC.KeepAlive%2A>。</span><span class="sxs-lookup"><span data-stu-id="05703-257">However, when using the COM interop CLR callable wrappers (RCWs), <xref:System.GC.KeepAlive%2A> is still required by code.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="05703-258">程式碼分析規則</span><span class="sxs-lookup"><span data-stu-id="05703-258">Code analysis rule</span></span>

<span data-ttu-id="05703-259">移除 <xref:System.GC.KeepAlive%2A>。</span><span class="sxs-lookup"><span data-stu-id="05703-259">Remove <xref:System.GC.KeepAlive%2A>.</span></span>

### <a name="use-the-hostprotection-attribute"></a><span data-ttu-id="05703-260">使用 HostProtection 屬性</span><span class="sxs-lookup"><span data-stu-id="05703-260">Use the HostProtection Attribute</span></span>

<span data-ttu-id="05703-261"><xref:System.Security.Permissions.HostProtectionAttribute> (HPA) 使用宣告式安全性動作來決定主機保護需求，甚至讓主機防止完全信任的程式碼呼叫不適用於指定主機的特定方法，例如 SQL Server 是 <xref:System.Environment.Exit%2A> 或 <xref:System.Windows.Forms.MessageBox.Show%2A>。</span><span class="sxs-lookup"><span data-stu-id="05703-261">The <xref:System.Security.Permissions.HostProtectionAttribute> (HPA) provides the use of declarative security actions to determine host protection requirements, allowing the host to prevent even fully trusted code from calling certain methods which are inappropriate for the given host, such as <xref:System.Environment.Exit%2A> or <xref:System.Windows.Forms.MessageBox.Show%2A> for SQL Server.</span></span>

<span data-ttu-id="05703-262">HPA 只會影響裝載 Common Language Runtime 以及實作主機保護的 Unmanaged 應用程式，例如 SQL Server。</span><span class="sxs-lookup"><span data-stu-id="05703-262">The HPA affects only unmanaged applications that host the common language runtime and implement host protection, such as SQL Server.</span></span> <span data-ttu-id="05703-263">套用時，安全性動作會根據類別或方法所公開的主機資源來建立連結要求。</span><span class="sxs-lookup"><span data-stu-id="05703-263">When applied, the security action results in the creation of a link demand based on the host resources the class or method exposes.</span></span> <span data-ttu-id="05703-264">如果在用戶端應用程式中或未受主機保護的伺服器上執行程式碼，則屬性會「消失」；它會偵測不到，因此不會進行套用。</span><span class="sxs-lookup"><span data-stu-id="05703-264">If the code is run in a client application or on a server that is not host-protected, the attribute "evaporates"; it is not detected and therefore not applied.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="05703-265">此屬性的目的是強制執行主機特定程式設計模型方針，而不是安全性行為。</span><span class="sxs-lookup"><span data-stu-id="05703-265">The purpose of this attribute is to enforce host-specific programming model guidelines, not security behavior.</span></span>  <span data-ttu-id="05703-266">雖然使用連結要求來檢查是否與程式設計模型需求一致，但是 <xref:System.Security.Permissions.HostProtectionAttribute> 不是安全性權限。</span><span class="sxs-lookup"><span data-stu-id="05703-266">Although a link demand is used to check for conformance to programming model requirements, the <xref:System.Security.Permissions.HostProtectionAttribute> is not a security permission.</span></span>

<span data-ttu-id="05703-267">如果主機沒有程式設計模型需求，則不會發生連結要求。</span><span class="sxs-lookup"><span data-stu-id="05703-267">If the host does not have programming model requirements, the link demands do not occur.</span></span>

<span data-ttu-id="05703-268">此屬性可識別下列各項：</span><span class="sxs-lookup"><span data-stu-id="05703-268">This attribute identifies the following:</span></span>

- <span data-ttu-id="05703-269">方法或類別，不適合主機程式設計模型但為良性。</span><span class="sxs-lookup"><span data-stu-id="05703-269">Methods or classes that do not fit the host programming model, but are otherwise benign.</span></span>

- <span data-ttu-id="05703-270">方法或類別，不適合主機程式設計模型，而且可能導致伺服器所管理的使用者程式碼不穩定。</span><span class="sxs-lookup"><span data-stu-id="05703-270">Methods or classes that do not fit the host programming model and could lead to destabilizing server-managed user code.</span></span>

- <span data-ttu-id="05703-271">方法或類別，不適合主機程式設計模型，而且可能導致伺服器處理序本身不穩定。</span><span class="sxs-lookup"><span data-stu-id="05703-271">Methods or classes that do not fit the host programming model and could lead to a destabilization of the server process itself.</span></span>

> [!NOTE]
> <span data-ttu-id="05703-272">如果您所建立的類別庫是要由可在主機保護環境中執行的應用程式進行呼叫，則應該將此屬性套用至公開 <xref:System.Security.Permissions.HostProtectionResource> 資源分類的成員。</span><span class="sxs-lookup"><span data-stu-id="05703-272">If you are creating a class library that is to be called by applications that may execute in a host protected environment, you should apply this attribute to members that expose <xref:System.Security.Permissions.HostProtectionResource> resource categories.</span></span> <span data-ttu-id="05703-273">具有此屬性的 .NET Framework Class Library 成員只會檢查立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="05703-273">The .NET Framework class library members with this attribute cause only the immediate caller to be checked.</span></span>  <span data-ttu-id="05703-274">程式庫成員也必須以相同的方式檢查其立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="05703-274">Your library member must also cause a check of its immediate caller in the same manner.</span></span>

<span data-ttu-id="05703-275">請在 <xref:System.Security.Permissions.HostProtectionAttribute> 中尋找 HPA 詳細資訊。</span><span class="sxs-lookup"><span data-stu-id="05703-275">Please find more information on HPA in <xref:System.Security.Permissions.HostProtectionAttribute>.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="05703-276">程式碼分析規則</span><span class="sxs-lookup"><span data-stu-id="05703-276">Code analysis rule</span></span>

<span data-ttu-id="05703-277">針對 SQL Server，用來介紹同步處理或執行緒處理的所有方法都必須使用 HPA 進行識別。</span><span class="sxs-lookup"><span data-stu-id="05703-277">For SQL Server, all methods used to introduce synchronization or threading must identified with the HPA.</span></span> <span data-ttu-id="05703-278">這包含共用狀態、已同步處理或管理外部處理序的方法。</span><span class="sxs-lookup"><span data-stu-id="05703-278">This includes methods that share state, are synchronized, or manage external processes.</span></span> <span data-ttu-id="05703-279">可影響 SQL Server 的 <xref:System.Security.Permissions.HostProtectionResource> 值是 <xref:System.Security.Permissions.HostProtectionResource.SharedState>、<xref:System.Security.Permissions.HostProtectionResource.Synchronization> 和 <xref:System.Security.Permissions.HostProtectionResource.ExternalProcessMgmt>。</span><span class="sxs-lookup"><span data-stu-id="05703-279">The <xref:System.Security.Permissions.HostProtectionResource> values that impact SQL Server are <xref:System.Security.Permissions.HostProtectionResource.SharedState>, <xref:System.Security.Permissions.HostProtectionResource.Synchronization>, and <xref:System.Security.Permissions.HostProtectionResource.ExternalProcessMgmt>.</span></span> <span data-ttu-id="05703-280">不過，HPA 應該識別任何 <xref:System.Security.Permissions.HostProtectionResource> 所公開的任何方法，而不只是使用會影響 SQL 之資源的方法。</span><span class="sxs-lookup"><span data-stu-id="05703-280">However, any method that exposes any <xref:System.Security.Permissions.HostProtectionResource> should be identified by a HPA, not just those using resources affecting SQL.</span></span>

### <a name="do-not-block-indefinitely-in-unmanaged-code"></a><span data-ttu-id="05703-281">不要無限期地封鎖未受管理的程式碼</span><span class="sxs-lookup"><span data-stu-id="05703-281">Do not block indefinitely in unmanaged code</span></span>

<span data-ttu-id="05703-282">因為 CLR 無法中止執行緒，所以使用 Unmanaged 程式碼進行封鎖可能會導致拒絕服務攻擊，而不是使用 Managed 程式碼進行封鎖。</span><span class="sxs-lookup"><span data-stu-id="05703-282">Blocking in unmanaged code instead of in managed code can cause a denial of service attack because the CLR is not able to abort the thread.</span></span>  <span data-ttu-id="05703-283">已封鎖的執行緒會防止 CLR 卸載 <xref:System.AppDomain>，至少不執行一些非常不安全的作業。</span><span class="sxs-lookup"><span data-stu-id="05703-283">A blocked thread prevents the CLR from unloading the <xref:System.AppDomain>, at least without doing some extremely unsafe operations.</span></span>  <span data-ttu-id="05703-284">使用 Windows 同步處理原始物件進行封鎖，是我們無法允許的一個明確範例。</span><span class="sxs-lookup"><span data-stu-id="05703-284">Blocking using a Windows synchronization primitive is a clear example of something we cannot allow.</span></span>  <span data-ttu-id="05703-285">`ReadFile`如果可能的話，應該避免在對通訊端的呼叫中封鎖，在理想的情況下，WINDOWS API 應該提供一種機制，讓這類作業的運作時間。</span><span class="sxs-lookup"><span data-stu-id="05703-285">Blocking in a call to `ReadFile` on a socket should be avoided if possible — ideally the Windows API should provide a mechanism for an operation like this to time out.</span></span>

<span data-ttu-id="05703-286">在理想情況下，所有呼叫原生的方法都應該使用具有合理有限逾時的 Win32 呼叫。</span><span class="sxs-lookup"><span data-stu-id="05703-286">Any method that calls into native should ideally use a Win32 call with a reasonable, finite timeout.</span></span>  <span data-ttu-id="05703-287">如果允許使用者指定逾時，則在沒有某種特定安全性權限時，不應該允許使用者指定無限逾時。</span><span class="sxs-lookup"><span data-stu-id="05703-287">If the user is allowed to specify the timeout, the user should not be allowed to specify an infinite timeout without some specific security permission.</span></span>  <span data-ttu-id="05703-288">準則是，如果方法將封鎖超過 ~10 秒，則需要使用支援逾時的版本，或需要額外的 CLR 支援。</span><span class="sxs-lookup"><span data-stu-id="05703-288">As a guideline, if a method will block for more than ~10 seconds, you need to be using a version that supports timeouts or you need additional CLR support.</span></span>

<span data-ttu-id="05703-289">以下是一些有問題的 Api 範例。</span><span class="sxs-lookup"><span data-stu-id="05703-289">Here are some examples of problematic APIs.</span></span>  <span data-ttu-id="05703-290">管道 (匿名和具名) 可以建立成包含逾時；不過，程式碼必須確定永遠不會使用 NMPWAIT_WAIT_FOREVER 來呼叫 `CreateNamedPipe` 和 `WaitNamedPipe`。</span><span class="sxs-lookup"><span data-stu-id="05703-290">Pipes (both anonymous and named) can be created with a timeout; however, code must ensure it never calls `CreateNamedPipe` nor `WaitNamedPipe` with NMPWAIT_WAIT_FOREVER.</span></span>  <span data-ttu-id="05703-291">此外，即使指定逾時，還是會有未預期的封鎖。</span><span class="sxs-lookup"><span data-stu-id="05703-291">Additionally, there can be unexpected blocking even if a timeout is specified.</span></span>  <span data-ttu-id="05703-292">除非寫入所有位元組，否則會封鎖在匿名管道上呼叫 `WriteFile`；這表示，如果緩衝區中有未讀取的資料，則除非讀取器已釋放管道緩衝區中的空間，否則會封鎖 `WriteFile` 呼叫。</span><span class="sxs-lookup"><span data-stu-id="05703-292">Calling `WriteFile` on an anonymous pipe will block until all bytes are written, meaning if the buffer has unread data in it, the `WriteFile` call will block until the reader has freed up space in the pipe’s buffer.</span></span>  <span data-ttu-id="05703-293">通訊端應該一律使用接受逾時機制的某個 API。</span><span class="sxs-lookup"><span data-stu-id="05703-293">Sockets should always use some API that honors a timeout mechanism.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="05703-294">程式碼分析規則</span><span class="sxs-lookup"><span data-stu-id="05703-294">Code analysis rule</span></span>

<span data-ttu-id="05703-295">沒有使用 Unmanaged 程式碼之逾時的封鎖是拒絕服務攻擊。</span><span class="sxs-lookup"><span data-stu-id="05703-295">Blocking without a timeout in unmanaged code is a denial of service attack.</span></span> <span data-ttu-id="05703-296">請不要對 `WaitForSingleObject`、`WaitForSingleObjectEx`、`WaitForMultipleObjects`、`MsgWaitForMultipleObjects` 和 `MsgWaitForMultipleObjectsEx` 執行平台叫用呼叫。</span><span class="sxs-lookup"><span data-stu-id="05703-296">Do not perform platform invoke calls to `WaitForSingleObject`, `WaitForSingleObjectEx`, `WaitForMultipleObjects`, `MsgWaitForMultipleObjects`, and `MsgWaitForMultipleObjectsEx`.</span></span>  <span data-ttu-id="05703-297">請不要使用 NMPWAIT_WAIT_FOREVER。</span><span class="sxs-lookup"><span data-stu-id="05703-297">Do not use NMPWAIT_WAIT_FOREVER.</span></span>

### <a name="identify-any-sta-dependent-features"></a><span data-ttu-id="05703-298">識別任何與 STA 相關的功能</span><span class="sxs-lookup"><span data-stu-id="05703-298">Identify any STA-Dependent features</span></span>

<span data-ttu-id="05703-299">識別任何使用 COM 單一執行緒 Apartment (STA) 的程式碼。</span><span class="sxs-lookup"><span data-stu-id="05703-299">Identify any code that uses COM single-threaded apartments (STAs).</span></span>  <span data-ttu-id="05703-300">在 SQL Server 處理序中，已停用 STA。</span><span class="sxs-lookup"><span data-stu-id="05703-300">STAs are disabled in the SQL Server process.</span></span>  <span data-ttu-id="05703-301">在 SQL Server 內，必須停用與 `CoInitialize` 相依的功能 (例如效能計數器或剪貼簿)。</span><span class="sxs-lookup"><span data-stu-id="05703-301">Features that depend on `CoInitialize`, such as performance counters or the clipboard, must be disabled within SQL Server.</span></span>

### <a name="ensure-finalizers-are-free-of-synchronization-problems"></a><span data-ttu-id="05703-302">確保完成項不受同步處理問題的歡迎</span><span class="sxs-lookup"><span data-stu-id="05703-302">Ensure finalizers are free of synchronization problems</span></span>

<span data-ttu-id="05703-303">多個完成項執行緒可能存在於 .NET Framework 的未來版本中，這表示會同時執行相同類型之不同執行個體的完成項。</span><span class="sxs-lookup"><span data-stu-id="05703-303">Multiple finalizer threads might exist in future versions of the .NET Framework, meaning the finalizers for different instances of the same type run simultaneously.</span></span>  <span data-ttu-id="05703-304">它們不需要完全具備執行緒安全；記憶體回收行程保證只有一個執行緒將執行所指定物件執行個體的完成項。</span><span class="sxs-lookup"><span data-stu-id="05703-304">They do not have to be completely thread safe; the garbage collector guarantees that only one thread will run the finalizer for a given object instance.</span></span>  <span data-ttu-id="05703-305">不過，完成項同時在多個不同的物件執行個體上執行時必須進行編碼，才能避免競爭情況和死結。</span><span class="sxs-lookup"><span data-stu-id="05703-305">However, the finalizers must be coded to avoid race conditions and deadlocks when running simultaneously on multiple different object instances.</span></span>  <span data-ttu-id="05703-306">在完成項中使用任何外部狀態時 (例如寫入記錄檔)，必須處理執行緒問題。</span><span class="sxs-lookup"><span data-stu-id="05703-306">When using any external state, such as writing to a log file, in a finalizer, threading issues must be handled.</span></span>  <span data-ttu-id="05703-307">請不要依賴可提供安全執行緒的最終處理。</span><span class="sxs-lookup"><span data-stu-id="05703-307">Do not rely on finalization to provide thread safety.</span></span> <span data-ttu-id="05703-308">請不要使用執行緒區域儲存區 (Managed 或原生)，將狀態儲存在完成項執行緒上。</span><span class="sxs-lookup"><span data-stu-id="05703-308">Do not use thread local storage, managed or native, to store state on the finalizer thread.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="05703-309">程式碼分析規則</span><span class="sxs-lookup"><span data-stu-id="05703-309">Code analysis rule</span></span>

<span data-ttu-id="05703-310">完成項必須沒有同步處理問題。</span><span class="sxs-lookup"><span data-stu-id="05703-310">Finalizers must be free of synchronization problems.</span></span> <span data-ttu-id="05703-311">請不要在完成項中使用靜態可變動狀態。</span><span class="sxs-lookup"><span data-stu-id="05703-311">Do not use a static mutable state in a finalizer.</span></span>

### <a name="avoid-unmanaged-memory-if-possible"></a><span data-ttu-id="05703-312">盡可能避免非受控記憶體</span><span class="sxs-lookup"><span data-stu-id="05703-312">Avoid unmanaged memory if possible</span></span>

<span data-ttu-id="05703-313">Unmanaged 記憶體可能會流失，就像作業系統控制代碼一樣。</span><span class="sxs-lookup"><span data-stu-id="05703-313">Unmanaged memory can be leaked, just like an operating system handle.</span></span> <span data-ttu-id="05703-314">可能的話，請嘗試使用 [stackalloc](../../csharp/language-reference/operators/stackalloc.md) 或釘選 Managed 物件 (例如 [fixed 陳述式](../../csharp/language-reference/keywords/fixed-statement.md)或使用 byte[] 的 <xref:System.Runtime.InteropServices.GCHandle>) 來使用堆疊上的記憶體。</span><span class="sxs-lookup"><span data-stu-id="05703-314">If possible, try to use memory on the stack using [stackalloc](../../csharp/language-reference/operators/stackalloc.md) or a pinned managed object such as the [fixed Statement](../../csharp/language-reference/keywords/fixed-statement.md) or a <xref:System.Runtime.InteropServices.GCHandle> using a byte[].</span></span> <span data-ttu-id="05703-315"><xref:System.GC> 最後會清除這些項目。</span><span class="sxs-lookup"><span data-stu-id="05703-315">The <xref:System.GC> eventually cleans these up.</span></span> <span data-ttu-id="05703-316">不過，如果您必須配置 Unmanaged 記憶體，請考慮使用衍生自 <xref:System.Runtime.InteropServices.SafeHandle> 的類別來包裝記憶體配置。</span><span class="sxs-lookup"><span data-stu-id="05703-316">However, if you must allocate unmanaged memory, consider using a class that derives from <xref:System.Runtime.InteropServices.SafeHandle> to wrap the memory allocation.</span></span>

<span data-ttu-id="05703-317">請注意，在至少一種情況下，<xref:System.Runtime.InteropServices.SafeHandle> 不足。</span><span class="sxs-lookup"><span data-stu-id="05703-317">Note that there is at least one case where <xref:System.Runtime.InteropServices.SafeHandle> is not adequate.</span></span> <span data-ttu-id="05703-318">針對配置或釋放記憶體的 COM 方法呼叫，其中一個 DLL 通常會透過 `CoTaskMemAlloc` 來配置記憶體，另一個 DLL 則使用 `CoTaskMemFree` 來釋放該記憶體。</span><span class="sxs-lookup"><span data-stu-id="05703-318">For COM method calls that allocate or free memory, it is common for one DLL to allocate memory via `CoTaskMemAlloc` then another DLL frees that memory with `CoTaskMemFree`.</span></span>  <span data-ttu-id="05703-319">不適合在這些位置使用 <xref:System.Runtime.InteropServices.SafeHandle>，因為它會嘗試將 Unmanaged 記憶體的存留期繫結至 <xref:System.Runtime.InteropServices.SafeHandle> 的存留期，而不是允許另一個 DLL 控制記憶體的存留期。</span><span class="sxs-lookup"><span data-stu-id="05703-319">Using <xref:System.Runtime.InteropServices.SafeHandle> in these places would be inappropriate since it will attempt to tie the lifetime of the unmanaged memory to the lifetime of the <xref:System.Runtime.InteropServices.SafeHandle> instead of allowing the other DLL control the lifetime of the memory.</span></span>

### <a name="review-all-uses-of-catchexception"></a><span data-ttu-id="05703-320">檢查 catch 的所有用法（例外狀況）</span><span class="sxs-lookup"><span data-stu-id="05703-320">Review all uses of catch(Exception)</span></span>

<span data-ttu-id="05703-321">擷取所有例外狀況 (而非一個特定例外狀況) 的 catch 區塊現在也會擷取非同步例外狀況。</span><span class="sxs-lookup"><span data-stu-id="05703-321">Catch blocks that catch all exceptions instead of one specific exception will now catch the asynchronous exceptions as well.</span></span> <span data-ttu-id="05703-322">檢查每個 catch(Exception) 區塊，以尋找沒有可能跳過的重要資源釋放或退出程式碼，以及處理 <xref:System.Threading.ThreadAbortException>、<xref:System.StackOverflowException> 或 <xref:System.OutOfMemoryException> 的 catch 區塊本身內可能不正確的行為。</span><span class="sxs-lookup"><span data-stu-id="05703-322">Examine every catch(Exception) block, looking for no important resource releasing or backout code that might be skipped, as well as potentially incorrect behavior within the catch block itself for handling a <xref:System.Threading.ThreadAbortException>, <xref:System.StackOverflowException>, or <xref:System.OutOfMemoryException>.</span></span>  <span data-ttu-id="05703-323">請注意，此程式碼可能會記錄或進行一些假設，這些假設是只能看到某些例外狀況，或者僅針對一種特殊原因，只要發生例外狀況就失敗。</span><span class="sxs-lookup"><span data-stu-id="05703-323">Note that it is possible this code might be logging or making some assumptions that it may only see certain exceptions, or that whenever an exception happens it failed for exactly one particular reason.</span></span>  <span data-ttu-id="05703-324">這些假設可能需要進行更新，以包含 <xref:System.Threading.ThreadAbortException>。</span><span class="sxs-lookup"><span data-stu-id="05703-324">These assumptions may need to be updated to include <xref:System.Threading.ThreadAbortException>.</span></span>

<span data-ttu-id="05703-325">請考慮變更可擷取所有例外狀況的所有位置，而這些例外狀況是在擷取您預期要擲回之特定類型的例外狀況時發生，例如字串格式化方法的 <xref:System.FormatException>。</span><span class="sxs-lookup"><span data-stu-id="05703-325">Consider changing all places that catch all exceptions to catching a specific type of exception that you expect will be thrown, such as a <xref:System.FormatException> from string formatting methods.</span></span>  <span data-ttu-id="05703-326">這會防止對非預期的例外狀況執行 catch 區塊，並且有助於確保程式碼因擷取到非預期的例外狀況而未隱藏 Bug。</span><span class="sxs-lookup"><span data-stu-id="05703-326">This prevents the catch block from running on unexpected exceptions and will help ensure the code does not hide bugs by catching unexpected exceptions.</span></span>  <span data-ttu-id="05703-327">因為一般規則絕不會處理程式庫程式碼中的例外狀況 (需要您擷取例外狀況的程式碼，可能指出所呼叫程式碼中的設計缺陷)。</span><span class="sxs-lookup"><span data-stu-id="05703-327">As a general rule never handle an exception in library code (code that requires you to catch an exception may indicate a design flaw in the code you are calling).</span></span>  <span data-ttu-id="05703-328">在某些情況下，您可能想要擷取例外狀況，並擲回不同的例外狀況類型來提供更多資料。</span><span class="sxs-lookup"><span data-stu-id="05703-328">In some cases you may want to catch an exception and throw a different exception type to provide more data.</span></span>  <span data-ttu-id="05703-329">在此情況下，請使用巢狀例外狀況，並將真正失敗原因儲存至新例外狀況的 <xref:System.Exception.InnerException%2A> 屬性中。</span><span class="sxs-lookup"><span data-stu-id="05703-329">Use nested exceptions in this case, storing the real cause of the failure in the <xref:System.Exception.InnerException%2A> property of the new exception.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="05703-330">程式碼分析規則</span><span class="sxs-lookup"><span data-stu-id="05703-330">Code analysis rule</span></span>

<span data-ttu-id="05703-331">檢閱所有使用 Managed 程式碼並擷取所有物件或擷取所有例外狀況的 catch 區塊。</span><span class="sxs-lookup"><span data-stu-id="05703-331">Review all catch blocks in managed code that catch all objects or catch all exceptions.</span></span>  <span data-ttu-id="05703-332">在 c # 中，這表示會同時標記 `catch` {} 和 `catch(Exception)` {} 。</span><span class="sxs-lookup"><span data-stu-id="05703-332">In C#, this means flagging both `catch` {} and `catch(Exception)` {}.</span></span>  <span data-ttu-id="05703-333">請考慮將例外狀況類型設為極為特別，或檢閱程式碼，確保它在擷取到非預期的例外狀況類型時不會以錯誤的方式操作。</span><span class="sxs-lookup"><span data-stu-id="05703-333">Consider making the exception type very specific, or review the code to ensure it does not act in a bad way if it catches an unexpected exception type.</span></span>

### <a name="do-not-assume-a-managed-thread-is-a-win32-thread--it-is-a-fiber"></a><span data-ttu-id="05703-334">不要假設受控執行緒是 Win32 執行緒–它是一個光纖</span><span class="sxs-lookup"><span data-stu-id="05703-334">Do not assume a managed thread is a Win32 thread – It is a Fiber</span></span>

<span data-ttu-id="05703-335">使用 Managed 執行緒區域儲存區確實會運作，但您可能不會使用 Unmanaged 執行緒區域儲存區，或假設程式碼將再次於目前作業系統執行緒上執行。</span><span class="sxs-lookup"><span data-stu-id="05703-335">Using managed thread local storage does work, but you may not use unmanaged thread local storage or assume the code will run on the current operating system thread again.</span></span> <span data-ttu-id="05703-336">請不要變更執行緒地區設定這類設定。</span><span class="sxs-lookup"><span data-stu-id="05703-336">Do not change settings like the thread’s locale.</span></span> <span data-ttu-id="05703-337">請不要透過平台叫用呼叫 `InitializeCriticalSection` 或 `CreateMutex`，因為它們需要進入鎖定的作業系統執行緒一併結束鎖定。</span><span class="sxs-lookup"><span data-stu-id="05703-337">Do not call `InitializeCriticalSection` or `CreateMutex` via platform invoke because they require the operating system thread that enters a lock also exit the lock.</span></span> <span data-ttu-id="05703-338">因為這不是使用 Fiber 的情況，所以 Win32 關鍵區段和 Mutex 不能直接用於 SQL 中。</span><span class="sxs-lookup"><span data-stu-id="05703-338">Since this will not be the case when using fibers, Win32 critical sections and mutexes cannot be used in SQL directly.</span></span>  <span data-ttu-id="05703-339">請注意，Managed <xref:System.Threading.Mutex> 類別未處理這些執行緒親和性考量。</span><span class="sxs-lookup"><span data-stu-id="05703-339">Note that the managed <xref:System.Threading.Mutex> class does not handle these thread affinity concerns.</span></span>

<span data-ttu-id="05703-340">您可以在 Managed <xref:System.Threading.Thread> 物件上安全地使用大部分狀態，包含 Managed 執行緒區域儲存區和執行緒的目前 UI 文化特性 (Culture)。</span><span class="sxs-lookup"><span data-stu-id="05703-340">You can safely use most of the state on a managed <xref:System.Threading.Thread> object, including managed thread local storage and the thread’s current UI culture.</span></span> <span data-ttu-id="05703-341">您也可以使用 <xref:System.ThreadStaticAttribute>，只讓目前 Managed 執行緒存取現有靜態變數的值 (這是在 CLR 中執行 Fiber 本機儲存體的另一種方式)。</span><span class="sxs-lookup"><span data-stu-id="05703-341">You can also use the <xref:System.ThreadStaticAttribute>, which makes the value of an existing static variable accessible only by the current managed thread (this is another way of doing fiber local storage in the CLR).</span></span> <span data-ttu-id="05703-342">基於程式設計模型考量，在 SQL 中執行時，您不可以變更執行緒的目前文化特性。</span><span class="sxs-lookup"><span data-stu-id="05703-342">For programming model reasons, you can not change the current culture of a thread when running in SQL.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="05703-343">程式碼分析規則</span><span class="sxs-lookup"><span data-stu-id="05703-343">Code analysis rule</span></span>

<span data-ttu-id="05703-344">SQL Server 會以 Fiber 模式執行；請不要使用執行緒區域儲存區。</span><span class="sxs-lookup"><span data-stu-id="05703-344">SQL Server runs in fiber mode; do not use thread local storage.</span></span> <span data-ttu-id="05703-345">請避免對 `TlsAlloc`、`TlsFree`、`TlsGetValue` 和 `TlsSetValue.` 執行平台叫用呼叫。</span><span class="sxs-lookup"><span data-stu-id="05703-345">Avoid platform invoke calls to `TlsAlloc`, `TlsFree`, `TlsGetValue`, and `TlsSetValue.`</span></span>

### <a name="let-sql-server-handle-impersonation"></a><span data-ttu-id="05703-346">讓 SQL Server 處理模擬</span><span class="sxs-lookup"><span data-stu-id="05703-346">Let SQL Server handle impersonation</span></span>

<span data-ttu-id="05703-347">因為模擬是在執行緒層級上運作，而且 SQL 可以透過 Fiber 模式執行，所以 Managed 程式碼應該不會模擬使用者，並且應該不會呼叫 `RevertToSelf`。</span><span class="sxs-lookup"><span data-stu-id="05703-347">Since impersonation operates on the thread level and SQL can run in fiber mode, managed code should not impersonate users, and should not call `RevertToSelf`.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="05703-348">程式碼分析規則</span><span class="sxs-lookup"><span data-stu-id="05703-348">Code analysis rule</span></span>

<span data-ttu-id="05703-349">讓 SQL Server 處理模擬。</span><span class="sxs-lookup"><span data-stu-id="05703-349">Let SQL Server handle impersonation.</span></span> <span data-ttu-id="05703-350">請不要使用 `RevertToSelf`、`ImpersonateAnonymousToken`、`DdeImpersonateClient`、`ImpersonateDdeClientWindow`、`ImpersonateLoggedOnUser`、`ImpersonateNamedPipeClient`、`ImpersonateSelf`、`RpcImpersonateClient`、`RpcRevertToSelf``RpcRevertToSelfEx` 或 `SetThreadToken`。</span><span class="sxs-lookup"><span data-stu-id="05703-350">Do not use `RevertToSelf`, `ImpersonateAnonymousToken`, `DdeImpersonateClient`, `ImpersonateDdeClientWindow`, `ImpersonateLoggedOnUser`, `ImpersonateNamedPipeClient`, `ImpersonateSelf`, `RpcImpersonateClient`, `RpcRevertToSelf`, `RpcRevertToSelfEx`, or `SetThreadToken`.</span></span>

### <a name="do-not-call-threadsuspend"></a><span data-ttu-id="05703-351">不要呼叫 Thread：：暫止</span><span class="sxs-lookup"><span data-stu-id="05703-351">Do not call Thread::Suspend</span></span>

<span data-ttu-id="05703-352">暫止執行緒的能力可能顯示為簡單作業，但可能會造成死結。</span><span class="sxs-lookup"><span data-stu-id="05703-352">The ability to suspend a thread may appear a simple operation, but it can cause deadlocks.</span></span>  <span data-ttu-id="05703-353">如果持有鎖定的執行緒是由第二個執行緒所暫止，然後第二個執行緒嘗試採用相同的鎖定，即會發生死結。</span><span class="sxs-lookup"><span data-stu-id="05703-353">If a thread holding a lock gets suspended by a second thread and then the second thread tries taking the same lock, a deadlock occurs.</span></span>  <span data-ttu-id="05703-354"><xref:System.Threading.Thread.Suspend%2A> 目前可能會干擾安全性、類別載入、遠端處理和反映。</span><span class="sxs-lookup"><span data-stu-id="05703-354"><xref:System.Threading.Thread.Suspend%2A> can interfere with security, class loading, remoting, and reflection currently.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="05703-355">程式碼分析規則</span><span class="sxs-lookup"><span data-stu-id="05703-355">Code analysis rule</span></span>

<span data-ttu-id="05703-356">請不要呼叫 <xref:System.Threading.Thread.Suspend%2A>。</span><span class="sxs-lookup"><span data-stu-id="05703-356">Do not call <xref:System.Threading.Thread.Suspend%2A>.</span></span> <span data-ttu-id="05703-357">請考慮改成使用實際同步處理原始物件，例如 <xref:System.Threading.Semaphore> 或 <xref:System.Threading.ManualResetEvent>。</span><span class="sxs-lookup"><span data-stu-id="05703-357">Consider using a real synchronization primitive instead, such as a <xref:System.Threading.Semaphore> or <xref:System.Threading.ManualResetEvent> .</span></span>

### <a name="protect-critical-operations-with-constrained-execution-regions-and-reliability-contracts"></a><span data-ttu-id="05703-358">使用受限制的執列區域和可靠性合約來保護重要作業</span><span class="sxs-lookup"><span data-stu-id="05703-358">Protect critical operations with constrained execution regions and reliability contracts</span></span>

<span data-ttu-id="05703-359">執行可更新共用狀態或需要確定完全成功或完全失敗的複雜作業時，請確定它受到限制的執行區域 (CER) 的保護。</span><span class="sxs-lookup"><span data-stu-id="05703-359">When performing a complex operation that updates a shared status or that needs to deterministically either fully succeed or fully fail, be sure that it is protected by a constrained execution region (CER).</span></span> <span data-ttu-id="05703-360">這保證程式碼可以在所有情況下執行，即使突然執行緒中止或突然 <xref:System.AppDomain> 卸載也是一樣。</span><span class="sxs-lookup"><span data-stu-id="05703-360">This guarantees that the code runs in every case, even an abrupt thread abort or an abrupt <xref:System.AppDomain> unload.</span></span>

<span data-ttu-id="05703-361">CER 是前面緊接 <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> 呼叫的特定 `try/finally` 區塊。</span><span class="sxs-lookup"><span data-stu-id="05703-361">A CER is a particular `try/finally` block immediately preceded by a call to <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A>.</span></span>

<span data-ttu-id="05703-362">這麼做會指示 Just-In-Time 編譯器在執行 `try` 區塊之前準備 finally 區塊中的所有程式碼。</span><span class="sxs-lookup"><span data-stu-id="05703-362">Doing so instructs the just-in-time compiler to prepare all the code in the finally block before running the `try` block.</span></span> <span data-ttu-id="05703-363">這保證會建置 finally 區塊中的程式碼，而且在所有情況下都會執行該程式碼。</span><span class="sxs-lookup"><span data-stu-id="05703-363">This guarantees that the code in the finally block is built and will run in all cases.</span></span> <span data-ttu-id="05703-364">CER 中通常不會有空的 `try` 區塊。</span><span class="sxs-lookup"><span data-stu-id="05703-364">It is not uncommon in a CER to have an empty `try` block.</span></span> <span data-ttu-id="05703-365">使用 CER 可防止非同步執行緒中止和記憶體不足例外狀況。</span><span class="sxs-lookup"><span data-stu-id="05703-365">Using a CER protects against asynchronous thread aborts and out-of-memory exceptions.</span></span> <span data-ttu-id="05703-366">請參閱 <xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A>，以了解可額外處理極深層程式碼堆疊溢位的 CER 形式。</span><span class="sxs-lookup"><span data-stu-id="05703-366">See <xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A> for a form of a CER that additionally handles stack overflows for exceedingly deep code.</span></span>

## <a name="see-also"></a><span data-ttu-id="05703-367">另請參閱</span><span class="sxs-lookup"><span data-stu-id="05703-367">See also</span></span>

- <xref:System.Runtime.ConstrainedExecution>
- [<span data-ttu-id="05703-368">SQL Server 程式設計和主機保護屬性</span><span class="sxs-lookup"><span data-stu-id="05703-368">SQL Server Programming and Host Protection Attributes</span></span>](sql-server-programming-and-host-protection-attributes.md)
