---
title: 延遲初始設定
description: 探索 .NET 中的延遲初始化，這項效能改進表示物件建立會延遲到第一次使用物件為止。
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- lazy initialization in .NET, introduction
ms.assetid: 56b4ae5c-4745-44ff-ad78-ffe4fcde6b9b
ms.openlocfilehash: 355fa326fc19e9a50a74e21ace0a6353f5c740c5
ms.sourcegitcommit: 3824ff187947572b274b9715b60c11269335c181
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 06/17/2020
ms.locfileid: "84904230"
---
# <a name="lazy-initialization"></a><span data-ttu-id="ad0d7-103">延遲初始設定</span><span class="sxs-lookup"><span data-stu-id="ad0d7-103">Lazy Initialization</span></span>
<span data-ttu-id="ad0d7-104">物件的「延遲初始設定」\*\* 表示物件一直延遲到第一次使用才建立。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-104">*Lazy initialization* of an object means that its creation is deferred until it is first used.</span></span> <span data-ttu-id="ad0d7-105">（本主題中的「*延遲初始化*」和「延遲具現*化*」這一詞是同義的）。延遲初始化主要是用來改善效能、避免浪費計算，以及減少程式記憶體需求。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-105">(For this topic, the terms *lazy initialization* and *lazy instantiation* are synonymous.) Lazy initialization is primarily used to improve performance, avoid wasteful computation, and reduce program memory requirements.</span></span> <span data-ttu-id="ad0d7-106">以下為最常見的案例：</span><span class="sxs-lookup"><span data-stu-id="ad0d7-106">These are the most common scenarios:</span></span>  
  
- <span data-ttu-id="ad0d7-107">當建立某個物件會耗費大量資源，而程式可能不使用它時。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-107">When you have an object that is expensive to create, and the program might not use it.</span></span> <span data-ttu-id="ad0d7-108">例如，假設您在記憶體中有 `Customer` 物件，它的 `Orders` 屬性包含大型的 `Order` 物件陣列，其初始化需要連接資料庫。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-108">For example, assume that you have in memory a `Customer` object that has an `Orders` property that contains a large array of `Order` objects that, to be initialized, requires a database connection.</span></span> <span data-ttu-id="ad0d7-109">如果使用者從未要求顯示訂單，或使用資料進行計算，就沒必要使用系統記憶體或計算週期來建立它。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-109">If the user never asks to display the Orders or use the data in a computation, then there is no reason to use system memory or computing cycles to create it.</span></span> <span data-ttu-id="ad0d7-110">使用 `Lazy<Orders>` 宣告延遲初始設定 `Orders` 物件，可在不使用物件時，避免浪費系統資源。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-110">By using `Lazy<Orders>` to declare the `Orders` object for lazy initialization, you can avoid wasting system resources when the object is not used.</span></span>  
  
- <span data-ttu-id="ad0d7-111">當建立某個物件會耗費大量資源，而您想要延遲到完成其他耗費資源的作業後，再建立它。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-111">When you have an object that is expensive to create, and you want to defer its creation until after other expensive operations have been completed.</span></span> <span data-ttu-id="ad0d7-112">例如，假設當程式啟動時會載入數個物件執行個體，但只有部分是立即需要的。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-112">For example, assume that your program loads several object instances when it starts, but only some of them are required immediately.</span></span> <span data-ttu-id="ad0d7-113">您可以延遲到必要的物件皆已建立後，再對不需要的物件進行初始設定，以改善程式的啟動效能。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-113">You can improve the startup performance of the program by deferring initialization of the objects that are not required until the required objects have been created.</span></span>  
  
 <span data-ttu-id="ad0d7-114">雖然您可以自行撰寫程式碼執行延遲初始設定，但仍建議您改用 <xref:System.Lazy%601>。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-114">Although you can write your own code to perform lazy initialization, we recommend that you use <xref:System.Lazy%601> instead.</span></span> <span data-ttu-id="ad0d7-115"><xref:System.Lazy%601> 及其相關類型也支援安全執行緒，並提供一致的例外狀況傳播原則。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-115"><xref:System.Lazy%601> and its related types also support thread-safety and provide a consistent exception propagation policy.</span></span>  
  
 <span data-ttu-id="ad0d7-116">下表列出 .NET Framework 第 4 版提供的類型，以在不同案例中啟用延遲初始化。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-116">The following table lists the types that the .NET Framework version 4 provides to enable lazy initialization in different scenarios.</span></span>  
  
|<span data-ttu-id="ad0d7-117">類型</span><span class="sxs-lookup"><span data-stu-id="ad0d7-117">Type</span></span>|<span data-ttu-id="ad0d7-118">描述</span><span class="sxs-lookup"><span data-stu-id="ad0d7-118">Description</span></span>|  
|----------|-----------------|  
|<xref:System.Lazy%601>|<span data-ttu-id="ad0d7-119">為任何類別庫或使用者定義類型提供延遲初始化語意的包裝函式類別。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-119">A wrapper class that provides lazy initialization semantics for any class library or user-defined type.</span></span>|  
|<xref:System.Threading.ThreadLocal%601>|<span data-ttu-id="ad0d7-120">類似於 <xref:System.Lazy%601>，不同之處在於它是在執行緒區域上提供延遲初始化語意。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-120">Resembles <xref:System.Lazy%601> except that it provides lazy initialization semantics on a thread-local basis.</span></span> <span data-ttu-id="ad0d7-121">每個執行緒都可以存取自己的唯一值。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-121">Every thread has access to its own unique value.</span></span>|  
|<xref:System.Threading.LazyInitializer>|<span data-ttu-id="ad0d7-122">為物件的延遲初始設定提供進階 `static` (Visual Basic 為 `Shared`) 方法，沒有類別的額外負荷。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-122">Provides advanced `static` (`Shared` in Visual Basic) methods for lazy initialization of objects without the overhead of a class.</span></span>|  
  
## <a name="basic-lazy-initialization"></a><span data-ttu-id="ad0d7-123">基本延遲初始設定</span><span class="sxs-lookup"><span data-stu-id="ad0d7-123">Basic Lazy Initialization</span></span>  
 <span data-ttu-id="ad0d7-124">若要定義延遲初始化類型，例如 `MyType`，請使用 `Lazy<MyType>` (Visual Basic 為 `Lazy(Of MyType)`)，如下列範例所示。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-124">To define a lazy-initialized type, for example, `MyType`, use `Lazy<MyType>` (`Lazy(Of MyType)` in Visual Basic), as shown in the following example.</span></span> <span data-ttu-id="ad0d7-125">如果沒有委派傳入 <xref:System.Lazy%601> 建構函式，第一次存取 Value 屬性時，會使用 <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> 建立包裝類型。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-125">If no delegate is passed in the <xref:System.Lazy%601> constructor, the wrapped type is created by using <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> when the value property is first accessed.</span></span> <span data-ttu-id="ad0d7-126">如果類型沒有無參數的函式，則會擲回執行時間例外狀況。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-126">If the type does not have a parameterless constructor, a run-time exception is thrown.</span></span>  
  
 <span data-ttu-id="ad0d7-127">在下例中，假設 `Orders` 是類別，包含從資料庫擷取的 `Order` 物件陣列。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-127">In the following example, assume that `Orders` is a class that contains an array of `Order` objects retrieved from a database.</span></span> <span data-ttu-id="ad0d7-128">`Customer` 物件包含 `Orders` 的執行個體，但視使用者的動作而 定，可能不需要來自 `Orders` 物件的資料。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-128">A `Customer` object contains an instance of `Orders`, but depending on user actions, the data from the `Orders` object might not be required.</span></span>  
  
 [!code-csharp[Lazy#1](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#1)]
 [!code-vb[Lazy#1](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#1)]  
  
 <span data-ttu-id="ad0d7-129">您也可以在 <xref:System.Lazy%601> 建構函式中傳遞委派，此建構函式會在特定時間於包裝類型上叫用特定的建構函式多載，執行任何其他需要的初始設定步驟，如下列範例中所示。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-129">You can also pass a delegate in the <xref:System.Lazy%601> constructor that invokes a specific constructor overload on the wrapped type at creation time, and perform any other initialization steps that are required, as shown in the following example.</span></span>  
  
 [!code-csharp[Lazy#2](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#2)]
 [!code-vb[Lazy#2](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#2)]  
  
 <span data-ttu-id="ad0d7-130">建立延遲物件後，要到第一次存取延遲變數的 <xref:System.Lazy%601.Value%2A> 屬性後，才會建立 `Orders` 的執行個體。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-130">After the Lazy object is created, no instance of `Orders` is created until the <xref:System.Lazy%601.Value%2A> property of the Lazy variable is accessed for the first time.</span></span> <span data-ttu-id="ad0d7-131">第一次存取時，會建立並傳回包裝類型，儲存以供未來存取。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-131">On first access, the wrapped type is created and returned, and stored for any future access.</span></span>  
  
 [!code-csharp[Lazy#3](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#3)]
 [!code-vb[Lazy#3](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#3)]  
  
 <span data-ttu-id="ad0d7-132"><xref:System.Lazy%601> 物件一律傳回相同的物件或隨之初始化的值。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-132">A <xref:System.Lazy%601> object always returns the same object or value that it was initialized with.</span></span> <span data-ttu-id="ad0d7-133">因此，<xref:System.Lazy%601.Value%2A> 屬性是唯讀的。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-133">Therefore, the <xref:System.Lazy%601.Value%2A> property is read-only.</span></span> <span data-ttu-id="ad0d7-134">如果 <xref:System.Lazy%601.Value%2A> 儲存參考型別，您就無法指派新的物件給它。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-134">If <xref:System.Lazy%601.Value%2A> stores a reference type, you cannot assign a new object to it.</span></span> <span data-ttu-id="ad0d7-135">（不過，您可以變更其可設定的公用欄位和屬性的值）。如果 <xref:System.Lazy%601.Value%2A> 儲存實值型別，您就無法修改其值。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-135">(However, you can change the value of its settable public fields and properties.) If <xref:System.Lazy%601.Value%2A> stores a value type, you cannot modify its value.</span></span> <span data-ttu-id="ad0d7-136">不過，您可以使用新的引數再次叫用變數的建構函式，建立新的變數。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-136">Nevertheless, you can create a new variable by invoking the variable constructor again by using new arguments.</span></span>  
  
 [!code-csharp[Lazy#4](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#4)]
 [!code-vb[Lazy#4](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#4)]  
  
 <span data-ttu-id="ad0d7-137">新的延遲執行個體，像舊版一樣，一直要到第一次存取其 <xref:System.Lazy%601.Value%2A> 屬性後，才會具現化 `Orders`。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-137">The new lazy instance, like the earlier one, does not instantiate `Orders` until its <xref:System.Lazy%601.Value%2A> property is first accessed.</span></span>  
  
### <a name="thread-safe-initialization"></a><span data-ttu-id="ad0d7-138">初始化安全執行緒</span><span class="sxs-lookup"><span data-stu-id="ad0d7-138">Thread-Safe Initialization</span></span>  
 <span data-ttu-id="ad0d7-139">根據預設，<xref:System.Lazy%601> 物件是安全執行緒。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-139">By default, <xref:System.Lazy%601> objects are thread-safe.</span></span> <span data-ttu-id="ad0d7-140">也就是說，如果建構函式不指定執行緒安全的種類，它建立的 <xref:System.Lazy%601> 物件就會是安全執行緒。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-140">That is, if the constructor does not specify the kind of thread safety, the <xref:System.Lazy%601> objects it creates are thread-safe.</span></span> <span data-ttu-id="ad0d7-141">在多執行緒案例中，第一個存取安全執行緒 <xref:System.Lazy%601> 物件的 <xref:System.Lazy%601.Value%2A> 屬性的執行緒，會將它初始化以在所有的執行緒上進行所有的後續存取，且所有執行緒都共用相同的資料。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-141">In multi-threaded scenarios, the first thread to access the <xref:System.Lazy%601.Value%2A> property of a thread-safe <xref:System.Lazy%601> object initializes it for all subsequent accesses on all threads, and all threads share the same data.</span></span> <span data-ttu-id="ad0d7-142">因此，哪個執行緒初始化物件不重要，只要是良性的競爭條件即可。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-142">Therefore, it does not matter which thread initializes the object, and race conditions are benign.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="ad0d7-143">您可以使用快取例外狀況，擴充錯誤條件的一致性。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-143">You can extend this consistency to error conditions by using exception caching.</span></span> <span data-ttu-id="ad0d7-144">如需詳細資訊，請參閱下一節[延遲物件的例外狀況](lazy-initialization.md#ExceptionsInLazyObjects)。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-144">For more information, see the next section, [Exceptions in Lazy Objects](lazy-initialization.md#ExceptionsInLazyObjects).</span></span>  
  
 <span data-ttu-id="ad0d7-145">下列範例示範，相同的 `Lazy<int>` 執行個體在三個不同的執行緒有相同的值。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-145">The following example shows that the same `Lazy<int>` instance has the same value for three separate threads.</span></span>  
  
 [!code-csharp[Lazy#8](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#8)]
 [!code-vb[Lazy#8](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#8)]  
  
 <span data-ttu-id="ad0d7-146">如果每個執行緒需要個別的資料，請使用 <xref:System.Threading.ThreadLocal%601> 類型，如本主題稍後所述。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-146">If you require separate data on each thread, use the <xref:System.Threading.ThreadLocal%601> type, as described later in this topic.</span></span>  
  
 <span data-ttu-id="ad0d7-147">某些 <xref:System.Lazy%601> 建構函式有名為 `isThreadSafe` 的布林參數，用來指定是否從多個執行緒存取 <xref:System.Lazy%601.Value%2A> 屬性。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-147">Some <xref:System.Lazy%601> constructors have a Boolean parameter named `isThreadSafe` that is used to specify whether the <xref:System.Lazy%601.Value%2A> property will be accessed from multiple threads.</span></span> <span data-ttu-id="ad0d7-148">如果您只打算從一個執行緒存取屬性，請傳入 `false` 以取得適度的效能優勢。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-148">If you intend to access the property from just one thread, pass in `false` to obtain a modest performance benefit.</span></span> <span data-ttu-id="ad0d7-149">如果打算從多個執行緒存取屬性，請傳入 `true` 指示 <xref:System.Lazy%601> 執行個體正確處理一個執行緒在初始化階段擲出例外狀況的競爭條件。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-149">If you intend to access the property from multiple threads, pass in `true` to instruct the <xref:System.Lazy%601> instance to correctly handle race conditions in which one thread throws an exception at initialization time.</span></span>  
  
 <span data-ttu-id="ad0d7-150">某些 <xref:System.Lazy%601> 建構函式有名為 `mode` 的 <xref:System.Threading.LazyThreadSafetyMode> 參數。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-150">Some <xref:System.Lazy%601> constructors have a <xref:System.Threading.LazyThreadSafetyMode> parameter named `mode`.</span></span> <span data-ttu-id="ad0d7-151">這些建構函式提供其他的執行緒安全性模式。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-151">These constructors provide an additional thread safety mode.</span></span> <span data-ttu-id="ad0d7-152">下表顯示指定執行緒安全性的建構函式參數如何影響 <xref:System.Lazy%601> 物件的執行緒安全性。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-152">The following table shows how the thread safety of a <xref:System.Lazy%601> object is affected by constructor parameters that specify thread safety.</span></span> <span data-ttu-id="ad0d7-153">每個建構函式最多只有一個這類參數。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-153">Each constructor has at most one such parameter.</span></span>  
  
|<span data-ttu-id="ad0d7-154">物件的執行緒安全性</span><span class="sxs-lookup"><span data-stu-id="ad0d7-154">Thread safety of the object</span></span>|<span data-ttu-id="ad0d7-155">`LazyThreadSafetyMode``mode`參數</span><span class="sxs-lookup"><span data-stu-id="ad0d7-155">`LazyThreadSafetyMode` `mode` parameter</span></span>|<span data-ttu-id="ad0d7-156">布林 `isThreadSafe` 參數</span><span class="sxs-lookup"><span data-stu-id="ad0d7-156">Boolean `isThreadSafe` parameter</span></span>|<span data-ttu-id="ad0d7-157">沒有執行緒安全性參數</span><span class="sxs-lookup"><span data-stu-id="ad0d7-157">No thread safety parameters</span></span>|  
|---------------------------------|---------------------------------------------|--------------------------------------|---------------------------------|  
|<span data-ttu-id="ad0d7-158">完整的安全執行緒，一次只有一個執行緒嘗試初始化值。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-158">Fully thread-safe; only one thread at a time tries to initialize the value.</span></span>|<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>|`true`|<span data-ttu-id="ad0d7-159">可以。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-159">Yes.</span></span>|  
|<span data-ttu-id="ad0d7-160">不具備安全執行緒。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-160">Not thread-safe.</span></span>|<xref:System.Threading.LazyThreadSafetyMode.None>|`false`|<span data-ttu-id="ad0d7-161">不適用。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-161">Not applicable.</span></span>|  
|<span data-ttu-id="ad0d7-162">完整的安全執行緒，多個執行緒競相初始化值。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-162">Fully thread-safe; threads race to initialize the value.</span></span>|<xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>|<span data-ttu-id="ad0d7-163">不適用。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-163">Not applicable.</span></span>|<span data-ttu-id="ad0d7-164">不適用。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-164">Not applicable.</span></span>|  
  
 <span data-ttu-id="ad0d7-165">如本表所示，指定 `mode` 參數的 <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> 如同指定 `isThreadSafe` 參數的 `true`，而指定 <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> 如同指定 `false`。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-165">As the table shows, specifying <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> for the `mode` parameter is the same as specifying `true` for the `isThreadSafe` parameter, and specifying <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> is the same as specifying `false`.</span></span>  
  
 <span data-ttu-id="ad0d7-166">指定 <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> 可讓多個執行緒嘗試初始化 <xref:System.Lazy%601> 執行個體。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-166">Specifying <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> allows multiple threads to attempt to initialize the <xref:System.Lazy%601> instance.</span></span> <span data-ttu-id="ad0d7-167">只有一個執行緒可贏得這場競賽，所有其他的執行緒都會收到成功的執行緒所初始化的值。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-167">Only one thread can win this race, and all the other threads receive the value that was initialized by the successful thread.</span></span> <span data-ttu-id="ad0d7-168">如果在初始化期間，對執行緒擲回例外狀況，該執行緒就不會收到成功的執行緒所設定的值。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-168">If an exception is thrown on a thread during initialization, that thread does not receive the value set by the successful thread.</span></span> <span data-ttu-id="ad0d7-169">例外狀況不會被快取，所以後續嘗試存取 <xref:System.Lazy%601.Value%2A> 屬性會導致成功初始化。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-169">Exceptions are not cached, so a subsequent attempt to access the <xref:System.Lazy%601.Value%2A> property can result in successful initialization.</span></span> <span data-ttu-id="ad0d7-170">這不同於其他方法處理例外狀況的方式，下節中會對此加以說明。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-170">This differs from the way exceptions are treated in other modes, which is described in the following section.</span></span> <span data-ttu-id="ad0d7-171">如需詳細資訊，請參閱 <xref:System.Threading.LazyThreadSafetyMode> 列舉。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-171">For more information, see the <xref:System.Threading.LazyThreadSafetyMode> enumeration.</span></span>  
  
<a name="ExceptionsInLazyObjects"></a>
## <a name="exceptions-in-lazy-objects"></a><span data-ttu-id="ad0d7-172">延遲物件的例外狀況</span><span class="sxs-lookup"><span data-stu-id="ad0d7-172">Exceptions in Lazy Objects</span></span>  
 <span data-ttu-id="ad0d7-173">如前所述，<xref:System.Lazy%601> 物件一律會傳回隨之初始化的相同物件或值，因此 <xref:System.Lazy%601.Value%2A> 屬性是唯讀的。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-173">As stated earlier, a <xref:System.Lazy%601> object always returns the same object or value that it was initialized with, and therefore the <xref:System.Lazy%601.Value%2A> property is read-only.</span></span> <span data-ttu-id="ad0d7-174">如果啟用例外狀況快取，此不變性也會延伸至例外狀況行為。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-174">If you enable exception caching, this immutability also extends to exception behavior.</span></span> <span data-ttu-id="ad0d7-175">如果延遲初始化的物件已啟用例外狀況快取，並在第一次存取屬性時，從其初始化方法擲回例外狀況 <xref:System.Lazy%601.Value%2A> ，則每次嘗試存取屬性時，就會擲回相同的例外狀況 <xref:System.Lazy%601.Value%2A> 。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-175">If a lazy-initialized object has exception caching enabled and throws an exception from its initialization method when the <xref:System.Lazy%601.Value%2A> property is first accessed, that same exception is thrown on every subsequent attempt to access the <xref:System.Lazy%601.Value%2A> property.</span></span> <span data-ttu-id="ad0d7-176">換句話說，即使在多執行緒案例中，也絕對不會重新叫用包裝類型的建構函式。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-176">In other words, the constructor of the wrapped type is never re-invoked, even in multithreaded scenarios.</span></span> <span data-ttu-id="ad0d7-177">因此，<xref:System.Lazy%601> 物件無法在某次存取中擲回例外狀況，並在後續存取中傳回值。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-177">Therefore, the <xref:System.Lazy%601> object cannot throw an exception on one access and return a value on a subsequent access.</span></span>  
  
 <span data-ttu-id="ad0d7-178">當您使用任何採用初始設定方法 (`valueFactory` 參數) 的 <xref:System.Lazy%601?displayProperty=nameWithType> 建構函式時，就啟用了例外狀況快取；例如，它會在您使用 `Lazy(T)(Func(T))` 建構函式時啟用。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-178">Exception caching is enabled when you use any <xref:System.Lazy%601?displayProperty=nameWithType> constructor that takes an initialization method (`valueFactory` parameter); for example, it is enabled when you use the `Lazy(T)(Func(T))`constructor.</span></span> <span data-ttu-id="ad0d7-179">如果建構函式也採用 <xref:System.Threading.LazyThreadSafetyMode> 值 (`mode` 參數)，請指定 <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> 或 <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-179">If the constructor also takes a <xref:System.Threading.LazyThreadSafetyMode> value (`mode` parameter), specify <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> or <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>.</span></span> <span data-ttu-id="ad0d7-180">指定初始設定方法，可啟用這兩種模式的例外狀況快取。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-180">Specifying an initialization method enables exception caching for these two modes.</span></span> <span data-ttu-id="ad0d7-181">初始設定方法可以非常簡單。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-181">The initialization method can be very simple.</span></span> <span data-ttu-id="ad0d7-182">例如，它可能會呼叫 c # 中的無參數的函式 `T` `new Lazy<Contents>(() => new Contents(), mode)` ，或 `New Lazy(Of Contents)(Function() New Contents())` Visual Basic 中的。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-182">For example, it might call the parameterless constructor for `T`: `new Lazy<Contents>(() => new Contents(), mode)` in C#, or `New Lazy(Of Contents)(Function() New Contents())` in Visual Basic.</span></span> <span data-ttu-id="ad0d7-183">如果您使用未指定初始設定方法的 <xref:System.Lazy%601?displayProperty=nameWithType> 建構函式，則不會快取 `T` 的無參數建構函式所擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-183">If you use a <xref:System.Lazy%601?displayProperty=nameWithType> constructor that does not specify an initialization method, exceptions that are thrown by the parameterless constructor for `T` are not cached.</span></span> <span data-ttu-id="ad0d7-184">如需詳細資訊，請參閱 <xref:System.Threading.LazyThreadSafetyMode> 列舉。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-184">For more information, see the <xref:System.Threading.LazyThreadSafetyMode> enumeration.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="ad0d7-185">如果您建立的 <xref:System.Lazy%601> 物件是將 `isThreadSafe` 建構函式參數設定為 `false`，或將 `mode` 建構函式參數設定為 <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>，您即必須從單一執行緒存取 <xref:System.Lazy%601> 物件，或提供您自己的同步處理。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-185">If you create a <xref:System.Lazy%601> object with the `isThreadSafe` constructor parameter set to `false` or the `mode` constructor parameter set to <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>, you must access the <xref:System.Lazy%601> object from a single thread or provide your own synchronization.</span></span> <span data-ttu-id="ad0d7-186">這適用該物件的所有層面，包括例外狀況快取。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-186">This applies to all aspects of the object, including exception caching.</span></span>  
  
 <span data-ttu-id="ad0d7-187">如前一節中所述，透過指定 <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> 所建立的 <xref:System.Lazy%601> 物件，會以不同的方式處理例外狀況。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-187">As noted in the previous section, <xref:System.Lazy%601> objects created by specifying <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> treat exceptions differently.</span></span> <span data-ttu-id="ad0d7-188">有了 <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>，多個執行緒可爭奪初始化 <xref:System.Lazy%601> 執行個體。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-188">With <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>, multiple threads can compete to initialize the <xref:System.Lazy%601> instance.</span></span> <span data-ttu-id="ad0d7-189">本例中未快取例外狀況，但會繼續嘗試存取 <xref:System.Lazy%601.Value%2A> 屬性，直到成功初始化。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-189">In this case, exceptions are not cached, and attempts to access the <xref:System.Lazy%601.Value%2A> property can continue until initialization is successful.</span></span>  
  
 <span data-ttu-id="ad0d7-190">下表摘要說明 <xref:System.Lazy%601> 建構函式控制例外狀況快取的方式。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-190">The following table summarizes the way the <xref:System.Lazy%601> constructors control exception caching.</span></span>  
  
|<span data-ttu-id="ad0d7-191">建構函式</span><span class="sxs-lookup"><span data-stu-id="ad0d7-191">Constructor</span></span>|<span data-ttu-id="ad0d7-192">執行緒安全模式</span><span class="sxs-lookup"><span data-stu-id="ad0d7-192">Thread safety mode</span></span>|<span data-ttu-id="ad0d7-193">使用初始設定方法</span><span class="sxs-lookup"><span data-stu-id="ad0d7-193">Uses initialization method</span></span>|<span data-ttu-id="ad0d7-194">已快取例外狀況</span><span class="sxs-lookup"><span data-stu-id="ad0d7-194">Exceptions are cached</span></span>|  
|-----------------|------------------------|--------------------------------|---------------------------|  
|<span data-ttu-id="ad0d7-195">Lazy(T)()</span><span class="sxs-lookup"><span data-stu-id="ad0d7-195">Lazy(T)()</span></span>|<span data-ttu-id="ad0d7-196">(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>)</span><span class="sxs-lookup"><span data-stu-id="ad0d7-196">(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>)</span></span>|<span data-ttu-id="ad0d7-197">否</span><span class="sxs-lookup"><span data-stu-id="ad0d7-197">No</span></span>|<span data-ttu-id="ad0d7-198">否</span><span class="sxs-lookup"><span data-stu-id="ad0d7-198">No</span></span>|  
|<span data-ttu-id="ad0d7-199">Lazy(T)(Func(T))</span><span class="sxs-lookup"><span data-stu-id="ad0d7-199">Lazy(T)(Func(T))</span></span>|<span data-ttu-id="ad0d7-200">(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>)</span><span class="sxs-lookup"><span data-stu-id="ad0d7-200">(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>)</span></span>|<span data-ttu-id="ad0d7-201">是</span><span class="sxs-lookup"><span data-stu-id="ad0d7-201">Yes</span></span>|<span data-ttu-id="ad0d7-202">是</span><span class="sxs-lookup"><span data-stu-id="ad0d7-202">Yes</span></span>|  
|<span data-ttu-id="ad0d7-203">Lazy(T)(Boolean)</span><span class="sxs-lookup"><span data-stu-id="ad0d7-203">Lazy(T)(Boolean)</span></span>|<span data-ttu-id="ad0d7-204">`True` (<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>) 或 `false` (<xref:System.Threading.LazyThreadSafetyMode.None>)</span><span class="sxs-lookup"><span data-stu-id="ad0d7-204">`True` (<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>) or `false` (<xref:System.Threading.LazyThreadSafetyMode.None>)</span></span>|<span data-ttu-id="ad0d7-205">否</span><span class="sxs-lookup"><span data-stu-id="ad0d7-205">No</span></span>|<span data-ttu-id="ad0d7-206">否</span><span class="sxs-lookup"><span data-stu-id="ad0d7-206">No</span></span>|  
|<span data-ttu-id="ad0d7-207">Lazy(T)(Func(T), Boolean)</span><span class="sxs-lookup"><span data-stu-id="ad0d7-207">Lazy(T)(Func(T), Boolean)</span></span>|<span data-ttu-id="ad0d7-208">`True` (<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>) 或 `false` (<xref:System.Threading.LazyThreadSafetyMode.None>)</span><span class="sxs-lookup"><span data-stu-id="ad0d7-208">`True` (<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>) or `false` (<xref:System.Threading.LazyThreadSafetyMode.None>)</span></span>|<span data-ttu-id="ad0d7-209">是</span><span class="sxs-lookup"><span data-stu-id="ad0d7-209">Yes</span></span>|<span data-ttu-id="ad0d7-210">是</span><span class="sxs-lookup"><span data-stu-id="ad0d7-210">Yes</span></span>|  
|<span data-ttu-id="ad0d7-211">Lazy(T)(LazyThreadSafetyMode)</span><span class="sxs-lookup"><span data-stu-id="ad0d7-211">Lazy(T)(LazyThreadSafetyMode)</span></span>|<span data-ttu-id="ad0d7-212">使用者指定的</span><span class="sxs-lookup"><span data-stu-id="ad0d7-212">User-specified</span></span>|<span data-ttu-id="ad0d7-213">否</span><span class="sxs-lookup"><span data-stu-id="ad0d7-213">No</span></span>|<span data-ttu-id="ad0d7-214">否</span><span class="sxs-lookup"><span data-stu-id="ad0d7-214">No</span></span>|  
|<span data-ttu-id="ad0d7-215">Lazy(T)(Func(T), LazyThreadSafetyMode)</span><span class="sxs-lookup"><span data-stu-id="ad0d7-215">Lazy(T)(Func(T), LazyThreadSafetyMode)</span></span>|<span data-ttu-id="ad0d7-216">使用者指定的</span><span class="sxs-lookup"><span data-stu-id="ad0d7-216">User-specified</span></span>|<span data-ttu-id="ad0d7-217">Yes</span><span class="sxs-lookup"><span data-stu-id="ad0d7-217">Yes</span></span>|<span data-ttu-id="ad0d7-218">如果使用者指定了 <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly> 則為否；否則為是。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-218">No if user specifies <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>; otherwise, yes.</span></span>|  
  
## <a name="implementing-a-lazy-initialized-property"></a><span data-ttu-id="ad0d7-219">實作延遲初始化的屬性</span><span class="sxs-lookup"><span data-stu-id="ad0d7-219">Implementing a Lazy-Initialized Property</span></span>  
 <span data-ttu-id="ad0d7-220">若要使用延遲初始設定來實作公用屬性，請將屬性的支援欄位定義為 <xref:System.Lazy%601>，並從屬性的 `get` 存取子傳回 <xref:System.Lazy%601.Value%2A> 屬性。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-220">To implement a public property by using lazy initialization, define the backing field of the property as a <xref:System.Lazy%601>, and return the <xref:System.Lazy%601.Value%2A> property from the `get` accessor of the property.</span></span>  
  
 [!code-csharp[Lazy#5](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#5)]
 [!code-vb[Lazy#5](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#5)]  
  
 <span data-ttu-id="ad0d7-221"><xref:System.Lazy%601.Value%2A> 屬性是唯讀的；因此，公開它的屬性沒有任何 `set` 存取子。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-221">The <xref:System.Lazy%601.Value%2A> property is read-only; therefore, the property that exposes it has no `set` accessor.</span></span> <span data-ttu-id="ad0d7-222">如果您需要 <xref:System.Lazy%601> 物件支援的讀取/寫入屬性，`set` 存取子必須建立新的 <xref:System.Lazy%601> 物件，並指派到備份存放區。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-222">If you require a read/write property backed by a <xref:System.Lazy%601> object, the `set` accessor must create a new <xref:System.Lazy%601> object and assign it to the backing store.</span></span> <span data-ttu-id="ad0d7-223">`set` 存取子必須建立 Lambda 運算式，傳回已傳遞給 `set` 存取子的新屬性值，並將該 Lambda 運算式傳遞至新 <xref:System.Lazy%601> 物件的建構函式。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-223">The `set` accessor must create a lambda expression that returns the new property value that was passed to the `set` accessor, and pass that lambda expression to the constructor for the new <xref:System.Lazy%601> object.</span></span> <span data-ttu-id="ad0d7-224">下一次存取 <xref:System.Lazy%601.Value%2A> 屬性會初始化新的 <xref:System.Lazy%601>，且其 <xref:System.Lazy%601.Value%2A> 屬性之後也會傳回已指派給屬性的新值。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-224">The next access of the <xref:System.Lazy%601.Value%2A> property will cause initialization of the new <xref:System.Lazy%601>, and its <xref:System.Lazy%601.Value%2A> property will thereafter return the new value that was assigned to the property.</span></span> <span data-ttu-id="ad0d7-225">之所以如此迂迴排列，是為了保留內建在 <xref:System.Lazy%601> 的多執行緒保護。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-225">The reason for this convoluted arrangement is to preserve the multithreading protections built into <xref:System.Lazy%601>.</span></span> <span data-ttu-id="ad0d7-226">否則，屬性存取子就必須快取 <xref:System.Lazy%601.Value%2A> 屬性傳回的第一個值，且只能修改快取的值，而您則必須撰寫自己的執行緒安全程式碼以完成此作業。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-226">Otherwise, the property accessors would have to cache the first value returned by the <xref:System.Lazy%601.Value%2A> property and only modify the cached value, and you would have to write your own thread-safe code to do that.</span></span> <span data-ttu-id="ad0d7-227">因為 <xref:System.Lazy%601> 物件支援的讀取/寫入屬性需要額外的初始設定，效能可能不太令人滿意。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-227">Because of the additional initializations required by a read/write property backed by a <xref:System.Lazy%601> object, the performance might not be acceptable.</span></span> <span data-ttu-id="ad0d7-228">此外，根據特定的案例，可能需要其他協調以避免 setter 與 getter 之間的競爭條件。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-228">Furthermore, depending on the specific scenario, additional coordination might be required to avoid race conditions between setters and getters.</span></span>  
  
## <a name="thread-local-lazy-initialization"></a><span data-ttu-id="ad0d7-229">執行緒區域延遲初始設定</span><span class="sxs-lookup"><span data-stu-id="ad0d7-229">Thread-Local Lazy Initialization</span></span>  
 <span data-ttu-id="ad0d7-230">在某些多執行緒的情況下，您可能想要向各執行緒提供它專用的私用資料。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-230">In some multithreaded scenarios, you might want to give each thread its own private data.</span></span> <span data-ttu-id="ad0d7-231">這類資料稱為「執行緒區域資料」\*\*。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-231">Such data is called *thread-local data*.</span></span> <span data-ttu-id="ad0d7-232">在 .NET Framework 3.5 版或更舊的版本中，您可以將 `ThreadStatic` 屬性套用到靜態變數，使其成為執行緒區域變數。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-232">In the .NET Framework version 3.5 and earlier, you could apply the `ThreadStatic` attribute to a static variable to make it thread-local.</span></span> <span data-ttu-id="ad0d7-233">不過，使用 `ThreadStatic` 屬性可能會導致極其細小的錯誤。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-233">However, using the `ThreadStatic` attribute can lead to subtle errors.</span></span> <span data-ttu-id="ad0d7-234">例如，即使基本的初始化陳述式，也只會在第一個存取它的執行緒上初始化變數，如下列範例所示。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-234">For example, even basic initialization statements will cause the variable to be initialized only on the first thread that accesses it, as shown in the following example.</span></span>  
  
 [!code-csharp[Lazy#6](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#6)]
 [!code-vb[Lazy#6](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#6)]  
  
 <span data-ttu-id="ad0d7-235">在所有其他的執行緒上，變數都是使用其預設值 (零) 來初始化。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-235">On all other threads, the variable will be initialized by using its default value (zero).</span></span> <span data-ttu-id="ad0d7-236">在 .NET Framework 第 4 版中它是替代方案，您可以使用 <xref:System.Threading.ThreadLocal%601?displayProperty=nameWithType> 類型建立執行個體式的執行緒本機變數，由您提供的 <xref:System.Action%601> 委派在所有執行緒上初始化。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-236">As an alternative in the .NET Framework version 4, you can use the <xref:System.Threading.ThreadLocal%601?displayProperty=nameWithType> type to create an instance-based, thread-local variable that is initialized on all threads by the <xref:System.Action%601> delegate that you provide.</span></span> <span data-ttu-id="ad0d7-237">在下列範例中，存取 `counter` 的所有執行緒都會看到其起始值為 1。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-237">In the following example, all threads that access `counter` will see its starting value as 1.</span></span>  
  
 [!code-csharp[Lazy#7](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#7)]
 [!code-vb[Lazy#7](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#7)]  
  
 <span data-ttu-id="ad0d7-238"><xref:System.Threading.ThreadLocal%601> 包裝其物件的方法，和 <xref:System.Lazy%601> 極其相似，但有以下基本差異：</span><span class="sxs-lookup"><span data-stu-id="ad0d7-238"><xref:System.Threading.ThreadLocal%601> wraps its object in much the same way as <xref:System.Lazy%601>, with these essential differences:</span></span>  
  
- <span data-ttu-id="ad0d7-239">每個執行緒都是使用不能從其他執行緒存取的專用私用資料，來初始化執行緒區域變數。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-239">Each thread initializes the thread-local variable by using its own private data that is not accessible from other threads.</span></span>  
  
- <span data-ttu-id="ad0d7-240"><xref:System.Threading.ThreadLocal%601.Value%2A?displayProperty=nameWithType> 屬性是讀寫的，不限修改次數。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-240">The <xref:System.Threading.ThreadLocal%601.Value%2A?displayProperty=nameWithType> property is read-write, and can be modified any number of times.</span></span> <span data-ttu-id="ad0d7-241">這會影響例外狀況傳播，例如，一個 `get` 作業可能會引發例外狀況，但下一個卻可以成功初始化值。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-241">This can affect exception propagation, for example, one `get` operation can raise an exception but the next one can successfully initialize the value.</span></span>  
  
- <span data-ttu-id="ad0d7-242">如未提供任何初始設定委派，則 <xref:System.Threading.ThreadLocal%601> 會使用預設的類型值初始化其包裝類型。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-242">If no initialization delegate is provided, <xref:System.Threading.ThreadLocal%601> will initialize its wrapped type by using the default value of the type.</span></span> <span data-ttu-id="ad0d7-243">在這方面，<xref:System.Threading.ThreadLocal%601> 和 <xref:System.ThreadStaticAttribute> 屬性一致。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-243">In this regard, <xref:System.Threading.ThreadLocal%601> is consistent with the <xref:System.ThreadStaticAttribute> attribute.</span></span>  
  
 <span data-ttu-id="ad0d7-244">下列範例示範，存取 `ThreadLocal<int>` 執行個體的每一個執行緒都會取得自己唯一的資料複本。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-244">The following example demonstrates that every thread that accesses the `ThreadLocal<int>` instance gets its own unique copy of the data.</span></span>  
  
 [!code-csharp[Lazy#9](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#9)]
 [!code-vb[Lazy#9](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#9)]  
  
## <a name="thread-local-variables-in-parallelfor-and-foreach"></a><span data-ttu-id="ad0d7-245">Parallel.For 和 ForEach 的執行緒區域變數</span><span class="sxs-lookup"><span data-stu-id="ad0d7-245">Thread-Local Variables in Parallel.For and ForEach</span></span>  
 <span data-ttu-id="ad0d7-246">當您使用 <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> 方法或 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> 方法平行逐一查看資料來源時，您可以使用有執行緒區域資料內建支援的多載。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-246">When you use the <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> method or <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method to iterate over data sources in parallel, you can use the overloads that have built-in support for thread-local data.</span></span> <span data-ttu-id="ad0d7-247">在這些方法中，執行緒位置是使用本機委派建立、存取和清除資料所達成的。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-247">In these methods, the thread-locality is achieved by using local delegates to create, access, and clean up the data.</span></span> <span data-ttu-id="ad0d7-248">如需詳細資訊，請參閱[如何：撰寫含有執行緒區域變數的 Parallel.For 迴圈](../../standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md)和[如何：撰寫含有分割區域變數的 Parallel.ForEach 迴圈](../../standard/parallel-programming/how-to-write-a-parallel-foreach-loop-with-partition-local-variables.md)。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-248">For more information, see [How to: Write a Parallel.For Loop with Thread-Local Variables](../../standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md) and [How to: Write a Parallel.ForEach Loop with Partition-Local Variables](../../standard/parallel-programming/how-to-write-a-parallel-foreach-loop-with-partition-local-variables.md).</span></span>  
  
## <a name="using-lazy-initialization-for-low-overhead-scenarios"></a><span data-ttu-id="ad0d7-249">低負荷情況下使用延遲初始設定</span><span class="sxs-lookup"><span data-stu-id="ad0d7-249">Using Lazy Initialization for Low-Overhead Scenarios</span></span>  
 <span data-ttu-id="ad0d7-250">在必須延遲初始化大量物件的情況下，您可能會判定，包裝 <xref:System.Lazy%601> 中的每個物件需要太多記憶體或太多的運算資源。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-250">In scenarios where you have to lazy-initialize a large number of objects, you might decide that wrapping each object in a <xref:System.Lazy%601> requires too much memory or too many computing resources.</span></span> <span data-ttu-id="ad0d7-251">或者，您可能對延遲初始設定的公開方式有嚴格的要求。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-251">Or, you might have stringent requirements about how lazy initialization is exposed.</span></span> <span data-ttu-id="ad0d7-252">在這種情況下，您可以使用 <xref:System.Threading.LazyInitializer?displayProperty=nameWithType> 類別的 `static` (Visual Basic 為 `Shared`) 方法，延遲初始化每個物件，不將它包裝在 <xref:System.Lazy%601> 的執行個體中。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-252">In such cases, you can use the `static` (`Shared` in Visual Basic) methods of the <xref:System.Threading.LazyInitializer?displayProperty=nameWithType> class to lazy-initialize each object without wrapping it in an instance of <xref:System.Lazy%601>.</span></span>  
  
 <span data-ttu-id="ad0d7-253">在下列範例中，假設不將整個 `Orders` 物件包裝在一個 <xref:System.Lazy%601> 物件中，您只有在必要時才會延遲初始化個別的 `Order` 物件。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-253">In the following example, assume that, instead of wrapping an entire `Orders` object in one <xref:System.Lazy%601> object, you have lazy-initialized individual `Order` objects only if they are required.</span></span>  
  
 [!code-csharp[Lazy#10](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#10)]
 [!code-vb[Lazy#10](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#10)]  
  
 <span data-ttu-id="ad0d7-254">請注意，本例是在每次反覆迴圈時叫用初始化程序。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-254">In this example, notice that the initialization procedure is invoked on every iteration of the loop.</span></span> <span data-ttu-id="ad0d7-255">在多執行緒案例中，第一個叫用初始化程序的執行緒，其值會被所有執行緒看到。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-255">In multi-threaded scenarios, the first thread to invoke the initialization procedure is the one whose value is seen by all threads.</span></span> <span data-ttu-id="ad0d7-256">後續其他執行緒也會叫用初始化程序，但其結果不被採用。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-256">Later threads also invoke the initialization procedure, but their results are not used.</span></span> <span data-ttu-id="ad0d7-257">如果無法接受這種潛在的競爭條件，請使用採用布林值引數和同步處理物件的 <xref:System.Threading.LazyInitializer.EnsureInitialized%2A?displayProperty=nameWithType> 多載。</span><span class="sxs-lookup"><span data-stu-id="ad0d7-257">If this kind of potential race condition is not acceptable, use the overload of <xref:System.Threading.LazyInitializer.EnsureInitialized%2A?displayProperty=nameWithType> that takes a Boolean argument and a synchronization object.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="ad0d7-258">另請參閱</span><span class="sxs-lookup"><span data-stu-id="ad0d7-258">See also</span></span>

- [<span data-ttu-id="ad0d7-259">Managed 執行緒基本概念</span><span class="sxs-lookup"><span data-stu-id="ad0d7-259">Managed Threading Basics</span></span>](../../standard/threading/managed-threading-basics.md)
- [<span data-ttu-id="ad0d7-260">執行緒和執行緒處理</span><span class="sxs-lookup"><span data-stu-id="ad0d7-260">Threads and Threading</span></span>](../../standard/threading/threads-and-threading.md)
- [<span data-ttu-id="ad0d7-261">工作平行程式庫 (TPL)</span><span class="sxs-lookup"><span data-stu-id="ad0d7-261">Task Parallel Library (TPL)</span></span>](../../standard/parallel-programming/task-parallel-library-tpl.md)
- [<span data-ttu-id="ad0d7-262">如何：執行物件的延遲初始化</span><span class="sxs-lookup"><span data-stu-id="ad0d7-262">How to: Perform Lazy Initialization of Objects</span></span>](how-to-perform-lazy-initialization-of-objects.md)
