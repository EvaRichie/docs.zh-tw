---
title: 執行個體鎖定的例外狀況動作
ms.date: 03/30/2017
ms.assetid: 164a5419-315c-4987-ad72-54cbdb88d402
ms.openlocfilehash: 3554975589bb6d55cef3611320d25687d1ee9ba6
ms.sourcegitcommit: bc293b14af795e0e999e3304dd40c0222cf2ffe4
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 11/26/2020
ms.locfileid: "96279853"
---
# <a name="instance-locked-exception-action"></a><span data-ttu-id="4036b-102">執行個體鎖定的例外狀況動作</span><span class="sxs-lookup"><span data-stu-id="4036b-102">Instance Locked Exception Action</span></span>

<span data-ttu-id="4036b-103">SQL 工作流程執行個體存放區的 <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore.InstanceLockedExceptionAction%2A> 屬性可讓您指定當 SQL 持續性提供者收到 <xref:System.Runtime.DurableInstancing.InstanceLockedException> 時應執行的動作。</span><span class="sxs-lookup"><span data-stu-id="4036b-103">The <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore.InstanceLockedExceptionAction%2A> property of the SQL Workflow Instance Store lets you specify what action the SQL persistence provider should take when it receives an <xref:System.Runtime.DurableInstancing.InstanceLockedException>.</span></span> <span data-ttu-id="4036b-104">當持續性提供者嘗試鎖定目前由其他服務主機鎖定的工作流程服務執行個體時，就會收到這個例外狀況。</span><span class="sxs-lookup"><span data-stu-id="4036b-104">The persistence provider receives this exception when it tries to lock a workflow service instance that is currently locked by another service host.</span></span> <span data-ttu-id="4036b-105">此屬性的值為 <xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.NoRetry>、<xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.BasicRetry> 和 <xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.AggressiveRetry>。</span><span class="sxs-lookup"><span data-stu-id="4036b-105">The values for this property are <xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.NoRetry>, <xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.BasicRetry>, and <xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.AggressiveRetry>.</span></span> <span data-ttu-id="4036b-106">預設值為 <xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.NoRetry>。</span><span class="sxs-lookup"><span data-stu-id="4036b-106">The default value is <xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.NoRetry>.</span></span> <span data-ttu-id="4036b-107">下列清單描述這三種選項：</span><span class="sxs-lookup"><span data-stu-id="4036b-107">The following list describes the three options:</span></span>  
  
- <span data-ttu-id="4036b-108"><xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.NoRetry>.</span><span class="sxs-lookup"><span data-stu-id="4036b-108"><xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.NoRetry>.</span></span> <span data-ttu-id="4036b-109">服務主機不會嘗試鎖定工作流程服務實例，並將傳遞 <xref:System.Runtime.DurableInstancing.InstanceLockedException> 給呼叫端。</span><span class="sxs-lookup"><span data-stu-id="4036b-109">The service host does not attempt to lock the workflow service instance and passes the <xref:System.Runtime.DurableInstancing.InstanceLockedException> to the caller.</span></span>  <span data-ttu-id="4036b-110">如果工作流程停留在記憶體中的期間超過60秒，請使用 <xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.NoRetry> 做為重試。</span><span class="sxs-lookup"><span data-stu-id="4036b-110">If your workflow stays in memory for a period exceeding 60 seconds, use <xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.NoRetry> as the retry.</span></span> <span data-ttu-id="4036b-111">預設值為 <xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.NoRetry>。</span><span class="sxs-lookup"><span data-stu-id="4036b-111">The default value is <xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.NoRetry>.</span></span>  
  
- <span data-ttu-id="4036b-112"><xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.BasicRetry>.</span><span class="sxs-lookup"><span data-stu-id="4036b-112"><xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.BasicRetry>.</span></span> <span data-ttu-id="4036b-113">服務主機在每次重試之間以線性間隔重新嘗試鎖定工作流程服務執行個體，並在序列結尾處將 <xref:System.Runtime.DurableInstancing.InstanceLockedException> 傳遞給呼叫端。</span><span class="sxs-lookup"><span data-stu-id="4036b-113">The service host reattempts to lock the workflow service instance with a linear interval between retry attempts and passes the <xref:System.Runtime.DurableInstancing.InstanceLockedException> to the caller at the end of the sequence.</span></span> <span data-ttu-id="4036b-114">如果工作流程停留在記憶體中 5-60 秒，並且郵件會分批到達，可能會將訊息傳送到同一個主機的同一個執行個體上，以便在卸載工作流程之前處理所有訊息，使用 <xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.BasicRetry> 在不浪費資源的情況下達到最佳延遲。</span><span class="sxs-lookup"><span data-stu-id="4036b-114">If you workflow stays in memory approximately between 5-60 seconds, and messages arrive in batches where it is more likely for messages being sent to the same instance on the same host to process all messages before unloading the workflow, use <xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.BasicRetry> to achieve the best latency without wasting resources.</span></span>  
  
- <span data-ttu-id="4036b-115"><xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.AggressiveRetry>.</span><span class="sxs-lookup"><span data-stu-id="4036b-115"><xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.AggressiveRetry>.</span></span> <span data-ttu-id="4036b-116">服務主機在每次重試之間以後退演算法間隔重新嘗試鎖定工作流程服務執行個體，並在序列結尾處將例外狀況傳遞給呼叫端。</span><span class="sxs-lookup"><span data-stu-id="4036b-116">The service host reattempts to lock the workflow service instance with an exponential backoff interval between retry attempts, and passes the exception to the caller at the end of the sequence.</span></span> <span data-ttu-id="4036b-117">如果工作流程停留在記憶體中的時間非常短 (不到 5 秒)，或者 Web 伺服陣列非常大，且將另一個訊息傳送到同一個主機的機率不高，請使用<xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.AggressiveRetry> 達到最佳的延遲。</span><span class="sxs-lookup"><span data-stu-id="4036b-117">If your workflow stays in memory for a very short time (less than 5 seconds), or a Web farm is large and the chance of another message being delivered to the same host is not very high, use <xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.AggressiveRetry> to achieve the best latency.</span></span>  
  
 <span data-ttu-id="4036b-118">執行個體鎖定的例外狀況動作功能支援下列案例。</span><span class="sxs-lookup"><span data-stu-id="4036b-118">The Instance Locked Exception Action feature supports the following scenarios.</span></span> <span data-ttu-id="4036b-119">在所有案例中，如果 SqlWorkflowInstanceStore 的 instanceLockedExceptionAction 屬性設為 <xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.BasicRetry> 或 <xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.AggressiveRetry>，主機會公開地定期重試取得鎖定執行個體。</span><span class="sxs-lookup"><span data-stu-id="4036b-119">In all scenarios, if the instanceLockedExceptionAction property of the SqlWorkflowInstanceStore is set to <xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.BasicRetry> or <xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.AggressiveRetry>, the host transparently retries to acquire the lock on instances periodically.</span></span>  
  
1. <span data-ttu-id="4036b-120">**啟用正常關機與應用程式定義域重疊回收：**</span><span class="sxs-lookup"><span data-stu-id="4036b-120">**Enabling graceful shutdown and overlapped recycling of application domains.**</span></span> <span data-ttu-id="4036b-121">假設具有正在執行工作流程服務實例之服務主機的 **appdomain** 正在回收，而新的 **appdomain** 將會以平行方式處理新的要求，而舊的 **appdomain** 會正常關閉。</span><span class="sxs-lookup"><span data-stu-id="4036b-121">Suppose an **AppDomain** with a service host running workflow service instances is being recycled and a new **AppDomain** is brought up to handle new requests in parallel while the old **AppDomain** is brought down gracefully.</span></span> <span data-ttu-id="4036b-122">關機作業會等到工作流程服務執行個體閒置時才進行，然後才保存及卸載執行個體。</span><span class="sxs-lookup"><span data-stu-id="4036b-122">The shutdown waits until workflow service instances are idle, and then persists and unloads the instances.</span></span> <span data-ttu-id="4036b-123">當新 **AppDomain** 中的主機嘗試鎖定實例時，會造成 <xref:System.Runtime.DurableInstancing.InstanceLockedException> 。</span><span class="sxs-lookup"><span data-stu-id="4036b-123">Any attempts by hosts in the new **AppDomain** to lock an instance will cause an <xref:System.Runtime.DurableInstancing.InstanceLockedException>.</span></span>  
  
2. <span data-ttu-id="4036b-124">**水準調整跨同質伺服器陣列的持久工作流程。**</span><span class="sxs-lookup"><span data-stu-id="4036b-124">**Horizontally scaling durable workflows across a homogeneous farm of servers.**</span></span> <span data-ttu-id="4036b-125">假設正在執行工作流程執行個體的伺服器陣列節點當機，且該工作流程主機無法移除其所執行之執行個體的鎖定。</span><span class="sxs-lookup"><span data-stu-id="4036b-125">Suppose a node of a server farm on which a workflow instance is running crashes and the workflow host cannot remove locks on the instance it is running.</span></span> <span data-ttu-id="4036b-126">在伺服器陣列其他節點上執行的服務主機收到給該工作流程的訊息時，該服務主機就會嘗試取得鎖定這些會收到 <xref:System.Runtime.DurableInstancing.InstanceLockedException> 的執行個體。</span><span class="sxs-lookup"><span data-stu-id="4036b-126">When a service host running on another node of the farm receives a message for that workflow instance, it tries to acquire locks on these instances it will receive the <xref:System.Runtime.DurableInstancing.InstanceLockedException>.</span></span> <span data-ttu-id="4036b-127">鎖定會在一段時間後逾期，因為應更新鎖定的主機已不存在。</span><span class="sxs-lookup"><span data-stu-id="4036b-127">The locks will expire after some time because the host that was supposed to renew the lock no longer exists.</span></span>  
  
     <span data-ttu-id="4036b-128">**水準調整跨同質伺服器陣列的持久工作流程。**</span><span class="sxs-lookup"><span data-stu-id="4036b-128">**Horizontally scaling durable workflows across a homogeneous farm of servers.**</span></span>  <span data-ttu-id="4036b-129">假設您要使用 NLB (網路負載平衡器) 之後的多部主機水平縮放長期工作流程，在其中一個陣列節點上執行的工作流程主機會載入工作流程執行個體並處理訊息，傳送至該執行個體的下一個訊息會路由至執行在其他節點上執行的主機，因為 NLB 沒有可將訊息傳遞至已執行該執行個體之主機的路由演算法。</span><span class="sxs-lookup"><span data-stu-id="4036b-129">Suppose you want to horizontally scale a durable workflow using multiple hosts behind a NLB (Network Load Balancer), the workflow host running on one node of the farm loads a workflow instance and is processing a message, and the next message to the instance is routed to the host that is running on another node because the NLB does not have routing algorithm to deliver messages to the host that is already running the instance.</span></span> <span data-ttu-id="4036b-130">第二部主機收到訊息時，會嘗試載入工作流程執行個體並接收 <xref:System.Runtime.DurableInstancing.InstanceLockedException>，因為第一部主機已在該執行個體上鎖定。</span><span class="sxs-lookup"><span data-stu-id="4036b-130">Upon receiving the message, the second host attempts to load the workflow instance and receives the <xref:System.Runtime.DurableInstancing.InstanceLockedException> because the first host has a lock on the instance.</span></span> <span data-ttu-id="4036b-131">第一部主機會在完成處理第一個訊息時解除鎖定該執行個體，而第二部主機會在下次重試時取得鎖定、載入執行個體，並且處理第二個訊息。</span><span class="sxs-lookup"><span data-stu-id="4036b-131">The first host unlocks the instance when it is finished with processing the first message and the second host acquires the lock when it retries the next time, loads the instance, and processes the second message.</span></span>
