---
title: 持續性的最佳作法
ms.date: 03/30/2017
ms.assetid: 6974c5a4-1af8-4732-ab53-7d694608a3a0
ms.openlocfilehash: 950a5d5c742b7882db93d71f3e7f205009f2a863
ms.sourcegitcommit: bc293b14af795e0e999e3304dd40c0222cf2ffe4
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 11/26/2020
ms.locfileid: "96246143"
---
# <a name="persistence-best-practices"></a><span data-ttu-id="ef3ac-102">持續性的最佳作法</span><span class="sxs-lookup"><span data-stu-id="ef3ac-102">Persistence Best Practices</span></span>

<span data-ttu-id="ef3ac-103">本文件包含與工作流程持續性相關之工作流程設計與組態的最佳作法。</span><span class="sxs-lookup"><span data-stu-id="ef3ac-103">This document covers best practices for workflow design and configuration related to workflow persistence.</span></span>  
  
## <a name="design-and-implementation-of-durable-workflows"></a><span data-ttu-id="ef3ac-104">設計及實作永久性工作流程</span><span class="sxs-lookup"><span data-stu-id="ef3ac-104">Design and Implementation of Durable Workflows</span></span>  

 <span data-ttu-id="ef3ac-105">一般來說，工作流程會在時間交錯的短期內工作，因為工作流程在這段期間內正在等候事件，所以會處於閒置狀態。</span><span class="sxs-lookup"><span data-stu-id="ef3ac-105">In general, workflows perform work in short periods that are interleaved with times during which the workflow is idle because it is waiting for an event.</span></span> <span data-ttu-id="ef3ac-106">這個事件可以是訊息或到期計時器等項目。</span><span class="sxs-lookup"><span data-stu-id="ef3ac-106">This event can be such things as a message or an expiring timer.</span></span> <span data-ttu-id="ef3ac-107">為了要能夠在工作流程執行個體閒置時將它卸載，服務主機必須保存工作流程執行個體。</span><span class="sxs-lookup"><span data-stu-id="ef3ac-107">To be able to unload the workflow instance when it becomes idle, the service host must persist the workflow instance.</span></span> <span data-ttu-id="ef3ac-108">只有當工作流程執行個體不在非保存區域時才可行 (例如，正在等候異動完成或等候非同步回呼)。</span><span class="sxs-lookup"><span data-stu-id="ef3ac-108">This is possible only if the workflow instance is not in a no-persist zone (for example, waiting for a transaction to complete, or waiting for an asynchronous callback).</span></span> <span data-ttu-id="ef3ac-109">若要允許卸載閒置的工作流程執行個體，工作流程作者應該只針對短期的動作使用交易範圍和非同步活動。</span><span class="sxs-lookup"><span data-stu-id="ef3ac-109">To allow an idle workflow instance to unload, the workflow author should use transaction scopes and asynchronous activities for short-lived actions only.</span></span> <span data-ttu-id="ef3ac-110">特別是，作者應該將這些非保存區域中的延遲活動盡量縮短。</span><span class="sxs-lookup"><span data-stu-id="ef3ac-110">In particular, the author should keep delay activities within these no-persist zones as short as possible.</span></span>  
  
 <span data-ttu-id="ef3ac-111">只有當工作流程所使用的所有資料型別都可序列化時，才能保存工作流程。</span><span class="sxs-lookup"><span data-stu-id="ef3ac-111">A workflow can only be persisted if all of the data types used by the workflow are serializable.</span></span> <span data-ttu-id="ef3ac-112">此外，保存之工作流程中所使用的自訂型別必須可以使用 <xref:System.Runtime.Serialization.NetDataContractSerializer> 來序列化，才能由 <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore> 保存。</span><span class="sxs-lookup"><span data-stu-id="ef3ac-112">In addition, custom types used in persisted workflows must be serializable with <xref:System.Runtime.Serialization.NetDataContractSerializer> in order to be persisted by <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore>.</span></span>  
  
 <span data-ttu-id="ef3ac-113">萬一主機或電腦故障，如果工作流程執行個體尚未保存就無法復原。</span><span class="sxs-lookup"><span data-stu-id="ef3ac-113">A workflow instance cannot be recovered in case of a host or computer failure if it has not been persisted.</span></span> <span data-ttu-id="ef3ac-114">一般來說，我們建議您在工作流程生命週期的早期保存工作流程執行個體。</span><span class="sxs-lookup"><span data-stu-id="ef3ac-114">In general, we recommend that you persist a workflow instance early in the workflow’s life cycle.</span></span>  
  
 <span data-ttu-id="ef3ac-115">如果您的工作流程會忙碌一段很長的時間，我們建議您在整段忙碌期間定期保存工作流程執行個體。</span><span class="sxs-lookup"><span data-stu-id="ef3ac-115">If your workflow is busy for a long time, we recommend that you persist the workflow instance regularly throughout its busy period.</span></span> <span data-ttu-id="ef3ac-116">若要這樣做，請在維持工作流程執行個體忙碌的整個活動序列中加入 <xref:System.Activities.Statements.Persist> 活動。</span><span class="sxs-lookup"><span data-stu-id="ef3ac-116">You can do this by adding <xref:System.Activities.Statements.Persist> activities throughout the sequence of activities that keep the workflow instance busy.</span></span> <span data-ttu-id="ef3ac-117">如此一來，應用程式定義域回收、主機故障或電腦故障就不會造成系統必須回復到忙碌期間的開頭。</span><span class="sxs-lookup"><span data-stu-id="ef3ac-117">In this manner, application domain recycling, host failures, or computer failures do not cause the system to be rolled back to the start of the busy period.</span></span> <span data-ttu-id="ef3ac-118">請注意，將 <xref:System.Activities.Statements.Persist> 活動加入至您的工作流程可能會造成效能的降低。</span><span class="sxs-lookup"><span data-stu-id="ef3ac-118">Be aware that adding <xref:System.Activities.Statements.Persist> activities to your workflow could lead to a degradation of performance.</span></span>  
  
 <span data-ttu-id="ef3ac-119">Windows Server App Fabric 會大幅簡化持續性的組態與使用。</span><span class="sxs-lookup"><span data-stu-id="ef3ac-119">Windows Server App Fabric greatly simplifies the configuration and use of persistence.</span></span> <span data-ttu-id="ef3ac-120">如需詳細資訊，請參閱[Windows Server App Fabric 持續](/previous-versions/appfabric/ee677272(v=azure.10))性</span><span class="sxs-lookup"><span data-stu-id="ef3ac-120">For more information, see [Windows Server App Fabric Persistence](/previous-versions/appfabric/ee677272(v=azure.10))</span></span>  
  
## <a name="configuration-of-scalability-parameters"></a><span data-ttu-id="ef3ac-121">延展性參數的組態</span><span class="sxs-lookup"><span data-stu-id="ef3ac-121">Configuration of Scalability Parameters</span></span>  

 <span data-ttu-id="ef3ac-122">延展性和效能需求會決定以下參數的設定：</span><span class="sxs-lookup"><span data-stu-id="ef3ac-122">Scalability and performance requirements determine the settings of the following parameters:</span></span>  
  
- <xref:System.ServiceModel.Activities.Description.WorkflowIdleBehavior.TimeToPersist%2A>  
  
- <xref:System.ServiceModel.Activities.Description.WorkflowIdleBehavior.TimeToUnload%2A>  
  
- <xref:System.ServiceModel.Activities.Description.SqlWorkflowInstanceStoreBehavior.InstanceLockedExceptionAction%2A>  
  
 <span data-ttu-id="ef3ac-123">這些參數應該根據目前的情況，依照以下方式設定。</span><span class="sxs-lookup"><span data-stu-id="ef3ac-123">These parameters should be set as follows, according to the current scenario.</span></span>  
  
### <a name="scenario-a-small-number-of-workflow-instances-that-require-optimal-response-time"></a><span data-ttu-id="ef3ac-124">案例：需要最佳回應時間的少量工作流程執行個體</span><span class="sxs-lookup"><span data-stu-id="ef3ac-124">Scenario: A Small Number of Workflow Instances That Require Optimal Response Time</span></span>  

 <span data-ttu-id="ef3ac-125">在此案例中，當所有工作流程執行個體閒置時，都應該維持已載入的狀態。</span><span class="sxs-lookup"><span data-stu-id="ef3ac-125">In this scenario, all workflow instances should remain loaded when they become idle.</span></span> <span data-ttu-id="ef3ac-126">請將 <xref:System.ServiceModel.Activities.Description.WorkflowIdleBehavior.TimeToUnload%2A> 設定為大的值。</span><span class="sxs-lookup"><span data-stu-id="ef3ac-126">Set <xref:System.ServiceModel.Activities.Description.WorkflowIdleBehavior.TimeToUnload%2A> to a large value.</span></span> <span data-ttu-id="ef3ac-127">使用這項設定會防止工作流程執行個體在電腦之間移動。</span><span class="sxs-lookup"><span data-stu-id="ef3ac-127">The use of this setting prevents a workflow instance from moving between computers.</span></span> <span data-ttu-id="ef3ac-128">只有當下列其中一個或多個條件成立時，才能使用這項設定：</span><span class="sxs-lookup"><span data-stu-id="ef3ac-128">Use this setting only if one or more of the following are true:</span></span>  
  
- <span data-ttu-id="ef3ac-129">工作流程執行個體在它的整個存留期都會收到單一訊息。</span><span class="sxs-lookup"><span data-stu-id="ef3ac-129">A workflow instance receives a single message throughout its lifetime.</span></span>  
  
- <span data-ttu-id="ef3ac-130">所有工作流程執行個體都在單一電腦上執行</span><span class="sxs-lookup"><span data-stu-id="ef3ac-130">All workflow instances run on a single computer</span></span>  
  
- <span data-ttu-id="ef3ac-131">工作流程執行個體所接收的所有訊息都會由同一部電腦所接收。</span><span class="sxs-lookup"><span data-stu-id="ef3ac-131">All messages that are received by a workflow instance are received by the same computer.</span></span>  
  
 <span data-ttu-id="ef3ac-132">請使用 <xref:System.Activities.Statements.Persist> 活動或是將 <xref:System.ServiceModel.Activities.Description.WorkflowIdleBehavior.TimeToPersist%2A> 設定為 0，以便在服務主機或電腦故障之後復原您的工作流程執行個體。</span><span class="sxs-lookup"><span data-stu-id="ef3ac-132">Use <xref:System.Activities.Statements.Persist> activities or set <xref:System.ServiceModel.Activities.Description.WorkflowIdleBehavior.TimeToPersist%2A> to 0 to enable recovery of your workflow instance after service host or computer failures.</span></span>  
  
### <a name="scenario-workflow-instances-are-idle-for-long-periods-of-time"></a><span data-ttu-id="ef3ac-133">案例：工作流程執行個體閒置很長的期間</span><span class="sxs-lookup"><span data-stu-id="ef3ac-133">Scenario: Workflow Instances Are Idle for Long Periods of Time</span></span>  

 <span data-ttu-id="ef3ac-134">在此案例中，將 <xref:System.ServiceModel.Activities.Description.WorkflowIdleBehavior.TimeToUnload%2A> 設定為 0 來盡快釋出資源。</span><span class="sxs-lookup"><span data-stu-id="ef3ac-134">In this scenario, set <xref:System.ServiceModel.Activities.Description.WorkflowIdleBehavior.TimeToUnload%2A> to 0 to release resources as soon as possible.</span></span>  
  
### <a name="scenario-workflow-instances-receive-multiple-messages-in-a-short-period-of-time"></a><span data-ttu-id="ef3ac-135">案例：工作流程執行個體在短期內收到多個訊息</span><span class="sxs-lookup"><span data-stu-id="ef3ac-135">Scenario: Workflow Instances Receive Multiple Messages in a Short Period of Time</span></span>  

 <span data-ttu-id="ef3ac-136">在此案例中，如果這些訊息是由同一部電腦所接收，請將 <xref:System.ServiceModel.Activities.Description.WorkflowIdleBehavior.TimeToUnload%2A> 設定為 60 秒。</span><span class="sxs-lookup"><span data-stu-id="ef3ac-136">In this scenario, set <xref:System.ServiceModel.Activities.Description.WorkflowIdleBehavior.TimeToUnload%2A> to 60 seconds if these messages are received by the same computer.</span></span> <span data-ttu-id="ef3ac-137">這樣會避免卸載及載入工作流程執行個體的快速序列。</span><span class="sxs-lookup"><span data-stu-id="ef3ac-137">This prevents a rapid sequence of unloading and loading of a workflow instance.</span></span> <span data-ttu-id="ef3ac-138">這樣也讓執行個體不會保存在記憶體中太久。</span><span class="sxs-lookup"><span data-stu-id="ef3ac-138">This also does not keep the instance in memory for too long.</span></span>  
  
 <span data-ttu-id="ef3ac-139">如果這些訊息可能會由不同電腦收到，請將 <xref:System.ServiceModel.Activities.Description.WorkflowIdleBehavior.TimeToUnload%2A> 設定為 0，並將 <xref:System.ServiceModel.Activities.Description.SqlWorkflowInstanceStoreBehavior.InstanceLockedExceptionAction%2A> 設定為 BasicRetry 或 AggressiveRetry。</span><span class="sxs-lookup"><span data-stu-id="ef3ac-139">Set <xref:System.ServiceModel.Activities.Description.WorkflowIdleBehavior.TimeToUnload%2A> to 0, and set <xref:System.ServiceModel.Activities.Description.SqlWorkflowInstanceStoreBehavior.InstanceLockedExceptionAction%2A> to BasicRetry or AggressiveRetry if these messages may be received by different computers.</span></span> <span data-ttu-id="ef3ac-140">如此可讓工作流程執行個體由另一部電腦所載入。</span><span class="sxs-lookup"><span data-stu-id="ef3ac-140">This allows the workflow instance to be loaded by another computer.</span></span>  
  
### <a name="scenario-workflow-uses-delay-activities-with-short-durations"></a><span data-ttu-id="ef3ac-141">案例：工作流程使用短期間的延遲活動</span><span class="sxs-lookup"><span data-stu-id="ef3ac-141">Scenario: Workflow Uses Delay Activities with Short Durations</span></span>  

 <span data-ttu-id="ef3ac-142">在此案例中，<xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore> 會定期輪詢持續性資料庫，以找出因為過期的 <xref:System.Activities.Statements.Delay> 活動所應該載入的執行個體。</span><span class="sxs-lookup"><span data-stu-id="ef3ac-142">In this scenario, the <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore> regularly polls the persistence database for instances that should be loaded because of an expired <xref:System.Activities.Statements.Delay> activity.</span></span> <span data-ttu-id="ef3ac-143">如果 <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore> 找到一個計時器將於下一個輪詢間隔到期，SQL 工作流程執行個體存放區會縮短輪詢間隔。</span><span class="sxs-lookup"><span data-stu-id="ef3ac-143">If the <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore> finds a timer that will expire in the next polling interval, the SQL Workflow Instance Store shortens the polling interval.</span></span> <span data-ttu-id="ef3ac-144">然後在計時器到期之後，將會立刻發生下一次輪詢。</span><span class="sxs-lookup"><span data-stu-id="ef3ac-144">The next poll will then occur right after the timer has expired.</span></span> <span data-ttu-id="ef3ac-145">如此一來，SQL 工作流程執行個體存放區會達到計時器的高精確度，且計時器的執行時間要比輪詢間隔來得長，輪詢間隔是由 <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore.RunnableInstancesDetectionPeriod%2A> 所設定。</span><span class="sxs-lookup"><span data-stu-id="ef3ac-145">This way, the SQL Workflow Instance Store achieves a high accuracy of timers that run longer than the polling interval, which is set by <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore.RunnableInstancesDetectionPeriod%2A>.</span></span> <span data-ttu-id="ef3ac-146">為了能夠及時處理較短的延遲，工作流程執行個體停留在記憶體中的時間至少必須達到一個輪詢間隔的長度。</span><span class="sxs-lookup"><span data-stu-id="ef3ac-146">To enable timely processing of shorter delays, the workflow instance must remain in memory for at least one polling interval.</span></span>  
  
 <span data-ttu-id="ef3ac-147">請將 <xref:System.ServiceModel.Activities.Description.WorkflowIdleBehavior.TimeToPersist%2A> 設定為 0，將到期時間寫入持續性資料庫。</span><span class="sxs-lookup"><span data-stu-id="ef3ac-147">Set <xref:System.ServiceModel.Activities.Description.WorkflowIdleBehavior.TimeToPersist%2A> to 0 to write the expiration time to the persistence database.</span></span>  
  
 <span data-ttu-id="ef3ac-148">請將 <xref:System.ServiceModel.Activities.Description.WorkflowIdleBehavior.TimeToUnload%2A> 設定為大於或等於 <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore.RunnableInstancesDetectionPeriod%2A> 的時間長度，好讓執行個體停留在記憶體中的時間至少達到一個輪詢間隔的長度。</span><span class="sxs-lookup"><span data-stu-id="ef3ac-148">Set <xref:System.ServiceModel.Activities.Description.WorkflowIdleBehavior.TimeToUnload%2A> to longer than or equal to <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore.RunnableInstancesDetectionPeriod%2A> to keep the instance in memory for at least one polling interval.</span></span>  
  
 <span data-ttu-id="ef3ac-149">我們不建議您降低 <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore.RunnableInstancesDetectionPeriod%2A>，因為這樣會導致持續性資料庫的負載增加。</span><span class="sxs-lookup"><span data-stu-id="ef3ac-149">We do not recommend reducing the <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore.RunnableInstancesDetectionPeriod%2A> because this leads to an increased load on the persistence database.</span></span> <span data-ttu-id="ef3ac-150">使用 <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore> 的每一部服務主機在每個偵測期間都會輪詢資料庫一次。</span><span class="sxs-lookup"><span data-stu-id="ef3ac-150">Each service host that uses the <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore> polls the database one time per detection period.</span></span> <span data-ttu-id="ef3ac-151">如果服務主機的數目很大，將 <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore.RunnableInstancesDetectionPeriod%2A> 設定為太短的時間間隔，則可能會導致系統的效能降低。</span><span class="sxs-lookup"><span data-stu-id="ef3ac-151">Setting <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore.RunnableInstancesDetectionPeriod%2A> to too small a time interval may cause your system's performance to decrease if the number of service hosts is large.</span></span>  
  
## <a name="configuring-the-sql-workflow-instance-store"></a><span data-ttu-id="ef3ac-152">設定 SQL 工作流程執行個體存放區</span><span class="sxs-lookup"><span data-stu-id="ef3ac-152">Configuring the SQL Workflow Instance Store</span></span>  

 <span data-ttu-id="ef3ac-153">SQL 工作流程執行個體存放區具有下列組態參數：</span><span class="sxs-lookup"><span data-stu-id="ef3ac-153">The SQL Workflow Instance Store has the following configuration parameters:</span></span>  
  
 <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore.InstanceEncodingOption%2A>  
 <span data-ttu-id="ef3ac-154">這個參數會指示 <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore> 壓縮工作流程執行個體狀態。</span><span class="sxs-lookup"><span data-stu-id="ef3ac-154">This parameter instructs the <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore> to compress the workflow instance state.</span></span> <span data-ttu-id="ef3ac-155">壓縮會減少儲存在持續性資料庫中的資料數量，並在持續性資料庫位於專用資料庫伺服器時減少網路流量。</span><span class="sxs-lookup"><span data-stu-id="ef3ac-155">Compression reduces the amount of data that is stored in the persistence database and reduces network traffic in case the persistence database resides on a dedicated database server.</span></span> <span data-ttu-id="ef3ac-156">如果使用壓縮，則需要計算資源來壓縮及擷取執行個體狀態。</span><span class="sxs-lookup"><span data-stu-id="ef3ac-156">If compression is used, it requires computational resources to compress and extract the instance state.</span></span> <span data-ttu-id="ef3ac-157">在大部分情況下，壓縮會導致效能提高。</span><span class="sxs-lookup"><span data-stu-id="ef3ac-157">In most cases, compression yields increased performance.</span></span>  
  
 <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore.InstanceCompletionAction%2A>  
 <span data-ttu-id="ef3ac-158">這個參數會指示 <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore> 保留或刪除完成的執行個體。</span><span class="sxs-lookup"><span data-stu-id="ef3ac-158">This parameter instructs the <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore> to either keep or delete completed instances.</span></span> <span data-ttu-id="ef3ac-159">保留完成的執行個體會使得持續性資料庫的儲存需求增加，並導致資料表變大，而這樣會增加資料表查詢時間。</span><span class="sxs-lookup"><span data-stu-id="ef3ac-159">Keeping completed instances increases the persistence database storage requirements and leads to larger tables, which increases table lookup times.</span></span> <span data-ttu-id="ef3ac-160">除非偵錯或稽核需要完成的執行個體，否則最好指示 <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore> 刪除完成的執行個體。</span><span class="sxs-lookup"><span data-stu-id="ef3ac-160">Unless completed instances are required for debugging or auditing, it is best to instruct the <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore> to delete completed instances.</span></span> <span data-ttu-id="ef3ac-161">只有當使用者建立處理序以便最後移除刪除的執行個體時，才應該保留刪除的執行個體。</span><span class="sxs-lookup"><span data-stu-id="ef3ac-161">Deleted instances should be kept only if the user establishes a process for eventually removing them.</span></span> <span data-ttu-id="ef3ac-162">請注意，只要完成的工作流程執行個體位於執行個體存放區，就不能重複使用相互關聯索引鍵。</span><span class="sxs-lookup"><span data-stu-id="ef3ac-162">Note that correlation keys cannot be reused as long as the completed workflow instance resides in the instance store.</span></span>  
  
 <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore.RunnableInstancesDetectionPeriod%2A>  
 <span data-ttu-id="ef3ac-163">這個參數會定義 <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore> 輪詢持續性資料庫所使用的最長間隔，以找出 <xref:System.Activities.Statements.Delay> 活動到期時應該載入的執行個體。</span><span class="sxs-lookup"><span data-stu-id="ef3ac-163">This parameter defines the maximum interval with which the <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore> polls the persistence database for instances that should be loaded when a <xref:System.Activities.Statements.Delay> activity expires.</span></span> <span data-ttu-id="ef3ac-164">如果 <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore> 找到一個計時器將於下一個輪詢間隔到期，它就會縮短輪詢間隔，以便在計時器到期之後立刻發生下一次輪詢。</span><span class="sxs-lookup"><span data-stu-id="ef3ac-164">If the <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore> finds a timer that will expire in the next polling interval, it shortens the polling interval so that the next poll will occur right after the timer has expired.</span></span> <span data-ttu-id="ef3ac-165">如此一來，SQL 工作流程執行個體存放區會達到計時器的高精確度，且計時器的執行時間要比 <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore.RunnableInstancesDetectionPeriod%2A> 來得長。</span><span class="sxs-lookup"><span data-stu-id="ef3ac-165">This way, the SQL Workflow Instance Store achieves a high accuracy of timers that run longer than <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore.RunnableInstancesDetectionPeriod%2A>.</span></span>  
  
 <span data-ttu-id="ef3ac-166">我們不建議您降低 <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore.RunnableInstancesDetectionPeriod%2A>，因為這樣會導致持續性資料庫的負載增加。</span><span class="sxs-lookup"><span data-stu-id="ef3ac-166">We do not recommend reducing the <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore.RunnableInstancesDetectionPeriod%2A>, because this leads to an increased load on the persistence database.</span></span> <span data-ttu-id="ef3ac-167">使用 <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore> 的每一部服務主機在每個偵測期間都會輪詢資料庫一次。</span><span class="sxs-lookup"><span data-stu-id="ef3ac-167">Each service host that uses the <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore> polls the database one time per detection period.</span></span> <span data-ttu-id="ef3ac-168">如果服務主機的數目很大，將 <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore.RunnableInstancesDetectionPeriod%2A> 設定為太短的時間間隔，則可能會導致系統的效能降低。</span><span class="sxs-lookup"><span data-stu-id="ef3ac-168">Setting <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore.RunnableInstancesDetectionPeriod%2A> to too small an interval may cause your system's performance to decrease if the number of service hosts is large.</span></span>  
  
 <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore.HostLockRenewalPeriod%2A>  
 <span data-ttu-id="ef3ac-169">這個參數會定義主機在持續性資料庫中更新其鎖定的間隔。</span><span class="sxs-lookup"><span data-stu-id="ef3ac-169">This parameter defines the interval with which the host renews its lock in the persistence database.</span></span> <span data-ttu-id="ef3ac-170">將此間隔縮短會在主機或電腦故障時更快復原工作流程執行個體。</span><span class="sxs-lookup"><span data-stu-id="ef3ac-170">Shortening this interval will enable a quicker recovery of the workflow instances in case a host or computer fails.</span></span> <span data-ttu-id="ef3ac-171">另一方面，較短的鎖定更新期間也會增加持續性資料庫的負載。</span><span class="sxs-lookup"><span data-stu-id="ef3ac-171">On the other hand, a short lock renewal period increases the load on the persistence database.</span></span> <span data-ttu-id="ef3ac-172">使用 <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore> 的每一部服務主機在每個更新期間都會更新其在資料庫中的鎖定一次。</span><span class="sxs-lookup"><span data-stu-id="ef3ac-172">Each service host that uses the <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore> will update its locks in the database one time per renewal period.</span></span> <span data-ttu-id="ef3ac-173">如果電腦執行許多服務主機，請確定鎖定更新所產生的負載不會降低系統的效能。</span><span class="sxs-lookup"><span data-stu-id="ef3ac-173">If a computer runs many service hosts, make sure that the load caused by lock renewal does not decrease your system's performance.</span></span> <span data-ttu-id="ef3ac-174">如果會的話，請考慮增加 <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore.HostLockRenewalPeriod%2A>。</span><span class="sxs-lookup"><span data-stu-id="ef3ac-174">If it does, consider increasing the <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore.HostLockRenewalPeriod%2A>.</span></span>  
  
 <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore.InstanceLockedExceptionAction%2A>  
 <span data-ttu-id="ef3ac-175">如果啟用的話，<xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore> 會在接下來的 30 秒鐘內重試載入鎖定的執行個體。</span><span class="sxs-lookup"><span data-stu-id="ef3ac-175">If enabled, the <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore> retries to load a locked instance for the next 30 seconds.</span></span> <span data-ttu-id="ef3ac-176">如果工作流程在短期內收到多個訊息，而且這些訊息是由不同電腦所接收，請將 <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore.InstanceLockedExceptionAction%2A> 設定為 BasicRetry 或 AggressiveRetry。</span><span class="sxs-lookup"><span data-stu-id="ef3ac-176">Set <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore.InstanceLockedExceptionAction%2A> to BasicRetry or AggressiveRetry if the workflow receives multiple messages in a short time, and these messages are received by different computers.</span></span>  
  
 <span data-ttu-id="ef3ac-177">只要未嘗試載入重試，載入重試機制就不會導致任何效能負擔，所以應該要一直啟用 <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore.InstanceLockedExceptionAction%2A>。</span><span class="sxs-lookup"><span data-stu-id="ef3ac-177">Because the load retry mechanism does not introduce any performance overhead as long as load retries are not tried, <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore.InstanceLockedExceptionAction%2A> should always be enabled.</span></span>
