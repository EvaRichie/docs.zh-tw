---
title: 在 WF 中建立非同步活動
description: 瞭解如何使用 AsyncCodeActivity 建立自訂非同步活動，此活動可讓衍生的活動執行非同步執行邏輯。
ms.date: 03/30/2017
ms.assetid: 497e81ed-5eef-460c-ba55-fae73c05824f
ms.openlocfilehash: a03fbde1ff27084cc36dffc3a1912220d9bbca7e
ms.sourcegitcommit: bc293b14af795e0e999e3304dd40c0222cf2ffe4
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 11/26/2020
ms.locfileid: "96242080"
---
# <a name="creating-asynchronous-activities-in-wf"></a><span data-ttu-id="17440-103">在 WF 中建立非同步活動</span><span class="sxs-lookup"><span data-stu-id="17440-103">Creating Asynchronous Activities in WF</span></span>

<span data-ttu-id="17440-104"><xref:System.Activities.AsyncCodeActivity> 會提供活動作者可用的基底類別，此類別可讓衍生活動實作非同步執行邏輯。</span><span class="sxs-lookup"><span data-stu-id="17440-104"><xref:System.Activities.AsyncCodeActivity> provides activity authors a base class to use that enables derived activities to implement asynchronous execution logic.</span></span> <span data-ttu-id="17440-105">若自訂活動必須執行非同步工作而不保存工作流程排程器執行緒，並且封鎖任何能夠平行執行的活動，則此功能非常實用。</span><span class="sxs-lookup"><span data-stu-id="17440-105">This is useful for custom activities that must perform asynchronous work without holding the workflow scheduler thread and blocking any activities that may be able to run in parallel.</span></span> <span data-ttu-id="17440-106">本主題提供如何使用 <xref:System.Activities.AsyncCodeActivity> 建立自訂非同步活動的概觀。</span><span class="sxs-lookup"><span data-stu-id="17440-106">This topic provides an overview of how to create custom asynchronous activities using <xref:System.Activities.AsyncCodeActivity>.</span></span>  
  
## <a name="using-asynccodeactivity"></a><span data-ttu-id="17440-107">使用 AsyncCodeActivity</span><span class="sxs-lookup"><span data-stu-id="17440-107">Using AsyncCodeActivity</span></span>  

 <span data-ttu-id="17440-108"><xref:System.Activities?displayProperty=nameWithType> 會提供自訂活動作者不同的基底類別，用於不同的活動撰寫需求。</span><span class="sxs-lookup"><span data-stu-id="17440-108"><xref:System.Activities?displayProperty=nameWithType> provides custom activity authors with different base classes for different activity authoring requirements.</span></span> <span data-ttu-id="17440-109">每個基底類別具有一種特定的語意，並且提供工作流程作者 (及活動執行階段) 對應的合約。</span><span class="sxs-lookup"><span data-stu-id="17440-109">Each one carries a particular semantic and provides a workflow author (and the activity runtime) a corresponding contract.</span></span> <span data-ttu-id="17440-110">以 <xref:System.Activities.AsyncCodeActivity> 為主的活動會採用非同步方式來對排程器執行緒執行相對工作，且以 Managed 程式碼表示其執行邏輯的活動。</span><span class="sxs-lookup"><span data-stu-id="17440-110">An <xref:System.Activities.AsyncCodeActivity> based activity is an activity that performs work asynchronously relative to the scheduler thread and whose execution logic is expressed in managed code.</span></span> <span data-ttu-id="17440-111">因為非同步的緣故，<xref:System.Activities.AsyncCodeActivity> 可能會在執行期間造成閒置點。</span><span class="sxs-lookup"><span data-stu-id="17440-111">As a result of going asynchronous, an <xref:System.Activities.AsyncCodeActivity> may induce an idle point during execution.</span></span> <span data-ttu-id="17440-112">由於非同步工作的變動特性，<xref:System.Activities.AsyncCodeActivity> 一定會在活動執行期間建立不保存的區塊。</span><span class="sxs-lookup"><span data-stu-id="17440-112">Due to the volatile nature of asynchronous work, an <xref:System.Activities.AsyncCodeActivity> always creates a no persist block for the duration of the activity’s execution.</span></span> <span data-ttu-id="17440-113">這樣可以避免工作流程執行階段在非同步工作當中保存工作流程執行個體，同時也避免工作流程執行個體在非同步程式碼執行期間卸載。</span><span class="sxs-lookup"><span data-stu-id="17440-113">This prevents the workflow runtime from persisting the workflow instance in the middle of the asynchronous work, and also prevents the workflow instance from unloading while the asynchronous code is executing.</span></span>  
  
### <a name="asynccodeactivity-methods"></a><span data-ttu-id="17440-114">AsyncCodeActivity 方法</span><span class="sxs-lookup"><span data-stu-id="17440-114">AsyncCodeActivity Methods</span></span>  

 <span data-ttu-id="17440-115">衍生自 <xref:System.Activities.AsyncCodeActivity> 的活動可以透過以自訂程式碼覆寫 <xref:System.Activities.AsyncCodeActivity.BeginExecute%2A> 和 <xref:System.Activities.AsyncCodeActivity.EndExecute%2A> 方法來建立非同步執行邏輯。</span><span class="sxs-lookup"><span data-stu-id="17440-115">Activities that derive from <xref:System.Activities.AsyncCodeActivity> can create asynchronous execution logic by overriding the <xref:System.Activities.AsyncCodeActivity.BeginExecute%2A> and <xref:System.Activities.AsyncCodeActivity.EndExecute%2A> methods with custom code.</span></span> <span data-ttu-id="17440-116">執行階段呼叫這些方法時，會將這些方法傳遞到 <xref:System.Activities.AsyncCodeActivityContext>。</span><span class="sxs-lookup"><span data-stu-id="17440-116">When called by the runtime, these methods are passed an <xref:System.Activities.AsyncCodeActivityContext>.</span></span> <span data-ttu-id="17440-117"><xref:System.Activities.AsyncCodeActivityContext>允許活動作者 <xref:System.Activities.AsyncCodeActivity.BeginExecute%2A> /  <xref:System.Activities.AsyncCodeActivity.EndExecute%2A> 在內容的屬性中提供共用的狀態 <xref:System.Activities.AsyncCodeActivityContext.UserState%2A> 。</span><span class="sxs-lookup"><span data-stu-id="17440-117"><xref:System.Activities.AsyncCodeActivityContext> allows the activity author to provide shared state across <xref:System.Activities.AsyncCodeActivity.BeginExecute%2A>/ <xref:System.Activities.AsyncCodeActivity.EndExecute%2A> in the context’s <xref:System.Activities.AsyncCodeActivityContext.UserState%2A> property.</span></span> <span data-ttu-id="17440-118">在下列範例中，`GenerateRandom` 活動會以非同步的方式產生隨機數字。</span><span class="sxs-lookup"><span data-stu-id="17440-118">In the following example, a `GenerateRandom` activity generates a random number asynchronously.</span></span>  
  
 [!code-csharp[CFX_ActivityExample#8](~/samples/snippets/csharp/VS_Snippets_CFX/CFX_ActivityExample/cs/Program.cs#8)]  
  
 <span data-ttu-id="17440-119">上一個範例活動衍生自 <xref:System.Activities.AsyncCodeActivity%601>，而且具有提升的 `OutArgument<int>`，名為 `Result`。</span><span class="sxs-lookup"><span data-stu-id="17440-119">The previous example activity derives from <xref:System.Activities.AsyncCodeActivity%601>, and has an elevated `OutArgument<int>` named `Result`.</span></span> <span data-ttu-id="17440-120">`GetRandom` 覆寫會擷取並傳回 <xref:System.Activities.AsyncCodeActivity%601.EndExecute%2A> 方法所傳回的值，而且此值會設定為 `Result` 值。</span><span class="sxs-lookup"><span data-stu-id="17440-120">The value returned by the `GetRandom` method is extracted and returned by the <xref:System.Activities.AsyncCodeActivity%601.EndExecute%2A> override, and this value is set as the `Result` value.</span></span> <span data-ttu-id="17440-121">不會傳回結果的非同步活動應衍生自 <xref:System.Activities.AsyncCodeActivity>。</span><span class="sxs-lookup"><span data-stu-id="17440-121">Asynchronous activities that do not return a result should derive from <xref:System.Activities.AsyncCodeActivity>.</span></span> <span data-ttu-id="17440-122">在下列範例中，會定義衍生自 `DisplayRandom` 的 <xref:System.Activities.AsyncCodeActivity> 活動。</span><span class="sxs-lookup"><span data-stu-id="17440-122">In the following example, a `DisplayRandom` activity is defined which derives from <xref:System.Activities.AsyncCodeActivity>.</span></span> <span data-ttu-id="17440-123">這個活動就像是 `GetRandom` 活動，但會將訊息顯示到主控台，而不傳回結果。</span><span class="sxs-lookup"><span data-stu-id="17440-123">This activity is like the `GetRandom` activity but instead of returning a result it displays a message to the console.</span></span>  
  
 [!code-csharp[CFX_ActivityExample#11](~/samples/snippets/csharp/VS_Snippets_CFX/CFX_ActivityExample/cs/Program.cs#11)]  
  
 <span data-ttu-id="17440-124">請注意，因為沒有傳回值，`DisplayRandom` 使用 <xref:System.Action> 而非 <xref:System.Func%602> 叫用其委派，而委派未傳回值。</span><span class="sxs-lookup"><span data-stu-id="17440-124">Note that because there is no return value, `DisplayRandom` uses an <xref:System.Action> instead of a <xref:System.Func%602> to invoke its delegate, and the delegate returns no value.</span></span>  
  
 <span data-ttu-id="17440-125"><xref:System.Activities.AsyncCodeActivity> 也提供 <xref:System.Activities.AsyncCodeActivity.Cancel%2A> 覆寫。</span><span class="sxs-lookup"><span data-stu-id="17440-125"><xref:System.Activities.AsyncCodeActivity> also provides a <xref:System.Activities.AsyncCodeActivity.Cancel%2A> override.</span></span> <span data-ttu-id="17440-126">當 <xref:System.Activities.AsyncCodeActivity.BeginExecute%2A> 和 <xref:System.Activities.AsyncCodeActivity.EndExecute%2A> 是必要的覆寫時，<xref:System.Activities.AsyncCodeActivity.Cancel%2A> 是選擇性的，而且可加以覆寫，讓活動能夠在取消或中止時清除未完成的非同步狀態。</span><span class="sxs-lookup"><span data-stu-id="17440-126">While <xref:System.Activities.AsyncCodeActivity.BeginExecute%2A> and <xref:System.Activities.AsyncCodeActivity.EndExecute%2A> are required overrides, <xref:System.Activities.AsyncCodeActivity.Cancel%2A> is optional, and can be overridden so the activity can clean up its outstanding asynchronous state when it is being canceled or aborted.</span></span> <span data-ttu-id="17440-127">如果可以清除，且 `AsyncCodeActivity.ExecutingActivityInstance.IsCancellationRequested` 是 `true`，活動應呼叫 <xref:System.Activities.AsyncCodeActivityContext.MarkCanceled%2A>。</span><span class="sxs-lookup"><span data-stu-id="17440-127">If clean up is possible and `AsyncCodeActivity.ExecutingActivityInstance.IsCancellationRequested` is `true`, the activity should call <xref:System.Activities.AsyncCodeActivityContext.MarkCanceled%2A>.</span></span> <span data-ttu-id="17440-128">從這個方法擲回的任何例外狀況對於工作流程執行個體均非常重要。</span><span class="sxs-lookup"><span data-stu-id="17440-128">Any exceptions thrown from this method are fatal to the workflow instance.</span></span>  
  
 [!code-csharp[CFX_ActivityExample#10](~/samples/snippets/csharp/VS_Snippets_CFX/CFX_ActivityExample/cs/Program.cs#10)]  
  
### <a name="invoking-asynchronous-methods-on-a-class"></a><span data-ttu-id="17440-129">在類別上叫用非同步方法</span><span class="sxs-lookup"><span data-stu-id="17440-129">Invoking Asynchronous Methods on a Class</span></span>  

 <span data-ttu-id="17440-130">.NET Framework 中的許多類別提供非同步功能，而且可以使用基礎活動以非同步方式叫用此功能 <xref:System.Activities.AsyncCodeActivity> 。</span><span class="sxs-lookup"><span data-stu-id="17440-130">Many of the classes in the .NET Framework provide asynchronous functionality, and this functionality can be asynchronously invoked by using an <xref:System.Activities.AsyncCodeActivity> based activity.</span></span> <span data-ttu-id="17440-131">在下列範例中，會建立活動，以使用類別以非同步方式建立檔案 <xref:System.IO.FileStream> 。</span><span class="sxs-lookup"><span data-stu-id="17440-131">In the following example, an activity is created that asynchronously creates a file by using the <xref:System.IO.FileStream> class.</span></span>  
  
 [!code-csharp[CFX_ActivityExample#12](~/samples/snippets/csharp/VS_Snippets_CFX/CFX_ActivityExample/cs/Program.cs#12)]  
  
### <a name="sharing-state-between-the-beginexecute-and-endexecute-methods"></a><span data-ttu-id="17440-132">共用 BeginExecute 和 EndExecute 方法之間的狀態</span><span class="sxs-lookup"><span data-stu-id="17440-132">Sharing State Between the BeginExecute and EndExecute Methods</span></span>  

 <span data-ttu-id="17440-133">上一個範例中，是在 <xref:System.IO.FileStream> 中存取於 <xref:System.Activities.AsyncCodeActivity.BeginExecute%2A> 中建立的 <xref:System.Activities.AsyncCodeActivity.EndExecute%2A> 物件。</span><span class="sxs-lookup"><span data-stu-id="17440-133">In the previous example, the <xref:System.IO.FileStream> object that was created in <xref:System.Activities.AsyncCodeActivity.BeginExecute%2A> was accessed in the <xref:System.Activities.AsyncCodeActivity.EndExecute%2A>.</span></span> <span data-ttu-id="17440-134">這是可能的，因為 `file` 變數會在 <xref:System.Activities.AsyncCodeActivityContext.UserState%2A?displayProperty=nameWithType> 的 <xref:System.Activities.AsyncCodeActivity.BeginExecute%2A> 屬性中傳遞。</span><span class="sxs-lookup"><span data-stu-id="17440-134">This is possible because the `file` variable was passed in the <xref:System.Activities.AsyncCodeActivityContext.UserState%2A?displayProperty=nameWithType> property in <xref:System.Activities.AsyncCodeActivity.BeginExecute%2A>.</span></span> <span data-ttu-id="17440-135">這是在 <xref:System.Activities.AsyncCodeActivity.BeginExecute%2A> 和 <xref:System.Activities.AsyncCodeActivity.EndExecute%2A> 之間共用狀態的正確方法。</span><span class="sxs-lookup"><span data-stu-id="17440-135">This is the correct method for sharing state between <xref:System.Activities.AsyncCodeActivity.BeginExecute%2A> and <xref:System.Activities.AsyncCodeActivity.EndExecute%2A>.</span></span> <span data-ttu-id="17440-136">在衍生類別 (此範例中為 `FileWriter`) 中使用成員變數來共用 <xref:System.Activities.AsyncCodeActivity.BeginExecute%2A> 和 <xref:System.Activities.AsyncCodeActivity.EndExecute%2A> 之間的狀態並不正確，因為可能會有多個活動執行個體參考該活動物件。</span><span class="sxs-lookup"><span data-stu-id="17440-136">It is incorrect to use a member variable in the derived class (`FileWriter` in this case) to share state between <xref:System.Activities.AsyncCodeActivity.BeginExecute%2A> and <xref:System.Activities.AsyncCodeActivity.EndExecute%2A> because the activity object may be referenced by multiple activity instances.</span></span> <span data-ttu-id="17440-137">嘗試使用成員變數來共用狀態，可能會導致其中一個 <xref:System.Activities.ActivityInstance> 的值覆寫或耗用另一個 <xref:System.Activities.ActivityInstance> 的值。</span><span class="sxs-lookup"><span data-stu-id="17440-137">Attempting to use a member variable to share state can result in values from one <xref:System.Activities.ActivityInstance> overwriting or consuming values from another <xref:System.Activities.ActivityInstance>.</span></span>  
  
### <a name="accessing-argument-values"></a><span data-ttu-id="17440-138">存取引數值</span><span class="sxs-lookup"><span data-stu-id="17440-138">Accessing Argument Values</span></span>  

 <span data-ttu-id="17440-139"><xref:System.Activities.AsyncCodeActivity> 的環境包含在活動定義的引數。</span><span class="sxs-lookup"><span data-stu-id="17440-139">The environment of an <xref:System.Activities.AsyncCodeActivity> consists of the arguments defined on the activity.</span></span> <span data-ttu-id="17440-140">您可以 <xref:System.Activities.AsyncCodeActivity.BeginExecute%2A> / <xref:System.Activities.AsyncCodeActivity.EndExecute%2A> 使用參數，從覆寫存取這些引數 <xref:System.Activities.AsyncCodeActivityContext> 。</span><span class="sxs-lookup"><span data-stu-id="17440-140">These arguments can be accessed from the <xref:System.Activities.AsyncCodeActivity.BeginExecute%2A>/<xref:System.Activities.AsyncCodeActivity.EndExecute%2A> overrides using the <xref:System.Activities.AsyncCodeActivityContext> parameter.</span></span> <span data-ttu-id="17440-141">您不可以在委派中存取引數，但可以使用其參數將引數值或任何其他所需的資料傳遞至委派。</span><span class="sxs-lookup"><span data-stu-id="17440-141">The arguments cannot be accessed in the delegate, but the argument values or any other desired data can be passed in to the delegate using its parameters.</span></span> <span data-ttu-id="17440-142">在下列範例中，會定義產生隨機數字的活動，此活動會從其 `Max` 引數取得內含的上限。</span><span class="sxs-lookup"><span data-stu-id="17440-142">In the following example, a random number-generating activity is defined that obtains the inclusive upper bound from its `Max` argument.</span></span> <span data-ttu-id="17440-143">當叫用委派時，會將引數的值傳遞至非同步程式碼。</span><span class="sxs-lookup"><span data-stu-id="17440-143">The value of the argument is passed in to the asynchronous code when the delegate is invoked.</span></span>  
  
 [!code-csharp[CFX_ActivityExample#9](~/samples/snippets/csharp/VS_Snippets_CFX/CFX_ActivityExample/cs/Program.cs#9)]  
  
### <a name="scheduling-actions-or-child-activities-using-asynccodeactivity"></a><span data-ttu-id="17440-144">使用 AsyncCodeActivity 排定動作或子活動</span><span class="sxs-lookup"><span data-stu-id="17440-144">Scheduling Actions or Child Activities Using AsyncCodeActivity</span></span>  

 <span data-ttu-id="17440-145"><xref:System.Activities.AsyncCodeActivity> 衍生的自訂活動提供根據工作流程執行緒非同步執行工作的方法，但不提供排定子活動或動作的功能。</span><span class="sxs-lookup"><span data-stu-id="17440-145"><xref:System.Activities.AsyncCodeActivity> derived custom activities  provide a method for performing work asynchronously with regard to the workflow thread, but do not provide the ability to schedule child activities or actions.</span></span> <span data-ttu-id="17440-146">但是，可以透過撰寫方式將非同步行為納入子活動排程。</span><span class="sxs-lookup"><span data-stu-id="17440-146">However, asynchronous behavior can be incorporated with scheduling of child activities through composition.</span></span> <span data-ttu-id="17440-147">您可以建立非同步活動，然後以 <xref:System.Activities.Activity> 或 <xref:System.Activities.NativeActivity> 衍生活動來撰寫該活動，以提供非同步行為，並排定子活動或動作。</span><span class="sxs-lookup"><span data-stu-id="17440-147">An asynchronous activity can be created, and then composed with an <xref:System.Activities.Activity> or <xref:System.Activities.NativeActivity> derived activity to provide asynchronous behavior and scheduling of child activities or actions.</span></span> <span data-ttu-id="17440-148">例如，您可以建立衍生自 <xref:System.Activities.Activity> 的活動，並且實作包含該非同步活動及其他實作活動邏輯之活動的 <xref:System.Activities.Statements.Sequence>。</span><span class="sxs-lookup"><span data-stu-id="17440-148">For example, an activity could be created that derives from <xref:System.Activities.Activity>, and has as its implementation a <xref:System.Activities.Statements.Sequence> containing the asynchronous activity as well the other activities that implement the logic of the activity.</span></span> <span data-ttu-id="17440-149">如需使用和撰寫活動的更多範例 <xref:System.Activities.Activity> <xref:System.Activities.NativeActivity> ，請參閱 how [To：建立活動](how-to-create-an-activity.md) 和 [活動撰寫選項](activity-authoring-options-in-wf.md)。</span><span class="sxs-lookup"><span data-stu-id="17440-149">For more examples of composing activities using <xref:System.Activities.Activity> and <xref:System.Activities.NativeActivity>, see [How to: Create an Activity](how-to-create-an-activity.md) and [Activity Authoring Options](activity-authoring-options-in-wf.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="17440-150">另請參閱</span><span class="sxs-lookup"><span data-stu-id="17440-150">See also</span></span>

- <xref:System.Action>
- <xref:System.Func%602>
