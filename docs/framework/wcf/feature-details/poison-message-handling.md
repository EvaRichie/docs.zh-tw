---
title: 有害訊息處理
ms.date: 03/30/2017
ms.assetid: 8d1c5e5a-7928-4a80-95ed-d8da211b8595
ms.openlocfilehash: d219c18bb072684deb6cc1d8a2d17b1989762151
ms.sourcegitcommit: cdb295dd1db589ce5169ac9ff096f01fd0c2da9d
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 06/09/2020
ms.locfileid: "84590562"
---
# <a name="poison-message-handling"></a><span data-ttu-id="f2e53-102">有害訊息處理</span><span class="sxs-lookup"><span data-stu-id="f2e53-102">Poison Message Handling</span></span>
<span data-ttu-id="f2e53-103">*有害訊息*是已超過應用程式傳遞嘗試次數上限的訊息。</span><span class="sxs-lookup"><span data-stu-id="f2e53-103">A *poison message* is a message that has exceeded the maximum number of delivery attempts to the application.</span></span> <span data-ttu-id="f2e53-104">這種情形可能會在佇列架構的應用程式因為錯誤而無法處理訊息時發生。</span><span class="sxs-lookup"><span data-stu-id="f2e53-104">This situation can arise when a queue-based application cannot process a message because of errors.</span></span> <span data-ttu-id="f2e53-105">為了符合可靠性的需求，佇列的應用程式會在交易中接收訊息。</span><span class="sxs-lookup"><span data-stu-id="f2e53-105">To meet reliability demands, a queued application receives messages under a transaction.</span></span> <span data-ttu-id="f2e53-106">若中止了接收佇列訊息的異動，則會讓訊息留在佇列中，而訊息將會在新的異動中重試。</span><span class="sxs-lookup"><span data-stu-id="f2e53-106">Aborting the transaction in which a queued message was received leaves the message in the queue so that the message is retried under a new transaction.</span></span> <span data-ttu-id="f2e53-107">如果造成異動中止的問題未予以更正，則接收的應用程式可能會卡在接收及中止相同訊息的迴圈中，直到超過傳遞嘗試次數的上限為止，因而形成有害訊息。</span><span class="sxs-lookup"><span data-stu-id="f2e53-107">If the problem that caused the transaction to abort is not corrected, the receiving application can get stuck in a loop receiving and aborting the same message until the maximum number of delivery attempts has been exceeded and a poison message results.</span></span>  
  
 <span data-ttu-id="f2e53-108">訊息變成有害訊息的原因有許多種。</span><span class="sxs-lookup"><span data-stu-id="f2e53-108">A message can become a poison message for many reasons.</span></span> <span data-ttu-id="f2e53-109">最常見的原因是應用程式特有的。</span><span class="sxs-lookup"><span data-stu-id="f2e53-109">The most common reasons are application-specific.</span></span> <span data-ttu-id="f2e53-110">例如，如果應用程式從佇列讀取訊息，並且執行某些資料庫處理，應用程式可能因為無法在該資料庫上取得鎖定，而造成中止交易。</span><span class="sxs-lookup"><span data-stu-id="f2e53-110">For example, if an application reads a message from a queue and performs some database processing, the application may fail to get a lock on the database, causing it to abort the transaction.</span></span> <span data-ttu-id="f2e53-111">由於資料庫交易中止，訊息會留在佇列中，造成應用程式再次讀取該訊息，並重新嘗試取得資料庫鎖定。</span><span class="sxs-lookup"><span data-stu-id="f2e53-111">Because the database transaction was aborted, the message remains in the queue, which causes the application to reread the message a second time and make another attempt to acquire a lock on the database.</span></span> <span data-ttu-id="f2e53-112">如果訊息包含無效的資訊，則也可能變成有害的。</span><span class="sxs-lookup"><span data-stu-id="f2e53-112">Messages can also become poison if they contain invalid information.</span></span> <span data-ttu-id="f2e53-113">例如，採購單可能包含無效的客戶編號。</span><span class="sxs-lookup"><span data-stu-id="f2e53-113">For example, a purchase order may contain an invalid customer number.</span></span> <span data-ttu-id="f2e53-114">在這些情況下，應用程式可能自動中止異動，而迫使訊息成為有害訊息。</span><span class="sxs-lookup"><span data-stu-id="f2e53-114">In these cases, the application may voluntarily abort the transaction and force the message to become a poison message.</span></span>  
  
 <span data-ttu-id="f2e53-115">在鮮少的情況下，訊息可能會無法分派至應用程式。</span><span class="sxs-lookup"><span data-stu-id="f2e53-115">On rare occasions, messages can fail to get dispatched to the application.</span></span> <span data-ttu-id="f2e53-116">Windows Communication Foundation （WCF）層可能會發現訊息有問題，例如，訊息的框架錯誤、附加的訊息認證無效，或是不正確動作標頭。</span><span class="sxs-lookup"><span data-stu-id="f2e53-116">The Windows Communication Foundation (WCF) layer may find a problem with the message, such as if the message has the wrong frame, invalid message credentials attached to it, or an invalid action header.</span></span> <span data-ttu-id="f2e53-117">在這些情況中，應用程式絕不會接收該訊息，不過，訊息仍然可能會變成有害訊息，並且以手動方式處理。</span><span class="sxs-lookup"><span data-stu-id="f2e53-117">In these cases, the application never receives the message; however, the message can still become a poison message and be processed manually.</span></span>  
  
## <a name="handling-poison-messages"></a><span data-ttu-id="f2e53-118">處理有害訊息</span><span class="sxs-lookup"><span data-stu-id="f2e53-118">Handling Poison Messages</span></span>  
 <span data-ttu-id="f2e53-119">在 WCF 中，有害訊息處理會提供一個機制，讓接收的應用程式處理無法分派至應用程式的訊息，或是因應用程式特定的原因而無法處理的訊息。</span><span class="sxs-lookup"><span data-stu-id="f2e53-119">In WCF, poison message handling provides a mechanism for a receiving application to deal with messages that cannot be dispatched to the application or messages that are dispatched to the application but that fail to be processed because of application-specific reasons.</span></span> <span data-ttu-id="f2e53-120">在每個可用的佇列系結中，使用下列屬性來設定有害訊息處理：</span><span class="sxs-lookup"><span data-stu-id="f2e53-120">Configure poison message handling with the following properties in each of the available queued bindings:</span></span>  
  
- <span data-ttu-id="f2e53-121">`ReceiveRetryCount`.</span><span class="sxs-lookup"><span data-stu-id="f2e53-121">`ReceiveRetryCount`.</span></span> <span data-ttu-id="f2e53-122">整數值，表示從應用程式佇列傳遞至應用程式的訊息重試次數上限。</span><span class="sxs-lookup"><span data-stu-id="f2e53-122">An integer value that indicates the maximum number of times to retry delivery of a message from the application queue to the application.</span></span> <span data-ttu-id="f2e53-123">預設值為 5。</span><span class="sxs-lookup"><span data-stu-id="f2e53-123">The default value is 5.</span></span> <span data-ttu-id="f2e53-124">這個值對於立即重試即可修正問題的情況來說就已足夠，例如資料庫上發生暫時死結時。</span><span class="sxs-lookup"><span data-stu-id="f2e53-124">This is sufficient in cases where an immediate retry fixes the problem, such as with a temporary deadlock on a database.</span></span>  
  
- <span data-ttu-id="f2e53-125">`MaxRetryCycles`.</span><span class="sxs-lookup"><span data-stu-id="f2e53-125">`MaxRetryCycles`.</span></span> <span data-ttu-id="f2e53-126">整數值，表示重試週期的上限。</span><span class="sxs-lookup"><span data-stu-id="f2e53-126">An integer value that indicates the maximum number of retry cycles.</span></span> <span data-ttu-id="f2e53-127">重試週期包含從應用程式佇列將訊息傳輸至重試子佇列，然後在經過一段可設定的延遲之後，再從重試子佇列傳回應用程式佇列，重新嘗試傳遞。</span><span class="sxs-lookup"><span data-stu-id="f2e53-127">A retry cycle consists of transferring a message from the application queue to the retry subqueue and, after a configurable delay, from the retry subqueue back into the application queue to reattempt delivery.</span></span> <span data-ttu-id="f2e53-128">預設值為 2。</span><span class="sxs-lookup"><span data-stu-id="f2e53-128">The default value is 2.</span></span> <span data-ttu-id="f2e53-129">在 Windows Vista 上，訊息最多會嘗試（ `ReceiveRetryCount` + 1） \* （ `MaxRetryCycles` + 1）次。</span><span class="sxs-lookup"><span data-stu-id="f2e53-129">On Windows Vista, the message is tried a maximum of (`ReceiveRetryCount` +1) \* (`MaxRetryCycles` + 1) times.</span></span> <span data-ttu-id="f2e53-130">`MaxRetryCycles`Windows Server 2003 和 Windows XP 會忽略。</span><span class="sxs-lookup"><span data-stu-id="f2e53-130">`MaxRetryCycles` is ignored on Windows Server 2003 and Windows XP.</span></span>  
  
- <span data-ttu-id="f2e53-131">`RetryCycleDelay`.</span><span class="sxs-lookup"><span data-stu-id="f2e53-131">`RetryCycleDelay`.</span></span> <span data-ttu-id="f2e53-132">重試週期之間的時間延遲。</span><span class="sxs-lookup"><span data-stu-id="f2e53-132">The time delay between retry cycles.</span></span> <span data-ttu-id="f2e53-133">預設值為 30 分鐘。</span><span class="sxs-lookup"><span data-stu-id="f2e53-133">The default value is 30 minutes.</span></span> <span data-ttu-id="f2e53-134">`MaxRetryCycles` 和 `RetryCycleDelay` 會一起提供解決問題的機制，透過定期延遲之後的重試，進行問題的修正。</span><span class="sxs-lookup"><span data-stu-id="f2e53-134">`MaxRetryCycles` and `RetryCycleDelay` together provide a mechanism to address the problem where a retry after a periodic delay fixes the problem.</span></span> <span data-ttu-id="f2e53-135">例如，這個機制會處理 SQL Server 中所設定等待異動認可的鎖定資料列。</span><span class="sxs-lookup"><span data-stu-id="f2e53-135">For example, this handles a locked row set in SQL Server pending transaction commit.</span></span>  
  
- <span data-ttu-id="f2e53-136">`ReceiveErrorHandling`.</span><span class="sxs-lookup"><span data-stu-id="f2e53-136">`ReceiveErrorHandling`.</span></span> <span data-ttu-id="f2e53-137">列舉型別，指出要針對達到重試次數上限之後，而導致傳遞失敗的訊息所採取的動作。</span><span class="sxs-lookup"><span data-stu-id="f2e53-137">An enumeration that indicates the action to take for a message that has failed delivery after the maximum number of retries has been attempted.</span></span> <span data-ttu-id="f2e53-138">這個值可以是 Fault、Drop、Reject 和 Move。</span><span class="sxs-lookup"><span data-stu-id="f2e53-138">The values can be Fault, Drop, Reject, and Move.</span></span> <span data-ttu-id="f2e53-139">預設選項為 Fault。</span><span class="sxs-lookup"><span data-stu-id="f2e53-139">The default option is Fault.</span></span>  
  
- <span data-ttu-id="f2e53-140">Fault：</span><span class="sxs-lookup"><span data-stu-id="f2e53-140">Fault.</span></span> <span data-ttu-id="f2e53-141">這個選項會將錯誤傳送至造成 `ServiceHost` 失敗的接聽項。</span><span class="sxs-lookup"><span data-stu-id="f2e53-141">This option sends a fault to the listener that caused the `ServiceHost` to fault.</span></span> <span data-ttu-id="f2e53-142">訊息必須藉由某種外部機制從應用程式佇列中移除，應用程式才能繼續處理佇列中的訊息。</span><span class="sxs-lookup"><span data-stu-id="f2e53-142">The message must be removed from the application queue by some external mechanism before the application can continue to process messages from the queue.</span></span>  
  
- <span data-ttu-id="f2e53-143">Drop：</span><span class="sxs-lookup"><span data-stu-id="f2e53-143">Drop.</span></span> <span data-ttu-id="f2e53-144">這個選項會捨棄有害訊息，而且該訊息永遠不會傳遞至應用程式。</span><span class="sxs-lookup"><span data-stu-id="f2e53-144">This option drops the poison message and the message is never delivered to the application.</span></span> <span data-ttu-id="f2e53-145">如果訊息的 `TimeToLive` 屬性此時已過期，那麼訊息便可能會出現在傳送者寄不出的信件佇列中。</span><span class="sxs-lookup"><span data-stu-id="f2e53-145">If the message's `TimeToLive` property has expired at this point, then the message may appear in the sender's dead-letter queue.</span></span> <span data-ttu-id="f2e53-146">如果未過期的話，訊息不會出現在任何位置。</span><span class="sxs-lookup"><span data-stu-id="f2e53-146">If not, the message does not appear anywhere.</span></span> <span data-ttu-id="f2e53-147">這個選項表示，使用者尚未指定訊息遺失時的做法。</span><span class="sxs-lookup"><span data-stu-id="f2e53-147">This option indicates that the user has not specified what to do if the message is lost.</span></span>  
  
- <span data-ttu-id="f2e53-148">Reject：</span><span class="sxs-lookup"><span data-stu-id="f2e53-148">Reject.</span></span> <span data-ttu-id="f2e53-149">此選項僅適用于 Windows Vista。</span><span class="sxs-lookup"><span data-stu-id="f2e53-149">This option is available only on Windows Vista.</span></span> <span data-ttu-id="f2e53-150">這會指示訊息佇列（MSMQ）將否定的認可傳回給傳送端佇列管理員，讓應用程式無法接收訊息。</span><span class="sxs-lookup"><span data-stu-id="f2e53-150">This instructs Message Queuing (MSMQ) to send a negative acknowledgment back to the sending queue manager that the application cannot receive the message.</span></span> <span data-ttu-id="f2e53-151">訊息會放在傳送的佇列管理員寄不出的信件佇列中。</span><span class="sxs-lookup"><span data-stu-id="f2e53-151">The message is placed in the sending queue manager's dead-letter queue.</span></span>  
  
- <span data-ttu-id="f2e53-152">Move：</span><span class="sxs-lookup"><span data-stu-id="f2e53-152">Move.</span></span> <span data-ttu-id="f2e53-153">此選項僅適用于 Windows Vista。</span><span class="sxs-lookup"><span data-stu-id="f2e53-153">This option is available only on Windows Vista.</span></span> <span data-ttu-id="f2e53-154">這個選項會將有害訊息移到有害訊息佇列，以便之後讓有害訊息處理應用程式進行處理。</span><span class="sxs-lookup"><span data-stu-id="f2e53-154">This moves the poison message to a poison-message queue for later processing by a poison-message handling application.</span></span> <span data-ttu-id="f2e53-155">有害訊息佇列是應用程式佇列的子佇列。</span><span class="sxs-lookup"><span data-stu-id="f2e53-155">The poison-message queue is a subqueue of the application queue.</span></span> <span data-ttu-id="f2e53-156">有害訊息處理應用程式可以是從有害佇列讀取訊息的 WCF 服務。</span><span class="sxs-lookup"><span data-stu-id="f2e53-156">A poison-message handling application can be a WCF service that reads messages out of the poison queue.</span></span> <span data-ttu-id="f2e53-157">有害佇列是應用程式佇列的子佇列，可以定址為 net. msmq：// \<*machine-name*> / *applicationQueue*;p oison，其中，*電腦名稱稱*是佇列所在的電腦名稱稱，而*applicationQueue*是應用程式特定佇列的名稱。</span><span class="sxs-lookup"><span data-stu-id="f2e53-157">The poison queue is a subqueue of the application queue and can be addressed as net.msmq://\<*machine-name*>/*applicationQueue*;poison, where *machine-name* is the name of the computer on which the queue resides and the *applicationQueue* is the name of the application-specific queue.</span></span>  
  
<span data-ttu-id="f2e53-158">以下為訊息的嘗試傳遞次數上限：</span><span class="sxs-lookup"><span data-stu-id="f2e53-158">The following are the maximum number of delivery attempts made for a message:</span></span>  
  
- <span data-ttu-id="f2e53-159">（（ReceiveRetryCount + 1） \* （MaxRetryCycles + 1））在 Windows Vista 上。</span><span class="sxs-lookup"><span data-stu-id="f2e53-159">((ReceiveRetryCount+1) \* (MaxRetryCycles + 1)) on Windows Vista.</span></span>  
  
- <span data-ttu-id="f2e53-160">（ReceiveRetryCount + 1）在 Windows Server 2003 和 Windows XP 上。</span><span class="sxs-lookup"><span data-stu-id="f2e53-160">(ReceiveRetryCount + 1) on Windows Server 2003 and Windows XP.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="f2e53-161">成功傳遞的訊息不會有任何重試次數。</span><span class="sxs-lookup"><span data-stu-id="f2e53-161">No retries are made for a message that is delivered successfully.</span></span>  
  
 <span data-ttu-id="f2e53-162">為了追蹤嘗試讀取訊息的次數，Windows Vista 維護了長期的訊息屬性來計算中止次數，以及計算訊息在應用程式佇列與子佇列之間移動的次數的「移動計數」屬性。</span><span class="sxs-lookup"><span data-stu-id="f2e53-162">To keep track of the number of times a message read is attempted, Windows Vista maintains a durable message property that counts the number of aborts and a move count property that counts the number of times the message moves between the application queue and subqueues.</span></span> <span data-ttu-id="f2e53-163">WCF 通道會使用這些來計算接收重試計數和重試迴圈計數。</span><span class="sxs-lookup"><span data-stu-id="f2e53-163">The WCF channel uses these to compute the receive retry count and the retry cycles count.</span></span> <span data-ttu-id="f2e53-164">在 Windows Server 2003 和 Windows XP 上，中止計數會由 WCF 通道保留在記憶體中，如果應用程式失敗，則會重設。</span><span class="sxs-lookup"><span data-stu-id="f2e53-164">On Windows Server 2003 and Windows XP, the abort count is maintained in memory by the WCF channel and is reset if the application fails.</span></span> <span data-ttu-id="f2e53-165">此外，WCF 通道可以隨時在記憶體中保留最多256個訊息的中止計數。</span><span class="sxs-lookup"><span data-stu-id="f2e53-165">Also, the WCF channel can hold the abort counts for up to 256 messages in memory at any time.</span></span> <span data-ttu-id="f2e53-166">如果讀取第 257 個訊息，那麼最舊訊息的中止計數就會重設。</span><span class="sxs-lookup"><span data-stu-id="f2e53-166">If a 257th message is read, then the oldest message's abort count is reset.</span></span>  
  
 <span data-ttu-id="f2e53-167">中止計數和移動計數屬性可透過作業內容提供給服務作業。</span><span class="sxs-lookup"><span data-stu-id="f2e53-167">The abort count and move count properties are available to the service operation through the operation context.</span></span> <span data-ttu-id="f2e53-168">以下程式碼範例將說明如何存取這兩個屬性。</span><span class="sxs-lookup"><span data-stu-id="f2e53-168">The following code example shows how to access them.</span></span>  
  
 [!code-csharp[S_UE_MSMQ_Poison#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/s_ue_msmq_poison/cs/service.cs#1)]  
  
 <span data-ttu-id="f2e53-169">WCF 提供兩個標準的佇列系結：</span><span class="sxs-lookup"><span data-stu-id="f2e53-169">WCF provides two standard queued bindings:</span></span>  
  
- <span data-ttu-id="f2e53-170"><xref:System.ServiceModel.NetMsmqBinding>.</span><span class="sxs-lookup"><span data-stu-id="f2e53-170"><xref:System.ServiceModel.NetMsmqBinding>.</span></span> <span data-ttu-id="f2e53-171">.NET Framework 系結，適合用來與其他 WCF 端點執行以佇列為基礎的通訊。</span><span class="sxs-lookup"><span data-stu-id="f2e53-171">A .NET Framework binding suitable for performing queue-based communication with other WCF endpoints.</span></span>  
  
- <span data-ttu-id="f2e53-172"><xref:System.ServiceModel.MsmqIntegration.MsmqIntegrationBinding>.</span><span class="sxs-lookup"><span data-stu-id="f2e53-172"><xref:System.ServiceModel.MsmqIntegration.MsmqIntegrationBinding>.</span></span> <span data-ttu-id="f2e53-173">此繫結適合用來與現有的訊息佇列應用程式進行通訊。</span><span class="sxs-lookup"><span data-stu-id="f2e53-173">A binding suitable for communicating with existing Message Queuing applications.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="f2e53-174">您可以根據 WCF 服務的需求來改變這些系結中的屬性。</span><span class="sxs-lookup"><span data-stu-id="f2e53-174">You can alter properties in these bindings based on the requirements of your WCF service.</span></span> <span data-ttu-id="f2e53-175">對於接收應用程式而言，整個有害訊息處理機制是在本機上進行的。</span><span class="sxs-lookup"><span data-stu-id="f2e53-175">The entire poison message handling mechanism is local to the receiving application.</span></span> <span data-ttu-id="f2e53-176">傳送應用程式看不到這個程序，除非接收應用程式最後停止並且將負值通知傳回至傳送者。</span><span class="sxs-lookup"><span data-stu-id="f2e53-176">The process is invisible to the sending application unless the receiving application ultimately stops and sends a negative acknowledgment back to the sender.</span></span> <span data-ttu-id="f2e53-177">在這種情況下，訊息會移到傳送者寄不出的信件佇列中。</span><span class="sxs-lookup"><span data-stu-id="f2e53-177">In that case, the message is moved to the sender's dead-letter queue.</span></span>  
  
## <a name="best-practice-handling-msmqpoisonmessageexception"></a><span data-ttu-id="f2e53-178">最佳做法：處理 MsmqPoisonMessageException</span><span class="sxs-lookup"><span data-stu-id="f2e53-178">Best Practice: Handling MsmqPoisonMessageException</span></span>  
 <span data-ttu-id="f2e53-179">當服務判定訊息是有害時，佇列的傳輸便會擲回 <xref:System.ServiceModel.MsmqPoisonMessageException>，其中包含有害訊息的 `LookupId`。</span><span class="sxs-lookup"><span data-stu-id="f2e53-179">When the service determines that a message is poison, the queued transport throws a <xref:System.ServiceModel.MsmqPoisonMessageException> that contains the `LookupId` of the poison message.</span></span>  
  
 <span data-ttu-id="f2e53-180">接收應用程式可實作 <xref:System.ServiceModel.Dispatcher.IErrorHandler> 介面，以處理應用程式所需的任何錯誤。</span><span class="sxs-lookup"><span data-stu-id="f2e53-180">A receiving application can implement the <xref:System.ServiceModel.Dispatcher.IErrorHandler> interface to handle any errors that the application requires.</span></span> <span data-ttu-id="f2e53-181">如需詳細資訊，請參閱[擴充對錯誤處理和報告的控制](../samples/extending-control-over-error-handling-and-reporting.md)。</span><span class="sxs-lookup"><span data-stu-id="f2e53-181">For more information, see [Extending Control Over Error Handling and Reporting](../samples/extending-control-over-error-handling-and-reporting.md).</span></span>  
  
 <span data-ttu-id="f2e53-182">應用程式可能需要以某種自動處理的方式將有害訊息移至有害訊息序列，讓服務能夠存取佇列中其餘的訊息。</span><span class="sxs-lookup"><span data-stu-id="f2e53-182">The application may require some kind of automated handling of poison messages that moves the poison messages to a poison message queue so that the service can access the rest of the messages in the queue.</span></span> <span data-ttu-id="f2e53-183">唯一會使用錯誤處理常式機制接聽有害訊息例外狀況的情況，是在 <xref:System.ServiceModel.Configuration.MsmqBindingElementBase.ReceiveErrorHandling%2A> 設定設為 <xref:System.ServiceModel.ReceiveErrorHandling.Fault> 的時候。</span><span class="sxs-lookup"><span data-stu-id="f2e53-183">The only scenario for using the error-handler mechanism to listen for poison-message exceptions is when the <xref:System.ServiceModel.Configuration.MsmqBindingElementBase.ReceiveErrorHandling%2A> setting is set to <xref:System.ServiceModel.ReceiveErrorHandling.Fault>.</span></span> <span data-ttu-id="f2e53-184">Message Queuing 3.0 的有害訊息範例會示範這種行為。</span><span class="sxs-lookup"><span data-stu-id="f2e53-184">The poison-message sample for Message Queuing 3.0 demonstrates this behavior.</span></span> <span data-ttu-id="f2e53-185">以下將說明處理有害訊息時所採取的步驟，包括最佳做法：</span><span class="sxs-lookup"><span data-stu-id="f2e53-185">The following outlines the steps to take to handle poison messages, including best practices:</span></span>  
  
1. <span data-ttu-id="f2e53-186">請確認您的有害設定能反映您應用程式的需求。</span><span class="sxs-lookup"><span data-stu-id="f2e53-186">Ensure your poison settings reflect the requirements of your application.</span></span> <span data-ttu-id="f2e53-187">使用設定時，請確定您瞭解 Windows Vista、Windows Server 2003 和 Windows XP 上訊息佇列功能之間的差異。</span><span class="sxs-lookup"><span data-stu-id="f2e53-187">When working with the settings, ensure that you understand the differences between the capabilities of Message Queuing on Windows Vista, Windows Server 2003, and Windows XP.</span></span>  
  
2. <span data-ttu-id="f2e53-188">如有必要，請執行 `IErrorHandler` 來處理有害訊息錯誤。</span><span class="sxs-lookup"><span data-stu-id="f2e53-188">If necessary, implement the `IErrorHandler` to handle poison-message errors.</span></span> <span data-ttu-id="f2e53-189">由於將 `ReceiveErrorHandling` 設為 `Fault` 時需要使用手動機制將有害訊息從佇列中移出，或更正外部相關的問題，因此通常的使用方式是在 `IErrorHandler` 設為 `ReceiveErrorHandling` 時實作 `Fault`，如下列程式碼中所示。</span><span class="sxs-lookup"><span data-stu-id="f2e53-189">Because setting `ReceiveErrorHandling` to `Fault` requires a manual mechanism to move the poison message out of the queue or to correct an external dependent issue, the typical usage is to implement `IErrorHandler` when `ReceiveErrorHandling` is set to `Fault`, as shown in the following code.</span></span>  
  
     [!code-csharp[S_UE_MSMQ_Poison#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/s_ue_msmq_poison/cs/poisonerrorhandler.cs#2)]  
  
3. <span data-ttu-id="f2e53-190">建立服務行為可使用的 `PoisonBehaviorAttribute`。</span><span class="sxs-lookup"><span data-stu-id="f2e53-190">Create a `PoisonBehaviorAttribute` that the service behavior can use.</span></span> <span data-ttu-id="f2e53-191">這個行為會在發送器上安裝 `IErrorHandler`。</span><span class="sxs-lookup"><span data-stu-id="f2e53-191">The behavior installs the `IErrorHandler` on the dispatcher.</span></span> <span data-ttu-id="f2e53-192">請參閱以下程式碼範例。</span><span class="sxs-lookup"><span data-stu-id="f2e53-192">See the following code example.</span></span>  
  
     [!code-csharp[S_UE_MSMQ_Poison#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/s_ue_msmq_poison/cs/poisonbehaviorattribute.cs#3)]  
  
4. <span data-ttu-id="f2e53-193">確認您的服務已標註為有害行為屬性。</span><span class="sxs-lookup"><span data-stu-id="f2e53-193">Ensure that your service is annotated with the poison behavior attribute.</span></span>  

 <span data-ttu-id="f2e53-194">此外，如果 `ReceiveErrorHandling` 設為 `Fault`，則 `ServiceHost` 會在遇到有害訊息時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="f2e53-194">In addition, if the `ReceiveErrorHandling` is set to `Fault`, the `ServiceHost` faults when encountering the poison message.</span></span> <span data-ttu-id="f2e53-195">您可以連結到發生錯誤的事件並關閉服務、採取矯正措施，然後重新啟動。</span><span class="sxs-lookup"><span data-stu-id="f2e53-195">You can hook up to the faulted event and shut down the service, take corrective actions, and restart.</span></span> <span data-ttu-id="f2e53-196">例如，可以標註傳播至 `LookupId` 的 <xref:System.ServiceModel.MsmqPoisonMessageException> 中的 `IErrorHandler`，當服務主機發生錯誤時，您就可以使用 `System.Messaging` API 接收來自佇列的訊息 (使用 `LookupId` 移除佇列中的訊息)，以及將訊息保存在某些外部儲存區或另一個佇列中。</span><span class="sxs-lookup"><span data-stu-id="f2e53-196">For example, the `LookupId` in the <xref:System.ServiceModel.MsmqPoisonMessageException> propagated to the `IErrorHandler` can be noted and when the service host faults, you could use the `System.Messaging` API to receive the message from the queue using the `LookupId` to remove the message from the queue and store the message in some external store or another queue.</span></span> <span data-ttu-id="f2e53-197">然後您可以重新啟動 `ServiceHost` 並繼續進行正常處理。</span><span class="sxs-lookup"><span data-stu-id="f2e53-197">You can then restart `ServiceHost` to resume normal processing.</span></span> <span data-ttu-id="f2e53-198">[MSMQ 4.0 中的有害訊息處理](../samples/poison-message-handling-in-msmq-4-0.md)示範此行為。</span><span class="sxs-lookup"><span data-stu-id="f2e53-198">The [Poison Message Handling in MSMQ 4.0](../samples/poison-message-handling-in-msmq-4-0.md) demonstrates this behavior.</span></span>  
  
## <a name="transaction-time-out-and-poison-messages"></a><span data-ttu-id="f2e53-199">交易逾時及有害訊息</span><span class="sxs-lookup"><span data-stu-id="f2e53-199">Transaction Time-Out and Poison Messages</span></span>  
 <span data-ttu-id="f2e53-200">佇列傳輸通道和使用者程式碼之間可能會發生一種類別的錯誤。</span><span class="sxs-lookup"><span data-stu-id="f2e53-200">A class of errors can occur between the queued transport channel and the user code.</span></span> <span data-ttu-id="f2e53-201">這些錯誤可能會在中間的各層中偵測到，例如訊息安全層或服務分派邏輯。</span><span class="sxs-lookup"><span data-stu-id="f2e53-201">These errors can be detected by layers in-between, such as the message security layer or the service dispatching logic.</span></span> <span data-ttu-id="f2e53-202">例如，在 SOAP 安全層中偵測到遺失了 X.509 憑證，以及遺失的動作就是訊息會被分派至應用程式的情況。</span><span class="sxs-lookup"><span data-stu-id="f2e53-202">For example, a missing X.509 certificate detected in the SOAP security layer and a missing action are cases where the message does get dispatched to the application.</span></span> <span data-ttu-id="f2e53-203">發生這類情況時，服務模型會捨棄訊息。</span><span class="sxs-lookup"><span data-stu-id="f2e53-203">When this happens, the service model drops the message.</span></span> <span data-ttu-id="f2e53-204">由於訊息是在異動中讀取，而且不會提供異動的結果，因此異動最後會逾時、中止，而訊息則會放回佇列中。</span><span class="sxs-lookup"><span data-stu-id="f2e53-204">Because the message is read in a transaction and an outcome for that transaction cannot be provided, the transaction eventually times out, aborts, and the message is put back into the queue.</span></span> <span data-ttu-id="f2e53-205">換句話說，針對特定的錯誤類別，交易不會立即中止，而是等到交易超時為止。您可以使用修改服務的交易超時 <xref:System.ServiceModel.ServiceBehaviorAttribute> 。</span><span class="sxs-lookup"><span data-stu-id="f2e53-205">In other words, for a certain class of errors, the transaction does not immediately abort but waits until the transaction times out. You can modify the transaction time-out for a service using <xref:System.ServiceModel.ServiceBehaviorAttribute>.</span></span>  
  
 <span data-ttu-id="f2e53-206">若要以全電腦為基礎來變更交易超時，請修改 machine.config 檔案，並設定適當的交易超時。請務必注意，視交易中的超時設定而定，交易最終會中止並回到佇列，而且其中止計數會遞增。</span><span class="sxs-lookup"><span data-stu-id="f2e53-206">To change the transaction time-out on a computer-wide basis, modify the machine.config file and set the appropriate transaction time-out. It is important to note that, depending on the time-out set in the transaction, the transaction eventually aborts and goes back to the queue and its abort count is incremented.</span></span> <span data-ttu-id="f2e53-207">最後，訊息會變成有害，並且根據使用者的設定進行正確的處置。</span><span class="sxs-lookup"><span data-stu-id="f2e53-207">Eventually, the message becomes poison and the right disposition is made according to the user settings.</span></span>  
  
## <a name="sessions-and-poison-messages"></a><span data-ttu-id="f2e53-208">工作階段及有害訊息</span><span class="sxs-lookup"><span data-stu-id="f2e53-208">Sessions and Poison Messages</span></span>  
 <span data-ttu-id="f2e53-209">工作階段如同單一訊息一樣，會進行相同的重試和有害訊息處理程序。</span><span class="sxs-lookup"><span data-stu-id="f2e53-209">A session undergoes the same retry and poison-message handling procedures as a single message.</span></span> <span data-ttu-id="f2e53-210">先前所列出的有害訊息屬性會套用到整個工作階段。</span><span class="sxs-lookup"><span data-stu-id="f2e53-210">The properties previously listed for poison messages apply to the entire session.</span></span> <span data-ttu-id="f2e53-211">這表示會重試整個工作階段，而且如果訊息遭拒絕，將移至最後的有害訊息佇列或傳送者寄不出的信件佇列。</span><span class="sxs-lookup"><span data-stu-id="f2e53-211">This means that the entire session is retried and goes to a final poison-message queue or the sender’s dead-letter queue if the message is rejected.</span></span>  
  
## <a name="batching-and-poison-messages"></a><span data-ttu-id="f2e53-212">批次處理及有害訊息</span><span class="sxs-lookup"><span data-stu-id="f2e53-212">Batching and Poison Messages</span></span>  
 <span data-ttu-id="f2e53-213">如果訊息變成有害訊息，而且是批次的一部分，那麼整個批次都會復原，而通道會回到一次讀取一個訊息的狀態。</span><span class="sxs-lookup"><span data-stu-id="f2e53-213">If a message becomes a poison message and is part of a batch, then the entire batch is rolled back and the channel returns to reading one message at a time.</span></span> <span data-ttu-id="f2e53-214">如需批次處理的詳細資訊，請參閱[批次處理交易中的訊息](batching-messages-in-a-transaction.md)</span><span class="sxs-lookup"><span data-stu-id="f2e53-214">For more information about batching, see [Batching Messages in a Transaction](batching-messages-in-a-transaction.md)</span></span>  
  
## <a name="poison-message-handling-for-messages-in-a-poison-queue"></a><span data-ttu-id="f2e53-215">有害佇列中之訊息的有害訊息處理</span><span class="sxs-lookup"><span data-stu-id="f2e53-215">Poison-message Handling for Messages in a Poison Queue</span></span>  
 <span data-ttu-id="f2e53-216">當訊息放入有害訊息佇列時，有害訊息處理就不會結束。</span><span class="sxs-lookup"><span data-stu-id="f2e53-216">Poison-message handling does not end when a message is placed in the poison-message queue.</span></span> <span data-ttu-id="f2e53-217">有害訊息佇列中的訊息必須繼續讀取和處理。</span><span class="sxs-lookup"><span data-stu-id="f2e53-217">Messages in the poison-message queue must still be read and handled.</span></span> <span data-ttu-id="f2e53-218">您可以在最終有害子佇列中讀取訊息時，使用有害訊息處理設定的子集。</span><span class="sxs-lookup"><span data-stu-id="f2e53-218">You can use a subset of the poison-message handling settings when reading messages from the final poison subqueue.</span></span> <span data-ttu-id="f2e53-219">適當的設定為 `ReceiveRetryCount` 和 `ReceiveErrorHandling`。</span><span class="sxs-lookup"><span data-stu-id="f2e53-219">The applicable settings are `ReceiveRetryCount` and `ReceiveErrorHandling`.</span></span> <span data-ttu-id="f2e53-220">您可以將 `ReceiveErrorHandling` 設定為 Drop、Reject 或 Fault。</span><span class="sxs-lookup"><span data-stu-id="f2e53-220">You can set `ReceiveErrorHandling` to Drop, Reject, or Fault.</span></span> <span data-ttu-id="f2e53-221">如果 `MaxRetryCycles` 設為 Move，則會忽略 `ReceiveErrorHandling` 並且擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="f2e53-221">`MaxRetryCycles` is ignored and an exception is thrown if `ReceiveErrorHandling` is set to Move.</span></span>  
  
## <a name="windows-vista-windows-server-2003-and-windows-xp-differences"></a><span data-ttu-id="f2e53-222">Windows Vista、Windows Server 2003 及 Windows XP 的差異</span><span class="sxs-lookup"><span data-stu-id="f2e53-222">Windows Vista, Windows Server 2003, and Windows XP Differences</span></span>  
 <span data-ttu-id="f2e53-223">如先前所述，並非所有的有害訊息處理設定都適用于 Windows Server 2003 和 Windows XP。</span><span class="sxs-lookup"><span data-stu-id="f2e53-223">As noted earlier, not all poison-message handling settings apply to Windows Server 2003 and Windows XP.</span></span> <span data-ttu-id="f2e53-224">Windows Server 2003、Windows XP 和 Windows Vista 上訊息佇列的下列主要差異，與有害訊息處理有關：</span><span class="sxs-lookup"><span data-stu-id="f2e53-224">The following key differences between Message Queuing on Windows Server 2003, Windows XP, and Windows Vista are relevant to poison-message handling:</span></span>  
  
- <span data-ttu-id="f2e53-225">Windows Vista 中的訊息佇列支援子佇列，而 Windows Server 2003 和 Windows XP 則不支援子佇列。</span><span class="sxs-lookup"><span data-stu-id="f2e53-225">Message Queuing in Windows Vista supports subqueues, while Windows Server 2003 and Windows XP do not support subqueues.</span></span> <span data-ttu-id="f2e53-226">子佇列是在有害訊息處理中使用。</span><span class="sxs-lookup"><span data-stu-id="f2e53-226">Subqueues are used in poison-message handling.</span></span> <span data-ttu-id="f2e53-227">重試佇列和有害佇列都是應用程式佇列的子佇列，應用程式佇列是根據有害訊息處理設定而建立的。</span><span class="sxs-lookup"><span data-stu-id="f2e53-227">The retry queues and the poison queue are subqueues to the application queue that is created based on the poison-message handling settings.</span></span> <span data-ttu-id="f2e53-228">`MaxRetryCycles` 會指示要建立多少重試子佇列。</span><span class="sxs-lookup"><span data-stu-id="f2e53-228">The `MaxRetryCycles` dictates how many retry subqueues to create.</span></span> <span data-ttu-id="f2e53-229">因此，在 Windows Server 2003 或 Windows XP 上執行時， `MaxRetryCycles` 會忽略且 `ReceiveErrorHandling.Move` 不允許。</span><span class="sxs-lookup"><span data-stu-id="f2e53-229">Therefore, when running on Windows Server 2003 or Windows XP, `MaxRetryCycles` are ignored and `ReceiveErrorHandling.Move` is not allowed.</span></span>  
  
- <span data-ttu-id="f2e53-230">Windows Vista 中的訊息佇列支援負面認可，而 Windows Server 2003 和 Windows XP 則不會。</span><span class="sxs-lookup"><span data-stu-id="f2e53-230">Message Queuing in Windows Vista supports negative acknowledgment, while Windows Server 2003 and Windows XP do not.</span></span> <span data-ttu-id="f2e53-231">來自接收佇列管理員的負認可會造成傳送佇列管理員將拒絕的訊息放在寄不出的信件佇列中。</span><span class="sxs-lookup"><span data-stu-id="f2e53-231">A negative acknowledgment from the receiving queue manager causes the sending queue manager to place the rejected message in the dead-letter queue.</span></span> <span data-ttu-id="f2e53-232">因此， `ReceiveErrorHandling.Reject` Windows Server 2003 和 WINDOWS XP 不允許使用。</span><span class="sxs-lookup"><span data-stu-id="f2e53-232">As such, `ReceiveErrorHandling.Reject` is not allowed with Windows Server 2003 and Windows XP.</span></span>  
  
- <span data-ttu-id="f2e53-233">Windows Vista 中的訊息佇列支援訊息屬性，它會保留嘗試傳遞訊息的次數計數。</span><span class="sxs-lookup"><span data-stu-id="f2e53-233">Message Queuing in Windows Vista supports a message property that keeps count of the number of times message delivery is attempted.</span></span> <span data-ttu-id="f2e53-234">Windows Server 2003 和 Windows XP 上無法使用此 [中止計數] 屬性。</span><span class="sxs-lookup"><span data-stu-id="f2e53-234">This abort count property is not available on Windows Server 2003 and Windows XP.</span></span> <span data-ttu-id="f2e53-235">WCF 會在記憶體中維護中止計數，因此當伺服陣列中的多個 WCF 服務讀取相同的訊息時，這個屬性可能不會包含正確的值。</span><span class="sxs-lookup"><span data-stu-id="f2e53-235">WCF maintains the abort count in memory, so it is possible that this property may not contain an accurate value when the same message is read by more than one WCF service in a farm.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="f2e53-236">請參閱</span><span class="sxs-lookup"><span data-stu-id="f2e53-236">See also</span></span>

- [<span data-ttu-id="f2e53-237">佇列概觀</span><span class="sxs-lookup"><span data-stu-id="f2e53-237">Queues Overview</span></span>](queues-overview.md)
- [<span data-ttu-id="f2e53-238">Windows Vista、Windows Server 2003 和 Windows XP 之間的佇列功能差異</span><span class="sxs-lookup"><span data-stu-id="f2e53-238">Differences in Queuing Features in Windows Vista, Windows Server 2003, and Windows XP</span></span>](diff-in-queue-in-vista-server-2003-windows-xp.md)
- [<span data-ttu-id="f2e53-239">指定及處理合約與服務中的錯誤</span><span class="sxs-lookup"><span data-stu-id="f2e53-239">Specifying and Handling Faults in Contracts and Services</span></span>](../specifying-and-handling-faults-in-contracts-and-services.md)
