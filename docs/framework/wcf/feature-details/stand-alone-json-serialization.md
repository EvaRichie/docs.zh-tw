---
title: 使用 DataContractJsonSerializer 的獨立 JSON 序列化
ms.date: 03/30/2017
ms.assetid: 312bd7b2-1300-4b12-801e-ebe742bd2287
ms.openlocfilehash: 259d5da544262b5cae08e1be9e8ea6e077d5b947
ms.sourcegitcommit: ee5b798427f81237a3c23d1fd81fff7fdc21e8d3
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 05/28/2020
ms.locfileid: "84144925"
---
# <a name="stand-alone-json-serialization-using-datacontractjsonserializer"></a><span data-ttu-id="bfe7a-102">使用 DataContractJsonSerializer 的獨立 JSON 序列化</span><span class="sxs-lookup"><span data-stu-id="bfe7a-102">Stand-Alone JSON Serialization using DataContractJsonSerializer</span></span>

> [!NOTE]
> <span data-ttu-id="bfe7a-103">本文說明 <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> 。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-103">This article is about <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>.</span></span> <span data-ttu-id="bfe7a-104">對於涉及序列化和還原序列化 JSON 的大部分案例，我們建議在 system.string[命名空間](../../../standard/serialization/system-text-json-overview.md)中的 api。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-104">For most scenarios that involve serializing and deserializing JSON, we recommend the APIs in the [System.Text.Json namespace](../../../standard/serialization/system-text-json-overview.md).</span></span>

<span data-ttu-id="bfe7a-105">JSON (JavaScript 物件標記法) 是專為在瀏覽器內的網頁上執行的 JavaScript 程式碼而設計的資料格式。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-105">JSON (JavaScript Object Notation) is a data format that is specifically designed to be used by JavaScript code running on Web pages inside the browser.</span></span> <span data-ttu-id="bfe7a-106">這是在 Windows Communication Foundation （WCF）中建立的 ASP.NET AJAX 服務所使用的預設資料格式。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-106">It is the default data format used by ASP.NET AJAX services created in Windows Communication Foundation (WCF).</span></span>

<span data-ttu-id="bfe7a-107">此外，在未與 ASP.NET 整合的情況下建立 AJAX 服務時，也可以使用這個格式，在這種情況中，XML 是預設值，不過您也可以選擇 JSON。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-107">This format can also be used when creating AJAX services without integrating with ASP.NET - in this case, XML is the default but JSON can be chosen.</span></span>

<span data-ttu-id="bfe7a-108">最後，如果您需要 JSON 支援但不想建立 AJAX 服務，<xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> 可讓您直接將 .NET 物件序列化為 JSON 資料，以及將這類資料還原序列化為 .NET 型別的執行個體。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-108">Finally, if you require JSON support but are not creating an AJAX service, the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> makes it possible to directly serialize .NET objects into JSON data and to deserialize such data back into instances of .NET types.</span></span> <span data-ttu-id="bfe7a-109">如需如何執行這項操作的說明，請參閱[如何：序列化和還原序列化 JSON 資料](../../../../docs/framework/wcf/feature-details/how-to-serialize-and-deserialize-json-data.md)。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-109">For a description of how to do this, see [How to: Serialize and Deserialize JSON Data](../../../../docs/framework/wcf/feature-details/how-to-serialize-and-deserialize-json-data.md).</span></span>

<span data-ttu-id="bfe7a-110">使用 JSON 時，相同的 .NET 型別會受到支援，不過有少數的例外情形，如同 <xref:System.Runtime.Serialization.DataContractSerializer> 所支援的一樣。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-110">When working with JSON, the same .NET types are supported, with a few exceptions, as are supported by the <xref:System.Runtime.Serialization.DataContractSerializer>.</span></span> <span data-ttu-id="bfe7a-111">如需支援的類型清單，請參閱[資料合約序列化程式支援的類型](../../../../docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md)。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-111">For a list of the types supported, see [Types Supported by the Data Contract Serializer](../../../../docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md).</span></span> <span data-ttu-id="bfe7a-112">其中包括大部分的基本型別、大部分的陣列和集合型別，以及使用 <xref:System.Runtime.Serialization.DataContractAttribute> 和 <xref:System.Runtime.Serialization.DataMemberAttribute> 的複雜型別。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-112">This includes most primitive types, most array and collection types, as well as complex types that use the <xref:System.Runtime.Serialization.DataContractAttribute> and <xref:System.Runtime.Serialization.DataMemberAttribute>.</span></span>

## <a name="mapping-net-types-to-json-types"></a><span data-ttu-id="bfe7a-113">將 .NET 型別對應至 JSON 型別</span><span class="sxs-lookup"><span data-stu-id="bfe7a-113">Mapping .NET types to JSON Types</span></span>

<span data-ttu-id="bfe7a-114">下表說明由序列化和還原序列化程序對應時，.NET 型別和 JSON/JavaScript 型別之間的對應關係。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-114">The following table shows the correspondence between .NET types and JSON/JavaScript types when mapped by serialization and deserialization procedures.</span></span>

|<span data-ttu-id="bfe7a-115">.NET 型別</span><span class="sxs-lookup"><span data-stu-id="bfe7a-115">.NET Types</span></span>|<span data-ttu-id="bfe7a-116">JSON/JavaScript</span><span class="sxs-lookup"><span data-stu-id="bfe7a-116">JSON/JavaScript</span></span>|<span data-ttu-id="bfe7a-117">備忘錄</span><span class="sxs-lookup"><span data-stu-id="bfe7a-117">Notes</span></span>|
|----------------|----------------------|-----------|
|<span data-ttu-id="bfe7a-118">所有數字型別，例如 <xref:System.Int32>、<xref:System.Decimal> 或 <xref:System.Double></span><span class="sxs-lookup"><span data-stu-id="bfe7a-118">All numeric types, for example <xref:System.Int32>, <xref:System.Decimal> or <xref:System.Double></span></span>|<span data-ttu-id="bfe7a-119">數字</span><span class="sxs-lookup"><span data-stu-id="bfe7a-119">Number</span></span>|<span data-ttu-id="bfe7a-120">`Double.NaN`、`Double.PositiveInfinity` 和 `Double.NegativeInfinity` 等特殊值不受支援，並且會造成無效的 JSON。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-120">Special values such as  `Double.NaN`, `Double.PositiveInfinity` and `Double.NegativeInfinity` are not supported and result in invalid JSON.</span></span>|
|<xref:System.Enum>|<span data-ttu-id="bfe7a-121">數字</span><span class="sxs-lookup"><span data-stu-id="bfe7a-121">Number</span></span>|<span data-ttu-id="bfe7a-122">請參閱本主題稍後的＜列舉與 JSON＞。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-122">See "Enumerations and JSON" later in this topic.</span></span>|
|<xref:System.Boolean>|<span data-ttu-id="bfe7a-123">布林值</span><span class="sxs-lookup"><span data-stu-id="bfe7a-123">Boolean</span></span>|--|
|<span data-ttu-id="bfe7a-124"><xref:System.String>, <xref:System.Char></span><span class="sxs-lookup"><span data-stu-id="bfe7a-124"><xref:System.String>, <xref:System.Char></span></span>|<span data-ttu-id="bfe7a-125">String</span><span class="sxs-lookup"><span data-stu-id="bfe7a-125">String</span></span>|--|
|<span data-ttu-id="bfe7a-126"><xref:System.TimeSpan>, <xref:System.Guid>, <xref:System.Uri></span><span class="sxs-lookup"><span data-stu-id="bfe7a-126"><xref:System.TimeSpan>, <xref:System.Guid>, <xref:System.Uri></span></span>|<span data-ttu-id="bfe7a-127">String</span><span class="sxs-lookup"><span data-stu-id="bfe7a-127">String</span></span>|<span data-ttu-id="bfe7a-128">這些類型在 JSON 中的格式與 XML 相同（基本上是以 ISO 8601 持續時間格式的 TimeSpan，"12345678-ABCD-abcd-ABCD-1234567890AB" 格式中的 GUID，以及 "" 的自然字串形式 http://www.example.com ）。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-128">The format of these types in JSON is the same as in XML (essentially, TimeSpan in the ISO 8601 Duration format, GUID in the "12345678-ABCD-ABCD-ABCD-1234567890AB" format and URI in its natural string form like "http://www.example.com").</span></span> <span data-ttu-id="bfe7a-129">如需精確的資訊，請參閱[資料合約架構參考](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md)。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-129">For precise information, see [Data Contract Schema Reference](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span></span>|
|<xref:System.Xml.XmlQualifiedName>|<span data-ttu-id="bfe7a-130">String</span><span class="sxs-lookup"><span data-stu-id="bfe7a-130">String</span></span>|<span data-ttu-id="bfe7a-131">格式為 "name:namespace" (第一個冒號前面的就是名稱)。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-131">The format is "name:namespace" (anything before the first colon is the name).</span></span> <span data-ttu-id="bfe7a-132">名稱或命名空間可能會遺失。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-132">Either the name or the namespace can be missing.</span></span> <span data-ttu-id="bfe7a-133">如果沒有命名空間，冒號也可以省略。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-133">If there is no namespace the colon can be omitted as well.</span></span>|
|<span data-ttu-id="bfe7a-134">型別 <xref:System.Array> 的 <xref:System.Byte></span><span class="sxs-lookup"><span data-stu-id="bfe7a-134"><xref:System.Array> of type <xref:System.Byte></span></span>|<span data-ttu-id="bfe7a-135">數字陣列</span><span class="sxs-lookup"><span data-stu-id="bfe7a-135">Array of numbers</span></span>|<span data-ttu-id="bfe7a-136">每個數字代表一個位元組值。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-136">Each number represents the value of one byte.</span></span>|
|<xref:System.DateTime>|<span data-ttu-id="bfe7a-137">DateTime 或字串</span><span class="sxs-lookup"><span data-stu-id="bfe7a-137">DateTime or String</span></span>|<span data-ttu-id="bfe7a-138">請參閱本主題稍後的＜日期/時間與 JSON＞。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-138">See Dates/Times and JSON later in this topic.</span></span>|
|<xref:System.DateTimeOffset>|<span data-ttu-id="bfe7a-139">複雜類型</span><span class="sxs-lookup"><span data-stu-id="bfe7a-139">Complex type</span></span>|<span data-ttu-id="bfe7a-140">請參閱本主題稍後的＜日期/時間與 JSON＞。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-140">See Dates/Times and JSON later in this topic.</span></span>|
|<span data-ttu-id="bfe7a-141">XML 和 ADO.NET 型別 (<xref:System.Xml.XmlElement>、</span><span class="sxs-lookup"><span data-stu-id="bfe7a-141">XML and ADO.NET types (<xref:System.Xml.XmlElement>,</span></span><br /><br /> <span data-ttu-id="bfe7a-142"><xref:System.Xml.Linq.XElement>.</span><span class="sxs-lookup"><span data-stu-id="bfe7a-142"><xref:System.Xml.Linq.XElement>.</span></span> <span data-ttu-id="bfe7a-143"><xref:System.Xml.XmlNode> 的陣列、</span><span class="sxs-lookup"><span data-stu-id="bfe7a-143">Arrays of <xref:System.Xml.XmlNode>,</span></span><br /><br /> <span data-ttu-id="bfe7a-144"><xref:System.Runtime.Serialization.ISerializable>,</span><span class="sxs-lookup"><span data-stu-id="bfe7a-144"><xref:System.Runtime.Serialization.ISerializable>,</span></span><br /><br /> <span data-ttu-id="bfe7a-145"><xref:System.Data.DataSet>).</span><span class="sxs-lookup"><span data-stu-id="bfe7a-145"><xref:System.Data.DataSet>).</span></span>|<span data-ttu-id="bfe7a-146">String</span><span class="sxs-lookup"><span data-stu-id="bfe7a-146">String</span></span>|<span data-ttu-id="bfe7a-147">請參閱本主題的＜XML 型別與 JSON＞一節。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-147">See the XML Types and JSON section of this topic.</span></span>|
|<xref:System.DBNull>|<span data-ttu-id="bfe7a-148">空的複雜型別</span><span class="sxs-lookup"><span data-stu-id="bfe7a-148">Empty complex type</span></span>|--|
|<span data-ttu-id="bfe7a-149">集合、字典與陣列</span><span class="sxs-lookup"><span data-stu-id="bfe7a-149">Collections, dictionaries, and arrays</span></span>|<span data-ttu-id="bfe7a-150">Array</span><span class="sxs-lookup"><span data-stu-id="bfe7a-150">Array</span></span>|<span data-ttu-id="bfe7a-151">請參閱本主題的＜集合、字典與陣列＞一節。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-151">See the Collections, Dictionaries, and Arrays section of this topic.</span></span>|
|<span data-ttu-id="bfe7a-152">複雜型別 (已套用 <xref:System.Runtime.Serialization.DataContractAttribute> 或 <xref:System.SerializableAttribute>)</span><span class="sxs-lookup"><span data-stu-id="bfe7a-152">Complex types (with the <xref:System.Runtime.Serialization.DataContractAttribute> or <xref:System.SerializableAttribute> applied)</span></span>|<span data-ttu-id="bfe7a-153">複雜類型</span><span class="sxs-lookup"><span data-stu-id="bfe7a-153">Complex type</span></span>|<span data-ttu-id="bfe7a-154">資料成員成為 JavaScript 複雜類型的成員。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-154">Data members become members of the JavaScript complex type.</span></span>|
|<span data-ttu-id="bfe7a-155">實作 <xref:System.Runtime.Serialization.ISerializable> 介面的複雜型別)</span><span class="sxs-lookup"><span data-stu-id="bfe7a-155">Complex types implementing the <xref:System.Runtime.Serialization.ISerializable> interface)</span></span>|<span data-ttu-id="bfe7a-156">複雜類型</span><span class="sxs-lookup"><span data-stu-id="bfe7a-156">Complex type</span></span>|<span data-ttu-id="bfe7a-157">與其他複雜型別相同，但不支援某些 <xref:System.Runtime.Serialization.ISerializable> 型別，請參閱本主題的「進階資訊」一節中有關 ISerializable 支援的部分。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-157">Same as other complex types but some <xref:System.Runtime.Serialization.ISerializable> types are not supported – see the ISerializable Support part of the Advanced Information section of this topic.</span></span>|
|<span data-ttu-id="bfe7a-158">任何型別的 `Null` 值</span><span class="sxs-lookup"><span data-stu-id="bfe7a-158">`Null` value for any type</span></span>|<span data-ttu-id="bfe7a-159">null</span><span class="sxs-lookup"><span data-stu-id="bfe7a-159">Null</span></span>|<span data-ttu-id="bfe7a-160">也支援可為 null 的實數值型別，並以與不可為 null 的實數值型別相同的方式對應至 JSON。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-160">Nullable value types are also supported and map to JSON in the same way as non-nullable value types.</span></span>|

### <a name="enumerations-and-json"></a><span data-ttu-id="bfe7a-161">列舉與 JSON</span><span class="sxs-lookup"><span data-stu-id="bfe7a-161">Enumerations and JSON</span></span>

<span data-ttu-id="bfe7a-162">在 JSON 中，列舉成員值會被視為數字，它處理這些值的方式與資料合約不同。在資料合約中，這些值會包含為成員名稱。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-162">Enumeration member values are treated as numbers in JSON, which is different from how they are treated in data contracts, where they are included as member names.</span></span> <span data-ttu-id="bfe7a-163">如需資料合約處理的詳細資訊，請參閱[資料合約中的列舉類型](../../../../docs/framework/wcf/feature-details/enumeration-types-in-data-contracts.md)。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-163">For more information about the data contract treatment, see [Enumeration Types in Data Contracts](../../../../docs/framework/wcf/feature-details/enumeration-types-in-data-contracts.md).</span></span>

- <span data-ttu-id="bfe7a-164">例如，如果您具有 `public enum Color {red, green, blue, yellow, pink}`，則序列化 `yellow` 會產生數字 3，而不是字串 "yellow"。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-164">For example, if you have `public enum Color {red, green, blue, yellow, pink}`, serializing `yellow` produces the number 3 and not the string "yellow".</span></span>

- <span data-ttu-id="bfe7a-165">所有 `enum` 成員都是可序列化的。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-165">All `enum` members are serializable.</span></span> <span data-ttu-id="bfe7a-166">如果使用的話，<xref:System.Runtime.Serialization.EnumMemberAttribute> 和 <xref:System.NonSerializedAttribute> 屬性會被忽略。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-166">The <xref:System.Runtime.Serialization.EnumMemberAttribute> and the <xref:System.NonSerializedAttribute> attributes are ignored if used.</span></span>

- <span data-ttu-id="bfe7a-167">您可以還原序列化不存在的 `enum` 值，例如，值 87 可以還原序列化為先前的 Color 列舉，即使沒有定義對應的色彩名稱亦然。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-167">It is possible to deserialize a nonexistent `enum` value - for example, the value 87 can be deserialized into the previous Color enum even though there is no corresponding color name defined.</span></span>

- <span data-ttu-id="bfe7a-168">`enum` 不是特殊旗標，且被視為和任何其他 `enum` 相同。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-168">A flags `enum` is not special and is treated the same as any other `enum`.</span></span>

### <a name="datestimes-and-json"></a><span data-ttu-id="bfe7a-169">日期/時間與 JSON</span><span class="sxs-lookup"><span data-stu-id="bfe7a-169">Dates/Times and JSON</span></span>

<span data-ttu-id="bfe7a-170">JSON 格式並未直接支援日期和時間。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-170">The JSON format does not directly support dates and times.</span></span> <span data-ttu-id="bfe7a-171">然而，它們相當常用，因此，ASP.NET AJAX 為這些型別提供了特別支援。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-171">However, they are very commonly used and ASP.NET AJAX provides special support for these types.</span></span> <span data-ttu-id="bfe7a-172">使用 ASP.NET AJAX Proxy 時，.NET 中的 型別會完全對應至 JavaScript 中的  型別。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-172">When using ASP.NET AJAX proxies, the <xref:System.DateTime> type in .NET fully corresponds to the `DateTime` type in JavaScript.</span></span>

- <span data-ttu-id="bfe7a-173">不使用 ASP.NET 時，<xref:System.DateTime> 型別在 JSON 中會以具有特殊格式的字串來表示，本主題的「進階資訊」一節中會加以說明。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-173">When not using ASP.NET, a <xref:System.DateTime> type is represented in JSON as a string with a special format that is described in the Advanced Information section of this topic.</span></span>

- <span data-ttu-id="bfe7a-174">JSON 中的 <xref:System.DateTimeOffset> 將以複雜型別來表示：{"DateTime":dateTime,"OffsetMinutes":offsetMinutes}。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-174"><xref:System.DateTimeOffset> is represented in JSON as a complex type: {"DateTime":dateTime,"OffsetMinutes":offsetMinutes}.</span></span> <span data-ttu-id="bfe7a-175">`offsetMinutes` 成員是與相關事件位置相關聯的格林威治時間 (GMT) 的本機時間位移，而格林威治時間現在也稱為 Coordinated Universal Time (UTC)。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-175">The `offsetMinutes` member is the local time offset from Greenwich Mean Time (GMT), also now referred to as Coordinated Universal Time (UTC), associated with the location of the event of interest.</span></span> <span data-ttu-id="bfe7a-176">`dateTime` 成員代表發生相關事件時的時間執行個體 (同樣地，當 ASP.NET AJAX 正在使用中時，它在 JavaScript 中會變成 `DateTime`，否則會變成字串)。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-176">The `dateTime` member represents the instance in time when the event of interest occurred (again, it becomes a `DateTime` in JavaScript when ASP.NET AJAX is in use and a string when it is not).</span></span> <span data-ttu-id="bfe7a-177">在序列化時，`dateTime` 成員永遠會序列化為 GMT。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-177">On serialization, the `dateTime` member is always serialized in GMT.</span></span> <span data-ttu-id="bfe7a-178">因此，如果要描述紐約時間 3:00 AM，`dateTime` 會有 8:00 AM 的時間元件，而且 `offsetMinutes` 為 -300，即從 GMT 減去 300 分鐘或是 5 小時。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-178">So, if describing 3:00 AM New York time, `dateTime` has a time component of 8:00 AM and `offsetMinutes` are 300 (minus 300 minutes or 5 hours from GMT).</span></span>

  > [!NOTE]
  > <span data-ttu-id="bfe7a-179">在序列化為 JSON 時，<xref:System.DateTime> 和 <xref:System.DateTimeOffset> 物件只會保存精確度到毫秒的資訊。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-179"><xref:System.DateTime> and <xref:System.DateTimeOffset> objects, when serialized to JSON, only preserve information to millisecond precision.</span></span> <span data-ttu-id="bfe7a-180">次毫秒值 (微/奈秒) 會在序列化期間遺失。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-180">Sub-millisecond values (micro/nanoseconds) are lost during serialization.</span></span>

### <a name="xml-types-and-json"></a><span data-ttu-id="bfe7a-181">XML 型別與 JSON</span><span class="sxs-lookup"><span data-stu-id="bfe7a-181">XML Types and JSON</span></span>

<span data-ttu-id="bfe7a-182">XML 型別成為 JSON 字串。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-182">XML types become JSON strings.</span></span>

- <span data-ttu-id="bfe7a-183">例如，如果 System.xml.linq.xelement> 類型的資料成員 "q" 包含 \<abc/> ，JSON 就是 {"q"： " \<abc/> "}。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-183">For example, if a data member "q" of type XElement contains \<abc/>, the JSON is {"q":"\<abc/>"}.</span></span>

- <span data-ttu-id="bfe7a-184">還有一些指定如何包裝 XML 的特殊規則。如需詳細資訊，請參閱本主題稍後的「進階資訊」一節。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-184">There are some special rules that specify how XML is wrapped - for more information, see the Advanced Information section later in this topic.</span></span>

- <span data-ttu-id="bfe7a-185">如果您要使用 ASP.NET AJAX 且不想在 JavaScript 中使用字串，希望改用 XML DOM，請在 上將  屬性設定為 XML，或在  上將  屬性設定為 XML。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-185">If you are using ASP.NET AJAX and do not want to use strings in the JavaScript, but want the XML DOM instead, set the <xref:System.ServiceModel.Web.WebGetAttribute.ResponseFormat%2A> property to XML on <xref:System.ServiceModel.Web.WebGetAttribute> or the <xref:System.ServiceModel.Web.WebInvokeAttribute.ResponseFormat%2A> property to XML on the <xref:System.ServiceModel.Web.WebInvokeAttribute>.</span></span>

### <a name="collections-dictionaries-and-arrays"></a><span data-ttu-id="bfe7a-186">集合、字典與陣列</span><span class="sxs-lookup"><span data-stu-id="bfe7a-186">Collections, Dictionaries and Arrays</span></span>

<span data-ttu-id="bfe7a-187">所有的集合、字典與陣列在 JSON 中都會以陣列來表示。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-187">All collections, dictionaries, and arrays are represented in JSON as arrays.</span></span>

- <span data-ttu-id="bfe7a-188">JSON 表示法會忽略任何使用 <xref:System.Runtime.Serialization.CollectionDataContractAttribute> 的自訂。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-188">Any customization that uses the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> is ignored in the JSON representation.</span></span>

- <span data-ttu-id="bfe7a-189">您不可以直接使用字典來搭配 JSON。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-189">Dictionaries are not a way to work directly with JSON.</span></span> <span data-ttu-id="bfe7a-190">在與 \<string,object> 其他 JSON 技術搭配使用的 WCF 中，可能不會以相同方式支援字典。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-190">Dictionary\<string,object> may not be supported in the same way in WCF as expected from working with other JSON technologies.</span></span> <span data-ttu-id="bfe7a-191">例如，如果字典中 "abc" 是對應至 "xyz" 而 "def" 是對應至 42，則 JSON 表示法不是 {"abc":"xyz","def":42}，而是 [{"Key":"abc","Value":"xyz"},{"Key":"def","Value":42}]。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-191">For example, if "abc" is mapped to "xyz" and "def" is mapped to 42 in a dictionary, the JSON representation is not {"abc":"xyz","def":42} but is [{"Key":"abc","Value":"xyz"},{"Key":"def","Value":42}] instead.</span></span>

- <span data-ttu-id="bfe7a-192">如果您希望直接使用 JSON (動態存取索引鍵和值，而不需預先定義嚴謹的合約)，可以選擇數個選項：</span><span class="sxs-lookup"><span data-stu-id="bfe7a-192">If you would like to work with JSON directly (accessing keys and values dynamically, without pre-defining a rigid contract), you have several options:</span></span>

  - <span data-ttu-id="bfe7a-193">請考慮使用[弱類型 JSON 序列化（AJAX）](../../../../docs/framework/wcf/samples/weakly-typed-json-serialization-sample.md)範例。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-193">Consider using the [Weakly-typed JSON Serialization (AJAX)](../../../../docs/framework/wcf/samples/weakly-typed-json-serialization-sample.md) sample.</span></span>

  - <span data-ttu-id="bfe7a-194">請考慮使用 <xref:System.Runtime.Serialization.ISerializable> 介面和還原序列化建構函式，這兩種機制可讓您分別在序列化和還原序列化時存取 JSON 索引鍵/值組，但不適用於部分信任案例中。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-194">Consider using the <xref:System.Runtime.Serialization.ISerializable> interface and deserialization constructors - these two mechanisms allow you to access JSON key/value pairs on serialization and deserialization respectively, but do not work in partial trust scenarios.</span></span>

  - <span data-ttu-id="bfe7a-195">請考慮使用[JSON 和 XML 之間的對應](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md)，而不是使用序列化程式。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-195">Consider working with the [Mapping Between JSON and XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md) instead of using a serializer.</span></span>

  - <span data-ttu-id="bfe7a-196">序列化內容中的*多*型是指將衍生型別序列化為預期的基底型別的能力。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-196">*Polymorphism* in the context of serialization refers to the ability to serialize a derived type where its base type is expected.</span></span> <span data-ttu-id="bfe7a-197">以多型方式使用集合時，例如，將集合指派至 <xref:System.Object> 時，有幾個 JSON 特定的特殊規則。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-197">There are special JSON-specific rules when using collections polymorphically, when, for example, assigning a collection to an <xref:System.Object>.</span></span> <span data-ttu-id="bfe7a-198">在本主題稍後的「進階資訊」一節中，將會更詳細地討論這個議題。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-198">This issue is more fully discussed in the Advanced Information section later in this topic.</span></span>

## <a name="additional-details"></a><span data-ttu-id="bfe7a-199">其他詳細資料</span><span class="sxs-lookup"><span data-stu-id="bfe7a-199">Additional Details</span></span>

### <a name="order-of-data-members"></a><span data-ttu-id="bfe7a-200">資料成員的順序</span><span class="sxs-lookup"><span data-stu-id="bfe7a-200">Order of Data Members</span></span>

<span data-ttu-id="bfe7a-201">使用 JSON 時，資料成員的順序並不重要。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-201">Order of data members is not important when using JSON.</span></span> <span data-ttu-id="bfe7a-202">特別是，即使設定 <xref:System.Runtime.Serialization.DataMemberAttribute.Order%2A>，仍然可以依照任何順序來還原序列化 JSON 資料。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-202">Specifically, even if <xref:System.Runtime.Serialization.DataMemberAttribute.Order%2A> is set, JSON data can still be deserialized in any order.</span></span>

### <a name="json-types"></a><span data-ttu-id="bfe7a-203">JSON 型別</span><span class="sxs-lookup"><span data-stu-id="bfe7a-203">JSON Types</span></span>

<span data-ttu-id="bfe7a-204">在還原序列化時，JSON 型別不必符合上述表格。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-204">The JSON type does not have to match the preceding table on deserialization.</span></span> <span data-ttu-id="bfe7a-205">例如，`Int` 通常會對應至 JSON 數字，但是它也可以成功地從 JSON 字串還原序列化，只要該字串包含有效數字。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-205">For example, an `Int` normally maps to a JSON number, but it can also be successfully deserialized from a JSON string as long as that string contains a valid number.</span></span> <span data-ttu-id="bfe7a-206">也就是說，只要有一個 `Int` 資料成員稱為 "q"，{"q":42} 和 {"q":"42"} 兩者皆為有效。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-206">That is, both {"q":42} and {"q":"42"} are valid if there is an `Int` data member called "q".</span></span>

### <a name="polymorphism"></a><span data-ttu-id="bfe7a-207">Polymorphism</span><span class="sxs-lookup"><span data-stu-id="bfe7a-207">Polymorphism</span></span>

<span data-ttu-id="bfe7a-208">多型序列化是由可序列化必須是基底型別之衍生型別的能力所組成。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-208">Polymorphic serialization consists of the ability to serialize a derived type where its base type is expected.</span></span> <span data-ttu-id="bfe7a-209">這是由 WCF 支援的 JSON 序列化，相當於支援 XML 序列化的方式。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-209">This is supported for JSON serialization by WCF comparable to the way XML serialization is supported.</span></span> <span data-ttu-id="bfe7a-210">例如，您可以序列化 `MyDerivedType` 預期的位置 `MyBaseType` ，或序列化 `Int` 預期的位置 `Object` 。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-210">For example, you can serialize `MyDerivedType` where `MyBaseType` is expected, or serialize `Int` where `Object` is expected.</span></span>

<span data-ttu-id="bfe7a-211">如果必須是基底型別，則在還原序列化衍生型別時可能會遺失型別資訊，除非您還原序列化複雜型別。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-211">Type information may be lost when deserializing a derived type if the base type is expected, unless you are deserializing a complex type.</span></span> <span data-ttu-id="bfe7a-212">例如，如果序列化必須是 <xref:System.Uri> 的 <xref:System.Object>，則會產生 JSON 字串。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-212">For example, if <xref:System.Uri> is serialized where <xref:System.Object> is expected, it results in a JSON string.</span></span> <span data-ttu-id="bfe7a-213">如果這個字串接著再還原序列化為 <xref:System.Object>，則會傳回 .NET <xref:System.String>。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-213">If this string is then deserialized back into <xref:System.Object>, a .NET <xref:System.String> is returned.</span></span> <span data-ttu-id="bfe7a-214">還原序列化程式並不知道字串初始的型別為 <xref:System.Uri>。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-214">The deserializer does not know that the string was initially of type <xref:System.Uri>.</span></span> <span data-ttu-id="bfe7a-215">一般而言，當必須是 <xref:System.Object> 時，所有的 JSON 字串都會還原序列化為 .NET 字串，並且所有用於序列化 .NET 集合、字典和陣列的 JSON 陣列都會還原序列化為 <xref:System.Array> 型別的 .NET <xref:System.Object>，不論實際的原始型別為何。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-215">Generally, when expecting <xref:System.Object>, all JSON strings are deserialized as .NET strings, and all JSON arrays used to serialize .NET collections, dictionaries, and arrays are deserialized as .NET <xref:System.Array> of type <xref:System.Object>, regardless of what the actual original type had been.</span></span> <span data-ttu-id="bfe7a-216">JSON 布林值會對應至 .NET <xref:System.Boolean>。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-216">A JSON boolean maps to a .NET <xref:System.Boolean>.</span></span> <span data-ttu-id="bfe7a-217">然而，當必須是 <xref:System.Object> 時，JSON 數字會還原序列化為 .NET <xref:System.Int32>、<xref:System.Decimal> 或 <xref:System.Double>，其中會自動選取最適合的型別。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-217">However when expecting an <xref:System.Object>, JSON numbers are deserialized as either .NET <xref:System.Int32>, <xref:System.Decimal> or <xref:System.Double>, where the most appropriate type is automatically picked.</span></span>

<span data-ttu-id="bfe7a-218">在還原序列化為介面型別時，<xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> 會將宣告型別視為物件來還原序列化。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-218">When deserializing into an interface type, the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> deserializes as if the declared type were object.</span></span>

<span data-ttu-id="bfe7a-219">在使用您自己的基底型別和衍生型別時，通常需要使用 <xref:System.Runtime.Serialization.KnownTypeAttribute>、<xref:System.ServiceModel.ServiceKnownTypeAttribute> 或相等的機制。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-219">When working with your own base and derived types, using the <xref:System.Runtime.Serialization.KnownTypeAttribute>, <xref:System.ServiceModel.ServiceKnownTypeAttribute> or an equivalent mechanism is normally required.</span></span> <span data-ttu-id="bfe7a-220">例如，如果您有一個具有傳回值的作業， `Animal` 而且實際傳回的實例 `Cat` （衍生自 `Animal` ），您應該將套用 <xref:System.Runtime.Serialization.KnownTypeAttribute> 至 `Animal` 類型或， <xref:System.ServiceModel.ServiceKnownTypeAttribute> 然後在 `Cat` 這些屬性中指定類型。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-220">For example, if you have an operation that has an `Animal` return value and it actually returns an instance of `Cat` (derived from `Animal`), you should either apply the <xref:System.Runtime.Serialization.KnownTypeAttribute>, to the `Animal` type or the <xref:System.ServiceModel.ServiceKnownTypeAttribute> to the operation and specify the `Cat` type in these attributes.</span></span> <span data-ttu-id="bfe7a-221">如需詳細資訊，請參閱[資料合約已知類型](../../../../docs/framework/wcf/feature-details/data-contract-known-types.md)。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-221">For more information, see [Data Contract Known Types](../../../../docs/framework/wcf/feature-details/data-contract-known-types.md).</span></span>

<span data-ttu-id="bfe7a-222">如需多型序列化運作方式的詳細資訊，以及使用時必須遵守的一些限制說明，請參閱本主題稍後的「進階資訊」一節。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-222">For details of how polymorphic serialization works and a discussion of some of the limitations that must be respected when using it, see the Advanced Information section later in this topic.</span></span>

### <a name="versioning"></a><span data-ttu-id="bfe7a-223">版本控制</span><span class="sxs-lookup"><span data-stu-id="bfe7a-223">Versioning</span></span>

<span data-ttu-id="bfe7a-224">在 JSON 中完全支援資料合約版本控制功能，包括 <xref:System.Runtime.Serialization.IExtensibleDataObject> 介面。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-224">The data contract versioning features, including the <xref:System.Runtime.Serialization.IExtensibleDataObject> interface, are fully supported in JSON.</span></span> <span data-ttu-id="bfe7a-225">此外，在大部分的情況中，可能可以在一種格式中還原序列化型別 (例如 XML)，然後再序列化成另一種格式 (例如 JSON)，而且仍然保有 <xref:System.Runtime.Serialization.IExtensibleDataObject> 中的資料。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-225">Furthermore, in most cases it is possible to deserialize a type in one format (for example, XML) and then serialize it into another format (for example, JSON) and still preserve the data in <xref:System.Runtime.Serialization.IExtensibleDataObject>.</span></span> <span data-ttu-id="bfe7a-226">如需詳細資訊，請參閱[向前相容資料合約](../../../../docs/framework/wcf/feature-details/forward-compatible-data-contracts.md)。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-226">For more information, see [Forward-Compatible Data Contracts](../../../../docs/framework/wcf/feature-details/forward-compatible-data-contracts.md).</span></span> <span data-ttu-id="bfe7a-227">請記住，JSON 並未循序，因此，任何順序資訊都會遺失。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-227">Remember that JSON is unordered so any order information is lost.</span></span> <span data-ttu-id="bfe7a-228">此外，JSON 不支援多個具有相同索引鍵名稱的索引鍵/值組。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-228">Furthermore, JSON does not support multiple key/value pairs with the same key name.</span></span> <span data-ttu-id="bfe7a-229">最後，<xref:System.Runtime.Serialization.IExtensibleDataObject> 上的所有作業原本就是多型的，也就是說，它們的衍生型別會指派給 <xref:System.Object> (所有型別的基底型別)。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-229">Finally, all operations on <xref:System.Runtime.Serialization.IExtensibleDataObject> are inherently polymorphic - that is their derived type are assigned to <xref:System.Object>, the base type for all types.</span></span>

## <a name="json-in-urls"></a><span data-ttu-id="bfe7a-230">URL 中的 JSON</span><span class="sxs-lookup"><span data-stu-id="bfe7a-230">JSON in URLs</span></span>

<span data-ttu-id="bfe7a-231">當以 HTTP GET 動詞命令來使用 ASP.NET AJAX 端點時 (使用 <xref:System.ServiceModel.Web.WebGetAttribute> 屬性)，傳入參數會出現在要求 URL 中而非訊息本文。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-231">When using ASP.NET AJAX endpoints with the HTTP GET verb (using the <xref:System.ServiceModel.Web.WebGetAttribute> attribute), incoming parameters appear in the request URL instead of the message body.</span></span> <span data-ttu-id="bfe7a-232">即使在要求 URL 中也支援 JSON，因此如果您的作業會使用名為 `Int` "number" 的作業和 `Person` 名為 "p" 的複雜型別，則 url 可能會類似下列 url。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-232">JSON is supported even in the request URL, so if you have an operation that takes an `Int` called "number" and a `Person` complex type called "p", the URL may resemble the following URL.</span></span>

```html
http://example.com/myservice.svc/MyOperation?number=7&p={"name":"John","age":42}
```

<span data-ttu-id="bfe7a-233">如果您是使用 ASP.NET AJAX 指令碼管理員控制項與 Proxy 來呼叫服務，這個 URL 就會由 Proxy 自動產生且不會被看到。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-233">If you are using an ASP.NET AJAX Script Manager control and proxy to call the service, this URL is automatically generated by the proxy and is not seen.</span></span> <span data-ttu-id="bfe7a-234">JSON 無法在非 ASP.NET AJAX 端點的 URL 上使用。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-234">JSON cannot be used in URLs on non-ASP.NET AJAX endpoints.</span></span>

## <a name="advanced-information"></a><span data-ttu-id="bfe7a-235">進階資訊</span><span class="sxs-lookup"><span data-stu-id="bfe7a-235">Advanced information</span></span>

### <a name="iserializable-support"></a><span data-ttu-id="bfe7a-236">ISerializable 支援</span><span class="sxs-lookup"><span data-stu-id="bfe7a-236">ISerializable Support</span></span>

#### <a name="supported-and-unsupported-iserializable-types"></a><span data-ttu-id="bfe7a-237">支援和不支援的 ISerializable 型別</span><span class="sxs-lookup"><span data-stu-id="bfe7a-237">Supported and Unsupported ISerializable Types</span></span>

<span data-ttu-id="bfe7a-238">一般而言，當序列化/還原序列化 JSON 時，會完全支援實作 <xref:System.Runtime.Serialization.ISerializable> 介面的型別。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-238">In general, types that implement the <xref:System.Runtime.Serialization.ISerializable> interface are fully supported when serializing/deserializing JSON.</span></span> <span data-ttu-id="bfe7a-239">然而，其中有些型別 (包括一些 .NET Framework 型別) 的實作方式會讓 JSON 特定的序列化造成它們無法正確地還原序列化：</span><span class="sxs-lookup"><span data-stu-id="bfe7a-239">However, some of these types (including some .NET Framework types) are implemented in such a way that the JSON-specific serialization aspects cause them to not deserialize correctly:</span></span>

- <span data-ttu-id="bfe7a-240">使用 <xref:System.Runtime.Serialization.ISerializable>，永遠無法預先知道個別資料成員的型別。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-240">With <xref:System.Runtime.Serialization.ISerializable>, the type of individual data members is never known in advance.</span></span> <span data-ttu-id="bfe7a-241">這導致多型情況與將型別還原序列化成物件很類似。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-241">This leads to a polymorphic situation similar to deserializing types into an object.</span></span> <span data-ttu-id="bfe7a-242">如前所述，這可能會導致遺失 JSON 中的型別資訊。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-242">As mentioned before, this may lead to loss of type information in JSON.</span></span> <span data-ttu-id="bfe7a-243">例如，在其 `enum` 實作中序列化 <xref:System.Runtime.Serialization.ISerializable> 並嘗試直接再還原序列化成 `enum` (沒有正確轉換) 的型別失敗，因為 `enum` 是使用 JSON 中的數字進行序列化，而 JSON 數字還原序列化成內建的 .NET 數字型別 (Int32、Decimal 或 Double)。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-243">For example, a type that serializes an `enum` in its <xref:System.Runtime.Serialization.ISerializable> implementation and attempts to deserialize back directly into an `enum` (without proper casts) fails, because an `enum` is serialized using numbers in JSON and JSON numbers deserialize into built-in .NET numeric types (Int32, Decimal or Double).</span></span> <span data-ttu-id="bfe7a-244">因此用於做為 `enum` 值的數字會遺失。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-244">So the fact that the number used to be an `enum` value is lost.</span></span>

- <span data-ttu-id="bfe7a-245">依賴其還原序列化建構函式中的還原序列化特定順序的 <xref:System.Runtime.Serialization.ISerializable> 型別可能也會無法還原序列化某些 JSON 資料，因為大部分的 JSON 序列化程式都不會保證任何特定順序。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-245">An <xref:System.Runtime.Serialization.ISerializable> type that depends on a particular order of deserialization in its deserialization constructor may also fail to deserialize some JSON data, because most JSON serializers do not guarantee any specific order.</span></span>

#### <a name="factory-types"></a><span data-ttu-id="bfe7a-246">處理站型別</span><span class="sxs-lookup"><span data-stu-id="bfe7a-246">Factory Types</span></span>

<span data-ttu-id="bfe7a-247">雖然一般而言，在 JSON 中會支援 <xref:System.Runtime.Serialization.IObjectReference> 介面，但是不會支援任何需要「處理站型別」功能 (從與實作介面的型別不同的 <xref:System.Runtime.Serialization.IObjectReference.GetRealObject%28System.Runtime.Serialization.StreamingContext%29> 型別傳回執行個體) 的型別。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-247">While the <xref:System.Runtime.Serialization.IObjectReference> interface is supported in JSON in general, any types that require the "factory type" feature (returning an instance of a different type from <xref:System.Runtime.Serialization.IObjectReference.GetRealObject%28System.Runtime.Serialization.StreamingContext%29> than the type that implements the interface) are not supported.</span></span>

### <a name="datetime-wire-format"></a><span data-ttu-id="bfe7a-248">DateTime Wire 格式</span><span class="sxs-lookup"><span data-stu-id="bfe7a-248">DateTime Wire Format</span></span>

<span data-ttu-id="bfe7a-249"><xref:System.DateTime> 值會以 "/Date(700000+0500)/" 的格式顯示為 JSON 字串，其中第一個數字 (範例中為 700000) 是 GMT 時區中毫秒的數字，自 1970 年 1 月 1 日午夜起的固定 (非日光節約時間) 時間。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-249"><xref:System.DateTime> values appear as JSON strings in the form of "/Date(700000+0500)/", where the first number (700000 in the example provided) is the number of milliseconds in the GMT time zone, regular (non-daylight savings) time since midnight, January 1, 1970.</span></span> <span data-ttu-id="bfe7a-250">該數字可能是負數，以代表較早的時間。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-250">The number may be negative to represent earlier times.</span></span> <span data-ttu-id="bfe7a-251">範例中組成 "+0500" 的部分是選擇性的，並指出時間的類型是 <xref:System.DateTimeKind.Local>，也就是說，應在還原序列化時轉換為本地時區。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-251">The part that consists of "+0500" in the example is optional and indicates that the time is of the <xref:System.DateTimeKind.Local> kind - that is, should be converted to the local time zone on deserialization.</span></span> <span data-ttu-id="bfe7a-252">如果沒有，時間便會還原序列化為 <xref:System.DateTimeKind.Utc>。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-252">If it is absent, the time is deserialized as <xref:System.DateTimeKind.Utc>.</span></span> <span data-ttu-id="bfe7a-253">實際數字 (這個範例中為 "0500") 和其符號 (+ 或 -) 會被忽略。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-253">The actual number ("0500" in this example) and its sign (+ or -) are ignored.</span></span>

<span data-ttu-id="bfe7a-254">當序列化 <xref:System.DateTime> 時，<xref:System.DateTimeKind.Local> 和 <xref:System.DateTimeKind.Unspecified> 時間是以位移寫入，而 <xref:System.DateTimeKind.Utc> 則不是。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-254">When serializing <xref:System.DateTime>, <xref:System.DateTimeKind.Local> and <xref:System.DateTimeKind.Unspecified> times are written with an offset, and <xref:System.DateTimeKind.Utc> is written without.</span></span>

<span data-ttu-id="bfe7a-255">ASP.NET AJAX 用戶端 JavaScript 程式碼會將此類字串自動轉換成 JavaScript `DateTime` 執行個體。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-255">The ASP.NET AJAX client JavaScript code automatically converts such strings into JavaScript `DateTime` instances.</span></span> <span data-ttu-id="bfe7a-256">如果在 .NET 中有其他字串有不是 <xref:System.DateTime> 型別的類似格式，它們也會被轉換。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-256">If there are other strings that have a similar form that are not of type <xref:System.DateTime> in .NET, they are converted as well.</span></span>

<span data-ttu-id="bfe7a-257">只有在 "/" 字元已轉義（也就是 JSON 看起來像是 " \\ /Date （700000 + 0500）/"）時才會進行轉換，因此， \\ WCF 的 JSON 編碼器（由啟用 <xref:System.ServiceModel.WebHttpBinding> ）一律會將 "/" 字元轉義。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-257">The conversion only takes place if the "/" characters are escaped (that is, the JSON looks like "\\/Date(700000+0500)\\/"), and for this reason WCF's JSON encoder (enabled by the <xref:System.ServiceModel.WebHttpBinding>) always escapes the "/" character.</span></span>

### <a name="xml-in-json-strings"></a><span data-ttu-id="bfe7a-258">JSON 字串中的 XML</span><span class="sxs-lookup"><span data-stu-id="bfe7a-258">XML in JSON Strings</span></span>

#### <a name="xmlelement"></a><span data-ttu-id="bfe7a-259">XmlElement</span><span class="sxs-lookup"><span data-stu-id="bfe7a-259">XmlElement</span></span>

<span data-ttu-id="bfe7a-260"><xref:System.Xml.XmlElement> 是依現狀序列化，沒有包裝。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-260"><xref:System.Xml.XmlElement> is serialized as is, with no wrapping.</span></span> <span data-ttu-id="bfe7a-261">例如，包含之類型的資料成員 "x" 表示如下所示 <xref:System.Xml.XmlElement> \<abc/> ：</span><span class="sxs-lookup"><span data-stu-id="bfe7a-261">For example, data member "x" of type <xref:System.Xml.XmlElement> that contains \<abc/> is represented as follows:</span></span>

```json
{"x":"<abc/>"}
```

#### <a name="arrays-of-xmlnode"></a><span data-ttu-id="bfe7a-262">XmlNode 的陣列</span><span class="sxs-lookup"><span data-stu-id="bfe7a-262">Arrays of XmlNode</span></span>

<span data-ttu-id="bfe7a-263">型別 <xref:System.Array> 的 <xref:System.Xml.XmlNode> 物件是包裝在型別的標準資料合約命名空間中稱為 ArrayOfXmlNode 的項目中。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-263"><xref:System.Array> objects of type <xref:System.Xml.XmlNode> are wrapped in an element called ArrayOfXmlNode in the standard data contract namespace for the type.</span></span> <span data-ttu-id="bfe7a-264">如果 "x" 是陣列，在包含 "value" 和空白項目節點 "M" 的命名空間 "ns" 中包含屬性節點 "N"，表示如下所示。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-264">If "x" is an array that contains attribute node "N" in namespace "ns" that contains "value" and an empty element node "M", the representation is as follows.</span></span>

```json
{"x":"<ArrayOfXmlNode xmlns=\"http://schemas.datacontract.org/2004/07/System.Xml\" a:N=\"value\" xmlns:a=\"ns\"><M/></ArrayOfXmlNode>"}
```

 <span data-ttu-id="bfe7a-265">在 XmlNode 陣列開頭的空白命名空間中的屬性 (在其他項目之前) 會不受支援。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-265">Attributes in the empty namespace at the beginning of XmlNode arrays (before other elements) are unsupported.</span></span>

#### <a name="ixmlserializable-types-including-xelement-and-dataset"></a><span data-ttu-id="bfe7a-266">IXmlSerializable 型別包括 XElement 和 DataSet</span><span class="sxs-lookup"><span data-stu-id="bfe7a-266">IXmlSerializable Types including XElement and DataSet</span></span>

<span data-ttu-id="bfe7a-267"><xref:System.Runtime.Serialization.ISerializable> 型別分為「內容型別」、「DataSet 型別」和「項目型別」。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-267"><xref:System.Runtime.Serialization.ISerializable> types subdivide into "content types", "DataSet types" and "element types".</span></span> <span data-ttu-id="bfe7a-268">如需這些類型的定義，請參閱[資料合約中的 XML 和 ADO.NET 類型](../../../../docs/framework/wcf/feature-details/xml-and-ado-net-types-in-data-contracts.md)。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-268">For definitions of these types, see [XML and ADO.NET Types in Data Contracts](../../../../docs/framework/wcf/feature-details/xml-and-ado-net-types-in-data-contracts.md).</span></span>

<span data-ttu-id="bfe7a-269">「內容」和「DataSet」型別的序列化類似前一節中所討論的 <xref:System.Array> 的 <xref:System.Xml.XmlNode> 物件。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-269">"Content" and "DataSet" types are serialized similar to <xref:System.Array> objects of <xref:System.Xml.XmlNode> discussed in the previous section.</span></span> <span data-ttu-id="bfe7a-270">它們會包裝在一個項目中，該項目的名稱和命名空間對應至所討論的型別的資料合約名稱和命名空間。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-270">They are wrapped in an element whose name and namespace corresponds to the data contract name and namespace of the type in question.</span></span>

<span data-ttu-id="bfe7a-271">如 <xref:System.Xml.Linq.XElement> 等「項目」型別會依現狀進行序列化，類似本主題之前所討論的 <xref:System.Xml.XmlElement>。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-271">"Element" types such as <xref:System.Xml.Linq.XElement> are serialized as is, similar to <xref:System.Xml.XmlElement> previously discussed in this topic.</span></span>

### <a name="polymorphism"></a><span data-ttu-id="bfe7a-272">Polymorphism</span><span class="sxs-lookup"><span data-stu-id="bfe7a-272">Polymorphism</span></span>

#### <a name="preserving-type-information"></a><span data-ttu-id="bfe7a-273">保留型別資訊</span><span class="sxs-lookup"><span data-stu-id="bfe7a-273">Preserving Type Information</span></span>

<span data-ttu-id="bfe7a-274">如前所述，在 JSON 中支援多型有一些限制。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-274">As stated earlier, polymorphism is supported in JSON with some limitations.</span></span> <span data-ttu-id="bfe7a-275">JavaScript 是弱型別語言，而型別身分識別通常不是問題。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-275">JavaScript is a weakly-typed language and type identity is normally not an issue.</span></span> <span data-ttu-id="bfe7a-276">然而，當使用 JSON 在強型別系統 (.NET) 和弱型別系統 (JavaScript) 之間進行通訊時，保留型別身分識別是很有用的。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-276">However, when using JSON to communicate between a strongly-typed system (.NET) and a weakly-typed system (JavaScript), it is useful to preserve type identity.</span></span> <span data-ttu-id="bfe7a-277">例如，資料合約名稱為 "Square" 和 "Circle" 的型別衍生自資料合約名稱為 "Shape" 的型別。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-277">For example, types with data contract names "Square" and "Circle" derive from a type with a data contract name of "Shape".</span></span> <span data-ttu-id="bfe7a-278">如果 "Circle" 是從 .NET 傳送至 JavaScript，稍後再傳回至應該有 "Shape" 的 .NET 方法，讓 .NET 端知道所討論的物件原本是 "Circle" 會很有用，否則衍生型別的特定資訊 (例如，"Circle" 上的 "radius" 資料成員) 可能會遺失。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-278">If "Circle" is sent from .NET to JavaScript and is later returned to a .NET method that expects "Shape", it is useful for the .NET side to know that the object in question was originally a "Circle" - otherwise any information specific to the derived type (for example, "radius" data member on "Circle") may be lost.</span></span>

<span data-ttu-id="bfe7a-279">若要保留型別身分識別，在將複雜型別序列化至 JSON 時可以新增「型別提示」，還原序列化程式便可辨識提示並執行適當的動作。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-279">To preserve type identity, when serializing complex types to JSON a "type hint" can be added, and the deserializer recognizes the hint and acts appropriately.</span></span> <span data-ttu-id="bfe7a-280">「類型提示」是 JSON 索引鍵/值組，索引鍵名稱為 " \_ \_ type" （兩個底線後面接著 "type" 一字）。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-280">The "type hint" is a JSON key/value pair with the key name of "\_\_type" (two underscores followed by the word "type").</span></span> <span data-ttu-id="bfe7a-281">值是格式 "DataContractName:DataContractNamespace" (第一個冒號之前是名稱) 的 JSON 字串。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-281">The value is a JSON string of the form "DataContractName:DataContractNamespace" (anything up to the first colon is the name).</span></span> <span data-ttu-id="bfe7a-282">使用之前的範例，"Circle" 可以進行序列化，如下所示。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-282">Using the earlier example, "Circle" can be serialized as follows.</span></span>

```json
{"__type":"Circle:http://example.com/myNamespace","x":50,"y":70,"radius":10}
```

<span data-ttu-id="bfe7a-283">型別提示與 XML 結構描述執行個體標準所定義的 `xsi:type` 屬性十分類似，並且是在序列化/還原序列化 XML 時使用。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-283">The type hint is very similar to the `xsi:type` attribute defined by the XML Schema Instance standard and used when serializing/deserializing XML.</span></span>

<span data-ttu-id="bfe7a-284">\_ \_ 因為可能與類型提示發生衝突，所以禁止使用稱為「類型」的資料成員。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-284">Data members called "\_\_type" are forbidden due to potential conflict with the type hint.</span></span>

#### <a name="reducing-the-size-of-type-hints"></a><span data-ttu-id="bfe7a-285">縮小型別提示的大小</span><span class="sxs-lookup"><span data-stu-id="bfe7a-285">Reducing the Size of Type Hints</span></span>

<span data-ttu-id="bfe7a-286">為了減少 JSON 訊息的大小， `http://schemas.datacontract.org/2004/07/` 會以 "#" 字元取代預設的資料合約命名空間前置詞（）。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-286">To reduce the size of JSON messages, the default data contract namespace prefix (`http://schemas.datacontract.org/2004/07/`) is replaced with the "#" character.</span></span> <span data-ttu-id="bfe7a-287">（若要讓此取代可回復，會使用轉義規則：如果命名空間是以 "#" 或 " \\ " 字元開頭，則會附加額外的 " \\ " 字元）。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-287">(To make this replacement reversible, an escaping rule is used: if the namespace starts with the "#" or "\\" characters, they are appended with an extra "\\" character).</span></span> <span data-ttu-id="bfe7a-288">因此，如果 "Circle" 是 .NET 命名空間 "MyApp" 中的類型，其預設資料合約命名空間為 `http://schemas.datacontract.org/2004/07/MyApp` 。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-288">Thus, if "Circle" is a type in the .NET namespace "MyApp.Shapes", its default data contract namespace is `http://schemas.datacontract.org/2004/07/MyApp`.</span></span> <span data-ttu-id="bfe7a-289">Shapes 和 JSON 表示如下所示。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-289">Shapes and the JSON representation is as follows.</span></span>

```json
{"__type":"Circle:#MyApp.Shapes","x":50,"y":70,"radius":10}
```

<span data-ttu-id="bfe7a-290">還原序列化時，會瞭解截斷的（#MyApp 圖形）和完整的（ <http://schemas.datacontract.org/2004/07/MyApp.Shapes> ）名稱。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-290">Both the truncated (#MyApp.Shapes) and the full (<http://schemas.datacontract.org/2004/07/MyApp.Shapes>) names is understood on deserialization.</span></span>

#### <a name="type-hint-position-in-json-objects"></a><span data-ttu-id="bfe7a-291">JSON 物件中的型別提示位置</span><span class="sxs-lookup"><span data-stu-id="bfe7a-291">Type Hint Position in JSON Objects</span></span>

<span data-ttu-id="bfe7a-292">請注意，型別提示必須最先出現在 JSON 表示中。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-292">Note that the type hint must appear first in the JSON representation.</span></span> <span data-ttu-id="bfe7a-293">只有在這種情況中，索引鍵/值組的順序在 JSON 處理中才會十分重要。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-293">This is the only case where order of key/value pairs is important in JSON processing.</span></span> <span data-ttu-id="bfe7a-294">例如，下列不是指定型別提示的有效方法。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-294">For example, the following is not a valid way to specify the type hint.</span></span>

```json
{"x":50,"y":70,"radius":10,"__type":"Circle:#MyApp.Shapes"}
```

<span data-ttu-id="bfe7a-295"><xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>WCF 和 ASP.NET AJAX 用戶端頁面所使用的都一律會先發出型別提示。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-295">Both the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> used by WCF and ASP.NET AJAX client pages always emit the type hint first.</span></span>

#### <a name="type-hints-apply-only-to-complex-types"></a><span data-ttu-id="bfe7a-296">型別提示只套用至複雜型別</span><span class="sxs-lookup"><span data-stu-id="bfe7a-296">Type Hints Apply Only to Complex Types</span></span>

<span data-ttu-id="bfe7a-297">非複雜型別是無法發出型別提示的。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-297">There is no way to emit a type hint for non-complex types.</span></span> <span data-ttu-id="bfe7a-298">例如，如果作業有 <xref:System.Object> 傳回型別但傳回 Circle，JSON 表示可以如稍早所示，並保留型別資訊。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-298">For example, if an operation has an <xref:System.Object> return type but returns a Circle, the JSON representation can be as shown earlier and the type information is preserved.</span></span> <span data-ttu-id="bfe7a-299">然而，如果傳回 URI，JSON 表示就是字串，而用於代表 URI 的字串會遺失。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-299">However, if Uri is returned, the JSON representation is a string and the fact that the string used to represent a Uri is lost.</span></span> <span data-ttu-id="bfe7a-300">這不僅適用於基本型別，也適用於集合和陣列。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-300">This applies not only to primitive types but also to collections and arrays.</span></span>

#### <a name="when-are-type-hints-emitted"></a><span data-ttu-id="bfe7a-301">何時會發出型別提示</span><span class="sxs-lookup"><span data-stu-id="bfe7a-301">When Are Type Hints Emitted</span></span>

<span data-ttu-id="bfe7a-302">型別提示可能會大幅增加訊息大小 (改善這種情況的方法之一是盡量使用較短的資料合約命名空間)。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-302">Type hints may increase message size significantly (one way to mitigate this is to use shorter data contract namespaces if possible).</span></span> <span data-ttu-id="bfe7a-303">因此，下列規則會管理是否發出型別提示：</span><span class="sxs-lookup"><span data-stu-id="bfe7a-303">Therefore, the following rules govern whether type hints are emitted:</span></span>

- <span data-ttu-id="bfe7a-304">當使用 ASP.NET AJAX 時，即使沒有基底/衍生指派 (例如，即使 Circle 指派至 Circle)，只要可以，還是永遠會發出型別提示</span><span class="sxs-lookup"><span data-stu-id="bfe7a-304">When using ASP.NET AJAX, type hints are always emitted whenever possible, even if there is no base/derived assignment - for example, even if a Circle is assigned to a Circle.</span></span> <span data-ttu-id="bfe7a-305">(如果要完整啟用從弱型別 JSON 環境至強型別 .NET 環境的呼叫處理，而不會意外遺失資訊，這是必要的)。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-305">(This is required to fully enable the process of calling from the weakly-typed JSON environment into the strongly-typed .NET environment with no surprising loss of information.)</span></span>

- <span data-ttu-id="bfe7a-306">如果使用沒有 ASP.NET 整合的 AJAX 服務，只有在有基底/衍生指派時，才會發出型別提示 - 也就是說，在 Circle 指派至 Shape 或 <xref:System.Object> 但不是在指派至 Circle 時發出。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-306">When using AJAX services with no ASP.NET integration, type hints are only emitted when there is a base/derived assignment - that is, emitted when Circle is assigned to Shape or <xref:System.Object> but not when assigned to Circle.</span></span> <span data-ttu-id="bfe7a-307">這會提供正確實作 JavaScript 用戶端所需的最少必要資訊，因而增進效能，但無法防止設計錯誤的用戶端中的型別資訊遺失。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-307">This provides the minimum information required to correctly implement a JavaScript client, thus improving performance, but does not protect against type information loss in incorrectly-designed clients.</span></span> <span data-ttu-id="bfe7a-308">如果您要避免在用戶端上處理這個問題，請避免在伺服器上使用基底/衍生指派。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-308">Avoid base/derived assignments altogether on the server if you want to avoid dealing with this issue on the client.</span></span>

- <span data-ttu-id="bfe7a-309">當使用 <xref:System.Runtime.Serialization.DataContractSerializer> 型別時，`alwaysEmitTypeInformation` 建構函式參數可讓您在前述兩種模式中做選擇，且預設為 "`false`" (只在有需要時發出型別提示)。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-309">When using the <xref:System.Runtime.Serialization.DataContractSerializer> type, the `alwaysEmitTypeInformation` constructor parameter allows you to choose between the preceding two modes, with the default being "`false`" (only emit type hints when required).</span></span>

#### <a name="duplicate-data-member-names"></a><span data-ttu-id="bfe7a-310">重複資料成員名稱</span><span class="sxs-lookup"><span data-stu-id="bfe7a-310">Duplicate Data Member Names</span></span>

<span data-ttu-id="bfe7a-311">衍生型別資訊會和基底型別資訊一起存在相同的 JSON 物件中，且可能會以各種順序出現。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-311">Derived type information is present in the same JSON object together with base type information, and can occur in any order.</span></span> <span data-ttu-id="bfe7a-312">例如， `Shape` 可能會以下列方式表示。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-312">For example, `Shape` may be represented as follows.</span></span>

```json
{"__type":"Shape:#MyApp.Shapes","x":50,"y":70}
```

<span data-ttu-id="bfe7a-313">其中 Circle 可能會表示如下。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-313">Whereas Circle may be represented as follows.</span></span>

```json
{"__type":"Circle:#MyApp.Shapes","x":50, "radius":10,"y":70}
```

<span data-ttu-id="bfe7a-314">如果基底 `Shape` 類型也包含名為 "" 的資料成員 `radius` ，這會導致兩個序列化的衝突（因為 JSON 物件不能有重複的索引鍵名稱）和還原序列化（因為不清楚 "radius" 是否參考 `Shape.radius` 或 `Circle.radius` ）。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-314">If the base `Shape` type also contained a data member called "`radius`", this leads to a collision on both serialization (because JSON objects cannot have repeating key names) and deserialization (because it is unclear whether "radius" refers to `Shape.radius` or `Circle.radius`).</span></span> <span data-ttu-id="bfe7a-315">因此，通常並不建議在資料合約類別中使用「屬性隱藏」的概念 (基底和衍生類別上相同名稱的資料成員)，而實際上在 JSON 的案例中是禁止的。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-315">Therefore, while the concept of "property hiding" (data members of the same name on based and derived classes) is generally not recommended in data contract classes, it is actually forbidden in the case of JSON.</span></span>

#### <a name="polymorphism-and-ixmlserializable-types"></a><span data-ttu-id="bfe7a-316">多型和 IXmlSerializable 型別</span><span class="sxs-lookup"><span data-stu-id="bfe7a-316">Polymorphism and IXmlSerializable Types</span></span>

<span data-ttu-id="bfe7a-317">根據一般的資料合約規則，只要符合「已知型別」需求。<xref:System.Xml.Serialization.IXmlSerializable> 型別就可能會如往常般以多型方式指派給彼此。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-317"><xref:System.Xml.Serialization.IXmlSerializable> types may be polymorphically assigned to each other as usual as long as Known Types requirements are met, according to usual data contract rules.</span></span> <span data-ttu-id="bfe7a-318">然而，序列化 <xref:System.Xml.Serialization.IXmlSerializable> 型別以取代 <xref:System.Object> 會造成型別資訊遺失，因為結果是 JSON 字串。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-318">However, serializing an <xref:System.Xml.Serialization.IXmlSerializable> type in place of <xref:System.Object> results in loss of type information as the result is a JSON string.</span></span>

#### <a name="polymorphism-and-certain-interface-types"></a><span data-ttu-id="bfe7a-319">多型和特定介面型別</span><span class="sxs-lookup"><span data-stu-id="bfe7a-319">Polymorphism and Certain Interface Types</span></span>

<span data-ttu-id="bfe7a-320">禁止序列化集合型別或實作 <xref:System.Xml.Serialization.IXmlSerializable> 的型別，其中應該有不是 <xref:System.Xml.Serialization.IXmlSerializable> (除了 <xref:System.Object>) 的非集合型別。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-320">It is forbidden to serialize a collection type or a type that implements <xref:System.Xml.Serialization.IXmlSerializable> where a non-collection type that is not <xref:System.Xml.Serialization.IXmlSerializable> (except for <xref:System.Object>) is expected.</span></span> <span data-ttu-id="bfe7a-321">例如，名為的自訂介面 `IMyInterface` 和 `MyType` 同時執行型別和的型別 <xref:System.Collections.Generic.IEnumerable%601> `int` `IMyInterface` 。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-321">For example, a custom interface called `IMyInterface` and a type `MyType` that implement both <xref:System.Collections.Generic.IEnumerable%601> of type `int` and `IMyInterface`.</span></span> <span data-ttu-id="bfe7a-322">禁止從傳回型別為的作業傳回 `MyType` `IMyInterface` 。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-322">It is forbidden to return `MyType` from an operation whose return type is `IMyInterface`.</span></span> <span data-ttu-id="bfe7a-323">這是因為 `MyType` 必須序列化為 JSON 陣列，而且需要型別提示，而且在您不能包含具有陣列的型別提示之前，請務必使用複雜型別。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-323">This is because `MyType` must be serialized as a JSON array and requires a type hint, and as stated before you cannot include a type hint with arrays, only with complex types.</span></span>

#### <a name="known-types-and-configuration"></a><span data-ttu-id="bfe7a-324">已知型別和組態</span><span class="sxs-lookup"><span data-stu-id="bfe7a-324">Known Types and Configuration</span></span>

<span data-ttu-id="bfe7a-325"><xref:System.Runtime.Serialization.DataContractSerializer> 也以相同的方法支援 <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> 所使用的所有已知型別機制。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-325">All of the Known Type mechanisms used by the <xref:System.Runtime.Serialization.DataContractSerializer> are also supported in the same way by the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>.</span></span> <span data-ttu-id="bfe7a-326">這兩個序列化程式都會讀取中的相同設定元素， [\<dataContractSerializer>](../../../../docs/framework/configure-apps/file-schema/wcf/datacontractserializer-of-system-runtime-serialization.md) [\<system.runtime.serialization>](../../../../docs/framework/configure-apps/file-schema/wcf/system-runtime-serialization.md) 以探索透過設定檔新增的已知型別。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-326">Both serializers read the same configuration element, [\<dataContractSerializer>](../../../../docs/framework/configure-apps/file-schema/wcf/datacontractserializer-of-system-runtime-serialization.md) in [\<system.runtime.serialization>](../../../../docs/framework/configure-apps/file-schema/wcf/system-runtime-serialization.md), to discover known types added through a configuration file.</span></span>

#### <a name="collections-assigned-to-object"></a><span data-ttu-id="bfe7a-327">指派給物件的集合</span><span class="sxs-lookup"><span data-stu-id="bfe7a-327">Collections Assigned to Object</span></span>

<span data-ttu-id="bfe7a-328">指派給物件的集合的序列化方式就如同實作 的集合一般：如果是複雜型別，則為每一個項目都有型別提示的 JSON 陣列。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-328">Collections assigned to Object are serialized as if they are collections that implement <xref:System.Collections.Generic.IEnumerable%601>: a JSON array with each entry that has a type hint if it is a complex type.</span></span> <span data-ttu-id="bfe7a-329">例如，指派給 <xref:System.Collections.Generic.List%601> 的型別，如下 `Shape` <xref:System.Object> 所示。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-329">For example, a <xref:System.Collections.Generic.List%601> of type `Shape` assigned to <xref:System.Object> looks like the following.</span></span>

```json
[{"__type":"Shape:#MyApp.Shapes","x":50,"y":70},
{"__type":"Shape:#MyApp.Shapes","x":58,"y":73},
{"__type":"Shape:#MyApp.Shapes","x":41,"y":32}]
```

<span data-ttu-id="bfe7a-330">當再還原序列化成 <xref:System.Object> 時：</span><span class="sxs-lookup"><span data-stu-id="bfe7a-330">When deserialized back into <xref:System.Object>:</span></span>

- <span data-ttu-id="bfe7a-331">`Shape`必須在已知類型清單中。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-331">`Shape` must be in the Known Types list.</span></span> <span data-ttu-id="bfe7a-332"><xref:System.Collections.Generic.List%601>已知型別 `Shape` 中的類型沒有任何作用。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-332">Having <xref:System.Collections.Generic.List%601> of type `Shape` in known types has no effect.</span></span> <span data-ttu-id="bfe7a-333">請注意，在此情況下，您不需要在 `Shape` 序列化上加入已知類型-這會自動完成。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-333">Note that you do not have to add `Shape` to known types on serialization in this case - this is done automatically.</span></span>

- <span data-ttu-id="bfe7a-334">集合會還原序列化為 <xref:System.Array> <xref:System.Object> 包含實例之型別的 `Shape` 。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-334">The collection is deserialized as an <xref:System.Array> of type <xref:System.Object> that contains `Shape` instances.</span></span>

#### <a name="derived-collections-assigned-to-base-collections"></a><span data-ttu-id="bfe7a-335">指派給基底集合的衍生集合</span><span class="sxs-lookup"><span data-stu-id="bfe7a-335">Derived Collections Assigned to Base Collections</span></span>

<span data-ttu-id="bfe7a-336">當將衍生集合指派給基底集合時，集合的序列化方式通常就如同基底型別的集合一般。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-336">When a derived collection is assigned to a base collection, the collection is usually serialized as if it was a collection of the base type.</span></span> <span data-ttu-id="bfe7a-337">然而，如果無法將衍生集合的項目型別指派給基底集合的項目型別，便會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-337">However, if the item type of the derived collection cannot be assigned to the item type of the base collection, an exception is thrown.</span></span>

#### <a name="type-hints-and-dictionaries"></a><span data-ttu-id="bfe7a-338">型別提示和字典</span><span class="sxs-lookup"><span data-stu-id="bfe7a-338">Type Hints and Dictionaries</span></span>

<span data-ttu-id="bfe7a-339">當字典指派給 <xref:System.Object> 時，字典中每個索引鍵和值項目的處理方式都如同指派給 <xref:System.Object> 一般，並會取得型別提示。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-339">When a dictionary is assigned to an <xref:System.Object>, each Key and Value entry in the dictionary is treated as if it was assigned to <xref:System.Object> and gets a type hint.</span></span>

<span data-ttu-id="bfe7a-340">當序列化字典型別時，包含 "Key" 和 "Value" 成員的 JSON 物件不受 `alwaysEmitTypeInformation` 設定的影響，且只有在前述集合規則需要時才包含型別提示。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-340">When serializing dictionary types, the JSON object that contains the "Key" and "Value" members is unaffected by the `alwaysEmitTypeInformation` setting and only contains a type hint when the preceding collection rules require it.</span></span>

### <a name="valid-json-key-names"></a><span data-ttu-id="bfe7a-341">有效的 JSON 索引鍵名稱</span><span class="sxs-lookup"><span data-stu-id="bfe7a-341">Valid JSON Key Names</span></span>

<span data-ttu-id="bfe7a-342">序列化程式 XML 會編碼不是有效的 XML 名稱的索引鍵名稱。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-342">The serializer XML-encodes key names that are not valid XML names.</span></span> <span data-ttu-id="bfe7a-343">例如，名稱為 "123" 的資料成員會有編碼的名稱，例如 " \_ x0031 \_ \_ x0032 \_ \_ x0033 \_ "，因為 "123" 是不正確 XML 元素名稱（以數位開頭）。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-343">For example, a data member with the name of "123" would have an encoded name such as "\_x0031\_\_x0032\_\_x0033\_" because "123" is an invalid XML element name (starts with a digit).</span></span> <span data-ttu-id="bfe7a-344">有些在 XML 名稱中無效的國際字元集可能會引起類似的情況。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-344">A similar situation may arise with some international character sets not valid in XML names.</span></span> <span data-ttu-id="bfe7a-345">如需 JSON 處理之 XML 效果的說明，請參閱[json 與 XML 之間的對應](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md)。</span><span class="sxs-lookup"><span data-stu-id="bfe7a-345">For an explanation of this effect of XML on JSON processing, see [Mapping Between JSON and XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="bfe7a-346">另請參閱</span><span class="sxs-lookup"><span data-stu-id="bfe7a-346">See also</span></span>

- [<span data-ttu-id="bfe7a-347">JSON 和其他資料傳輸格式的支援</span><span class="sxs-lookup"><span data-stu-id="bfe7a-347">Support for JSON and Other Data Transfer Formats</span></span>](../../../../docs/framework/wcf/feature-details/support-for-json-and-other-data-transfer-formats.md)
