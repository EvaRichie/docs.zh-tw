---
title: 服務端點與佇列定址
ms.date: 03/30/2017
ms.assetid: 7d2d59d7-f08b-44ed-bd31-913908b83d97
ms.openlocfilehash: 8b323993a698dac219e0f2be43e9b508a19065dd
ms.sourcegitcommit: 71b8f5a2108a0f1a4ef1d8d75c5b3e129ec5ca1e
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 05/29/2020
ms.locfileid: "84202417"
---
# <a name="service-endpoints-and-queue-addressing"></a><span data-ttu-id="8d1bd-102">服務端點與佇列定址</span><span class="sxs-lookup"><span data-stu-id="8d1bd-102">Service Endpoints and Queue Addressing</span></span>
<span data-ttu-id="8d1bd-103">本主題將討論用戶端如何針對從佇列讀取的服務進行定址，以及服務端點如何對應至佇列。</span><span class="sxs-lookup"><span data-stu-id="8d1bd-103">This topic discusses how clients address services that read from queues and how service endpoints map to queues.</span></span> <span data-ttu-id="8d1bd-104">提醒您，下圖顯示傳統 Windows Communication Foundation （WCF）佇列的應用程式部署。</span><span class="sxs-lookup"><span data-stu-id="8d1bd-104">As a reminder, the following illustration shows the classic Windows Communication Foundation (WCF) queued application deployment.</span></span>  
  
 <span data-ttu-id="8d1bd-105">![佇列應用程式圖表](../../../../docs/framework/wcf/feature-details/media/distributed-queue-figure.jpg "分散式-佇列-圖表")</span><span class="sxs-lookup"><span data-stu-id="8d1bd-105">![Queued Application Diagram](../../../../docs/framework/wcf/feature-details/media/distributed-queue-figure.jpg "Distributed-Queue-Figure")</span></span>  
  
 <span data-ttu-id="8d1bd-106">當用戶端需要將訊息傳送到服務時，它會針對傳送到目標佇列的訊息加以定址。</span><span class="sxs-lookup"><span data-stu-id="8d1bd-106">For the client to send the message to the service, the client addresses the message to the Target Queue.</span></span> <span data-ttu-id="8d1bd-107">為了讓服務讀取來自佇列的訊息，服務會將其接聽位址設為目標佇列。</span><span class="sxs-lookup"><span data-stu-id="8d1bd-107">For the service to read messages from the queue, it sets its listen address to the Target Queue.</span></span> <span data-ttu-id="8d1bd-108">WCF 中的定址是統一資源識別元（URI），而訊息佇列（MSMQ）佇列名稱不是以 URI 為基礎。</span><span class="sxs-lookup"><span data-stu-id="8d1bd-108">Addressing in WCF is Uniform Resource Identifier (URI)-based while Message Queuing (MSMQ) queue names are not URI-based.</span></span> <span data-ttu-id="8d1bd-109">因此，您必須瞭解如何使用 WCF 來定址在 MSMQ 中建立的佇列。</span><span class="sxs-lookup"><span data-stu-id="8d1bd-109">It is therefore essential to understand how to address queues created in MSMQ using WCF.</span></span>  
  
## <a name="msmq-addressing"></a><span data-ttu-id="8d1bd-110">MSMQ 定址</span><span class="sxs-lookup"><span data-stu-id="8d1bd-110">MSMQ Addressing</span></span>  
 <span data-ttu-id="8d1bd-111">MSMQ 使用路徑與格式名稱來識別佇列。</span><span class="sxs-lookup"><span data-stu-id="8d1bd-111">MSMQ uses paths and format names to identify a queue.</span></span> <span data-ttu-id="8d1bd-112">路徑會指定主機名稱與 `QueueName`。</span><span class="sxs-lookup"><span data-stu-id="8d1bd-112">Paths specify a host name and a `QueueName`.</span></span> <span data-ttu-id="8d1bd-113">或者，您可以在主機名稱與 `Private$` 之間包含 `QueueName`，來表示尚未於 Active Directory 目錄服務中發行的私用佇列。</span><span class="sxs-lookup"><span data-stu-id="8d1bd-113">Optionally, there can be a `Private$` between the host name and the `QueueName` to indicate a private queue that is not published in the Active Directory directory service.</span></span>  
  
 <span data-ttu-id="8d1bd-114">路徑名稱會對應至 "FormatNames"，以判斷位址的其他層面，包括路由和佇列管理員傳輸通訊協定。</span><span class="sxs-lookup"><span data-stu-id="8d1bd-114">Path names are mapped to "FormatNames" to determine additional aspects of the address, including routing and queue manager transfer protocol.</span></span> <span data-ttu-id="8d1bd-115">佇列管理員支援兩種傳輸通訊協定：原生 MSMQ 通訊協定與 SOAP Reliable Messaging Protocol (SRMP)。</span><span class="sxs-lookup"><span data-stu-id="8d1bd-115">The Queue Manager supports two transfer protocols: native MSMQ protocol and SOAP Reliable Messaging Protocol (SRMP).</span></span>  
  
 <span data-ttu-id="8d1bd-116">如需 MSMQ 路徑和格式名稱的詳細資訊，請參閱[關於訊息佇列](https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms706032(v=vs.85))。</span><span class="sxs-lookup"><span data-stu-id="8d1bd-116">For more information about MSMQ path and format names, see [About Message Queuing](https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms706032(v=vs.85)).</span></span>  
  
## <a name="netmsmqbinding-and-service-addressing"></a><span data-ttu-id="8d1bd-117">NetMsmqBinding 與服務定址</span><span class="sxs-lookup"><span data-stu-id="8d1bd-117">NetMsmqBinding and Service Addressing</span></span>  
 <span data-ttu-id="8d1bd-118">針對傳送給服務的訊息進行定址時，URI 裡的配置是依據通訊時使用的傳輸所選定的。</span><span class="sxs-lookup"><span data-stu-id="8d1bd-118">When addressing a message to a service, the scheme in the URI is chosen based on the transport used for communication.</span></span> <span data-ttu-id="8d1bd-119">WCF 中的每個傳輸都有一個獨特的配置。</span><span class="sxs-lookup"><span data-stu-id="8d1bd-119">Each transport in WCF has a unique scheme.</span></span> <span data-ttu-id="8d1bd-120">配置必須反映通訊時使用的傳輸本質。</span><span class="sxs-lookup"><span data-stu-id="8d1bd-120">The scheme must reflect the nature of transport used for communication.</span></span> <span data-ttu-id="8d1bd-121">例如，net.tcp、net.pipe、HTTP 等等。</span><span class="sxs-lookup"><span data-stu-id="8d1bd-121">For example, net.tcp, net.pipe, HTTP, and so on.</span></span>  
  
 <span data-ttu-id="8d1bd-122">WCF 中的 MSMQ 佇列傳輸會公開一個 net.tcp 配置。</span><span class="sxs-lookup"><span data-stu-id="8d1bd-122">The MSMQ queued transport in WCF exposes a net.msmq scheme.</span></span> <span data-ttu-id="8d1bd-123">任何使用 net.msmq 配置來定址的訊息，將透過使用 MSMQ 佇列傳輸通道的 `NetMsmqBinding` 來傳送。</span><span class="sxs-lookup"><span data-stu-id="8d1bd-123">Any message addressed using the net.msmq scheme is sent using the `NetMsmqBinding` over the MSMQ queued transport channel.</span></span>  
  
 <span data-ttu-id="8d1bd-124">WCF 中的佇列定址是以下列模式為基礎：</span><span class="sxs-lookup"><span data-stu-id="8d1bd-124">The addressing of a queue in WCF is based on the following pattern:</span></span>  
  
 <span data-ttu-id="8d1bd-125">net.tcp：// \<*host-name*> /[私用/]\<*queue-name*></span><span class="sxs-lookup"><span data-stu-id="8d1bd-125">net.msmq: // \<*host-name*> / [private/] \<*queue-name*></span></span>  
  
 <span data-ttu-id="8d1bd-126">其中：</span><span class="sxs-lookup"><span data-stu-id="8d1bd-126">where:</span></span>  
  
- <span data-ttu-id="8d1bd-127">\<*host-name*>這是裝載目標佇列的電腦名稱稱。</span><span class="sxs-lookup"><span data-stu-id="8d1bd-127">\<*host-name*> is the name of the machine that hosts the Target Queue.</span></span>  
  
- <span data-ttu-id="8d1bd-128">[private] 為選擇性項目。</span><span class="sxs-lookup"><span data-stu-id="8d1bd-128">[private] is optional.</span></span> <span data-ttu-id="8d1bd-129">在您針對屬於私用佇列的目標佇列進行定址時，才會用到它。</span><span class="sxs-lookup"><span data-stu-id="8d1bd-129">It is used when addressing a Target Queue that is a private queue.</span></span> <span data-ttu-id="8d1bd-130">若要針對公用佇列進行定址，您不可指定私用佇列。</span><span class="sxs-lookup"><span data-stu-id="8d1bd-130">To address a public queue, you must not specify private.</span></span> <span data-ttu-id="8d1bd-131">請注意，與 MSMQ 路徑不同的是，WCF URI 表單中沒有 "$"。</span><span class="sxs-lookup"><span data-stu-id="8d1bd-131">Note that, unlike MSMQ paths, there is no "$" in the WCF URI form.</span></span>  
  
- <span data-ttu-id="8d1bd-132">\<*queue-name*>這是佇列的名稱。</span><span class="sxs-lookup"><span data-stu-id="8d1bd-132">\<*queue-name*> is the name of the queue.</span></span> <span data-ttu-id="8d1bd-133">佇列名稱同時也參照到子佇列。</span><span class="sxs-lookup"><span data-stu-id="8d1bd-133">The queue name can also refer to a subqueue.</span></span> <span data-ttu-id="8d1bd-134">因此， \<*queue-name*>  =  \<*name-of-queue*> [;*子佇列-名稱*]。</span><span class="sxs-lookup"><span data-stu-id="8d1bd-134">Thus, \<*queue-name*> = \<*name-of-queue*>[;*sub-queue-name*].</span></span>  
  
 <span data-ttu-id="8d1bd-135">範例 1：若要針對 abc atadatum.com 電腦所裝載的私密佇列 PurchaseOrders 進行定址，URI 必須是 net.msmq://abc.adatum.com/private/PurchaseOrders。</span><span class="sxs-lookup"><span data-stu-id="8d1bd-135">Example1: To address a private queue PurchaseOrders hosted on computer abc atadatum.com, the URI would be net.msmq://abc.adatum.com/private/PurchaseOrders.</span></span>  
  
 <span data-ttu-id="8d1bd-136">範例 2：若要針對 def atadatum.com 電腦所裝載的公用佇列 AccountsPayable 進行定址，URI 必須是 net.msmq://def.adatum.com/AccountsPayable。</span><span class="sxs-lookup"><span data-stu-id="8d1bd-136">Example2: To address a public queue AccountsPayable hosted on computer def atadatum.com, the URI would be net.msmq://def.adatum.com/AccountsPayable.</span></span>  
  
 <span data-ttu-id="8d1bd-137">接聽項會使用佇列位址來當成接聽 URI 以讀取訊息。</span><span class="sxs-lookup"><span data-stu-id="8d1bd-137">The queue address is used as the Listen URI by the Listener to read messages from.</span></span> <span data-ttu-id="8d1bd-138">換句話說，佇列位址等於 TCP 通訊端的接聽連接埠。</span><span class="sxs-lookup"><span data-stu-id="8d1bd-138">In other words, the queue address is equivalent to the listen port of TCP socket.</span></span>  
  
 <span data-ttu-id="8d1bd-139">當端點要從佇列中讀取時，必須以先前開啟 ServiceHost 時所指定的相同配置來指定佇列位址。</span><span class="sxs-lookup"><span data-stu-id="8d1bd-139">An endpoint that reads from a queue must specify the address of the queue using the same scheme specified previously when opening the ServiceHost.</span></span> <span data-ttu-id="8d1bd-140">如需範例，請參閱[NET MSMQ Binding](../../../../docs/framework/wcf/samples/net-msmq-binding.md)。</span><span class="sxs-lookup"><span data-stu-id="8d1bd-140">For examples, see [Net MSMQ Binding](../../../../docs/framework/wcf/samples/net-msmq-binding.md).</span></span>  
  
### <a name="multiple-contracts-in-a-queue"></a><span data-ttu-id="8d1bd-141">佇列中多個合約</span><span class="sxs-lookup"><span data-stu-id="8d1bd-141">Multiple Contracts in a Queue</span></span>  
 <span data-ttu-id="8d1bd-142">佇列中的訊息可以實作不同的合約。</span><span class="sxs-lookup"><span data-stu-id="8d1bd-142">Messages in a queue can implement different contracts.</span></span> <span data-ttu-id="8d1bd-143">在此情況下，下列任何一項必須為真，以順利讀取並處理所有訊息：</span><span class="sxs-lookup"><span data-stu-id="8d1bd-143">In this case, it is essential that one of the following is true to successfully read and process all messages:</span></span>  
  
- <span data-ttu-id="8d1bd-144">指定可實作所有合約的服務端點。</span><span class="sxs-lookup"><span data-stu-id="8d1bd-144">Specify an endpoint for a service that implements all the contracts.</span></span> <span data-ttu-id="8d1bd-145">這是建議的方法。</span><span class="sxs-lookup"><span data-stu-id="8d1bd-145">This is the recommended approach.</span></span>  
  
- <span data-ttu-id="8d1bd-146">指定多個端點使用不同的合約，但是確保所有端點都使用相同的 `NetMsmqBinding` 物件。</span><span class="sxs-lookup"><span data-stu-id="8d1bd-146">Specify multiple endpoints with different contracts, but ensure that all the endpoints use the same `NetMsmqBinding` object.</span></span> <span data-ttu-id="8d1bd-147">ServiceModel 的分派邏輯使用訊息幫浦從分派的傳輸通道中讀取訊息，最後再依據合約將訊息信號分離到不同的端點上。</span><span class="sxs-lookup"><span data-stu-id="8d1bd-147">The dispatching logic in ServiceModel uses a message pump that reads messages out of the transport channel for dispatch, which eventually de-multiplexes messages based on the contract to different endpoints.</span></span> <span data-ttu-id="8d1bd-148">訊息幫浦會針對接聽 URI/繫結對來建立。</span><span class="sxs-lookup"><span data-stu-id="8d1bd-148">A message pump is created for a listen URI/Binding pair.</span></span> <span data-ttu-id="8d1bd-149">佇列接聽項會使用接聽項位址做為接聽 URI。</span><span class="sxs-lookup"><span data-stu-id="8d1bd-149">The queue address is used as the Listen URI by the queued listener.</span></span> <span data-ttu-id="8d1bd-150">讓所有端點都使用相同的繫結物件可確保使用單一訊息幫浦來讀取訊息，並依據合約將訊息信號分離到相關的端點上。</span><span class="sxs-lookup"><span data-stu-id="8d1bd-150">Having all the endpoints use the same binding object ensures that a single message pump is used to read the message and de-multiplex to relevant endpoints based on the contract.</span></span>  
  
### <a name="srmp-messaging"></a><span data-ttu-id="8d1bd-151">SRMP 訊息處理</span><span class="sxs-lookup"><span data-stu-id="8d1bd-151">SRMP Messaging</span></span>  
 <span data-ttu-id="8d1bd-152">如先前所述，您可以使用 SRMP 通訊協定來進行佇列對佇列 (queue-to-queue) 傳輸作業。</span><span class="sxs-lookup"><span data-stu-id="8d1bd-152">As previously discussed, you can use the SRMP protocol for queue-to-queue transfers.</span></span> <span data-ttu-id="8d1bd-153">當 HTTP 傳輸需要在傳輸佇列與目標佇列之間傳輸訊息時，通常會使用這種方式。</span><span class="sxs-lookup"><span data-stu-id="8d1bd-153">This is commonly used when an HTTP transport transmits messages between the Transmission Queue and the Target Queue.</span></span>  
  
 <span data-ttu-id="8d1bd-154">若要使用 SRMP 傳輸通訊協定，請使用 net.msmq URI 配置 (如先前所述) 針對訊息進行定址，然後在 `QueueTransferProtocol` 的 `NetMsmqBinding` 屬性中指定 SRMP 或安全 SRMP 的選擇。</span><span class="sxs-lookup"><span data-stu-id="8d1bd-154">To use the SRMP transfer protocol, address messages using the net.msmq URI scheme, as mentioned previously, and specify the choice of SRMP or Secured SRMP in the `QueueTransferProtocol` property of the `NetMsmqBinding`.</span></span>  
  
 <span data-ttu-id="8d1bd-155">指定 `QueueTransferProtocol` 屬性是一種僅限傳送的功能。</span><span class="sxs-lookup"><span data-stu-id="8d1bd-155">Specifying the `QueueTransferProtocol` property is a send-only feature.</span></span> <span data-ttu-id="8d1bd-156">用戶端會使用這種方式來表示要使用哪種佇列傳輸通訊協定。</span><span class="sxs-lookup"><span data-stu-id="8d1bd-156">This is an indication by the client which kind of queue transfer protocol to use.</span></span>  
  
### <a name="using-active-directory"></a><span data-ttu-id="8d1bd-157">使用 Active Directory</span><span class="sxs-lookup"><span data-stu-id="8d1bd-157">Using Active Directory</span></span>  
 <span data-ttu-id="8d1bd-158">MSMQ 預設支援 Active Directory 整合。</span><span class="sxs-lookup"><span data-stu-id="8d1bd-158">MSMQ comes with support for Active Directory integration.</span></span> <span data-ttu-id="8d1bd-159">當 MSMQ 與 Active Directory 整合一併安裝時，電腦必須是 Windows 網域的一部分。</span><span class="sxs-lookup"><span data-stu-id="8d1bd-159">When MSMQ is installed with Active Directory integration, the machine must be part of a Windows domain.</span></span> <span data-ttu-id="8d1bd-160">Active Directory 可用來發佈用於探索的佇列;這類佇列稱為*公用佇列*。</span><span class="sxs-lookup"><span data-stu-id="8d1bd-160">Active Directory is used to publish queues for discovery; such queues are called *public queues*.</span></span> <span data-ttu-id="8d1bd-161">針對佇列進行定址時，可以使用 Active Directory 來解析佇列。</span><span class="sxs-lookup"><span data-stu-id="8d1bd-161">When addressing a queue, the queue can be resolved using Active Directory.</span></span> <span data-ttu-id="8d1bd-162">這與使用網域名稱系統 (DNS) 來解析網路名稱 IP 位址有異曲同工之妙。</span><span class="sxs-lookup"><span data-stu-id="8d1bd-162">This is similar to how Domain Name System (DNS) is used to resolve the IP address of a network name.</span></span> <span data-ttu-id="8d1bd-163">`UseActiveDirectory` 中的 `NetMsmqBinding` 屬性是一項布林值，可表示佇列通道是否該使用 Active Directory 來解析佇列 URI。</span><span class="sxs-lookup"><span data-stu-id="8d1bd-163">The `UseActiveDirectory` property in `NetMsmqBinding` is a Boolean that indicates whether the queued channel must use Active Directory to resolve the queue URI.</span></span> <span data-ttu-id="8d1bd-164">根據預設，此屬性設定為 `false`。</span><span class="sxs-lookup"><span data-stu-id="8d1bd-164">By default it is set to `false`.</span></span> <span data-ttu-id="8d1bd-165">如果 `UseActiveDirectory` 屬性設為 `true`，則佇列通道會使用 Active Directory 將 net.msmq:// URI 轉換為格式名稱。</span><span class="sxs-lookup"><span data-stu-id="8d1bd-165">If the `UseActiveDirectory` property is set to `true`, then the queued channel uses Active Directory to convert the net.msmq:// URI to format name.</span></span>  
  
 <span data-ttu-id="8d1bd-166">只有當用戶端傳送訊息時，`UseActiveDirectory` 屬性才有意義，因為當傳送訊息時，會使用此屬性來解析佇列位址。</span><span class="sxs-lookup"><span data-stu-id="8d1bd-166">The `UseActiveDirectory` property is meaningful only for the client that is sending the message because it is used to resolve the address of the queue when sending messages.</span></span>  
  
### <a name="mapping-netmsmq-uri-to-message-queuing-format-names"></a><span data-ttu-id="8d1bd-167">將 net.msmq URI 對應至訊息佇列格式名稱</span><span class="sxs-lookup"><span data-stu-id="8d1bd-167">Mapping net.msmq URI to Message Queuing Format Names</span></span>  
 <span data-ttu-id="8d1bd-168">佇列通道會處理提供給通道的 net.msmq URI 名稱以及 MSMQ 格式名稱之間的對應。</span><span class="sxs-lookup"><span data-stu-id="8d1bd-168">The queued channel handles mapping the net.msmq URI name provided to the channel to MSMQ format names.</span></span> <span data-ttu-id="8d1bd-169">下表摘要說明用來對應彼此關係的規則。</span><span class="sxs-lookup"><span data-stu-id="8d1bd-169">The following table summarizes the rules used to map between them.</span></span>  
  
|<span data-ttu-id="8d1bd-170">以 WCF URI 為基礎的佇列位址</span><span class="sxs-lookup"><span data-stu-id="8d1bd-170">WCF URI-based queue address</span></span>|<span data-ttu-id="8d1bd-171">使用 Active Directory 屬性</span><span class="sxs-lookup"><span data-stu-id="8d1bd-171">Use Active Directory property</span></span>|<span data-ttu-id="8d1bd-172">佇列傳輸通訊協定屬性</span><span class="sxs-lookup"><span data-stu-id="8d1bd-172">Queue Transfer Protocol property</span></span>|<span data-ttu-id="8d1bd-173">最後的 MSMQ 格式名稱</span><span class="sxs-lookup"><span data-stu-id="8d1bd-173">Resulting MSMQ format names</span></span>|  
|----------------------------------|-----------------------------------|--------------------------------------|---------------------------------|  
|`Net.msmq://<machine-name>/private/abc`|<span data-ttu-id="8d1bd-174">FALSE (預設值)</span><span class="sxs-lookup"><span data-stu-id="8d1bd-174">False (default)</span></span>|<span data-ttu-id="8d1bd-175">Native (預設)</span><span class="sxs-lookup"><span data-stu-id="8d1bd-175">Native (default)</span></span>|`DIRECT=OS:machine-name\private$\abc`|  
|`Net.msmq://<machine-name>/private/abc`|<span data-ttu-id="8d1bd-176">False</span><span class="sxs-lookup"><span data-stu-id="8d1bd-176">False</span></span>|<span data-ttu-id="8d1bd-177">SRMP</span><span class="sxs-lookup"><span data-stu-id="8d1bd-177">SRMP</span></span>|`DIRECT=http://machine/msmq/private$/abc`|  
|`Net.msmq://<machine-name>/private/abc`|<span data-ttu-id="8d1bd-178">True</span><span class="sxs-lookup"><span data-stu-id="8d1bd-178">True</span></span>|<span data-ttu-id="8d1bd-179">原生</span><span class="sxs-lookup"><span data-stu-id="8d1bd-179">Native</span></span>|<span data-ttu-id="8d1bd-180">`PUBLIC=some-guid`（佇列的 GUID）</span><span class="sxs-lookup"><span data-stu-id="8d1bd-180">`PUBLIC=some-guid` (the GUID of the queue)</span></span>|  
  
### <a name="reading-messages-from-the-dead-letter-queue-or-the-poison-message-queue"></a><span data-ttu-id="8d1bd-181">從寄不出的信件佇列或有害訊息佇列讀取訊息</span><span class="sxs-lookup"><span data-stu-id="8d1bd-181">Reading Messages from the Dead-Letter Queue or the Poison-Message Queue</span></span>  
 <span data-ttu-id="8d1bd-182">若要從屬於目標佇列之子佇列的有害訊息佇列中讀取訊息，請使用子佇列位址來開啟 `ServiceHost`。</span><span class="sxs-lookup"><span data-stu-id="8d1bd-182">To read messages from a poison-message queue that is a subqueue of the target queue, open the `ServiceHost` with the address of the subqueue.</span></span>  
  
 <span data-ttu-id="8d1bd-183">範例：從本機電腦的 PurchaseOrders 私用佇列之有害訊息佇列讀取訊息的服務，會定址為 net.msmq://localhost/private/PurchaseOrders;poison。</span><span class="sxs-lookup"><span data-stu-id="8d1bd-183">Example: A service that reads from the poison-message queue of the PurchaseOrders private queue from the local machine would address net.msmq://localhost/private/PurchaseOrders;poison.</span></span>  
  
 <span data-ttu-id="8d1bd-184">為了從系統的異動式寄不出的信件佇列讀取訊息，URI 必須採用 net.msmq://localhost/system$;DeadXact 的格式。</span><span class="sxs-lookup"><span data-stu-id="8d1bd-184">To read messages from a system transactional dead-letter queue, the URI must be of the form: net.msmq://localhost/system$;DeadXact.</span></span>  
  
 <span data-ttu-id="8d1bd-185">為了從系統的非交易式寄不出的信件佇列讀取訊息，URI 必須採用 net.msmq://localhost/system$;DeadLetter 的格式。</span><span class="sxs-lookup"><span data-stu-id="8d1bd-185">To read messages from a system nontransactional dead-letter queue, the URI must be of the form: net.msmq://localhost/system$;DeadLetter.</span></span>  
  
 <span data-ttu-id="8d1bd-186">在使用自訂寄不出的信件佇列時，請注意寄不出的信件佇列必須位於本機電腦上。</span><span class="sxs-lookup"><span data-stu-id="8d1bd-186">When using a custom dead-letter queue, note that the dead-letter queue must reside on the local computer.</span></span> <span data-ttu-id="8d1bd-187">因此，寄不出的信件佇列 URI 將限於 </span><span class="sxs-lookup"><span data-stu-id="8d1bd-187">As such, the URI for the dead-letter queue is restricted to the form:</span></span>  
  
 <span data-ttu-id="8d1bd-188">net.tcp：//localhost/[private/] \<*custom-dead-letter-queue-name*> 。</span><span class="sxs-lookup"><span data-stu-id="8d1bd-188">net.msmq: //localhost/ [private/]  \<*custom-dead-letter-queue-name*>.</span></span>  
  
 <span data-ttu-id="8d1bd-189">WCF 服務會確認它所收到的所有訊息都已定址到它正在接聽的特定佇列。</span><span class="sxs-lookup"><span data-stu-id="8d1bd-189">A WCF service verifies that all messages it receives were addressed to the particular queue it is listening on.</span></span> <span data-ttu-id="8d1bd-190">如果訊息的目的地佇列不符合找到的佇列，則服務將無法處理訊息。</span><span class="sxs-lookup"><span data-stu-id="8d1bd-190">If the message’s destination queue does not match the queue it is found in, the service does not process the message.</span></span> <span data-ttu-id="8d1bd-191">這是負責接聽寄不出的信件佇列的服務必須解決的問題，因為寄不出的信件佇列中任何訊息都是要傳送到其他地方的。</span><span class="sxs-lookup"><span data-stu-id="8d1bd-191">This is an issue that services listening to a dead-letter queue must address because any message in the dead-letter queue was meant to be delivered elsewhere.</span></span> <span data-ttu-id="8d1bd-192">若要從寄不出的信件佇列或有害佇列中讀取訊息，必須使用包含 `ServiceBehavior` 參數的 <xref:System.ServiceModel.AddressFilterMode.Any>。</span><span class="sxs-lookup"><span data-stu-id="8d1bd-192">To read messages from a dead-letter queue, or from a poison queue, a `ServiceBehavior` with the <xref:System.ServiceModel.AddressFilterMode.Any> parameter must be used.</span></span> <span data-ttu-id="8d1bd-193">如需範例，請參閱[無效信件佇列](../../../../docs/framework/wcf/samples/dead-letter-queues.md)。</span><span class="sxs-lookup"><span data-stu-id="8d1bd-193">For an example, see [Dead Letter Queues](../../../../docs/framework/wcf/samples/dead-letter-queues.md).</span></span>  
  
## <a name="msmqintegrationbinding-and-service-addressing"></a><span data-ttu-id="8d1bd-194">MsmqIntegrationBinding 與服務定址</span><span class="sxs-lookup"><span data-stu-id="8d1bd-194">MsmqIntegrationBinding and Service Addressing</span></span>  
 <span data-ttu-id="8d1bd-195">`MsmqIntegrationBinding` 是用來與傳統 MSMQ 應用程式進行通訊的。</span><span class="sxs-lookup"><span data-stu-id="8d1bd-195">The `MsmqIntegrationBinding` is used for communication with traditional MSMQ applications.</span></span> <span data-ttu-id="8d1bd-196">為了簡化與現有 MSMQ 應用程式的交互操作，WCF 僅支援格式名稱定址。</span><span class="sxs-lookup"><span data-stu-id="8d1bd-196">To ease interoperation with an existing MSMQ application, WCF supports only format name addressing.</span></span> <span data-ttu-id="8d1bd-197">因此，使用此繫結來傳送的訊息必須符合下列 URI 配置：</span><span class="sxs-lookup"><span data-stu-id="8d1bd-197">Thus, messages sent using this binding must conform to the URI scheme:</span></span>  
  
 <span data-ttu-id="8d1bd-198">msmq. msmq.formatname：\<*MSMQ-format-name*>></span><span class="sxs-lookup"><span data-stu-id="8d1bd-198">msmq.formatname:\<*MSMQ-format-name*>></span></span>  
  
 <span data-ttu-id="8d1bd-199">MSMQ 格式名稱是[關於訊息佇列](https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms706032(v=vs.85))中 msmq 指定的格式。</span><span class="sxs-lookup"><span data-stu-id="8d1bd-199">The MSMQ-format-name is of the form specified by MSMQ in [About Message Queuing](https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms706032(v=vs.85)).</span></span>  
  
 <span data-ttu-id="8d1bd-200">請注意，當您使用 `MsmqIntegrationBinding` 從佇列接收訊息時，只能使用直接格式名稱，與公用與私用格式名稱 (需要 Active Directory 整合)。</span><span class="sxs-lookup"><span data-stu-id="8d1bd-200">Note that you can only use direct format names, and public and private format names (requires Active Directory integration) when receiving messages from a queue using `MsmqIntegrationBinding`.</span></span> <span data-ttu-id="8d1bd-201">然而，我們建議您使用直接格式名稱。</span><span class="sxs-lookup"><span data-stu-id="8d1bd-201">However, it is advised that you use direct format names.</span></span> <span data-ttu-id="8d1bd-202">例如，在 Windows Vista 上，使用任何其他格式名稱會造成錯誤，因為系統會嘗試開啟子佇列，這只能使用直接格式名稱來開啟。</span><span class="sxs-lookup"><span data-stu-id="8d1bd-202">For example, on Windows Vista, using any other format name causes an error because the system attempts to open a subqueue, which can only be opened with direct format names.</span></span>  
  
 <span data-ttu-id="8d1bd-203">當您使用 `MsmqIntegrationBinding` 為 SRMP 定址時，不需要在直接格式名稱中新增 /msmq/ 以協助網際網路資訊服務 (IIS) 進行分派作業。</span><span class="sxs-lookup"><span data-stu-id="8d1bd-203">When addressing SRMP using `MsmqIntegrationBinding`, there is no requirement to add /msmq/ in the direct format name to help Internet Information Services (IIS) with dispatching.</span></span> <span data-ttu-id="8d1bd-204">例如：使用 SRMP 通訊協定定址佇列 abc 時，您應該使用，而不是 `DIRECT=http://adatum.com/msmq/private$/abc` `DIRECT=http://adatum.com/private$/abc` 。</span><span class="sxs-lookup"><span data-stu-id="8d1bd-204">For example: When addressing a queue abc using the SRMP protocol, instead of `DIRECT=http://adatum.com/msmq/private$/abc`, you should use `DIRECT=http://adatum.com/private$/abc`.</span></span>  
  
 <span data-ttu-id="8d1bd-205">請注意，您無法使用包含 `MsmqIntegrationBinding` 的 net.msmq:// 定址。</span><span class="sxs-lookup"><span data-stu-id="8d1bd-205">Note that you cannot use net.msmq:// addressing with `MsmqIntegrationBinding`.</span></span> <span data-ttu-id="8d1bd-206">由於 `MsmqIntegrationBinding` 支援自由格式的 MSMQ 格式名稱定址，因此您可以使用使用此系結的 WCF 服務來使用 MSMQ 中的多播和通訊群組清單功能。</span><span class="sxs-lookup"><span data-stu-id="8d1bd-206">Because `MsmqIntegrationBinding` supports free-form MSMQ format name addressing, you can use a WCF service that uses this binding to use multicast and distribution list features in MSMQ.</span></span> <span data-ttu-id="8d1bd-207">當您使用 `CustomDeadLetterQueue` 時，需指定 `MsmqIntegrationBinding` 則是一個例外。</span><span class="sxs-lookup"><span data-stu-id="8d1bd-207">One exception is specifying `CustomDeadLetterQueue` when using the `MsmqIntegrationBinding`.</span></span> <span data-ttu-id="8d1bd-208">它必須是 net.msmq:// 的格式，與使用 `NetMsmqBinding` 來指定的方式很類似。</span><span class="sxs-lookup"><span data-stu-id="8d1bd-208">It must be of the form net.msmq://, similar to how it is specified using the `NetMsmqBinding`.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="8d1bd-209">另請參閱</span><span class="sxs-lookup"><span data-stu-id="8d1bd-209">See also</span></span>

- [<span data-ttu-id="8d1bd-210">以 Web 裝載佇列應用程式</span><span class="sxs-lookup"><span data-stu-id="8d1bd-210">Web Hosting a Queued Application</span></span>](../../../../docs/framework/wcf/feature-details/web-hosting-a-queued-application.md)
