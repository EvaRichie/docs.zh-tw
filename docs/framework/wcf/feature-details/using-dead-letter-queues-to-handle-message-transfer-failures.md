---
title: 使用寄不出的信件佇列來處理訊息傳輸失敗
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: 9e891c6a-d960-45ea-904f-1a00e202d61a
ms.openlocfilehash: f07397b4c10ffec4902dbde37b622978d00f5b63
ms.sourcegitcommit: cdb295dd1db589ce5169ac9ff096f01fd0c2da9d
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 06/09/2020
ms.locfileid: "84594981"
---
# <a name="using-dead-letter-queues-to-handle-message-transfer-failures"></a><span data-ttu-id="e678a-102">使用寄不出的信件佇列來處理訊息傳輸失敗</span><span class="sxs-lookup"><span data-stu-id="e678a-102">Using Dead-Letter Queues to Handle Message Transfer Failures</span></span>
<span data-ttu-id="e678a-103">佇列訊息可能會傳遞失敗。</span><span class="sxs-lookup"><span data-stu-id="e678a-103">Queued messages can fail delivery.</span></span> <span data-ttu-id="e678a-104">這些失敗的訊息都會記錄在寄不出的信件佇列中。</span><span class="sxs-lookup"><span data-stu-id="e678a-104">These failed messages are recorded in a dead-letter queue.</span></span> <span data-ttu-id="e678a-105">造成傳遞失敗的原因可能是網路失敗、佇列已刪除、佇列已滿、驗證失敗，或是未能準時傳遞。</span><span class="sxs-lookup"><span data-stu-id="e678a-105">The failed delivery can be caused by reasons such as network failures, a deleted queue, a full queue, authentication failure, or a failure to deliver on time.</span></span>  
  
 <span data-ttu-id="e678a-106">如果接收應用程式未及時讀取佇列中的訊息，佇列的訊息可能會長時間停留於佇列中。</span><span class="sxs-lookup"><span data-stu-id="e678a-106">Queued messages can remain in the queue for a long time if the receiving application does not read them from the queue in a timely fashion.</span></span> <span data-ttu-id="e678a-107">這項行為對於時間緊急的訊息可能會不適當。</span><span class="sxs-lookup"><span data-stu-id="e678a-107">This behavior may not be appropriate for time-sensitive messages.</span></span> <span data-ttu-id="e678a-108">時間緊急訊息的佇列繫結會設定「訊息存留時間」(TTL) 屬性，此屬性會指示該訊息在過期前可於佇列中停留多久。</span><span class="sxs-lookup"><span data-stu-id="e678a-108">Time-sensitive messages have a Time to Live (TTL) property set in the queued binding, which indicates how long the messages can be in the queue before they must expire.</span></span> <span data-ttu-id="e678a-109">過期訊息會傳送至稱為「寄不出的信件佇列」的特殊佇列。</span><span class="sxs-lookup"><span data-stu-id="e678a-109">Expired messages are sent to a special queue called the dead-letter queue.</span></span> <span data-ttu-id="e678a-110">訊息也可能會因為其他原因而放入寄不出的信件佇列中，例如超過佇列配額或發生驗證失敗。</span><span class="sxs-lookup"><span data-stu-id="e678a-110">Messages can also be put in a dead-letter queue for other reasons, such as exceeding a queue quota or because of authentication failure.</span></span>  
  
 <span data-ttu-id="e678a-111">一般而言，應用程式都會撰寫補償邏輯來讀取寄不出的信件佇列中的訊息和失敗原因。</span><span class="sxs-lookup"><span data-stu-id="e678a-111">Generally, applications write compensation logic to read messages from the dead-letter queue and failure reasons.</span></span> <span data-ttu-id="e678a-112">補償邏輯會依據失敗原因而有不同。</span><span class="sxs-lookup"><span data-stu-id="e678a-112">The compensation logic depends on the cause of the failure.</span></span> <span data-ttu-id="e678a-113">例如，在驗證失敗的情況下，您可以修正附加在訊息中的憑證，並且重新傳送訊息。</span><span class="sxs-lookup"><span data-stu-id="e678a-113">For example, in the case of authentication failure, you can correct the certificate attached with the message and resend the message.</span></span> <span data-ttu-id="e678a-114">如果是因為到達目標佇列配額而導致傳遞失敗，您可以在解決配額問題之後重新嘗試傳遞。</span><span class="sxs-lookup"><span data-stu-id="e678a-114">If delivery failed because the target queue quota was reached, you can reattempt delivery in the hope that the quota problem was resolved.</span></span>  
  
 <span data-ttu-id="e678a-115">大多數佇列系統都有整個系統的寄不出的信件佇列，而該系統的所有失敗訊息都會儲存於其中。</span><span class="sxs-lookup"><span data-stu-id="e678a-115">Most queuing systems have a system-wide dead-letter queue where all failed messages from that system are stored.</span></span> <span data-ttu-id="e678a-116">訊息佇列 (MSMQ) 提供兩種整個系統的寄不出的信件佇列，一個是整個系統的異動式寄不出的信件佇列，其中會儲存無法傳遞到異動式佇列的訊息，另一個是整個系統的非異動式寄不出的信件佇列，其中會儲存無法傳遞到非異動式佇列的訊息。</span><span class="sxs-lookup"><span data-stu-id="e678a-116">Message Queuing (MSMQ) provides two system-wide dead-letter queues: a transactional system-wide dead-letter queue that stores messages that failed delivery to the transactional queue and a non-transactional system-wide dead-letter queue that stores messages that failed delivery to the non-transactional queue.</span></span> <span data-ttu-id="e678a-117">如果有兩個用戶端將訊息傳送至兩個不同的服務，因此 WCF 中的不同佇列會共用相同的 MSMQ 服務來傳送，則可能會在系統寄不出的信件佇列中混用訊息。</span><span class="sxs-lookup"><span data-stu-id="e678a-117">If two clients are sending messages to two different services, and therefore different queues in WCF are sharing the same MSMQ service to send, then it is possible to have a mix of messages in the system dead-letter queue.</span></span> <span data-ttu-id="e678a-118">這種處理不一定是最佳做法。</span><span class="sxs-lookup"><span data-stu-id="e678a-118">This is not always optimal.</span></span> <span data-ttu-id="e678a-119">在幾種情況下 (例如，考量安全性的情況下)，您可能不想讓某個用戶端從寄不出的信件佇列中讀取到另一個用戶端的訊息。</span><span class="sxs-lookup"><span data-stu-id="e678a-119">In several cases (security, for example), you may not want one client to read another client's messages from a dead-letter queue.</span></span> <span data-ttu-id="e678a-120">共用的寄不出的信件佇列也會要求用戶端瀏覽整個佇列來尋找自己所傳送的訊息，而根據寄不出的信件佇列中的訊息數目，這樣可能會極為耗費資源。</span><span class="sxs-lookup"><span data-stu-id="e678a-120">A shared dead-letter queue also requires clients to browse through the queue to find a message that they sent, which can be prohibitively expensive based on the number of messages in the dead-letter queue.</span></span> <span data-ttu-id="e678a-121">因此，在 WCF 中 `NetMsmqBinding` ， `MsmqIntegrationBinding,` 和在 Windows Vista 上的 MSMQ 會提供自訂的寄不出的信件佇列（有時稱為應用程式特定的寄不出的信件佇列）。</span><span class="sxs-lookup"><span data-stu-id="e678a-121">Therefore, in WCF`NetMsmqBinding`, `MsmqIntegrationBinding,` and MSMQ on Windows Vista provide a custom dead-letter queue (sometimes referred to as an application-specific dead-letter queue).</span></span>  
  
 <span data-ttu-id="e678a-122">自訂的寄不出的信件佇列會隔離共用相同 MSMQ 服務以傳送訊息的用戶端。</span><span class="sxs-lookup"><span data-stu-id="e678a-122">The custom dead-letter queue provides isolation between clients that share the same MSMQ service to send messages.</span></span>  
  
 <span data-ttu-id="e678a-123">在 Windows Server 2003 和 Windows XP 上，Windows Communication Foundation （WCF）會針對所有排入佇列的用戶端應用程式提供全系統的無效信件佇列。</span><span class="sxs-lookup"><span data-stu-id="e678a-123">On Windows Server 2003 and Windows XP, Windows Communication Foundation (WCF) provides a system-wide dead-letter queue for all queued client applications.</span></span> <span data-ttu-id="e678a-124">在 Windows Vista 上，WCF 會針對每個佇列的用戶端應用程式提供寄不出的信件佇列。</span><span class="sxs-lookup"><span data-stu-id="e678a-124">On Windows Vista, WCF provides a dead-letter queue for each queued client application.</span></span>  
  
## <a name="specifying-use-of-the-dead-letter-queue"></a><span data-ttu-id="e678a-125">指定寄不出的信件佇列的使用方式</span><span class="sxs-lookup"><span data-stu-id="e678a-125">Specifying Use of the Dead-Letter Queue</span></span>  
 <span data-ttu-id="e678a-126">寄不出的信件佇列是位於傳送應用程式的佇列管理員中。</span><span class="sxs-lookup"><span data-stu-id="e678a-126">A dead-letter queue is in the queue manager of the sending application.</span></span> <span data-ttu-id="e678a-127">它會儲存已過期的訊息或是無法傳輸或傳遞的訊息。</span><span class="sxs-lookup"><span data-stu-id="e678a-127">It stores messages that have expired or that have failed transfer or delivery.</span></span>  
  
 <span data-ttu-id="e678a-128">繫結具有下列寄不出的信件佇列屬性：</span><span class="sxs-lookup"><span data-stu-id="e678a-128">The binding has the following dead-letter queue properties:</span></span>  
  
- <xref:System.ServiceModel.MsmqBindingBase.DeadLetterQueue%2A>  
  
- <xref:System.ServiceModel.MsmqBindingBase.CustomDeadLetterQueue%2A>  
  
## <a name="reading-messages-from-the-dead-letter-queue"></a><span data-ttu-id="e678a-129">從寄不出的信件佇列讀取訊息</span><span class="sxs-lookup"><span data-stu-id="e678a-129">Reading Messages from the Dead-Letter Queue</span></span>  
 <span data-ttu-id="e678a-130">從寄不出的信件佇列讀取訊息的應用程式類似于從應用程式佇列讀取的 WCF 服務，但以下的次要差異除外：</span><span class="sxs-lookup"><span data-stu-id="e678a-130">An application that reads messages out of a dead-letter queue is similar to a WCF service that reads from an application queue, except for the following minor differences:</span></span>  
  
- <span data-ttu-id="e678a-131">為了從系統的交易式寄不出的信件佇列讀取訊息，統一資源識別元 (URI) 必須採用 net.msmq://localhost/system$;DeadXact 的格式。</span><span class="sxs-lookup"><span data-stu-id="e678a-131">To read messages from a system transactional dead-letter queue, the Uniform Resource Identifier (URI) must be of the form: net.msmq://localhost/system$;DeadXact.</span></span>  
  
- <span data-ttu-id="e678a-132">為了從系統的非交易式寄不出的信件佇列讀取訊息，URI 必須採用 net.msmq://localhost/system$;DeadLetter 的格式。</span><span class="sxs-lookup"><span data-stu-id="e678a-132">To read messages from a system non-transactional dead-letter queue, the URI must be of the form: net.msmq://localhost/system$;DeadLetter.</span></span>  
  
- <span data-ttu-id="e678a-133">若要從自訂的寄不出的信件佇列讀取訊息，URI 的格式必須是： net. msmq：//localhost/private/ \<*custom-dlq-name*> ，其中*dlq*是自訂的寄不出的信件佇列的名稱。</span><span class="sxs-lookup"><span data-stu-id="e678a-133">To read messages from a custom dead-letter queue, the URI must be of the form:net.msmq://localhost/private/\<*custom-dlq-name*> where *custom-dlq-name* is the name of the custom dead-letter queue.</span></span>  
  
 <span data-ttu-id="e678a-134">如需如何定址佇列的詳細資訊，請參閱[服務端點和佇列定址](service-endpoints-and-queue-addressing.md)。</span><span class="sxs-lookup"><span data-stu-id="e678a-134">For more information about how to address queues, see [Service Endpoints and Queue Addressing](service-endpoints-and-queue-addressing.md).</span></span>  
  
 <span data-ttu-id="e678a-135">接收端上的 WCF 堆疊符合服務正在接聽的位址與訊息上的位址。</span><span class="sxs-lookup"><span data-stu-id="e678a-135">The WCF stack on the receiver matches addresses that the service is listening on with the address on the message.</span></span> <span data-ttu-id="e678a-136">如果這些位址相符，便發送該訊息，否則，就不發送該訊息。</span><span class="sxs-lookup"><span data-stu-id="e678a-136">If the addresses match, the message is dispatched; if not, the message is not dispatched.</span></span> <span data-ttu-id="e678a-137">這種做法在從寄不出的信件佇列讀取訊息時會發生問題，因為寄不出的信件佇列中的訊息通常是定位傳送給該服務，而不定位傳送給寄不出的信件佇列服務。</span><span class="sxs-lookup"><span data-stu-id="e678a-137">This can cause problems when reading from the dead-letter queue, because messages in the dead-letter queue are typically addressed to the service and not the dead-letter queue service.</span></span> <span data-ttu-id="e678a-138">因此，從寄不出的信件佇列讀取的服務必須安裝位址篩選 `ServiceBehavior`，這個行為會指示堆疊比對佇列中的所有訊息，而不管收訊者為何。</span><span class="sxs-lookup"><span data-stu-id="e678a-138">Therefore, the service reading from the dead-letter queue must install an address filter `ServiceBehavior` that instructs the stack to match all messages in the queue independently of the addressee.</span></span> <span data-ttu-id="e678a-139">具體來說，您必須在從寄不出的信件佇列讀取訊息的服務中新增含有 `ServiceBehavior` 參數的 <xref:System.ServiceModel.AddressFilterMode.Any>。</span><span class="sxs-lookup"><span data-stu-id="e678a-139">Specifically, you must add a `ServiceBehavior` with the <xref:System.ServiceModel.AddressFilterMode.Any> parameter to the service reading messages from the dead-letter queue.</span></span>  
  
## <a name="poison-message-handling-from-the-dead-letter-queue"></a><span data-ttu-id="e678a-140">從寄不出的信件佇列處理有害訊息</span><span class="sxs-lookup"><span data-stu-id="e678a-140">Poison Message Handling from the Dead-Letter Queue</span></span>  
 <span data-ttu-id="e678a-141">在一些條件前提下，寄不出的信件佇列會提供有害訊息處理的功能。</span><span class="sxs-lookup"><span data-stu-id="e678a-141">Poison message handling is available on dead-letter queues, with some conditions.</span></span> <span data-ttu-id="e678a-142">由於您無法從系統佇列建立子佇列，所以在從系統的寄不出的信件佇列讀取時，`ReceiveErrorHandling` 無法設定為 `Move`。</span><span class="sxs-lookup"><span data-stu-id="e678a-142">Because you cannot create sub-queues from system queues, when reading from the system dead-letter queue, the `ReceiveErrorHandling` cannot be set to `Move`.</span></span> <span data-ttu-id="e678a-143">請注意，如果是從自訂的寄不出的信件佇列讀取，您就可建立子佇列，因此，`Move` 會是有效處置有害訊息的方式。</span><span class="sxs-lookup"><span data-stu-id="e678a-143">Note that if you are reading from a custom dead-letter queue, you can have sub-queues and, therefore, `Move` is a valid disposition for the poison message.</span></span>  
  
 <span data-ttu-id="e678a-144">當 `ReceiveErrorHandling` 設定為 `Reject`，從自訂的寄不出的信件佇列讀取時，有害訊息將會放到系統的寄不出的信件佇列中。</span><span class="sxs-lookup"><span data-stu-id="e678a-144">When `ReceiveErrorHandling` is set to `Reject`, when reading from the custom dead letter queue, the poison message is put in the system dead-letter queue.</span></span> <span data-ttu-id="e678a-145">如果是從系統的寄不出的信件佇列讀取，該訊息就會被捨棄 (清除)。</span><span class="sxs-lookup"><span data-stu-id="e678a-145">If reading from the system dead-letter queue, the message is dropped (purged).</span></span> <span data-ttu-id="e678a-146">在 MSMQ 中，由系統的寄不出的信件佇列傳回 Reject 時，便會捨棄 (清除) 訊息。</span><span class="sxs-lookup"><span data-stu-id="e678a-146">A reject from a system dead-letter queue in MSMQ drops (purges) the message.</span></span>  
  
## <a name="example"></a><span data-ttu-id="e678a-147">範例</span><span class="sxs-lookup"><span data-stu-id="e678a-147">Example</span></span>  
 <span data-ttu-id="e678a-148">下列範例會示範如何建立寄不出的信件佇列，以及如何使用該佇列來處理過期的訊息。</span><span class="sxs-lookup"><span data-stu-id="e678a-148">The following example shows how to create a dead-letter queue and how to use it to process expired messages.</span></span> <span data-ttu-id="e678a-149">此範例是以[如何：與 WCF 端點交換佇列訊息](how-to-exchange-queued-messages-with-wcf-endpoints.md)中的範例為基礎。</span><span class="sxs-lookup"><span data-stu-id="e678a-149">The example is based on the example in [How to: Exchange Queued Messages with WCF Endpoints](how-to-exchange-queued-messages-with-wcf-endpoints.md).</span></span> <span data-ttu-id="e678a-150">下列範例會示範如何撰寫訂單處理服務的用戶端程式碼，該服務會分別針對每個應用程式使用寄不出的信件佇列。</span><span class="sxs-lookup"><span data-stu-id="e678a-150">The following example shows how to write the client code to the order processing service that uses a dead-letter queue for each application.</span></span> <span data-ttu-id="e678a-151">這個範例也會示範如何處理寄不出的信件佇列中的訊息。</span><span class="sxs-lookup"><span data-stu-id="e678a-151">The example also shows how to process messages from the dead-letter queue.</span></span>  
  
 <span data-ttu-id="e678a-152">下列是用戶端的程式碼，此用戶端會針對每個應用程式指定寄不出的信件佇列。</span><span class="sxs-lookup"><span data-stu-id="e678a-152">The following is code for a client that specifies a dead-letter queue for each application.</span></span>  
  
 [!code-csharp[S_DeadLetter#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/s_deadletter/cs/client.cs#1)]
 [!code-vb[S_DeadLetter#1](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/s_deadletter/vb/client.vb#1)]  
  
 <span data-ttu-id="e678a-153">下列是用戶端組態檔的程式碼。</span><span class="sxs-lookup"><span data-stu-id="e678a-153">The following is code for the client configuration file.</span></span>  

 <span data-ttu-id="e678a-154">下列是服務的程式碼，此服務會處理寄不出的信件佇列中的訊息。</span><span class="sxs-lookup"><span data-stu-id="e678a-154">The following is code for a service processing messages from a dead-letter queue.</span></span>  
  
 [!code-csharp[S_DeadLetter#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/s_deadletter/cs/dlservice.cs#3)]
 [!code-vb[S_DeadLetter#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/s_deadletter/vb/dlservice.vb#3)]  
  
 <span data-ttu-id="e678a-155">下列是寄不出的信件佇列服務組態檔的程式碼。</span><span class="sxs-lookup"><span data-stu-id="e678a-155">The following is code for the dead-letter queue service configuration file.</span></span>  

## <a name="see-also"></a><span data-ttu-id="e678a-156">請參閱</span><span class="sxs-lookup"><span data-stu-id="e678a-156">See also</span></span>

- [<span data-ttu-id="e678a-157">佇列概觀</span><span class="sxs-lookup"><span data-stu-id="e678a-157">Queues Overview</span></span>](queues-overview.md)
- [<span data-ttu-id="e678a-158">HOW TO：與 WCF 端點交換佇列訊息</span><span class="sxs-lookup"><span data-stu-id="e678a-158">How to: Exchange Queued Messages with WCF Endpoints</span></span>](how-to-exchange-queued-messages-with-wcf-endpoints.md)
- [<span data-ttu-id="e678a-159">有害訊息處理</span><span class="sxs-lookup"><span data-stu-id="e678a-159">Poison Message Handling</span></span>](poison-message-handling.md)
