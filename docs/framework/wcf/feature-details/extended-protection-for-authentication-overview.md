---
title: 驗證的延伸保護概觀
ms.date: 03/30/2017
ms.assetid: 3d2ceffe-a7bf-4bd9-a5a2-9406423bd7f8
ms.openlocfilehash: fdc42228077bbc703e2e7557c8d7fdb3ff57a150
ms.sourcegitcommit: 27a15a55019f6b5f2733961738babe94aec0def3
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 09/15/2020
ms.locfileid: "90559261"
---
# <a name="extended-protection-for-authentication-overview"></a><span data-ttu-id="3386d-102">驗證的延伸保護概觀</span><span class="sxs-lookup"><span data-stu-id="3386d-102">Extended Protection for Authentication Overview</span></span>
<span data-ttu-id="3386d-103">驗證的延伸保護有助於防範中間人 (MITM) 攻擊，以免用戶端的認證遭攻擊者攔截後再轉送至伺服器。</span><span class="sxs-lookup"><span data-stu-id="3386d-103">Extended Protection for Authentication helps protect against man-in-the-middle (MITM) attacks, in which an attacker intercepts a client’s credentials and forwards them to a server.</span></span>  
  
 <span data-ttu-id="3386d-104">試想此一涉及三方的案例：用戶端、伺服器和攻擊者。</span><span class="sxs-lookup"><span data-stu-id="3386d-104">Consider a scenario with three participants: a client, server, and attacker.</span></span> <span data-ttu-id="3386d-105">伺服器的 URL 為 `https://server`，而攻擊者的 URL 為 `https://attacker`。</span><span class="sxs-lookup"><span data-stu-id="3386d-105">The server has the URL `https://server`, whereas the attacker has the URL `https://attacker`.</span></span> <span data-ttu-id="3386d-106">攻擊者計誘用戶端誤以為存取了伺服器，但其實是進入攻擊者網站。</span><span class="sxs-lookup"><span data-stu-id="3386d-106">The attacker tricks the client into accessing the attacker as if it were the server.</span></span> <span data-ttu-id="3386d-107">接著攻擊者傳送要求至伺服器。</span><span class="sxs-lookup"><span data-stu-id="3386d-107">The attacker then sends a request to the server.</span></span> <span data-ttu-id="3386d-108">如果攻擊者試圖存取受保護的資源，伺服器將以 WWW-Authenticate 標頭回覆予攻擊者。</span><span class="sxs-lookup"><span data-stu-id="3386d-108">If the attacker is trying to access a secure resource, the server replies to the attacker with a WWW-Authenticate header.</span></span> <span data-ttu-id="3386d-109">由於攻擊者沒有驗證資訊，便將 WWW-Authenticate 標頭傳送給用戶端。</span><span class="sxs-lookup"><span data-stu-id="3386d-109">The attacker does not have the authentication information, so it sends the WWW-Authenticate header on to the client.</span></span> <span data-ttu-id="3386d-110">用戶端隨即傳送 Authorization 標頭給攻擊者，而攻擊者再將此標頭傳送至伺服器，致使其得以利用用戶端的認證存取受保護的資源。</span><span class="sxs-lookup"><span data-stu-id="3386d-110">The client sends the Authorization header to the attacker, and the attacker sends the header on to the server and gets access to the secure resources using the client’s credentials.</span></span>  
  
 <span data-ttu-id="3386d-111">就目前而言，當用戶端應用程式使用 Kerberos、Digest 或 NTLM 透過 HTTPS 向伺服器驗證自身時，首先會建立傳輸層安全性 (TLS) 通道，並且使用此通道進行驗證。</span><span class="sxs-lookup"><span data-stu-id="3386d-111">Currently, when a client application authenticates itself to the server using Kerberos, Digest, or NTLM using HTTPS, a Transport Level Security (TLS) channel is first established and authentication takes place using this channel.</span></span> <span data-ttu-id="3386d-112">但是，安全通訊端層 (SSL) 所產生的工作階段金鑰與驗證期間產生的工作階段金鑰之間並無任何繫結。</span><span class="sxs-lookup"><span data-stu-id="3386d-112">However, there is no binding between the session key generated by Secure Sockets Layer (SSL) and the session key that is generated during authentication.</span></span> <span data-ttu-id="3386d-113">因此在前述案例中，若通訊是透過 TLS (例如 HTTPS 通道) 進行，則所建立的 SSL 通道會有兩個：其一位於用戶端和攻擊者之間，其二位於攻擊者和伺服器之間。</span><span class="sxs-lookup"><span data-stu-id="3386d-113">So, in the previous scenario, if the communication takes places over a TLS (such as an HTTPS channel), there are two SSL channels created: one between the client and the attacker, and another between the attacker and the server.</span></span> <span data-ttu-id="3386d-114">用戶端的認證從用戶端傳送至伺服器時，會先經過用戶端和攻擊者之間的 SSL 通道，再經過攻擊者和伺服器之間的通道。</span><span class="sxs-lookup"><span data-stu-id="3386d-114">The client’s credentials are sent from the client to the server first over the SSL channel between the client and the attacker and then over the channel between the attacker and the server.</span></span> <span data-ttu-id="3386d-115">一旦用戶端的認證送達伺服器，伺服器隨即驗證其認證，卻未偵測送出這些認證的通道竟是來自攻擊者而非用戶端。</span><span class="sxs-lookup"><span data-stu-id="3386d-115">Once the client’s credentials reach the server, the server verifies the credentials without detecting that the channel over which those credentials were sent originated with the attacker and not the client.</span></span>  
  
 <span data-ttu-id="3386d-116">其解決方法是使用受 TLS 保護的外部通道，加上用戶端驗證型內部通道，並且將通道繫結權杖 (CBT) 傳遞至伺服器。</span><span class="sxs-lookup"><span data-stu-id="3386d-116">The solution is to use a TLS-secured outer channel and a client-authenticated inner channel, and to pass a Channel Binding Token (CBT) to the server.</span></span> <span data-ttu-id="3386d-117">CBT 為受 TLS 保護的通道之屬性，用於將外部通道繫結至用戶端驗證型內部通道上的對話。</span><span class="sxs-lookup"><span data-stu-id="3386d-117">The CBT is a property of the TLS-secured outer channel, and is used to bind the outer channel to a conversation over the client-authenticated inner channel.</span></span>  
  
 <span data-ttu-id="3386d-118">在前述案例中，用戶端和攻擊者間 TLS 通道的 CBT 將與傳送至伺服器的授權資訊合併。</span><span class="sxs-lookup"><span data-stu-id="3386d-118">In the previous scenario, the CBT of the client-attacker TLS channel is merged with the authorization information that is sent to the server.</span></span> <span data-ttu-id="3386d-119">若伺服器可感知 CBT，便會將用戶端驗證資訊所內含的 CBT (對應於用戶端和攻擊者間的通道) 與附加至攻擊者和伺服器間通道的 CBT 相比較。</span><span class="sxs-lookup"><span data-stu-id="3386d-119">A CBT-aware server compares the CBT contained in the client authentication information, which corresponds to the client-attacker channel, to the CBT attached to the attacker-server channel.</span></span> <span data-ttu-id="3386d-120">CBT 乃是通道的目的端所特有，故而用戶端和攻擊者間的 CBT 與攻擊者和伺服器間的 CBT 不符。</span><span class="sxs-lookup"><span data-stu-id="3386d-120">A CBT is specific to a channel’s destination, so the client-attacker CBT does not match the attacker-server CBT.</span></span> <span data-ttu-id="3386d-121">如此可讓伺服器偵測到 MITM 攻擊並拒絕驗證要求。</span><span class="sxs-lookup"><span data-stu-id="3386d-121">This lets the server detect the MITM attack and refuse the authentication request.</span></span>  
  
 <span data-ttu-id="3386d-122">用戶端不需要任何組態設定。</span><span class="sxs-lookup"><span data-stu-id="3386d-122">The client side does not require any configuration setting.</span></span> <span data-ttu-id="3386d-123">若用戶端已更新為會傳遞 CBT 至伺服器，往後都將一律這麼做。</span><span class="sxs-lookup"><span data-stu-id="3386d-123">Once the client has been updated to pass the CBT to the server, it always does so.</span></span> <span data-ttu-id="3386d-124">如果伺服器也已更新，即可設定為使用 CBT 或者予以忽略。</span><span class="sxs-lookup"><span data-stu-id="3386d-124">If the server has also been updated, it can be configured to use the CBT or ignore it.</span></span> <span data-ttu-id="3386d-125">伺服器只要未更新，就會忽略此權仗。</span><span class="sxs-lookup"><span data-stu-id="3386d-125">If it has not been updated, it ignores it.</span></span>  
  
 <span data-ttu-id="3386d-126">伺服器可以具備下列保護層級：</span><span class="sxs-lookup"><span data-stu-id="3386d-126">The server can have the following levels of protection:</span></span>  
  
- <span data-ttu-id="3386d-127">無。</span><span class="sxs-lookup"><span data-stu-id="3386d-127">None.</span></span> <span data-ttu-id="3386d-128">未執行通道繫結程序驗證。</span><span class="sxs-lookup"><span data-stu-id="3386d-128">No channel binding validation is performed.</span></span> <span data-ttu-id="3386d-129">此乃所有未更新之伺服器的行為。</span><span class="sxs-lookup"><span data-stu-id="3386d-129">This is the behavior of all servers that have not been updated.</span></span>  
  
- <span data-ttu-id="3386d-130">部分。</span><span class="sxs-lookup"><span data-stu-id="3386d-130">Partial.</span></span> <span data-ttu-id="3386d-131">所有已更新的用戶端都必須向伺服器提供通道繫結資訊。</span><span class="sxs-lookup"><span data-stu-id="3386d-131">All clients that have been updated must provide channel binding information to the server.</span></span> <span data-ttu-id="3386d-132">尚未更新的用戶端則沒有這個必要。</span><span class="sxs-lookup"><span data-stu-id="3386d-132">Clients that have not been updated do not have to do so.</span></span> <span data-ttu-id="3386d-133">此乃顧及應用程式相容性的中繼選項。</span><span class="sxs-lookup"><span data-stu-id="3386d-133">This is an intermediate option that allows for application compatibility.</span></span>  
  
- <span data-ttu-id="3386d-134">完整。</span><span class="sxs-lookup"><span data-stu-id="3386d-134">Full.</span></span> <span data-ttu-id="3386d-135">所有用戶端都必須提供通道繫結資訊。</span><span class="sxs-lookup"><span data-stu-id="3386d-135">All clients must provide channel binding information.</span></span> <span data-ttu-id="3386d-136">用戶端若未提供此資訊，伺服器會拒絕其驗證要求。</span><span class="sxs-lookup"><span data-stu-id="3386d-136">The server rejects authentication requests from clients that do not do so.</span></span>  
  
 <span data-ttu-id="3386d-137">如需詳細資訊，請參閱「Win7 CBT/延伸保護」範例。</span><span class="sxs-lookup"><span data-stu-id="3386d-137">For more information, see the Win7 CBT/Extended Protection sample.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="3386d-138">另請參閱</span><span class="sxs-lookup"><span data-stu-id="3386d-138">See also</span></span>

- <span data-ttu-id="3386d-139">[Windows Server AppFabric 的資訊安全模型](/previous-versions/appfabric/ee677202(v=azure.10))</span><span class="sxs-lookup"><span data-stu-id="3386d-139">[Security Model for Windows Server App Fabric](/previous-versions/appfabric/ee677202(v=azure.10))</span></span>
