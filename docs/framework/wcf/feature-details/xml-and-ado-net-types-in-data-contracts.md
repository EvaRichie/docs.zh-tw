---
title: 資料合約中的 XML 與 ADO.NET 型別
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: c2ce8461-3c15-4c41-8c81-1cb78f5b59a6
ms.openlocfilehash: d4ac956af0addf9c3b38f3bfb8e8644757dc81c3
ms.sourcegitcommit: bc293b14af795e0e999e3304dd40c0222cf2ffe4
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 11/26/2020
ms.locfileid: "96238305"
---
# <a name="xml-and-adonet-types-in-data-contracts"></a><span data-ttu-id="65dfb-102">資料合約中的 XML 與 ADO.NET 型別</span><span class="sxs-lookup"><span data-stu-id="65dfb-102">XML and ADO.NET Types in Data Contracts</span></span>

<span data-ttu-id="65dfb-103">Windows Communication Foundation (WCF) 資料合約模型支援直接代表 XML 的特定類型。</span><span class="sxs-lookup"><span data-stu-id="65dfb-103">The Windows Communication Foundation (WCF) data contract model supports certain types that represent XML directly.</span></span> <span data-ttu-id="65dfb-104">當這些型別序列化為 XML 時，序列化程式會寫出這些型別的 XML 內容，而不做更進一步的處理。</span><span class="sxs-lookup"><span data-stu-id="65dfb-104">When these types are serialized to XML, the serializer writes out the XML contents of these types without any further processing.</span></span> <span data-ttu-id="65dfb-105">支援的型別為 <xref:System.Xml.XmlElement>、<xref:System.Xml.XmlNode> 的陣列 (但不是 `XmlNode` 型別本身) 以及實作 <xref:System.Xml.Serialization.IXmlSerializable> 的型別。</span><span class="sxs-lookup"><span data-stu-id="65dfb-105">Supported types are <xref:System.Xml.XmlElement>, arrays of <xref:System.Xml.XmlNode> (but not the `XmlNode` type itself), as well as types that implement <xref:System.Xml.Serialization.IXmlSerializable>.</span></span> <span data-ttu-id="65dfb-106"><xref:System.Data.DataSet> 和 <xref:System.Data.DataTable> 型別以及具型別資料集都常用於資料庫程式撰寫中。</span><span class="sxs-lookup"><span data-stu-id="65dfb-106">The <xref:System.Data.DataSet> and <xref:System.Data.DataTable> type, as well as typed datasets, are commonly used in database programming.</span></span> <span data-ttu-id="65dfb-107">這些型別會實作 `IXmlSerializable` 介面，因此在資料合約模型中是可序列化的。</span><span class="sxs-lookup"><span data-stu-id="65dfb-107">These types implement the `IXmlSerializable` interface and are therefore serializable in the data contract model.</span></span> <span data-ttu-id="65dfb-108">在本主題最後，會列出這些型別的一些特別考量。</span><span class="sxs-lookup"><span data-stu-id="65dfb-108">Some special considerations for these types are listed at the end of this topic.</span></span>  
  
## <a name="xml-types"></a><span data-ttu-id="65dfb-109">XML 型別</span><span class="sxs-lookup"><span data-stu-id="65dfb-109">XML Types</span></span>  
  
### <a name="xml-element"></a><span data-ttu-id="65dfb-110">Xml 項目</span><span class="sxs-lookup"><span data-stu-id="65dfb-110">Xml Element</span></span>  

 <span data-ttu-id="65dfb-111">`XmlElement` 型別是使用它的 XML 內容來序列化。</span><span class="sxs-lookup"><span data-stu-id="65dfb-111">The `XmlElement` type is serialized using its XML contents.</span></span> <span data-ttu-id="65dfb-112">以下列型別為例。</span><span class="sxs-lookup"><span data-stu-id="65dfb-112">For example, using the following type.</span></span>  
  
 [!code-csharp[DataContractAttribute#4](../../../../samples/snippets/csharp/VS_Snippets_CFX/datacontractattribute/cs/overview.cs#4)]
 [!code-vb[DataContractAttribute#4](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/datacontractattribute/vb/overview.vb#4)]  
  
 <span data-ttu-id="65dfb-113">這會序列化為 XML，如下所示：</span><span class="sxs-lookup"><span data-stu-id="65dfb-113">This is serialized to XML as follows:</span></span>  
  
```xml  
<MyDataContract xmlns="http://schemas.contoso.com">  
    <myDataMember>  
        <myElement xmlns="" myAttribute="myValue">  
            myContents  
        </myElement>  
    </myDataMember>  
</MyDataContract>  
```  
  
 <span data-ttu-id="65dfb-114">請注意，包裝函式資料成員項目 `<myDataMember>` 仍然存在。</span><span class="sxs-lookup"><span data-stu-id="65dfb-114">Notice that a wrapper data member element `<myDataMember>` is still present.</span></span> <span data-ttu-id="65dfb-115">不能在資料合約模型中移除這個項目。</span><span class="sxs-lookup"><span data-stu-id="65dfb-115">There is no way of removing this element in the data contract model.</span></span> <span data-ttu-id="65dfb-116">處理這個模型 (<xref:System.Runtime.Serialization.DataContractSerializer> 和 <xref:System.Runtime.Serialization.NetDataContractSerializer>) 的序列化程式可能會發出特別的屬性到這個包裝函式項目內。</span><span class="sxs-lookup"><span data-stu-id="65dfb-116">The serializers that handle this model (the <xref:System.Runtime.Serialization.DataContractSerializer> and <xref:System.Runtime.Serialization.NetDataContractSerializer>) may emit special attributes into this wrapper element.</span></span> <span data-ttu-id="65dfb-117">這些屬性包括標準的 XML Schema Instance "nil" 屬性 (允許 `XmlElement` 成為 `null`) 和 "type" 屬性 (允許多型使用 `XmlElement`)。</span><span class="sxs-lookup"><span data-stu-id="65dfb-117">These attributes include the standard XML Schema Instance "nil" attribute (allowing the `XmlElement` to be `null`) and the "type" attribute (allowing `XmlElement` to be used polymorphically).</span></span> <span data-ttu-id="65dfb-118">此外，下列 XML 屬性是 WCF 專用的： "Id"、"Ref"、"Type" 和 "Assembly"。</span><span class="sxs-lookup"><span data-stu-id="65dfb-118">Also, the following XML attributes are specific to WCF: "Id", "Ref", "Type" and "Assembly".</span></span> <span data-ttu-id="65dfb-119">這些屬性可發出以支援使用 `XmlElement` 搭配已啟用的物件圖形保留模式，或使用 <xref:System.Runtime.Serialization.NetDataContractSerializer></span><span class="sxs-lookup"><span data-stu-id="65dfb-119">These attributes may be emitted to support using the `XmlElement` with the object graph preservation mode enabled, or with the <xref:System.Runtime.Serialization.NetDataContractSerializer>.</span></span> <span data-ttu-id="65dfb-120"> (如需物件圖形保留模式的詳細資訊，請參閱 [序列化和還原序列化](serialization-and-deserialization.md)。 ) </span><span class="sxs-lookup"><span data-stu-id="65dfb-120">(For more information about the object graph preservation mode, see [Serialization and Deserialization](serialization-and-deserialization.md).)</span></span>  
  
 <span data-ttu-id="65dfb-121">`XmlElement` 的陣列或集合是被允許的，且處理方式和其他任何的陣列或集合相同。</span><span class="sxs-lookup"><span data-stu-id="65dfb-121">Arrays or collections of `XmlElement` are allowed and are handled as any other array or collection.</span></span> <span data-ttu-id="65dfb-122">也就是說，整個集合將會有包裝函式項目，而陣列中的各個 `<myDataMember>` 則會有不同的包裝函式項目 (與上例中的 `XmlElement` 類似)。</span><span class="sxs-lookup"><span data-stu-id="65dfb-122">That is, there is a wrapper element for the entire collection, and a separate wrapper element (similar to `<myDataMember>` in the preceding example) for each `XmlElement` in the array.</span></span>  
  
 <span data-ttu-id="65dfb-123">在還原序列化時，還原序列化程式會從傳入的 XML 建立 `XmlElement`。</span><span class="sxs-lookup"><span data-stu-id="65dfb-123">On deserialization, an `XmlElement` is created by the deserializer from the incoming XML.</span></span> <span data-ttu-id="65dfb-124">還原序列化程式會提供有效的父 <xref:System.Xml.XmlDocument>。</span><span class="sxs-lookup"><span data-stu-id="65dfb-124">A valid parent <xref:System.Xml.XmlDocument> is provided by the deserializer.</span></span>  
  
 <span data-ttu-id="65dfb-125">請確定要還原序列化為 `XmlElement` 的 XML 片段會定義所使用的所有前置詞，並且不會依賴任何來自祖系項目的前置詞定義。</span><span class="sxs-lookup"><span data-stu-id="65dfb-125">Make sure that the XML fragment that is deserialized to an `XmlElement` defines all prefixes that it uses and does not rely on any prefix definitions from ancestor elements.</span></span> <span data-ttu-id="65dfb-126">只有在使用 `DataContractSerializer` 從不同的 (非 `DataContractSerializer`) 來源存取 XML 時，這才是問題。</span><span class="sxs-lookup"><span data-stu-id="65dfb-126">This is a concern only when using the `DataContractSerializer` to access XML from a different (non-`DataContractSerializer`) source.</span></span>  
  
 <span data-ttu-id="65dfb-127">搭配使用時 `DataContractSerializer` ， `XmlElement` 可能會被指派多型，但只能指派給類型的資料成員 <xref:System.Object> 。</span><span class="sxs-lookup"><span data-stu-id="65dfb-127">When used with the `DataContractSerializer`, the `XmlElement` may be assigned polymorphically, but only to a data member of type <xref:System.Object>.</span></span> <span data-ttu-id="65dfb-128">即使實作 <xref:System.Collections.IEnumerable>，`XmlElement` 仍然無法用來做為集合型別，且無法指派給 <xref:System.Collections.IEnumerable> 資料成員。</span><span class="sxs-lookup"><span data-stu-id="65dfb-128">Even though it implements <xref:System.Collections.IEnumerable>, an `XmlElement` cannot be used as a collection type and cannot be assigned to an <xref:System.Collections.IEnumerable> data member.</span></span> <span data-ttu-id="65dfb-129">如同所有的多型指派， `DataContractSerializer` 會在產生的 XML 中發出資料合約名稱–在此情況下，它會在 "" 命名空間中「XmlElement」 http://schemas.datacontract.org/2004/07/System.Xml 。</span><span class="sxs-lookup"><span data-stu-id="65dfb-129">As with all polymorphic assignments, the `DataContractSerializer` emits the data contract name in the resulting XML – in this case, it is "XmlElement" in the "http://schemas.datacontract.org/2004/07/System.Xml" namespace.</span></span>  
  
 <span data-ttu-id="65dfb-130">使用 `NetDataContractSerializer`，會支援 `XmlElement` 之任何有效的多型指派 (至 `Object` 或 `IEnumerable`)。</span><span class="sxs-lookup"><span data-stu-id="65dfb-130">With the `NetDataContractSerializer`, any valid polymorphic assignment of `XmlElement` (to `Object` or `IEnumerable`) is supported.</span></span>  
  
 <span data-ttu-id="65dfb-131">請勿嘗試使用序列化程式與從 `XmlElement` 衍生的型別，不論是否為多型指派。</span><span class="sxs-lookup"><span data-stu-id="65dfb-131">Do not attempt to use either of the serializers with types derived from `XmlElement`, whether they are assigned polymorphically or not.</span></span>  
  
### <a name="array-of-xmlnode"></a><span data-ttu-id="65dfb-132">XmlNode 的陣列</span><span class="sxs-lookup"><span data-stu-id="65dfb-132">Array of XmlNode</span></span>  

 <span data-ttu-id="65dfb-133">使用 <xref:System.Xml.XmlNode> 的陣列與使用 `XmlElement` 十分類似。</span><span class="sxs-lookup"><span data-stu-id="65dfb-133">Using arrays of <xref:System.Xml.XmlNode> is very similar to using `XmlElement`.</span></span> <span data-ttu-id="65dfb-134">使用 `XmlNode` 的陣列比使用 `XmlElement` 更有彈性。</span><span class="sxs-lookup"><span data-stu-id="65dfb-134">Using arrays of `XmlNode` gives you more flexibility than using `XmlElement`.</span></span> <span data-ttu-id="65dfb-135">您可以在資料成員包裝項目內撰寫多個項目。</span><span class="sxs-lookup"><span data-stu-id="65dfb-135">You can write multiple elements inside the data member wrapping element.</span></span> <span data-ttu-id="65dfb-136">您也可以將項目以外的內容插入資料成員包裝項目內，例如 XML 註解。</span><span class="sxs-lookup"><span data-stu-id="65dfb-136">You can also inject content other than elements inside of the data member wrapping element, such as XML comments.</span></span> <span data-ttu-id="65dfb-137">最後，您可以將屬性置入包裝資料成員項目內。</span><span class="sxs-lookup"><span data-stu-id="65dfb-137">Finally, you can put attributes into the wrapping data member element.</span></span> <span data-ttu-id="65dfb-138">這些都可以藉由將 `XmlNode` 的特定衍生類別 (例如 `XmlNode`、<xref:System.Xml.XmlAttribute> 或 `XmlElement`) 填入 <xref:System.Xml.XmlComment> 的陣列來達成。</span><span class="sxs-lookup"><span data-stu-id="65dfb-138">All this can be achieved by populating the array of `XmlNode` with specific derived classes of `XmlNode` such as <xref:System.Xml.XmlAttribute>, `XmlElement` or <xref:System.Xml.XmlComment>.</span></span> <span data-ttu-id="65dfb-139">以下列型別為例。</span><span class="sxs-lookup"><span data-stu-id="65dfb-139">For example, using the following type.</span></span>  
  
 [!code-csharp[DataContractAttribute#5](../../../../samples/snippets/csharp/VS_Snippets_CFX/datacontractattribute/cs/overview.cs#5)]
 [!code-vb[DataContractAttribute#5](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/datacontractattribute/vb/overview.vb#5)]  
  
 <span data-ttu-id="65dfb-140">當序列化時，結果 XML 將會類似下列程式碼。</span><span class="sxs-lookup"><span data-stu-id="65dfb-140">When serialized, the resulting XML is similar to the following code.</span></span>  
  
```xml  
<MyDataContract xmlns="http://schemas.contoso.com">  
  <myDataMember myAttribute="myValue">  
     <!--myComment-->  
     <myElement xmlns="" myAttribute="myValue">  
 myContents  
     </myElement>  
     <myElement xmlns="" myAttribute="myValue">  
       myContents  
     </myElement>  
  </myDataMember>  
</MyDataContract>  
```  
  
 <span data-ttu-id="65dfb-141">請注意，資料成員包裝函式項目 `<myDataMember>` 包含一個屬性、一個註解和兩個項目。</span><span class="sxs-lookup"><span data-stu-id="65dfb-141">Note that the data member wrapper element `<myDataMember>` contains an attribute, a comment, and two elements.</span></span> <span data-ttu-id="65dfb-142">有四個已序列化的 `XmlNode` 執行個體。</span><span class="sxs-lookup"><span data-stu-id="65dfb-142">These are the four `XmlNode` instances that were serialized.</span></span>  
  
 <span data-ttu-id="65dfb-143">無法序列化會造成無效 XML 的 `XmlNode` 陣列。</span><span class="sxs-lookup"><span data-stu-id="65dfb-143">An array of `XmlNode` that results in invalid XML cannot be serialized.</span></span> <span data-ttu-id="65dfb-144">例如，兩個 `XmlNode` 執行個體的陣列 (其中第一個是 `XmlElement` 而第二個是 <xref:System.Xml.XmlAttribute>) 是無效的，因為這個序列沒有對應至任何有效的 XML 執行個體 (沒有位置可附加此屬性)。</span><span class="sxs-lookup"><span data-stu-id="65dfb-144">For example, an array of two `XmlNode` instances where the first one is an `XmlElement` and the second one is an <xref:System.Xml.XmlAttribute> is invalid, because this sequence does not correspond to any valid XML instance (there is no place to attach the attribute to).</span></span>  
  
 <span data-ttu-id="65dfb-145">在還原序列化 `XmlNode` 的陣列時，會建立節點並填入來自傳入的 XML 的資訊。</span><span class="sxs-lookup"><span data-stu-id="65dfb-145">On deserialization of an array of `XmlNode`, nodes are created and populated with information from the incoming XML.</span></span> <span data-ttu-id="65dfb-146">還原序列化程式會提供有效的父 <xref:System.Xml.XmlDocument>。</span><span class="sxs-lookup"><span data-stu-id="65dfb-146">A valid parent <xref:System.Xml.XmlDocument> is provided by the deserializer.</span></span> <span data-ttu-id="65dfb-147">所有節點都會還原序列化，包括包裝函式資料成員專案上的任何屬性，但不包括 WCF 序列化程式所放置的屬性 (例如用來指出多型指派) 的屬性。</span><span class="sxs-lookup"><span data-stu-id="65dfb-147">All nodes are deserialized, including any attributes on the wrapper data member element, but excluding the attributes placed there by the WCF serializers (such as the attributes used to indicate polymorphic assignment).</span></span> <span data-ttu-id="65dfb-148">有關定義 XML 片段中所有命名空間前置詞的警告適用於 `XmlNode` 陣列的還原序列化，就像還原序列化 `XmlElement` 一樣。</span><span class="sxs-lookup"><span data-stu-id="65dfb-148">The caveat about defining all namespace prefixes in the XML fragment applies to the deserialization of arrays of `XmlNode` just like it does to deserializing `XmlElement`.</span></span>  
  
 <span data-ttu-id="65dfb-149">當使用序列化程式並開啟物件圖形保留時，物件相等性只會保留在 `XmlNode` 陣列的層級，而不是個別 `XmlNode` 執行個體的層級。</span><span class="sxs-lookup"><span data-stu-id="65dfb-149">When using the serializers with object graph preservation turned on, object equality is only preserved on the level of `XmlNode` arrays, not individual `XmlNode` instances.</span></span>  
  
 <span data-ttu-id="65dfb-150">請勿嘗試序列化有一或多個節點設定為 `XmlNode` 之 `null` 的陣列。</span><span class="sxs-lookup"><span data-stu-id="65dfb-150">Do not attempt to serialize an array of `XmlNode` where one or more of the nodes is set to `null`.</span></span> <span data-ttu-id="65dfb-151">允許整個陣列成員為 `null`，但陣列中包含的個別 `XmlNode` 則不允許。</span><span class="sxs-lookup"><span data-stu-id="65dfb-151">It is permitted for the entire array member to be `null`, but not for any individual `XmlNode` contained in the array.</span></span> <span data-ttu-id="65dfb-152">如果整個陣列成員為 null，包裝函式資料成員項目便會包含特別的屬性，指出它為 null。</span><span class="sxs-lookup"><span data-stu-id="65dfb-152">If the entire array member is null, the wrapper data member element contains a special attribute that indicates that it is null.</span></span> <span data-ttu-id="65dfb-153">在還原序列化時，整個陣列成員也會變成 null。</span><span class="sxs-lookup"><span data-stu-id="65dfb-153">On deserialization, the entire array member also becomes null.</span></span>  
  
 <span data-ttu-id="65dfb-154">序列化程式只會特別處理 `XmlNode` 的一般陣列。</span><span class="sxs-lookup"><span data-stu-id="65dfb-154">Only regular arrays of `XmlNode` are treated specially by the serializer.</span></span> <span data-ttu-id="65dfb-155">宣告為包含 `XmlNode` 之其他集合型別的資料成員，或宣告為衍生自 `XmlNode` 之型別陣列的資料成員都不會受到特別的處理。</span><span class="sxs-lookup"><span data-stu-id="65dfb-155">Data members declared as other collection types that contain `XmlNode`, or data members declared as arrays of types derived from `XmlNode`, are not treated specially.</span></span> <span data-ttu-id="65dfb-156">因此，它們通常是不可序列化的，除非它們也符合其他的序列化能力準則之一。</span><span class="sxs-lookup"><span data-stu-id="65dfb-156">Thus, they are normally not serializable unless they also meet one of the other criteria for serializing.</span></span>  
  
 <span data-ttu-id="65dfb-157">`XmlNode` 的陣列或陣列集合是被允許的。</span><span class="sxs-lookup"><span data-stu-id="65dfb-157">Arrays or collections of arrays of `XmlNode` are allowed.</span></span> <span data-ttu-id="65dfb-158">整個集合會有包裝函式項目，而在外部陣列或集合中 `<myDataMember>` 之每個陣列則會有不同的包裝函式項目 (與上例中 `XmlNode` 類似)。</span><span class="sxs-lookup"><span data-stu-id="65dfb-158">There is a wrapper element for the entire collection, and a separate wrapper element (similar to `<myDataMember>` in the preceding example) for each array of `XmlNode` in the outer array or collection.</span></span>  
  
 <span data-ttu-id="65dfb-159">以 <xref:System.Array> 執行個體填入 `Object` 之型別 `Array` 的資料成員或 `IEnumerable` 的 `XmlNode` 不會造成資料成員被視為 `Array` 執行個體的 `XmlNode`。</span><span class="sxs-lookup"><span data-stu-id="65dfb-159">Populating a data member of type <xref:System.Array> of `Object` or `Array` of `IEnumerable` with `XmlNode` instances does not result in the data member being treated as an `Array` of `XmlNode` instances.</span></span> <span data-ttu-id="65dfb-160">每個陣列成員都會分開進行序列化。</span><span class="sxs-lookup"><span data-stu-id="65dfb-160">Each array member is serialized separately.</span></span>  
  
 <span data-ttu-id="65dfb-161">當搭配 `DataContractSerializer` 使用時，可能會多型指派 `XmlNode` 的陣列，但只有對型別 `Object` 的資料成員。</span><span class="sxs-lookup"><span data-stu-id="65dfb-161">When used with the `DataContractSerializer`, arrays of `XmlNode` can be assigned polymorphically, but only to a data member of type `Object`.</span></span> <span data-ttu-id="65dfb-162">即使實作 `IEnumerable`，`XmlNode` 的陣列仍然無法用來做為集合型別，並指派給 `IEnumerable` 資料成員。</span><span class="sxs-lookup"><span data-stu-id="65dfb-162">Even though it implements `IEnumerable`, an array of `XmlNode` cannot be used as a collection type and be assigned to an `IEnumerable` data member.</span></span> <span data-ttu-id="65dfb-163">如同所有的多型指派， `DataContractSerializer` 會在產生的 XML 中發出資料合約名稱–在此案例中，它在 "" 命名空間中是 "ArrayOfXmlNode" http://schemas.datacontract.org/2004/07/System.Xml 。</span><span class="sxs-lookup"><span data-stu-id="65dfb-163">As with all polymorphic assignments, the `DataContractSerializer` emits the data contract name in the resulting XML – in this case, it is "ArrayOfXmlNode" in the "http://schemas.datacontract.org/2004/07/System.Xml" namespace.</span></span> <span data-ttu-id="65dfb-164">搭配使用時 `NetDataContractSerializer` ，支援任何有效的陣列指派 `XmlNode` 。</span><span class="sxs-lookup"><span data-stu-id="65dfb-164">When used with the `NetDataContractSerializer`, any valid assignment of an `XmlNode` array is supported.</span></span>  
  
### <a name="schema-considerations"></a><span data-ttu-id="65dfb-165">結構描述的考量</span><span class="sxs-lookup"><span data-stu-id="65dfb-165">Schema Considerations</span></span>  

 <span data-ttu-id="65dfb-166">如需 XML 類型之架構對應的詳細資訊，請參閱 [資料合約架構參考](data-contract-schema-reference.md)。</span><span class="sxs-lookup"><span data-stu-id="65dfb-166">For details about the schema mapping of XML types, see [Data Contract Schema Reference](data-contract-schema-reference.md).</span></span> <span data-ttu-id="65dfb-167">本節將提供重點摘要。</span><span class="sxs-lookup"><span data-stu-id="65dfb-167">This section provides a summary of the important points.</span></span>  
  
 <span data-ttu-id="65dfb-168">型別 `XmlElement` 的資料成員會對應至使用下列匿名型別定義的項目。</span><span class="sxs-lookup"><span data-stu-id="65dfb-168">A data member of type `XmlElement` is mapped to an element defined using the following anonymous type.</span></span>  
  
```xml  
<xsd:complexType>  
   <xsd:sequence>  
      <xsd:any minOccurs="0" processContents="lax" />  
   </xsd:sequence>  
</xsd:complexType>  
```  
  
 <span data-ttu-id="65dfb-169">`XmlNode` 之型別陣列的資料成員會對應至使用下列匿名型別定義的項目。</span><span class="sxs-lookup"><span data-stu-id="65dfb-169">A data member of type Array of `XmlNode` is mapped to an element defined using the following anonymous type.</span></span>  
  
```xml  
<xsd:complexType mixed="true">  
   <xsd:sequence>  
      <xsd:any minOccurs="0" maxOccurs="unbounded" processContents="lax" />  
   </xsd:sequence>  
   <xsd:anyAttribute/>  
</xsd:complexType>  
```  
  
## <a name="types-implementing-the-ixmlserializable-interface"></a><span data-ttu-id="65dfb-170">實作 IXmlSerializable 介面的型別</span><span class="sxs-lookup"><span data-stu-id="65dfb-170">Types Implementing the IXmlSerializable Interface</span></span>  

 <span data-ttu-id="65dfb-171">實作 `IXmlSerializable` 介面的型別完全受到 `DataContractSerializer` 的支援。</span><span class="sxs-lookup"><span data-stu-id="65dfb-171">Types that implement the `IXmlSerializable` interface are fully supported by the `DataContractSerializer`.</span></span> <span data-ttu-id="65dfb-172"><xref:System.Xml.Serialization.XmlSchemaProviderAttribute> 屬性應永遠套用至這些型別，以控制其結構描述。</span><span class="sxs-lookup"><span data-stu-id="65dfb-172">The <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> attribute should always be applied to these types to control their schema.</span></span>  
  
 <span data-ttu-id="65dfb-173">實作 `IXmlSerializable` 的型別有三種：代表任意內容的型別、代表單一項目的型別以及舊版 <xref:System.Data.DataSet> 型別。</span><span class="sxs-lookup"><span data-stu-id="65dfb-173">There are three varieties of types that implement `IXmlSerializable`: types that represent arbitrary content, types that represent a single element, and legacy <xref:System.Data.DataSet> types.</span></span>  
  
- <span data-ttu-id="65dfb-174">內容型別是使用由 `XmlSchemaProviderAttribute` 屬性指定的結構描述提供者方法。</span><span class="sxs-lookup"><span data-stu-id="65dfb-174">Content types use a schema provider method specified by the `XmlSchemaProviderAttribute` attribute.</span></span> <span data-ttu-id="65dfb-175">此方法不會傳回 `null`，而屬性上的 <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> 屬性會留在 `false` 的預設值。</span><span class="sxs-lookup"><span data-stu-id="65dfb-175">The method does not return `null`, and the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> property on the attribute is left at its default value of `false`.</span></span> <span data-ttu-id="65dfb-176">這是 `IXmlSerializable` 型別最常見的使用。</span><span class="sxs-lookup"><span data-stu-id="65dfb-176">This is the most common usage of `IXmlSerializable` types.</span></span>  
  
- <span data-ttu-id="65dfb-177">當 `IXmlSerializable` 型別必須控制自己的根項目名稱時，便會使用項目型別。</span><span class="sxs-lookup"><span data-stu-id="65dfb-177">Element types are used when an `IXmlSerializable` type must control its own root element name.</span></span> <span data-ttu-id="65dfb-178">如果要將型別標示為項目型別，請將 <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> 屬性上的 <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> 屬性設定為 `true`，或從結構描述提供者方法傳回 null。</span><span class="sxs-lookup"><span data-stu-id="65dfb-178">To mark a type as an element type, either set the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> property on the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> attribute to `true` or return null from the schema provider method.</span></span> <span data-ttu-id="65dfb-179">對於項目型別，是否具有結構描述提供者方法是選擇性的 – 您可以在 `XmlSchemaProviderAttribute` 中指定 null 來取代方法名稱。</span><span class="sxs-lookup"><span data-stu-id="65dfb-179">Having a schema provider method is optional for element types – you may specify null instead of the method name in the `XmlSchemaProviderAttribute`.</span></span> <span data-ttu-id="65dfb-180">然而，如果 `IsAny` 是 `true` 並已指定結構描述提供者方法，則此方法必須傳回 null。</span><span class="sxs-lookup"><span data-stu-id="65dfb-180">However, if `IsAny` is `true` and a schema provider method is specified, the method must return null.</span></span>  
  
- <span data-ttu-id="65dfb-181">舊版 <xref:System.Data.DataSet> 型別是沒有以 `IXmlSerializable` 屬性標示的 `XmlSchemaProviderAttribute` 型別。</span><span class="sxs-lookup"><span data-stu-id="65dfb-181">Legacy <xref:System.Data.DataSet> types are `IXmlSerializable` types that are not marked with the `XmlSchemaProviderAttribute` attribute.</span></span> <span data-ttu-id="65dfb-182">相反地，它們是依賴 <xref:System.Xml.Serialization.IXmlSerializable.GetSchema%2A> 方法來產生結構描述。</span><span class="sxs-lookup"><span data-stu-id="65dfb-182">Instead, they rely on the <xref:System.Xml.Serialization.IXmlSerializable.GetSchema%2A> method for schema generation.</span></span> <span data-ttu-id="65dfb-183">在舊版 .NET Framework 中，這個模式是用於 `DataSet` 型別且其具型別的資料集會衍生類別，但這個模式現在已經過時且只為了舊版而支援。</span><span class="sxs-lookup"><span data-stu-id="65dfb-183">This pattern is used for the `DataSet` type and its typed dataset derives a class in earlier versions of the .NET Framework, but is now obsolete and is supported only for legacy reasons.</span></span> <span data-ttu-id="65dfb-184">請勿依賴這個模式，並永遠套用 `XmlSchemaProviderAttribute` 至您的 `IXmlSerializable` 型別。</span><span class="sxs-lookup"><span data-stu-id="65dfb-184">Do not rely on this pattern and always apply the `XmlSchemaProviderAttribute` to your `IXmlSerializable` types.</span></span>  
  
### <a name="ixmlserializable-content-types"></a><span data-ttu-id="65dfb-185">IXmlSerializable 內容型別</span><span class="sxs-lookup"><span data-stu-id="65dfb-185">IXmlSerializable Content Types</span></span>  

 <span data-ttu-id="65dfb-186">當序列化實作 `IXmlSerializable` 且為上述定義的內容型別之型別的資料成員時，序列化程式會撰寫資料成員的包裝函式項目，並將控制項傳遞至 <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="65dfb-186">When serializing a data member of a type that implements `IXmlSerializable` and is a content type as defined previously, the serializer writes the wrapper element for the data member and pass control to the <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> method.</span></span> <span data-ttu-id="65dfb-187"><xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> 實作會撰寫 XML，包括將屬性新增至包裝函式項目。</span><span class="sxs-lookup"><span data-stu-id="65dfb-187">The <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> implementation can write any XML, including adding attributes to the wrapper element.</span></span> <span data-ttu-id="65dfb-188">在 `WriteXml` 完成之後，序列化程式會關閉項目。</span><span class="sxs-lookup"><span data-stu-id="65dfb-188">After `WriteXml` is done, the serializer closes the element.</span></span>  
  
 <span data-ttu-id="65dfb-189">當還原序列化實作 `IXmlSerializable` 且為上述定義的內容型別之型別的資料成員時，還原序列化程式會將 XML 讀取器放在資料成員的包裝函式項目上，並將控制項傳遞至 <xref:System.Xml.Serialization.IXmlSerializable.ReadXml%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="65dfb-189">When deserializing a data member of a type that implements `IXmlSerializable` and is a content type as defined previously, the deserializer positions the XML reader on the wrapper element for the data member and pass control to the <xref:System.Xml.Serialization.IXmlSerializable.ReadXml%2A> method.</span></span> <span data-ttu-id="65dfb-190">此方法必須讀取整個項目，包括開始和結束標記。</span><span class="sxs-lookup"><span data-stu-id="65dfb-190">The method must read the entire element, including the start and end tags.</span></span> <span data-ttu-id="65dfb-191">請確定您的 `ReadXml` 程式碼會處理項目是空白的案例。</span><span class="sxs-lookup"><span data-stu-id="65dfb-191">Make sure your `ReadXml` code handles the case where the element is empty.</span></span> <span data-ttu-id="65dfb-192">此外，您的 `ReadXml` 實作不應依賴以特定的方式為包裝函式項目命名。</span><span class="sxs-lookup"><span data-stu-id="65dfb-192">Additionally, your `ReadXml` implementation should not rely on the wrapper element being named a particular way.</span></span> <span data-ttu-id="65dfb-193">由序列化程式所選擇的名稱可能會有所不同。</span><span class="sxs-lookup"><span data-stu-id="65dfb-193">The name is chosen by the serializer can vary.</span></span>  
  
 <span data-ttu-id="65dfb-194">允許將 `IXmlSerializable` 內容型別多型指派為如型別 <xref:System.Object> 的資料成員。</span><span class="sxs-lookup"><span data-stu-id="65dfb-194">It is permitted to assign `IXmlSerializable` content types polymorphically, for example, to data members of type <xref:System.Object>.</span></span> <span data-ttu-id="65dfb-195">也允許型別執行個體為 null。</span><span class="sxs-lookup"><span data-stu-id="65dfb-195">It is also permitted for the type instances to be null.</span></span> <span data-ttu-id="65dfb-196">最後，可以使用 `IXmlSerializable` 型別並啟用物件圖形保留，以及搭配 <xref:System.Runtime.Serialization.NetDataContractSerializer>。</span><span class="sxs-lookup"><span data-stu-id="65dfb-196">Finally, it is possible to use `IXmlSerializable` types with object graph preservation enabled and with the <xref:System.Runtime.Serialization.NetDataContractSerializer>.</span></span> <span data-ttu-id="65dfb-197">所有這些功能都需要 WCF 序列化程式將特定屬性附加至包裝函式專案中 ( "nil" 和 "type" （在 XML 架構實例命名空間中），並將 WCF 專屬命名空間中的 "Id"、"Ref"、"Type" 和 "Assembly") 。</span><span class="sxs-lookup"><span data-stu-id="65dfb-197">All these features require the WCF serializer to attach certain attributes into the wrapper element ("nil" and "type" in the XML Schema Instance namespace and "Id", "Ref", "Type" and "Assembly" in a WCF-specific namespace).</span></span>  
  
#### <a name="attributes-to-ignore-when-implementing-readxml"></a><span data-ttu-id="65dfb-198">實作 ReadXml 時要忽略的屬性</span><span class="sxs-lookup"><span data-stu-id="65dfb-198">Attributes to Ignore when Implementing ReadXml</span></span>  

 <span data-ttu-id="65dfb-199">在將控制項傳遞至您的 `ReadXml` 程式碼之前，還原序列化程式會檢查 XML 項目、偵測這些特殊的 XML 屬性並進行動作。</span><span class="sxs-lookup"><span data-stu-id="65dfb-199">Before passing control to your `ReadXml` code, the deserializer examines the XML element, detects these special XML attributes, and acts on them.</span></span> <span data-ttu-id="65dfb-200">例如，如果 "nil" 為 `true`，便會還原序列化 null 值並且不會呼叫 `ReadXml`。</span><span class="sxs-lookup"><span data-stu-id="65dfb-200">For example, if "nil" is `true`, a null value is deserialized and `ReadXml` is not called.</span></span> <span data-ttu-id="65dfb-201">如果偵測到多型，則會還原序列化項目的內容，就如同它是不同的型別一樣。</span><span class="sxs-lookup"><span data-stu-id="65dfb-201">If polymorphism is detected, the contents of the element are deserialized as if it was a different type.</span></span> <span data-ttu-id="65dfb-202">會呼叫 `ReadXml` 的多型指派型別的實作。</span><span class="sxs-lookup"><span data-stu-id="65dfb-202">The polymorphically assigned type’s implementation of `ReadXml` is called.</span></span> <span data-ttu-id="65dfb-203">在任何情況下，`ReadXml` 實作都應忽略這些特殊屬性，因為它們是由還原序列化程式所處理的。</span><span class="sxs-lookup"><span data-stu-id="65dfb-203">In any case, a `ReadXml` implementation should ignore these special attributes because they are handled by the deserializer.</span></span>  
  
### <a name="schema-considerations-for-ixmlserializable-content-types"></a><span data-ttu-id="65dfb-204">IXmlSerializable 內容型別的結構描述考量</span><span class="sxs-lookup"><span data-stu-id="65dfb-204">Schema Considerations for IXmlSerializable Content Types</span></span>  

 <span data-ttu-id="65dfb-205">當匯出 `IXmlSerializable` 內容型別的結構描述時，會呼叫結構描述提供者方法。</span><span class="sxs-lookup"><span data-stu-id="65dfb-205">When exporting schema an `IXmlSerializable` content type, the schema provider method is called.</span></span> <span data-ttu-id="65dfb-206"><xref:System.Xml.Schema.XmlSchemaSet> 會傳遞至結構描述提供者方法。</span><span class="sxs-lookup"><span data-stu-id="65dfb-206">An <xref:System.Xml.Schema.XmlSchemaSet> is passed to the schema provider method.</span></span> <span data-ttu-id="65dfb-207">此方法會將有效的結構描述新增至結構描述集。</span><span class="sxs-lookup"><span data-stu-id="65dfb-207">The method can add any valid schema to the schema set.</span></span> <span data-ttu-id="65dfb-208">結構描述集包含在發生結構描述匯出時已知的結構描述。</span><span class="sxs-lookup"><span data-stu-id="65dfb-208">The schema set contains the schema that is already known at the time when schema export occurs.</span></span> <span data-ttu-id="65dfb-209">當結構描述提供者方法必須將項目新增至結構描述集時，必須判斷有適當命名空間的 <xref:System.Xml.Schema.XmlSchema> 是否已經存在於此集中。</span><span class="sxs-lookup"><span data-stu-id="65dfb-209">When the schema provider method must add an item to the schema set, it must determine if an <xref:System.Xml.Schema.XmlSchema> with the appropriate namespace already exists in the set.</span></span> <span data-ttu-id="65dfb-210">如果是，結構描述提供者方法必須將新項目新增至現有的 `XmlSchema`。</span><span class="sxs-lookup"><span data-stu-id="65dfb-210">If it does, the schema provider method must add the new item to the existing `XmlSchema`.</span></span> <span data-ttu-id="65dfb-211">否則，就必須建立新的 `XmlSchema` 執行個體。</span><span class="sxs-lookup"><span data-stu-id="65dfb-211">Otherwise, it must create a new `XmlSchema` instance.</span></span> <span data-ttu-id="65dfb-212">如果是使用 `IXmlSerializable` 型別的陣列，這就很重要。</span><span class="sxs-lookup"><span data-stu-id="65dfb-212">This is important if arrays of `IXmlSerializable` types are being used.</span></span> <span data-ttu-id="65dfb-213">例如，如果您的 `IXmlSerializable` 型別在命名空間 "B" 中匯出為型別 "A"，就有可能在呼叫結構描述提供者方法時，結構描述集已經包含 "B" 的結構描述以保存 "ArrayOfA" 型別。</span><span class="sxs-lookup"><span data-stu-id="65dfb-213">For example, if you have an `IXmlSerializable` type that gets exported as type "A" in namespace "B", it is possible that by the time the schema provider method is called the schema set already contains the schema for "B" to hold the "ArrayOfA" type.</span></span>  
  
 <span data-ttu-id="65dfb-214">除了將型別新增至 <xref:System.Xml.Schema.XmlSchemaSet>，內容型別的結構描述提供者方法還必須傳回非 null 的值。</span><span class="sxs-lookup"><span data-stu-id="65dfb-214">In addition to adding types to the <xref:System.Xml.Schema.XmlSchemaSet>, the schema provider method for content types must return a non-null value.</span></span> <span data-ttu-id="65dfb-215">它會傳回 <xref:System.Xml.XmlQualifiedName>，指定用於指定的 `IXmlSerializable` 型別的結構描述型別的名稱。</span><span class="sxs-lookup"><span data-stu-id="65dfb-215">It can return an <xref:System.Xml.XmlQualifiedName> that specifies the name of the schema type to use for the given `IXmlSerializable` type.</span></span> <span data-ttu-id="65dfb-216">這個限定名稱也會做為型別的資料合約名稱和命名空間。</span><span class="sxs-lookup"><span data-stu-id="65dfb-216">This qualified name also serves as the data contract name and namespace for the type.</span></span> <span data-ttu-id="65dfb-217">當結構描述提供者方法傳回時，允許立即傳回不存在於結構描述集中的型別。</span><span class="sxs-lookup"><span data-stu-id="65dfb-217">It is permitted to return a type that does not exist in the schema set immediately when the schema provider method returns.</span></span> <span data-ttu-id="65dfb-218">然而，預期在匯出所有相關型別時 (在 <xref:System.Runtime.Serialization.XsdDataContractExporter.Export%2A> 上為所有相關型別呼叫 <xref:System.Runtime.Serialization.XsdDataContractExporter> 方法，並存取 <xref:System.Runtime.Serialization.XsdDataContractExporter.Schemas%2A> 屬性)，此型別會存在於結構描述集中。</span><span class="sxs-lookup"><span data-stu-id="65dfb-218">However, it is expected that by the time all related types are exported (the <xref:System.Runtime.Serialization.XsdDataContractExporter.Export%2A> method is called for all relevant types on the <xref:System.Runtime.Serialization.XsdDataContractExporter> and the <xref:System.Runtime.Serialization.XsdDataContractExporter.Schemas%2A> property is accessed), the type exists in the schema set.</span></span> <span data-ttu-id="65dfb-219">在完成所有相關 `Schemas` 呼叫之前存取 `Export` 屬性會造成 <xref:System.Xml.Schema.XmlSchemaException>。</span><span class="sxs-lookup"><span data-stu-id="65dfb-219">Accessing the `Schemas` property before all relevant `Export` calls have been made can result in an <xref:System.Xml.Schema.XmlSchemaException>.</span></span> <span data-ttu-id="65dfb-220">如需匯出流程的詳細資訊，請參閱 [從類別匯出架構](exporting-schemas-from-classes.md)。</span><span class="sxs-lookup"><span data-stu-id="65dfb-220">For more information about the export process, see [Exporting Schemas from Classes](exporting-schemas-from-classes.md).</span></span>  
  
 <span data-ttu-id="65dfb-221">結構描述提供者方法也可能傳回 <xref:System.Xml.Schema.XmlSchemaType> 以使用。</span><span class="sxs-lookup"><span data-stu-id="65dfb-221">The schema provider method can also return the <xref:System.Xml.Schema.XmlSchemaType> to use.</span></span> <span data-ttu-id="65dfb-222">此型別可能是或不是匿名的。</span><span class="sxs-lookup"><span data-stu-id="65dfb-222">The type may or may not be anonymous.</span></span> <span data-ttu-id="65dfb-223">如果是匿名的，每當使用 `IXmlSerializable` 型別做為資料成員時，便會將 `IXmlSerializable` 型別的結構描述匯出為匿名型別。</span><span class="sxs-lookup"><span data-stu-id="65dfb-223">If it is anonymous, the schema for the `IXmlSerializable` type is exported as an anonymous type every time the `IXmlSerializable` type is used as a data member.</span></span> <span data-ttu-id="65dfb-224">`IXmlSerializable` 型別仍然會有資料合約名稱和命名空間。</span><span class="sxs-lookup"><span data-stu-id="65dfb-224">The `IXmlSerializable` type still has a data contract name and namespace.</span></span> <span data-ttu-id="65dfb-225"> (這是以[資料合約名稱](data-contract-names.md)所述的方式來決定，但 <xref:System.Runtime.Serialization.DataContractAttribute> 無法使用屬性來自訂名稱 ) 。如果不是匿名的，則必須是中的其中一個類型。 `XmlSchemaSet`</span><span class="sxs-lookup"><span data-stu-id="65dfb-225">(This is determined as described in [Data Contract Names](data-contract-names.md) except that the <xref:System.Runtime.Serialization.DataContractAttribute> attribute cannot be used to customize the name.) If it is not anonymous, it must be one of the types in the `XmlSchemaSet`.</span></span> <span data-ttu-id="65dfb-226">這種情況等於傳回型別的 `XmlQualifiedName`。</span><span class="sxs-lookup"><span data-stu-id="65dfb-226">This case is equivalent to returning the `XmlQualifiedName` of the type.</span></span>  
  
 <span data-ttu-id="65dfb-227">此外，會匯出型別的全域項目宣告。</span><span class="sxs-lookup"><span data-stu-id="65dfb-227">Additionally, a global element declaration is exported for the type.</span></span> <span data-ttu-id="65dfb-228">如果型別沒有套用 <xref:System.Xml.Serialization.XmlRootAttribute> 屬性，項目會有和資料合約相同的名稱及命名空間，且其 "nillable" 屬性也會為 true。</span><span class="sxs-lookup"><span data-stu-id="65dfb-228">If the type does not have the <xref:System.Xml.Serialization.XmlRootAttribute> attribute applied to it, the element has the same name and namespace as the data contract, and its "nillable" property is true.</span></span> <span data-ttu-id="65dfb-229">唯一的例外是架構命名空間 ( " http://www.w3.org/2001/XMLSchema " ) -如果類型的資料合約是在此命名空間中，對應的全域專案會在空白的命名空間中，因為禁止將新的專案加入至架構命名空間。</span><span class="sxs-lookup"><span data-stu-id="65dfb-229">The only exception to this is the schema namespace ("http://www.w3.org/2001/XMLSchema") – if the type’s data contract is in this namespace, the corresponding global element is in the blank namespace because it is forbidden to add new elements to the schema namespace.</span></span> <span data-ttu-id="65dfb-230">如果型別已套用 `XmlRootAttribute` 屬性 (Attribute)，則會使用下列屬性 (Property) 匯出全域項目宣告：<xref:System.Xml.Serialization.XmlRootAttribute.ElementName%2A>、<xref:System.Xml.Serialization.XmlRootAttribute.Namespace%2A> 和 <xref:System.Xml.Serialization.XmlRootAttribute.IsNullable%2A> 屬性 (Property)。</span><span class="sxs-lookup"><span data-stu-id="65dfb-230">If the type has the `XmlRootAttribute` attribute applied to it, the global element declaration is exported using the following: <xref:System.Xml.Serialization.XmlRootAttribute.ElementName%2A>, <xref:System.Xml.Serialization.XmlRootAttribute.Namespace%2A> and <xref:System.Xml.Serialization.XmlRootAttribute.IsNullable%2A> properties.</span></span> <span data-ttu-id="65dfb-231">套用 `XmlRootAttribute` 的預設值是資料合約名稱、空白命名空間以及為 true 的 "nillable"。</span><span class="sxs-lookup"><span data-stu-id="65dfb-231">The defaults with `XmlRootAttribute` applied are the data contract name, a blank namespace and "nillable" being true.</span></span>  
  
 <span data-ttu-id="65dfb-232">相同的全域項目宣告規則亦適用於舊版資料集型別。</span><span class="sxs-lookup"><span data-stu-id="65dfb-232">The same global element declaration rules apply to legacy dataset types.</span></span> <span data-ttu-id="65dfb-233">請注意，`XmlRootAttribute` 無法覆寫透過自訂程式碼新增的全域項目宣告，不論是使用結構描述提供者方法新增至 `XmlSchemaSet` 或透過舊版資料集型別的 `GetSchema`。</span><span class="sxs-lookup"><span data-stu-id="65dfb-233">Note that the `XmlRootAttribute` cannot override global element declarations added through custom code, either added to the `XmlSchemaSet` using the schema provider method or through `GetSchema` for legacy dataset types.</span></span>  
  
### <a name="ixmlserializable-element-types"></a><span data-ttu-id="65dfb-234">IXmlSerializable 項目型別</span><span class="sxs-lookup"><span data-stu-id="65dfb-234">IXmlSerializable Element Types</span></span>  

 <span data-ttu-id="65dfb-235">`IXmlSerializable` 項目型別會將 `IsAny` 屬性設定為 `true`，或讓其結構描述提供者方法傳回 `null`。</span><span class="sxs-lookup"><span data-stu-id="65dfb-235">`IXmlSerializable` element types have either the `IsAny` property set to `true` or have their schema provider method return `null`.</span></span>  
  
 <span data-ttu-id="65dfb-236">項目型別的序列化及還原序列化和內容型別的序列化及還原序列化十分類似。</span><span class="sxs-lookup"><span data-stu-id="65dfb-236">Serializing and deserializing an element type is very similar to serializing and deserializing a content type.</span></span> <span data-ttu-id="65dfb-237">然而，有一些重要的差異：</span><span class="sxs-lookup"><span data-stu-id="65dfb-237">However, there are some important differences:</span></span>  
  
- <span data-ttu-id="65dfb-238">`WriteXml` 實作預期只撰寫一個項目 (其中當然可包含多個子項目)。</span><span class="sxs-lookup"><span data-stu-id="65dfb-238">The `WriteXml` implementation is expected to write exactly one element (which could of course contain multiple child elements).</span></span> <span data-ttu-id="65dfb-239">它不應在這個單一項目、多個同層項目或混合內容以外撰寫屬性。</span><span class="sxs-lookup"><span data-stu-id="65dfb-239">It should not be writing attributes outside of this single element, multiple sibling elements or mixed content.</span></span> <span data-ttu-id="65dfb-240">此項目可能是空白的。</span><span class="sxs-lookup"><span data-stu-id="65dfb-240">The element may be empty.</span></span>  
  
- <span data-ttu-id="65dfb-241">`ReadXml` 實作不應讀取包裝函式項目。</span><span class="sxs-lookup"><span data-stu-id="65dfb-241">The `ReadXml` implementation should not read the wrapper element.</span></span> <span data-ttu-id="65dfb-242">它預期會讀取 `WriteXml` 所產生的一個項目。</span><span class="sxs-lookup"><span data-stu-id="65dfb-242">It is expected to read the one element that `WriteXml` produces.</span></span>  
  
- <span data-ttu-id="65dfb-243">當定期序列化項目型別時 (例如，做為資料合約中的資料成員)，序列化程式會在呼叫 `WriteXml` 之前輸出包裝函式項目，就像使用內容型別一樣。</span><span class="sxs-lookup"><span data-stu-id="65dfb-243">When serializing an element type regularly (for example, as a data member in a data contract), the serializer outputs a wrapper element before calling `WriteXml`, as with content types.</span></span> <span data-ttu-id="65dfb-244">然而，當在最上層序列化項目型別時，序列化程式通常完全不會輸出包含 `WriteXml` 撰寫之項目的包裝函式項目，除非在 `DataContractSerializer` 或 `NetDataContractSerializer` 建構函式中建構序列化程式時已明確指定根名稱和命名空間。</span><span class="sxs-lookup"><span data-stu-id="65dfb-244">However, when serializing an element type at the top level, the serializer does not normally output a wrapper element at all around the element that `WriteXml` writes, unless a root name and namespace were explicitly specified when constructing the serializer in the `DataContractSerializer` or `NetDataContractSerializer` constructors.</span></span> <span data-ttu-id="65dfb-245">如需詳細資訊，請參閱 [序列化和還原序列化](serialization-and-deserialization.md)。</span><span class="sxs-lookup"><span data-stu-id="65dfb-245">For more information, see [Serialization and Deserialization](serialization-and-deserialization.md).</span></span>  
  
- <span data-ttu-id="65dfb-246">當在最上層序列化項目型別，但在建構期間沒有指定根名稱和命名空間時，<xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A> 和 <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> 基本上不會執行任何動作，而 <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObjectContent%2A> 會呼叫 `WriteXml`。</span><span class="sxs-lookup"><span data-stu-id="65dfb-246">When serializing an element type at the top level without specifying the root name and namespace at construction time, <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A> and <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> essentially does nothing and <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObjectContent%2A> calls `WriteXml`.</span></span> <span data-ttu-id="65dfb-247">在這個模式中，正在序列化的物件不得為 null，且無法多型指派。</span><span class="sxs-lookup"><span data-stu-id="65dfb-247">In this mode, the object being serialized cannot be null and cannot be polymorphically assigned.</span></span> <span data-ttu-id="65dfb-248">另外，物件圖形保留無法啟用，且 `NetDataContractSerializer` 無法使用。</span><span class="sxs-lookup"><span data-stu-id="65dfb-248">Also, object graph preservation cannot enabled and the `NetDataContractSerializer` cannot be used.</span></span>  
  
- <span data-ttu-id="65dfb-249">當在最上層還原序列化元素型別，但在建構期間沒有指定根名稱和命名空間時，如果可以找到任何元素的起始，<xref:System.Runtime.Serialization.XmlObjectSerializer.IsStartObject%2A> 就會傳回 `true`。</span><span class="sxs-lookup"><span data-stu-id="65dfb-249">When deserializing an element type at the top level without specifying the root name and namespace at construction time, <xref:System.Runtime.Serialization.XmlObjectSerializer.IsStartObject%2A> returns `true` if it can find the start of any element.</span></span> <span data-ttu-id="65dfb-250"><xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> 參數設定為 `verifyObjectName` 的 `true` 在實際讀取物件之前，行為方式會和 `IsStartObject` 相同。</span><span class="sxs-lookup"><span data-stu-id="65dfb-250"><xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> with the `verifyObjectName` parameter set to `true` behaves in the same way as `IsStartObject` before actually reading the object.</span></span> <span data-ttu-id="65dfb-251">然後 `ReadObject` 就會將控制項傳遞給 `ReadXml` 方法。</span><span class="sxs-lookup"><span data-stu-id="65dfb-251">`ReadObject` then passes control to `ReadXml` method.</span></span>  
  
 <span data-ttu-id="65dfb-252">項目型別匯出的結構描述和前一節中所述的 `XmlElement` 型別相同，除了結構描述提供者方法可以將其他結構描述新增至 <xref:System.Xml.Schema.XmlSchemaSet>，就像內容型別一樣。</span><span class="sxs-lookup"><span data-stu-id="65dfb-252">The schema exported for element types is the same as for the `XmlElement` type as described in an earlier section, except that the schema provider method can add any additional schema to the <xref:System.Xml.Schema.XmlSchemaSet> as with content types.</span></span> <span data-ttu-id="65dfb-253">不允許使用 `XmlRootAttribute` 屬性搭配項目型別，也永遠不會為這些型別發出全域項目宣告。</span><span class="sxs-lookup"><span data-stu-id="65dfb-253">Using the `XmlRootAttribute` attribute with element types is not allowed, and global element declarations are never emitted for these types.</span></span>  
  
### <a name="differences-from-the-xmlserializer"></a><span data-ttu-id="65dfb-254">與 XmlSerializer 的差異</span><span class="sxs-lookup"><span data-stu-id="65dfb-254">Differences from the XmlSerializer</span></span>  

 <span data-ttu-id="65dfb-255">`IXmlSerializable` 也會辨識 `XmlSchemaProviderAttribute` 介面和 `XmlRootAttribute` 和 <xref:System.Xml.Serialization.XmlSerializer> 屬性。</span><span class="sxs-lookup"><span data-stu-id="65dfb-255">The `IXmlSerializable` interface and the `XmlSchemaProviderAttribute` and `XmlRootAttribute` attributes are also understood by the <xref:System.Xml.Serialization.XmlSerializer> .</span></span> <span data-ttu-id="65dfb-256">然而，在資料合約模型中對於它們的處理方式有一些差異。</span><span class="sxs-lookup"><span data-stu-id="65dfb-256">However, there are some differences in how these are treated in the data contract model.</span></span> <span data-ttu-id="65dfb-257">重要差異摘要如下：</span><span class="sxs-lookup"><span data-stu-id="65dfb-257">The important differences are summarized in the following:</span></span>  
  
- <span data-ttu-id="65dfb-258">結構描述提供者方法必須可公開在 `XmlSerializer` 中使用，但不必公開在資料合約模型中使用。</span><span class="sxs-lookup"><span data-stu-id="65dfb-258">The schema provider method must be public to be usable in the `XmlSerializer`, but does not have to be public to be usable in the data contract model.</span></span>  
  
- <span data-ttu-id="65dfb-259">當 `IsAny` 在資料合約模型中為 true，但未使用 `XmlSerializer` 時，便會呼叫結構描述提供者方法。</span><span class="sxs-lookup"><span data-stu-id="65dfb-259">The schema provider method is called when `IsAny` is true in the data contract model but not with the `XmlSerializer`.</span></span>  
  
- <span data-ttu-id="65dfb-260">當沒有出現內容或舊版資料集型別的 `XmlRootAttribute` 屬性時，`XmlSerializer` 會在空白命名空間中匯出全域項目宣告。</span><span class="sxs-lookup"><span data-stu-id="65dfb-260">When the `XmlRootAttribute` attribute is not present for content or legacy dataset types, the `XmlSerializer` exports a global element declaration in the blank namespace.</span></span> <span data-ttu-id="65dfb-261">在資料合約模型中，所使用的命名空間通常是資料合約命名空間，如前所述。</span><span class="sxs-lookup"><span data-stu-id="65dfb-261">In the data contract model, the namespace used is normally the data contract namespace as described earlier.</span></span>  
  
 <span data-ttu-id="65dfb-262">在建立將搭配這兩種序列化技術使用的型別時，請注意這些差異。</span><span class="sxs-lookup"><span data-stu-id="65dfb-262">Be aware of these differences when creating types that are used with both serialization technologies.</span></span>  
  
### <a name="importing-ixmlserializable-schema"></a><span data-ttu-id="65dfb-263">匯入 IXmlSerializable 結構描述</span><span class="sxs-lookup"><span data-stu-id="65dfb-263">Importing IXmlSerializable Schema</span></span>  

 <span data-ttu-id="65dfb-264">當匯入從 `IXmlSerializable` 型別產生的結構描述時，有一些可能性：</span><span class="sxs-lookup"><span data-stu-id="65dfb-264">When importing a schema generated from `IXmlSerializable` types, there are a few possibilities:</span></span>  
  
- <span data-ttu-id="65dfb-265">產生的架構可能是有效的資料合約架構，如 [資料合約架構參考](data-contract-schema-reference.md)中所述。</span><span class="sxs-lookup"><span data-stu-id="65dfb-265">The generated schema may be a valid data contract schema as described in [Data Contract Schema Reference](data-contract-schema-reference.md).</span></span> <span data-ttu-id="65dfb-266">在這種情況中，結構描述會如平常般匯入，並產生一般資料合約類型。</span><span class="sxs-lookup"><span data-stu-id="65dfb-266">In this case, schema can be imported as usual and regular data contract types are generated.</span></span>  
  
- <span data-ttu-id="65dfb-267">所產生的結構描述可能不是有效的資料合約結構描述。</span><span class="sxs-lookup"><span data-stu-id="65dfb-267">The generated schema may not be a valid data contract schema.</span></span> <span data-ttu-id="65dfb-268">例如，您的結構描述提供者方法可能會產生結構描述，其中包含資料合約模型中不支援的 XML 屬性。</span><span class="sxs-lookup"><span data-stu-id="65dfb-268">For example, your schema provider method may generate schema that involves XML attributes which are not supported in the data contract model.</span></span> <span data-ttu-id="65dfb-269">在這種情況中，您可以將結構描述匯入為 `IXmlSerializable` 型別。</span><span class="sxs-lookup"><span data-stu-id="65dfb-269">In this case, you can import the schema as `IXmlSerializable` types.</span></span> <span data-ttu-id="65dfb-270">此匯入模式預設為不開啟，但很容易啟用–例如，使用 `/importXmlTypes` 命令列參數來切換至 [System.servicemodel 中繼資料公用程式工具 ( # A0) ](../servicemodel-metadata-utility-tool-svcutil-exe.md)。</span><span class="sxs-lookup"><span data-stu-id="65dfb-270">This import mode is not on by default but can easily be enabled – for example, with the `/importXmlTypes` command-line switch to the [ServiceModel Metadata Utility Tool (Svcutil.exe)](../servicemodel-metadata-utility-tool-svcutil-exe.md).</span></span> <span data-ttu-id="65dfb-271">這在匯入架構中會詳細說明 [以產生類別](importing-schema-to-generate-classes.md)。</span><span class="sxs-lookup"><span data-stu-id="65dfb-271">This is described in detail in the [Importing Schema to Generate Classes](importing-schema-to-generate-classes.md).</span></span> <span data-ttu-id="65dfb-272">請注意，您必須對您的型別執行個體直接使用 XML。</span><span class="sxs-lookup"><span data-stu-id="65dfb-272">Note that you must work directly with the XML for your type instances.</span></span> <span data-ttu-id="65dfb-273">您可能也會考慮使用不同的序列化技術，支援範圍更廣的結構描述 – 請參閱有關使用 `XmlSerializer` 的主題。</span><span class="sxs-lookup"><span data-stu-id="65dfb-273">You may also consider using a different serialization technology that supports a wider range of schema – see the topic on using the `XmlSerializer`.</span></span>  
  
- <span data-ttu-id="65dfb-274">您可能會想要在 Proxy 中重複使用現有的 `IXmlSerializable` 型別，而非產生一個新的。</span><span class="sxs-lookup"><span data-stu-id="65dfb-274">You may want to reuse your existing `IXmlSerializable` types in the proxy instead of generating new ones.</span></span> <span data-ttu-id="65dfb-275">在這種情況中，「匯入結構描述以產生型別」主題中所說明的參照型別功能可用於指出要重複使用的型別。</span><span class="sxs-lookup"><span data-stu-id="65dfb-275">In this case, the referenced types feature described in the Importing Schema to Generate Types topic can be used to indicate the type to reuse.</span></span> <span data-ttu-id="65dfb-276">這會對應至在 svcutil.exe 上使用 `/reference` 參數，指定包含要重複使用之型別的組件。</span><span class="sxs-lookup"><span data-stu-id="65dfb-276">This corresponds to using the `/reference` switch on svcutil.exe, which specifies the assembly that contains the types to reuse.</span></span>  
  
## <a name="representing-arbitrary-xml-in-data-contracts"></a><span data-ttu-id="65dfb-277">表示資料合約中的任意 XML</span><span class="sxs-lookup"><span data-stu-id="65dfb-277">Representing Arbitrary XML in Data Contracts</span></span>  

 <span data-ttu-id="65dfb-278">`XmlElement`、`XmlNode` 的陣列和 `IXmlSerializable` 型別可讓您將任意 XML 插入資料合約模型中。</span><span class="sxs-lookup"><span data-stu-id="65dfb-278">The `XmlElement`, Array of `XmlNode` and `IXmlSerializable` types allow you to inject arbitrary XML into the data contract model.</span></span> <span data-ttu-id="65dfb-279">`DataContractSerializer` 和 `NetDataContractSerializer` 會將此 XML 內容傳遞至使用中的 XML 寫入器，而不會干擾處理程序。</span><span class="sxs-lookup"><span data-stu-id="65dfb-279">The `DataContractSerializer` and `NetDataContractSerializer` pass this XML content on to the XML writer in use, without interfering in the process.</span></span> <span data-ttu-id="65dfb-280">然而，XML 寫入器可能會對所撰寫的 XML 強加特定的限制。</span><span class="sxs-lookup"><span data-stu-id="65dfb-280">However, the XML writers may enforce certain restrictions on the XML that they write.</span></span> <span data-ttu-id="65dfb-281">特別是，下列是一些重要的範例：</span><span class="sxs-lookup"><span data-stu-id="65dfb-281">Specifically, here are some important examples:</span></span>  
  
- <span data-ttu-id="65dfb-282">XML 寫入器通常不會允許 XML 檔宣告 (例如， \<?xml version=’1.0’ ?> 在撰寫另一份檔的過程中) 。</span><span class="sxs-lookup"><span data-stu-id="65dfb-282">The XML writers do not typically allow an XML document declaration (for example, \<?xml version=’1.0’ ?>) in the middle of writing another document.</span></span> <span data-ttu-id="65dfb-283">您無法採用完整的 XML 文件並序列化為 `Array` 資料成員的 `XmlNode`。</span><span class="sxs-lookup"><span data-stu-id="65dfb-283">You cannot take a full XML document and serialize it as an `Array` of `XmlNode` data member.</span></span> <span data-ttu-id="65dfb-284">如果要執行這項操作，您必須刪除文件宣告或使用您自己的編碼配置來表示它。</span><span class="sxs-lookup"><span data-stu-id="65dfb-284">To do this, you have to either strip out the document declaration or use your own encoding scheme to represent it.</span></span>  
  
- <span data-ttu-id="65dfb-285">WCF 中提供的所有 XML 寫入器都會拒絕 XML 處理指示 (\<? … ?>) 和檔案類型定義 (\<! … >) ，因為它們在 SOAP 訊息中是不允許的。</span><span class="sxs-lookup"><span data-stu-id="65dfb-285">All of the XML writers supplied with WCF reject XML processing instructions (\<? … ?>) and document type definitions (\<! … >), because they are not allowed in SOAP messages.</span></span> <span data-ttu-id="65dfb-286">同樣地，您可以使用您自己的編碼機制來解決這個限制。</span><span class="sxs-lookup"><span data-stu-id="65dfb-286">Again, you can use your own encoding mechanism to get around this restriction.</span></span> <span data-ttu-id="65dfb-287">如果您必須在結果 XML 中包含它們，可以撰寫自訂編碼器，使用支援它們的 XML 寫入器。</span><span class="sxs-lookup"><span data-stu-id="65dfb-287">If you must include these in your resultant XML, you can write a custom encoder that uses XML writers that support them.</span></span>  
  
- <span data-ttu-id="65dfb-288">當實作 `WriteXml` 時，請避免在 XML 寫入器上呼叫 <xref:System.Xml.XmlWriter.WriteRaw%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="65dfb-288">When implementing `WriteXml`, avoid calling <xref:System.Xml.XmlWriter.WriteRaw%2A> method on the XML writer.</span></span> <span data-ttu-id="65dfb-289">WCF 使用各種 XML 編碼 (包括二進位) ，因此很難或無法使用， `WriteRaw` 因此結果可用於任何編碼。</span><span class="sxs-lookup"><span data-stu-id="65dfb-289">WCF uses a variety of XML encodings (including binary), it is very difficult or impossible to use `WriteRaw` such that the result is usable in any encoding.</span></span>  
  
- <span data-ttu-id="65dfb-290">在執行時 `WriteXml` ，請避免 <xref:System.Xml.XmlWriter.WriteEntityRef%2A> 使用 <xref:System.Xml.XmlWriter.WriteNmToken%2A> WCF 提供的 XML 寫入器上不支援的和方法。</span><span class="sxs-lookup"><span data-stu-id="65dfb-290">When implementing `WriteXml`, avoid using the <xref:System.Xml.XmlWriter.WriteEntityRef%2A> and <xref:System.Xml.XmlWriter.WriteNmToken%2A> methods that are unsupported on the XML writers supplied with WCF.</span></span>  
  
## <a name="using-dataset-typed-dataset-and-datatable"></a><span data-ttu-id="65dfb-291">使用 DataSet、Typed DataSet 和 DataTable</span><span class="sxs-lookup"><span data-stu-id="65dfb-291">Using DataSet, Typed DataSet and DataTable</span></span>  

 <span data-ttu-id="65dfb-292">使用這些型別在資料合約模型中是受到完整支援的。</span><span class="sxs-lookup"><span data-stu-id="65dfb-292">Using these types is fully supported in the data contract model.</span></span> <span data-ttu-id="65dfb-293">當使用這些型別時，請考慮下列各點：</span><span class="sxs-lookup"><span data-stu-id="65dfb-293">When using these types, consider the following points:</span></span>  
  
- <span data-ttu-id="65dfb-294">這些類型的架構 (特別是 <xref:System.Data.DataSet> 其具類型的衍生類別，) 可能無法與某些非 WCF 平臺互通，或在搭配這些平臺使用時可能會導致可用性不佳。</span><span class="sxs-lookup"><span data-stu-id="65dfb-294">The schema for these types (especially <xref:System.Data.DataSet> and its typed derived classes) may not be interoperable with some non-WCF platforms, or may result in poor usability when used with these platforms.</span></span> <span data-ttu-id="65dfb-295">此外，使用 `DataSet` 型別可能會對效能有影響。</span><span class="sxs-lookup"><span data-stu-id="65dfb-295">Additionally, using the `DataSet` type may have performance implications.</span></span> <span data-ttu-id="65dfb-296">最後，它可能會讓您將來更難處理應用程式的版本。</span><span class="sxs-lookup"><span data-stu-id="65dfb-296">Finally, it may make it more difficult for you to version your application in the future.</span></span> <span data-ttu-id="65dfb-297">請考慮使用明確定義的資料合約類型來取代您合約中的 `DataSet` 型別。</span><span class="sxs-lookup"><span data-stu-id="65dfb-297">Consider using explicitly defined data contract types instead of `DataSet` types in your contracts.</span></span>  
  
- <span data-ttu-id="65dfb-298">當匯入 `DataSet` 或 `DataTable` 結構描述時，參照這些型別是很重要的。</span><span class="sxs-lookup"><span data-stu-id="65dfb-298">When importing `DataSet` or `DataTable` schema, it is important to reference these types.</span></span> <span data-ttu-id="65dfb-299">使用 Svcutil.exe 命令列工具，即可將 System.Data.dll 元件名稱傳遞至參數，以完成此作業 `/reference` 。</span><span class="sxs-lookup"><span data-stu-id="65dfb-299">With the Svcutil.exe command-line tool, this can be accomplished by passing the System.Data.dll assembly name to the `/reference` switch.</span></span> <span data-ttu-id="65dfb-300">如果匯入具型別資料集結構描述，您必須參照具型別資料集的型別。</span><span class="sxs-lookup"><span data-stu-id="65dfb-300">If importing typed dataset schema, you must reference the typed dataset’s type.</span></span> <span data-ttu-id="65dfb-301">使用 Svcutil.exe，將具型別資料集之元件的位置傳遞至 `/reference` 參數。</span><span class="sxs-lookup"><span data-stu-id="65dfb-301">With Svcutil.exe, pass the location of the typed dataset’s assembly to the `/reference` switch.</span></span> <span data-ttu-id="65dfb-302">如需參考類型的詳細資訊，請參閱匯 [入架構以產生類別](importing-schema-to-generate-classes.md)。</span><span class="sxs-lookup"><span data-stu-id="65dfb-302">For more information about referencing types, see the [Importing Schema to Generate Classes](importing-schema-to-generate-classes.md).</span></span>  
  
 <span data-ttu-id="65dfb-303">支援資料合約模型中具有型別的資料集是受限制的。</span><span class="sxs-lookup"><span data-stu-id="65dfb-303">Support for typed DataSets in the data contract model is limited.</span></span> <span data-ttu-id="65dfb-304">具有型別的資料集可以序列化和還原序列化，並可以匯出其結構描述。</span><span class="sxs-lookup"><span data-stu-id="65dfb-304">Typed DataSets can be serialized and deserialized and can export their schema.</span></span> <span data-ttu-id="65dfb-305">但是，資料合約結構描述匯入無法從結構描述產生新的具有型別資料集型別，因為它只會重複使用現有的資料集型別。</span><span class="sxs-lookup"><span data-stu-id="65dfb-305">However, the Data Contract schema import is unable to generate new typed DataSet types from the schema, as it can only reuse existing ones.</span></span> <span data-ttu-id="65dfb-306">您可以在 Svcutil.exe 上使用 `/r` 參數來指向現有具有型別的資料集。</span><span class="sxs-lookup"><span data-stu-id="65dfb-306">You can point to an existing typed DataSet by using the `/r` switch on Svcutil.exe.</span></span> <span data-ttu-id="65dfb-307">如果您嘗試在使用具型別資料集的服務上使用 Svcutil.exe，但不使用 `/r` 參數，則會自動選取替代的序列化程式 (XmlSerializer)。</span><span class="sxs-lookup"><span data-stu-id="65dfb-307">If you attempt to use a Svcutil.exe without the `/r` switch on a service that uses a typed dataset, an alternative serializer (XmlSerializer) is automatically selected.</span></span> <span data-ttu-id="65dfb-308">如果您必須使用 DataContractSerializer，且必須從結構描述產生資料集，您可以使用下列程序：產生具有型別的資料集型別 (透過在服務上使用 Xsd.exe 工具並加上 `/d` 參數)、編譯該型別，然後在 Svcutil.exe 上使用 `/r` 參數來指向這些型別。</span><span class="sxs-lookup"><span data-stu-id="65dfb-308">If you must use the DataContractSerializer and must generate DataSets from schema, you can use the following procedure: generate the typed DataSet types (by using the Xsd.exe tool with the `/d` switch on the service), compile the types, and then point to them using the `/r` switch on Svcutil.exe.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="65dfb-309">另請參閱</span><span class="sxs-lookup"><span data-stu-id="65dfb-309">See also</span></span>

- <xref:System.Runtime.Serialization.DataContractSerializer>
- <xref:System.Xml.Serialization.IXmlSerializable>
- [<span data-ttu-id="65dfb-310">使用資料合約</span><span class="sxs-lookup"><span data-stu-id="65dfb-310">Using Data Contracts</span></span>](using-data-contracts.md)
- [<span data-ttu-id="65dfb-311">資料合約序列化程式支援的型別</span><span class="sxs-lookup"><span data-stu-id="65dfb-311">Types Supported by the Data Contract Serializer</span></span>](types-supported-by-the-data-contract-serializer.md)
