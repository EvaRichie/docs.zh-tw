---
title: 資料的安全性考量
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: a7eb98da-4a93-4692-8b59-9d670c79ffb2
ms.openlocfilehash: 530bb54936f97f1d7460d63cfa316c760cbd449d
ms.sourcegitcommit: 2543a78be6e246aa010a01decf58889de53d1636
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 07/17/2020
ms.locfileid: "86441813"
---
# <a name="security-considerations-for-data"></a><span data-ttu-id="b3d73-102">資料的安全性考量</span><span class="sxs-lookup"><span data-stu-id="b3d73-102">Security Considerations for Data</span></span>

<span data-ttu-id="b3d73-103">處理 Windows Communication Foundation （WCF）中的資料時，您必須考慮一些威脅類別。</span><span class="sxs-lookup"><span data-stu-id="b3d73-103">When dealing with data in Windows Communication Foundation (WCF), you must consider a number of threat categories.</span></span> <span data-ttu-id="b3d73-104">下表列出與資料處理有關的最重要威脅類別。</span><span class="sxs-lookup"><span data-stu-id="b3d73-104">The following table lists the most important threat classes that relate to data processing.</span></span> <span data-ttu-id="b3d73-105">WCF 提供工具來減輕這些威脅。</span><span class="sxs-lookup"><span data-stu-id="b3d73-105">WCF provides tools to mitigate these threats.</span></span>

<span data-ttu-id="b3d73-106">阻絕服務當接收不受信任的資料時，資料可能會導致接收端存取不相稱數量的各種資源，例如記憶體、執行緒、可用的連接，或藉由導致冗長的計算來處理處理器迴圈。</span><span class="sxs-lookup"><span data-stu-id="b3d73-106">Denial of service When receiving untrusted data, the data may cause the receiving side to access a disproportionate amount of various resources, such as memory, threads, available connections, or processor cycles by causing lengthy computations.</span></span> <span data-ttu-id="b3d73-107">針對伺服器的阻絕服務攻擊可能會造成伺服器當機，或無法處理來自其他合法用戶端的訊息。</span><span class="sxs-lookup"><span data-stu-id="b3d73-107">A denial-of-service attack against a server may cause it to crash and be unable to process messages from other, legitimate clients.</span></span>

<span data-ttu-id="b3d73-108">惡意程式碼執行傳入不受信任的資料，會導致接收端執行其不想要的程式碼。</span><span class="sxs-lookup"><span data-stu-id="b3d73-108">Malicious code execution Incoming untrusted data causes the receiving side to run code it did not intend to.</span></span>

<span data-ttu-id="b3d73-109">資訊洩漏遠端攻擊者會強制接收方回應其要求，使其能夠公開比預期更多的資訊。</span><span class="sxs-lookup"><span data-stu-id="b3d73-109">Information disclosure The remote attacker forces the receiving party to respond to its requests in such a way as to disclose more information than it intends to.</span></span>

## <a name="user-provided-code-and-code-access-security"></a><span data-ttu-id="b3d73-110">使用者提供的程式碼和程式碼存取安全性</span><span class="sxs-lookup"><span data-stu-id="b3d73-110">User-Provided Code and Code Access Security</span></span>

<span data-ttu-id="b3d73-111">Windows Communication Foundation （WCF）基礎結構中的幾個地方，會執行使用者所提供的程式碼。</span><span class="sxs-lookup"><span data-stu-id="b3d73-111">A number of places in the Windows Communication Foundation (WCF) infrastructure run code that is provided by the user.</span></span> <span data-ttu-id="b3d73-112">例如， <xref:System.Runtime.Serialization.DataContractSerializer> 序列化引擎可能會呼叫使用者提供的屬性 `set` 存取子和 `get` 存取子。</span><span class="sxs-lookup"><span data-stu-id="b3d73-112">For example, the <xref:System.Runtime.Serialization.DataContractSerializer> serialization engine may call user-provided property `set` accessors and `get` accessors.</span></span> <span data-ttu-id="b3d73-113">WCF 通道基礎結構也可以呼叫類別的使用者提供的衍生類別 <xref:System.ServiceModel.Channels.Message> 。</span><span class="sxs-lookup"><span data-stu-id="b3d73-113">The WCF channel infrastructure may also call into user-provided derived classes of the <xref:System.ServiceModel.Channels.Message> class.</span></span>

<span data-ttu-id="b3d73-114">程式碼作者有責任要確保沒有安全性弱點的存在。</span><span class="sxs-lookup"><span data-stu-id="b3d73-114">It is the responsibility of the code author to ensure that no security vulnerabilities exist.</span></span> <span data-ttu-id="b3d73-115">例如，如果您以型別整數的資料成員屬性來建立資料合約類型，並在 `set` 存取子實作中根據屬性值來配置陣列，如果惡意訊息包含此資料成員的極大值，您便有可能會遭到阻絕服務攻擊。</span><span class="sxs-lookup"><span data-stu-id="b3d73-115">For example, if you create a data contract type with a data member property of type integer, and in the `set` accessor implementation allocate an array based on the property value, you expose the possibility of a denial-of-service attack if a malicious message contains an extremely large value for this data member.</span></span> <span data-ttu-id="b3d73-116">一般來說，請避免以傳入資料為基礎所做的任何配置，或是使用者提供之程式碼中的漫長處理 (特別是如果小量的傳入資料可能會造成的漫長處理)。</span><span class="sxs-lookup"><span data-stu-id="b3d73-116">In general, avoid any allocations based on incoming data or lengthy processing in user-provided code (especially if lengthy processing can be caused by a small amount of incoming data).</span></span> <span data-ttu-id="b3d73-117">當執行使用者提供之程式碼的安全性分析時，請確定同時考慮所有的失敗情況 (也就是擲回例外狀況的所有程式碼分支)。</span><span class="sxs-lookup"><span data-stu-id="b3d73-117">When performing security analysis of user-provided code, make sure to also consider all failure cases (that is, all code branches where exceptions are thrown).</span></span>

<span data-ttu-id="b3d73-118">使用者提供之程式碼的最終範例為您在各個作業之服務實作內的程式碼。</span><span class="sxs-lookup"><span data-stu-id="b3d73-118">The ultimate example of user-provided code is the code inside your service implementation for each operation.</span></span> <span data-ttu-id="b3d73-119">您服務實作的安全性是您的責任。</span><span class="sxs-lookup"><span data-stu-id="b3d73-119">The security of your service implementation is your responsibility.</span></span> <span data-ttu-id="b3d73-120">很容易就會不小心建立可能會造成阻絕服務弱點的不安全作業實作。</span><span class="sxs-lookup"><span data-stu-id="b3d73-120">It is easy to inadvertently create insecure operation implementations that may result in denial-of-service vulnerabilities.</span></span> <span data-ttu-id="b3d73-121">例如，採用字串並從名稱以該字串開頭的資料庫傳回客戶清單的作業。</span><span class="sxs-lookup"><span data-stu-id="b3d73-121">For example, an operation that takes a string and returns the list of customers from a database whose name starts with that string.</span></span> <span data-ttu-id="b3d73-122">如果您是使用大型資料庫，且傳遞的字串只是單一字母，您的程式碼可能會嘗試建立大於所有可用記憶體的訊息，而造成整個服務失敗</span><span class="sxs-lookup"><span data-stu-id="b3d73-122">If you are working with a large database and the string being passed is just a single letter, your code may attempt to create a message larger than all available memory, causing the entire service to fail.</span></span> <span data-ttu-id="b3d73-123">（ <xref:System.OutOfMemoryException> 在 .NET Framework 中無法復原，而且一律會導致應用程式終止）。</span><span class="sxs-lookup"><span data-stu-id="b3d73-123">(An <xref:System.OutOfMemoryException> is not recoverable in the .NET Framework and always results in the termination of your application.)</span></span>

<span data-ttu-id="b3d73-124">您應該要確保各種擴充點中均未插入惡意程式碼。</span><span class="sxs-lookup"><span data-stu-id="b3d73-124">You should ensure that no malicious code is plugged in to the various extensibility points.</span></span> <span data-ttu-id="b3d73-125">這對於在部分信任下執行、從部分信任組件處理類型，或是建立無法由部分信任程式碼使用的元件時，特別有關係。</span><span class="sxs-lookup"><span data-stu-id="b3d73-125">This is especially relevant when running under partial trust, dealing with types from partially-trusted assemblies, or creating components usable by partially-trusted code.</span></span> <span data-ttu-id="b3d73-126">如需詳細資訊，請參閱本主題稍後的「部分信任威脅」。</span><span class="sxs-lookup"><span data-stu-id="b3d73-126">For more information, see "Partial Trust Threats" in a later section.</span></span>

<span data-ttu-id="b3d73-127">請注意，在部分信任中執行時，資料合約序列化基礎結構只支援資料合約程式設計模型的有限子集 - 例如，使用不支援 <xref:System.SerializableAttribute> 屬性的私用資料成員或型別。</span><span class="sxs-lookup"><span data-stu-id="b3d73-127">Note that when running in partial trust, the data contract serialization infrastructure supports only a limited subset of the data contract programming model - for example, private data members or types using the <xref:System.SerializableAttribute> attribute are not supported.</span></span> <span data-ttu-id="b3d73-128">如需詳細資訊，請參閱[部分信任](partial-trust.md)。</span><span class="sxs-lookup"><span data-stu-id="b3d73-128">For more information, see [Partial Trust](partial-trust.md).</span></span>

## <a name="avoiding-unintentional-information-disclosure"></a><span data-ttu-id="b3d73-129">避免意外的資訊洩漏</span><span class="sxs-lookup"><span data-stu-id="b3d73-129">Avoiding Unintentional Information Disclosure</span></span>

<span data-ttu-id="b3d73-130">當設計具有安全性的可序列化型別時，可能要考量資訊洩漏的問題。</span><span class="sxs-lookup"><span data-stu-id="b3d73-130">When designing serializable types with security in mind, information disclosure is a possible concern.</span></span>

<span data-ttu-id="b3d73-131">請考慮下列幾點：</span><span class="sxs-lookup"><span data-stu-id="b3d73-131">Consider the following points:</span></span>

- <span data-ttu-id="b3d73-132"><xref:System.Runtime.Serialization.DataContractSerializer> 程式設計模型允許在序列化期間，在型別或組件以外公開私用和內部資料。</span><span class="sxs-lookup"><span data-stu-id="b3d73-132">The <xref:System.Runtime.Serialization.DataContractSerializer> programming model allows the exposure of private and internal data outside of the type or assembly during serialization.</span></span> <span data-ttu-id="b3d73-133">此外，型別的形式可能會在結構描述匯出期間公開。</span><span class="sxs-lookup"><span data-stu-id="b3d73-133">Additionally, the shape of a type can be exposed during schema export.</span></span> <span data-ttu-id="b3d73-134">請確定了解您型別的序列化規劃。</span><span class="sxs-lookup"><span data-stu-id="b3d73-134">Be sure to understand your type's serialization projection.</span></span> <span data-ttu-id="b3d73-135">如果您不希望公開任何內容，請停用序列化 (例如，如果是資料合約，請不要套用 <xref:System.Runtime.Serialization.DataMemberAttribute> 屬性)。</span><span class="sxs-lookup"><span data-stu-id="b3d73-135">If you do not want anything exposed, disable serializing it (for example, by not applying the <xref:System.Runtime.Serialization.DataMemberAttribute> attribute in the case of a data contract).</span></span>

- <span data-ttu-id="b3d73-136">請注意，相同型別可能會有多種序列化規劃，視使用中的序列化程式而定。</span><span class="sxs-lookup"><span data-stu-id="b3d73-136">Be aware that the same type may have multiple serialization projections, depending on the serializer in use.</span></span> <span data-ttu-id="b3d73-137">相同型別可能會在搭配 <xref:System.Runtime.Serialization.DataContractSerializer> 使用時公開一組資料，而在搭配 <xref:System.Xml.Serialization.XmlSerializer>使用時公開另一組資料。</span><span class="sxs-lookup"><span data-stu-id="b3d73-137">The same type may expose one set of data when used with the <xref:System.Runtime.Serialization.DataContractSerializer> and another set of data when used with the <xref:System.Xml.Serialization.XmlSerializer>.</span></span> <span data-ttu-id="b3d73-138">意外使用錯誤的序列化程式可能會導致資訊洩漏。</span><span class="sxs-lookup"><span data-stu-id="b3d73-138">Accidentally using the wrong serializer may lead to information disclosure.</span></span>

- <span data-ttu-id="b3d73-139">在舊版遠端程序呼叫 (RPC)/已編碼模式中使用 <xref:System.Xml.Serialization.XmlSerializer> ，可能會意外對接收端公開傳送端上物件圖形的形狀。</span><span class="sxs-lookup"><span data-stu-id="b3d73-139">Using the <xref:System.Xml.Serialization.XmlSerializer> in legacy remote procedure call (RPC)/encoded mode may unintentionally expose the shape of the object graph on the sending side to the receiving side.</span></span>

## <a name="preventing-denial-of-service-attacks"></a><span data-ttu-id="b3d73-140">防止阻絕服務攻擊</span><span class="sxs-lookup"><span data-stu-id="b3d73-140">Preventing Denial-of-Service Attacks</span></span>

### <a name="quotas"></a><span data-ttu-id="b3d73-141">配額</span><span class="sxs-lookup"><span data-stu-id="b3d73-141">Quotas</span></span>

<span data-ttu-id="b3d73-142">造成接收端配置大量的記憶體是一種潛在的阻絕服務攻擊。</span><span class="sxs-lookup"><span data-stu-id="b3d73-142">Causing the receiving side to allocate a significant amount of memory is a potential denial-of-service attack.</span></span> <span data-ttu-id="b3d73-143">當此區段專注於由大型訊息所引起的記憶體消耗問題之時，可能會發生其他攻擊。</span><span class="sxs-lookup"><span data-stu-id="b3d73-143">While this section concentrates on memory consumption issues arising from large messages, other attacks may occur.</span></span> <span data-ttu-id="b3d73-144">例如，訊息可能會使用不當比例的處理時間量。</span><span class="sxs-lookup"><span data-stu-id="b3d73-144">For example, messages may use a disproportionate amount of processing time.</span></span>

<span data-ttu-id="b3d73-145">通常是使用配額來降低阻絕服務攻擊。</span><span class="sxs-lookup"><span data-stu-id="b3d73-145">Denial-of-service attacks are usually mitigated using quotas.</span></span> <span data-ttu-id="b3d73-146">當超過配額時，通常會擲回 <xref:System.ServiceModel.QuotaExceededException> 例外狀況。</span><span class="sxs-lookup"><span data-stu-id="b3d73-146">When a quota is exceeded, a <xref:System.ServiceModel.QuotaExceededException> exception is normally thrown.</span></span> <span data-ttu-id="b3d73-147">如果沒有配額，惡意訊息可能會導致存取所有的可用記憶體，造成 <xref:System.OutOfMemoryException> 例外狀況，或存取所有的可用堆疊，造成 <xref:System.StackOverflowException>。</span><span class="sxs-lookup"><span data-stu-id="b3d73-147">Without the quota, a malicious message may cause all available memory to be accessed, resulting in an <xref:System.OutOfMemoryException> exception, or all available stacks to be accessed, resulting in a <xref:System.StackOverflowException>.</span></span>

<span data-ttu-id="b3d73-148">超過配額的情況是可復原的；如果是在執行中的服務中遇到，會捨棄目前正在處理的訊息，而服務會繼續執行並處理之後的訊息。</span><span class="sxs-lookup"><span data-stu-id="b3d73-148">The quota exceeded scenario is recoverable; if encountered in a running service, the message currently being processed is discarded and the service keeps running and processes further messages.</span></span> <span data-ttu-id="b3d73-149">不過，記憶體不足和堆疊溢位的情況無法在 .NET Framework 中的任何位置復原;服務會在遇到這類例外狀況時終止。</span><span class="sxs-lookup"><span data-stu-id="b3d73-149">The out-of-memory and stack overflow scenarios, however, are not recoverable anywhere in the .NET Framework; the service terminates if it encounters such exceptions.</span></span>

<span data-ttu-id="b3d73-150">WCF 中的配額不牽涉到任何預先配置。</span><span class="sxs-lookup"><span data-stu-id="b3d73-150">Quotas in WCF do not involve any pre-allocation.</span></span> <span data-ttu-id="b3d73-151">例如，如果 <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> 配額 (在各種不同類別上) 設定為 128 KB，不表示會為各個訊息自動配置 128 KB。</span><span class="sxs-lookup"><span data-stu-id="b3d73-151">For example, if the <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> quota (found on various classes) is set to 128 KB, it does not mean that 128 KB is automatically allocated for each message.</span></span> <span data-ttu-id="b3d73-152">實際的配置量要視實際的傳入訊息大小而定。</span><span class="sxs-lookup"><span data-stu-id="b3d73-152">The actual amount allocated depends on the actual incoming message size.</span></span>

<span data-ttu-id="b3d73-153">傳輸層有許多的配額。</span><span class="sxs-lookup"><span data-stu-id="b3d73-153">Many quotas are available at the transport layer.</span></span> <span data-ttu-id="b3d73-154">這些是由使用中的特定傳輸通道 (HTTP、TCP 等等) 所強制執行的配額。</span><span class="sxs-lookup"><span data-stu-id="b3d73-154">These are quotas enforced by the specific transport channel in use (HTTP, TCP, and so on).</span></span> <span data-ttu-id="b3d73-155">這些配額在 [Transport Quotas](transport-quotas.md)中有詳細的說明，而本主題只討論其中一部分。</span><span class="sxs-lookup"><span data-stu-id="b3d73-155">While this topic discusses some of these quotas, these quotas are described in detail in [Transport Quotas](transport-quotas.md).</span></span>

### <a name="hashtable-vulnerability"></a><span data-ttu-id="b3d73-156">Hashtable 弱點</span><span class="sxs-lookup"><span data-stu-id="b3d73-156">Hashtable Vulnerability</span></span>

<span data-ttu-id="b3d73-157">若資料合約包含 Hashtable 或集合，會有弱點。</span><span class="sxs-lookup"><span data-stu-id="b3d73-157">A vulnerability exists when data contracts contain hashtables or collections.</span></span> <span data-ttu-id="b3d73-158">如果大量的值插入 Hashtable，而其中大部分的值產生相同的雜湊值，就會發生問題。</span><span class="sxs-lookup"><span data-stu-id="b3d73-158">The problem occurs if a large number of values are inserted into a hashtable where a large number of those values generate the same hash value.</span></span> <span data-ttu-id="b3d73-159">這可以當做 DOS 攻擊使用。</span><span class="sxs-lookup"><span data-stu-id="b3d73-159">This can be used as a DOS attack.</span></span>  <span data-ttu-id="b3d73-160">您可以藉由設定 MaxReceivedMessageSize 系結配額來減輕此弱點。</span><span class="sxs-lookup"><span data-stu-id="b3d73-160">This vulnerability can be mitigated by setting the MaxReceivedMessageSize binding quota.</span></span> <span data-ttu-id="b3d73-161">為了防止此類攻擊而設定這種配額時，請務必小心。</span><span class="sxs-lookup"><span data-stu-id="b3d73-161">Care must be taken while setting this quota in order to prevent such attacks.</span></span> <span data-ttu-id="b3d73-162">此配額會對 WCF 訊息的大小設定上限。</span><span class="sxs-lookup"><span data-stu-id="b3d73-162">This quota puts an upper limit on the size of WCF message.</span></span> <span data-ttu-id="b3d73-163">此外，請避免在您的資料合約中使用 Hashtable 或集合。</span><span class="sxs-lookup"><span data-stu-id="b3d73-163">Additionally, avoid using hashtables or collections in your data contracts.</span></span>

## <a name="limiting-memory-consumption-without-streaming"></a><span data-ttu-id="b3d73-164">不使用資料流來限制記憶體消耗</span><span class="sxs-lookup"><span data-stu-id="b3d73-164">Limiting Memory Consumption Without Streaming</span></span>

<span data-ttu-id="b3d73-165">大型訊息的安全性模型要視是否正在使用資料流而定。</span><span class="sxs-lookup"><span data-stu-id="b3d73-165">The security model around large messages depends on whether streaming is in use.</span></span> <span data-ttu-id="b3d73-166">在基本、未經資料流處理的情況中，訊息會進入緩衝記憶體中。</span><span class="sxs-lookup"><span data-stu-id="b3d73-166">In the basic, non-streamed case, messages are buffered into memory.</span></span> <span data-ttu-id="b3d73-167">在這種情況中，請在 <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> 上或系統提供的繫結上使用 <xref:System.ServiceModel.Channels.TransportBindingElement> 配額，藉由限制存取的訊息大小上限來防止大型訊息。</span><span class="sxs-lookup"><span data-stu-id="b3d73-167">In this case, use the <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> quota on the <xref:System.ServiceModel.Channels.TransportBindingElement> or on the system-provided bindings to protect against large messages by limiting the maximum message size to access.</span></span> <span data-ttu-id="b3d73-168">請注意，服務可能會同時處理多個訊息，此時它們都將會在記憶體中。</span><span class="sxs-lookup"><span data-stu-id="b3d73-168">Note that a service may be processing multiple messages at the same time, in which case they are all in memory.</span></span> <span data-ttu-id="b3d73-169">請使用節流功能來降低這個威脅。</span><span class="sxs-lookup"><span data-stu-id="b3d73-169">Use the throttling feature to mitigate this threat.</span></span>

<span data-ttu-id="b3d73-170">同時也請注意，雖然 `MaxReceivedMessageSize` 不會對每個訊息的記憶體消耗設定上限，但會限制在常數係數之內。</span><span class="sxs-lookup"><span data-stu-id="b3d73-170">Also note that `MaxReceivedMessageSize` does not place an upper bound on per-message memory consumption, but limits it to within a constant factor.</span></span> <span data-ttu-id="b3d73-171">例如，如果 `MaxReceivedMessageSize` 是 1 MB，且收到 1-MB 的訊息後還原序列化，則會需要額外的記憶體來包含已還原序列化物件圖形，而造成總記憶體消耗超過 1 MB。</span><span class="sxs-lookup"><span data-stu-id="b3d73-171">For example, if the `MaxReceivedMessageSize` is 1 MB and a 1-MB message is received and then deserialized, additional memory is required to contain the deserialized object graph, resulting in total memory consumption well over 1 MB.</span></span> <span data-ttu-id="b3d73-172">因此，請避免建立可序列化的型別，防止沒有太多傳入資料，卻造成大量的記憶體消耗。</span><span class="sxs-lookup"><span data-stu-id="b3d73-172">For this reason, avoid creating serializable types that could result in significant memory consumption without much incoming data.</span></span> <span data-ttu-id="b3d73-173">例如，具有50選擇性資料成員欄位和額外100私用欄位的資料合約 "MyContract" 可能會以 XML 結構 "" 具現化 \<MyContract/> 。</span><span class="sxs-lookup"><span data-stu-id="b3d73-173">For example, a data contract "MyContract" with 50 optional data member fields and an additional 100 private fields could be instantiated with the XML construction "\<MyContract/>".</span></span> <span data-ttu-id="b3d73-174">此 XML 會造成存取的記憶體用在 150 個欄位上。</span><span class="sxs-lookup"><span data-stu-id="b3d73-174">This XML results in memory being accessed for 150 fields.</span></span> <span data-ttu-id="b3d73-175">請注意，根據預設，資料成員是選擇性的。</span><span class="sxs-lookup"><span data-stu-id="b3d73-175">Note that data members are optional by default.</span></span> <span data-ttu-id="b3d73-176">當此類型別是陣列的一部分時，問題是複合性的。</span><span class="sxs-lookup"><span data-stu-id="b3d73-176">The problem is compounded when such a type is part of an array.</span></span>

<span data-ttu-id="b3d73-177">只有`MaxReceivedMessageSize` 不足以防止所有的阻絕服務攻擊。</span><span class="sxs-lookup"><span data-stu-id="b3d73-177">`MaxReceivedMessageSize` alone is not enough to prevent all denial-of-service attacks.</span></span> <span data-ttu-id="b3d73-178">例如，傳入的訊息可能會強制還原序列化程式要還原序列化深度巢狀的物件圖形 (包含的物件中還包含另一個物件的物件)。</span><span class="sxs-lookup"><span data-stu-id="b3d73-178">For example, the deserializer may be forced to deserialize a deeply-nested object graph (an object that contains another object that contains yet another one, and so on) by an incoming message.</span></span> <span data-ttu-id="b3d73-179"><xref:System.Runtime.Serialization.DataContractSerializer> 和 <xref:System.Xml.Serialization.XmlSerializer> 都會以巢狀方式呼叫方法，以還原序列化此類圖形。</span><span class="sxs-lookup"><span data-stu-id="b3d73-179">Both the <xref:System.Runtime.Serialization.DataContractSerializer> and the <xref:System.Xml.Serialization.XmlSerializer> call methods in a nested way to deserialize such graphs.</span></span> <span data-ttu-id="b3d73-180">深度巢狀的方法呼叫可能會造成無法復原的 <xref:System.StackOverflowException>。</span><span class="sxs-lookup"><span data-stu-id="b3d73-180">Deep nesting of method calls may result in an unrecoverable <xref:System.StackOverflowException>.</span></span> <span data-ttu-id="b3d73-181">這項威脅可以藉由設定 <xref:System.ServiceModel.Configuration.XmlDictionaryReaderQuotasElement.MaxDepth%2A> 配額以限制 XML 巢狀的層級來降低，如同本主題中稍後的＜安全使用 XML＞一節中所述。</span><span class="sxs-lookup"><span data-stu-id="b3d73-181">This threat is mitigated by setting the <xref:System.ServiceModel.Configuration.XmlDictionaryReaderQuotasElement.MaxDepth%2A> quota to limit the level of XML nesting, as discussed in the "Using XML Safely" section later in the topic.</span></span>

<span data-ttu-id="b3d73-182">當使用二進位 XML 編碼時，將其他配額設定為 `MaxReceivedMessageSize` 特別重要。</span><span class="sxs-lookup"><span data-stu-id="b3d73-182">Setting additional quotas to `MaxReceivedMessageSize` is especially important when using binary XML encoding.</span></span> <span data-ttu-id="b3d73-183">使用二進位編碼與壓縮有些相同：傳入訊息中的一小群位元組可代表許多資料。</span><span class="sxs-lookup"><span data-stu-id="b3d73-183">Using binary encoding is somewhat equivalent to compression: a small group of bytes in the incoming message may represent a lot of data.</span></span> <span data-ttu-id="b3d73-184">因此，即使訊息符合 `MaxReceivedMessageSize` 限制，仍可能以完整展開的形式佔用太多記憶體。</span><span class="sxs-lookup"><span data-stu-id="b3d73-184">Thus, even a message fitting into the `MaxReceivedMessageSize` limit may take up much more memory in fully expanded form.</span></span> <span data-ttu-id="b3d73-185">如果要降低此類 XML 特定的威脅，必須正確設定所有的 XML 讀取器配額，如同本主題中稍後的＜安全使用 XML＞一節中所述。</span><span class="sxs-lookup"><span data-stu-id="b3d73-185">To mitigate such XML-specific threats, all of the XML reader quotas must be set correctly, as discussed in the "Using XML Safely" section later in this topic.</span></span>

## <a name="limiting-memory-consumption-with-streaming"></a><span data-ttu-id="b3d73-186">使用資料流來限制記憶體消耗</span><span class="sxs-lookup"><span data-stu-id="b3d73-186">Limiting Memory Consumption with Streaming</span></span>

<span data-ttu-id="b3d73-187">當進行資料流處理時，您可能會使用小的 `MaxReceivedMessageSize` 設定來防止阻絕服務攻擊。</span><span class="sxs-lookup"><span data-stu-id="b3d73-187">When streaming, you may use a small `MaxReceivedMessageSize` setting to protect against denial-of-service attacks.</span></span> <span data-ttu-id="b3d73-188">然而，使用資料流可能會有更複雜的情況。</span><span class="sxs-lookup"><span data-stu-id="b3d73-188">However, more complicated scenarios are possible with streaming.</span></span> <span data-ttu-id="b3d73-189">例如，檔案上載服務會接受大於所有可用記憶體的檔案。</span><span class="sxs-lookup"><span data-stu-id="b3d73-189">For example, a file upload service accepts files larger than all available memory.</span></span> <span data-ttu-id="b3d73-190">在這種情況中，請將 `MaxReceivedMessageSize` 設定為極大值，如此應該幾乎不會有資料進入緩衝記憶體，且訊息會直接串流至磁碟。</span><span class="sxs-lookup"><span data-stu-id="b3d73-190">In this case, set the `MaxReceivedMessageSize` to an extremely large value, expecting that almost no data is buffered in memory and the message streams directly to disk.</span></span> <span data-ttu-id="b3d73-191">如果惡意訊息可以某種方式強制 WCF 緩衝處理資料，而不是在此情況下串流，則 `MaxReceivedMessageSize` 無法再針對存取所有可用記憶體的訊息進行保護。</span><span class="sxs-lookup"><span data-stu-id="b3d73-191">If a malicious message can somehow force WCF to buffer data instead of streaming it in this case, `MaxReceivedMessageSize` no longer protects against the message accessing all available memory.</span></span>

<span data-ttu-id="b3d73-192">若要降低此威脅，特定的配額設定會存在於限制緩衝處理的各種 WCF 資料處理元件上。</span><span class="sxs-lookup"><span data-stu-id="b3d73-192">To mitigate this threat, specific quota settings exist on various WCF data-processing components that limit buffering.</span></span> <span data-ttu-id="b3d73-193">其中最重要的是各種傳輸繫結項目和標準繫結上的 `MaxBufferSize` 屬性。</span><span class="sxs-lookup"><span data-stu-id="b3d73-193">The most important of these is the `MaxBufferSize` property on various transport binding elements and standard bindings.</span></span> <span data-ttu-id="b3d73-194">當進行資料流處理時，應在設定此配額時考慮您願意配置給每個訊息的最大記憶體量。</span><span class="sxs-lookup"><span data-stu-id="b3d73-194">When streaming, this quota should be set taking into account the maximum amount of memory you are willing to allocate per message.</span></span> <span data-ttu-id="b3d73-195">如同 `MaxReceivedMessageSize`，此設定不會設定記憶體消耗的絕對上限，而只會將其限制在常數係數之內。</span><span class="sxs-lookup"><span data-stu-id="b3d73-195">As with `MaxReceivedMessageSize`, the setting does not put an absolute maximum on memory consumption but only limits it to within a constant factor.</span></span> <span data-ttu-id="b3d73-196">同時，如同 `MaxReceivedMessageSize`，請注意同時處理多個訊息的可能性。</span><span class="sxs-lookup"><span data-stu-id="b3d73-196">Also, as with `MaxReceivedMessageSize`, be aware of the possibility of multiple messages being processed simultaneously.</span></span>

### <a name="maxbuffersize-details"></a><span data-ttu-id="b3d73-197">MaxBufferSize 詳細資料</span><span class="sxs-lookup"><span data-stu-id="b3d73-197">MaxBufferSize Details</span></span>

<span data-ttu-id="b3d73-198">`MaxBufferSize`屬性會限制任何大量緩衝 WCF 執行的工作。</span><span class="sxs-lookup"><span data-stu-id="b3d73-198">The `MaxBufferSize` property limits any bulk buffering WCF does.</span></span> <span data-ttu-id="b3d73-199">例如，WCF 一律會緩衝 SOAP 標頭和 SOAP 錯誤，以及在訊息傳輸優化機制（MTOM）訊息中找不到自然讀取順序的任何 MIME 部分。</span><span class="sxs-lookup"><span data-stu-id="b3d73-199">For example, WCF always buffers SOAP headers and SOAP faults, as well as any MIME parts found to be not in the natural reading order in an Message Transmission Optimization Mechanism (MTOM) message.</span></span> <span data-ttu-id="b3d73-200">這個設定會限制上述所有情況中的緩衝處理量。</span><span class="sxs-lookup"><span data-stu-id="b3d73-200">This setting limits the amount of buffering in all these cases.</span></span>

<span data-ttu-id="b3d73-201">WCF 會藉由將 `MaxBufferSize` 值傳遞給可能緩衝的各種元件來完成這項工作。</span><span class="sxs-lookup"><span data-stu-id="b3d73-201">WCF accomplishes this by passing the `MaxBufferSize` value to the various components that may buffer.</span></span> <span data-ttu-id="b3d73-202">例如， <xref:System.ServiceModel.Channels.Message.CreateMessage%2A> 類別的一些 <xref:System.ServiceModel.Channels.Message> 多載會接受 `maxSizeOfHeaders` 參數。</span><span class="sxs-lookup"><span data-stu-id="b3d73-202">For example, some <xref:System.ServiceModel.Channels.Message.CreateMessage%2A> overloads of the <xref:System.ServiceModel.Channels.Message> class take a `maxSizeOfHeaders` parameter.</span></span> <span data-ttu-id="b3d73-203">WCF 會將 `MaxBufferSize` 值傳遞給這個參數，以限制 SOAP 標頭緩衝處理的數量。</span><span class="sxs-lookup"><span data-stu-id="b3d73-203">WCF passes the `MaxBufferSize` value to this parameter to limit the amount of SOAP header buffering.</span></span> <span data-ttu-id="b3d73-204">當直接使用 <xref:System.ServiceModel.Channels.Message> 類別時，設定這個參數是很重要的。</span><span class="sxs-lookup"><span data-stu-id="b3d73-204">It is important to set this parameter when using the <xref:System.ServiceModel.Channels.Message> class directly.</span></span> <span data-ttu-id="b3d73-205">一般來說，在 WCF 中使用接受配額參數的元件時，請務必瞭解這些參數的安全性含意，並正確設定它們。</span><span class="sxs-lookup"><span data-stu-id="b3d73-205">In general, when using a component in WCF that takes quota parameters, it is important to understand the security implications of these parameters and set them correctly.</span></span>

<span data-ttu-id="b3d73-206">MTOM 訊息編碼器也有 `MaxBufferSize` 設定。</span><span class="sxs-lookup"><span data-stu-id="b3d73-206">The MTOM message encoder also has a `MaxBufferSize` setting.</span></span> <span data-ttu-id="b3d73-207">當使用標準繫結時，這會自動設定為傳輸層的 `MaxBufferSize` 值。</span><span class="sxs-lookup"><span data-stu-id="b3d73-207">When using standard bindings, this is set automatically to the transport-level `MaxBufferSize` value.</span></span> <span data-ttu-id="b3d73-208">然而，如果使用 MTOM 訊息編碼器繫結項目來建構自訂繫結，在使用資料流時將 `MaxBufferSize` 屬性設定為安全值是很重要的。</span><span class="sxs-lookup"><span data-stu-id="b3d73-208">However, when using the MTOM message encoder binding element to construct a custom binding, it is important to set the `MaxBufferSize` property to a safe value when streaming is used.</span></span>

## <a name="xml-based-streaming-attacks"></a><span data-ttu-id="b3d73-209">XML 資料流攻擊</span><span class="sxs-lookup"><span data-stu-id="b3d73-209">XML-Based Streaming Attacks</span></span>

<span data-ttu-id="b3d73-210">`MaxBufferSize`單獨的不足以確保在預期資料流程時，無法強制 WCF 能夠緩衝處理。</span><span class="sxs-lookup"><span data-stu-id="b3d73-210">`MaxBufferSize` alone is not enough to ensure that WCF cannot be forced into buffering when streaming is expected.</span></span> <span data-ttu-id="b3d73-211">例如，WCF XML 讀取器在開始讀取新專案時，一律會緩衝整個 XML 元素的開始標記。</span><span class="sxs-lookup"><span data-stu-id="b3d73-211">For example, the WCF XML readers always buffer the entire XML element start tag when starting to read a new element.</span></span> <span data-ttu-id="b3d73-212">完成這項操作才能正確處理命名空間和屬性。</span><span class="sxs-lookup"><span data-stu-id="b3d73-212">This is done so that namespaces and attributes are properly processed.</span></span> <span data-ttu-id="b3d73-213">如果 `MaxReceivedMessageSize` 設定為大型 (例如，如果要啟用直接到磁碟的大型檔案資料流案例)，可能會建構惡意訊息，其中整個訊息本文為大型 XML 項目開始標記。</span><span class="sxs-lookup"><span data-stu-id="b3d73-213">If `MaxReceivedMessageSize` is configured to be large (for example, to enable a direct-to-disk large file streaming scenario), a malicious message may be constructed where the entire message body is a large XML element start tag.</span></span> <span data-ttu-id="b3d73-214">嘗試讀取會造成 <xref:System.OutOfMemoryException>。</span><span class="sxs-lookup"><span data-stu-id="b3d73-214">An attempt to read it results in an <xref:System.OutOfMemoryException>.</span></span> <span data-ttu-id="b3d73-215">這是許多可能以 XML 為基礎的阻絕服務攻擊之一，可以使用 XML 讀取器配額來緩和，本主題稍後的「安全地使用 XML」一節中所述。</span><span class="sxs-lookup"><span data-stu-id="b3d73-215">This is one of many possible XML-based denial-of-service attacks that can all be mitigated using XML reader quotas, discussed in the "Using XML Safely" section later in this topic.</span></span> <span data-ttu-id="b3d73-216">當進行資料流處理時，設定所有這些配額特別重要。</span><span class="sxs-lookup"><span data-stu-id="b3d73-216">When streaming, it is especially important to set all of these quotas.</span></span>

### <a name="mixing-streaming-and-buffering-programming-models"></a><span data-ttu-id="b3d73-217">混合資料流及緩衝程式撰寫模型</span><span class="sxs-lookup"><span data-stu-id="b3d73-217">Mixing Streaming and Buffering Programming Models</span></span>

<span data-ttu-id="b3d73-218">許多可能的攻擊都是由於在同一個服務中混合資料流和非資料流程式撰寫模型所引起。</span><span class="sxs-lookup"><span data-stu-id="b3d73-218">Many possible attacks arise from mixing streaming and non-streaming programming models in the same service.</span></span> <span data-ttu-id="b3d73-219">假設服務合約有兩個作業：一個採用 <xref:System.IO.Stream> ，另一個採用某種自訂型別的陣列。</span><span class="sxs-lookup"><span data-stu-id="b3d73-219">Suppose there is a service contract with two operations: one takes a <xref:System.IO.Stream> and another takes an array of some custom type.</span></span> <span data-ttu-id="b3d73-220">另外假設 `MaxReceivedMessageSize` 設定為一個很大的值，讓第一個作業可以處理大型資料流。</span><span class="sxs-lookup"><span data-stu-id="b3d73-220">Suppose also that `MaxReceivedMessageSize` is set to a large value to enable the first operation to process large streams.</span></span> <span data-ttu-id="b3d73-221">但是，這表示大型訊息現在可以也傳送到第二個作業，而還原序列化程式會在呼叫作業之前，將記憶體中的資料當做陣列緩衝處理。</span><span class="sxs-lookup"><span data-stu-id="b3d73-221">Unfortunately, this means that large messages can now be sent to the second operation as well, and the deserializer buffers data in memory as an array before the operation is called.</span></span> <span data-ttu-id="b3d73-222">這是一種潛在的阻絕服務攻擊： `MaxBufferSize` 配額沒有限制訊息本文的大小，這也是還原序列化程式所使用的。</span><span class="sxs-lookup"><span data-stu-id="b3d73-222">This is a potential denial-of-service attack: the `MaxBufferSize` quota does not limit the size of the message body, which is what the deserializer works with.</span></span>

<span data-ttu-id="b3d73-223">因此，請避免在同一個合約中混合資料流和非資料流的作業。</span><span class="sxs-lookup"><span data-stu-id="b3d73-223">For this reason, avoid mixing stream-based and non-streamed operations in the same contract.</span></span> <span data-ttu-id="b3d73-224">如果您一定要混合這兩種程式撰寫模型，請使用下列預防措施：</span><span class="sxs-lookup"><span data-stu-id="b3d73-224">If you absolutely must mix the two programming models, use the following precautions:</span></span>

- <span data-ttu-id="b3d73-225">將 <xref:System.Runtime.Serialization.IExtensibleDataObject> 的 <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A> 屬性設定為 <xref:System.ServiceModel.ServiceBehaviorAttribute> ，以關閉 `true`功能。</span><span class="sxs-lookup"><span data-stu-id="b3d73-225">Turn off the <xref:System.Runtime.Serialization.IExtensibleDataObject> feature by setting the <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A> property of the <xref:System.ServiceModel.ServiceBehaviorAttribute> to `true`.</span></span> <span data-ttu-id="b3d73-226">如此可確保只會還原序列化屬於合約一部分的成員。</span><span class="sxs-lookup"><span data-stu-id="b3d73-226">This ensures that only members that are a part of the contract are deserialized.</span></span>

- <span data-ttu-id="b3d73-227">將 <xref:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph%2A> 的 <xref:System.Runtime.Serialization.DataContractSerializer> 屬性設定為安全值。</span><span class="sxs-lookup"><span data-stu-id="b3d73-227">Set the <xref:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph%2A> property of the <xref:System.Runtime.Serialization.DataContractSerializer> to a safe value.</span></span> <span data-ttu-id="b3d73-228">這個配額也可在 <xref:System.ServiceModel.ServiceBehaviorAttribute> 屬性上或透過組態取得。</span><span class="sxs-lookup"><span data-stu-id="b3d73-228">This quota is also available on the <xref:System.ServiceModel.ServiceBehaviorAttribute> attribute or through configuration.</span></span> <span data-ttu-id="b3d73-229">這個配額會限制在一個還原序列化事件中還原序列化的物件數目。</span><span class="sxs-lookup"><span data-stu-id="b3d73-229">This quota limits the number of objects that are deserialized in one deserialization episode.</span></span> <span data-ttu-id="b3d73-230">一般而言，訊息合約中每個作業參數或訊息本文部分都會在一個事件中還原序列化。</span><span class="sxs-lookup"><span data-stu-id="b3d73-230">Normally, each operation parameter or message body part in a message contract is deserialized in one episode.</span></span> <span data-ttu-id="b3d73-231">當還原序列化陣列時，會將每個陣列項目視為個別的物件。</span><span class="sxs-lookup"><span data-stu-id="b3d73-231">When deserializing arrays, each array entry is counted as a separate object.</span></span>

- <span data-ttu-id="b3d73-232">將所有的 XML 讀取器配額設定為安全值。</span><span class="sxs-lookup"><span data-stu-id="b3d73-232">Set all of the XML reader quotas to safe values.</span></span> <span data-ttu-id="b3d73-233">請注意 <xref:System.Xml.XmlDictionaryReaderQuotas.MaxDepth%2A>、 <xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A>和 <xref:System.Xml.XmlDictionaryReaderQuotas.MaxArrayLength%2A> ，並避免非資料流作業中的字串。</span><span class="sxs-lookup"><span data-stu-id="b3d73-233">Pay attention to <xref:System.Xml.XmlDictionaryReaderQuotas.MaxDepth%2A>, <xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A>, and <xref:System.Xml.XmlDictionaryReaderQuotas.MaxArrayLength%2A> and avoid strings in non-streaming operations.</span></span>

- <span data-ttu-id="b3d73-234">請檢閱已知類型的清單，記住可以隨時產生其中任何一個 (請參閱本主題稍後的＜防止載入非預期的類型＞一節)。</span><span class="sxs-lookup"><span data-stu-id="b3d73-234">Review the list of known types, keeping in mind that any one of them can be instantiated at any time (see the "Preventing Unintended Types from Being Loaded" section later in this topic).</span></span>

- <span data-ttu-id="b3d73-235">請勿使用實作 <xref:System.Xml.Serialization.IXmlSerializable> 介面的型別，該介面會緩衝處理大量資料。</span><span class="sxs-lookup"><span data-stu-id="b3d73-235">Do not use any types that implement the <xref:System.Xml.Serialization.IXmlSerializable> interface that buffer a lot of data.</span></span> <span data-ttu-id="b3d73-236">請勿將此種型別新增至已知類型的清單。</span><span class="sxs-lookup"><span data-stu-id="b3d73-236">Do not add such types to the list of known types.</span></span>

- <span data-ttu-id="b3d73-237">請勿使用 <xref:System.Xml.XmlElement>、 <xref:System.Xml.XmlNode> 陣列、 <xref:System.Byte> 陣列或實作合約中 <xref:System.Runtime.Serialization.ISerializable> 的型別。</span><span class="sxs-lookup"><span data-stu-id="b3d73-237">Do not use the <xref:System.Xml.XmlElement>, <xref:System.Xml.XmlNode> arrays, <xref:System.Byte> arrays, or types that implement <xref:System.Runtime.Serialization.ISerializable> in a contract.</span></span>

- <span data-ttu-id="b3d73-238">請勿使用 <xref:System.Xml.XmlElement>、 <xref:System.Xml.XmlNode> 陣列、 <xref:System.Byte> 陣列或實作已知類型清單中的 <xref:System.Runtime.Serialization.ISerializable> 的型別。</span><span class="sxs-lookup"><span data-stu-id="b3d73-238">Do not use the <xref:System.Xml.XmlElement>, <xref:System.Xml.XmlNode> arrays, <xref:System.Byte> arrays, or types that implement <xref:System.Runtime.Serialization.ISerializable> in the list of known types.</span></span>

<span data-ttu-id="b3d73-239">上述預防措施適用於當非資料流的作業使用 <xref:System.Runtime.Serialization.DataContractSerializer>時。</span><span class="sxs-lookup"><span data-stu-id="b3d73-239">The preceding precautions apply when the non-streamed operation uses the <xref:System.Runtime.Serialization.DataContractSerializer>.</span></span> <span data-ttu-id="b3d73-240">如果您是使用 <xref:System.Xml.Serialization.XmlSerializer>，請絕對不要在同一個服務上混合資料流和非資料流程式設計模型，因為它沒有 <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior.MaxItemsInObjectGraph%2A> 配額的保護。</span><span class="sxs-lookup"><span data-stu-id="b3d73-240">Never mix streaming and non-streaming programming models on the same service if you are using the <xref:System.Xml.Serialization.XmlSerializer>, because it does not have the protection of the <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior.MaxItemsInObjectGraph%2A> quota.</span></span>

### <a name="slow-stream-attacks"></a><span data-ttu-id="b3d73-241">慢速資料流攻擊</span><span class="sxs-lookup"><span data-stu-id="b3d73-241">Slow Stream Attacks</span></span>

<span data-ttu-id="b3d73-242">資料流阻絕服務攻擊的類別不包含記憶體消耗。</span><span class="sxs-lookup"><span data-stu-id="b3d73-242">A class of streaming denial-of-service attacks does not involve memory consumption.</span></span> <span data-ttu-id="b3d73-243">相反地，攻擊包含資料的慢速傳送者或接收者。</span><span class="sxs-lookup"><span data-stu-id="b3d73-243">Instead, the attack involves a slow sender or receiver of data.</span></span> <span data-ttu-id="b3d73-244">在等候傳送或接收資料時，如執行緒和可用連線等資源會用盡。</span><span class="sxs-lookup"><span data-stu-id="b3d73-244">While waiting for the data to be sent or received, resources such as threads and available connections are exhausted.</span></span> <span data-ttu-id="b3d73-245">這種情況可能是由於惡意攻擊或慢速網路連線上的合法傳送者/接收者所引起。</span><span class="sxs-lookup"><span data-stu-id="b3d73-245">This situation could arise either as a result of a malicious attack or from a legitimate sender/receiver on a slow network connection.</span></span>

<span data-ttu-id="b3d73-246">如果要降低這些攻擊，請正確設定傳輸逾時。</span><span class="sxs-lookup"><span data-stu-id="b3d73-246">To mitigate these attacks, set the transport time-outs correctly.</span></span> <span data-ttu-id="b3d73-247">如需詳細資訊，請參閱[傳輸配額](transport-quotas.md)。</span><span class="sxs-lookup"><span data-stu-id="b3d73-247">For more information, see [Transport Quotas](transport-quotas.md).</span></span> <span data-ttu-id="b3d73-248">其次，在使用 `Read` `Write` WCF 中的資料流程時，絕對不要使用同步或作業。</span><span class="sxs-lookup"><span data-stu-id="b3d73-248">Secondly, never use synchronous `Read` or `Write` operations when working with streams in WCF.</span></span>

## <a name="using-xml-safely"></a><span data-ttu-id="b3d73-249">安全使用 XML</span><span class="sxs-lookup"><span data-stu-id="b3d73-249">Using XML Safely</span></span>

> [!NOTE]
> <span data-ttu-id="b3d73-250">雖然本節主要與 XML 有關，但其中的資訊也適用於「JavaScript 物件標記法」(JSON) 文件。</span><span class="sxs-lookup"><span data-stu-id="b3d73-250">Although this section is about XML, the information also applies to JavaScript Object Notation (JSON) documents.</span></span> <span data-ttu-id="b3d73-251">使用 [Mapping Between JSON and XML](mapping-between-json-and-xml.md)時，配額的工作方式類似。</span><span class="sxs-lookup"><span data-stu-id="b3d73-251">The quotas work similarly, using [Mapping Between JSON and XML](mapping-between-json-and-xml.md).</span></span>

### <a name="secure-xml-readers"></a><span data-ttu-id="b3d73-252">安全的 XML 讀取器</span><span class="sxs-lookup"><span data-stu-id="b3d73-252">Secure XML Readers</span></span>

<span data-ttu-id="b3d73-253">XML 資訊集形成 WCF 中所有訊息處理的基礎。</span><span class="sxs-lookup"><span data-stu-id="b3d73-253">The XML Infoset forms the basis of all message processing in WCF.</span></span> <span data-ttu-id="b3d73-254">接受來自不受信任來源的 XML 資料時，會有許多必須降低之拒絕服務攻擊的可能性。</span><span class="sxs-lookup"><span data-stu-id="b3d73-254">When accepting XML data from an untrusted source, a number of denial-of-service attack possibilities exist that must be mitigated.</span></span> <span data-ttu-id="b3d73-255">WCF 提供特殊、安全的 XML 讀取器。</span><span class="sxs-lookup"><span data-stu-id="b3d73-255">WCF provides special, secure XML readers.</span></span> <span data-ttu-id="b3d73-256">當使用 WCF 中的其中一個標準編碼（文字、二進位或 MTOM）時，就會自動建立這些讀取器。</span><span class="sxs-lookup"><span data-stu-id="b3d73-256">These readers are created automatically when using one of the standard encodings in WCF (text, binary, or MTOM).</span></span>

<span data-ttu-id="b3d73-257">這些讀取器上有些安全性功能永遠在使用中。</span><span class="sxs-lookup"><span data-stu-id="b3d73-257">Some of the security features on these readers are always active.</span></span> <span data-ttu-id="b3d73-258">例如，讀取器絕對不會處理文件類型定義 (DTD)，它是阻絕服務攻擊的潛在來源，絕對不得出現在合法的 SOAP 訊息中。</span><span class="sxs-lookup"><span data-stu-id="b3d73-258">For example, the readers never process document type definitions (DTDs), which are a potential source of denial-of-service attacks and should never appear in legitimate SOAP messages.</span></span> <span data-ttu-id="b3d73-259">其他的安全性功能包括必須設定的讀取器配額，在下節中將加以說明。</span><span class="sxs-lookup"><span data-stu-id="b3d73-259">Other security features include reader quotas that must be configured, which are described in the following section.</span></span>

<span data-ttu-id="b3d73-260">直接使用 XML 讀取器時（例如在撰寫自己的自訂編碼器時，或直接使用 <xref:System.ServiceModel.Channels.Message> 類別時），如果有機會使用不受信任的資料，請一律使用 WCF 安全的讀取器。</span><span class="sxs-lookup"><span data-stu-id="b3d73-260">When working directly with XML readers (such as when writing your own custom encoder or when working directly with the <xref:System.ServiceModel.Channels.Message> class), always use the WCF secure readers when there is a chance of working with untrusted data.</span></span> <span data-ttu-id="b3d73-261">請呼叫 <xref:System.Xml.XmlDictionaryReader.CreateTextReader%2A>類別上 <xref:System.Xml.XmlDictionaryReader.CreateBinaryReader%2A>、 <xref:System.Xml.XmlDictionaryReader.CreateMtomReader%2A> 或 <xref:System.Xml.XmlDictionaryReader> 的其中一個靜態處理站方法多載，以建立安全的讀取器。</span><span class="sxs-lookup"><span data-stu-id="b3d73-261">Create the secure readers by calling one of the static factory method overloads of <xref:System.Xml.XmlDictionaryReader.CreateTextReader%2A>, <xref:System.Xml.XmlDictionaryReader.CreateBinaryReader%2A>, or <xref:System.Xml.XmlDictionaryReader.CreateMtomReader%2A> on the <xref:System.Xml.XmlDictionaryReader> class.</span></span> <span data-ttu-id="b3d73-262">當建立讀取器時，請傳入安全的配額值。</span><span class="sxs-lookup"><span data-stu-id="b3d73-262">When creating a reader, pass in secure quota values.</span></span> <span data-ttu-id="b3d73-263">請勿呼叫 `Create` 方法多載。</span><span class="sxs-lookup"><span data-stu-id="b3d73-263">Do not call the `Create` method overloads.</span></span> <span data-ttu-id="b3d73-264">這些不會建立 WCF 讀取器。</span><span class="sxs-lookup"><span data-stu-id="b3d73-264">These do not create a WCF reader.</span></span> <span data-ttu-id="b3d73-265">相反地，它們會建立不受本節所述之安全性功能保護的讀取器。</span><span class="sxs-lookup"><span data-stu-id="b3d73-265">Instead, a reader is created that is not protected by the security features described in this section.</span></span>

### <a name="reader-quotas"></a><span data-ttu-id="b3d73-266">讀取器配額</span><span class="sxs-lookup"><span data-stu-id="b3d73-266">Reader Quotas</span></span>

<span data-ttu-id="b3d73-267">安全的 XML 讀取器有五個可設定的配額。</span><span class="sxs-lookup"><span data-stu-id="b3d73-267">The secure XML readers have five configurable quotas.</span></span> <span data-ttu-id="b3d73-268">這些通常是使用編碼繫結項目或標準繫結上之 `ReaderQuotas` 屬性來設定的，或是使用在建立讀取器時傳遞的 <xref:System.Xml.XmlDictionaryReaderQuotas> 物件來設定。</span><span class="sxs-lookup"><span data-stu-id="b3d73-268">These are normally configured using the `ReaderQuotas` property on the encoding binding elements or standard bindings, or by using an <xref:System.Xml.XmlDictionaryReaderQuotas> object passed when creating a reader.</span></span>

#### <a name="maxbytesperread"></a><span data-ttu-id="b3d73-269">MaxBytesPerRead</span><span class="sxs-lookup"><span data-stu-id="b3d73-269">MaxBytesPerRead</span></span>

<span data-ttu-id="b3d73-270">這個配額會限制當讀取項目開始標記和其屬性時，在單一 `Read` 作業中讀取的位元組數目</span><span class="sxs-lookup"><span data-stu-id="b3d73-270">This quota limits the number of bytes that are read in a single `Read` operation when reading the element start tag and its attributes.</span></span> <span data-ttu-id="b3d73-271">(在非資料流處理的情況中，項目名稱本身不會納入配額的計數)。 <xref:System.Xml.XmlDictionaryReaderQuotas.MaxBytesPerRead%2A> 十分重要的原因如下：</span><span class="sxs-lookup"><span data-stu-id="b3d73-271">(In non-streamed cases, the element name itself is not counted against the quota.) <xref:System.Xml.XmlDictionaryReaderQuotas.MaxBytesPerRead%2A> is important for the following reasons:</span></span>

- <span data-ttu-id="b3d73-272">當讀取項目名稱和其屬性時，它們一定會進入緩衝記憶體。</span><span class="sxs-lookup"><span data-stu-id="b3d73-272">The element name and its attributes are always buffered in memory when they are being read.</span></span> <span data-ttu-id="b3d73-273">因此，在資料流處理模式中正確設定此配額是很重要的，以防止在應該進行資料流處理時有過度的緩衝處理。</span><span class="sxs-lookup"><span data-stu-id="b3d73-273">Therefore, it is important to set this quota correctly in streaming mode to prevent excessive buffering when streaming is expected.</span></span> <span data-ttu-id="b3d73-274">如需有關會發生之實際緩衝處理量的資訊，請參閱 `MaxDepth` 配額一節。</span><span class="sxs-lookup"><span data-stu-id="b3d73-274">See the `MaxDepth` quota section for information about the actual amount of buffering that takes place.</span></span>

- <span data-ttu-id="b3d73-275">使用太多 XML 屬性可能會耗盡不當比例的處理時間，因為必須檢查屬性名稱的唯一性。</span><span class="sxs-lookup"><span data-stu-id="b3d73-275">Having too many XML attributes may use up disproportionate processing time because attribute names have to be checked for uniqueness.</span></span> <span data-ttu-id="b3d73-276">`MaxBytesPerRead` 可降低這個威脅。</span><span class="sxs-lookup"><span data-stu-id="b3d73-276">`MaxBytesPerRead` mitigates this threat.</span></span>

#### <a name="maxdepth"></a><span data-ttu-id="b3d73-277">MaxDepth</span><span class="sxs-lookup"><span data-stu-id="b3d73-277">MaxDepth</span></span>

<span data-ttu-id="b3d73-278">這個配額會限制 XML 項目的最大巢狀結構深度。</span><span class="sxs-lookup"><span data-stu-id="b3d73-278">This quota limits the maximum nesting depth of XML elements.</span></span> <span data-ttu-id="b3d73-279">例如，檔 " \<A> \<B> \<C/> \</B> \</A> " 的嵌套深度為三。</span><span class="sxs-lookup"><span data-stu-id="b3d73-279">For example, the document "\<A>\<B>\<C/>\</B>\</A>" has a nesting depth of three.</span></span> <span data-ttu-id="b3d73-280"><xref:System.Xml.XmlDictionaryReaderQuotas.MaxDepth%2A> 十分重要的原因如下：</span><span class="sxs-lookup"><span data-stu-id="b3d73-280"><xref:System.Xml.XmlDictionaryReaderQuotas.MaxDepth%2A> is important for the following reasons:</span></span>

- <span data-ttu-id="b3d73-281">`MaxDepth` 會與 `MaxBytesPerRead`互動：由於讀取器永遠會為目前項目和其所有祖系將資料保存在記憶體中，因此讀取器的最大記憶體消耗與這兩個設定的產品是成比例的。</span><span class="sxs-lookup"><span data-stu-id="b3d73-281">`MaxDepth` interacts with `MaxBytesPerRead`: the reader always keeps data in memory for the current element and all of its ancestors, so the maximum memory consumption of the reader is proportional to the product of these two settings.</span></span>

- <span data-ttu-id="b3d73-282">當還原序列化深度巢狀物件圖形時，會強制還原序列化程式存取整個堆疊並擲回無法復原的 <xref:System.StackOverflowException>。</span><span class="sxs-lookup"><span data-stu-id="b3d73-282">When deserializing a deeply-nested object graph, the deserializer is forced to access the entire stack and throw an unrecoverable <xref:System.StackOverflowException>.</span></span> <span data-ttu-id="b3d73-283">在 <xref:System.Runtime.Serialization.DataContractSerializer> 和 <xref:System.Xml.Serialization.XmlSerializer>兩者的 XML 巢狀結構和物件巢狀結構之間有直接的相互關聯。</span><span class="sxs-lookup"><span data-stu-id="b3d73-283">A direct correlation exists between XML nesting and object nesting for both the <xref:System.Runtime.Serialization.DataContractSerializer> and the <xref:System.Xml.Serialization.XmlSerializer>.</span></span> <span data-ttu-id="b3d73-284">請使用 `MaxDepth` 來降低這個威脅。</span><span class="sxs-lookup"><span data-stu-id="b3d73-284">Use `MaxDepth` to mitigate this threat.</span></span>

#### <a name="maxnametablecharcount"></a><span data-ttu-id="b3d73-285">MaxNameTableCharCount</span><span class="sxs-lookup"><span data-stu-id="b3d73-285">MaxNameTableCharCount</span></span>

<span data-ttu-id="b3d73-286">這個配額會限制讀取器的「 *名稱表格*」(Nametable) 大小。</span><span class="sxs-lookup"><span data-stu-id="b3d73-286">This quota limits the size of the reader’s *nametable*.</span></span> <span data-ttu-id="b3d73-287">名稱表格包含會在處理 XML 文件時遇到的特定字串 (例如命名空間和前置詞)。</span><span class="sxs-lookup"><span data-stu-id="b3d73-287">The nametable contains certain strings (such as namespaces and prefixes) that are encountered when processing an XML document.</span></span> <span data-ttu-id="b3d73-288">當這些字串在緩衝記憶體中時，請設定這個配額，以防止在應該進行資料流處理時有過度緩衝處理。</span><span class="sxs-lookup"><span data-stu-id="b3d73-288">As these strings are buffered in memory, set this quota to prevent excessive buffering when streaming is expected.</span></span>

#### <a name="maxstringcontentlength"></a><span data-ttu-id="b3d73-289">MaxStringContentLength</span><span class="sxs-lookup"><span data-stu-id="b3d73-289">MaxStringContentLength</span></span>

<span data-ttu-id="b3d73-290">這個配額會限制 XML 讀取器傳回的字串大小上限。</span><span class="sxs-lookup"><span data-stu-id="b3d73-290">This quota limits the maximum string size that the XML reader returns.</span></span> <span data-ttu-id="b3d73-291">這個配額不會限制 XML 讀取器本身的記憶體消耗，但會限制正在使用讀取器之元件中的記憶體消耗。</span><span class="sxs-lookup"><span data-stu-id="b3d73-291">This quota does not limit memory consumption in the XML reader itself, but in the component that is using the reader.</span></span> <span data-ttu-id="b3d73-292">例如，當 <xref:System.Runtime.Serialization.DataContractSerializer> 使用以 <xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A>保護的讀取器時，它不會還原序列化大於這個配額的字串。</span><span class="sxs-lookup"><span data-stu-id="b3d73-292">For example, when the <xref:System.Runtime.Serialization.DataContractSerializer> uses a reader secured with <xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A>, it does not deserialize strings larger than this quota.</span></span> <span data-ttu-id="b3d73-293">當直接使用 <xref:System.Xml.XmlDictionaryReader> 類別時，不是所有的方法都會使用這個配額，而是只有特別設計來讀取字串的方法，例如 <xref:System.Xml.XmlDictionaryReader.ReadContentAsString%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="b3d73-293">When using the <xref:System.Xml.XmlDictionaryReader> class directly, not all methods respect this quota, but only the methods that are specifically designed to read strings, such as the <xref:System.Xml.XmlDictionaryReader.ReadContentAsString%2A> method.</span></span> <span data-ttu-id="b3d73-294">由於讀取器上的 <xref:System.Xml.XmlReader.Value%2A> 屬性不會受到這個配額影響，因此不應在需要這個配額所提供的保護時使用。</span><span class="sxs-lookup"><span data-stu-id="b3d73-294">The <xref:System.Xml.XmlReader.Value%2A> property on the reader is not affected by this quota, and thus should not be used when the protection this quota provides is necessary.</span></span>

#### <a name="maxarraylength"></a><span data-ttu-id="b3d73-295">MaxArrayLength</span><span class="sxs-lookup"><span data-stu-id="b3d73-295">MaxArrayLength</span></span>

<span data-ttu-id="b3d73-296">這個配額會限制 XML 讀取器將會傳回之基本陣列的大小上限，包括位元組陣列。</span><span class="sxs-lookup"><span data-stu-id="b3d73-296">This quota limits the maximum size of an array of primitives that the XML reader returns, including byte arrays.</span></span> <span data-ttu-id="b3d73-297">這個配額不會限制 XML 讀取器本身的記憶體消耗，但會限制正在使用讀取器之任何元件中的記憶體消耗。</span><span class="sxs-lookup"><span data-stu-id="b3d73-297">This quota does not limit memory consumption in the XML reader itself, but in whatever component that is using the reader.</span></span> <span data-ttu-id="b3d73-298">例如，當 <xref:System.Runtime.Serialization.DataContractSerializer> 使用以 <xref:System.Xml.XmlDictionaryReaderQuotas.MaxArrayLength%2A>保護的讀取器時，它不會還原序列化大於這個配額的位元組陣列。</span><span class="sxs-lookup"><span data-stu-id="b3d73-298">For example, when the <xref:System.Runtime.Serialization.DataContractSerializer> uses a reader secured with <xref:System.Xml.XmlDictionaryReaderQuotas.MaxArrayLength%2A>, it does not deserialize byte arrays larger than this quota.</span></span> <span data-ttu-id="b3d73-299">當嘗試在單一合約中混合資料流和緩衝處理的程式撰寫模型時，設定這個配額是很重要的。</span><span class="sxs-lookup"><span data-stu-id="b3d73-299">It is important to set this quota when attempting to mix streaming and buffered programming models in a single contract.</span></span> <span data-ttu-id="b3d73-300">請記住，當直接使用 <xref:System.Xml.XmlDictionaryReader> 類別時，只有特別設計來讀取特定基本型別之任意大小之陣列的方法 (例如 <xref:System.Xml.XmlDictionaryReader.ReadInt32Array%2A>) 會使用這個配額。</span><span class="sxs-lookup"><span data-stu-id="b3d73-300">Keep in mind that when using the <xref:System.Xml.XmlDictionaryReader> class directly, only the methods that are specifically designed to read arrays of arbitrary size of certain primitive types, such as <xref:System.Xml.XmlDictionaryReader.ReadInt32Array%2A>, respect this quota.</span></span>

## <a name="threats-specific-to-the-binary-encoding"></a><span data-ttu-id="b3d73-301">二進位編碼特定的威脅</span><span class="sxs-lookup"><span data-stu-id="b3d73-301">Threats Specific to the Binary Encoding</span></span>

<span data-ttu-id="b3d73-302">WCF 支援的二進位 XML 編碼包含*字典字串*功能。</span><span class="sxs-lookup"><span data-stu-id="b3d73-302">The binary XML encoding WCF supports includes a *dictionary strings* feature.</span></span> <span data-ttu-id="b3d73-303">只要使用幾個位元組就可以編碼大型字串。</span><span class="sxs-lookup"><span data-stu-id="b3d73-303">A large string may be encoded using only a few bytes.</span></span> <span data-ttu-id="b3d73-304">這雖然可以獲得可觀的效能，但也會引入必須降低的新阻絕服務威脅。</span><span class="sxs-lookup"><span data-stu-id="b3d73-304">This enables significant performance gains, but introduces new denial-of-service threats that must be mitigated.</span></span>

<span data-ttu-id="b3d73-305">字典有兩種：「 *靜態* 」(Static) 和「 *動態*」(Dynamic)。</span><span class="sxs-lookup"><span data-stu-id="b3d73-305">There are two kinds of dictionaries: *static* and *dynamic*.</span></span> <span data-ttu-id="b3d73-306">靜態字典是內建的長字串清單，可使用二進位編碼中的簡短程式碼來表示。</span><span class="sxs-lookup"><span data-stu-id="b3d73-306">The static dictionary is a built-in list of long strings that may be represented using a short code in the binary encoding.</span></span> <span data-ttu-id="b3d73-307">當讀取器建立且無法修改時，這份字串清單是固定的。</span><span class="sxs-lookup"><span data-stu-id="b3d73-307">This list of strings is fixed when the reader is created and cannot be modified.</span></span> <span data-ttu-id="b3d73-308">根據預設，WCF 使用之靜態字典中的字串都不會有足夠的大小來造成嚴重的阻絕服務威脅，雖然它們仍然可以在字典擴充攻擊中使用。</span><span class="sxs-lookup"><span data-stu-id="b3d73-308">None of the strings in the static dictionary that WCF uses by default are sufficiently large to pose a serious denial-of-service threat, although they may still be used in a dictionary expansion attack.</span></span> <span data-ttu-id="b3d73-309">在您提供自己的靜態字典之進階狀況中，在引入大型字典字串時請小心。</span><span class="sxs-lookup"><span data-stu-id="b3d73-309">In advanced scenarios where you supply your own static dictionary, be careful when introducing large dictionary strings.</span></span>

<span data-ttu-id="b3d73-310">動態字典功能可讓訊息定義自己的字串，並與簡短程式碼建立關聯。</span><span class="sxs-lookup"><span data-stu-id="b3d73-310">The dynamic dictionaries feature allows messages to define their own strings and associate them with short codes.</span></span> <span data-ttu-id="b3d73-311">在整個通訊工作階段期間，這些字串與程式碼的對應會保存在記憶體中，讓後續的訊息不必重新傳送字串，並且可以使用已經定義的程式碼。</span><span class="sxs-lookup"><span data-stu-id="b3d73-311">These string-to-code mappings are kept in memory during the entire communication session, such that subsequent messages do not have to resend the strings and can utilize codes that are already defined.</span></span> <span data-ttu-id="b3d73-312">這些字串可能有任意長度，因而引起比靜態字典中更嚴重的威脅。</span><span class="sxs-lookup"><span data-stu-id="b3d73-312">These strings may be of arbitrary length and thus pose a more serious threat than those in the static dictionary.</span></span>

<span data-ttu-id="b3d73-313">第一個必須降低的威脅是動態字典 (字串與程式碼的對應表格) 變得太大的可能性。</span><span class="sxs-lookup"><span data-stu-id="b3d73-313">The first threat that must be mitigated is the possibility of the dynamic dictionary (the string-to-code mapping table) becoming too large.</span></span> <span data-ttu-id="b3d73-314">這個字典可能會展開至數個訊息，所以 `MaxReceivedMessageSize` 配額無法提供保護，因為它只能分別套用至各個訊息。</span><span class="sxs-lookup"><span data-stu-id="b3d73-314">This dictionary may be expanded over the course of several messages, and so the `MaxReceivedMessageSize` quota offers no protection because it applies only to each message separately.</span></span> <span data-ttu-id="b3d73-315">因此， <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement.MaxSessionSize%2A> 上有獨立的 <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement> 屬性，限制字典的大小。</span><span class="sxs-lookup"><span data-stu-id="b3d73-315">Therefore, a separate <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement.MaxSessionSize%2A> property exists on the <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement> that limits the size of the dictionary.</span></span>

<span data-ttu-id="b3d73-316">與其他大部分配額不同的是，這個配額也適用於撰寫訊息時。</span><span class="sxs-lookup"><span data-stu-id="b3d73-316">Unlike most other quotas, this quota also applies when writing messages.</span></span> <span data-ttu-id="b3d73-317">如果在讀取訊息時超過這個配額，便會如往常般擲回 `QuotaExceededException` 。</span><span class="sxs-lookup"><span data-stu-id="b3d73-317">If it is exceeded when reading a message, the `QuotaExceededException` is thrown as usual.</span></span> <span data-ttu-id="b3d73-318">如果在撰寫訊息時超過這個配額，就會依原狀寫入造成超過配額的字串，而不需使用動態字典功能。</span><span class="sxs-lookup"><span data-stu-id="b3d73-318">If it is exceeded when writing a message, any strings that cause the quota to be exceeded are written as-is, without using the dynamic dictionaries feature.</span></span>

### <a name="dictionary-expansion-threats"></a><span data-ttu-id="b3d73-319">字典展開威脅</span><span class="sxs-lookup"><span data-stu-id="b3d73-319">Dictionary Expansion Threats</span></span>

<span data-ttu-id="b3d73-320">二進位特定攻擊的一個顯著類別是由於字典展開所引起的。</span><span class="sxs-lookup"><span data-stu-id="b3d73-320">A significant class of binary-specific attacks arises from dictionary expansion.</span></span> <span data-ttu-id="b3d73-321">如果廣泛利用字串字典功能，使用二進位形式的小型訊息可能會變成使用完整展開之文字形式的超大型訊息。</span><span class="sxs-lookup"><span data-stu-id="b3d73-321">A small message in binary form may turn into a very large message in fully expanded textual form if it makes extensive use of the string dictionaries feature.</span></span> <span data-ttu-id="b3d73-322">動態字典字串的展開因數會受到 <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement.MaxSessionSize%2A> 配額的限制，因為動態字典字串不會超過整個字典的大小上限。</span><span class="sxs-lookup"><span data-stu-id="b3d73-322">The expansion factor for dynamic dictionary strings is limited by the <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement.MaxSessionSize%2A> quota, because no dynamic dictionary string exceeds the maximum size of the entire dictionary.</span></span>

<span data-ttu-id="b3d73-323"><xref:System.Xml.XmlDictionaryReaderQuotas.MaxNameTableCharCount%2A>、 `MaxStringContentLength`和 `MaxArrayLength` 屬性只限制記憶體消耗。</span><span class="sxs-lookup"><span data-stu-id="b3d73-323">The <xref:System.Xml.XmlDictionaryReaderQuotas.MaxNameTableCharCount%2A>, `MaxStringContentLength`, and `MaxArrayLength` properties only limit memory consumption.</span></span> <span data-ttu-id="b3d73-324">通常不需要它們來降低非資料流使用中的威脅，因為記憶體使用已經受到 `MaxReceivedMessageSize`的限制。</span><span class="sxs-lookup"><span data-stu-id="b3d73-324">They are normally not required to mitigate any threats in the non-streamed usage because memory usage is already limited by `MaxReceivedMessageSize`.</span></span> <span data-ttu-id="b3d73-325">然而， `MaxReceivedMessageSize` 會計算預先展開的位元組。</span><span class="sxs-lookup"><span data-stu-id="b3d73-325">However, `MaxReceivedMessageSize` counts pre-expansion bytes.</span></span> <span data-ttu-id="b3d73-326">當二進位編碼正在使用中時，記憶體消耗有可能會超過 `MaxReceivedMessageSize`，其只受到 <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement.MaxSessionSize%2A>因數的限制。</span><span class="sxs-lookup"><span data-stu-id="b3d73-326">When binary encoding is in use, memory consumption could potentially go beyond `MaxReceivedMessageSize`, limited only by a factor of <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement.MaxSessionSize%2A>.</span></span> <span data-ttu-id="b3d73-327">因此，當使用二進位編碼時，永遠設定所有的讀取器配額 (特別是 <xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A>) 是很重要的。</span><span class="sxs-lookup"><span data-stu-id="b3d73-327">For this reason, it is important to always set all of the reader quotas (especially <xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A>) when using the binary encoding.</span></span>

<span data-ttu-id="b3d73-328">當搭配使用二進位編碼和 <xref:System.Runtime.Serialization.DataContractSerializer>時， `IExtensibleDataObject` 介面可能會誤用來掛接字典展開攻擊。</span><span class="sxs-lookup"><span data-stu-id="b3d73-328">When using binary encoding together with the <xref:System.Runtime.Serialization.DataContractSerializer>, the `IExtensibleDataObject` interface can be misused to mount a dictionary expansion attack.</span></span> <span data-ttu-id="b3d73-329">這個介面基本上是為不屬於合約之任意資料提供無限制的儲存區。</span><span class="sxs-lookup"><span data-stu-id="b3d73-329">This interface essentially provides unlimited storage for arbitrary data that is not a part of the contract.</span></span> <span data-ttu-id="b3d73-330">如果無法將配額設定得夠低，讓 `MaxSessionSize` 乘以 `MaxReceivedMessageSize` 不會引起問題，當使用二進位編碼時，請停用 `IExtensibleDataObject` 功能。</span><span class="sxs-lookup"><span data-stu-id="b3d73-330">If quotas cannot be set low enough such that `MaxSessionSize` multiplied by `MaxReceivedMessageSize` does not pose a problem, disable the `IExtensibleDataObject` feature when using the binary encoding.</span></span> <span data-ttu-id="b3d73-331">請將 `IgnoreExtensionDataObject` 屬性 (Attribute) 上的 `true` 屬性 (Property) 設定為 `ServiceBehaviorAttribute` 。</span><span class="sxs-lookup"><span data-stu-id="b3d73-331">Set the `IgnoreExtensionDataObject` property to `true` on the `ServiceBehaviorAttribute` attribute.</span></span> <span data-ttu-id="b3d73-332">或者，請不要實作 `IExtensibleDataObject` 介面。</span><span class="sxs-lookup"><span data-stu-id="b3d73-332">Alternatively, do not implement the `IExtensibleDataObject` interface.</span></span> <span data-ttu-id="b3d73-333">如需詳細資訊，請參閱[向前相容資料合約](forward-compatible-data-contracts.md)。</span><span class="sxs-lookup"><span data-stu-id="b3d73-333">For more information, see [Forward-Compatible Data Contracts](forward-compatible-data-contracts.md).</span></span>

### <a name="quotas-summary"></a><span data-ttu-id="b3d73-334">配額摘要</span><span class="sxs-lookup"><span data-stu-id="b3d73-334">Quotas Summary</span></span>

<span data-ttu-id="b3d73-335">下表為有關配額的指引摘要。</span><span class="sxs-lookup"><span data-stu-id="b3d73-335">The following table summarizes the guidance about quotas.</span></span>

|<span data-ttu-id="b3d73-336">條件</span><span class="sxs-lookup"><span data-stu-id="b3d73-336">Condition</span></span>|<span data-ttu-id="b3d73-337">要設定的重要配額</span><span class="sxs-lookup"><span data-stu-id="b3d73-337">Important quotas to set</span></span>|
|---------------|-----------------------------|
|<span data-ttu-id="b3d73-338">沒有資料流或資料流處理小型訊息、文字或 MTOM 編碼</span><span class="sxs-lookup"><span data-stu-id="b3d73-338">No streaming or streaming small messages, text, or MTOM encoding</span></span>|<span data-ttu-id="b3d73-339">`MaxReceivedMessageSize`、`MaxBytesPerRead` 和 `MaxDepth`</span><span class="sxs-lookup"><span data-stu-id="b3d73-339">`MaxReceivedMessageSize`, `MaxBytesPerRead`, and `MaxDepth`</span></span>|
|<span data-ttu-id="b3d73-340">沒有資料流或資料流處理小型訊息、二進位編碼</span><span class="sxs-lookup"><span data-stu-id="b3d73-340">No streaming or streaming small messages, binary encoding</span></span>|<span data-ttu-id="b3d73-341">`MaxReceivedMessageSize`、 `MaxSessionSize`和所有的 `ReaderQuotas`</span><span class="sxs-lookup"><span data-stu-id="b3d73-341">`MaxReceivedMessageSize`, `MaxSessionSize`, and all `ReaderQuotas`</span></span>|
|<span data-ttu-id="b3d73-342">資料流處理大型訊息、文字或 MTOM 編碼</span><span class="sxs-lookup"><span data-stu-id="b3d73-342">Streaming large messages, text, or MTOM encoding</span></span>|<span data-ttu-id="b3d73-343">`MaxBufferSize` 和所有的 `ReaderQuotas`</span><span class="sxs-lookup"><span data-stu-id="b3d73-343">`MaxBufferSize` and all `ReaderQuotas`</span></span>|
|<span data-ttu-id="b3d73-344">資料流處理大型訊息、二進位編碼</span><span class="sxs-lookup"><span data-stu-id="b3d73-344">Streaming large messages, binary encoding</span></span>|<span data-ttu-id="b3d73-345">`MaxBufferSize`、 `MaxSessionSize`和所有的 `ReaderQuotas`</span><span class="sxs-lookup"><span data-stu-id="b3d73-345">`MaxBufferSize`, `MaxSessionSize`, and all `ReaderQuotas`</span></span>|

- <span data-ttu-id="b3d73-346">當資料流正在使用中時，不論是否正在資料流處理大型或小型訊息，永遠必須設定傳輸層逾時且不得使用同步讀取/寫入。</span><span class="sxs-lookup"><span data-stu-id="b3d73-346">Transport-level time-outs must always be set and never use synchronous reads/writes when streaming is in use, regardless of whether you are streaming large or small messages.</span></span>

- <span data-ttu-id="b3d73-347">如果對配額有問題，請將它設定為安全值，而不要將其保留為開放。</span><span class="sxs-lookup"><span data-stu-id="b3d73-347">When in doubt about a quota, set it to a safe value rather than leaving it open.</span></span>

## <a name="preventing-malicious-code-execution"></a><span data-ttu-id="b3d73-348">防止惡意程式碼執行</span><span class="sxs-lookup"><span data-stu-id="b3d73-348">Preventing Malicious Code Execution</span></span>

<span data-ttu-id="b3d73-349">威脅的下列一般類別可以執行程式碼並造成非預期的影響：</span><span class="sxs-lookup"><span data-stu-id="b3d73-349">The following general classes of threats can execute code and have unintended effects:</span></span>

- <span data-ttu-id="b3d73-350">還原序列化程式會載入惡意、不安全或安全性敏感的型別。</span><span class="sxs-lookup"><span data-stu-id="b3d73-350">The deserializer loads a malicious, unsafe, or security-sensitive type.</span></span>

- <span data-ttu-id="b3d73-351">傳入訊息會造成還原序列化程式以具有非預期結果的方式，來建構通常是安全之型別的執行個體。</span><span class="sxs-lookup"><span data-stu-id="b3d73-351">An incoming message causes the deserializer to construct an instance of a normally safe type in such a way that it has unintended consequences.</span></span>

<span data-ttu-id="b3d73-352">下列各節將進一步說明威脅的這些類別。</span><span class="sxs-lookup"><span data-stu-id="b3d73-352">The following sections discuss these classes of threats further.</span></span>

## <a name="datacontractserializer"></a><span data-ttu-id="b3d73-353">DataContractSerializer</span><span class="sxs-lookup"><span data-stu-id="b3d73-353">DataContractSerializer</span></span>

<span data-ttu-id="b3d73-354">（如需有關的安全性資訊 <xref:System.Xml.Serialization.XmlSerializer> ，請參閱相關檔。）的安全性模型與的 <xref:System.Xml.Serialization.XmlSerializer> 類似 <xref:System.Runtime.Serialization.DataContractSerializer> ，而且大部分的細節都不同。</span><span class="sxs-lookup"><span data-stu-id="b3d73-354">(For security information on the <xref:System.Xml.Serialization.XmlSerializer>, see the relevant documentation.) The security model for the <xref:System.Xml.Serialization.XmlSerializer> is similar to that of the <xref:System.Runtime.Serialization.DataContractSerializer>, and differs mostly in details.</span></span> <span data-ttu-id="b3d73-355">例如， <xref:System.Xml.Serialization.XmlIncludeAttribute> 屬性是用於型別內含而不是 <xref:System.Runtime.Serialization.KnownTypeAttribute> 屬性。</span><span class="sxs-lookup"><span data-stu-id="b3d73-355">For example, the <xref:System.Xml.Serialization.XmlIncludeAttribute> attribute is used for type inclusion instead of the <xref:System.Runtime.Serialization.KnownTypeAttribute> attribute.</span></span> <span data-ttu-id="b3d73-356">然而，本主題稍後將說明 <xref:System.Xml.Serialization.XmlSerializer> 的一些專有威脅。</span><span class="sxs-lookup"><span data-stu-id="b3d73-356">However, some threats unique to the <xref:System.Xml.Serialization.XmlSerializer> are discussed later in this topic.</span></span>

### <a name="preventing-unintended-types-from-being-loaded"></a><span data-ttu-id="b3d73-357">防止載入非預期的型別</span><span class="sxs-lookup"><span data-stu-id="b3d73-357">Preventing Unintended Types from Being Loaded</span></span>

<span data-ttu-id="b3d73-358">載入非預期的型別可能會有重大的影響，不論此型別是否為惡意或只是有安全性敏感的副作用。</span><span class="sxs-lookup"><span data-stu-id="b3d73-358">Loading unintended types may have significant consequences, whether the type is malicious or just has security-sensitive side effects.</span></span> <span data-ttu-id="b3d73-359">型別可能含有可利用的安全性弱點、在其建構函式或類別建構函式中執行安全性敏感的動作、具有加速阻絕服務攻擊的大型記憶體使用量，或是擲回不可復原的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="b3d73-359">A type may contain exploitable security vulnerability, perform security-sensitive actions in its constructor or class constructor, have a large memory footprint that facilitates denial-of-service attacks, or may throw non-recoverable exceptions.</span></span> <span data-ttu-id="b3d73-360">型別可能會具有類別建構函式，會在載入型別時及建立執行個體之前立刻執行。</span><span class="sxs-lookup"><span data-stu-id="b3d73-360">Types may have class constructors that run as soon as the type is loaded and before any instances are created.</span></span> <span data-ttu-id="b3d73-361">因此，控制還原序列化程式可能會載入的這組型別十分重要。</span><span class="sxs-lookup"><span data-stu-id="b3d73-361">For these reasons, it is important to control the set of types that the deserializer may load.</span></span>

<span data-ttu-id="b3d73-362"><xref:System.Runtime.Serialization.DataContractSerializer> 會以有彈性的方式來還原序列化。</span><span class="sxs-lookup"><span data-stu-id="b3d73-362">The <xref:System.Runtime.Serialization.DataContractSerializer> deserializes in a loosely coupled way.</span></span> <span data-ttu-id="b3d73-363">它絕對不會從傳入資料讀取 Common Language Runtime (CLR) 型別和組件名稱。</span><span class="sxs-lookup"><span data-stu-id="b3d73-363">It never reads common language runtime (CLR) type and assembly names from the incoming data.</span></span> <span data-ttu-id="b3d73-364">雖然這與 <xref:System.Xml.Serialization.XmlSerializer>的行為類似，但是與 <xref:System.Runtime.Serialization.NetDataContractSerializer>、 <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter>和 <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter>的行為不同。</span><span class="sxs-lookup"><span data-stu-id="b3d73-364">This is similar to the behavior of the <xref:System.Xml.Serialization.XmlSerializer>, but differs from the behavior of the <xref:System.Runtime.Serialization.NetDataContractSerializer>, <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter>, and the <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter>.</span></span> <span data-ttu-id="b3d73-365">有彈性的結合可增加某種程度的安全性，因為遠端攻擊者無法只藉由在訊息中命名該型別，來指出要載入的任意型別。</span><span class="sxs-lookup"><span data-stu-id="b3d73-365">Loose coupling introduces a degree of safety, because the remote attacker cannot indicate an arbitrary type to load just by naming that type in the message.</span></span>

<span data-ttu-id="b3d73-366"><xref:System.Runtime.Serialization.DataContractSerializer> 永遠可以載入根據合約目前應載入的型別。</span><span class="sxs-lookup"><span data-stu-id="b3d73-366">The <xref:System.Runtime.Serialization.DataContractSerializer> is always allowed to load a type that is currently expected according to the contract.</span></span> <span data-ttu-id="b3d73-367">例如，如果資料合約有型別 `Customer`的資料成員， <xref:System.Runtime.Serialization.DataContractSerializer> 就可以在還原序列化此資料成員時載入 `Customer` 型別。</span><span class="sxs-lookup"><span data-stu-id="b3d73-367">For example, if a data contract has a data member of type `Customer`, the <xref:System.Runtime.Serialization.DataContractSerializer> is allowed to load the `Customer` type when it deserializes this data member.</span></span>

<span data-ttu-id="b3d73-368">此外， <xref:System.Runtime.Serialization.DataContractSerializer> 支援多型。</span><span class="sxs-lookup"><span data-stu-id="b3d73-368">Additionally, the <xref:System.Runtime.Serialization.DataContractSerializer> supports polymorphism.</span></span> <span data-ttu-id="b3d73-369">雖然資料成員可宣告為 <xref:System.Object>，但是傳入資料可能會包含 `Customer` 執行個體。</span><span class="sxs-lookup"><span data-stu-id="b3d73-369">A data member may be declared as <xref:System.Object>, but the incoming data may contain a `Customer` instance.</span></span> <span data-ttu-id="b3d73-370">這只有在 `Customer` 型別已透過下列其中一種機制，成為還原序列化程式的「已知」型別時，才有可能發生：</span><span class="sxs-lookup"><span data-stu-id="b3d73-370">This is possible only if the `Customer` type has been made "known" to the deserializer through one of these mechanisms:</span></span>

- <span data-ttu-id="b3d73-371">套用至型別的<xref:System.Runtime.Serialization.KnownTypeAttribute> 屬性。</span><span class="sxs-lookup"><span data-stu-id="b3d73-371"><xref:System.Runtime.Serialization.KnownTypeAttribute> attribute applied to a type.</span></span>

- <span data-ttu-id="b3d73-372">指定傳回型別清單之方法的`KnownTypeAttribute` 屬性。</span><span class="sxs-lookup"><span data-stu-id="b3d73-372">`KnownTypeAttribute` attribute specifying a method that returns a list of types.</span></span>

- <span data-ttu-id="b3d73-373">`ServiceKnownTypeAttribute` 屬性。</span><span class="sxs-lookup"><span data-stu-id="b3d73-373">`ServiceKnownTypeAttribute` attribute.</span></span>

- <span data-ttu-id="b3d73-374">`KnownTypes` 組態區段。</span><span class="sxs-lookup"><span data-stu-id="b3d73-374">The `KnownTypes` configuration section.</span></span>

- <span data-ttu-id="b3d73-375">如果直接使用序列化程式，已知類型的清單會在建構期間明確傳遞至 <xref:System.Runtime.Serialization.DataContractSerializer> 。</span><span class="sxs-lookup"><span data-stu-id="b3d73-375">A list of known types explicitly passed to the <xref:System.Runtime.Serialization.DataContractSerializer> during construction, if using the serializer directly.</span></span>

<span data-ttu-id="b3d73-376">上述各機制都會引入更多還原序列化程式可以載入的型別，以增加表面區域。</span><span class="sxs-lookup"><span data-stu-id="b3d73-376">Each of these mechanisms increases the surface area by introducing more types that the deserializer can load.</span></span> <span data-ttu-id="b3d73-377">請控制上述各機制，以確保不會將惡意或非預期的類型新增至已知類型清單。</span><span class="sxs-lookup"><span data-stu-id="b3d73-377">Control each of these mechanisms to ensure no malicious or unintended types are added to the known types list.</span></span>

<span data-ttu-id="b3d73-378">只要已知類型在範圍內，就可以隨時載入，而且即使合約禁止實際使用它，仍可以建立此類型的執行個體。</span><span class="sxs-lookup"><span data-stu-id="b3d73-378">Once a known type is in scope, it can be loaded at any time, and instances of the type can be created, even if the contract forbids actually using it.</span></span> <span data-ttu-id="b3d73-379">例如，假設使用上述其中一個機制將類型 "MyDangerousType" 新增至已知類型清單。</span><span class="sxs-lookup"><span data-stu-id="b3d73-379">For example, suppose the type "MyDangerousType" is added to the known types list using one of the mechanisms above.</span></span> <span data-ttu-id="b3d73-380">這表示：</span><span class="sxs-lookup"><span data-stu-id="b3d73-380">This means that:</span></span>

- <span data-ttu-id="b3d73-381">`MyDangerousType` 已載入且其類別建構函式正在執行。</span><span class="sxs-lookup"><span data-stu-id="b3d73-381">`MyDangerousType` is loaded and its class constructor runs.</span></span>

- <span data-ttu-id="b3d73-382">即使在還原序列化含有字串資料成員的資料合約時，惡意訊息仍然可能會造成建立 `MyDangerousType` 的執行個體。</span><span class="sxs-lookup"><span data-stu-id="b3d73-382">Even when deserializing a data contract with a string data member, a malicious message may still cause an instance of `MyDangerousType` to create.</span></span> <span data-ttu-id="b3d73-383">`MyDangerousType`中的程式碼 (例如屬性 setter) 可能會執行。</span><span class="sxs-lookup"><span data-stu-id="b3d73-383">Code in `MyDangerousType`, such as property setters, may run.</span></span> <span data-ttu-id="b3d73-384">完成這項操作之後，還原序列化程式會嘗試將這個執行個體指派給字串資料成員，然後失敗並有例外狀況。</span><span class="sxs-lookup"><span data-stu-id="b3d73-384">After this is done, the deserializer tries to assign this instance to the string data member and fail with an exception.</span></span>

<span data-ttu-id="b3d73-385">當撰寫傳回已知類型清單的方法時，或將清單直接傳遞至 <xref:System.Runtime.Serialization.DataContractSerializer> 建構函式時，請確保準備清單的程式碼是安全的，並且只在受信任的資料上作業。</span><span class="sxs-lookup"><span data-stu-id="b3d73-385">When writing a method that returns a list of known types, or when passing a list directly to the <xref:System.Runtime.Serialization.DataContractSerializer> constructor, ensure that the code that prepares the list is secure and operates only on trusted data.</span></span>

<span data-ttu-id="b3d73-386">如果在組態中指定已知類型，請確保組態檔是安全的。</span><span class="sxs-lookup"><span data-stu-id="b3d73-386">If specifying known types in configuration, ensure that the configuration file is secure.</span></span> <span data-ttu-id="b3d73-387">請永遠在組態中使用強式名稱 (藉由指定型別所在之已簽署組件的公開金鑰)，但不指定要載入之型別的版本。</span><span class="sxs-lookup"><span data-stu-id="b3d73-387">Always use strong names in configuration (by specifying the public key of the signed assembly where the type resides), but do not specify the version of the type to load.</span></span> <span data-ttu-id="b3d73-388">型別載入器會自動選取最新版本 (如果可能)。</span><span class="sxs-lookup"><span data-stu-id="b3d73-388">The type loader automatically picks the latest version, if possible.</span></span> <span data-ttu-id="b3d73-389">如果在組態中指定特定版本，就會有下列風險：型別可能會有在未來版本中可能會修正的安全性弱點，但有弱點的版本仍將會載入，因為它在組態中已明確指定。</span><span class="sxs-lookup"><span data-stu-id="b3d73-389">If you specify a particular version in configuration, you run the following risk: A type may have a security vulnerability that may be fixed in a future version, but the vulnerable version still loads because it is explicitly specified in configuration.</span></span>

<span data-ttu-id="b3d73-390">已知類型太多會有另一種結果： <xref:System.Runtime.Serialization.DataContractSerializer> 會在應用程式定義域中建立序列化/還原序列化程式碼的快取，以及必須序列化和還原序列化之各個型別的項目。</span><span class="sxs-lookup"><span data-stu-id="b3d73-390">Having too many known types has another consequence: The <xref:System.Runtime.Serialization.DataContractSerializer> creates a cache of serialization/deserialization code in the application domain, with an entry for each type it must serialize and deserialize.</span></span> <span data-ttu-id="b3d73-391">只要應用程式定義域在執行中，便永遠不會清除這個快取。</span><span class="sxs-lookup"><span data-stu-id="b3d73-391">This cache is never cleared as long as the application domain is running.</span></span> <span data-ttu-id="b3d73-392">因此，知道應用程式使用許多已知類型的攻擊者可以造成所有這些類型的還原序列化，導致快取使用不當比例的大量記憶體。</span><span class="sxs-lookup"><span data-stu-id="b3d73-392">Therefore, an attacker who is aware that an application uses many known types can cause the deserialization of all these types, causing the cache to consume a disproportionately large amount of memory.</span></span>

### <a name="preventing-types-from-being-in-an-unintended-state"></a><span data-ttu-id="b3d73-393">防止型別處於非預期的狀態</span><span class="sxs-lookup"><span data-stu-id="b3d73-393">Preventing Types from Being in an Unintended State</span></span>

<span data-ttu-id="b3d73-394">型別可能會有必須強制執行的內部一致性條件約束。</span><span class="sxs-lookup"><span data-stu-id="b3d73-394">A type may have internal consistency constraints that must be enforced.</span></span> <span data-ttu-id="b3d73-395">請務必小心，避免在還原序列化期間違反這些條件約束。</span><span class="sxs-lookup"><span data-stu-id="b3d73-395">Care must be taken to avoid breaking these constraints during deserialization.</span></span>

<span data-ttu-id="b3d73-396">下面的型別範例代表太空船上氣閘的狀態，並強制執行不得同時開啟內門和外門的條件約束。</span><span class="sxs-lookup"><span data-stu-id="b3d73-396">The following example of a type represents the state of an airlock on a spacecraft, and enforces the constraint that both the inner and the outer doors cannot be open at the same time.</span></span>

[!code-csharp[DataContractAttribute#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/datacontractattribute/cs/overview.cs#3)]
[!code-vb[DataContractAttribute#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/datacontractattribute/vb/overview.vb#3)]

<span data-ttu-id="b3d73-397">攻擊者可能會傳送類似這樣的惡意訊息，避開條件約束並讓物件處於無效狀態，這可能會有無法預期的結果。</span><span class="sxs-lookup"><span data-stu-id="b3d73-397">An attacker may send a malicious message like this, getting around the constraints and getting the object into an invalid state, which may have unintended and unpredictable consequences.</span></span>

```xml
<SpaceStationAirlock>
    <innerDoorOpen>true</innerDoorOpen>
    <outerDoorOpen>true</outerDoorOpen>
</SpaceStationAirlock>
```

<span data-ttu-id="b3d73-398">注意下列各點可以避免這種情況：</span><span class="sxs-lookup"><span data-stu-id="b3d73-398">This situation can be avoided by being aware of the following points:</span></span>

- <span data-ttu-id="b3d73-399">當 <xref:System.Runtime.Serialization.DataContractSerializer> 還原序列化大部分的類別時，建構函式不會執行。</span><span class="sxs-lookup"><span data-stu-id="b3d73-399">When the <xref:System.Runtime.Serialization.DataContractSerializer> deserializes most classes, constructors do not run.</span></span> <span data-ttu-id="b3d73-400">因此，請勿依賴在建構函式中完成的任何狀態管理。</span><span class="sxs-lookup"><span data-stu-id="b3d73-400">Therefore, do not rely on any state management done in the constructor.</span></span>

- <span data-ttu-id="b3d73-401">請使用回呼來確保物件處於有效狀態中。</span><span class="sxs-lookup"><span data-stu-id="b3d73-401">Use callbacks to ensure that the object is in a valid state.</span></span> <span data-ttu-id="b3d73-402">以 <xref:System.Runtime.Serialization.OnDeserializedAttribute> 屬性標示的回呼特別有用，因為它是在還原序列化完成之後執行，並有機會檢查和更正整體狀態。</span><span class="sxs-lookup"><span data-stu-id="b3d73-402">The callback marked with the <xref:System.Runtime.Serialization.OnDeserializedAttribute> attribute is especially useful because it runs after deserialization is complete and has a chance to examine and correct the overall state.</span></span> <span data-ttu-id="b3d73-403">如需詳細資訊，請參閱[版本相容序列化回呼](version-tolerant-serialization-callbacks.md)。</span><span class="sxs-lookup"><span data-stu-id="b3d73-403">For more information, see [Version-Tolerant Serialization Callbacks](version-tolerant-serialization-callbacks.md).</span></span>

- <span data-ttu-id="b3d73-404">請勿將資料合約類型設計為依賴呼叫 setter 屬性必須遵守的特定順序。</span><span class="sxs-lookup"><span data-stu-id="b3d73-404">Do not design data contract types to rely on any particular order in which property setters must be called.</span></span>

- <span data-ttu-id="b3d73-405">請小心使用以 <xref:System.SerializableAttribute> 屬性標示的舊版型別。</span><span class="sxs-lookup"><span data-stu-id="b3d73-405">Take care using legacy types marked with the <xref:System.SerializableAttribute> attribute.</span></span> <span data-ttu-id="b3d73-406">其中有許多是設計來搭配使用 .NET Framework 遠端處理，僅用於受信任的資料。</span><span class="sxs-lookup"><span data-stu-id="b3d73-406">Many of them were designed to work with .NET Framework remoting for use with trusted data only.</span></span> <span data-ttu-id="b3d73-407">以此屬性標示之現有型別的設計可能尚未考慮到狀態安全性。</span><span class="sxs-lookup"><span data-stu-id="b3d73-407">Existing types marked with this attribute may not have been designed with state safety in mind.</span></span>

- <span data-ttu-id="b3d73-408">就狀態安全性而言，請勿依賴 <xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A> 屬性 (Attribute) 的 <xref:System.Runtime.Serialization.DataMemberAttribute> 屬性 (Property) 來保證資料的存在。</span><span class="sxs-lookup"><span data-stu-id="b3d73-408">Do not rely on the <xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A> property of the <xref:System.Runtime.Serialization.DataMemberAttribute> attribute to guarantee presence of data as far as state safety is concerned.</span></span> <span data-ttu-id="b3d73-409">資料可能永遠是 `null`、 `zero`或 `invalid`。</span><span class="sxs-lookup"><span data-stu-id="b3d73-409">Data could always be `null`, `zero`, or `invalid`.</span></span>

- <span data-ttu-id="b3d73-410">在沒有先驗證之前，絕對不要信任從不受信任的資料來源還原序列化的物件圖形。</span><span class="sxs-lookup"><span data-stu-id="b3d73-410">Never trust an object graph deserialized from an untrusted data source without validating it first.</span></span> <span data-ttu-id="b3d73-411">每個個別物件可能處於一致性狀態，但是整個物件圖形可能不是。</span><span class="sxs-lookup"><span data-stu-id="b3d73-411">Each individual object may be in a consistent state, but the object graph as a whole may not be.</span></span> <span data-ttu-id="b3d73-412">此外，即使物件圖形保留模式已停用，已還原序列化圖形仍可能有相同物件的多個參照，或是有循環參照。</span><span class="sxs-lookup"><span data-stu-id="b3d73-412">Furthermore, even if the object graph preservation mode is disabled, the deserialized graph may have multiple references to the same object or have circular references.</span></span> <span data-ttu-id="b3d73-413">如需詳細資訊，請參閱[序列化和還原序列化](serialization-and-deserialization.md)。</span><span class="sxs-lookup"><span data-stu-id="b3d73-413">For more information, see [Serialization and Deserialization](serialization-and-deserialization.md).</span></span>

### <a name="using-the-netdatacontractserializer-securely"></a><span data-ttu-id="b3d73-414">安全使用 NetDataContractSerializer</span><span class="sxs-lookup"><span data-stu-id="b3d73-414">Using the NetDataContractSerializer Securely</span></span>

<span data-ttu-id="b3d73-415"><xref:System.Runtime.Serialization.NetDataContractSerializer> 是對型別使用緊密結合的序列化引擎。</span><span class="sxs-lookup"><span data-stu-id="b3d73-415">The <xref:System.Runtime.Serialization.NetDataContractSerializer> is a serialization engine that uses tight coupling to types.</span></span> <span data-ttu-id="b3d73-416">這與 <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> 和 <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter>很類似。</span><span class="sxs-lookup"><span data-stu-id="b3d73-416">This is similar to the <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> and the <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter>.</span></span> <span data-ttu-id="b3d73-417">也就是說，它會從傳入資料讀取 .NET Framework 元件和類型名稱，以判斷要具現化的類型。</span><span class="sxs-lookup"><span data-stu-id="b3d73-417">That is, it determines which type to instantiate by reading the .NET Framework assembly and type name from the incoming data.</span></span> <span data-ttu-id="b3d73-418">雖然它是 WCF 的一部分，但並沒有提供方法來插入此序列化引擎。必須撰寫自訂程式碼。</span><span class="sxs-lookup"><span data-stu-id="b3d73-418">Although it is a part of WCF, there is no supplied way of plugging in this serialization engine; custom code must be written.</span></span> <span data-ttu-id="b3d73-419">的 `NetDataContractSerializer` 主要目的是為了簡化從 .NET Framework 遠端處理到 WCF 的作業。</span><span class="sxs-lookup"><span data-stu-id="b3d73-419">The `NetDataContractSerializer` is provided primarily to ease migration from .NET Framework remoting to WCF.</span></span> <span data-ttu-id="b3d73-420">如需詳細資訊，請參閱[序列化和還原序列化](serialization-and-deserialization.md)中的相關章節。</span><span class="sxs-lookup"><span data-stu-id="b3d73-420">For more information, see the relevant section in [Serialization and Deserialization](serialization-and-deserialization.md).</span></span>

<span data-ttu-id="b3d73-421">由於訊息本身可能會指出可以載入的任何型別，因此 <xref:System.Runtime.Serialization.NetDataContractSerializer> 機制原本就是不安全的，且只應搭配受信任的資料使用。</span><span class="sxs-lookup"><span data-stu-id="b3d73-421">Because the message itself may indicate any type can be loaded, the <xref:System.Runtime.Serialization.NetDataContractSerializer> mechanism is inherently insecure and should be used only with trusted data.</span></span> <span data-ttu-id="b3d73-422">如需詳細資訊，請參閱[BinaryFormatter 安全性指南](/dotnet/standard/serialization/binaryformatter-security-guide)。</span><span class="sxs-lookup"><span data-stu-id="b3d73-422">For more information, see the [BinaryFormatter security guide](/dotnet/standard/serialization/binaryformatter-security-guide).</span></span>

<span data-ttu-id="b3d73-423">即使和受信任的資料一起使用，傳入資料仍可能不足以指定要載入的型別，特別是如果 <xref:System.Runtime.Serialization.NetDataContractSerializer.AssemblyFormat%2A> 屬性設定為 <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle.Simple>時。</span><span class="sxs-lookup"><span data-stu-id="b3d73-423">Even when used with trusted data, the incoming data may insufficiently specify the type to load, especially if the <xref:System.Runtime.Serialization.NetDataContractSerializer.AssemblyFormat%2A> property is set to <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle.Simple>.</span></span> <span data-ttu-id="b3d73-424">任何可以存取應用程式目錄或全域組件快取的人，都可以使用應載入的型別來取代惡意型別。</span><span class="sxs-lookup"><span data-stu-id="b3d73-424">Anyone with access to the application’s directory or to the global assembly cache can substitute a malicious type in place of the one that is supposed to load.</span></span> <span data-ttu-id="b3d73-425">請正確設定權限，永遠確保應用程式目錄和全域組件快取的安全性。</span><span class="sxs-lookup"><span data-stu-id="b3d73-425">Always ensure the security of your application’s directory and of the global assembly cache by correctly setting permissions.</span></span>

<span data-ttu-id="b3d73-426">一般而言，如果您允許部分信任的程式碼存取您的 `NetDataContractSerializer` 執行個體，或是控制代理選取器 (<xref:System.Runtime.Serialization.ISurrogateSelector>) 或序列化繫結器 (<xref:System.Runtime.Serialization.SerializationBinder>)，則程式碼會在序列化/還原序列化處理上行使廣大的控制力。</span><span class="sxs-lookup"><span data-stu-id="b3d73-426">In general, if you allow partially trusted code access to your `NetDataContractSerializer` instance or otherwise control the surrogate selector (<xref:System.Runtime.Serialization.ISurrogateSelector>) or the serialization binder (<xref:System.Runtime.Serialization.SerializationBinder>), the code may exercise a great deal of control over the serialization/deserialization process.</span></span> <span data-ttu-id="b3d73-427">例如，它會插入任意型別、導致資訊洩漏、竄改結果物件圖形或序列化資料，或溢位結果序列化資料流。</span><span class="sxs-lookup"><span data-stu-id="b3d73-427">For example, it may inject arbitrary types, lead to information disclosure, tamper with the resulting object graph or serialized data, or overflow the resultant serialized stream.</span></span>

<span data-ttu-id="b3d73-428">`NetDataContractSerializer` 的另一個安全性問題是阻絕服務，而不是惡意程式碼執行威脅。</span><span class="sxs-lookup"><span data-stu-id="b3d73-428">Another security concern with the `NetDataContractSerializer` is a denial of service, not a malicious code execution threat.</span></span> <span data-ttu-id="b3d73-429">當使用 `NetDataContractSerializer`時，請永遠將 <xref:System.Runtime.Serialization.NetDataContractSerializer.MaxItemsInObjectGraph%2A> 配額設定為安全值。</span><span class="sxs-lookup"><span data-stu-id="b3d73-429">When using the `NetDataContractSerializer`, always set the <xref:System.Runtime.Serialization.NetDataContractSerializer.MaxItemsInObjectGraph%2A> quota to a safe value.</span></span> <span data-ttu-id="b3d73-430">建構配置大小只受此配額限制之物件陣列的小型惡意訊息十分簡單。</span><span class="sxs-lookup"><span data-stu-id="b3d73-430">It is easy to construct a small malicious message that allocates an array of objects whose size is limited only by this quota.</span></span>

### <a name="xmlserializer-specific-threats"></a><span data-ttu-id="b3d73-431">XmlSerializer 特定的威脅</span><span class="sxs-lookup"><span data-stu-id="b3d73-431">XmlSerializer-Specific Threats</span></span>

<span data-ttu-id="b3d73-432"><xref:System.Xml.Serialization.XmlSerializer> 安全性模型與 <xref:System.Runtime.Serialization.DataContractSerializer>的很類似。</span><span class="sxs-lookup"><span data-stu-id="b3d73-432">The <xref:System.Xml.Serialization.XmlSerializer> security model is similar to that of the <xref:System.Runtime.Serialization.DataContractSerializer>.</span></span> <span data-ttu-id="b3d73-433">然而，有一些威脅是 <xref:System.Xml.Serialization.XmlSerializer>專有的。</span><span class="sxs-lookup"><span data-stu-id="b3d73-433">A few threats, however, are unique to the <xref:System.Xml.Serialization.XmlSerializer>.</span></span>

<span data-ttu-id="b3d73-434"><xref:System.Xml.Serialization.XmlSerializer> 會在執行階段產生「 *序列化組件* 」(Serialization Assembly)，其中包含實際序列化和還原序列化的程式碼；這些組件是在暫存檔目錄中建立的。</span><span class="sxs-lookup"><span data-stu-id="b3d73-434">The <xref:System.Xml.Serialization.XmlSerializer> generates *serialization assemblies* at runtime that contain code that actually serializes and deserializes; these assemblies are created in a temporary files directory.</span></span> <span data-ttu-id="b3d73-435">如果其他處理序或使用者具有該目錄的存取權，他們可能會使用任意程式碼來覆寫序列化/還原序列化程式碼。</span><span class="sxs-lookup"><span data-stu-id="b3d73-435">If some other process or user has access rights to that directory, they may overwrite the serialization/deserialization code with arbitrary code.</span></span> <span data-ttu-id="b3d73-436">然後 <xref:System.Xml.Serialization.XmlSerializer> 會使用其安全性內容來執行此程式碼，而不是序列化/還原序列化程式碼。</span><span class="sxs-lookup"><span data-stu-id="b3d73-436">The <xref:System.Xml.Serialization.XmlSerializer> then runs this code using its security context, instead of the serialization/deserialization code.</span></span> <span data-ttu-id="b3d73-437">請確定暫存檔目錄上的權限設定是正確的，以防止這種情況發生。</span><span class="sxs-lookup"><span data-stu-id="b3d73-437">Make sure the permissions are set correctly on the temporary files directory to prevent this from happening.</span></span>

<span data-ttu-id="b3d73-438"><xref:System.Xml.Serialization.XmlSerializer> 也有使用預先產生之序列化組件的模式，而非在執行階段產生它們。</span><span class="sxs-lookup"><span data-stu-id="b3d73-438">The <xref:System.Xml.Serialization.XmlSerializer> also has a mode in which it uses pre-generated serialization assemblies instead of generating them at runtime.</span></span> <span data-ttu-id="b3d73-439">每當 <xref:System.Xml.Serialization.XmlSerializer> 可以找到合適的序列化組件時，就會觸發這個模式。</span><span class="sxs-lookup"><span data-stu-id="b3d73-439">This mode is triggered whenever the <xref:System.Xml.Serialization.XmlSerializer> can find a suitable serialization assembly.</span></span> <span data-ttu-id="b3d73-440"><xref:System.Xml.Serialization.XmlSerializer> 會檢查序列化組件是否由相同金鑰所簽署，此金鑰用於簽署含有正在序列化之型別的組件。</span><span class="sxs-lookup"><span data-stu-id="b3d73-440">The <xref:System.Xml.Serialization.XmlSerializer> checks whether or not the serialization assembly was signed by the same key that was used to sign the assembly that contains the types being serialized.</span></span> <span data-ttu-id="b3d73-441">這會提供保護，不受偽裝成序列化組件的惡意組件所攻擊。</span><span class="sxs-lookup"><span data-stu-id="b3d73-441">This offers protection from malicious assemblies being disguised as serialization assemblies.</span></span> <span data-ttu-id="b3d73-442">然而，如果含有可序列化型別的組件未簽署， <xref:System.Xml.Serialization.XmlSerializer> 就無法執行這項檢查，而會使用任何有正確名稱的組件。</span><span class="sxs-lookup"><span data-stu-id="b3d73-442">However, if the assembly that contains your serializable types is not signed, the <xref:System.Xml.Serialization.XmlSerializer> cannot perform this check and uses any assembly with the correct name.</span></span> <span data-ttu-id="b3d73-443">如此便可能會執行惡意程式碼。</span><span class="sxs-lookup"><span data-stu-id="b3d73-443">This makes running malicious code possible.</span></span> <span data-ttu-id="b3d73-444">請永遠簽署含有可序列化型別的組件，或緊密控制應用程式目錄和全域組件快取的存取權，以防止引入惡意組件。</span><span class="sxs-lookup"><span data-stu-id="b3d73-444">Always sign the assemblies that contain your serializable types, or tightly control access to your application’s directory and the global assembly cache to prevent the introduction of malicious assemblies.</span></span>

<span data-ttu-id="b3d73-445"><xref:System.Xml.Serialization.XmlSerializer> 可能會受限於阻絕服務攻擊。</span><span class="sxs-lookup"><span data-stu-id="b3d73-445">The <xref:System.Xml.Serialization.XmlSerializer> can be subject to a denial of service attack.</span></span> <span data-ttu-id="b3d73-446"><xref:System.Xml.Serialization.XmlSerializer> 沒有 `MaxItemsInObjectGraph` 配額 (如同 <xref:System.Runtime.Serialization.DataContractSerializer>上所提供)。</span><span class="sxs-lookup"><span data-stu-id="b3d73-446">The <xref:System.Xml.Serialization.XmlSerializer> does not have a `MaxItemsInObjectGraph` quota (as is available on the <xref:System.Runtime.Serialization.DataContractSerializer>).</span></span> <span data-ttu-id="b3d73-447">因此，它會還原序列化任意的物件量，只受訊息大小的限制。</span><span class="sxs-lookup"><span data-stu-id="b3d73-447">Thus, it deserializes an arbitrary amount of objects, limited only by the message size.</span></span>

### <a name="partial-trust-threats"></a><span data-ttu-id="b3d73-448">部分信任威脅</span><span class="sxs-lookup"><span data-stu-id="b3d73-448">Partial Trust Threats</span></span>

<span data-ttu-id="b3d73-449">請注意下列與使用部分信任執行之程式碼有關的威脅問題。</span><span class="sxs-lookup"><span data-stu-id="b3d73-449">Note the following concerns regarding threats related to code running with partial trust.</span></span> <span data-ttu-id="b3d73-450">這些威脅包括惡意的部分信任程式碼，以及惡意的部分信任程式碼與其他攻擊案例的組合 (例如，建構特定字串後再還原序列化的部分信任程式碼)。</span><span class="sxs-lookup"><span data-stu-id="b3d73-450">These threats include malicious partially-trusted code as well as malicious partially-trusted code in combination with other attack scenarios (for example, partially-trusted code that constructs a specific string and then deserializing it).</span></span>

- <span data-ttu-id="b3d73-451">當使用任何序列化元件時，即使整個序列化狀況都在您的判斷提示範圍內，而且您並未處理任何不受信任的資料或物件，也絕對不要在這類使用之前判斷提示任何權限。</span><span class="sxs-lookup"><span data-stu-id="b3d73-451">When using any serialization components, never assert any permissions before such usage, even if the entire serialization scenario is within the scope of your assert, and you are not dealing with any untrusted data or objects.</span></span> <span data-ttu-id="b3d73-452">這類使用可能會造成安全性弱點。</span><span class="sxs-lookup"><span data-stu-id="b3d73-452">Such usage may lead to security vulnerabilities.</span></span>

- <span data-ttu-id="b3d73-453">當部分信任的程式碼已控制序列化處理，無論是透過擴充點 (Surrogate)、序列化的型別，或透過其他方式，部分信任的程式碼會造成序列化程式將大量的資料輸出到序列化資料流，而對這個資料流的接收者造成阻絕服務 (DoS)。</span><span class="sxs-lookup"><span data-stu-id="b3d73-453">In cases where partially-trusted code has control over the serialization process, either through extensibility points (surrogates), types being serialized, or through other means, the partially-trusted code may cause the serializer to output a large amount of data into the serialized stream, which may cause Denial of Service (DoS) to the receiver of this stream.</span></span> <span data-ttu-id="b3d73-454">如果您所序列化的資料是提供給對 DoS 威脅敏感的目標使用，則請勿序列化部分信任的類型，或者讓部分信任的程式碼控制序列化。</span><span class="sxs-lookup"><span data-stu-id="b3d73-454">If you are serializing data intended for a target that is sensitive to DoS threats, do not serialize partially-trusted types or otherwise let partially-trusted code control serialization.</span></span>

- <span data-ttu-id="b3d73-455">如果您允許部分信任的程式碼存取您的 <xref:System.Runtime.Serialization.DataContractSerializer> 實例，或控制[資料合約的代理](../extending/data-contract-surrogates.md)，它可能會對序列化/還原序列化程式執行很大的控制。</span><span class="sxs-lookup"><span data-stu-id="b3d73-455">If you allow partially-trusted code access to your <xref:System.Runtime.Serialization.DataContractSerializer> instance or otherwise control the [Data Contract Surrogates](../extending/data-contract-surrogates.md), it may exercise a great deal of control over the serialization/deserialization process.</span></span> <span data-ttu-id="b3d73-456">例如，它會插入任意型別、導致資訊洩漏、竄改結果物件圖形或序列化資料，或溢位結果序列化資料流。</span><span class="sxs-lookup"><span data-stu-id="b3d73-456">For example, it may inject arbitrary types, lead to information disclosure, tamper with the resulting object graph or serialized data, or overflow the resultant serialized stream.</span></span> <span data-ttu-id="b3d73-457">在「安全使用 NetDataContractSerializer Securely」一節中會說明等同的 <xref:System.Runtime.Serialization.NetDataContractSerializer> 威脅。</span><span class="sxs-lookup"><span data-stu-id="b3d73-457">An equivalent <xref:System.Runtime.Serialization.NetDataContractSerializer> threat is described in the "Using the NetDataContractSerializer Securely" section.</span></span>

- <span data-ttu-id="b3d73-458">如果 <xref:System.Runtime.Serialization.DataContractAttribute> 屬性套用至型別 (或標示為 <xref:System.SerializableAttribute> 但不是 <xref:System.Runtime.Serialization.ISerializable>的型別)，即使所有的建構函式都是非公用或依要求受到保護的，還原序列化程式仍然可以建立此型別的執行個體。</span><span class="sxs-lookup"><span data-stu-id="b3d73-458">If the <xref:System.Runtime.Serialization.DataContractAttribute> attribute is applied to a type (or the type marked as <xref:System.SerializableAttribute> but is not <xref:System.Runtime.Serialization.ISerializable>), the deserializer can create an instance of such a type even if all constructors are non-public or protected by demands.</span></span>

- <span data-ttu-id="b3d73-459">絕對不要信任還原序列化的結果，除非已還原序列化資料受到信任，而且確定所有已知類型都是您信任的類型。</span><span class="sxs-lookup"><span data-stu-id="b3d73-459">Never trust the result of deserialization unless the data to be deserialized is trusted and you are certain that all known types are types that you trust.</span></span> <span data-ttu-id="b3d73-460">請注意，在部分信任中執行時，已知類型不會從應用程式組態檔載入 (而是從電腦組態檔載入)。</span><span class="sxs-lookup"><span data-stu-id="b3d73-460">Note that known types are not loaded from the application configuration file, (but are loaded from the computer configuration file) when running in partial trust.</span></span>

- <span data-ttu-id="b3d73-461">如果您以新增的 Surrogate 將 <xref:System.Runtime.Serialization.DataContractSerializer> 執行個體傳遞至部分信任的程式碼，則程式碼會變更該 Surrogate 上任何可修改的設定。</span><span class="sxs-lookup"><span data-stu-id="b3d73-461">If you pass a <xref:System.Runtime.Serialization.DataContractSerializer> instance with a surrogate added to partially-trusted code, the code can change any modifiable settings on that surrogate.</span></span>

- <span data-ttu-id="b3d73-462">對於已還原序列化物件，如果 XML 讀取器 (或其中的資料) 來自部分信任程式碼，請將結果的已還原序列化物件視為不受信任的資料。</span><span class="sxs-lookup"><span data-stu-id="b3d73-462">For a deserialized object, if the XML reader (or the data therein) comes from partially-trusted code, treat the resulting deserialized object as untrusted data.</span></span>

- <span data-ttu-id="b3d73-463">事實上， <xref:System.Runtime.Serialization.ExtensionDataObject> 型別沒有 Public 成員不表示其中的資料是安全的。</span><span class="sxs-lookup"><span data-stu-id="b3d73-463">The fact that the <xref:System.Runtime.Serialization.ExtensionDataObject> type has no public members does not mean that data within it is secure.</span></span> <span data-ttu-id="b3d73-464">例如，如果您從有權限的資料來源還原序列化至部分資料所在的物件中，然後將該物件傳遞至部分信任程式碼，部分信任程式碼就可以序列化此物件，以讀取 `ExtensionDataObject` 中的資料。</span><span class="sxs-lookup"><span data-stu-id="b3d73-464">For example, if you deserialize from a privileged data source into an object in which some data resides, then hand that object to partially-trusted code, the partially-trusted code can read the data in the `ExtensionDataObject` by serializing the object.</span></span> <span data-ttu-id="b3d73-465">當從有權限的資料來源還原序列化至稍後將傳遞至部分信任程式碼的物件中時，請考慮將 <xref:System.Runtime.Serialization.DataContractSerializer.IgnoreExtensionDataObject%2A> 設定為 `true` 。</span><span class="sxs-lookup"><span data-stu-id="b3d73-465">Consider setting <xref:System.Runtime.Serialization.DataContractSerializer.IgnoreExtensionDataObject%2A> to `true` when deserializing from a privileged data source into an object that is later passed to partially-trusted code.</span></span>

- <span data-ttu-id="b3d73-466">在完全信任的情況下，<xref:System.Runtime.Serialization.DataContractSerializer> 和 <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> support the serialization of private, protected, internal, 和 public members in full trust.</span><span class="sxs-lookup"><span data-stu-id="b3d73-466"><xref:System.Runtime.Serialization.DataContractSerializer> and <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> support the serialization of private, protected, internal, and public members in full trust.</span></span> <span data-ttu-id="b3d73-467">不過，在部分信任的情況下，只能序列化公用成員。</span><span class="sxs-lookup"><span data-stu-id="b3d73-467">However, in partial trust, only public members can be serialized.</span></span> <span data-ttu-id="b3d73-468">如果應用程式嘗試序列化非公用成員，就會擲回 <xref:System.Security.SecurityException> 。</span><span class="sxs-lookup"><span data-stu-id="b3d73-468">A <xref:System.Security.SecurityException> is thrown if an application attempts to serialize a non-public member.</span></span>

    <span data-ttu-id="b3d73-469">在部分信任的情況下，若要允許內部或受保護內部成員進行序列化，請使用 <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> 組件屬性。</span><span class="sxs-lookup"><span data-stu-id="b3d73-469">To allow internal or protected internal members to be serialized in partial trust, use the <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> assembly attribute.</span></span> <span data-ttu-id="b3d73-470">這個屬性會允許組件宣告只有某些其他組件能夠看見其內部成員。</span><span class="sxs-lookup"><span data-stu-id="b3d73-470">This attribute allows an assembly to declare that its internal members are visible to some other assembly.</span></span> <span data-ttu-id="b3d73-471">在此情況下，想要序列化其內部成員的組件就會宣告 System.Runtime.Serialization.dll 能夠看見其內部成員。</span><span class="sxs-lookup"><span data-stu-id="b3d73-471">In this case, an assembly that wants to have its internal members serialized declares that its internal members are visible to System.Runtime.Serialization.dll.</span></span>

    <span data-ttu-id="b3d73-472">這種方法的優點在於不需要更高的程式碼產生路徑。</span><span class="sxs-lookup"><span data-stu-id="b3d73-472">The advantage of this approach is that it does not require an elevated code generation path.</span></span>

    <span data-ttu-id="b3d73-473">同時，也有兩個主要缺點。</span><span class="sxs-lookup"><span data-stu-id="b3d73-473">At the same time, there are two major disadvantages.</span></span>

    <span data-ttu-id="b3d73-474">第一個缺點是， <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> 屬性 (Attribute) 的 opt-in 屬性 (Property) 屬於組件範圍。</span><span class="sxs-lookup"><span data-stu-id="b3d73-474">The first disadvantage is that the opt-in property of the <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> attribute is assembly-wide.</span></span> <span data-ttu-id="b3d73-475">也就是說，您無法指定只有特定類別能夠序列化其內部成員。</span><span class="sxs-lookup"><span data-stu-id="b3d73-475">That is, you cannot specify that only a certain class can have its internal members serialized.</span></span> <span data-ttu-id="b3d73-476">當然，您仍然可以選擇不要序列化特定內部成員，只要不將 <xref:System.Runtime.Serialization.DataMemberAttribute> 屬性加入至該成員即可。</span><span class="sxs-lookup"><span data-stu-id="b3d73-476">Of course, you can still choose not to serialize a specific internal member, by simply not adding a <xref:System.Runtime.Serialization.DataMemberAttribute> attribute to that member.</span></span> <span data-ttu-id="b3d73-477">同樣地，只要稍微考量可視性，開發人員也可以選擇將成員設定為內部而非私用或受保護。</span><span class="sxs-lookup"><span data-stu-id="b3d73-477">Similarly, a developer can also choose to make a member internal rather than private or protected, with slight visibility concerns.</span></span>

    <span data-ttu-id="b3d73-478">第二個缺點是，這種方法仍然不支援私用或受保護成員。</span><span class="sxs-lookup"><span data-stu-id="b3d73-478">The second disadvantage is that it still does not support private or protected members.</span></span>

    <span data-ttu-id="b3d73-479">為了在部分信任的情況下說明 <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> 屬性的使用方式，請考慮下列程式：</span><span class="sxs-lookup"><span data-stu-id="b3d73-479">To illustrate the use of the <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> attribute in partial trust, consider the following program:</span></span>

    [!code-csharp[CDF_WCF_SecurityConsiderationsForData#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/cdf_wcf_securityconsiderationsfordata/cs/program.cs#1)]

    <span data-ttu-id="b3d73-480">在上述範例中， `PermissionsHelper.InternetZone` 會對應至部分信任的 <xref:System.Security.PermissionSet> 。</span><span class="sxs-lookup"><span data-stu-id="b3d73-480">In the example above, `PermissionsHelper.InternetZone` corresponds to the <xref:System.Security.PermissionSet> for partial trust.</span></span> <span data-ttu-id="b3d73-481">現在，如果沒有 <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> 屬性，應用程式將會失敗，並擲回， <xref:System.Security.SecurityException> 指出非公用成員無法在部分信任中序列化。</span><span class="sxs-lookup"><span data-stu-id="b3d73-481">Now, without the <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> attribute, the application will fail, throwing a <xref:System.Security.SecurityException> indicating that non-public members cannot be serialized in partial trust.</span></span>

    <span data-ttu-id="b3d73-482">不過，如果我們將下列程式碼加入至原始程式檔，此程式就會順利執行。</span><span class="sxs-lookup"><span data-stu-id="b3d73-482">However, if we add the following line to the source file, the program runs successfully.</span></span>

    [!code-csharp[CDF_WCF_SecurityConsiderationsForData#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/cdf_wcf_securityconsiderationsfordata/cs/program.cs#2)]

## <a name="other-state-management-concerns"></a><span data-ttu-id="b3d73-483">其他的狀態管理問題</span><span class="sxs-lookup"><span data-stu-id="b3d73-483">Other State Management Concerns</span></span>

<span data-ttu-id="b3d73-484">其他有一些與物件狀態管理有關的問題值得您注意：</span><span class="sxs-lookup"><span data-stu-id="b3d73-484">A few other concerns regarding object state management are worth mentioning:</span></span>

- <span data-ttu-id="b3d73-485">當搭配使用資料流程式設計模型與資料流傳輸時，訊息的處理會發生在訊息到達時。</span><span class="sxs-lookup"><span data-stu-id="b3d73-485">When using the stream-based programming model with a streaming transport, processing of the message occurs as the message arrives.</span></span> <span data-ttu-id="b3d73-486">訊息的傳送者可能會在資料流處理期間中止傳送作業，如果預期還有更多內容，會讓程式碼處於無法預測的狀態中。</span><span class="sxs-lookup"><span data-stu-id="b3d73-486">The sender of the message may abort the send operation in the middle of the stream, leaving your code in an unpredictable state if more content was expected.</span></span> <span data-ttu-id="b3d73-487">一般而言，請勿依賴正完成中的資料流，也不要執行如果中止資料流時無法回復的資料流作業中的任何工作。</span><span class="sxs-lookup"><span data-stu-id="b3d73-487">In general, do not rely on the stream being complete, and do not perform any work in a stream-based operation that cannot be rolled back in case the stream is aborted.</span></span> <span data-ttu-id="b3d73-488">這也適用於資料流處理本文之後可能會有格式錯誤的訊息 (例如，可能會遺失 SOAP 信封的結束標記或可能有第二個訊息本文)。</span><span class="sxs-lookup"><span data-stu-id="b3d73-488">This also applies to the situation where a message may be malformed after the streaming body (for example, it may be missing an end tag for the SOAP envelope or may have a second message body).</span></span>

- <span data-ttu-id="b3d73-489">使用 `IExtensibleDataObject` 功能可能會造成發生敏感性資料。</span><span class="sxs-lookup"><span data-stu-id="b3d73-489">Using the `IExtensibleDataObject` feature may cause sensitive data to be emitted.</span></span> <span data-ttu-id="b3d73-490">如果您正接受來自不受信任的來源資料進入含有 `IExtensibleObjectData` 的資料合約，然後再重新發出到簽署訊息的安全通道上，就是可能在對您完全不了解的資料提供保證。</span><span class="sxs-lookup"><span data-stu-id="b3d73-490">If you are accepting data from an untrusted source into data contracts with `IExtensibleObjectData` and later re-emitting it on a secure channel where messages are signed, you are potentially vouching for data you know nothing about.</span></span> <span data-ttu-id="b3d73-491">甚至，如果您在帳戶中納入已知和未知的資料，正在傳送的整體狀態可能會變成無效。</span><span class="sxs-lookup"><span data-stu-id="b3d73-491">Moreover, the overall state you are sending may be invalid if you take both the known and unknown pieces of data into account.</span></span> <span data-ttu-id="b3d73-492">請將延伸資料屬性選擇性地設定為 `null` ，或選擇性地停用 `IExtensibleObjectData` 功能，以避免這種情況。</span><span class="sxs-lookup"><span data-stu-id="b3d73-492">Avoid this situation by either selectively setting the extension data property to `null` or by selectively disabling the `IExtensibleObjectData` feature.</span></span>

## <a name="schema-import"></a><span data-ttu-id="b3d73-493">結構描述匯入</span><span class="sxs-lookup"><span data-stu-id="b3d73-493">Schema Import</span></span>

<span data-ttu-id="b3d73-494">一般來說，將匯入結構描述以產生型別的處理序只會發生在設計階段 (例如，當在 Web 服務上使用 [ServiceModel Metadata Utility Tool (Svcutil.exe)](../servicemodel-metadata-utility-tool-svcutil-exe.md) 來產生用戶端類別)。</span><span class="sxs-lookup"><span data-stu-id="b3d73-494">Normally, the process of importing schema to generate types happens only at design time, for example, when using the [ServiceModel Metadata Utility Tool (Svcutil.exe)](../servicemodel-metadata-utility-tool-svcutil-exe.md) on a Web service to generate a client class.</span></span> <span data-ttu-id="b3d73-495">然而，在更進階的情況中，您可能會在執行階段處理結構描述。</span><span class="sxs-lookup"><span data-stu-id="b3d73-495">However, in more advanced scenarios, you may process schema at runtime.</span></span> <span data-ttu-id="b3d73-496">請注意，這樣做可能會讓您遭到阻絕服務攻擊。</span><span class="sxs-lookup"><span data-stu-id="b3d73-496">Be aware that doing so can expose you to denial-of-service risks.</span></span> <span data-ttu-id="b3d73-497">有些結構描述可能要花很長的時間匯入。</span><span class="sxs-lookup"><span data-stu-id="b3d73-497">Some schema may take a long time to be imported.</span></span> <span data-ttu-id="b3d73-498">如果結構描述有可能來自不受信任的來源，請絕對不要在這種情況中使用 <xref:System.Xml.Serialization.XmlSerializer> 結構描述匯入元件。</span><span class="sxs-lookup"><span data-stu-id="b3d73-498">Never use the <xref:System.Xml.Serialization.XmlSerializer> schema import component in such scenarios if schemas are possibly coming from an untrusted source.</span></span>

## <a name="threats-specific-to-aspnet-ajax-integration"></a><span data-ttu-id="b3d73-499">ASP.NET AJAX 整合特定的威脅</span><span class="sxs-lookup"><span data-stu-id="b3d73-499">Threats Specific to ASP.NET AJAX Integration</span></span>

<span data-ttu-id="b3d73-500">當使用者執行 <xref:System.ServiceModel.Description.WebScriptEnablingBehavior> 或時 <xref:System.ServiceModel.Description.WebHttpBehavior> ，WCF 會公開可同時接受 XML 和 JSON 訊息的端點。</span><span class="sxs-lookup"><span data-stu-id="b3d73-500">When the user implements <xref:System.ServiceModel.Description.WebScriptEnablingBehavior> or <xref:System.ServiceModel.Description.WebHttpBehavior>, WCF exposes an endpoint that can accept both XML and JSON messages.</span></span> <span data-ttu-id="b3d73-501">但是，只有一組讀取器配額是由 XML 讀取器和 JSON 讀取器使用。</span><span class="sxs-lookup"><span data-stu-id="b3d73-501">However, there is only one set of reader quotas, used both by the XML reader and the JSON reader.</span></span> <span data-ttu-id="b3d73-502">有些配額設定可能適用一個讀取器，但對於其他讀取器而言過大。</span><span class="sxs-lookup"><span data-stu-id="b3d73-502">Some quota settings may be appropriate for one reader but too large for the other.</span></span>

<span data-ttu-id="b3d73-503">實作 `WebScriptEnablingBehavior`時，使用者可以選擇在端點公開 JavaScript Proxy。</span><span class="sxs-lookup"><span data-stu-id="b3d73-503">When implementing `WebScriptEnablingBehavior`, the user has the option to expose a JavaScript proxy at the endpoint.</span></span> <span data-ttu-id="b3d73-504">必須考量下列安全問題：</span><span class="sxs-lookup"><span data-stu-id="b3d73-504">The following security issues must be considered:</span></span>

- <span data-ttu-id="b3d73-505">服務的相關資訊 (作業名稱、參數名稱等) 可透過檢查 JavaScript Proxy 取得。</span><span class="sxs-lookup"><span data-stu-id="b3d73-505">Information about the service (operation names, parameter names, and so on) can be obtained by examining the JavaScript proxy.</span></span>

- <span data-ttu-id="b3d73-506">使用 JavaScript 端點時，敏感與私用的資訊可在用戶端 Web 瀏覽器快取中取得。</span><span class="sxs-lookup"><span data-stu-id="b3d73-506">When using the JavaScript endpoint, sensitive and private information might be retained in the client Web browser cache.</span></span>

## <a name="a-note-on-components"></a><span data-ttu-id="b3d73-507">元件注意事項</span><span class="sxs-lookup"><span data-stu-id="b3d73-507">A Note on Components</span></span>

<span data-ttu-id="b3d73-508">WCF 是彈性且可自訂的系統。</span><span class="sxs-lookup"><span data-stu-id="b3d73-508">WCF is a flexible and customizable system.</span></span> <span data-ttu-id="b3d73-509">本主題的大部分內容都著重在最常見的 WCF 使用案例。</span><span class="sxs-lookup"><span data-stu-id="b3d73-509">Most of the contents of this topic focus on the most common WCF usage scenarios.</span></span> <span data-ttu-id="b3d73-510">不過，您可以用許多不同的方式撰寫 WCF 提供的元件。</span><span class="sxs-lookup"><span data-stu-id="b3d73-510">However, it is possible to compose components WCF provides in many different ways.</span></span> <span data-ttu-id="b3d73-511">了解使用各個元件的安全性含意是很重要的。</span><span class="sxs-lookup"><span data-stu-id="b3d73-511">It is important to understand the security implications of using each component.</span></span> <span data-ttu-id="b3d73-512">尤其是：</span><span class="sxs-lookup"><span data-stu-id="b3d73-512">In particular:</span></span>

- <span data-ttu-id="b3d73-513">當您必須使用 XML 讀取器時，請使用 <xref:System.Xml.XmlDictionaryReader> 類別提供的讀取器，而非其他的讀取器。</span><span class="sxs-lookup"><span data-stu-id="b3d73-513">When you must use XML readers, use the readers the <xref:System.Xml.XmlDictionaryReader> class provides as opposed to any other readers.</span></span> <span data-ttu-id="b3d73-514">安全的讀取器是使用 <xref:System.Xml.XmlDictionaryReader.CreateTextReader%2A>、 <xref:System.Xml.XmlDictionaryReader.CreateBinaryReader%2A>或 <xref:System.Xml.XmlDictionaryReader.CreateMtomReader%2A> 方法建立的。</span><span class="sxs-lookup"><span data-stu-id="b3d73-514">Safe readers are created using <xref:System.Xml.XmlDictionaryReader.CreateTextReader%2A>, <xref:System.Xml.XmlDictionaryReader.CreateBinaryReader%2A>, or <xref:System.Xml.XmlDictionaryReader.CreateMtomReader%2A> methods.</span></span> <span data-ttu-id="b3d73-515">請勿使用 <xref:System.Xml.XmlReader.Create%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="b3d73-515">Do not use the <xref:System.Xml.XmlReader.Create%2A> method.</span></span> <span data-ttu-id="b3d73-516">請永遠使用安全的配額來設定讀取器。</span><span class="sxs-lookup"><span data-stu-id="b3d73-516">Always configure the readers with safe quotas.</span></span> <span data-ttu-id="b3d73-517">WCF 中的序列化引擎只有在與 WCF 的安全 XML 讀取器搭配使用時才是安全的。</span><span class="sxs-lookup"><span data-stu-id="b3d73-517">The serialization engines in WCF are secure only when used with secure XML readers from WCF.</span></span>

- <span data-ttu-id="b3d73-518">當使用 <xref:System.Runtime.Serialization.DataContractSerializer> 來還原序列化可能不受信任的資料時，請永遠設定 <xref:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph%2A> 屬性。</span><span class="sxs-lookup"><span data-stu-id="b3d73-518">When using the <xref:System.Runtime.Serialization.DataContractSerializer> to deserialize potentially untrusted data, always set the <xref:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph%2A> property.</span></span>

- <span data-ttu-id="b3d73-519">當建立訊息時，如果 `maxSizeOfHeaders` 沒有提供足夠的保護，請設定 `MaxReceivedMessageSize` 參數。</span><span class="sxs-lookup"><span data-stu-id="b3d73-519">When creating a message, set the `maxSizeOfHeaders` parameter if `MaxReceivedMessageSize` does not offer enough protection.</span></span>

- <span data-ttu-id="b3d73-520">當建立編碼器時，請永遠設定相關配額，例如 `MaxSessionSize` 和 `MaxBufferSize`。</span><span class="sxs-lookup"><span data-stu-id="b3d73-520">When creating an encoder, always configure the relevant quotas, such as `MaxSessionSize` and `MaxBufferSize`.</span></span>

- <span data-ttu-id="b3d73-521">當使用 XPath 訊息篩選條件時，請設定 <xref:System.ServiceModel.Dispatcher.XPathMessageFilter.NodeQuota%2A> 以限制篩選條件所瀏覽的 XML 節點的量。</span><span class="sxs-lookup"><span data-stu-id="b3d73-521">When using an XPath message filter, set the <xref:System.ServiceModel.Dispatcher.XPathMessageFilter.NodeQuota%2A> to limit the amount of XML nodes the filter visits.</span></span> <span data-ttu-id="b3d73-522">請勿使用 XPath 運算式，它可能會花太長時間計算而沒有瀏覽許多節點。</span><span class="sxs-lookup"><span data-stu-id="b3d73-522">Do not use XPath expressions that could take a long time to compute without visiting many nodes.</span></span>

- <span data-ttu-id="b3d73-523">一般來說，當使用接受配額的元件時，請了解它的安全性含意並設定為安全值。</span><span class="sxs-lookup"><span data-stu-id="b3d73-523">In general, when using any component that accepts a quota, understand its security implications and set it to a safe value.</span></span>

## <a name="see-also"></a><span data-ttu-id="b3d73-524">請參閱</span><span class="sxs-lookup"><span data-stu-id="b3d73-524">See also</span></span>

- <xref:System.Runtime.Serialization.DataContractSerializer>
- <xref:System.Xml.XmlDictionaryReader>
- <xref:System.Xml.Serialization.XmlSerializer>
- [<span data-ttu-id="b3d73-525">資料合約已知型別</span><span class="sxs-lookup"><span data-stu-id="b3d73-525">Data Contract Known Types</span></span>](data-contract-known-types.md)
