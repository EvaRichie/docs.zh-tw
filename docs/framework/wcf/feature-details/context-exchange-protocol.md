---
title: 內容交換通訊協定
ms.date: 03/30/2017
ms.assetid: 3dfd38e0-ae52-491c-94f4-7a862b9843d4
ms.openlocfilehash: ba613a2d12843ad00034057f8bbf08d5357d7f04
ms.sourcegitcommit: bc293b14af795e0e999e3304dd40c0222cf2ffe4
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 11/26/2020
ms.locfileid: "96237816"
---
# <a name="context-exchange-protocol"></a><span data-ttu-id="e8a58-102">內容交換通訊協定</span><span class="sxs-lookup"><span data-stu-id="e8a58-102">Context Exchange Protocol</span></span>

<span data-ttu-id="e8a58-103">本節說明 Windows Communication Foundation (WCF) 版本 .NET Framework 3.5 版中引進的內容交換通訊協定。</span><span class="sxs-lookup"><span data-stu-id="e8a58-103">This section describes the context exchange protocol introduced in Windows Communication Foundation (WCF) release .NET Framework version 3.5.</span></span> <span data-ttu-id="e8a58-104">這項通訊協定可讓用戶端通道接受服務所提供的內容，並透過相同的用戶端通道執行個體將之套用到該服務的後續所有要求。</span><span class="sxs-lookup"><span data-stu-id="e8a58-104">This protocol allows the client channel to accept a context supplied by a service and apply it to all subsequent requests to that service sent over the same client channel instance.</span></span> <span data-ttu-id="e8a58-105">內容交換通訊協定的實作可透過 HTTP Cookie 或 SOAP 標頭這兩種機制，在伺服器與用戶端之間傳播內容。</span><span class="sxs-lookup"><span data-stu-id="e8a58-105">The implementation of the context exchange protocol can use one of the following two mechanisms to propagate the context between the server and the client: HTTP cookies or a SOAP header.</span></span>  
  
 <span data-ttu-id="e8a58-106">內容交換通訊協定可在自訂通道層中實作。</span><span class="sxs-lookup"><span data-stu-id="e8a58-106">The context exchange protocol is implemented in a custom channel layer.</span></span> <span data-ttu-id="e8a58-107">通道會透過 <xref:System.ServiceModel.Channels.ContextMessageProperty> 屬性，在應用程式層來回傳送內容。</span><span class="sxs-lookup"><span data-stu-id="e8a58-107">The channel communicates the context to and from the application layer using a <xref:System.ServiceModel.Channels.ContextMessageProperty> property.</span></span> <span data-ttu-id="e8a58-108">至於端點之間的傳輸，內容值將在通道層上序列化為 SOAP 標頭，或是在代表 HTTP 要求和回應的訊息屬性之間來回轉換。</span><span class="sxs-lookup"><span data-stu-id="e8a58-108">For transmission between endpoints, the value of the context is either serialized as a SOAP header at the channel layer, or converted to or from the message properties that represent a HTTP request and response.</span></span> <span data-ttu-id="e8a58-109">在第二個情況中，我們預期其中一個基礎通道層會將 HTTP 要求和回應訊息屬性個別轉換至 HTTP Cookie，反之亦然。</span><span class="sxs-lookup"><span data-stu-id="e8a58-109">In the latter case, it is expected that one of the underlying channel layers converts the HTTP request and response message properties to and from HTTP cookies, respectively.</span></span> <span data-ttu-id="e8a58-110">您可透過 <xref:System.ServiceModel.Channels.ContextExchangeMechanism> 上的 <xref:System.ServiceModel.Channels.ContextBindingElement> 屬性，選擇用來交換內容的機制。</span><span class="sxs-lookup"><span data-stu-id="e8a58-110">The choice of the mechanism used to exchange the context is done using the <xref:System.ServiceModel.Channels.ContextExchangeMechanism> property on the <xref:System.ServiceModel.Channels.ContextBindingElement>.</span></span> <span data-ttu-id="e8a58-111">有效值為 `HttpCookie` 或 `SoapHeader`。</span><span class="sxs-lookup"><span data-stu-id="e8a58-111">Valid values are `HttpCookie` or `SoapHeader`.</span></span>  
  
 <span data-ttu-id="e8a58-112">在用戶端上，通道的執行個體可以依據通道屬性 <xref:System.ServiceModel.Channels.IContextManager.Enabled%2A> 上的設定，以兩種模式來運作。</span><span class="sxs-lookup"><span data-stu-id="e8a58-112">On the client, an instance of a channel can operate in two modes based on the settings on the channel property, <xref:System.ServiceModel.Channels.IContextManager.Enabled%2A>.</span></span>  
  
## <a name="mode-1-channel-context-management"></a><span data-ttu-id="e8a58-113">模式 1：通道內容管理</span><span class="sxs-lookup"><span data-stu-id="e8a58-113">Mode 1: Channel Context Management</span></span>  

 <span data-ttu-id="e8a58-114">當 <xref:System.ServiceModel.Channels.IContextManager.Enabled%2A> 設定為 `true` 時，這就是預設的模式。</span><span class="sxs-lookup"><span data-stu-id="e8a58-114">This is the default mode where <xref:System.ServiceModel.Channels.IContextManager.Enabled%2A> is set to `true`.</span></span> <span data-ttu-id="e8a58-115">在此模式中，內容通道會管理內容，並在其存留期間快取內容。</span><span class="sxs-lookup"><span data-stu-id="e8a58-115">In this mode the context channel manages the context and caches the context during its lifetime.</span></span> <span data-ttu-id="e8a58-116">您可以呼叫 `IContextManager` 方法，透過通道屬性 `GetContext` 從通道擷取內容。</span><span class="sxs-lookup"><span data-stu-id="e8a58-116">Context can be retrieved from the channel through channel property `IContextManager` by calling the `GetContext` method.</span></span> <span data-ttu-id="e8a58-117">您也可以呼叫通道屬性上的 `SetContext` 方法，在開啟通道之前，使用特定內容預先初始化通道。</span><span class="sxs-lookup"><span data-stu-id="e8a58-117">The channel can also be pre-initialized with specific context before being opened by calling the `SetContext` method on the channel property.</span></span> <span data-ttu-id="e8a58-118">一旦通道透過內容初始化完畢，就無法重設。</span><span class="sxs-lookup"><span data-stu-id="e8a58-118">Once the channel is initialized with context it cannot be reset.</span></span>  
  
 <span data-ttu-id="e8a58-119">下列為此模式中的不變量清單：</span><span class="sxs-lookup"><span data-stu-id="e8a58-119">The following is a list of invariants in this mode:</span></span>  
  
- <span data-ttu-id="e8a58-120">在通道已經開啟的情況下，任何使用 `SetContext` 來重設內容的嘗試都會擲回 <xref:System.InvalidOperationException>。</span><span class="sxs-lookup"><span data-stu-id="e8a58-120">Any attempt to reset the context using `SetContext` after the channel has been opened throws an <xref:System.InvalidOperationException>.</span></span>  
  
- <span data-ttu-id="e8a58-121">在傳出的訊息中使用 <xref:System.ServiceModel.Channels.ContextMessageProperty> 來傳送內容的嘗試都會擲回 <xref:System.InvalidOperationException>。</span><span class="sxs-lookup"><span data-stu-id="e8a58-121">Any attempt to send context by using the <xref:System.ServiceModel.Channels.ContextMessageProperty> in an outgoing message throws an <xref:System.InvalidOperationException>.</span></span>  
  
- <span data-ttu-id="e8a58-122">如果在通道已經使用特定內容初始化之後，從伺服器接收包含特定內容的訊息時就會產生 <xref:System.ServiceModel.ProtocolException>。</span><span class="sxs-lookup"><span data-stu-id="e8a58-122">If a message is received from server with a specific context, when the channel has already been initialized with a specific context, this results in a <xref:System.ServiceModel.ProtocolException>.</span></span>  
  
    > [!NOTE]
    > <span data-ttu-id="e8a58-123">只有當開啟的通道未明確設定任何內容時，才適合從伺服器接收初始內容。</span><span class="sxs-lookup"><span data-stu-id="e8a58-123">It is appropriate to receive an initial context from the server only if the channel is opened without any context set explicitly.</span></span>  
  
- <span data-ttu-id="e8a58-124">傳入訊息上的 <xref:System.ServiceModel.Channels.ContextMessageProperty> 一律為 null。</span><span class="sxs-lookup"><span data-stu-id="e8a58-124">The <xref:System.ServiceModel.Channels.ContextMessageProperty> on incoming message is always null.</span></span>  
  
## <a name="mode-2-application-context-management"></a><span data-ttu-id="e8a58-125">模式 2：應用程式內容管理</span><span class="sxs-lookup"><span data-stu-id="e8a58-125">Mode 2: Application Context Management</span></span>  

 <span data-ttu-id="e8a58-126">當 <xref:System.ServiceModel.Channels.IContextManager.Enabled%2A> 設為 `false` 的時候，會變成這個模式。</span><span class="sxs-lookup"><span data-stu-id="e8a58-126">This is the mode when <xref:System.ServiceModel.Channels.IContextManager.Enabled%2A> is set to `false`.</span></span> <span data-ttu-id="e8a58-127">在此模式中，內容通道不會管理內容。</span><span class="sxs-lookup"><span data-stu-id="e8a58-127">In this mode the context channel does not manage context.</span></span> <span data-ttu-id="e8a58-128">應用程式需負責透過 <xref:System.ServiceModel.Channels.ContextMessageProperty> 來擷取、管理與套用內容。</span><span class="sxs-lookup"><span data-stu-id="e8a58-128">It is the application's responsibility to retrieve, manage and apply context by using the <xref:System.ServiceModel.Channels.ContextMessageProperty>.</span></span> <span data-ttu-id="e8a58-129">任何嘗試呼叫 `GetContext` 或 `SetContext` 的行為都會導致 <xref:System.InvalidOperationException>。</span><span class="sxs-lookup"><span data-stu-id="e8a58-129">Any attempt to call `GetContext` or `SetContext` results in an <xref:System.InvalidOperationException>.</span></span>  
  
 <span data-ttu-id="e8a58-130">不管選擇了哪一種模式，用戶端通道處理站都會支援 <xref:System.ServiceModel.Channels.IRequestChannel>、<xref:System.ServiceModel.Channels.IRequestSessionChannel> 和 <xref:System.ServiceModel.Channels.IDuplexSessionChannel> 訊息交換模式。</span><span class="sxs-lookup"><span data-stu-id="e8a58-130">No matter which mode is chosen the client channel factory supports <xref:System.ServiceModel.Channels.IRequestChannel>, <xref:System.ServiceModel.Channels.IRequestSessionChannel>, and <xref:System.ServiceModel.Channels.IDuplexSessionChannel> message exchange patterns.</span></span>  
  
 <span data-ttu-id="e8a58-131">對服務來說，通道的執行個體負責將傳入訊息上由用戶端提供的內容，轉換為 <xref:System.ServiceModel.Channels.ContextMessageProperty>。</span><span class="sxs-lookup"><span data-stu-id="e8a58-131">On the service, an instance of the channel is responsible for converting the context supplied by the client on incoming messages to the <xref:System.ServiceModel.Channels.ContextMessageProperty>.</span></span> <span data-ttu-id="e8a58-132">訊息屬性可以接著由應用程式層或是呼叫堆疊中更上層的其他通道來存取。</span><span class="sxs-lookup"><span data-stu-id="e8a58-132">The message property can then be accessed by the application layer or other channels further up in the call stack.</span></span> <span data-ttu-id="e8a58-133">服務通道同時可允許應用程式層藉由將 <xref:System.ServiceModel.Channels.ContextMessageProperty> 附加至回應訊息，以指定要傳播回用戶端的新內容值。</span><span class="sxs-lookup"><span data-stu-id="e8a58-133">The service channels also allow the application layer to specify a new context value to be propagated back to the client by attaching a <xref:System.ServiceModel.Channels.ContextMessageProperty> to the response message.</span></span> <span data-ttu-id="e8a58-134">視繫結的組態而定，這個屬性會轉換成包含內容的 SOAP 標頭或 HTTP Cookie。</span><span class="sxs-lookup"><span data-stu-id="e8a58-134">This property is converted to the SOAP header or HTTP cookie that contains the context, which depends on the configuration of the binding.</span></span> <span data-ttu-id="e8a58-135">服務通道接聽項支援 <xref:System.ServiceModel.Channels.IReplyChannel>、<xref:System.ServiceModel.Channels.IReplySessionChannel> 和 <xref:System.ServiceModel.Channels.IReplySessionChannel> 訊息交換模式。</span><span class="sxs-lookup"><span data-stu-id="e8a58-135">The service channel listener supports <xref:System.ServiceModel.Channels.IReplyChannel>, <xref:System.ServiceModel.Channels.IReplySessionChannel>, and <xref:System.ServiceModel.Channels.IReplySessionChannel> message exchange patterns.</span></span>  
  
 <span data-ttu-id="e8a58-136">內容交換通訊協定引進了新的 `wsc:Context` SOAP 標頭，可在未使用 HTTP Cookie 來傳播內容時，用來代表內容資訊。</span><span class="sxs-lookup"><span data-stu-id="e8a58-136">The context exchange protocol introduces a new `wsc:Context` SOAP header to represent the context information when HTTP cookies are not used to propagate the context.</span></span> <span data-ttu-id="e8a58-137">內容標頭結構描述允許任何數量的子項目存在，其中每一個都包含一個字串索引鍵與字串內容。</span><span class="sxs-lookup"><span data-stu-id="e8a58-137">The context header schema allows for any number of child elements, each with a string key and string content.</span></span> <span data-ttu-id="e8a58-138">下列是內容標頭的範例。</span><span class="sxs-lookup"><span data-stu-id="e8a58-138">The following is an example of a context header.</span></span>  
  
 `<Context xmlns="http://schemas.microsoft.com/ws/2006/05/context">`  
  
 `<property name="myContext">context-2</property>`  
  
 `</Context>`  
  
 <span data-ttu-id="e8a58-139">在 `HttpCookie` 模式中，Cookie 會透過 `SetCookie` 標頭來設定。</span><span class="sxs-lookup"><span data-stu-id="e8a58-139">When in `HttpCookie` mode, cookies are set using the `SetCookie` header.</span></span> <span data-ttu-id="e8a58-140">Cookie 的名稱是 `WscContext`。</span><span class="sxs-lookup"><span data-stu-id="e8a58-140">The cookie name is `WscContext`.</span></span> <span data-ttu-id="e8a58-141">Cookie 的值是 `wsc:Context` 標頭的 Base64 編碼。</span><span class="sxs-lookup"><span data-stu-id="e8a58-141">The value of the cookie is the Base64 encoding of the `wsc:Context` header.</span></span> <span data-ttu-id="e8a58-142">此值會以引號包住。</span><span class="sxs-lookup"><span data-stu-id="e8a58-142">This value is enclosed in quotes.</span></span>  
  
 <span data-ttu-id="e8a58-143">傳輸中的內容值必須加以保護以免遭到修改，所持理由與保護 WS-Addressing 標頭一樣，因為標頭是用來決定要求將分派到服務的哪個位置。</span><span class="sxs-lookup"><span data-stu-id="e8a58-143">The value of the context must be protected from modification while in transit for the same reason WS-Addressing headers are protected – the header is used to determine where to dispatch the request to on the service.</span></span> <span data-ttu-id="e8a58-144">因此當繫結提供訊息保護功能時，便需要針對 `wsc:Context` 標頭在 SOAP 或傳輸層級進行數位簽署或是簽署加上加密處理。</span><span class="sxs-lookup"><span data-stu-id="e8a58-144">The `wsc:Context` header is therefore required to be digitally signed or signed and encrypted at either the SOAP or transport level when the binding offers message protection capability.</span></span> <span data-ttu-id="e8a58-145">一旦使用 HTTP Cookie 來傳播內容，就應該透過傳輸安全性來保護這些 Cookie 的安全。</span><span class="sxs-lookup"><span data-stu-id="e8a58-145">When HTTP cookies are used to propagate context, they should be protected using transport security.</span></span>  
  
 <span data-ttu-id="e8a58-146">服務端點可以在發行的原則中明確地陳述對內容交換通訊協定的支援需求。</span><span class="sxs-lookup"><span data-stu-id="e8a58-146">Service endpoints that require support for the context exchange protocol can make it explicit in the published policy.</span></span> <span data-ttu-id="e8a58-147">兩個全新的原則判斷提示已經引進來代表用戶端需求，以支援 SOAP 層級的內容交換通訊協定或是啟用 HTTP Cookie 支援。</span><span class="sxs-lookup"><span data-stu-id="e8a58-147">Two new policy assertions have been introduced to represent the requirement for the client to support the context exchange protocol at the SOAP level or to enable HTTP cookie support.</span></span> <span data-ttu-id="e8a58-148">服務原則中會不會產生這些判斷提示是由如下列所示的 <xref:System.ServiceModel.Channels.ContextBindingElement.ContextExchangeMechanism%2A> 屬性值所控制：</span><span class="sxs-lookup"><span data-stu-id="e8a58-148">Generation of these assertions into the policy on the service is controlled by the value of the <xref:System.ServiceModel.Channels.ContextBindingElement.ContextExchangeMechanism%2A> property as follows:</span></span>  
  
- <span data-ttu-id="e8a58-149">對 <xref:System.ServiceModel.Channels.ContextExchangeMechanism.ContextSoapHeader> 來說，會產生下列判斷提示：</span><span class="sxs-lookup"><span data-stu-id="e8a58-149">For <xref:System.ServiceModel.Channels.ContextExchangeMechanism.ContextSoapHeader>, the following assertion is generated:</span></span>  
  
    ```xml  
    <IncludeContext
    xmlns="http://schemas.microsoft.com/ws/2006/05/context"  
    protectionLevel="Sign" />  
    ```  
  
- <span data-ttu-id="e8a58-150">對 <xref:System.ServiceModel.Channels.ContextExchangeMechanism.HttpCookie> 來說，會產生下列判斷提示：</span><span class="sxs-lookup"><span data-stu-id="e8a58-150">For <xref:System.ServiceModel.Channels.ContextExchangeMechanism.HttpCookie>, the following assertion is generated:</span></span>  
  
    ```xml  
    <HttpUseCookie xmlns="http://schemas.xmlsoap.org/soap/http"/>  
    ```  
  
## <a name="see-also"></a><span data-ttu-id="e8a58-151">另請參閱</span><span class="sxs-lookup"><span data-stu-id="e8a58-151">See also</span></span>

- [<span data-ttu-id="e8a58-152">Web 服務通訊協定互通性手冊</span><span class="sxs-lookup"><span data-stu-id="e8a58-152">Web Services Protocols Interoperability Guide</span></span>](web-services-protocols-interoperability-guide.md)
