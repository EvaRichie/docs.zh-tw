---
title: 大型資料與資料流
ms.date: 03/30/2017
ms.assetid: ab2851f5-966b-4549-80ab-c94c5c0502d2
ms.openlocfilehash: 21993f230b19a76020807e1f17bd6256f2ee0b1c
ms.sourcegitcommit: cdb295dd1db589ce5169ac9ff096f01fd0c2da9d
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 06/09/2020
ms.locfileid: "84586321"
---
# <a name="large-data-and-streaming"></a><span data-ttu-id="9718c-102">大型資料與資料流</span><span class="sxs-lookup"><span data-stu-id="9718c-102">Large Data and Streaming</span></span>

<span data-ttu-id="9718c-103">Windows Communication Foundation （WCF）是以 XML 為基礎的通訊基礎結構。</span><span class="sxs-lookup"><span data-stu-id="9718c-103">Windows Communication Foundation (WCF) is an XML-based communications infrastructure.</span></span> <span data-ttu-id="9718c-104">因為 XML 資料通常是以[xml 1.0 規格](https://www.w3.org/TR/REC-xml/)中所定義的標準文字格式來編碼，所以連線的系統開發人員和架構師通常會關心網路上所傳送之訊息的線路使用量（或大小），而 xml 的文字編碼則會對二進位資料的有效率傳輸造成特殊挑戰。</span><span class="sxs-lookup"><span data-stu-id="9718c-104">Because XML data is commonly encoded in the standard text format defined in the [XML 1.0 specification](https://www.w3.org/TR/REC-xml/), connected systems developers and architects are typically concerned about the wire footprint (or size) of messages sent across the network, and the text-based encoding of XML poses special challenges for the efficient transfer of binary data.</span></span>  
  
## <a name="basic-considerations"></a><span data-ttu-id="9718c-105">基本考量</span><span class="sxs-lookup"><span data-stu-id="9718c-105">Basic Considerations</span></span>  
 <span data-ttu-id="9718c-106">為了提供有關 WCF 的下列資訊的背景資訊，本節特別針對一般適用于連線系統基礎結構的編碼、二進位資料和串流，強調一些一般考慮和考慮。</span><span class="sxs-lookup"><span data-stu-id="9718c-106">To provide background information about the following information for WCF, this section highlights some general concerns and considerations for encodings, binary data, and streaming that generally apply to connected systems infrastructures.</span></span>  
  
### <a name="encoding-data-text-vs-binary"></a><span data-ttu-id="9718c-107">資料編碼：文字與二進位的比較</span><span class="sxs-lookup"><span data-stu-id="9718c-107">Encoding Data: Text vs. Binary</span></span>  
 <span data-ttu-id="9718c-108">常見的開發人員問題包括：由於開始標記和結束標記的重複性質，因此與二進位格式相比，XML 的額外負荷相當大；一般認為數值的編碼會龐大很多，因為它們是以文字值來表示；而二進位資料無法有效地表示，因為它必須進行特殊編碼才能內嵌在文字格式中。</span><span class="sxs-lookup"><span data-stu-id="9718c-108">Commonly expressed developer concerns include the perception that XML has significant overhead when compared to binary formats due to the repetitive nature of start tags and end tags, that the encoding of numerical values is considered to be significantly larger because they are expressed in text values, and that binary data cannot be expressed efficiently because it must be specially encoded for embedding into a text format.</span></span>  
  
 <span data-ttu-id="9718c-109">雖然上述許多問題和類似問題的確存在，但是 XML Web Service 環境中的 XML 文字編碼訊息和舊版遠端程序呼叫 (RPC) 環境中的二進位編碼訊息之間的實際差異常常不如最初所想的那麼顯著。</span><span class="sxs-lookup"><span data-stu-id="9718c-109">While many of these and similar concerns are valid, the actual difference between XML-text encoded messages in an XML Web services environment and binary-encoded messages in a legacy remote procedure call (RPC) environment is often much less significant than the initial consideration might suggest.</span></span>  
  
 <span data-ttu-id="9718c-110">XML 文字編碼訊息是透明化且為「人們可讀取的」，而二進位訊息相較之下常常十分模糊，而且沒有工具很難解碼。</span><span class="sxs-lookup"><span data-stu-id="9718c-110">While XML-text encoded messages are transparent and "human readable", binary messages are often fairly obscure in comparison and difficult to decode without tools.</span></span> <span data-ttu-id="9718c-111">這種在可讀性方面的差異很容易讓人忽略，二進位訊息也常常在承載中包含內嵌中繼資料，這和 XML 文字訊息一樣會增加額外負荷。</span><span class="sxs-lookup"><span data-stu-id="9718c-111">This difference in legibility leads one to overlook that binary messages also often carry inline metadata in the payload, which adds overhead just as with XML text messages.</span></span> <span data-ttu-id="9718c-112">特別是二進位格式，目的是提供有彈性及動態的叫用功能。</span><span class="sxs-lookup"><span data-stu-id="9718c-112">This is specifically true for binary formats that aim to provide loose-coupling and dynamic invocation capabilities.</span></span>  
  
 <span data-ttu-id="9718c-113">然而，二進位格式通常會將此類描述性的中繼資料資訊包含在「標頭」中，其中也會宣告下列資料記錄的資料配置。</span><span class="sxs-lookup"><span data-stu-id="9718c-113">However, binary formats commonly carry such descriptive metadata information in a "header," which also declares the data layout for the following data records.</span></span> <span data-ttu-id="9718c-114">然後承載便會遵循這個通用的中繼資料區塊宣告，讓後續的額外負荷減至最小。</span><span class="sxs-lookup"><span data-stu-id="9718c-114">The payload then follows this common metadata block declaration with minimal further overhead.</span></span> <span data-ttu-id="9718c-115">相反地，XML 會將各個資料項目封入項目或屬性中，讓各個序列化的承載物件重複包含封入的中繼資料。</span><span class="sxs-lookup"><span data-stu-id="9718c-115">In contrast, XML encloses each data item in an element or attribute so that the enclosing metadata is repetitively included for each serialized payload object.</span></span> <span data-ttu-id="9718c-116">因此，雖然在比較文字與二進位表示法時，因為有些描述性中繼資料必須對這兩者做表示，所以單一序列化承載物件的大小十分類似，但是二進位格式可以獲得因整體額外負荷較低而傳輸之各個額外承載物件的共用中繼資料描述的好處。</span><span class="sxs-lookup"><span data-stu-id="9718c-116">As a result, the size of a single serialized payload object is similar when comparing text to binary representations as some descriptive metadata must be expressed for both, but the binary format benefits from the shared metadata description with each additional payload object that is transferred due to the lower overall overhead.</span></span>  
  
 <span data-ttu-id="9718c-117">對於特定的資料型別 (例如數字)，使用固定大小的二進位數值表示法 (例如，128 位元的十進位類型而非純文字) 仍然可能會有缺點，因為純文字表示法可能會減少數個位元組。</span><span class="sxs-lookup"><span data-stu-id="9718c-117">Still, for certain data types, such as numbers, there might be a disadvantage to using fixed-size, binary numerical representations, such as a 128-bit decimal type instead of plain text, as the plain text representation might be several bytes smaller.</span></span> <span data-ttu-id="9718c-118">文字資料也可能會從一般較為彈性的 XML 文字編碼方式獲得大小方面的好處，因為有些二進位格式可能會預設為 16 位元或甚至 32 位元的 Unicode，而不適用於 .NET 二進位 XML 格式。</span><span class="sxs-lookup"><span data-stu-id="9718c-118">Text data also might have size benefits from the typically more flexible XML text encoding choices, while some binary formats might default to 16-bit or even 32-bit Unicode, which does not apply to the .NET Binary XML Format.</span></span>  
  
 <span data-ttu-id="9718c-119">因此，文字與二進位之間的選擇並不如假設二進位訊息永遠小於 XML 文字訊息那樣容易。</span><span class="sxs-lookup"><span data-stu-id="9718c-119">As a result, deciding between text or binary is not quite as easy as assuming that binary messages are always smaller than XML-text messages.</span></span>  
  
 <span data-ttu-id="9718c-120">XML 文字訊息有一項無庸置疑的優點，就是它們是以標準為基礎，並提供最廣泛的互通性選項和平台支援。</span><span class="sxs-lookup"><span data-stu-id="9718c-120">A clear advantage of XML-text messages is that they are standards-based and offer the broadest choice of interoperability options and platform support.</span></span> <span data-ttu-id="9718c-121">如需詳細資訊，請參閱本主題稍後的「編碼方式」一節。</span><span class="sxs-lookup"><span data-stu-id="9718c-121">For more information, see the "Encodings" section later in this topic.</span></span>  
  
### <a name="binary-content"></a><span data-ttu-id="9718c-122">二進位內容</span><span class="sxs-lookup"><span data-stu-id="9718c-122">Binary Content</span></span>  
 <span data-ttu-id="9718c-123">就結果訊息大小方面，有一個部分是二進位編碼優於文字編碼的，即為大型二進位資料項目 (例如必須在服務和其取用者之間交換的圖片、視訊、音訊剪輯，或任何其他形式的不透明二進位資料)。</span><span class="sxs-lookup"><span data-stu-id="9718c-123">One area where binary encodings are superior to text-based encodings in terms of the resulting message size are large binary data items such as pictures, videos, sound clips, or any other form of opaque, binary data that must be exchanged between services and their consumers.</span></span> <span data-ttu-id="9718c-124">若要讓資料的這些型別符合 XML 文字，常用的方法是使用 Base64 編碼方式進行編碼。</span><span class="sxs-lookup"><span data-stu-id="9718c-124">To fit these types of data into XML text, the common approach is to encode them using the Base64 encoding.</span></span>  
  
 <span data-ttu-id="9718c-125">在以 Base64 編碼的字串中，每個字元代表原始 8 位元資料中的 6 位元，造成 Base64 的 4:3 編碼與額外負荷比率，且不計算通常由慣例新增的額外格式設定字元 (歸位/換行字元)。</span><span class="sxs-lookup"><span data-stu-id="9718c-125">In a Base64-encoded string, each character represents 6-bits of the original 8-bit data, which results in a 4:3 encoding-overhead ratio for Base64, not counting extra formatting characters (carriage return/line feed) that are commonly added by convention.</span></span> <span data-ttu-id="9718c-126">雖然 XML 和二進位編碼之間的差別大小要視案例而定，但是在傳輸 500 MB 承載時得到超過 33% 的大小通常是無法接受的。</span><span class="sxs-lookup"><span data-stu-id="9718c-126">While the significance of the differences between XML and binary encodings typically depends on the scenario, a size gain of more than 33% when transmitting a 500-MB payload is usually not acceptable.</span></span>  
  
 <span data-ttu-id="9718c-127">為避免這項編碼額外負荷，訊息傳輸最佳化機制 (MTOM) 標準允許外顯化 (Externalizing) 包含在訊息中的大型資料項目，並在不使用任何特殊編碼的情況下以二進位資料包含在訊息中。</span><span class="sxs-lookup"><span data-stu-id="9718c-127">To avoid this encoding overhead, the Message Transmission Optimization Mechanism (MTOM) standard allows for externalizing large data elements that are contained in a message and carrying them with the message as binary data without any special encoding.</span></span> <span data-ttu-id="9718c-128">使用 MTOM，訊息會以類似的方式與簡單郵件傳送通訊協定（SMTP）電子郵件訊息交換，其中包含附件或內嵌的內容（圖片和其他內嵌內容）;MTOM 訊息會封裝成多部分/相關的 MIME 序列，而根部分則是實際的 SOAP 訊息。</span><span class="sxs-lookup"><span data-stu-id="9718c-128">With MTOM, messages are exchanged in a similar fashion to Simple Mail Transfer Protocol (SMTP) email messages with attachments or embedded content (pictures and other embedded content); MTOM messages are packaged as multipart/related MIME sequences with the root part being the actual SOAP message.</span></span>  
  
 <span data-ttu-id="9718c-129">MTOM SOAP 訊息是從其未編碼的版本修改，讓參照個別 MIME 部分的特殊項目標記取代包含二進位資料之訊息中的原始項目。</span><span class="sxs-lookup"><span data-stu-id="9718c-129">An MTOM SOAP message is modified from its un-encoded version so that special element tags that refer to the respective MIME parts take the place of the original elements in the message that contained binary data.</span></span> <span data-ttu-id="9718c-130">因此，SOAP 訊息會指向與其一起傳送的 MIME 部分，來參照二進位內容，否則就只會包含 XML 文字資料。</span><span class="sxs-lookup"><span data-stu-id="9718c-130">As a result, the SOAP message refers to binary content by pointing to the MIME parts sent with it, but otherwise just carries XML text data.</span></span> <span data-ttu-id="9718c-131">由於這個模型與已建立的 SMTP 模型非常接近，因此有廣泛的工具支援可在許多平台上編碼及解碼 MTOM 訊息，讓它具有極大的互通性選擇。</span><span class="sxs-lookup"><span data-stu-id="9718c-131">Because this model is closely aligned with the well-established SMTP model, there is broad tooling support to encode and decode MTOM messages on many platforms, which makes it an extremely interoperable choice.</span></span>  
  
 <span data-ttu-id="9718c-132">同樣的，如同 Base64，MTOM 也有一些 MIME 格式的必要額外負荷，因此只有在二進位資料項目的大小超過約 1 KB 時，才會看到使用 MTOM 的優點。</span><span class="sxs-lookup"><span data-stu-id="9718c-132">Still, as with Base64, MTOM also comes with some necessary overhead for the MIME format, so that advantages of using MTOM are only seen when the size of a binary data element exceeds about 1 KB.</span></span> <span data-ttu-id="9718c-133">由於額外負荷之故，如果二進位承載保持在該臨界值之下，以 MTOM 編碼的訊息可能會大於使用 Base64 編碼二進位資料的訊息。</span><span class="sxs-lookup"><span data-stu-id="9718c-133">Due to the overhead, MTOM-encoded messages might be larger than messages that use Base64 encoding for binary data, if the binary payload remains under that threshold.</span></span> <span data-ttu-id="9718c-134">如需詳細資訊，請參閱本主題稍後的「編碼方式」一節。</span><span class="sxs-lookup"><span data-stu-id="9718c-134">For more information, see the "Encodings" section later in this topic.</span></span>  
  
### <a name="large-data-content"></a><span data-ttu-id="9718c-135">大型資料內容</span><span class="sxs-lookup"><span data-stu-id="9718c-135">Large Data Content</span></span>  
 <span data-ttu-id="9718c-136">除了網路使用量以外，先前提到的 500 MB 承載也會為服務和用戶端帶來很大的本機挑戰。</span><span class="sxs-lookup"><span data-stu-id="9718c-136">Wire-footprint aside, the previously mentioned 500-MB payload also poses a great local challenge at for the service and the client.</span></span> <span data-ttu-id="9718c-137">根據預設，WCF 會在*緩衝模式*中處理訊息。</span><span class="sxs-lookup"><span data-stu-id="9718c-137">By default, WCF processes messages in *buffered mode*.</span></span> <span data-ttu-id="9718c-138">這表示在傳送之前或接收之後，訊息的整個內容都會存在於記憶體中。</span><span class="sxs-lookup"><span data-stu-id="9718c-138">This means that the entire content of a message is present in memory before it is sent or after it is received.</span></span> <span data-ttu-id="9718c-139">雖然這對大部分的案例都是一個很好的策略，而且對於訊息功能 (例如數位簽章和可靠的傳遞) 是必要的，但是大型訊息可能會很容易耗盡系統的資源。</span><span class="sxs-lookup"><span data-stu-id="9718c-139">While that is a good strategy for most scenarios, and necessary for messaging features such as digital signatures and reliable delivery, large messages could exhaust a system's resources.</span></span>  
  
 <span data-ttu-id="9718c-140">處理大型承載的策略是資料流。</span><span class="sxs-lookup"><span data-stu-id="9718c-140">The strategy to deal with large payloads is streaming.</span></span> <span data-ttu-id="9718c-141">雖然訊息 (特別是以 XML 表示的訊息) 通常都被視為相當精簡的資料套件，但是一個訊息的大小可能會有數 GB，且類似連續資料流而非資料套件。</span><span class="sxs-lookup"><span data-stu-id="9718c-141">While messages, especially those expressed in XML, are commonly thought of as being relatively compact data packages, a message might be multiple gigabytes in size and resemble a continuous data stream more than a data package.</span></span> <span data-ttu-id="9718c-142">當在資料流模式而非緩衝模式中傳輸資料時，傳送者會以資料流的格式讓接收者可以使用訊息本文的內容，而訊息基礎結構會持續將變成可用的資料從傳送者轉寄給接收者。</span><span class="sxs-lookup"><span data-stu-id="9718c-142">When data is transferred in streaming mode instead of buffered mode, the sender makes the contents of the message body available to the recipient in the form of a stream and the message infrastructure continuously forwards the data from sender to receiver as it becomes available.</span></span>  
  
 <span data-ttu-id="9718c-143">發生此類大型資料內容傳輸的最常見案例就是下列二進位資料物件的傳輸：</span><span class="sxs-lookup"><span data-stu-id="9718c-143">The most common scenario in which such large data content transfers occur are transfers of binary data objects that:</span></span>  
  
- <span data-ttu-id="9718c-144">無法輕易分成訊息序列。</span><span class="sxs-lookup"><span data-stu-id="9718c-144">Cannot be easily broken up into a message sequence.</span></span>  
  
- <span data-ttu-id="9718c-145">必須及時傳遞。</span><span class="sxs-lookup"><span data-stu-id="9718c-145">Must be delivered in a timely manner.</span></span>  
  
- <span data-ttu-id="9718c-146">當初始化傳輸時，無法完整提供使用。</span><span class="sxs-lookup"><span data-stu-id="9718c-146">Are not available in their entirety when the transfer is initiated.</span></span>  
  
 <span data-ttu-id="9718c-147">對於沒有這些條件約束的資料，通常比一個大型訊息更能夠在一個工作階段的範圍內傳送訊息的序列。</span><span class="sxs-lookup"><span data-stu-id="9718c-147">For data that does not have these constraints, it is typically better to send sequences of messages within the scope of a session than one large message.</span></span> <span data-ttu-id="9718c-148">如需詳細資訊，請參閱本主題稍後的「資料流程資料」一節。</span><span class="sxs-lookup"><span data-stu-id="9718c-148">For more information, see the "Streaming Data" section later in this topic.</span></span>  
  
 <span data-ttu-id="9718c-149">傳送大量資料時，您必須設定 `maxAllowedContentLength` iis 設定（如需詳細資訊，請參閱設定[Iis 要求限制](https://docs.microsoft.com/iis/configuration/system.webServer/security/requestFiltering/requestLimits/)）和系結 `maxReceivedMessageSize` 設定（例如[system.servicemodel. BasicHttpBinding. MaxReceivedMessageSize](xref:System.ServiceModel.HttpBindingBase.MaxReceivedMessageSize%2A)或 <xref:System.ServiceModel.NetTcpBinding.MaxReceivedMessageSize%2A> ）。</span><span class="sxs-lookup"><span data-stu-id="9718c-149">When sending large amounts of data you will need to set the `maxAllowedContentLength` IIS setting (for more information see [Configuring IIS Request Limits](https://docs.microsoft.com/iis/configuration/system.webServer/security/requestFiltering/requestLimits/)) and the `maxReceivedMessageSize` binding setting (for example [System.ServiceModel.BasicHttpBinding.MaxReceivedMessageSize](xref:System.ServiceModel.HttpBindingBase.MaxReceivedMessageSize%2A) or <xref:System.ServiceModel.NetTcpBinding.MaxReceivedMessageSize%2A>).</span></span> <span data-ttu-id="9718c-150">`maxAllowedContentLength`屬性預設為 28.6 MB，而 `maxReceivedMessageSize` 屬性預設為64kb。</span><span class="sxs-lookup"><span data-stu-id="9718c-150">The `maxAllowedContentLength` property defaults to 28.6 MB and the `maxReceivedMessageSize` property defaults to 64KB.</span></span>  
  
## <a name="encodings"></a><span data-ttu-id="9718c-151">編碼方式</span><span class="sxs-lookup"><span data-stu-id="9718c-151">Encodings</span></span>  
 <span data-ttu-id="9718c-152">*編碼*會定義一組關於如何在網路上呈現訊息的規則。</span><span class="sxs-lookup"><span data-stu-id="9718c-152">An *encoding* defines a set of rules about how to present messages on the wire.</span></span> <span data-ttu-id="9718c-153">*編碼器*會在傳送端執行這種編碼方式，並負責將記憶體中的 <xref:System.ServiceModel.Channels.Message> 轉換成位元組資料流程或位元組緩衝區，以便在網路上傳送。</span><span class="sxs-lookup"><span data-stu-id="9718c-153">An *encoder* implements such an encoding and is responsible, on the sender side, for turning an in-memory <xref:System.ServiceModel.Channels.Message> into a byte stream or byte buffer that can be sent across the network.</span></span> <span data-ttu-id="9718c-154">在接收者端，編碼器會將位元組序列變成記憶體中的訊息。</span><span class="sxs-lookup"><span data-stu-id="9718c-154">On the receiver side, the encoder turns a sequence of bytes into an in-memory message.</span></span>  
  
 <span data-ttu-id="9718c-155">WCF 包含三個編碼器，並可讓您視需要撰寫和插入自己的編碼器。</span><span class="sxs-lookup"><span data-stu-id="9718c-155">WCF includes three encoders and allows you to write and plug in your own encoders, if necessary.</span></span>  
  
 <span data-ttu-id="9718c-156">根據預設，每個標準繫結都包括預先設定的編碼器，讓前置詞為 Net\* 的繫結使用二進位編碼器 (藉由包含 <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement> 類別)，而 <xref:System.ServiceModel.BasicHttpBinding> 和 <xref:System.ServiceModel.WSHttpBinding> 類別則使用文字訊息編碼器 (藉由 <xref:System.ServiceModel.Channels.TextMessageEncodingBindingElement> 類別)。</span><span class="sxs-lookup"><span data-stu-id="9718c-156">Each of the standard bindings includes a preconfigured encoder, whereby the bindings with the Net\* prefix use the binary encoder (by including the <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement> class) while the <xref:System.ServiceModel.BasicHttpBinding> and <xref:System.ServiceModel.WSHttpBinding> classes use the text message encoder (by means of the <xref:System.ServiceModel.Channels.TextMessageEncodingBindingElement> class) by default.</span></span>  
  
|<span data-ttu-id="9718c-157">編碼器繫結項目</span><span class="sxs-lookup"><span data-stu-id="9718c-157">Encoder binding element</span></span>|<span data-ttu-id="9718c-158">描述</span><span class="sxs-lookup"><span data-stu-id="9718c-158">Description</span></span>|  
|-----------------------------|-----------------|  
|<xref:System.ServiceModel.Channels.TextMessageEncodingBindingElement>|<span data-ttu-id="9718c-159">文字訊息編碼器是所有 HTTP 繫結的預設編碼器，以及所有優先考量互通性之自訂繫結的適當選擇。</span><span class="sxs-lookup"><span data-stu-id="9718c-159">The text message encoder is the default encoder for all HTTP-based bindings and the appropriate choice for all custom bindings where interoperability is the highest concern.</span></span> <span data-ttu-id="9718c-160">此編碼器不需特別處理二進位資料，即可讀取及撰寫標準 SOAP 1.1/SOAP 1.2 文字訊息。</span><span class="sxs-lookup"><span data-stu-id="9718c-160">This encoder reads and writes standard SOAP 1.1/SOAP 1.2 text messages with no special handling for binary data.</span></span> <span data-ttu-id="9718c-161">如果 <xref:System.ServiceModel.Channels.MessageVersion?displayProperty=nameWithType> 訊息的屬性設定為 <xref:System.ServiceModel.Channels.MessageVersion.None?displayProperty=nameWithType> ，則會省略輸出中的 SOAP 封套包裝函式，而且只會序列化訊息主體內容。</span><span class="sxs-lookup"><span data-stu-id="9718c-161">If the <xref:System.ServiceModel.Channels.MessageVersion?displayProperty=nameWithType> property of a message is set to <xref:System.ServiceModel.Channels.MessageVersion.None?displayProperty=nameWithType>, the SOAP envelope wrapper is omitted from the output and only the message body content is serialized.</span></span>|  
|<xref:System.ServiceModel.Channels.MtomMessageEncodingBindingElement>|<span data-ttu-id="9718c-162">MTOM 訊息編碼器是實作二進位資料特殊處理的文字編碼器，根據預設，它並非用於任何標準繫結中，因為它完全是依個案執行的最佳化公用程式。</span><span class="sxs-lookup"><span data-stu-id="9718c-162">The MTOM message encoder is a text encoder that implements special handling for binary data and is not used by default in any of the standard bindings because it is strictly a case-by-case optimization utility.</span></span> <span data-ttu-id="9718c-163">如果訊息包含達到 MTOM 編碼可產生功效之臨界值的二進位資料，資料便會在訊息封套之後外顯化為 MIME 部分。</span><span class="sxs-lookup"><span data-stu-id="9718c-163">If the message contains binary data that exceeds a threshold where MTOM encoding yields a benefit, the data is externalized into a MIME part following the message envelope.</span></span> <span data-ttu-id="9718c-164">請參閱本節稍後的「啟用 MTOM」。</span><span class="sxs-lookup"><span data-stu-id="9718c-164">See Enabling MTOM later in this section.</span></span>|  
|<xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement>|<span data-ttu-id="9718c-165">二進位訊息編碼器是 Net \* 系結的預設編碼器，而當兩個通訊方都是以 WCF 為基礎時，會提供適當的選擇。</span><span class="sxs-lookup"><span data-stu-id="9718c-165">The binary message encoder is the default encoder for the Net\* bindings and the appropriate choice whenever both communicating parties are based on WCF.</span></span> <span data-ttu-id="9718c-166">二進位訊息編碼器是使用 .NET 二進位 XML 格式，這是 XML 資訊設定 (Infoset) 的 Microsoft 特定二進位表示法，通常會產生比同等的 XML 1.0 表示法更小的使用量，並將二進位資料編碼為位元組資料流。</span><span class="sxs-lookup"><span data-stu-id="9718c-166">The binary message encoder uses the .NET Binary XML Format, a Microsoft-specific binary representation for XML Information Sets (Infosets) that generally yields a smaller footprint than the equivalent XML 1.0 representation and encodes binary data as a byte stream.</span></span>|  
  
 <span data-ttu-id="9718c-167">文字訊息編碼通常是所有需要互通性之通訊路徑的最佳選擇，而二進位訊息編碼則是其他通訊路徑的最佳選擇。</span><span class="sxs-lookup"><span data-stu-id="9718c-167">Text message encoding is typically the best choice for any communication path that requires interoperability, while binary message encoding is the best choice for any other communication path.</span></span> <span data-ttu-id="9718c-168">與單一訊息的文字相比，二進位訊息編碼通常會產生較小的訊息大小，而在通訊工作階段的持續期間，訊息大小甚至會逐漸變得更小。</span><span class="sxs-lookup"><span data-stu-id="9718c-168">Binary message encoding typically yields smaller message sizes compared to text for a single message and progressively even smaller message sizes over the duration of a communication session.</span></span> <span data-ttu-id="9718c-169">與文字編碼不同的是，二進位編碼不必對二進位資料使用特殊處理，例如使用 Base64 而將位元組表示為位元組。</span><span class="sxs-lookup"><span data-stu-id="9718c-169">Unlike text encoding, binary encoding does not have to use special handling for binary data, such as using Base64, but represents bytes as bytes.</span></span>  
  
 <span data-ttu-id="9718c-170">如果您的方案不需要互通性，但您還是想要使用 HTTP 傳輸，可以將 <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement> 撰寫為使用 <xref:System.ServiceModel.Channels.HttpTransportBindingElement> 類別傳輸的自訂繫結。</span><span class="sxs-lookup"><span data-stu-id="9718c-170">If your solution does not require interoperability, but you still want to use HTTP transport, you can compose the <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement> into a custom binding that uses the <xref:System.ServiceModel.Channels.HttpTransportBindingElement> class for the transport.</span></span> <span data-ttu-id="9718c-171">如果您的服務有許多用戶端需要互通性，建議您公開平行端點，其中每個端點都已啟用適合個別用戶端的傳輸和編碼選擇。</span><span class="sxs-lookup"><span data-stu-id="9718c-171">If a number of clients on your service require interoperability, it is recommended that you expose parallel endpoints that each has the appropriate transport and encoding choices for the respective clients enabled.</span></span>  
  
### <a name="enabling-mtom"></a><span data-ttu-id="9718c-172">啟用 MTOM</span><span class="sxs-lookup"><span data-stu-id="9718c-172">Enabling MTOM</span></span>  
 <span data-ttu-id="9718c-173">當互通性成為一項需求且必須傳送大型二進位資料時，MTOM 訊息編碼是可以在標準 <xref:System.ServiceModel.BasicHttpBinding> 或 <xref:System.ServiceModel.WSHttpBinding> 繫結程序上啟用的替代編碼策略，方法是將個別 `MessageEncoding` 屬性設定為 <xref:System.ServiceModel.WSMessageEncoding.Mtom> 或將 <xref:System.ServiceModel.Channels.MtomMessageEncodingBindingElement> 撰寫為 <xref:System.ServiceModel.Channels.CustomBinding>。</span><span class="sxs-lookup"><span data-stu-id="9718c-173">When interoperability is a requirement and large binary data must be sent, then MTOM message encoding is the alternative encoding strategy that you can enable on the standard <xref:System.ServiceModel.BasicHttpBinding> or <xref:System.ServiceModel.WSHttpBinding> bindings by setting the respective `MessageEncoding` property to <xref:System.ServiceModel.WSMessageEncoding.Mtom> or by composing the <xref:System.ServiceModel.Channels.MtomMessageEncodingBindingElement> into a <xref:System.ServiceModel.Channels.CustomBinding>.</span></span> <span data-ttu-id="9718c-174">下列從[MTOM 編碼](../samples/mtom-encoding.md)範例中解壓縮的範例程式碼示範如何在設定中啟用 MTOM。</span><span class="sxs-lookup"><span data-stu-id="9718c-174">The following example code, extracted from the [MTOM Encoding](../samples/mtom-encoding.md) sample demonstrates how to enable MTOM in configuration.</span></span>  
  
```xml  
<system.serviceModel>  
     …  
    <bindings>  
      <wsHttpBinding>  
        <binding name="ExampleBinding" messageEncoding="Mtom"/>  
      </wsHttpBinding>  
    </bindings>  
     …  
</system.serviceModel>  
```  
  
 <span data-ttu-id="9718c-175">如同先前所述，使用 MTOM 編碼的決定要視所傳送的資料磁碟區而定。</span><span class="sxs-lookup"><span data-stu-id="9718c-175">As mentioned earlier, the decision to use MTOM encoding depends on the data volume you are sending.</span></span> <span data-ttu-id="9718c-176">同時，由於 MTOM 是在繫結層級啟用的，因此啟用 MTOM 會影響指定端點上的所有作業。</span><span class="sxs-lookup"><span data-stu-id="9718c-176">Also, because MTOM is enabled at the binding level, enabling MTOM affects all operations on a given endpoint.</span></span>  
  
 <span data-ttu-id="9718c-177">由於不論二進位資料最後是否外顯化，MTOM 編碼器永遠會發出以 MTOM 編碼的 MIME/多部分訊息，因此您通常只要為與超過 1 KB 之二進位資料交換訊息的端點啟用 MTOM。</span><span class="sxs-lookup"><span data-stu-id="9718c-177">Because the MTOM encoder always emits an MTOM-encoded MIME/multi-part message regardless of whether binary data ends up being externalized, you should generally only enable MTOM for endpoints that exchange messages with more than 1 KB of binary data.</span></span> <span data-ttu-id="9718c-178">同時，如果可能的話，設計用來與啟用 MTOM 之端點一起使用的服務合約應限制為指定此類資料傳輸作業。</span><span class="sxs-lookup"><span data-stu-id="9718c-178">Also, the service contracts designed for use with MTOM-enabled endpoints should, when possible, be constrained to specifying such data transfer operations.</span></span> <span data-ttu-id="9718c-179">相關的控制功能應位於獨立的合約上。</span><span class="sxs-lookup"><span data-stu-id="9718c-179">Related control functionality should reside on a separate contract.</span></span> <span data-ttu-id="9718c-180">這項「僅限 MTOM」規則只適用於透過啟用 MTOM 之端點傳送的訊息；MTOM 編碼器也可以解碼並剖析傳入的非 MTOM 訊息。</span><span class="sxs-lookup"><span data-stu-id="9718c-180">This "MTOM-only" rule applies only to messages sent through an MTOM-enabled endpoint; the MTOM-encoder can decode and parse incoming non-MTOM messages as well.</span></span>  
  
 <span data-ttu-id="9718c-181">使用 MTOM 編碼器符合所有其他 WCF 功能。</span><span class="sxs-lookup"><span data-stu-id="9718c-181">Using the MTOM encoder conforms with all other WCF features.</span></span> <span data-ttu-id="9718c-182">請注意，您可能無法在所有的情況中都看到這項規則，例如當需要工作階段支援時。</span><span class="sxs-lookup"><span data-stu-id="9718c-182">Note that it may not be possible to observe this rule in all cases, such as when session support is required.</span></span>  
  
### <a name="programming-model"></a><span data-ttu-id="9718c-183">程式設計模型</span><span class="sxs-lookup"><span data-stu-id="9718c-183">Programming Model</span></span>  
 <span data-ttu-id="9718c-184">不論您在應用程式中使用這三種內建編碼器的哪一種，程式設計的操作和傳輸二進位資料時完全相同。</span><span class="sxs-lookup"><span data-stu-id="9718c-184">Regardless of which of the three built-in encoders you use in your application, the programming experience is identical with regards to transferring binary data.</span></span> <span data-ttu-id="9718c-185">其差異在於 WCF 如何根據其資料類型來處理資料。</span><span class="sxs-lookup"><span data-stu-id="9718c-185">The difference is in how WCF handles the data based on their data types.</span></span>  
  
```csharp
[DataContract]  
class MyData  
{  
    [DataMember]  
    byte[] binaryBuffer;  
    [DataMember]  
    string someStringData;  
}
```  
  
 <span data-ttu-id="9718c-186">當使用 MTOM 時，會根據下列規則序列化前面的資料合約：</span><span class="sxs-lookup"><span data-stu-id="9718c-186">When using MTOM, the preceding data contract is serialized according to the following rules:</span></span>  
  
- <span data-ttu-id="9718c-187">如果 `binaryBuffer` 不是 `null`，且當與 Base64 編碼相比時，分別包含足以證明 MTOM 外顯化額外負荷 (MIME 標頭等等) 的資料，資料便會外顯化並包含在訊息中做為二進位 MIME 部分。</span><span class="sxs-lookup"><span data-stu-id="9718c-187">If `binaryBuffer` is not `null` and individually contains enough data to justify the MTOM externalization overhead (MIME headers, and so on) when compared to Base64 encoding, the data is externalized and carried with the message as a binary MIME part.</span></span> <span data-ttu-id="9718c-188">如果未超過臨界值，資料便會編碼為 Base64。</span><span class="sxs-lookup"><span data-stu-id="9718c-188">If the threshold is not exceeded, the data is encoded as Base64.</span></span>  
  
- <span data-ttu-id="9718c-189">不論大小，字串 (以及所有其他不是二進位的型別) 在訊息本文內永遠會表示為字串。</span><span class="sxs-lookup"><span data-stu-id="9718c-189">The string (and all other types that are not binary) is always represented as a string inside the message body, regardless of size.</span></span>  
  
 <span data-ttu-id="9718c-190">不論您是否使用明確的資料合約 (如前例中所述)，在作業中使用參數清單、具備巢狀資料合約，或傳輸集合內的資料合約物件，這在 MTOM 編碼上的作用都是相同的。</span><span class="sxs-lookup"><span data-stu-id="9718c-190">The effect on the MTOM encoding is the same whether you use an explicit data contract, as shown in the preceding example, use a parameter list in an operation, have nested data contracts, or transfer a data contract object inside a collection.</span></span> <span data-ttu-id="9718c-191">位元組陣列永遠是最佳化的候選項目，如果達到最佳化臨界值，則它就是最佳選擇。</span><span class="sxs-lookup"><span data-stu-id="9718c-191">Byte arrays are always candidates for optimization and are optimized if the optimization thresholds are being met.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="9718c-192">您不應在資料合約內使用 <xref:System.IO.Stream?displayProperty=nameWithType> 衍生型別。</span><span class="sxs-lookup"><span data-stu-id="9718c-192">You should not be using <xref:System.IO.Stream?displayProperty=nameWithType> derived types inside of data contracts.</span></span> <span data-ttu-id="9718c-193">資料流資料應使用資料流模型進行通訊，下面的「資料流資料」一節中將有說明。</span><span class="sxs-lookup"><span data-stu-id="9718c-193">Stream data should be communicated using the streaming model, explained in the following "Streaming Data" section.</span></span>  
  
## <a name="streaming-data"></a><span data-ttu-id="9718c-194">資料流資料</span><span class="sxs-lookup"><span data-stu-id="9718c-194">Streaming Data</span></span>  
 <span data-ttu-id="9718c-195">當您有大量的資料要傳輸時，WCF 中的串流傳輸模式是一種可讓您完整緩衝和處理記憶體中訊息的預設行為的替代方法。</span><span class="sxs-lookup"><span data-stu-id="9718c-195">When you have a large amount of data to transfer, the streaming transfer mode in WCF is a feasible alternative to the default behavior of buffering and processing messages in memory in their entirety.</span></span>  
  
 <span data-ttu-id="9718c-196">如同先前所述，如果資料無法分段、如果訊息必須及時傳遞，或是如果資料在初始化傳輸時尚未完全可供使用，只對大型訊息 (含有文字或二進位內容) 啟用資料流。</span><span class="sxs-lookup"><span data-stu-id="9718c-196">As mentioned earlier, enable streaming only for large messages (with text or binary content) if the data cannot be segmented, if the message must be delivered in a timely fashion, or if the data is not yet fully available when the transfer is initiated.</span></span>  
  
### <a name="restrictions"></a><span data-ttu-id="9718c-197">限制</span><span class="sxs-lookup"><span data-stu-id="9718c-197">Restrictions</span></span>  
 <span data-ttu-id="9718c-198">啟用串流時，您無法使用大量的 WCF 功能：</span><span class="sxs-lookup"><span data-stu-id="9718c-198">You cannot use a significant number of WCF features when streaming is enabled:</span></span>  
  
- <span data-ttu-id="9718c-199">無法執行訊息本文的數位簽章，因為它們需要計算整個訊息內容的雜湊。</span><span class="sxs-lookup"><span data-stu-id="9718c-199">Digital signatures for the message body cannot be performed because they require computing a hash over the entire message contents.</span></span> <span data-ttu-id="9718c-200">使用資料流時，由於內容在建構及傳送訊息標頭時尚未完全可供使用，因此無法計算數位簽章。</span><span class="sxs-lookup"><span data-stu-id="9718c-200">With streaming, the content is not fully available when the message headers are constructed and sent and, therefore, a digital signature cannot be computed.</span></span>  
  
- <span data-ttu-id="9718c-201">加密是依賴數位簽章來確認資料已正確地重新建構。</span><span class="sxs-lookup"><span data-stu-id="9718c-201">Encryption depends on digital signatures to verify that the data has been reconstructed correctly.</span></span>  
  
- <span data-ttu-id="9718c-202">如果訊息在傳輸中遺失，可靠工作階段必須緩衝用戶端上已傳送的訊息以供重新傳遞，且在將訊息傳遞至服務實作之前，必須將它們保存在服務上來保留訊息順序，以防收到不依順序的訊息。</span><span class="sxs-lookup"><span data-stu-id="9718c-202">Reliable sessions must buffer sent messages on the client for redelivery if a message gets lost in transfer and must hold messages on the service before handing them to the service implementation to preserve message order in case messages are received out-of-sequence.</span></span>  
  
 <span data-ttu-id="9718c-203">由於這些功能條件約束之故，您對資料流只能使用傳輸層級安全性選項，且無法開啟可靠工作階段。</span><span class="sxs-lookup"><span data-stu-id="9718c-203">Because of these functional constraints, you can use only transport-level security options for streaming and you cannot turn on reliable sessions.</span></span> <span data-ttu-id="9718c-204">資料流只能用於下列系統定義的繫結：</span><span class="sxs-lookup"><span data-stu-id="9718c-204">Streaming is only available with the following system-defined bindings:</span></span>  
  
- <xref:System.ServiceModel.BasicHttpBinding>  
  
- <xref:System.ServiceModel.NetTcpBinding>  
  
- <xref:System.ServiceModel.NetNamedPipeBinding>  
  
- <xref:System.ServiceModel.WebHttpBinding>  
  
 <span data-ttu-id="9718c-205">由於 <xref:System.ServiceModel.NetTcpBinding> 和 <xref:System.ServiceModel.NetNamedPipeBinding> 的基礎傳輸具有固有的可靠傳遞和連線工作階段支援，因此和 HTTP 不同的是，這兩種繫結實際上只受到這些條件約束很小的影響。</span><span class="sxs-lookup"><span data-stu-id="9718c-205">Because the underlying transports of <xref:System.ServiceModel.NetTcpBinding> and <xref:System.ServiceModel.NetNamedPipeBinding> have inherent reliable delivery and connection-based session support, unlike HTTP, these two bindings are only minimally affected by these constraints, in practice.</span></span>  
  
 <span data-ttu-id="9718c-206">資料流無法用於訊息佇列 (MSMQ) 傳輸，因此也無法搭配 <xref:System.ServiceModel.NetMsmqBinding> 或 <xref:System.ServiceModel.MsmqIntegration.MsmqIntegrationBinding> 類別使用。</span><span class="sxs-lookup"><span data-stu-id="9718c-206">Streaming is not available with the Message Queuing (MSMQ) transport and so cannot be used with the <xref:System.ServiceModel.NetMsmqBinding> or the <xref:System.ServiceModel.MsmqIntegration.MsmqIntegrationBinding> class.</span></span> <span data-ttu-id="9718c-207">訊息佇列傳輸只支援訊息大小受限制的緩衝資料傳輸，而所有其他傳輸對於大部分的案例都沒有任何實際的訊息大小限制。</span><span class="sxs-lookup"><span data-stu-id="9718c-207">The Message Queuing transport only supports buffered data transfers with a constrained message size, while all other transports do not have any practical message size limit for the vast majority of scenarios.</span></span>  
  
 <span data-ttu-id="9718c-208">當使用對等通道傳輸時，資料流也無法使用，因此無法用於 <xref:System.ServiceModel.NetPeerTcpBinding>。</span><span class="sxs-lookup"><span data-stu-id="9718c-208">Streaming is also not available when using the Peer Channel transport, so is not available with the <xref:System.ServiceModel.NetPeerTcpBinding>.</span></span>  
  
#### <a name="streaming-and-sessions"></a><span data-ttu-id="9718c-209">資料流與工作階段</span><span class="sxs-lookup"><span data-stu-id="9718c-209">Streaming and Sessions</span></span>  
 <span data-ttu-id="9718c-210">使用工作階段架構繫結對呼叫進行資料流處理時，可能會遇到未預期的行為。</span><span class="sxs-lookup"><span data-stu-id="9718c-210">You may get unexpected behavior when streaming calls with a session-based binding.</span></span> <span data-ttu-id="9718c-211">即使使用的繫結已設定為使用工作階段，所有資料流處理呼叫還是會透過不支援工作階段的單一通道 (資料包通道) 來進行。</span><span class="sxs-lookup"><span data-stu-id="9718c-211">All streaming calls are made through a single channel (the datagram channel) that does not support sessions even if the binding being used is configured to use sessions.</span></span> <span data-ttu-id="9718c-212">如果多個用戶端透過工作階段架構繫結對同一個服務物件進行資料流處理呼叫，而且服務物件的並行模式已設為單一且其執行個體內容模式已設為 PerSession，則所有呼叫必須經過資料包通道，所以一次只能處理一個呼叫。</span><span class="sxs-lookup"><span data-stu-id="9718c-212">If multiple clients make streaming calls to the same service object over a session-based binding and the service object's concurrency mode is set to single and its instance context mode is set to PerSession, all calls must go through the datagram channel and so only one call is processed at a time.</span></span> <span data-ttu-id="9718c-213">一或多個用戶端可能會超時。若要解決這個問題，您可以將服務物件的實例內容模式設定為 PerCall 或平行存取多個。</span><span class="sxs-lookup"><span data-stu-id="9718c-213">One or more clients may then time out. You can work around this issue by either setting the service object's Instance Context Mode to PerCall or Concurrency to Multiple.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="9718c-214">此時 MaxConcurrentSessions 沒有作用，因為只有一個可用的「工作階段」。</span><span class="sxs-lookup"><span data-stu-id="9718c-214">MaxConcurrentSessions has no effect in this case because there is only one "session" available.</span></span>  
  
### <a name="enabling-streaming"></a><span data-ttu-id="9718c-215">啟用資料流</span><span class="sxs-lookup"><span data-stu-id="9718c-215">Enabling Streaming</span></span>  
 <span data-ttu-id="9718c-216">您可以使用下列方法來啟用資料流：</span><span class="sxs-lookup"><span data-stu-id="9718c-216">You can enable streaming in the following ways:</span></span>  
  
- <span data-ttu-id="9718c-217">在資料流模式中傳送及接受要求，而在緩衝模式中接受及傳回回應 (<xref:System.ServiceModel.TransferMode.StreamedRequest>)。</span><span class="sxs-lookup"><span data-stu-id="9718c-217">Send and accept requests in streaming mode, and accept and return responses in buffered mode (<xref:System.ServiceModel.TransferMode.StreamedRequest>).</span></span>  
  
- <span data-ttu-id="9718c-218">在緩衝模式中傳送及接受要求，而在資料流模式中接受及傳回回應 (<xref:System.ServiceModel.TransferMode.StreamedResponse>)。</span><span class="sxs-lookup"><span data-stu-id="9718c-218">Send and accept requests in buffered mode, and accept and return responses in streamed mode (<xref:System.ServiceModel.TransferMode.StreamedResponse>).</span></span>  
  
- <span data-ttu-id="9718c-219">在資料流模式中雙向傳送和接收要求與回應。</span><span class="sxs-lookup"><span data-stu-id="9718c-219">Send and receive requests and responses in streamed mode in both directions.</span></span> <span data-ttu-id="9718c-220">(<xref:System.ServiceModel.TransferMode.Streamed>).</span><span class="sxs-lookup"><span data-stu-id="9718c-220">(<xref:System.ServiceModel.TransferMode.Streamed>).</span></span>  
  
 <span data-ttu-id="9718c-221">您可以將傳輸模式設定為 <xref:System.ServiceModel.TransferMode.Buffered> (這是所有繫結上的預設設定)，以停用資料流。</span><span class="sxs-lookup"><span data-stu-id="9718c-221">You can disable streaming by setting the transfer mode to <xref:System.ServiceModel.TransferMode.Buffered>, which is the default setting on all bindings.</span></span> <span data-ttu-id="9718c-222">下列程式碼顯示如何在組態中設定傳輸模式。</span><span class="sxs-lookup"><span data-stu-id="9718c-222">The following code shows how to set the transfer mode in configuration.</span></span>  
  
```xml  
<system.serviceModel>  
     …  
    <bindings>  
      <basicHttpBinding>  
        <binding name="ExampleBinding" transferMode="Streamed"/>  
      </basicHttpBinding>  
    </bindings>  
     …  
</system.serviceModel>  
```  
  
 <span data-ttu-id="9718c-223">當您在程式碼中產生您的繫結時，必須將繫結的個別 `TransferMode` 屬性 (或是如果您正在撰寫自訂繫結，則為傳輸繫結項目) 設定為前述其中一個值。</span><span class="sxs-lookup"><span data-stu-id="9718c-223">When you instantiate your binding in code, you must set the respective `TransferMode` property of the binding (or the transport binding element if you are composing a custom binding) to one of the previously mentioned values.</span></span>  
  
 <span data-ttu-id="9718c-224">您可以單獨在通訊方的任一端為要求和回覆或雙向開啟資料流，而不影響功能。</span><span class="sxs-lookup"><span data-stu-id="9718c-224">You can turn on streaming for requests and replies or for both directions independently at either side of the communicating parties without affecting functionality.</span></span> <span data-ttu-id="9718c-225">然而，您應該永遠假設傳輸資料大小太過龐大，因此在通訊連結的兩個端點上要調整啟用資料流。</span><span class="sxs-lookup"><span data-stu-id="9718c-225">However, you should always assume that the transferred data size is so significant that enabling streaming is justified on both endpoints of a communication link.</span></span> <span data-ttu-id="9718c-226">對於其中一個端點不是使用 WCF 來執行的跨平臺通訊，使用串流的能力取決於平臺的串流處理功能。</span><span class="sxs-lookup"><span data-stu-id="9718c-226">For cross-platform communication where one of the endpoints is not implemented with WCF, the ability to use streaming depends on the platform's streaming capabilities.</span></span> <span data-ttu-id="9718c-227">另一個少見的例外狀況可能是記憶體消耗導向的案例，其中用戶端或服務必須將工作集減至最小，且只能負荷小量的緩衝區大小。</span><span class="sxs-lookup"><span data-stu-id="9718c-227">Another rare exception might be a memory-consumption driven scenario where a client or service must minimize its working set and can only afford small buffer sizes.</span></span>  
  
### <a name="enabling-asynchronous-streaming"></a><span data-ttu-id="9718c-228">啟用非同步資料流處理</span><span class="sxs-lookup"><span data-stu-id="9718c-228">Enabling Asynchronous Streaming</span></span>  
 <span data-ttu-id="9718c-229">若要啟用非同步資料流，請將 <xref:System.ServiceModel.Description.DispatcherSynchronizationBehavior> 端點行為加入至服務主機，並將其 <xref:System.ServiceModel.Description.DispatcherSynchronizationBehavior.AsynchronousSendEnabled%2A> 屬性設定為 `true`。</span><span class="sxs-lookup"><span data-stu-id="9718c-229">To enable asynchronous streaming, add the  <xref:System.ServiceModel.Description.DispatcherSynchronizationBehavior> endpoint behavior to the service host and set its <xref:System.ServiceModel.Description.DispatcherSynchronizationBehavior.AsynchronousSendEnabled%2A> property to `true`.</span></span> <span data-ttu-id="9718c-230">我們還加入了在傳送端進行真實非同步資料流處理的功能。</span><span class="sxs-lookup"><span data-stu-id="9718c-230">We have also added the capability of true asynchronous streaming on the send side.</span></span> <span data-ttu-id="9718c-231">在將訊息串流至多個用戶端，但部分用戶端可能因為網路擁塞或完全不讀取而造成讀取速度緩慢的情節中，這項功能可以提升服務的延展性。</span><span class="sxs-lookup"><span data-stu-id="9718c-231">This improves scalability of the service in scenarios where it is streaming messages to multiple clients some of which are slow in reading possibly due to network congestion or are not reading at all.</span></span> <span data-ttu-id="9718c-232">在這些情節中，目前不會針對用戶端封鎖服務上的個別執行緒。</span><span class="sxs-lookup"><span data-stu-id="9718c-232">In these scenarios we now do not block individual threads on the service per client.</span></span> <span data-ttu-id="9718c-233">這樣可確保服務可以處理更多的用戶端，從而提升服務的延展性。</span><span class="sxs-lookup"><span data-stu-id="9718c-233">This ensures that the service is able to process many more clients thereby improving the scalability of the service.</span></span>  
  
### <a name="programming-model-for-streamed-transfers"></a><span data-ttu-id="9718c-234">資料流傳輸的程式設計模型</span><span class="sxs-lookup"><span data-stu-id="9718c-234">Programming Model for Streamed Transfers</span></span>  
 <span data-ttu-id="9718c-235">資料流的程式設計模型是很直接的。</span><span class="sxs-lookup"><span data-stu-id="9718c-235">The programming model for streaming is straightforward.</span></span> <span data-ttu-id="9718c-236">如果要接收資料流資料，請指定具有單一 <xref:System.IO.Stream> 型別輸入參數的作業合約。</span><span class="sxs-lookup"><span data-stu-id="9718c-236">For receiving streamed data, specify an operation contract that has a single <xref:System.IO.Stream> typed input parameter.</span></span> <span data-ttu-id="9718c-237">如果要傳回資料流資料，請傳回 <xref:System.IO.Stream> 參照。</span><span class="sxs-lookup"><span data-stu-id="9718c-237">For returning streamed data, return a <xref:System.IO.Stream> reference.</span></span>  
  
```csharp
[ServiceContract(Namespace="http://Microsoft.ServiceModel.Samples")]  
public interface IStreamedService  
{  
    [OperationContract]  
    Stream Echo(Stream data);  
    [OperationContract]  
    Stream RequestInfo(string query);  
    [OperationContract(OneWay=true)]  
    void ProvideInfo(Stream data);  
}  
```  
  
 <span data-ttu-id="9718c-238">前例中的作業 `Echo` 接收並傳回資料流，因此應該用於使用 <xref:System.ServiceModel.TransferMode.Streamed> 的繫結上。</span><span class="sxs-lookup"><span data-stu-id="9718c-238">The operation `Echo` in the preceding example receives and returns a stream and should therefore be used on a binding with <xref:System.ServiceModel.TransferMode.Streamed>.</span></span> <span data-ttu-id="9718c-239">對於作業 `RequestInfo`，<xref:System.ServiceModel.TransferMode.StreamedResponse> 是最適合的，因為它只傳回 <xref:System.IO.Stream>。</span><span class="sxs-lookup"><span data-stu-id="9718c-239">For the operation `RequestInfo`, <xref:System.ServiceModel.TransferMode.StreamedResponse> is best suited, because it only returns a <xref:System.IO.Stream>.</span></span> <span data-ttu-id="9718c-240">單向作業最適合 <xref:System.ServiceModel.TransferMode.StreamedRequest>。</span><span class="sxs-lookup"><span data-stu-id="9718c-240">The one-way operation is best suited for <xref:System.ServiceModel.TransferMode.StreamedRequest>.</span></span>  
  
 <span data-ttu-id="9718c-241">請注意，將第二個參數新增至下列 `Echo` 或 `ProvideInfo` 作業會造成服務模型還原到緩衝策略，並使用資料流的執行階段序列化表示法。</span><span class="sxs-lookup"><span data-stu-id="9718c-241">Note that adding a second parameter to the following `Echo` or `ProvideInfo` operations causes the service model to revert back to a buffered strategy and use the run-time serialization representation of the stream.</span></span> <span data-ttu-id="9718c-242">只有具備單一輸出資料流參數的作業與端對端要求資料流相容。</span><span class="sxs-lookup"><span data-stu-id="9718c-242">Only operations with a single input stream parameter are compatible with end-to-end request streaming.</span></span>  
  
 <span data-ttu-id="9718c-243">這項規則同樣適用於訊息合約。</span><span class="sxs-lookup"><span data-stu-id="9718c-243">This rule similarly applies to message contracts.</span></span> <span data-ttu-id="9718c-244">如同下列訊息合約所示，您在做為資料流的訊息合約中只能有單一本文成員。</span><span class="sxs-lookup"><span data-stu-id="9718c-244">As shown in the following message contract, you can have only a single body member in your message contract that is a stream.</span></span> <span data-ttu-id="9718c-245">如果您希望與資料流進行其他資訊的通訊，此資訊必須包含在訊息標頭中。</span><span class="sxs-lookup"><span data-stu-id="9718c-245">If you want to communicate additional information with the stream, this information must be a carried in message headers.</span></span> <span data-ttu-id="9718c-246">訊息本文是專為資料流內容保留的。</span><span class="sxs-lookup"><span data-stu-id="9718c-246">The message body is exclusively reserved for the stream content.</span></span>  
  
```csharp
[MessageContract]  
public class UploadStreamMessage  
{  
   [MessageHeader]  
   public string appRef;  
   [MessageBodyMember]  
   public Stream data;  
}
```  
  
 <span data-ttu-id="9718c-247">當資料流到達檔案結尾 (EOF) 時，資料流傳輸會結束且訊息會關閉。</span><span class="sxs-lookup"><span data-stu-id="9718c-247">Streamed transfers end and the message is closed when the stream reaches the end of file (EOF).</span></span> <span data-ttu-id="9718c-248">當傳送訊息（傳回值或叫用作業）時，您可以傳遞， <xref:System.IO.FileStream> 而 WCF 基礎結構接著會從該資料流程提取所有資料，直到資料流程已完全讀取並到達 EOF 為止。</span><span class="sxs-lookup"><span data-stu-id="9718c-248">When sending a message (returning a value or invoking an operation), you can pass a <xref:System.IO.FileStream> and the WCF infrastructure subsequently pulls all the data from that stream until the stream has been completely read and reached EOF.</span></span> <span data-ttu-id="9718c-249">如果要傳輸來源中沒有此類預先建立之 <xref:System.IO.Stream> 衍生類別的資料流資料，請建構此類別，將該類別覆疊在您的資料流來源上，然後用來做為引數或傳回值。</span><span class="sxs-lookup"><span data-stu-id="9718c-249">To transfer streamed data for the source that no such pre-built <xref:System.IO.Stream> derived class exists, construct such a class, overlay that class over your stream source, and use that as the argument or return value.</span></span>  
  
 <span data-ttu-id="9718c-250">接收訊息時，WCF 會透過 Base64 編碼的訊息內文內容（或個別的 MIME 部分（如果使用 MTOM）來建立資料流程，而當讀取內容時，資料流程會到達 EOF。</span><span class="sxs-lookup"><span data-stu-id="9718c-250">When receiving a message, WCF constructs a stream over the Base64-encoded message body content (or the respective MIME part if using MTOM) and the stream reaches EOF when the content has been read.</span></span>  
  
 <span data-ttu-id="9718c-251">雖然傳輸層的資料流也會使用任何其他的訊息合約類型 (參數清單、資料合約引數和明確的訊息合約)，但是由於此類型別訊息的序列化和還原序列化需要序列化程式的緩衝處理，因此並不建議使用此類合約變數。</span><span class="sxs-lookup"><span data-stu-id="9718c-251">Transport-level streaming also works with any other message contract type (parameter lists, data contract arguments, and explicit message contract), but because the serialization and deserialization of such typed messages requires buffering by the serializer, using such contract variants is not advisable.</span></span>  
  
### <a name="special-security-considerations-for-large-data"></a><span data-ttu-id="9718c-252">大型資料的特殊安全性考量</span><span class="sxs-lookup"><span data-stu-id="9718c-252">Special Security Considerations for Large Data</span></span>  
 <span data-ttu-id="9718c-253">所有的繫結都可讓您限制傳入訊息的大小，以防止阻絕服務攻擊。</span><span class="sxs-lookup"><span data-stu-id="9718c-253">All bindings allow you to constrain the size of incoming messages to prevent denial-of-service attacks.</span></span> <span data-ttu-id="9718c-254"><xref:System.ServiceModel.BasicHttpBinding>例如，會公開[BasicHttpBinding MaxReceivedMessageSize](xref:System.ServiceModel.HttpBindingBase.MaxReceivedMessageSize%2A)屬性，它會限定傳入訊息的大小，因此也會限制處理訊息時所存取的記憶體數量上限。</span><span class="sxs-lookup"><span data-stu-id="9718c-254">The <xref:System.ServiceModel.BasicHttpBinding>, for example, exposes a [System.ServiceModel.BasicHttpBinding.MaxReceivedMessageSize](xref:System.ServiceModel.HttpBindingBase.MaxReceivedMessageSize%2A) property that bounds the size of the incoming message, and so also bounds the maximum amount of memory that is accessed when processing the message.</span></span> <span data-ttu-id="9718c-255">這個單位的設定是位元組，預設值是 65,536 位元組。</span><span class="sxs-lookup"><span data-stu-id="9718c-255">This unit is set in bytes with a default value of 65,536 bytes.</span></span>  
  
 <span data-ttu-id="9718c-256">大型資料流案例特定的安全性威脅會造成資料在接收者預期進行資料流處理時，進行緩衝處理，引起阻絕服務。</span><span class="sxs-lookup"><span data-stu-id="9718c-256">A security threat that is specific to the large data streaming scenario provokes a denial of service by causing data to be buffered when the receiver expects it to be streamed.</span></span> <span data-ttu-id="9718c-257">例如，WCF 一律會緩衝處理訊息的 SOAP 標頭，因此攻擊者可能會建立完全由標頭組成的大型惡意訊息，以強制緩衝處理資料。</span><span class="sxs-lookup"><span data-stu-id="9718c-257">For example, WCF always buffers the SOAP headers of a message, and so an attacker may construct a large malicious message that consists entirely of headers to force the data to be buffered.</span></span> <span data-ttu-id="9718c-258">當啟用資料流時，`MaxReceivedMessageSize` 可能會設定為極大值，因為接收者絕對不會預期在記憶體中一次緩衝處理整個訊息。</span><span class="sxs-lookup"><span data-stu-id="9718c-258">When streaming is enabled, the `MaxReceivedMessageSize` may be set to an extremely large value, because the receiver never expects the entire message to be buffered in memory at once.</span></span> <span data-ttu-id="9718c-259">如果強制 WCF 會緩衝訊息，則會發生記憶體溢位。</span><span class="sxs-lookup"><span data-stu-id="9718c-259">If WCF is forced to buffer the message, a memory overflow occurs.</span></span>  
  
 <span data-ttu-id="9718c-260">因此，在這種情況中，限制傳入訊息大小上限是不夠的。</span><span class="sxs-lookup"><span data-stu-id="9718c-260">Therefore, restricting the maximum incoming message size is not enough in this case.</span></span> <span data-ttu-id="9718c-261">`MaxBufferSize`需要屬性來限制 WCF 緩衝區的記憶體。</span><span class="sxs-lookup"><span data-stu-id="9718c-261">The `MaxBufferSize` property is required to constrain the memory that WCF buffers.</span></span> <span data-ttu-id="9718c-262">重要的是在資料流處理時，將它設定為安全值 (或保留為預設值)。</span><span class="sxs-lookup"><span data-stu-id="9718c-262">It is important to set this to a safe value (or keep it at the default value) when streaming.</span></span> <span data-ttu-id="9718c-263">例如，假設您的服務必須接收大小高達 4 GB 的檔案，然後儲存在本機磁碟上。</span><span class="sxs-lookup"><span data-stu-id="9718c-263">For example, suppose your service must receive files up to 4 GB in size and store them on the local disk.</span></span> <span data-ttu-id="9718c-264">也請假設您的記憶體受到一次只能緩衝處理 64 KB 資料的限制。</span><span class="sxs-lookup"><span data-stu-id="9718c-264">Suppose also that your memory is constrained in such a way that you can only buffer 64 KB of data at a time.</span></span> <span data-ttu-id="9718c-265">然後您會將 `MaxReceivedMessageSize` 設定為 4 GB，而將 `MaxBufferSize` 設定為 64 KB。</span><span class="sxs-lookup"><span data-stu-id="9718c-265">Then you would set the `MaxReceivedMessageSize` to 4 GB and `MaxBufferSize` to 64 KB.</span></span> <span data-ttu-id="9718c-266">同時，在您的服務實作中，必須確保您只從 64 KB 區塊的傳入資料流讀取，而且在前一個區塊寫入磁碟並從記憶體捨棄之前，不會讀取下一個區塊。</span><span class="sxs-lookup"><span data-stu-id="9718c-266">Also, in your service implementation, you must ensure that you read only from the incoming stream in 64-KB chunks and do not read the next chunk before the previous one has been written to disk and discarded from memory.</span></span>  
  
 <span data-ttu-id="9718c-267">也請務必瞭解，此配額只會限制 WCF 完成的緩衝，而且無法保護您在自己的服務或用戶端執行中所做的任何緩衝。</span><span class="sxs-lookup"><span data-stu-id="9718c-267">It is also important to understand that this quota only limits the buffering done by WCF and cannot protect you against any buffering that you do in your own service or client implementation.</span></span> <span data-ttu-id="9718c-268">如需其他安全性考慮的詳細資訊，請參閱[資料的安全性考慮](security-considerations-for-data.md)。</span><span class="sxs-lookup"><span data-stu-id="9718c-268">For more information about additional security considerations, see [Security Considerations for Data](security-considerations-for-data.md).</span></span>  
  
> [!NOTE]
> <span data-ttu-id="9718c-269">使用緩衝或資料流傳輸是由端點處決定。</span><span class="sxs-lookup"><span data-stu-id="9718c-269">The decision to use either buffered or streamed transfers is a local decision of the endpoint.</span></span> <span data-ttu-id="9718c-270">如果是 HTTP 傳輸，傳輸模式不會在連線上傳播，或是在 Proxy 伺服器與其他媒介之間進行傳播。</span><span class="sxs-lookup"><span data-stu-id="9718c-270">For HTTP transports, the transfer mode does not propagate across a connection or to proxy servers and other intermediaries.</span></span> <span data-ttu-id="9718c-271">設定傳輸模式不會反映在服務介面的描述中。</span><span class="sxs-lookup"><span data-stu-id="9718c-271">Setting the transfer mode is not reflected in the description of the service interface.</span></span> <span data-ttu-id="9718c-272">將 WCF 用戶端產生到服務之後，您必須針對要搭配資料流程傳輸使用的服務編輯設定檔，以設定模式。</span><span class="sxs-lookup"><span data-stu-id="9718c-272">After generating a WCF client to a service, you must edit the configuration file for services intended to be used with streamed transfers to set the mode.</span></span> <span data-ttu-id="9718c-273">如果是 TCP 和具名管道傳輸，會傳播傳輸模式做為原則判斷提示。</span><span class="sxs-lookup"><span data-stu-id="9718c-273">For TCP and named pipe transports, the transfer mode is propagated as a policy assertion.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="9718c-274">請參閱</span><span class="sxs-lookup"><span data-stu-id="9718c-274">See also</span></span>

- [<span data-ttu-id="9718c-275">HOW TO：啟用資料流</span><span class="sxs-lookup"><span data-stu-id="9718c-275">How to: Enable Streaming</span></span>](how-to-enable-streaming.md)
