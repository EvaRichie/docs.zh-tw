---
title: 佇列通訊的最佳做法
ms.date: 03/30/2017
helpviewer_keywords:
- queues [WCF], best practices
- best practices [WCF], queued communication
ms.assetid: 446a6383-cae3-4338-b193-a33c14a49948
ms.openlocfilehash: 412b30a497fcf4c341f80a64c76fcbbc425e70b2
ms.sourcegitcommit: bc293b14af795e0e999e3304dd40c0222cf2ffe4
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 11/26/2020
ms.locfileid: "96247443"
---
# <a name="best-practices-for-queued-communication"></a><span data-ttu-id="bf298-102">佇列通訊的最佳做法</span><span class="sxs-lookup"><span data-stu-id="bf298-102">Best Practices for Queued Communication</span></span>

<span data-ttu-id="bf298-103">本主題提供 Windows Communication Foundation (WCF) 中佇列通訊的建議作法。</span><span class="sxs-lookup"><span data-stu-id="bf298-103">This topic provides recommended practices for queued communication in Windows Communication Foundation (WCF).</span></span> <span data-ttu-id="bf298-104">下列各節由案例的觀點來討論建議的做法。</span><span class="sxs-lookup"><span data-stu-id="bf298-104">The following sections discuss recommended practices from a scenario perspective.</span></span>  
  
## <a name="fast-best-effort-queued-messaging"></a><span data-ttu-id="bf298-105">快速、最佳的佇列傳訊</span><span class="sxs-lookup"><span data-stu-id="bf298-105">Fast, Best-Effort Queued Messaging</span></span>  

 <span data-ttu-id="bf298-106">在需要佇列傳訊提供分離、且以最佳保證提供快速、高效能的傳訊案例中，使用非交易式佇列並且將 <xref:System.ServiceModel.MsmqBindingBase.ExactlyOnce%2A> 屬性設定為 `false`。</span><span class="sxs-lookup"><span data-stu-id="bf298-106">For scenarios that require separation that queued messaging provides and fast, high-performance messaging with best-effort assurances, use a non-transactional queue and set the <xref:System.ServiceModel.MsmqBindingBase.ExactlyOnce%2A> property to `false`.</span></span>  
  
 <span data-ttu-id="bf298-107">此外，您可以透過將 <xref:System.ServiceModel.MsmqBindingBase.Durable%2A> 屬性設定為 `false`，來選擇不要造成磁碟寫入的成本。</span><span class="sxs-lookup"><span data-stu-id="bf298-107">In addition, you can choose not to incur the cost of disk writes by setting the <xref:System.ServiceModel.MsmqBindingBase.Durable%2A> property to `false`.</span></span>  
  
 <span data-ttu-id="bf298-108">安全性隱含對效能的影響。</span><span class="sxs-lookup"><span data-stu-id="bf298-108">Security has implications on performance.</span></span> <span data-ttu-id="bf298-109">如需詳細資訊，請參閱 [效能考慮](performance-considerations.md)。</span><span class="sxs-lookup"><span data-stu-id="bf298-109">For more information, see [Performance Considerations](performance-considerations.md).</span></span>  
  
## <a name="reliable-end-to-end-queued-messaging"></a><span data-ttu-id="bf298-110">可靠的端對端佇列傳訊</span><span class="sxs-lookup"><span data-stu-id="bf298-110">Reliable End-to-End Queued Messaging</span></span>  

 <span data-ttu-id="bf298-111">下列各節描述需要端對端可靠傳訊的案例之建議做法。</span><span class="sxs-lookup"><span data-stu-id="bf298-111">The following sections describe recommended practices for scenarios that require end-to-end reliable messaging.</span></span>  
  
### <a name="basic-reliable-transfer"></a><span data-ttu-id="bf298-112">基本可靠傳輸</span><span class="sxs-lookup"><span data-stu-id="bf298-112">Basic Reliable Transfer</span></span>  

 <span data-ttu-id="bf298-113">對於端對端可靠性，將 <xref:System.ServiceModel.MsmqBindingBase.ExactlyOnce%2A> 屬性設定為 `true` 以確保傳輸。</span><span class="sxs-lookup"><span data-stu-id="bf298-113">For end-to-end reliability, set the <xref:System.ServiceModel.MsmqBindingBase.ExactlyOnce%2A> property to `true` to ensure transfer.</span></span> <span data-ttu-id="bf298-114">視您的需要將 <xref:System.ServiceModel.MsmqBindingBase.Durable%2A> 屬性設定為 `true` 或 `false` (預設為 `true`)。</span><span class="sxs-lookup"><span data-stu-id="bf298-114">The <xref:System.ServiceModel.MsmqBindingBase.Durable%2A> property can be set to `true` or `false` depending on your requirements (the default is `true`).</span></span> <span data-ttu-id="bf298-115">一般而言，<xref:System.ServiceModel.MsmqBindingBase.Durable%2A> 屬性設定為 `true` 以作為端對端可靠性的一部分。</span><span class="sxs-lookup"><span data-stu-id="bf298-115">Generally, the <xref:System.ServiceModel.MsmqBindingBase.Durable%2A> property is set to `true` as part of end-to-end reliability.</span></span> <span data-ttu-id="bf298-116">危害是一種效能成本，但會使訊息成為永久性的訊息，因此佇列管理員中止時，不會遺失訊息。</span><span class="sxs-lookup"><span data-stu-id="bf298-116">The compromise is a performance cost, but makes the message durable so that the message is not lost if a queue manager crashes.</span></span>  
  
### <a name="use-of-transactions"></a><span data-ttu-id="bf298-117">使用異動</span><span class="sxs-lookup"><span data-stu-id="bf298-117">Use of Transactions</span></span>  

 <span data-ttu-id="bf298-118">您必須使用異動來確保端對端的可靠性。</span><span class="sxs-lookup"><span data-stu-id="bf298-118">You must use transactions to ensure end-to-end reliability.</span></span> <span data-ttu-id="bf298-119">`ExactlyOnce` 保證只能夠確保訊息傳送到目標佇列。</span><span class="sxs-lookup"><span data-stu-id="bf298-119">`ExactlyOnce` assurances only ensure that messages are delivered to the target queue.</span></span> <span data-ttu-id="bf298-120">若要確保收到訊息，請使用交易。</span><span class="sxs-lookup"><span data-stu-id="bf298-120">To ensure that the message is received, use transactions.</span></span> <span data-ttu-id="bf298-121">如果沒有使用交易，在服務中止時，您會遺失實際上正在傳遞給應用程式的訊息。</span><span class="sxs-lookup"><span data-stu-id="bf298-121">Without transactions, if the service crashes, you lose the message that is being delivered but is actually delivered to the application.</span></span>  
  
### <a name="use-of-dead-letter-queues"></a><span data-ttu-id="bf298-122">使用寄不出的信件佇列</span><span class="sxs-lookup"><span data-stu-id="bf298-122">Use of Dead-letter Queues</span></span>  

 <span data-ttu-id="bf298-123">寄不出的信件佇列確保在訊息無法傳遞至目標時通知您。</span><span class="sxs-lookup"><span data-stu-id="bf298-123">Dead-letter queues ensure that you are notified if a message fails to be delivered to the target queue.</span></span> <span data-ttu-id="bf298-124">灺可以使用系統提供的寄不出的信件佇列，或自訂的寄不出的信件佇列。</span><span class="sxs-lookup"><span data-stu-id="bf298-124">You can use the system-provided dead-letter queue or a custom dead-letter queue.</span></span> <span data-ttu-id="bf298-125">一般而言，使用自訂的寄不出的信件佇列是最佳選擇，因為它可以讓您將寄不出的信件訊息從某個應用程式傳送到單一寄不出的信件佇列中。</span><span class="sxs-lookup"><span data-stu-id="bf298-125">In general, using a custom dead-letter queue is best because it enables you to send dead-letter messages from one application into a single dead-letter queue.</span></span> <span data-ttu-id="bf298-126">否則，針對在系統上執行的所有應用程式產生的所有寄不出的信件訊息會傳遞到單一佇列。</span><span class="sxs-lookup"><span data-stu-id="bf298-126">Otherwise, all dead-letter messages that occur for all applications running on the system are delivered to a single queue.</span></span> <span data-ttu-id="bf298-127">然後每個應用程式必須搜尋整個寄不出的信件佇列，以尋找和該應用程式相關的寄不出的信件訊息。</span><span class="sxs-lookup"><span data-stu-id="bf298-127">Each application must then search though the dead-letter queue to find the dead-letter messages that are relevant to that application.</span></span> <span data-ttu-id="bf298-128">有時使用自訂的寄不出的信件佇列不可行，例如在使用 MSMQ 3.0 時。</span><span class="sxs-lookup"><span data-stu-id="bf298-128">Sometimes, using a custom dead-letter queue is not feasible, such as when using MSMQ 3.0.</span></span>  
  
 <span data-ttu-id="bf298-129">不建議關閉用於端對端可靠通訊的寄不出的信件佇列。</span><span class="sxs-lookup"><span data-stu-id="bf298-129">Turning off dead-letter queues for end-to-end reliable communication is not recommended.</span></span>  
  
 <span data-ttu-id="bf298-130">如需詳細資訊，請參閱 [使用 Dead-Letter 佇列來處理訊息傳輸失敗](using-dead-letter-queues-to-handle-message-transfer-failures.md)。</span><span class="sxs-lookup"><span data-stu-id="bf298-130">For more information, see [Using Dead-Letter Queues to Handle Message Transfer Failures](using-dead-letter-queues-to-handle-message-transfer-failures.md).</span></span>  
  
### <a name="use-of-poison-message-handling"></a><span data-ttu-id="bf298-131">使用有害訊息處理</span><span class="sxs-lookup"><span data-stu-id="bf298-131">Use of Poison-Message Handling</span></span>  

 <span data-ttu-id="bf298-132">有害訊息處理提供從失敗中復原的能力以處理訊息。</span><span class="sxs-lookup"><span data-stu-id="bf298-132">Poison-message handling provides the ability to recover from the failure to process messages.</span></span>  
  
 <span data-ttu-id="bf298-133">使用有害訊息處理功能時，請確定 <xref:System.ServiceModel.MsmqBindingBase.ReceiveErrorHandling%2A> 屬性已設定為適當的值。</span><span class="sxs-lookup"><span data-stu-id="bf298-133">When using the poison-message handling feature, ensure that the <xref:System.ServiceModel.MsmqBindingBase.ReceiveErrorHandling%2A> property is set to the appropriate value.</span></span> <span data-ttu-id="bf298-134">設定為 <xref:System.ServiceModel.ReceiveErrorHandling.Drop> 表示資料遺失。</span><span class="sxs-lookup"><span data-stu-id="bf298-134">Setting it to <xref:System.ServiceModel.ReceiveErrorHandling.Drop> means the data is lost.</span></span> <span data-ttu-id="bf298-135">另一方面，當偵測到有害訊息時，將它設定為 <xref:System.ServiceModel.ReceiveErrorHandling.Fault> 會導致服務主機發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="bf298-135">On the other hand, setting it to <xref:System.ServiceModel.ReceiveErrorHandling.Fault> faults the service host when it detects a poison message.</span></span> <span data-ttu-id="bf298-136">使用 MSMQ 3.0 時，<xref:System.ServiceModel.ReceiveErrorHandling.Fault> 是避免資料遺失與移走有害訊息的最佳選項。</span><span class="sxs-lookup"><span data-stu-id="bf298-136">Using MSMQ 3.0, <xref:System.ServiceModel.ReceiveErrorHandling.Fault> is the best option to avoid data loss and move the poison message out of the way.</span></span> <span data-ttu-id="bf298-137">使用 MSMQ 4.0 時，<xref:System.ServiceModel.ReceiveErrorHandling.Move> 是建議的處理方式。</span><span class="sxs-lookup"><span data-stu-id="bf298-137">Using MSMQ 4.0, <xref:System.ServiceModel.ReceiveErrorHandling.Move> is the recommended approach.</span></span> <span data-ttu-id="bf298-138"><xref:System.ServiceModel.ReceiveErrorHandling.Move> 會將有害訊息移出佇列，讓服務可以繼續處理新訊息。</span><span class="sxs-lookup"><span data-stu-id="bf298-138"><xref:System.ServiceModel.ReceiveErrorHandling.Move> moves a poisoned message out of the queue so the service can continue to process new messages.</span></span> <span data-ttu-id="bf298-139">然後有害訊息服務可以個別處理有害訊息。</span><span class="sxs-lookup"><span data-stu-id="bf298-139">The poison-message service can then process the poison message separately.</span></span>  
  
 <span data-ttu-id="bf298-140">如需詳細資訊，請參閱 [有害訊息處理](poison-message-handling.md)。</span><span class="sxs-lookup"><span data-stu-id="bf298-140">For more information, see [Poison Message Handling](poison-message-handling.md).</span></span>  
  
## <a name="achieving-high-throughput"></a><span data-ttu-id="bf298-141">達到高輸送量</span><span class="sxs-lookup"><span data-stu-id="bf298-141">Achieving High Throughput</span></span>  

 <span data-ttu-id="bf298-142">若要在單一端點上達到高輸送量，可以使用下列幾項：</span><span class="sxs-lookup"><span data-stu-id="bf298-142">To achieve high throughput on a single endpoint, use the following:</span></span>  
  
- <span data-ttu-id="bf298-143">交易的批次處理。</span><span class="sxs-lookup"><span data-stu-id="bf298-143">Transacted batching.</span></span> <span data-ttu-id="bf298-144">異動的批次處理確保可以在單一異動中讀取多則訊息。</span><span class="sxs-lookup"><span data-stu-id="bf298-144">Transacted batching ensures that many messages can be read in a single transaction.</span></span> <span data-ttu-id="bf298-145">這樣可以最佳化異動認可，因此增加了整體效能。</span><span class="sxs-lookup"><span data-stu-id="bf298-145">This optimizes transaction commits, increasing overall performance.</span></span> <span data-ttu-id="bf298-146">批次處理的代價在於，如果批次內的一則訊息中發生失敗，整個批次都要復原，而且必須一次處理一則訊息，直到再度對批次而言是安全的為止。</span><span class="sxs-lookup"><span data-stu-id="bf298-146">The cost of batching is that if a failure occurs in a single message within a batch, then the entire batch is rolled back and the messages must be processed one at a time until it is safe to batch again.</span></span> <span data-ttu-id="bf298-147">在大部分情況中，傾向於使用批次處理增加系統效能，特別是當您有參與異動的其他資源管理員時。</span><span class="sxs-lookup"><span data-stu-id="bf298-147">In most cases, poison messages are rare, so batching is the preferred way to increase system performance, particularly when you have other resource managers that participate in the transaction.</span></span> <span data-ttu-id="bf298-148">如需詳細資訊，請參閱 [批次處理交易中的訊息](batching-messages-in-a-transaction.md)。</span><span class="sxs-lookup"><span data-stu-id="bf298-148">For more information, see [Batching Messages in a Transaction](batching-messages-in-a-transaction.md).</span></span>  
  
- <span data-ttu-id="bf298-149">並行。</span><span class="sxs-lookup"><span data-stu-id="bf298-149">Concurrency.</span></span> <span data-ttu-id="bf298-150">並行可以增加輸送量，但也會影響對共用資源的爭用。</span><span class="sxs-lookup"><span data-stu-id="bf298-150">Concurrency increases throughput, but concurrency also affects contention to shared resources.</span></span> <span data-ttu-id="bf298-151">如需詳細資訊，請參閱 [並行](../samples/concurrency.md)存取。</span><span class="sxs-lookup"><span data-stu-id="bf298-151">For more information, see [Concurrency](../samples/concurrency.md).</span></span>  
  
- <span data-ttu-id="bf298-152">節流。</span><span class="sxs-lookup"><span data-stu-id="bf298-152">Throttling.</span></span> <span data-ttu-id="bf298-153">為了得到最佳效能，控制在發送器管線中的訊息數目。</span><span class="sxs-lookup"><span data-stu-id="bf298-153">For optimal performance, throttle the number of messages in the dispatcher pipeline.</span></span> <span data-ttu-id="bf298-154">如需如何進行這項操作的範例，請參閱 [節流](../samples/throttling.md)。</span><span class="sxs-lookup"><span data-stu-id="bf298-154">For an example of how to do this, see [Throttling](../samples/throttling.md).</span></span>  
  
 <span data-ttu-id="bf298-155">使用批次處理時，注意轉換為並行批次的並行與節流。</span><span class="sxs-lookup"><span data-stu-id="bf298-155">When using batching, be aware that concurrency and throttling translate to concurrent batches.</span></span>  
  
 <span data-ttu-id="bf298-156">若要達到更高的輸送量和可用性，請使用從佇列讀取之 WCF 服務的伺服器陣列。</span><span class="sxs-lookup"><span data-stu-id="bf298-156">To achieve higher throughput and availability, use a farm of WCF services that read from the queue.</span></span> <span data-ttu-id="bf298-157">這樣做需要所有這些服務在相同的端點上公開相同的合約。</span><span class="sxs-lookup"><span data-stu-id="bf298-157">This requires that all of these services expose the same contract on the same endpoint.</span></span> <span data-ttu-id="bf298-158">陣列方法最適合有高訊息產生速率的應用程式，因為它對所有來自相同佇列的讀取啟用多種服務。</span><span class="sxs-lookup"><span data-stu-id="bf298-158">The farm approach works best for applications that have high production rates of messages because it enables a number of services to all read from the same queue.</span></span>  
  
 <span data-ttu-id="bf298-159">使用陣列時，注意 MSMQ 3.0 不支援遠端交易的讀取。</span><span class="sxs-lookup"><span data-stu-id="bf298-159">When using farms, be aware that MSMQ 3.0 does not support remote transacted reads.</span></span> <span data-ttu-id="bf298-160">MSMQ 4.0 不支援遠端交易的讀取。</span><span class="sxs-lookup"><span data-stu-id="bf298-160">MSMQ 4.0 does support remote transacted reads.</span></span>  
  
 <span data-ttu-id="bf298-161">如需詳細資訊，請參閱在 [交易中批次處理訊息](batching-messages-in-a-transaction.md) ，以及 [Windows Vista、windows Server 2003 和 Windows XP 中佇列功能的差異](diff-in-queue-in-vista-server-2003-windows-xp.md)。</span><span class="sxs-lookup"><span data-stu-id="bf298-161">For more information, see [Batching Messages in a Transaction](batching-messages-in-a-transaction.md) and [Differences in Queuing Features in Windows Vista, Windows Server 2003, and Windows XP](diff-in-queue-in-vista-server-2003-windows-xp.md).</span></span>  
  
## <a name="queuing-with-unit-of-work-semantics"></a><span data-ttu-id="bf298-162">有工作單元語意的佇列</span><span class="sxs-lookup"><span data-stu-id="bf298-162">Queuing with Unit of Work Semantics</span></span>  

 <span data-ttu-id="bf298-163">在有些案例中，可能與佇列中的訊息群組有關，因此這些訊息的排序非常重要。</span><span class="sxs-lookup"><span data-stu-id="bf298-163">In some scenarios a group of messages in a queue may be related and, therefore, the ordering of these messages is significant.</span></span> <span data-ttu-id="bf298-164">在這類案例中，將相關訊息群組視為單一單元而加以處理：全部都成功處理或全部都未成功處理。</span><span class="sxs-lookup"><span data-stu-id="bf298-164">In such scenarios, process a group of related messages together as a single unit: either all of the messages are processed successfully or none are.</span></span> <span data-ttu-id="bf298-165">若要實作這類行為，請使用有佇列的工作階段。</span><span class="sxs-lookup"><span data-stu-id="bf298-165">To implement such behavior, use sessions with queues.</span></span>  
  
 <span data-ttu-id="bf298-166">如需詳細資訊，請參閱 [在會話中群組佇列訊息](grouping-queued-messages-in-a-session.md)。</span><span class="sxs-lookup"><span data-stu-id="bf298-166">For more information, see [Grouping Queued Messages in a Session](grouping-queued-messages-in-a-session.md).</span></span>  
  
## <a name="correlating-request-reply-messages"></a><span data-ttu-id="bf298-167">相關的要求回覆訊息</span><span class="sxs-lookup"><span data-stu-id="bf298-167">Correlating Request-Reply Messages</span></span>  

 <span data-ttu-id="bf298-168">雖然佇列都是單向的，在有些案例中，您可能想要將收到的回覆與之前傳送的要求相互關聯。</span><span class="sxs-lookup"><span data-stu-id="bf298-168">Though queues are typically one-way, in some scenarios you may want to correlate a reply received to a request sent earlier.</span></span> <span data-ttu-id="bf298-169">如果您需要這類關聯，建議您套用自己的 SOA 訊息標頭，此標題包含與訊息關聯的資訊。</span><span class="sxs-lookup"><span data-stu-id="bf298-169">If you require such correlation, it is recommended that you apply your own SOAP message header that contains correlation information with the message.</span></span> <span data-ttu-id="bf298-170">一般來說，寄件者將此標頭附加在訊息中，而處理訊息並以回覆佇列上的新訊息回覆的接收者附加包含關聯資訊的傳送者訊息標頭，因此傳送者可以透過要求訊息來識別回覆訊息。</span><span class="sxs-lookup"><span data-stu-id="bf298-170">Typically, the sender attaches this header with the message, and the receiver, upon processing the message and replying back with a new message on a reply queue, attaches the sender's message header that contains the correlation information so that the sender can identify the reply message with the request message.</span></span>  
  
## <a name="integrating-with-non-wcf-applications"></a><span data-ttu-id="bf298-171">整合非 WCF 應用程式</span><span class="sxs-lookup"><span data-stu-id="bf298-171">Integrating with Non-WCF Applications</span></span>  

 <span data-ttu-id="bf298-172">`MsmqIntegrationBinding`在整合 WCF 服務或用戶端與非 WCF 服務或用戶端時使用。</span><span class="sxs-lookup"><span data-stu-id="bf298-172">Use `MsmqIntegrationBinding` when integrating WCF services or clients with non-WCF services or clients.</span></span> <span data-ttu-id="bf298-173">非 WCF 應用程式可以是使用 System. 訊息、COM +、Visual Basic 或 c + + 撰寫的 MSMQ 應用程式。</span><span class="sxs-lookup"><span data-stu-id="bf298-173">The non-WCF application can be an MSMQ application written using System.Messaging, COM+, Visual Basic, or C++.</span></span>  
  
 <span data-ttu-id="bf298-174">使用 `MsmqIntegrationBinding` 時，請注意下列各點：</span><span class="sxs-lookup"><span data-stu-id="bf298-174">When using `MsmqIntegrationBinding`, be aware of the following:</span></span>  
  
- <span data-ttu-id="bf298-175">WCF 訊息主體與 MSMQ 訊息內文不同。</span><span class="sxs-lookup"><span data-stu-id="bf298-175">A WCF message body is not the same as a MSMQ message body.</span></span> <span data-ttu-id="bf298-176">使用佇列系結傳送 WCF 訊息時，WCF 訊息內文會放置在 MSMQ 訊息內。</span><span class="sxs-lookup"><span data-stu-id="bf298-176">When sending a WCF message using a queued binding, the WCF message body is placed inside of a MSMQ message.</span></span> <span data-ttu-id="bf298-177">MSMQ 基礎結構未注意到此額外資訊，它只看到 MSMQ 訊息。</span><span class="sxs-lookup"><span data-stu-id="bf298-177">The MSMQ infrastructure is oblivious to this extra information; it sees only the MSMQ message.</span></span>  
  
- <span data-ttu-id="bf298-178">`MsmqIntegrationBinding` 支援常見的序列化類型。</span><span class="sxs-lookup"><span data-stu-id="bf298-178">`MsmqIntegrationBinding` supports popular serialization types.</span></span> <span data-ttu-id="bf298-179">根據序列化類型、泛型訊息的本文類型、<xref:System.ServiceModel.MsmqIntegration.MsmqMessage%601>，採用不同類型的參數。</span><span class="sxs-lookup"><span data-stu-id="bf298-179">Based on the serialization type, the body type of the generic message, <xref:System.ServiceModel.MsmqIntegration.MsmqMessage%601>, takes different type parameters.</span></span> <span data-ttu-id="bf298-180">例如，<xref:System.ServiceModel.MsmqIntegration.MsmqMessageSerializationFormat.ByteArray> 需要 `MsmqMessage\<byte[]>`，而 <xref:System.ServiceModel.MsmqIntegration.MsmqMessageSerializationFormat.Stream> 需要 `MsmqMessage<Stream>`。</span><span class="sxs-lookup"><span data-stu-id="bf298-180">For example, <xref:System.ServiceModel.MsmqIntegration.MsmqMessageSerializationFormat.ByteArray> requires `MsmqMessage\<byte[]>` and <xref:System.ServiceModel.MsmqIntegration.MsmqMessageSerializationFormat.Stream> requires `MsmqMessage<Stream>`.</span></span>  
  
- <span data-ttu-id="bf298-181">使用 XML 序列化，您可以使用專案上的屬性來指定已知型別， `KnownTypes` [\<behavior>](../../configure-apps/file-schema/wcf/behavior-of-servicebehaviors.md) 然後用它來判斷如何還原序列化 XML 訊息。</span><span class="sxs-lookup"><span data-stu-id="bf298-181">With XML serialization, you can specify the known type using the `KnownTypes` attribute on the [\<behavior>](../../configure-apps/file-schema/wcf/behavior-of-servicebehaviors.md) element that is then used to determine how to deserialize the XML message.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="bf298-182">另請參閱</span><span class="sxs-lookup"><span data-stu-id="bf298-182">See also</span></span>

- [<span data-ttu-id="bf298-183">WCF 中的佇列</span><span class="sxs-lookup"><span data-stu-id="bf298-183">Queuing in WCF</span></span>](queuing-in-wcf.md)
- [<span data-ttu-id="bf298-184">作法：與 WCF 端點交換佇列訊息</span><span class="sxs-lookup"><span data-stu-id="bf298-184">How to: Exchange Queued Messages with WCF Endpoints</span></span>](how-to-exchange-queued-messages-with-wcf-endpoints.md)
- [<span data-ttu-id="bf298-185">作法：與 WCF 端點和訊息佇列應用程式交換訊息</span><span class="sxs-lookup"><span data-stu-id="bf298-185">How to: Exchange Messages with WCF Endpoints and Message Queuing Applications</span></span>](how-to-exchange-messages-with-wcf-endpoints-and-message-queuing-applications.md)
- [<span data-ttu-id="bf298-186">在工作階段中群組佇列訊息</span><span class="sxs-lookup"><span data-stu-id="bf298-186">Grouping Queued Messages in a Session</span></span>](grouping-queued-messages-in-a-session.md)
- [<span data-ttu-id="bf298-187">批次處理異動中的訊息</span><span class="sxs-lookup"><span data-stu-id="bf298-187">Batching Messages in a Transaction</span></span>](batching-messages-in-a-transaction.md)
- [<span data-ttu-id="bf298-188">使用寄不出的信件佇列來處理訊息傳輸失敗</span><span class="sxs-lookup"><span data-stu-id="bf298-188">Using Dead-Letter Queues to Handle Message Transfer Failures</span></span>](using-dead-letter-queues-to-handle-message-transfer-failures.md)
- [<span data-ttu-id="bf298-189">有害訊息處理</span><span class="sxs-lookup"><span data-stu-id="bf298-189">Poison Message Handling</span></span>](poison-message-handling.md)
- [<span data-ttu-id="bf298-190">Windows Vista、Windows Server 2003 和 Windows XP 之間的佇列功能差異</span><span class="sxs-lookup"><span data-stu-id="bf298-190">Differences in Queuing Features in Windows Vista, Windows Server 2003, and Windows XP</span></span>](diff-in-queue-in-vista-server-2003-windows-xp.md)
- [<span data-ttu-id="bf298-191">使用傳輸安全性來確保訊息的安全</span><span class="sxs-lookup"><span data-stu-id="bf298-191">Securing Messages Using Transport Security</span></span>](securing-messages-using-transport-security.md)
- [<span data-ttu-id="bf298-192">使用訊息安全性來保護訊息的安全</span><span class="sxs-lookup"><span data-stu-id="bf298-192">Securing Messages Using Message Security</span></span>](securing-messages-using-message-security.md)
- [<span data-ttu-id="bf298-193">佇列訊息的疑難排解</span><span class="sxs-lookup"><span data-stu-id="bf298-193">Troubleshooting Queued Messaging</span></span>](troubleshooting-queued-messaging.md)
