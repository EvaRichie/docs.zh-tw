---
title: 使用用戶端存取服務
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: c8329832-bf66-4064-9034-bf39f153fc2d
ms.openlocfilehash: d136e094e4f1ea5258ff568527d10ac25a38f1a9
ms.sourcegitcommit: bc293b14af795e0e999e3304dd40c0222cf2ffe4
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 11/26/2020
ms.locfileid: "96293958"
---
# <a name="accessing-services-using-a-client"></a><span data-ttu-id="92d3d-102">使用用戶端存取服務</span><span class="sxs-lookup"><span data-stu-id="92d3d-102">Accessing Services Using a Client</span></span>

<span data-ttu-id="92d3d-103">用戶端應用程式必須建立、設定和使用 WCF 用戶端或通道物件來與服務通訊。</span><span class="sxs-lookup"><span data-stu-id="92d3d-103">Client applications must create, configure, and use WCF client or channel objects to communicate with services.</span></span> <span data-ttu-id="92d3d-104">[WCF 用戶端總覽](../wcf-client-overview.md)主題概要說明建立基本用戶端和通道物件以及使用這些物件所需的物件和步驟。</span><span class="sxs-lookup"><span data-stu-id="92d3d-104">The [WCF Client Overview](../wcf-client-overview.md) topic provides an overview of the objects and steps involved in creating basic client and channel objects and using them.</span></span>  
  
 <span data-ttu-id="92d3d-105">本主題會就用戶端應用程式以及在不同案例下可能有用的用戶端和通道物件，提供一些相關問題的深入資訊。</span><span class="sxs-lookup"><span data-stu-id="92d3d-105">This topic provides in-depth information about some of the issues with client applications and client and channel objects that may be useful depending upon your scenario.</span></span>  
  
## <a name="overview"></a><span data-ttu-id="92d3d-106">概觀</span><span class="sxs-lookup"><span data-stu-id="92d3d-106">Overview</span></span>  

 <span data-ttu-id="92d3d-107">本主題將說明下列項目的相關行為和問題：</span><span class="sxs-lookup"><span data-stu-id="92d3d-107">This topic describes behavior and issues relating to:</span></span>  
  
- <span data-ttu-id="92d3d-108">通道和工作階段存留期 (Lifetime)。</span><span class="sxs-lookup"><span data-stu-id="92d3d-108">Channel and session lifetimes.</span></span>  
  
- <span data-ttu-id="92d3d-109">處理例外狀況。</span><span class="sxs-lookup"><span data-stu-id="92d3d-109">Handling exceptions.</span></span>  
  
- <span data-ttu-id="92d3d-110">瞭解封鎖問題。</span><span class="sxs-lookup"><span data-stu-id="92d3d-110">Understanding blocking issues.</span></span>  
  
- <span data-ttu-id="92d3d-111">以互動方式初始化通道。</span><span class="sxs-lookup"><span data-stu-id="92d3d-111">Initializing channels interactively.</span></span>  
  
### <a name="channel-and-session-lifetimes"></a><span data-ttu-id="92d3d-112">通道和工作階段存留期。</span><span class="sxs-lookup"><span data-stu-id="92d3d-112">Channel and Session Lifetimes</span></span>  

 <span data-ttu-id="92d3d-113">Windows Communication Foundation (WCF) 應用程式包含兩種類別的通道、資料包和會話。</span><span class="sxs-lookup"><span data-stu-id="92d3d-113">Windows Communication Foundation (WCF) applications includes two categories of channels, datagram and sessionful.</span></span>  
  
 <span data-ttu-id="92d3d-114">*資料包* 通道是所有訊息都不相關的通道。</span><span class="sxs-lookup"><span data-stu-id="92d3d-114">A *datagram* channel is a channel in which all messages are uncorrelated.</span></span> <span data-ttu-id="92d3d-115">使用資料包通道時，如果輸入或輸出作業失敗，下一個作業通常不會受到影響，而且還可以重複使用同一個通道。</span><span class="sxs-lookup"><span data-stu-id="92d3d-115">With a datagram channel, if an input or output operation fails, the next operation is typically unaffected, and the same channel can be reused.</span></span> <span data-ttu-id="92d3d-116">基於這點，資料包通道通常不會發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="92d3d-116">Because of this, datagram channels typically do not fault.</span></span>  
  
 <span data-ttu-id="92d3d-117">不過，*會話* 通道是連接到另一個端點的通道。</span><span class="sxs-lookup"><span data-stu-id="92d3d-117">*Sessionful* channels, however, are channels with a connection to the other endpoint.</span></span> <span data-ttu-id="92d3d-118">某一端工作階段中的訊息永遠都會與另一端的相同工作階段相關聯。</span><span class="sxs-lookup"><span data-stu-id="92d3d-118">Messages in a session on one side are always correlated with the same session on the other side.</span></span> <span data-ttu-id="92d3d-119">此外，工作階段中的參與者雙方都必須同意其對話需求已被滿足，這樣工作階段才能算是成功。</span><span class="sxs-lookup"><span data-stu-id="92d3d-119">In addition, both participants in a session must agree that the requirements of their conversation were met for that session to be considered successful.</span></span> <span data-ttu-id="92d3d-120">如果它們不同意，工作階段通道可能會發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="92d3d-120">If they cannot agree, the sessionful channel may fault.</span></span>  
  
 <span data-ttu-id="92d3d-121">呼叫第一個作業，便可明確地或隱含地開啟用戶端。</span><span class="sxs-lookup"><span data-stu-id="92d3d-121">Open clients explicitly or implicitly by calling the first operation.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="92d3d-122">通常嘗試明確地偵測錯的工作階段通道不會有任何效用，因為您收到通知的時間會依工作階段實作而有不同。</span><span class="sxs-lookup"><span data-stu-id="92d3d-122">Trying to explicitly detect faulted sessionful channels is not typically useful, because when you are notified depends upon the session implementation.</span></span> <span data-ttu-id="92d3d-123">例如，由於 <xref:System.ServiceModel.NetTcpBinding?displayProperty=nameWithType> (已停用可靠工作階段) 會面臨 TCP 連線的工作階段，如果您接聽服務或用戶端上的 <xref:System.ServiceModel.ICommunicationObject.Faulted?displayProperty=nameWithType> 事件，您就有可能會在發生網路失敗時立刻收到通知。</span><span class="sxs-lookup"><span data-stu-id="92d3d-123">For example, because the <xref:System.ServiceModel.NetTcpBinding?displayProperty=nameWithType> (with the reliable session disabled) surfaces the session of the TCP connection, if you listen to the <xref:System.ServiceModel.ICommunicationObject.Faulted?displayProperty=nameWithType> event on the service or the client you are likely to be notified quickly in the event of a network failure.</span></span> <span data-ttu-id="92d3d-124">但可靠工作階段 (透過已啟用 <xref:System.ServiceModel.Channels.ReliableSessionBindingElement?displayProperty=nameWithType> 的繫結所建立) 是設計用來隔離服務與小型的網路失敗。</span><span class="sxs-lookup"><span data-stu-id="92d3d-124">But reliable sessions (established by bindings in which the <xref:System.ServiceModel.Channels.ReliableSessionBindingElement?displayProperty=nameWithType> is enabled) are designed to insulate services from small network failures.</span></span> <span data-ttu-id="92d3d-125">如果工作階段可在合理的時間內重新建立，則相同繫結 (針對可靠工作階段所設定) 就可能不會發生錯誤，除非中斷情形持續了更長的一段時間。</span><span class="sxs-lookup"><span data-stu-id="92d3d-125">If the session can be reestablished within a reasonable period of time, the same binding—configured for reliable sessions—might not fault until the interruption continued for a longer period of time.</span></span>  
  
 <span data-ttu-id="92d3d-126">根據預設，大部分系統提供的繫結 (會將通道公開至應用程式層) 都會使用工作階段，但 <xref:System.ServiceModel.BasicHttpBinding?displayProperty=nameWithType> 則不會。</span><span class="sxs-lookup"><span data-stu-id="92d3d-126">Most of the system-provided bindings (which expose channels to the application layer) use sessions by default, but the <xref:System.ServiceModel.BasicHttpBinding?displayProperty=nameWithType> does not.</span></span> <span data-ttu-id="92d3d-127">如需詳細資訊，請參閱 [使用會話](../using-sessions.md)。</span><span class="sxs-lookup"><span data-stu-id="92d3d-127">For more information, see [Using Sessions](../using-sessions.md).</span></span>  
  
### <a name="the-proper-use-of-sessions"></a><span data-ttu-id="92d3d-128">工作階段的正確用法</span><span class="sxs-lookup"><span data-stu-id="92d3d-128">The Proper Use of Sessions</span></span>  

 <span data-ttu-id="92d3d-129">工作階段會提供特定方式來瞭解整個訊息交換是否已經完成，以及兩端是否都認為此工作階段成功。</span><span class="sxs-lookup"><span data-stu-id="92d3d-129">Sessions provide a way to know if the entire message exchange is complete, and if both sides considered it successful.</span></span> <span data-ttu-id="92d3d-130">建議由呼叫應用程式在一個 try 區塊中開啟通道、使用通道，以及關閉通道。</span><span class="sxs-lookup"><span data-stu-id="92d3d-130">It is recommended that a calling application open the channel, use it, and close the channel inside one try block.</span></span> <span data-ttu-id="92d3d-131">如果工作階段通道已開啟，而呼叫一次 <xref:System.ServiceModel.ICommunicationObject.Close%2A?displayProperty=nameWithType> 方法後有成功傳回該呼叫，就表示工作階段成功。</span><span class="sxs-lookup"><span data-stu-id="92d3d-131">If a session channel is open, and the <xref:System.ServiceModel.ICommunicationObject.Close%2A?displayProperty=nameWithType> method is called once, and that call returns successfully, then the session was successful.</span></span> <span data-ttu-id="92d3d-132">在這個案例中所謂的成功，是指所有傳遞可保證已達成指定的繫結程序，而且另一端在呼叫 <xref:System.ServiceModel.ICommunicationObject.Abort%2A?displayProperty=nameWithType> 之前並沒有呼叫通道上的 <xref:System.ServiceModel.ICommunicationObject.Close%2A>。</span><span class="sxs-lookup"><span data-stu-id="92d3d-132">Successful in this case means that all delivery guarantees the binding specified were met, and the other side did not call <xref:System.ServiceModel.ICommunicationObject.Abort%2A?displayProperty=nameWithType> on the channel before calling <xref:System.ServiceModel.ICommunicationObject.Close%2A>.</span></span>  
  
 <span data-ttu-id="92d3d-133">下列章節將提供這個用戶端方法的範例。</span><span class="sxs-lookup"><span data-stu-id="92d3d-133">The following section provides an example of this client approach.</span></span>  
  
### <a name="handling-exceptions"></a><span data-ttu-id="92d3d-134">例外狀況處理</span><span class="sxs-lookup"><span data-stu-id="92d3d-134">Handling Exceptions</span></span>  

 <span data-ttu-id="92d3d-135">在用戶端應用程式中處理例外狀況是很直接的工作。</span><span class="sxs-lookup"><span data-stu-id="92d3d-135">Handling exceptions in client applications is straightforward.</span></span> <span data-ttu-id="92d3d-136">如果通道是在 try 區塊中開啟、使用以及關閉，則除非有擲回例外狀況，否則對話就算成功。</span><span class="sxs-lookup"><span data-stu-id="92d3d-136">If a channel is opened, used, and closed inside a try block, then the conversation has succeeded, unless an exception is thrown.</span></span> <span data-ttu-id="92d3d-137">一般來說，如果有擲回例外狀況，對話就會中止。</span><span class="sxs-lookup"><span data-stu-id="92d3d-137">Typically, if an exception is thrown the conversation is aborted.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="92d3d-138">`using` `Using` 不建議在 Visual Basic) 中使用 (語句。</span><span class="sxs-lookup"><span data-stu-id="92d3d-138">Use of the `using` statement (`Using` in Visual Basic) is not recommended.</span></span> <span data-ttu-id="92d3d-139">這是因為 `using` 陳述式的結尾可能會引發例外狀況而遮蓋掉您想瞭解的其他例外狀況。</span><span class="sxs-lookup"><span data-stu-id="92d3d-139">This is because the end of the `using` statement can cause exceptions that can mask other exceptions you may need to know about.</span></span> <span data-ttu-id="92d3d-140">如需詳細資訊，請參閱 [使用 Close 和 Abort 釋放 WCF 用戶端資源](../samples/use-close-abort-release-wcf-client-resources.md)。</span><span class="sxs-lookup"><span data-stu-id="92d3d-140">For more information, see [Use Close and Abort to release WCF client resources](../samples/use-close-abort-release-wcf-client-resources.md).</span></span>  
  
 <span data-ttu-id="92d3d-141">下列程式碼範例會顯示使用 try/catch 區塊而非 `using` 陳述式的建議用戶端模式。</span><span class="sxs-lookup"><span data-stu-id="92d3d-141">The following code example shows the recommended client pattern using a try/catch block and not the `using` statement.</span></span>  
  
 [!code-csharp[FaultContractAttribute#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/faultcontractattribute/cs/client.cs#3)]
 [!code-vb[FaultContractAttribute#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/faultcontractattribute/vb/client.vb#3)]  
  
> [!NOTE]
> <span data-ttu-id="92d3d-142">檢查 <xref:System.ServiceModel.ICommunicationObject.State%2A?displayProperty=nameWithType> 屬性的值屬於競爭條件，因此不建議用來判斷是否要重複使用或關閉通道。</span><span class="sxs-lookup"><span data-stu-id="92d3d-142">Checking the value of the <xref:System.ServiceModel.ICommunicationObject.State%2A?displayProperty=nameWithType> property is a race condition and is not recommended to determine whether to reuse or close a channel.</span></span>  
  
 <span data-ttu-id="92d3d-143">即使在關閉時發生例外狀況，資料包通道也絕不會發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="92d3d-143">Datagram channels never fault even if exceptions occur when they are closed.</span></span> <span data-ttu-id="92d3d-144">此外，無法使用安全對話來進行驗證的非雙工用戶端通常會擲回 <xref:System.ServiceModel.Security.MessageSecurityException?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="92d3d-144">In addition, non-duplex clients that fail to authenticate using a secure conversation typically throw a <xref:System.ServiceModel.Security.MessageSecurityException?displayProperty=nameWithType>.</span></span> <span data-ttu-id="92d3d-145">不過，如果使用安全對話的雙工用戶端驗證失敗，則用戶端就會轉而收到 <xref:System.TimeoutException?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="92d3d-145">However if the duplex client using a secure conversation fails to authenticate, the client receives a <xref:System.TimeoutException?displayProperty=nameWithType> instead.</span></span>  
  
 <span data-ttu-id="92d3d-146">如需在應用層級使用錯誤資訊的詳細資訊，請參閱 [指定和處理合約和服務中](../specifying-and-handling-faults-in-contracts-and-services.md)的錯誤。</span><span class="sxs-lookup"><span data-stu-id="92d3d-146">For more complete information about working with error information at the application level, see [Specifying and Handling Faults in Contracts and Services](../specifying-and-handling-faults-in-contracts-and-services.md).</span></span> <span data-ttu-id="92d3d-147">[預期的例外](../samples/expected-exceptions.md) 狀況描述預期的例外狀況，並顯示如何處理它們。</span><span class="sxs-lookup"><span data-stu-id="92d3d-147">[Expected Exceptions](../samples/expected-exceptions.md) describes expected exceptions and shows how to handle them.</span></span> <span data-ttu-id="92d3d-148">如需如何在開發通道時處理錯誤的詳細資訊，請參閱 [處理例外狀況和錯誤](../extending/handling-exceptions-and-faults.md)。</span><span class="sxs-lookup"><span data-stu-id="92d3d-148">For more information about how to handle errors when developing channels, see [Handling Exceptions and Faults](../extending/handling-exceptions-and-faults.md).</span></span>  
  
### <a name="client-blocking-and-performance"></a><span data-ttu-id="92d3d-149">用戶端封鎖和效能</span><span class="sxs-lookup"><span data-stu-id="92d3d-149">Client Blocking and Performance</span></span>  

 <span data-ttu-id="92d3d-150">當應用程式同步呼叫要求-回覆作業時，除非有收到傳回值或擲回例外狀況 (例如 <xref:System.TimeoutException?displayProperty=nameWithType>)，否則用戶端會封鎖。</span><span class="sxs-lookup"><span data-stu-id="92d3d-150">When an application synchronously calls a request-reply operation, the client blocks until a return value is received or an exception (such as a <xref:System.TimeoutException?displayProperty=nameWithType>) is thrown.</span></span> <span data-ttu-id="92d3d-151">這個行為類似本機行為。</span><span class="sxs-lookup"><span data-stu-id="92d3d-151">This behavior is similar to local behavior.</span></span> <span data-ttu-id="92d3d-152">當應用程式同步叫用 WCF 用戶端物件或通道上的作業時，除非通道層可以將資料寫入至網路或擲回例外狀況，否則用戶端不會傳回。</span><span class="sxs-lookup"><span data-stu-id="92d3d-152">When an application synchronously invokes an operation on a WCF client object or channel, the client does not return until the channel layer can write the data to the network or until an exception is thrown.</span></span> <span data-ttu-id="92d3d-153">雖然單向訊息交換模式 (指定方式是標示作業的 <xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A?displayProperty=nameWithType> 設定為 `true`) 可以讓某些用戶端更能有效回應，但單向作業也會根據繫結程序和已經傳送的訊息來執行封鎖。</span><span class="sxs-lookup"><span data-stu-id="92d3d-153">And while the one-way message exchange pattern (specified by marking an operation with <xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A?displayProperty=nameWithType> set to `true`) can make some clients more responsive, one-way operations can also block, depending upon the binding and what messages have already been sent.</span></span> <span data-ttu-id="92d3d-154">單向作業只能進行訊息交換，無法執行其他作業。</span><span class="sxs-lookup"><span data-stu-id="92d3d-154">One-way operations are only about the message exchange, no more and no less.</span></span> <span data-ttu-id="92d3d-155">如需詳細資訊，請參閱 [單向服務](one-way-services.md)。</span><span class="sxs-lookup"><span data-stu-id="92d3d-155">For more information, see [One-Way Services](one-way-services.md).</span></span>  
  
 <span data-ttu-id="92d3d-156">不論在何種訊息交換模式下，大型資料區塊都會減慢用戶端的處理速度。</span><span class="sxs-lookup"><span data-stu-id="92d3d-156">Large data chunks can slow client processing no matter what the message exchange pattern.</span></span> <span data-ttu-id="92d3d-157">若要瞭解如何處理這些問題，請參閱 [大型資料和串流](large-data-and-streaming.md)。</span><span class="sxs-lookup"><span data-stu-id="92d3d-157">To understand how to handle these issues, see [Large Data and Streaming](large-data-and-streaming.md).</span></span>  
  
 <span data-ttu-id="92d3d-158">如果您的應用程式在作業完成時必須執行更多工作，您應該在 WCF 用戶端所執行的服務合約介面上建立異步方法組。</span><span class="sxs-lookup"><span data-stu-id="92d3d-158">If your application must do more work while an operation completes, you should create an asynchronous method pair on the service contract interface that your WCF client implements.</span></span> <span data-ttu-id="92d3d-159">最簡單的方法是在 `/async` [ [System.servicemodel 中繼資料公用程式] 工具上使用參數 ( # A0) ](../servicemodel-metadata-utility-tool-svcutil-exe.md)。</span><span class="sxs-lookup"><span data-stu-id="92d3d-159">The easiest way to do this is to use the `/async` switch on the [ServiceModel Metadata Utility Tool (Svcutil.exe)](../servicemodel-metadata-utility-tool-svcutil-exe.md).</span></span> <span data-ttu-id="92d3d-160">如需範例，請參閱 [如何：以非同步方式呼叫服務作業](how-to-call-wcf-service-operations-asynchronously.md)。</span><span class="sxs-lookup"><span data-stu-id="92d3d-160">For an example, see [How to: Call Service Operations Asynchronously](how-to-call-wcf-service-operations-asynchronously.md).</span></span>  
  
 <span data-ttu-id="92d3d-161">如需提高用戶端效能的詳細資訊，請參閱 [中介層用戶端應用程式](middle-tier-client-applications.md)。</span><span class="sxs-lookup"><span data-stu-id="92d3d-161">For more information about increasing client performance, see [Middle-Tier Client Applications](middle-tier-client-applications.md).</span></span>  
  
### <a name="enabling-the-user-to-select-credentials-dynamically"></a><span data-ttu-id="92d3d-162">讓使用者以動態方式選取認證</span><span class="sxs-lookup"><span data-stu-id="92d3d-162">Enabling the User to Select Credentials Dynamically</span></span>  

 <span data-ttu-id="92d3d-163"><xref:System.ServiceModel.Dispatcher.IInteractiveChannelInitializer> 介面可讓應用程式顯示使用者介面，以便使用者選擇要在逾時計時器啟動之前用來建立通道的認證。</span><span class="sxs-lookup"><span data-stu-id="92d3d-163">The <xref:System.ServiceModel.Dispatcher.IInteractiveChannelInitializer> interface enables applications to display a user interface that enables the user to choose credentials with which a channel is created before the timeout timers start.</span></span>  
  
 <span data-ttu-id="92d3d-164">應用程式開發人員可以透過兩種方式來使用插入的 <xref:System.ServiceModel.Dispatcher.IInteractiveChannelInitializer>。</span><span class="sxs-lookup"><span data-stu-id="92d3d-164">Application developers can make use of an inserted <xref:System.ServiceModel.Dispatcher.IInteractiveChannelInitializer> in two ways.</span></span> <span data-ttu-id="92d3d-165">用戶端應用程式可以在 <xref:System.ServiceModel.ClientBase%601.DisplayInitializationUI%2A?displayProperty=nameWithType> <xref:System.ServiceModel.IClientChannel.DisplayInitializationUI%2A?displayProperty=nameWithType> 開啟通道 (*明確*) 方法之前，先呼叫或 (或非同步版本) ，或呼叫第一項作業 (*隱含* 方法) 。</span><span class="sxs-lookup"><span data-stu-id="92d3d-165">The client application can call either <xref:System.ServiceModel.ClientBase%601.DisplayInitializationUI%2A?displayProperty=nameWithType> or <xref:System.ServiceModel.IClientChannel.DisplayInitializationUI%2A?displayProperty=nameWithType> (or an asynchronous version) prior to opening the channel (the *explicit* approach) or call the first operation (the *implicit* approach).</span></span>  
  
 <span data-ttu-id="92d3d-166">如果使用隱含方式，應用程式就必須在 <xref:System.ServiceModel.ClientBase%601> 或 <xref:System.ServiceModel.IClientChannel> 延伸上呼叫第一項作業。</span><span class="sxs-lookup"><span data-stu-id="92d3d-166">If using the implicit approach, the application must call the first operation on a <xref:System.ServiceModel.ClientBase%601> or <xref:System.ServiceModel.IClientChannel> extension.</span></span> <span data-ttu-id="92d3d-167">如果呼叫第一項作業以外的任何作業，就會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="92d3d-167">If it calls anything other than the first operation, an exception is thrown.</span></span>  
  
 <span data-ttu-id="92d3d-168">如果使用明確方式，應用程式必須依照順序執行下列步驟：</span><span class="sxs-lookup"><span data-stu-id="92d3d-168">If using the explicit approach, the application must perform the following steps in order:</span></span>  
  
1. <span data-ttu-id="92d3d-169">呼叫 <xref:System.ServiceModel.ClientBase%601.DisplayInitializationUI%2A?displayProperty=nameWithType> 或 <xref:System.ServiceModel.IClientChannel.DisplayInitializationUI%2A?displayProperty=nameWithType> (或非同步版本)。</span><span class="sxs-lookup"><span data-stu-id="92d3d-169">Call either <xref:System.ServiceModel.ClientBase%601.DisplayInitializationUI%2A?displayProperty=nameWithType> or <xref:System.ServiceModel.IClientChannel.DisplayInitializationUI%2A?displayProperty=nameWithType> (or an asynchronous version).</span></span>  
  
2. <span data-ttu-id="92d3d-170">當初始設定式已回傳時，在 <xref:System.ServiceModel.ICommunicationObject.Open%2A> 物件或是 <xref:System.ServiceModel.IClientChannel> 屬性傳回的 <xref:System.ServiceModel.IClientChannel> 物件上呼叫 <xref:System.ServiceModel.ClientBase%601.InnerChannel%2A?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="92d3d-170">When the initializers have returned, call either the <xref:System.ServiceModel.ICommunicationObject.Open%2A> method on the <xref:System.ServiceModel.IClientChannel> object or on the <xref:System.ServiceModel.IClientChannel> object returned from the <xref:System.ServiceModel.ClientBase%601.InnerChannel%2A?displayProperty=nameWithType> property.</span></span>  
  
3. <span data-ttu-id="92d3d-171">呼叫作業。</span><span class="sxs-lookup"><span data-stu-id="92d3d-171">Call operations.</span></span>  
  
 <span data-ttu-id="92d3d-172">建議您採用明確方式來處理使用者介面的實際執行品質應用程式控制。</span><span class="sxs-lookup"><span data-stu-id="92d3d-172">It is recommended that production-quality applications control the user-interface process by adopting the explicit approach.</span></span>  
  
 <span data-ttu-id="92d3d-173">使用隱含方式的應用程式會叫用使用者介面初始設定式，但若應用程式的使用者無法在繫結的傳送逾時期限之內回應，當使用者介面傳回時就會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="92d3d-173">Applications that use the implicit approach invoke the user-interface initializers, but if the user of the application fails to respond within the send timeout period of the binding, an exception is thrown when the user interface returns.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="92d3d-174">另請參閱</span><span class="sxs-lookup"><span data-stu-id="92d3d-174">See also</span></span>

- [<span data-ttu-id="92d3d-175">雙工服務</span><span class="sxs-lookup"><span data-stu-id="92d3d-175">Duplex Services</span></span>](duplex-services.md)
- [<span data-ttu-id="92d3d-176">作法：使用單向和要求-回覆合約來存取服務</span><span class="sxs-lookup"><span data-stu-id="92d3d-176">How to: Access Services with One-Way and Request-Reply Contracts</span></span>](how-to-access-wcf-services-with-one-way-and-request-reply-contracts.md)
- [<span data-ttu-id="92d3d-177">作法：使用雙面合約存取服務</span><span class="sxs-lookup"><span data-stu-id="92d3d-177">How to: Access Services with a Duplex Contract</span></span>](how-to-access-services-with-a-duplex-contract.md)
- [<span data-ttu-id="92d3d-178">作法：存取 WSE 3.0 服務</span><span class="sxs-lookup"><span data-stu-id="92d3d-178">How to: Access a WSE 3.0 Service</span></span>](how-to-access-a-wse-3-0-service-with-a-wcf-client.md)
- [<span data-ttu-id="92d3d-179">作法：使用 ChannelFactory</span><span class="sxs-lookup"><span data-stu-id="92d3d-179">How to: Use the ChannelFactory</span></span>](how-to-use-the-channelfactory.md)
- [<span data-ttu-id="92d3d-180">作法：以非同步方式呼叫服務作業</span><span class="sxs-lookup"><span data-stu-id="92d3d-180">How to: Call Service Operations Asynchronously</span></span>](how-to-call-wcf-service-operations-asynchronously.md)
- [<span data-ttu-id="92d3d-181">中介層用戶端應用程式</span><span class="sxs-lookup"><span data-stu-id="92d3d-181">Middle-Tier Client Applications</span></span>](middle-tier-client-applications.md)
