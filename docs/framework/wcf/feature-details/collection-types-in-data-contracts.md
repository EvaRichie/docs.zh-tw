---
title: 資料合約中的集合型別
description: 瞭解資料合約模型如何處理 .NET Framework 中的集合，以及 WCF 如何支援集合類型的資料序列化。
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- collection types [WCF], data contracts
- data contracts [WCF], collection types
- collection types [WCF]
ms.assetid: 9b45b28e-0a82-4ea3-8c33-ec0094aff9d5
ms.openlocfilehash: 83acf1f74bf3cb117f3f94743eda32d3f2cc4b82
ms.sourcegitcommit: 358a28048f36a8dca39a9fe6e6ac1f1913acadd5
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 06/23/2020
ms.locfileid: "85245176"
---
# <a name="collection-types-in-data-contracts"></a><span data-ttu-id="c626e-103">資料合約中的集合型別</span><span class="sxs-lookup"><span data-stu-id="c626e-103">Collection Types in Data Contracts</span></span>

<span data-ttu-id="c626e-104">「 *集合* 」(Collection) 是特定型別之項目的清單。</span><span class="sxs-lookup"><span data-stu-id="c626e-104">A *collection* is a list of items of a certain type.</span></span> <span data-ttu-id="c626e-105">在 .NET Framework 中，這類清單可以使用陣列或各種其他類型（泛型清單、泛型 <xref:System.ComponentModel.BindingList%601> 、 <xref:System.Collections.Specialized.StringCollection> 或）來表示 <xref:System.Collections.ArrayList> 。</span><span class="sxs-lookup"><span data-stu-id="c626e-105">In the .NET Framework, such lists can be represented using arrays or a variety of other types (Generic List, Generic <xref:System.ComponentModel.BindingList%601>, <xref:System.Collections.Specialized.StringCollection>, or <xref:System.Collections.ArrayList>).</span></span> <span data-ttu-id="c626e-106">例如，集合可能含有特定「客戶」的地址清單。</span><span class="sxs-lookup"><span data-stu-id="c626e-106">For example, a collection may hold a list of Addresses for a given Customer.</span></span> <span data-ttu-id="c626e-107">不論實際型別為何，這些集合統稱為「 *清單集合*」(List Collection)。</span><span class="sxs-lookup"><span data-stu-id="c626e-107">These collections are called *list collections*, regardless of their actual type.</span></span>

<span data-ttu-id="c626e-108">特殊形式的集合可以用來表示一個項目 (「索引鍵」) 與另一個項目 (「值」) 之間的關聯。</span><span class="sxs-lookup"><span data-stu-id="c626e-108">A special form of collection exists that represents an association between one item (the "key") and another (the "value").</span></span> <span data-ttu-id="c626e-109">在 .NET Framework 中，這些會以類型（例如 <xref:System.Collections.Hashtable> 和泛型字典）來表示。</span><span class="sxs-lookup"><span data-stu-id="c626e-109">In the .NET Framework, these are represented by types such as <xref:System.Collections.Hashtable> and the generic dictionary.</span></span> <span data-ttu-id="c626e-110">例如，關聯集合可能會將城市 (「索引鍵」) 對應到其人口數目 (「值」)。</span><span class="sxs-lookup"><span data-stu-id="c626e-110">For example, an association collection may map a city ("key") to its population ("value").</span></span> <span data-ttu-id="c626e-111">不論實際型別為何，這些集合統稱為「 *字典集合*」(Dictionary Collection)。</span><span class="sxs-lookup"><span data-stu-id="c626e-111">These collections are called *dictionary collections*, regardless of their actual type.</span></span>

<span data-ttu-id="c626e-112">集合在資料合約模型中會受到特殊處理。</span><span class="sxs-lookup"><span data-stu-id="c626e-112">Collections receive special treatment in the data contract model.</span></span>

<span data-ttu-id="c626e-113">包括陣列與泛型集合等實作 <xref:System.Collections.IEnumerable> 介面的型別，都會識別為集合。</span><span class="sxs-lookup"><span data-stu-id="c626e-113">Types that implement the <xref:System.Collections.IEnumerable> interface, including arrays and generic collections, are recognized as collections.</span></span> <span data-ttu-id="c626e-114">在這些型別中，實作 <xref:System.Collections.IDictionary> 或泛型 <xref:System.Collections.Generic.IDictionary%602> 介面的型別屬於字典集合，而其他所有型別則屬於清單集合。</span><span class="sxs-lookup"><span data-stu-id="c626e-114">Of those, types that implement the <xref:System.Collections.IDictionary> or Generic <xref:System.Collections.Generic.IDictionary%602> interfaces are dictionary collections; all others are list collections.</span></span>

<span data-ttu-id="c626e-115">下列各節將詳細討論集合類型的其他需求，例如具有稱為的方法 `Add` 和無參數的函式。</span><span class="sxs-lookup"><span data-stu-id="c626e-115">Additional requirements on collection types, such as having a method called `Add` and a parameterless constructor, are discussed in detail in the following sections.</span></span> <span data-ttu-id="c626e-116">這樣便可確保集合型別能夠序列化與還原序列化。</span><span class="sxs-lookup"><span data-stu-id="c626e-116">This ensures that collection types can be both serialized and deserialized.</span></span> <span data-ttu-id="c626e-117">這表示某些集合不會直接支援，例如泛型 <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> （因為它沒有無參數的函式）。</span><span class="sxs-lookup"><span data-stu-id="c626e-117">This means that some collections are not directly supported, such as the Generic <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> (because it has no parameterless constructor).</span></span> <span data-ttu-id="c626e-118">不過，如需規避這些限制的詳細資訊，請參閱本主題稍後的「使用集合介面型別和唯讀集合」一節。</span><span class="sxs-lookup"><span data-stu-id="c626e-118">However, for information about circumventing these restrictions, see the section "Using Collection Interface Types and Read-Only Collections" later in this topic.</span></span>

<span data-ttu-id="c626e-119">包含在集合中的型別必須是資料合約類型，否則必須是可序列化的型別。</span><span class="sxs-lookup"><span data-stu-id="c626e-119">The types contained in collections must be data contract types, or be otherwise serializable.</span></span> <span data-ttu-id="c626e-120">如需詳細資訊，請參閱[資料合約序列化程式支援的類型](types-supported-by-the-data-contract-serializer.md)。</span><span class="sxs-lookup"><span data-stu-id="c626e-120">For more information, see [Types Supported by the Data Contract Serializer](types-supported-by-the-data-contract-serializer.md).</span></span>

<span data-ttu-id="c626e-121">如需有關什麼是以及如何序列化集合的詳細資訊，請參閱本主題「先進的集合規則」一節中有關序列化集合的資訊。</span><span class="sxs-lookup"><span data-stu-id="c626e-121">For more information about what is and what is not considered a valid collection, as well as about how collections are serialized, see the information about serializing collections in the "Advanced Collection Rules" section of this topic.</span></span>

## <a name="interchangeable-collections"></a><span data-ttu-id="c626e-122">可互換的集合</span><span class="sxs-lookup"><span data-stu-id="c626e-122">Interchangeable Collections</span></span>

<span data-ttu-id="c626e-123">相同型別的所有清單集合，都會被視為具有相同的資料合約 (除非有使用 <xref:System.Runtime.Serialization.CollectionDataContractAttribute> 屬性來自訂這些集合，如本主題稍後所討論)。</span><span class="sxs-lookup"><span data-stu-id="c626e-123">All list collections of the same type are considered to have the same data contract (unless they are customized using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute, as discussed later in this topic).</span></span> <span data-ttu-id="c626e-124">例如，下列資料合約是相等的。</span><span class="sxs-lookup"><span data-stu-id="c626e-124">Thus, for example, the following data contracts are equivalent.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#0](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#0)]
[!code-vb[c_collection_types_in_data_contracts#0](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#0)]

<span data-ttu-id="c626e-125">這兩個資料合約都會產生與下列程式碼類似的 XML。</span><span class="sxs-lookup"><span data-stu-id="c626e-125">Both data contracts result in XML similar to the following code.</span></span>

```xml
<PurchaseOrder>
    <customerName>...</customerName>
    <items>
        <Item>...</Item>
        <Item>...</Item>
        <Item>...</Item>
        ...
    </items>
    <comments>
        <string>...</string>
        <string>...</string>
        <string>...</string>
        ...
    </comments>
</PurchaseOrder>
```

<span data-ttu-id="c626e-126">集合可互換性讓您能夠使用像是已針對伺服器效能完成最佳化的集合型別，以及設計用來繫結至用戶端上之使用者介面元件的集合型別。</span><span class="sxs-lookup"><span data-stu-id="c626e-126">Collection interchangeability allows you to use, for example, a collection type optimized for performance on the server and a collection type designed to be bound to user interface components on the client.</span></span>

<span data-ttu-id="c626e-127">類似於清單集合，具有相同索引鍵和值型別的所有字典集合都會被視為具有相同的資料合約 (除非已由 <xref:System.Runtime.Serialization.CollectionDataContractAttribute> 屬性自訂)。</span><span class="sxs-lookup"><span data-stu-id="c626e-127">Similar to list collections, all dictionary collections that have the same key and value types are considered to have the same data contract (unless customized by the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute).</span></span>

<span data-ttu-id="c626e-128">就考慮集合的相等性而言，只有資料合約類型 (而非 .NET 型別) 會有影響。</span><span class="sxs-lookup"><span data-stu-id="c626e-128">Only the data contract type matters as far as collection equivalence is concerned, not .NET types.</span></span> <span data-ttu-id="c626e-129">也就是說，如果 Type1 集合與 Type2 集合擁有相同的資料合約，Type1 與 Type2 就會被視為相等。</span><span class="sxs-lookup"><span data-stu-id="c626e-129">That is, a collection of Type1 is considered equivalent to a collection of Type2 if Type1 and Type2 have equivalent data contracts.</span></span>

<span data-ttu-id="c626e-130">非泛型集合也會被視為與 `Object`型別的泛型集合具有相同的資料合約</span><span class="sxs-lookup"><span data-stu-id="c626e-130">Non-generic collections are considered to have the same data contract as generic collections of type `Object`.</span></span> <span data-ttu-id="c626e-131">(例如， <xref:System.Collections.ArrayList> 與 <xref:System.Collections.Generic.List%601> 之泛型 `Object` 的資料合約都是相等的)。</span><span class="sxs-lookup"><span data-stu-id="c626e-131">(For example, the data contracts for <xref:System.Collections.ArrayList> and Generic <xref:System.Collections.Generic.List%601> of `Object` are the same.)</span></span>

## <a name="using-collection-interface-types-and-read-only-collections"></a><span data-ttu-id="c626e-132">使用集合介面型別和唯讀集合</span><span class="sxs-lookup"><span data-stu-id="c626e-132">Using Collection Interface Types and Read-Only Collections</span></span>

<span data-ttu-id="c626e-133">集合介面型別 (<xref:System.Collections.IEnumerable>、 <xref:System.Collections.IDictionary>、泛型 <xref:System.Collections.Generic.IDictionary%602>，或是從這些介面衍生的介面) 也會被視為與實際集合型別具有相等的集合資料合約。</span><span class="sxs-lookup"><span data-stu-id="c626e-133">Collection interface types (<xref:System.Collections.IEnumerable>, <xref:System.Collections.IDictionary>, generic <xref:System.Collections.Generic.IDictionary%602>, or interfaces derived from these interfaces) are also considered as having collection data contracts, equivalent to collection data contracts for actual collection types.</span></span> <span data-ttu-id="c626e-134">這樣一來，便可將要序列化的型別宣告成集合介面型別，而其結果相同於假設是使用實際的集合型別的結果。</span><span class="sxs-lookup"><span data-stu-id="c626e-134">Thus, it is possible to declare the type being serialized as a collection interface type and the results are the same as if an actual collection type had been used.</span></span> <span data-ttu-id="c626e-135">例如，下列資料合約是相等的。</span><span class="sxs-lookup"><span data-stu-id="c626e-135">For example, the following data contracts are equivalent.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#1)]
[!code-vb[c_collection_types_in_data_contracts#1](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#1)]

<span data-ttu-id="c626e-136">在進行序列化期間，當宣告的型別為介面時，使用的實際執行個體型別就可以是實作該介面的任何型別。</span><span class="sxs-lookup"><span data-stu-id="c626e-136">During serialization, when the declared type is an interface, the actual instance type used can be any type that implements that interface.</span></span> <span data-ttu-id="c626e-137">不適用先前所討論的限制（具有無參數的函式和 `Add` 方法）。</span><span class="sxs-lookup"><span data-stu-id="c626e-137">Restrictions discussed previously (having a parameterless constructor and an `Add` method) do not apply.</span></span> <span data-ttu-id="c626e-138">例如，您可以將 Customer2 中的地址設定為地址之泛用 <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> 的執行個體，即使無法直接宣告泛用 <xref:System.Collections.ObjectModel.ReadOnlyCollection%601>型別的資料成員也是如此。</span><span class="sxs-lookup"><span data-stu-id="c626e-138">For example, you can set addresses in Customer2 to an instance of Generic <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> of Address, even though you cannot directly declare a data member of type Generic <xref:System.Collections.ObjectModel.ReadOnlyCollection%601>.</span></span>

<span data-ttu-id="c626e-139">在進行還原序列化期間，如果宣告的型別為介面，序列化引擎便會選擇實作宣告之介面的型別，而且該型別會具現化。</span><span class="sxs-lookup"><span data-stu-id="c626e-139">During deserialization, when the declared type is an interface, the serialization engine chooses a type that implements the declared interface, and the type is instantiated.</span></span> <span data-ttu-id="c626e-140">已知型別機制（在[資料合約已知](data-contract-known-types.md)型別中所述）在這裡沒有任何作用;類型的選擇會內建在 WCF 中。</span><span class="sxs-lookup"><span data-stu-id="c626e-140">The known types mechanism (described in [Data Contract Known Types](data-contract-known-types.md)) has no effect here; the choice of type is built into WCF.</span></span>

## <a name="customizing-collection-types"></a><span data-ttu-id="c626e-141">自訂集合型別</span><span class="sxs-lookup"><span data-stu-id="c626e-141">Customizing Collection Types</span></span>

<span data-ttu-id="c626e-142">您可以使用 <xref:System.Runtime.Serialization.CollectionDataContractAttribute> 屬性來自訂集合型別，此屬性有數種用法。</span><span class="sxs-lookup"><span data-stu-id="c626e-142">You can customize collection types by using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute, which has several uses.</span></span>

<span data-ttu-id="c626e-143">請注意，自訂集合類型會影響集合的可互換性，所以我們一般會建議您盡可能避免套用這個屬性。</span><span class="sxs-lookup"><span data-stu-id="c626e-143">Note that customizing collection types compromises collection interchangeability, so it is generally recommended to avoid applying this attribute whenever possible.</span></span> <span data-ttu-id="c626e-144">如需有關此問題的詳細資訊，請參閱本主題稍後的「先進的集合規則」一節。</span><span class="sxs-lookup"><span data-stu-id="c626e-144">For more information about this issue, see the "Advanced Collection Rules" section later in this topic.</span></span>

### <a name="collection-data-contract-naming"></a><span data-ttu-id="c626e-145">集合資料合約命名</span><span class="sxs-lookup"><span data-stu-id="c626e-145">Collection Data Contract Naming</span></span>

<span data-ttu-id="c626e-146">如 [Data Contract Names](data-contract-names.md)中所述，命名集合型別的規則與命名一般資料合約類型的規則相似，不過其中仍有某些重要差異：</span><span class="sxs-lookup"><span data-stu-id="c626e-146">The rules for naming collection types are similar to those for naming regular data contract types, as described in [Data Contract Names](data-contract-names.md), although some important differences exist:</span></span>

- <span data-ttu-id="c626e-147">使用 <xref:System.Runtime.Serialization.CollectionDataContractAttribute> 屬性來自訂名稱，而不是使用 <xref:System.Runtime.Serialization.DataContractAttribute> 屬性。</span><span class="sxs-lookup"><span data-stu-id="c626e-147">The <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute is used to customize the name, instead of the <xref:System.Runtime.Serialization.DataContractAttribute> attribute.</span></span> <span data-ttu-id="c626e-148"><xref:System.Runtime.Serialization.CollectionDataContractAttribute> 屬性 (Attribute) 也有 `Name` 和 `Namespace` 屬性 (Property)。</span><span class="sxs-lookup"><span data-stu-id="c626e-148">The <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute also has `Name` and `Namespace` properties.</span></span>

- <span data-ttu-id="c626e-149">在未套用 <xref:System.Runtime.Serialization.CollectionDataContractAttribute> 屬性時，集合型別的預設名稱和命名空間 (Namespace) 會取決於集合內所包含型別的名稱和命名空間。</span><span class="sxs-lookup"><span data-stu-id="c626e-149">When the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute is not applied, the default name and namespace for collection types depend on the names and namespaces of types contained within the collection.</span></span> <span data-ttu-id="c626e-150">它們都不會被集合型別本身的名稱和命名空間影響。</span><span class="sxs-lookup"><span data-stu-id="c626e-150">They are not affected by the name and namespace of the collection type itself.</span></span> <span data-ttu-id="c626e-151">如需範例，請參閱下列型別。</span><span class="sxs-lookup"><span data-stu-id="c626e-151">For an example, see the following types.</span></span>

  ```csharp
  public CustomerList1 : Collection<string> {}
  public StringList1 : Collection<string> {}
  ```

<span data-ttu-id="c626e-152">這兩個型別的資料合約名稱都是 "ArrayOfstring"，而不是 "CustomerList1" 或 "StringList1"。</span><span class="sxs-lookup"><span data-stu-id="c626e-152">Both types’ data contract name is "ArrayOfstring" and not "CustomerList1" or "StringList1".</span></span> <span data-ttu-id="c626e-153">這表示在根層級序列化其中任何一個型別時，都會產生與下列程式碼相似的 XML。</span><span class="sxs-lookup"><span data-stu-id="c626e-153">This means that serializing any one of these types at the root level yields XML similar to the following code.</span></span>

```xml
<ArrayOfstring>
    <string>...</string>
    <string>...</string>
    <string>...</string>
    ...
</ArrayOfstring>
```

<span data-ttu-id="c626e-154">選擇這個命名規則的原因，在於要確保表示字串清單的任何非自訂型別都具有相同的資料合約與 XML 表示。</span><span class="sxs-lookup"><span data-stu-id="c626e-154">This naming rule was chosen to ensure that any non-customized type that represents a list of strings has the same data contract and XML representation.</span></span> <span data-ttu-id="c626e-155">這樣集合便可進行互換。</span><span class="sxs-lookup"><span data-stu-id="c626e-155">This makes collection interchangeability possible.</span></span> <span data-ttu-id="c626e-156">在此範例中，CustomerList1 和 StringList1 完全可以互換。</span><span class="sxs-lookup"><span data-stu-id="c626e-156">In this example, CustomerList1 and StringList1 are completely interchangeable.</span></span>

<span data-ttu-id="c626e-157">不過，當套用 <xref:System.Runtime.Serialization.CollectionDataContractAttribute> 屬性 (Attribute) 時，集合會成為自訂的集合資料合約，即使未在此屬性上設定任何屬性 (Property) 也是如此。</span><span class="sxs-lookup"><span data-stu-id="c626e-157">However, when the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute is applied, the collection becomes a customized collection data contract, even if no properties are set on the attribute.</span></span> <span data-ttu-id="c626e-158">這樣一來，集合資料合約的名稱與命名空間便會取決於集合型別本身。</span><span class="sxs-lookup"><span data-stu-id="c626e-158">The name and namespace of the collection data contract then depend on the collection type itself.</span></span> <span data-ttu-id="c626e-159">如需範例，請參閱下列型別。</span><span class="sxs-lookup"><span data-stu-id="c626e-159">For an example, see the following type.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#2)]
[!code-vb[c_collection_types_in_data_contracts#2](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#2)]

<span data-ttu-id="c626e-160">在經過序列化之後，會產生與下列相似的 XML。</span><span class="sxs-lookup"><span data-stu-id="c626e-160">When serialized, the resulting XML is similar to the following.</span></span>

```xml
<CustomerList2>
    <string>...</string>
    <string>...</string>
    <string>...</string>
    ...
</CustomerList2>
```

<span data-ttu-id="c626e-161">請注意，這種 XML 已經不再相同於非自訂化型別的 XML 表示。</span><span class="sxs-lookup"><span data-stu-id="c626e-161">Notice that this is no longer equivalent to the XML representation of the non-customized types.</span></span>

- <span data-ttu-id="c626e-162">您可以使用 `Name` 和 `Namespace` 屬性來進一步自訂命名。</span><span class="sxs-lookup"><span data-stu-id="c626e-162">You can use the `Name` and `Namespace` properties to further customize the naming.</span></span> <span data-ttu-id="c626e-163">請參閱下列類別。</span><span class="sxs-lookup"><span data-stu-id="c626e-163">See the following class.</span></span>

  [!code-csharp[c_collection_types_in_data_contracts#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#3)]
  [!code-vb[c_collection_types_in_data_contracts#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#3)]

<span data-ttu-id="c626e-164">產生的 XML 與下列程式碼相似。</span><span class="sxs-lookup"><span data-stu-id="c626e-164">The resulting XML is similar to the following.</span></span>

```xml
<cust_list>
    <string>...</string>
    <string>...</string>
    <string>...</string>
    ...
</cust_list>
```

<span data-ttu-id="c626e-165">如需詳細資訊，請參閱本主題稍後的「先進的集合規則」一節。</span><span class="sxs-lookup"><span data-stu-id="c626e-165">For more information, see the "Advanced Collection Rules" section later in this topic.</span></span>

### <a name="customizing-the-repeating-element-name-in-list-collections"></a><span data-ttu-id="c626e-166">自訂清單集合中的重複項目名稱</span><span class="sxs-lookup"><span data-stu-id="c626e-166">Customizing the Repeating Element Name in List Collections</span></span>

<span data-ttu-id="c626e-167">清單集合包含一些重複的項目。</span><span class="sxs-lookup"><span data-stu-id="c626e-167">List collections contain repeating entries.</span></span> <span data-ttu-id="c626e-168">通常，每個重複項目都會以項目表示，該項目會根據集合內所包含型別的資料合約名稱來命名。</span><span class="sxs-lookup"><span data-stu-id="c626e-168">Normally, each repeating entry is represented as an element named according to the data contract name of the type contained in the collection.</span></span>

<span data-ttu-id="c626e-169">在 `CustomerList` 範例中，集合包含的是字串。</span><span class="sxs-lookup"><span data-stu-id="c626e-169">In the `CustomerList` examples, the collections contained strings.</span></span> <span data-ttu-id="c626e-170">字串基本型別的資料合約名稱為 "string"，因此重複專案為 " \<string> "。</span><span class="sxs-lookup"><span data-stu-id="c626e-170">The data contract name for the string primitive type is "string", so the repeating element was "\<string>".</span></span>

<span data-ttu-id="c626e-171">不過，只要在 <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ItemName%2A> 屬性 (Attribute) 上使用 <xref:System.Runtime.Serialization.CollectionDataContractAttribute> 屬性 (Property)，即可自訂這個重複項目。</span><span class="sxs-lookup"><span data-stu-id="c626e-171">However, using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ItemName%2A> property on the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute, this repeating element name can be customized.</span></span> <span data-ttu-id="c626e-172">如需範例，請參閱下列型別。</span><span class="sxs-lookup"><span data-stu-id="c626e-172">For an example, see the following type.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#4](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#4)]
[!code-vb[c_collection_types_in_data_contracts#4](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#4)]

<span data-ttu-id="c626e-173">產生的 XML 與下列程式碼相似。</span><span class="sxs-lookup"><span data-stu-id="c626e-173">The resulting XML is similar to the following.</span></span>

```xml
<CustomerList4>
    <customer>...</customer>
    <customer>...</customer>
    <customer>...</customer>
    ...
</CustomerList4>
```

<span data-ttu-id="c626e-174">重複項目的命名空間永遠都會與集合資料合約的命名空間相同，而就像先前所述，使用 `Namespace` 屬性便可自訂此命名空間。</span><span class="sxs-lookup"><span data-stu-id="c626e-174">The namespace of the repeating element is always the same as the namespace of the collection data contract, which can be customized using the `Namespace` property, as described previously.</span></span>

### <a name="customizing-dictionary-collections"></a><span data-ttu-id="c626e-175">自訂字典集合</span><span class="sxs-lookup"><span data-stu-id="c626e-175">Customizing Dictionary Collections</span></span>

<span data-ttu-id="c626e-176">字典集合基本上就是項目清單，其中的每個項目都有後接一個值的索引鍵。</span><span class="sxs-lookup"><span data-stu-id="c626e-176">Dictionary collections are essentially lists of entries, where each entry has a key followed by a value.</span></span> <span data-ttu-id="c626e-177">就像是在使用一般清單，您可以使用 <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ItemName%2A> 屬性來變更重複項目的對應項目名稱。</span><span class="sxs-lookup"><span data-stu-id="c626e-177">Just as with regular lists, you can change the element name that corresponds to the repeating element by using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ItemName%2A> property.</span></span>

<span data-ttu-id="c626e-178">此外，您也可以使用 <xref:System.Runtime.Serialization.CollectionDataContractAttribute.KeyName%2A> 和 <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ValueName%2A> 屬性來變更表示索引鍵與值的項目名稱。</span><span class="sxs-lookup"><span data-stu-id="c626e-178">Additionally, you can change the element names that represent the key and the value by using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute.KeyName%2A> and <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ValueName%2A> properties.</span></span> <span data-ttu-id="c626e-179">這些項目的命名空間都與集合資料合約的命名空間相同。</span><span class="sxs-lookup"><span data-stu-id="c626e-179">The namespaces for these elements are the same as the namespace of the collection data contract.</span></span>

<span data-ttu-id="c626e-180">如需範例，請參閱下列型別。</span><span class="sxs-lookup"><span data-stu-id="c626e-180">For an example, see the following type.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#5](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#5)]
[!code-vb[c_collection_types_in_data_contracts#5](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#5)]

<span data-ttu-id="c626e-181">在經過序列化之後，會產生與下列相似的 XML。</span><span class="sxs-lookup"><span data-stu-id="c626e-181">When serialized, the resulting XML is similar to the following.</span></span>

```xml
<CountriesOrRegionsWithCapitals>
    <entry>
        <countryorregion>USA</countryorregion>
        <capital>Washington</capital>
    </entry>
    <entry>
        <countryorregion>France</countryorregion>
        <capital>Paris</capital>
    </entry>
    ...
</CountriesOrRegionsWithCapitals>
```

<span data-ttu-id="c626e-182">如需字典集合的詳細資訊，請參閱本主題稍後的「先進的集合規則」一節。</span><span class="sxs-lookup"><span data-stu-id="c626e-182">For more information about dictionary collections, see the "Advanced Collection Rules" section later in this topic.</span></span>

## <a name="collections-and-known-types"></a><span data-ttu-id="c626e-183">集合與已知型別</span><span class="sxs-lookup"><span data-stu-id="c626e-183">Collections and Known Types</span></span>

<span data-ttu-id="c626e-184">當使用多型方式，將集合取代其他集合或集合介面時，您並不需要將集合型別新增到已知型別中。</span><span class="sxs-lookup"><span data-stu-id="c626e-184">You do not need to add collection types to known types when used polymorphically in place of other collections or collection interfaces.</span></span> <span data-ttu-id="c626e-185">例如，如果您宣告 <xref:System.Collections.IEnumerable> 型別的資料成員，並使用該成員傳送 <xref:System.Collections.ArrayList>的執行個體，這時您並不需要將 <xref:System.Collections.ArrayList> 新增到已知型別。</span><span class="sxs-lookup"><span data-stu-id="c626e-185">For example, if you declare a data member of type <xref:System.Collections.IEnumerable> and use it to send an instance of <xref:System.Collections.ArrayList>, you do not need to add <xref:System.Collections.ArrayList> to known types.</span></span>

<span data-ttu-id="c626e-186">當您以多型方式使用集合來取代非集合型別時，這些集合就必須加入至已知型別中。</span><span class="sxs-lookup"><span data-stu-id="c626e-186">When you use collections polymorphically in place of non-collection types, they must be added to known types.</span></span> <span data-ttu-id="c626e-187">例如，如果您宣告 `Object` 型別的資料成員，並使用該成員來傳送 <xref:System.Collections.ArrayList>的執行個體，請將 <xref:System.Collections.ArrayList> 加入至已知型別。</span><span class="sxs-lookup"><span data-stu-id="c626e-187">For example, if you declare a data member of type `Object` and use it to send an instance of <xref:System.Collections.ArrayList>, add <xref:System.Collections.ArrayList> to known types.</span></span>

<span data-ttu-id="c626e-188">這時您無法以多型方式來序列化任何相等的集合。</span><span class="sxs-lookup"><span data-stu-id="c626e-188">This does not allow you to serialize any equivalent collection polymorphically.</span></span> <span data-ttu-id="c626e-189">例如，在上一個範例中，當您將 <xref:System.Collections.ArrayList> 加入至已知型別清單時，這樣無法讓您指派 `Array of Object` 類別，即使此類別具有相等的資料合約也是如此。</span><span class="sxs-lookup"><span data-stu-id="c626e-189">For example, when you add <xref:System.Collections.ArrayList> to the list of known types in the preceding example, this does not let you assign the `Array of Object` class, even though it has an equivalent data contract.</span></span> <span data-ttu-id="c626e-190">這點與非集合型別進行序列化時的一般已知型別行為並無不同，但是由於集合經常都是相等的，因此最好特別弄清楚這樣對集合而言的意義為何。</span><span class="sxs-lookup"><span data-stu-id="c626e-190">This is no different from regular known types behavior on serialization for non-collection types, but it is especially important to understand in the case of collections because it is very common for collections to be equivalent.</span></span>

<span data-ttu-id="c626e-191">在序列化期間，任何資料合約的任何範圍中只能有一個已知的型別，而且相等的集合都會具有相同的資料合約。</span><span class="sxs-lookup"><span data-stu-id="c626e-191">During serialization, only one type can be known in any given scope for a given data contract, and equivalent collections all have the same data contracts.</span></span> <span data-ttu-id="c626e-192">這表示在先前的範例中，您不可以將 <xref:System.Collections.ArrayList> 和 `Array of Object` 同時加入至相同範圍中的已知型別。</span><span class="sxs-lookup"><span data-stu-id="c626e-192">This means that, in the previous example, you cannot add both <xref:System.Collections.ArrayList> and `Array of Object` to known types at the same scope.</span></span> <span data-ttu-id="c626e-193">同樣地，這個行為相同於非集合型別的已知型別行為，但是您要特別弄清楚這樣對於集合的意義為何。</span><span class="sxs-lookup"><span data-stu-id="c626e-193">Again, this is equivalent to known types behavior for non-collection types, but it is especially important to understand for collections.</span></span>

<span data-ttu-id="c626e-194">集合的內容也可能需要已知型別。</span><span class="sxs-lookup"><span data-stu-id="c626e-194">Known types may also be required for contents of collections.</span></span> <span data-ttu-id="c626e-195">例如，如果實際上 <xref:System.Collections.ArrayList> 是包含 `Type1` 與 `Type2`的執行個體，這兩個型別就應該要同時新增到已知型別。</span><span class="sxs-lookup"><span data-stu-id="c626e-195">For example, if an <xref:System.Collections.ArrayList> actually contains instances of `Type1` and `Type2`, both of these types should be added to known types.</span></span>

<span data-ttu-id="c626e-196">下列範例會示範使用集合與已知型別而正確建構的物件圖形。</span><span class="sxs-lookup"><span data-stu-id="c626e-196">The following example shows a properly constructed object graph using collections and known types.</span></span> <span data-ttu-id="c626e-197">這個範例有點不自然，因為在實際的應用程式中，您通常不會將下列資料成員定義為 `Object`，並因此不會有任何已知型別/多型問題。</span><span class="sxs-lookup"><span data-stu-id="c626e-197">The example is somewhat contrived, because in an actual application you would normally not define the following data members as `Object`, and thus do not have any known type/polymorphism issues.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#6](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#6)]
[!code-vb[c_collection_types_in_data_contracts#6](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#6)]

<span data-ttu-id="c626e-198">在進行還原序列化時，如果宣告的型別是集合型別，則無論實際傳送的型別為何，這個已宣告型別都會完成具現化。</span><span class="sxs-lookup"><span data-stu-id="c626e-198">On deserialization, if the declared type is a collection type, the declared type is instantiated regardless of the type that was actually sent.</span></span> <span data-ttu-id="c626e-199">如果宣告的型別是集合介面，還原序列化程式就會挑選要具現化的型別而不管已知型別為何。</span><span class="sxs-lookup"><span data-stu-id="c626e-199">If the declared type is a collection interface, the deserializer picks a type to be instantiated with no regard to known types.</span></span>

<span data-ttu-id="c626e-200">另外，在還原序列化期間，如果宣告的型別不是集合型別，但是正在傳送的卻是某個集合型別，這時會從已知型別清單中挑選符合的集合型別。</span><span class="sxs-lookup"><span data-stu-id="c626e-200">Also on deserialization, if the declared type is not a collection type but a collection type is being sent, a matching collection type is picked out of the known types list.</span></span> <span data-ttu-id="c626e-201">您也可以在進行還原序列化時，將集合介面型別新增到已知型別的清單中。</span><span class="sxs-lookup"><span data-stu-id="c626e-201">It is possible to add collection interface types to the list of known types on deserialization.</span></span> <span data-ttu-id="c626e-202">同樣地，在此情況下，還原序列化引擎會挑選要具現化的型別。</span><span class="sxs-lookup"><span data-stu-id="c626e-202">In this case, the deserialization engine again picks a type to be instantiated.</span></span>

## <a name="collections-and-the-netdatacontractserializer-class"></a><span data-ttu-id="c626e-203">集合與 NetDataContractSerializer 類別</span><span class="sxs-lookup"><span data-stu-id="c626e-203">Collections and the NetDataContractSerializer Class</span></span>

<span data-ttu-id="c626e-204">當使用 <xref:System.Runtime.Serialization.NetDataContractSerializer> 類別時，不是陣列的非自訂化集合型別 (不含 <xref:System.Runtime.Serialization.CollectionDataContractAttribute> 屬性) 會失去其特殊意義。</span><span class="sxs-lookup"><span data-stu-id="c626e-204">When the <xref:System.Runtime.Serialization.NetDataContractSerializer> class is in use, non-customized collection types (without the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute) that are not arrays lose their special meaning.</span></span>

<span data-ttu-id="c626e-205">已標示 <xref:System.SerializableAttribute> 屬性的非自訂化集合型別，依然可由 <xref:System.Runtime.Serialization.NetDataContractSerializer> 類別根據 <xref:System.SerializableAttribute> 屬性或 <xref:System.Runtime.Serialization.ISerializable> 介面規則加以序列化。</span><span class="sxs-lookup"><span data-stu-id="c626e-205">Non-customized collection types marked with the <xref:System.SerializableAttribute> attribute can still be serialized by the <xref:System.Runtime.Serialization.NetDataContractSerializer> class according to the <xref:System.SerializableAttribute> attribute or the <xref:System.Runtime.Serialization.ISerializable> interface rules.</span></span>

<span data-ttu-id="c626e-206">即使此時是使用 <xref:System.Runtime.Serialization.NetDataContractSerializer> 類別，自訂的集合型別、集合介面及陣列依然會被視為集合。</span><span class="sxs-lookup"><span data-stu-id="c626e-206">Customized collection types, collection interfaces, and arrays are still treated as collections, even when the <xref:System.Runtime.Serialization.NetDataContractSerializer> class is in use.</span></span>

## <a name="collections-and-schema"></a><span data-ttu-id="c626e-207">集合與結構描述</span><span class="sxs-lookup"><span data-stu-id="c626e-207">Collections and Schema</span></span>

<span data-ttu-id="c626e-208">所有相等的集合都具有相同的 XML 結構描述定義語言 (XSD) 結構描述表示方式。</span><span class="sxs-lookup"><span data-stu-id="c626e-208">All equivalent collections have the same representation in XML Schema definition language (XSD) schema.</span></span> <span data-ttu-id="c626e-209">基於這點，通常您由所產生用戶端程式碼所取得的集合型別，並不相同於伺服器上的集合型別。</span><span class="sxs-lookup"><span data-stu-id="c626e-209">Because of this, you normally do not get the same collection type in the generated client code as the one on the server.</span></span> <span data-ttu-id="c626e-210">例如，伺服器可能會搭配使用資料合約與整數資料成員的泛型 <xref:System.Collections.Generic.List%601> ，但是在產生的用戶端程式碼中，該相同資料成員可能會成為整數陣列。</span><span class="sxs-lookup"><span data-stu-id="c626e-210">For example, the server may use a data contract with a Generic <xref:System.Collections.Generic.List%601> of Integer data member, but in the generated client code the same data member may become an array of integers.</span></span>

<span data-ttu-id="c626e-211">字典集合會以 WCF 特定的架構注釋標記，表示它們是字典;否則，它們與包含具有索引鍵和值之專案的簡單列表不區分。</span><span class="sxs-lookup"><span data-stu-id="c626e-211">Dictionary collections are marked with a WCF-specific schema annotation that indicate that they are dictionaries; otherwise, they are indistinguishable from simple lists that contain entries with a key and a value.</span></span> <span data-ttu-id="c626e-212">如需集合透過資料合約結構描述之表示方式的詳細描述，請參閱 [Data Contract Schema Reference](data-contract-schema-reference.md)。</span><span class="sxs-lookup"><span data-stu-id="c626e-212">For an exact description of how collections are represented in data contract schema, see [Data Contract Schema Reference](data-contract-schema-reference.md).</span></span>

<span data-ttu-id="c626e-213">根據預設，不會針對已匯入程式碼中的非自訂集合產生型別。</span><span class="sxs-lookup"><span data-stu-id="c626e-213">By default, types are not generated for non-customized collections in imported code.</span></span> <span data-ttu-id="c626e-214">清單集合型別的資料成員都會當做陣列匯入，而字典集合型別的資料成員會當做泛型字典匯入。</span><span class="sxs-lookup"><span data-stu-id="c626e-214">Data members of list collection types are imported as arrays, and data members of dictionary collection types are imported as Generic Dictionary.</span></span>

<span data-ttu-id="c626e-215">不過，對於自訂集合則會產生個別的型別，並標示 <xref:System.Runtime.Serialization.CollectionDataContractAttribute> 屬性。</span><span class="sxs-lookup"><span data-stu-id="c626e-215">However, for customized collections, separate types are generated, marked with the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute.</span></span> <span data-ttu-id="c626e-216">（架構中的自訂集合類型不會使用預設的命名空間、名稱、重複專案名稱或索引鍵/值元素名稱）。這些類型是衍生自泛型的空白類型， <xref:System.Collections.Generic.List%601> 適用于清單類型和字典類型的泛型字典。</span><span class="sxs-lookup"><span data-stu-id="c626e-216">(A customized collection type in the schema is one that does not use the default namespace, name, repeating element name, or key/value element names.) These types are empty types that derive from Generic <xref:System.Collections.Generic.List%601> for list types and Generic Dictionary for dictionary types.</span></span>

<span data-ttu-id="c626e-217">例如，您在伺服器上可能擁有下列型別。</span><span class="sxs-lookup"><span data-stu-id="c626e-217">For example, you may have the following types on the server.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#7](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#7)]
[!code-vb[c_collection_types_in_data_contracts#7](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#7)]

<span data-ttu-id="c626e-218">當匯出結構描述並再度將其匯入時，會產生與下列類似的用戶端程式碼 (此時顯示欄位而非屬性以提高可讀性)。</span><span class="sxs-lookup"><span data-stu-id="c626e-218">When the schema is exported and imported back again, the generated client code is similar to the following (fields are shown instead of properties for ease of reading).</span></span>

[!code-csharp[c_collection_types_in_data_contracts#8](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#8)]
[!code-vb[c_collection_types_in_data_contracts#8](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#8)]

<span data-ttu-id="c626e-219">您可能希望使用所產生程式碼中的不同型別，而不要使用預設的型別。</span><span class="sxs-lookup"><span data-stu-id="c626e-219">You may want to use different types in generated code than the default ones.</span></span> <span data-ttu-id="c626e-220">例如，您可能希望對資料成員使用泛型 <xref:System.ComponentModel.BindingList%601> 而不要使用一般陣列，以便更輕鬆地將成員繫結至使用者介面元件。</span><span class="sxs-lookup"><span data-stu-id="c626e-220">For example, you may want to use Generic <xref:System.ComponentModel.BindingList%601> instead of regular arrays for your data members to make it easier to bind them to user interface components.</span></span>

<span data-ttu-id="c626e-221">若要選擇要產生的集合型別，請在匯入結構描述時，將您要使用的集合型別清單傳入 <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A> 物件的 <xref:System.Runtime.Serialization.ImportOptions> 屬性。</span><span class="sxs-lookup"><span data-stu-id="c626e-221">To choose collection types to generate, pass a list of collection types you want to use into the <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A> property of the <xref:System.Runtime.Serialization.ImportOptions> object when importing schema.</span></span> <span data-ttu-id="c626e-222">這些型別稱為「 *參照集合型別*」(Referenced Collection Type)。</span><span class="sxs-lookup"><span data-stu-id="c626e-222">These types are called *referenced collection types*.</span></span>

<span data-ttu-id="c626e-223">如果是要參考泛型型別，這些型別必須是完全開放式的泛型，或是完全封閉式的泛型。</span><span class="sxs-lookup"><span data-stu-id="c626e-223">When generic types are being referenced, they must either be fully-open generics or fully-closed generics.</span></span>

> [!NOTE]
> <span data-ttu-id="c626e-224">當使用 Svcutil.exe 工具時，即可使用 **/collectionType** 命令列參數完成這項參考作業 (簡短形式： **/ct**)。</span><span class="sxs-lookup"><span data-stu-id="c626e-224">When using the Svcutil.exe tool, this reference can be accomplished by using the **/collectionType** command-line switch (short form: **/ct**).</span></span> <span data-ttu-id="c626e-225">請記住，您必須同時使用 **/reference** 參數 (簡短形式： **/r**) 來指定參照集合型別的組件 (Assembly)。</span><span class="sxs-lookup"><span data-stu-id="c626e-225">Keep in mind that you must also specify the assembly for the referenced collection types using the **/reference** switch (short form: **/r**).</span></span> <span data-ttu-id="c626e-226">如果該型別為泛型，後面就會接上反引號 (\`) 與泛型參數的數目。</span><span class="sxs-lookup"><span data-stu-id="c626e-226">If the type is generic, it must be followed by a back quote and the number of generic parameters.</span></span> <span data-ttu-id="c626e-227">反引號（ \` ）不會與單引號（'）字元混淆。</span><span class="sxs-lookup"><span data-stu-id="c626e-227">The back quote (\`) is not to be confused with the single quote (‘) character.</span></span> <span data-ttu-id="c626e-228">您可以多次使用 **/collectionType** 參數來指定多個參照集合型別。</span><span class="sxs-lookup"><span data-stu-id="c626e-228">You can specify multiple referenced collection types by using the **/collectionType** switch more than once.</span></span>

<span data-ttu-id="c626e-229">例如，使所有清單都當做泛型 <xref:System.Collections.Generic.List%601>匯入。</span><span class="sxs-lookup"><span data-stu-id="c626e-229">For example, to cause all lists to be imported as Generic <xref:System.Collections.Generic.List%601>.</span></span>

```console
svcutil.exe MyService.wsdl MyServiceSchema.xsd /r:C:\full_path_to_system_dll\System.dll /ct:System.Collections.Generic.List`1
```

<span data-ttu-id="c626e-230">匯入任何集合時，就會掃描這份參照集合型別清單，並且在找到一個型別時，將最符合的集合當做資料成員型別 (適用於非自訂集合) 來使用，或是當做要從其中衍生的基底型別 (Base Type) (適用於自訂集合)。</span><span class="sxs-lookup"><span data-stu-id="c626e-230">When importing any collection, this list of referenced collection types is scanned, and the best-matching collection is used if one is found, either as a data member type (for non-customized collections) or as a base type to derive from (for customized collections).</span></span> <span data-ttu-id="c626e-231">字典只會與字典比對，清單也只會與清單比對。</span><span class="sxs-lookup"><span data-stu-id="c626e-231">Dictionaries are only matched against dictionaries, while lists are matched against lists.</span></span>

<span data-ttu-id="c626e-232">例如，如果您將泛型 <xref:System.ComponentModel.BindingList%601> 與 <xref:System.Collections.Hashtable> 新增到參考型別的清單，上述範例會產生與下列相似的用戶端程式碼。</span><span class="sxs-lookup"><span data-stu-id="c626e-232">For example, if you add the Generic <xref:System.ComponentModel.BindingList%601> and <xref:System.Collections.Hashtable> to the list of referenced types, the generated client code for the preceding example is similar to the following.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#9](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#9)]
[!code-vb[c_collection_types_in_data_contracts#9](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#9)]

<span data-ttu-id="c626e-233">您可以指定集合介面型別做為參照集合型別的一部分，不過您不能指定無效的集合型別 (例如沒有 `Add` 方法或公用建構函式的型別)。</span><span class="sxs-lookup"><span data-stu-id="c626e-233">You can specify collection interface types as part of your referenced collection types, but you cannot specify invalid collection types (such as ones with no `Add` method or public constructor).</span></span>

<span data-ttu-id="c626e-234">封閉式泛型會被視為最符合的型別</span><span class="sxs-lookup"><span data-stu-id="c626e-234">A closed generic is considered to be the best match.</span></span> <span data-ttu-id="c626e-235">(非泛型型別則會被視為相等於 `Object`的封閉式泛型)。</span><span class="sxs-lookup"><span data-stu-id="c626e-235">(Non-generic types are considered equivalent to closed generics of `Object`).</span></span> <span data-ttu-id="c626e-236">例如，如果 <xref:System.Collections.Generic.List%601> 的泛型 <xref:System.DateTime>、泛型 <xref:System.ComponentModel.BindingList%601> (開放式泛型) 和 <xref:System.Collections.ArrayList> 都是參照集合型別，便會產生下列結果。</span><span class="sxs-lookup"><span data-stu-id="c626e-236">For example, if the types Generic <xref:System.Collections.Generic.List%601> of <xref:System.DateTime>, Generic <xref:System.ComponentModel.BindingList%601> (open generic), and <xref:System.Collections.ArrayList> are the referenced collection types, the following is generated.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#10](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#10)]
[!code-vb[c_collection_types_in_data_contracts#10](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#10)]

<span data-ttu-id="c626e-237">若是清單集合，則只支援下表中的清況。</span><span class="sxs-lookup"><span data-stu-id="c626e-237">For list collections, only the cases in the following table are supported.</span></span>

|<span data-ttu-id="c626e-238">參考型別</span><span class="sxs-lookup"><span data-stu-id="c626e-238">Referenced type</span></span>|<span data-ttu-id="c626e-239">由參考型別實作的介面</span><span class="sxs-lookup"><span data-stu-id="c626e-239">Interface implemented by referenced type</span></span>|<span data-ttu-id="c626e-240">範例</span><span class="sxs-lookup"><span data-stu-id="c626e-240">Example</span></span>|<span data-ttu-id="c626e-241">型別的處理方式：</span><span class="sxs-lookup"><span data-stu-id="c626e-241">Type treated as:</span></span>|
|---------------------|----------------------------------------------|-------------|----------------------|
|<span data-ttu-id="c626e-242">非泛型或封閉式泛型 (任何參數數目)</span><span class="sxs-lookup"><span data-stu-id="c626e-242">Non-generic or closed generic (any number of parameters)</span></span>|<span data-ttu-id="c626e-243">非泛型</span><span class="sxs-lookup"><span data-stu-id="c626e-243">Non-generic</span></span>|`MyType : IList`<br /><br /> <span data-ttu-id="c626e-244">或</span><span class="sxs-lookup"><span data-stu-id="c626e-244">or</span></span><br /><br /> `MyType<T> : IList`<br /><br /> <span data-ttu-id="c626e-245">其中 T= `int`</span><span class="sxs-lookup"><span data-stu-id="c626e-245">where T= `int`</span></span>|<span data-ttu-id="c626e-246">`Object` 的封閉式泛型 (例如， `IList<object>`)</span><span class="sxs-lookup"><span data-stu-id="c626e-246">Closed generic of `Object` (for example, `IList<object>`)</span></span>|
|<span data-ttu-id="c626e-247">非泛型或封閉式泛型 (任何數目之不需要符合集合型別的參數)</span><span class="sxs-lookup"><span data-stu-id="c626e-247">Non-generic or closed generic (any number of parameters that do not necessarily match the collection type)</span></span>|<span data-ttu-id="c626e-248">封閉式泛型</span><span class="sxs-lookup"><span data-stu-id="c626e-248">Closed generic</span></span>|`MyType : IList<string>`<br /><br /> <span data-ttu-id="c626e-249">或</span><span class="sxs-lookup"><span data-stu-id="c626e-249">or</span></span><br /><br /> <span data-ttu-id="c626e-250">`MyType<T> : IList<string>` 其中 T=`int`</span><span class="sxs-lookup"><span data-stu-id="c626e-250">`MyType<T> : IList<string>` where T=`int`</span></span>|<span data-ttu-id="c626e-251">封閉式泛型 (例如， `IList<string>`)</span><span class="sxs-lookup"><span data-stu-id="c626e-251">Closed generic (for example, `IList<string>`)</span></span>|
|<span data-ttu-id="c626e-252">具有任何參數數目的封閉式泛型</span><span class="sxs-lookup"><span data-stu-id="c626e-252">Closed generic with any number of parameters</span></span>|<span data-ttu-id="c626e-253">使用型別之任何一個參數的開放式泛型</span><span class="sxs-lookup"><span data-stu-id="c626e-253">Open generic using any one of the type’s parameters</span></span>|`MyType<T,U,V> : IList<U>`<br /><br /> <span data-ttu-id="c626e-254">其中 T=`int`，U=`string`，V=`bool`</span><span class="sxs-lookup"><span data-stu-id="c626e-254">where T=`int`, U=`string`, V=`bool`</span></span>|<span data-ttu-id="c626e-255">封閉式泛型 (例如， `IList<string>`)</span><span class="sxs-lookup"><span data-stu-id="c626e-255">Closed generic (for example, `IList<string>`)</span></span>|
|<span data-ttu-id="c626e-256">具有一個參數的開放式泛型</span><span class="sxs-lookup"><span data-stu-id="c626e-256">Open generic with one parameter</span></span>|<span data-ttu-id="c626e-257">使用型別之參數的開放式泛型</span><span class="sxs-lookup"><span data-stu-id="c626e-257">Open generic using the type’s parameter</span></span>|<span data-ttu-id="c626e-258">`MyType<T> : IList<T>`，T 是開放式的</span><span class="sxs-lookup"><span data-stu-id="c626e-258">`MyType<T> : IList<T>`, T is open</span></span>|<span data-ttu-id="c626e-259">開放式泛型 (例如， `IList<T>`)</span><span class="sxs-lookup"><span data-stu-id="c626e-259">Open generic (for example, `IList<T>`)</span></span>|

<span data-ttu-id="c626e-260">如果型別實作一個以上的清單集合介面，則會套用下列限制：</span><span class="sxs-lookup"><span data-stu-id="c626e-260">If a type implements more than one list collection interface, the following restrictions apply:</span></span>

- <span data-ttu-id="c626e-261">如果型別針對不同型別多次實作泛型 <xref:System.Collections.Generic.IEnumerable%601> (或其衍生的介面)，該型別就不會被視為有效的參照集合型別，並將遭到忽略。</span><span class="sxs-lookup"><span data-stu-id="c626e-261">If the type implements Generic <xref:System.Collections.Generic.IEnumerable%601> (or its derived interfaces) multiple times for different types, the type is not considered a valid referenced collection type and is ignored.</span></span> <span data-ttu-id="c626e-262">即使其中一些實作為無效或是使用開放式泛型，也是如此。</span><span class="sxs-lookup"><span data-stu-id="c626e-262">This is true even if some implementations are invalid or use open generics.</span></span> <span data-ttu-id="c626e-263">例如，實作 <xref:System.Collections.Generic.IEnumerable%601> 之泛型 `int` 與 T 之泛型 <xref:System.Collections.Generic.IEnumerable%601> 的型別一律不會當做 `int` 或任何其他型別的參照集合使用，無論該型別是否具有接受 `Add` 的 `int` 方法，或是具有接受型別 T 參數的 `Add` 方法。</span><span class="sxs-lookup"><span data-stu-id="c626e-263">For example, a type that implements Generic <xref:System.Collections.Generic.IEnumerable%601> of `int` and Generic <xref:System.Collections.Generic.IEnumerable%601> of T would never be used as a referenced collection of `int` or any other type, regardless of whether the type has an `Add` method accepting `int` or an `Add` method accepting a parameter of type T, or both.</span></span>

- <span data-ttu-id="c626e-264">如果型別實作泛型集合介面和 <xref:System.Collections.IList>，除非該泛型集合介面是型別 <xref:System.Object>的封閉式泛型，否則該型別永遠不會用來當做參照集合型別。</span><span class="sxs-lookup"><span data-stu-id="c626e-264">If the type implements a generic collection interface as well as <xref:System.Collections.IList>, the type is never used as a referenced collection type unless the generic collection interface is a closed generic of type <xref:System.Object>.</span></span>

<span data-ttu-id="c626e-265">若是字典集合，則只支援下表中的清況。</span><span class="sxs-lookup"><span data-stu-id="c626e-265">For dictionary collections, only the cases in the following table are supported.</span></span>

|<span data-ttu-id="c626e-266">參考型別</span><span class="sxs-lookup"><span data-stu-id="c626e-266">Referenced type</span></span>|<span data-ttu-id="c626e-267">由參考型別實作的介面</span><span class="sxs-lookup"><span data-stu-id="c626e-267">Interface implemented by referenced type</span></span>|<span data-ttu-id="c626e-268">範例</span><span class="sxs-lookup"><span data-stu-id="c626e-268">Example</span></span>|<span data-ttu-id="c626e-269">型別的處理方式</span><span class="sxs-lookup"><span data-stu-id="c626e-269">Type treated as</span></span>|
|---------------------|----------------------------------------------|-------------|---------------------|
|<span data-ttu-id="c626e-270">非泛型或封閉式泛型 (任何參數數目)</span><span class="sxs-lookup"><span data-stu-id="c626e-270">Non-generic or closed generic (any number of parameters)</span></span>|<xref:System.Collections.IDictionary>|`MyType : IDictionary`<br /><br /> <span data-ttu-id="c626e-271">或</span><span class="sxs-lookup"><span data-stu-id="c626e-271">or</span></span><br /><br /> <span data-ttu-id="c626e-272">`MyType<T> : IDictionary` 其中 T=`int`</span><span class="sxs-lookup"><span data-stu-id="c626e-272">`MyType<T> : IDictionary` where T=`int`</span></span>|<span data-ttu-id="c626e-273">封閉式泛型 `IDictionary<object,object>`</span><span class="sxs-lookup"><span data-stu-id="c626e-273">Closed generic `IDictionary<object,object>`</span></span>|
|<span data-ttu-id="c626e-274">封閉式泛型 (任何參數數目)</span><span class="sxs-lookup"><span data-stu-id="c626e-274">Closed generic (any number of parameters)</span></span>|<span data-ttu-id="c626e-275"><xref:System.Collections.Generic.IDictionary%602>，封閉式</span><span class="sxs-lookup"><span data-stu-id="c626e-275"><xref:System.Collections.Generic.IDictionary%602>, closed</span></span>|<span data-ttu-id="c626e-276">`MyType<T> : IDictionary<string, bool>` 其中 T=`int`</span><span class="sxs-lookup"><span data-stu-id="c626e-276">`MyType<T> : IDictionary<string, bool>` where T=`int`</span></span>|<span data-ttu-id="c626e-277">封閉式泛型 (例如， `IDIctionary<string,bool>`)</span><span class="sxs-lookup"><span data-stu-id="c626e-277">Closed generic (for example, `IDIctionary<string,bool>`)</span></span>|
|<span data-ttu-id="c626e-278">封閉式泛型 (任何參數數目)</span><span class="sxs-lookup"><span data-stu-id="c626e-278">Closed generic (any number of parameters)</span></span>|<span data-ttu-id="c626e-279">泛型 <xref:System.Collections.Generic.IDictionary%602>，其中一個索引鍵或值屬封閉式，另一個則為開放式並使用型別的一個參數</span><span class="sxs-lookup"><span data-stu-id="c626e-279">Generic <xref:System.Collections.Generic.IDictionary%602>, one of either key or value is closed, the other is open and uses one of type’s parameters</span></span>|<span data-ttu-id="c626e-280">`MyType<T,U,V> : IDictionary<string,V>` 其中 T=`int`，U=`float`，V=`bool`</span><span class="sxs-lookup"><span data-stu-id="c626e-280">`MyType<T,U,V> : IDictionary<string,V>` where T=`int`, U=`float`,V=`bool`</span></span><br /><br /> <span data-ttu-id="c626e-281">或</span><span class="sxs-lookup"><span data-stu-id="c626e-281">or</span></span><br /><br /> <span data-ttu-id="c626e-282">`MyType<Z> : IDictionary<Z,bool>` 其中 Z=`string`</span><span class="sxs-lookup"><span data-stu-id="c626e-282">`MyType<Z> : IDictionary<Z,bool>` where Z=`string`</span></span>|<span data-ttu-id="c626e-283">封閉式泛型 (例如， `IDictionary<string,bool>`)</span><span class="sxs-lookup"><span data-stu-id="c626e-283">Closed generic (For example, `IDictionary<string,bool>`)</span></span>|
|<span data-ttu-id="c626e-284">封閉式泛型 (任何參數數目)</span><span class="sxs-lookup"><span data-stu-id="c626e-284">Closed generic (any number of parameters)</span></span>|<span data-ttu-id="c626e-285">泛型 <xref:System.Collections.Generic.IDictionary%602>，索引鍵與值都屬開放式，而且每一個都會使用型別的一個參數</span><span class="sxs-lookup"><span data-stu-id="c626e-285">Generic <xref:System.Collections.Generic.IDictionary%602>, both key and value are open and each uses one of the type’s parameters</span></span>|<span data-ttu-id="c626e-286">`MyType<T,U,V> : IDictionary<V,U>` 其中 T=`int`，U=`bool`，V=`string`</span><span class="sxs-lookup"><span data-stu-id="c626e-286">`MyType<T,U,V> : IDictionary<V,U>` where T=`int`, U=`bool`, V=`string`</span></span>|<span data-ttu-id="c626e-287">封閉式泛型 (例如， `IDictionary<string,bool>`)</span><span class="sxs-lookup"><span data-stu-id="c626e-287">Closed generic (for example, `IDictionary<string,bool>`)</span></span>|
|<span data-ttu-id="c626e-288">開放式泛型 (兩個參數)</span><span class="sxs-lookup"><span data-stu-id="c626e-288">Open generic (two parameters)</span></span>|<span data-ttu-id="c626e-289">泛型 <xref:System.Collections.Generic.IDictionary%602>，開放式，依照型別之泛型參數的出現順序來同時使用這兩個參數</span><span class="sxs-lookup"><span data-stu-id="c626e-289">Generic <xref:System.Collections.Generic.IDictionary%602>, open, uses both of the type’s generic parameters in the order they appear</span></span>|<span data-ttu-id="c626e-290">`MyType<K,V> : IDictionary<K,V>`，K 與 V 都屬開放式</span><span class="sxs-lookup"><span data-stu-id="c626e-290">`MyType<K,V> : IDictionary<K,V>`, K and V both open</span></span>|<span data-ttu-id="c626e-291">開放式泛型 (例如， `IDictionary<K,V>`)</span><span class="sxs-lookup"><span data-stu-id="c626e-291">Open generic (for example, `IDictionary<K,V>`)</span></span>|

<span data-ttu-id="c626e-292">如果型別同時實作 <xref:System.Collections.IDictionary> 與泛型 <xref:System.Collections.Generic.IDictionary%602>，這時就只會考慮泛型 <xref:System.Collections.Generic.IDictionary%602> 。</span><span class="sxs-lookup"><span data-stu-id="c626e-292">If the type implements both <xref:System.Collections.IDictionary> and Generic <xref:System.Collections.Generic.IDictionary%602>, only Generic <xref:System.Collections.Generic.IDictionary%602> is considered.</span></span>

<span data-ttu-id="c626e-293">不支援參考部分的泛型型別。</span><span class="sxs-lookup"><span data-stu-id="c626e-293">Referencing partial generic types is not supported.</span></span>

<span data-ttu-id="c626e-294">不允許重複。例如，您不能將 <xref:System.Collections.Generic.List%601> 的泛型 `Integer` 和 `Integer` 的泛型集合同時加入至 <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A>，否則會造成當結構描述中出現整數清單時無法判斷要使用哪一個集合的問題。</span><span class="sxs-lookup"><span data-stu-id="c626e-294">Duplicates are not allowed, for example, you cannot add both the Generic <xref:System.Collections.Generic.List%601> of `Integer` and the Generic Collection of `Integer` to <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A>, because this makes it impossible to determine which one to use when a list of integers is found in the schema.</span></span> <span data-ttu-id="c626e-295">只有當結構描述中有公開重複問題的型別時，才會偵測到重複。</span><span class="sxs-lookup"><span data-stu-id="c626e-295">Duplicates are detected only if there is a type in the schema that exposes the duplicates problem.</span></span> <span data-ttu-id="c626e-296">例如，如果要匯入的結構描述不包含整數的清單，才能允許將 <xref:System.Collections.Generic.List%601> 的泛型 `Integer` 與 `Integer` 的泛型集合新增到 <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A>，不過沒有一個會具有作用。</span><span class="sxs-lookup"><span data-stu-id="c626e-296">For example, if the schema being imported does not contain lists of integers, it is allowed to have both the Generic <xref:System.Collections.Generic.List%601> of `Integer` and the Generic Collection of `Integer` in the <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A>, but neither has any effect.</span></span>

## <a name="advanced-collection-rules"></a><span data-ttu-id="c626e-297">進階集合規則</span><span class="sxs-lookup"><span data-stu-id="c626e-297">Advanced Collection Rules</span></span>

### <a name="serializing-collections"></a><span data-ttu-id="c626e-298">序列化集合</span><span class="sxs-lookup"><span data-stu-id="c626e-298">Serializing Collections</span></span>

<span data-ttu-id="c626e-299">下面是序列化之集合規則的清單：</span><span class="sxs-lookup"><span data-stu-id="c626e-299">The following is a list of collection rules for serialization:</span></span>

- <span data-ttu-id="c626e-300">允許結合集合型別 (即新增集合的集合)。</span><span class="sxs-lookup"><span data-stu-id="c626e-300">Combining collection types (having collections of collections) is allowed.</span></span> <span data-ttu-id="c626e-301">不規則陣列會被視為集合的集合。</span><span class="sxs-lookup"><span data-stu-id="c626e-301">Jagged arrays are treated as collections of collections.</span></span> <span data-ttu-id="c626e-302">不支援多維陣列。</span><span class="sxs-lookup"><span data-stu-id="c626e-302">Multidimensional arrays are not supported.</span></span>

- <span data-ttu-id="c626e-303">位元組的陣列與 <xref:System.Xml.XmlNode> 的陣列，都是會被視為基本型別 (而非集合) 的特殊陣列型別。</span><span class="sxs-lookup"><span data-stu-id="c626e-303">Arrays of byte and arrays of <xref:System.Xml.XmlNode> are special array types that are treated as primitives, not collections.</span></span> <span data-ttu-id="c626e-304">序列化位元組陣列時，會產生含有 Base64 編碼資料區塊的單一 XML 元素，而不是針對各個位元組產生個別元素。</span><span class="sxs-lookup"><span data-stu-id="c626e-304">Serializing an array of byte results in a single XML element that contains a chunk of Base64-encoded data, instead of a separate element for each byte.</span></span> <span data-ttu-id="c626e-305">如需如何處理陣列的詳細資訊 <xref:System.Xml.XmlNode> ，請參閱[資料合約中的 XML 和 ADO.NET 類型](xml-and-ado-net-types-in-data-contracts.md)。</span><span class="sxs-lookup"><span data-stu-id="c626e-305">For more information about how an array of <xref:System.Xml.XmlNode> is treated, see [XML and ADO.NET Types in Data Contracts](xml-and-ado-net-types-in-data-contracts.md).</span></span> <span data-ttu-id="c626e-306">當然，這些特殊型別本身可以參與集合：位元組陣列的陣列會產生多個 XML 項目，其中每個項目會包含 Base64 編碼資料的區塊。</span><span class="sxs-lookup"><span data-stu-id="c626e-306">Of course, these special types can themselves participate in collections: an array of array of byte results in multiple XML elements, with each containing a chunk of Base64-encoded data.</span></span>

- <span data-ttu-id="c626e-307">如果集合型別套用了 <xref:System.Runtime.Serialization.DataContractAttribute> 屬性，該型別就會被視為一般資料合約類型，而不是集合。</span><span class="sxs-lookup"><span data-stu-id="c626e-307">If the <xref:System.Runtime.Serialization.DataContractAttribute> attribute is applied to a collection type, the type is treated as a regular data contract type, not as a collection.</span></span>

- <span data-ttu-id="c626e-308">如果集合型別實作 <xref:System.Xml.Serialization.IXmlSerializable> 介面，則會套用下列規則，並指型別為 `myType:IList<string>, IXmlSerializable`：</span><span class="sxs-lookup"><span data-stu-id="c626e-308">If a collection type implements the <xref:System.Xml.Serialization.IXmlSerializable> interface, the following rules apply, given a type `myType:IList<string>, IXmlSerializable`:</span></span>

  - <span data-ttu-id="c626e-309">如果宣告的型別為 `IList<string>`，則型別會序列化為清單。</span><span class="sxs-lookup"><span data-stu-id="c626e-309">If the declared type is `IList<string>`, the type is serialized as a list.</span></span>

  - <span data-ttu-id="c626e-310">如果宣告的型別為 `myType`，它會序列化為 `IXmlSerializable`。</span><span class="sxs-lookup"><span data-stu-id="c626e-310">If the declared type is `myType`, it is serialized as `IXmlSerializable`.</span></span>

  - <span data-ttu-id="c626e-311">如果宣告的型別為 `IXmlSerializable`，則它會序列化為 `IXmlSerializable`，但只有在您將 `myType` 新增至已知型別的清單中才會這麼做。</span><span class="sxs-lookup"><span data-stu-id="c626e-311">If the declared type is `IXmlSerializable`, it is serialized as `IXmlSerializable`, but only if you add `myType` to the list of known types.</span></span>

- <span data-ttu-id="c626e-312">集合會透過下表中的方法來加以序列化與還原序列化。</span><span class="sxs-lookup"><span data-stu-id="c626e-312">Collections are serialized and deserialized using the methods shown in the following table.</span></span>

|<span data-ttu-id="c626e-313">實作的集合型別</span><span class="sxs-lookup"><span data-stu-id="c626e-313">Collection type implements</span></span>|<span data-ttu-id="c626e-314">進行序列化時呼叫的方法</span><span class="sxs-lookup"><span data-stu-id="c626e-314">Method(s) called on serialization</span></span>|<span data-ttu-id="c626e-315">進行還原序列化時呼叫的方法</span><span class="sxs-lookup"><span data-stu-id="c626e-315">Method(s) called on deserialization</span></span>|
|--------------------------------|-----------------------------------------|-------------------------------------------|
|<span data-ttu-id="c626e-316">泛型 <xref:System.Collections.Generic.IDictionary%602></span><span class="sxs-lookup"><span data-stu-id="c626e-316">Generic <xref:System.Collections.Generic.IDictionary%602></span></span>|<span data-ttu-id="c626e-317">`get_Keys`, `get_Values`</span><span class="sxs-lookup"><span data-stu-id="c626e-317">`get_Keys`, `get_Values`</span></span>|<span data-ttu-id="c626e-318">泛型 Add</span><span class="sxs-lookup"><span data-stu-id="c626e-318">Generic Add</span></span>|
|<xref:System.Collections.IDictionary>|<span data-ttu-id="c626e-319">`get_Keys`, `get_Values`</span><span class="sxs-lookup"><span data-stu-id="c626e-319">`get_Keys`, `get_Values`</span></span>|`Add`|
|<span data-ttu-id="c626e-320">泛型 <xref:System.Collections.Generic.IList%601></span><span class="sxs-lookup"><span data-stu-id="c626e-320">Generic <xref:System.Collections.Generic.IList%601></span></span>|<span data-ttu-id="c626e-321">泛型 <xref:System.Collections.Generic.IList%601> 索引子</span><span class="sxs-lookup"><span data-stu-id="c626e-321">Generic <xref:System.Collections.Generic.IList%601> indexer</span></span>|<span data-ttu-id="c626e-322">泛型 Add</span><span class="sxs-lookup"><span data-stu-id="c626e-322">Generic Add</span></span>|
|<span data-ttu-id="c626e-323">泛型 <xref:System.Collections.Generic.ICollection%601></span><span class="sxs-lookup"><span data-stu-id="c626e-323">Generic <xref:System.Collections.Generic.ICollection%601></span></span>|<span data-ttu-id="c626e-324">列舉值</span><span class="sxs-lookup"><span data-stu-id="c626e-324">Enumerator</span></span>|<span data-ttu-id="c626e-325">泛型 Add</span><span class="sxs-lookup"><span data-stu-id="c626e-325">Generic Add</span></span>|
|<xref:System.Collections.IList>|<span data-ttu-id="c626e-326"><xref:System.Collections.IList> 索引子</span><span class="sxs-lookup"><span data-stu-id="c626e-326"><xref:System.Collections.IList> Indexer</span></span>|`Add`|
|<span data-ttu-id="c626e-327">泛型 <xref:System.Collections.Generic.IEnumerable%601></span><span class="sxs-lookup"><span data-stu-id="c626e-327">Generic <xref:System.Collections.Generic.IEnumerable%601></span></span>|`GetEnumerator`|<span data-ttu-id="c626e-328">稱為 `Add` 的非靜態方法，其會接受一個適當型別 (泛型參數型別或是它的一個基底型別) 的參數。</span><span class="sxs-lookup"><span data-stu-id="c626e-328">A non-static method called `Add` that takes one parameter of the appropriate type (the type of the generic parameter or one of its base types).</span></span> <span data-ttu-id="c626e-329">序列化程式必須配合這種方法，才能在進行序列化與還原序列化時將集合型別視為集合來處理。</span><span class="sxs-lookup"><span data-stu-id="c626e-329">Such a method must exist for the serializer to treat a collection type as a collection during both serialization and deserialization.</span></span>|
|<span data-ttu-id="c626e-330"><xref:System.Collections.IEnumerable> (以及衍生自該項的 <xref:System.Collections.ICollection>)</span><span class="sxs-lookup"><span data-stu-id="c626e-330"><xref:System.Collections.IEnumerable> (and thus <xref:System.Collections.ICollection>, which derives from it)</span></span>|`GetEnumerator`|<span data-ttu-id="c626e-331">稱為 `Add` 的非靜態方法，其會接受一個型別為 `Object`的參數。</span><span class="sxs-lookup"><span data-stu-id="c626e-331">A non-static method called `Add` that takes one parameter of type `Object`.</span></span> <span data-ttu-id="c626e-332">序列化程式必須配合這種方法，才能在進行序列化與還原序列化時將集合型別視為集合來處理。</span><span class="sxs-lookup"><span data-stu-id="c626e-332">Such a method must exist for the serializer to treat a collection type as a collection during both serialization and deserialization.</span></span>|

<span data-ttu-id="c626e-333">上面表格是依遞減的優先順序來列出集合介面。</span><span class="sxs-lookup"><span data-stu-id="c626e-333">The preceding table lists collection interfaces in descending order of precedence.</span></span> <span data-ttu-id="c626e-334">這表示，如果型別同時實作 <xref:System.Collections.IList> 與泛型 <xref:System.Collections.Generic.IEnumerable%601>，該集合便會根據 <xref:System.Collections.IList> 規則完成序列化與還原序列化：</span><span class="sxs-lookup"><span data-stu-id="c626e-334">This means, for example, that if a type implements both <xref:System.Collections.IList> and Generic <xref:System.Collections.Generic.IEnumerable%601>, the collection is serialized and deserialized according to the <xref:System.Collections.IList> rules:</span></span>

- <span data-ttu-id="c626e-335">在還原序列化時，會先藉由呼叫無參數的函式來建立類型的實例，藉以還原序列化所有的集合，而該函式必須存在，序列化程式才會將集合類型視為集合，同時進行序列化和還原序列化。</span><span class="sxs-lookup"><span data-stu-id="c626e-335">At deserialization, all collections are deserialized by first creating an instance of the type by calling the parameterless constructor, which must be present for the serializer to treat a collection type as a collection during both serialization and deserialization.</span></span>

- <span data-ttu-id="c626e-336">如果超過一次地實作相同的泛型集合介面 (例如，如果型別同時實作 <xref:System.Collections.Generic.ICollection%601> 的泛型 `Integer` 與 <xref:System.Collections.Generic.ICollection%601> 的泛型 <xref:System.String>)，而且找不到較高優先順序的介面，這時集合就無法被視為有效的集合。</span><span class="sxs-lookup"><span data-stu-id="c626e-336">If the same generic collection interface is implemented more than once (for example, if a type implements both Generic <xref:System.Collections.Generic.ICollection%601> of `Integer` and Generic <xref:System.Collections.Generic.ICollection%601> of <xref:System.String>) and no higher-precedence interface is found, the collection is not treated as a valid collection.</span></span>

- <span data-ttu-id="c626e-337">這些集合型別都可以將 <xref:System.SerializableAttribute> 屬性套用到本身，而且可以實作 <xref:System.Runtime.Serialization.ISerializable> 介面。</span><span class="sxs-lookup"><span data-stu-id="c626e-337">Collection types can have the <xref:System.SerializableAttribute> attribute applied to them and can implement the <xref:System.Runtime.Serialization.ISerializable> interface.</span></span> <span data-ttu-id="c626e-338">這兩者都會遭到忽略。</span><span class="sxs-lookup"><span data-stu-id="c626e-338">Both of these are ignored.</span></span> <span data-ttu-id="c626e-339">不過，如果型別沒有完全符合集合型別需求 (例如，遺失了 `Add` 方法)，該型別就不會被視為集合型別，而且這樣一來， <xref:System.SerializableAttribute> 屬性與 <xref:System.Runtime.Serialization.ISerializable> 介面就會用來判斷型別是否可序列化。</span><span class="sxs-lookup"><span data-stu-id="c626e-339">However, if the type does not fully meet collection type requirements (for example, the `Add` method is missing), the type is not considered a collection type, and thus the <xref:System.SerializableAttribute> attribute and the <xref:System.Runtime.Serialization.ISerializable> interface are used to determine whether the type can be serialized.</span></span>

- <span data-ttu-id="c626e-340">將 <xref:System.Runtime.Serialization.CollectionDataContractAttribute> 屬性套用至集合以自訂集合時，會移除上述的 <xref:System.SerializableAttribute> 後援機制。</span><span class="sxs-lookup"><span data-stu-id="c626e-340">Applying the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute to a collection to customize it removes the <xref:System.SerializableAttribute> preceding fallback mechanism.</span></span> <span data-ttu-id="c626e-341">相反地，如果自訂的集合未能符合集合型別需求，便會擲回 <xref:System.Runtime.Serialization.InvalidDataContractException> 例外狀況 (Exception)。</span><span class="sxs-lookup"><span data-stu-id="c626e-341">Instead, if a customized collection does not meet collection type requirements, an <xref:System.Runtime.Serialization.InvalidDataContractException> exception is thrown.</span></span> <span data-ttu-id="c626e-342">例外狀況字串通常會包含資訊，說明為什麼指定類型未被視為有效的集合（沒有 `Add` 方法、無參數的函式等等），因此套用 <xref:System.Runtime.Serialization.CollectionDataContractAttribute> 屬性以進行調試通常會很有用。</span><span class="sxs-lookup"><span data-stu-id="c626e-342">The exception string often contains information that explains why a given type is not considered a valid collection (no `Add` method, no parameterless constructor, and so on), so it is often useful to apply the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute for debugging purposes.</span></span>

### <a name="collection-naming"></a><span data-ttu-id="c626e-343">集合命名</span><span class="sxs-lookup"><span data-stu-id="c626e-343">Collection Naming</span></span>

<span data-ttu-id="c626e-344">下面是集合命名規則的清單：</span><span class="sxs-lookup"><span data-stu-id="c626e-344">The following is a list of collection naming rules:</span></span>

- <span data-ttu-id="c626e-345">除非使用命名空間覆寫，否則所有字典集合資料合約的預設命名空間，以及包含基本類型的清單集合資料合約，都是 `http://schemas.microsoft.com/2003/10/Serialization/Arrays` 。</span><span class="sxs-lookup"><span data-stu-id="c626e-345">The default namespace for all dictionary collection data contracts, as well as for list collection data contracts that contain primitive types, is `http://schemas.microsoft.com/2003/10/Serialization/Arrays` unless overridden using Namespace.</span></span> <span data-ttu-id="c626e-346">對應至內建 XSD 型別，以及 `char`、 `Timespan`與 `Guid` 型別的型別，都會因此目的而被視為基本型別。</span><span class="sxs-lookup"><span data-stu-id="c626e-346">Types that map to built-in XSD types, as well as `char`, `Timespan`, and `Guid` types, are considered primitives for this purpose.</span></span>

- <span data-ttu-id="c626e-347">除非已使用 Namespace 覆寫，否則包含非基本型別之集合型別的預設命名空間，就是集合中所包含之型別的資料合約命名空間。</span><span class="sxs-lookup"><span data-stu-id="c626e-347">The default namespace for collection types that contain non-primitive types, unless it is overridden using Namespace, is the same as the data contract namespace of the type contained in the collection.</span></span>

- <span data-ttu-id="c626e-348">除非已使用 Name 覆寫，否則清單集合資料合約的預設名稱，就會是 "ArrayOf" 字串與集合中所包含型別之資料合約名稱的組合。</span><span class="sxs-lookup"><span data-stu-id="c626e-348">The default name for list collection data contracts, unless overridden using Name, is the string "ArrayOf" combined with the data contract name of the type contained in the collection.</span></span> <span data-ttu-id="c626e-349">例如，整數泛型清單的資料合約名稱是 "ArrayOfint"。</span><span class="sxs-lookup"><span data-stu-id="c626e-349">For example, the data contract name for a Generic List of Integers is "ArrayOfint".</span></span> <span data-ttu-id="c626e-350">請記住， `Object` 的資料合約名稱是 "anyType"，因此非泛型清單 (例如， <xref:System.Collections.ArrayList> ) 的資料合約名稱會是 "ArrayOfanyType"。</span><span class="sxs-lookup"><span data-stu-id="c626e-350">Keep in mind that the data contract name of `Object` is "anyType", so the data contract name of non-generic lists like <xref:System.Collections.ArrayList> is "ArrayOfanyType".</span></span>

<span data-ttu-id="c626e-351">除非已使用 `Name`覆寫，否則字典集合資料合約的預設名稱，就會是 "ArrayOfKeyValueOf" 字串與索引鍵型別之資料合約名稱加上值型別之資料合約名稱的組合。</span><span class="sxs-lookup"><span data-stu-id="c626e-351">The default name for dictionary collection data contracts, unless overridden using `Name`, is the string "ArrayOfKeyValueOf" combined with the data contract name of the key type followed by the data contract name of the value type.</span></span> <span data-ttu-id="c626e-352">例如，字串與整數之泛型字典的資料合約名稱為 "ArrayOfKeyValueOfstringint"。</span><span class="sxs-lookup"><span data-stu-id="c626e-352">For example, the data contract name for a Generic Dictionary of String and Integer is "ArrayOfKeyValueOfstringint".</span></span> <span data-ttu-id="c626e-353">此外，如果索引鍵或值型別其中一個不是基本型別，便會在名稱後附加索引鍵與值型別之資料合約命名空間的命名空間雜湊。</span><span class="sxs-lookup"><span data-stu-id="c626e-353">Additionally, if either the key or the value types are not primitive types, a namespace hash of the data contract namespaces of the key and value types is appended to the name.</span></span> <span data-ttu-id="c626e-354">如需命名空間雜湊的詳細資訊，請參閱[資料合約名稱](data-contract-names.md)。</span><span class="sxs-lookup"><span data-stu-id="c626e-354">For more information about namespace hashes, see [Data Contract Names](data-contract-names.md).</span></span>

<span data-ttu-id="c626e-355">每個字典集合資料合約都具有表示字典中一個項目的附屬資料合約。</span><span class="sxs-lookup"><span data-stu-id="c626e-355">Each dictionary collection data contract has a companion data contract that represents one entry in the dictionary.</span></span> <span data-ttu-id="c626e-356">除了 "ArrayOf" 的前置詞以外，該合約的名稱與字典資料合約的名稱相同，而且其命名空間也與字典資料合約相同。</span><span class="sxs-lookup"><span data-stu-id="c626e-356">Its name is the same as for the dictionary data contract, except for the "ArrayOf" prefix, and its namespace is the same as for the dictionary data contract.</span></span> <span data-ttu-id="c626e-357">例如，對於 "ArrayOfKeyValueOfstringint" 字典資料合約，"KeyValueofstringint" 資料合約表示字典中的一個項目。</span><span class="sxs-lookup"><span data-stu-id="c626e-357">For example, for the "ArrayOfKeyValueOfstringint" dictionary data contract, the "KeyValueofstringint" data contract represents one entry in the dictionary.</span></span> <span data-ttu-id="c626e-358">您可以使用 `ItemName` 屬性來自訂這個資料合約的名稱，如下節所示。</span><span class="sxs-lookup"><span data-stu-id="c626e-358">You can customize the name of this data contract by using the `ItemName` property, as described in the next section.</span></span>

<span data-ttu-id="c626e-359">如 [Data Contract Names](data-contract-names.md)中所述，泛型型別命名規則會完全套用到集合型別，也就是說，您可以在名稱內使用大括號來表示泛型型別參數。</span><span class="sxs-lookup"><span data-stu-id="c626e-359">Generic type naming rules, as described in [Data Contract Names](data-contract-names.md), fully apply to collection types; that is, you can use curly braces within Name to indicate generic type parameters.</span></span> <span data-ttu-id="c626e-360">不過，在大括號內的數字是指泛型參數數目，而非集合內所包含型別的數目。</span><span class="sxs-lookup"><span data-stu-id="c626e-360">However, numbers within the braces refer to generic parameters and not types contained within the collection.</span></span>

## <a name="collection-customization"></a><span data-ttu-id="c626e-361">集合自訂化</span><span class="sxs-lookup"><span data-stu-id="c626e-361">Collection Customization</span></span>

<span data-ttu-id="c626e-362">禁止以下列方式使用 <xref:System.Runtime.Serialization.CollectionDataContractAttribute> 屬性，否則會造成 <xref:System.Runtime.Serialization.InvalidDataContractException> 例外狀況：</span><span class="sxs-lookup"><span data-stu-id="c626e-362">The following uses of the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute are forbidden and result in an <xref:System.Runtime.Serialization.InvalidDataContractException> exception:</span></span>

- <span data-ttu-id="c626e-363">將 <xref:System.Runtime.Serialization.DataContractAttribute> 屬性套用至已套用 <xref:System.Runtime.Serialization.CollectionDataContractAttribute> 屬性的型別，或是套用至它的一個衍生型別。</span><span class="sxs-lookup"><span data-stu-id="c626e-363">Applying the <xref:System.Runtime.Serialization.DataContractAttribute> attribute to a type to which the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute has been applied, or to one of its derived types.</span></span>

- <span data-ttu-id="c626e-364">將 <xref:System.Runtime.Serialization.CollectionDataContractAttribute> 屬性套用至實作 <xref:System.Xml.Serialization.IXmlSerializable> 介面的型別。</span><span class="sxs-lookup"><span data-stu-id="c626e-364">Applying the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute to a type that implements the <xref:System.Xml.Serialization.IXmlSerializable> interface.</span></span>

- <span data-ttu-id="c626e-365">將 <xref:System.Runtime.Serialization.CollectionDataContractAttribute> 屬性套用至非集合型別。</span><span class="sxs-lookup"><span data-stu-id="c626e-365">Applying the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute to a non-collection type.</span></span>

- <span data-ttu-id="c626e-366">嘗試在已套用至非字典型別的 <xref:System.Runtime.Serialization.CollectionDataContractAttribute.KeyName%2A> 屬性上設定 <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ValueName%2A> 或 <xref:System.Runtime.Serialization.CollectionDataContractAttribute> 。</span><span class="sxs-lookup"><span data-stu-id="c626e-366">Attempting to set <xref:System.Runtime.Serialization.CollectionDataContractAttribute.KeyName%2A> or <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ValueName%2A> on a <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute applied to a non-dictionary type.</span></span>

### <a name="polymorphism-rules"></a><span data-ttu-id="c626e-367">多型規則</span><span class="sxs-lookup"><span data-stu-id="c626e-367">Polymorphism Rules</span></span>

<span data-ttu-id="c626e-368">正如先前所述，使用 <xref:System.Runtime.Serialization.CollectionDataContractAttribute> 屬性來自訂集合可能會干擾集合的可互換性。</span><span class="sxs-lookup"><span data-stu-id="c626e-368">As previously mentioned, customizing collections by using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute may interfere with collection interchangeability.</span></span> <span data-ttu-id="c626e-369">唯有兩個自訂集合型別的名稱、命名空間、項目名稱，以及索引鍵與值名稱 (如果是字典集合) 彼此相符時，這兩個集合型别才能被視為相等。</span><span class="sxs-lookup"><span data-stu-id="c626e-369">Two customized collection types can only be considered equivalent if their name, namespace, item name, as well as key and value names (if these are dictionary collections) match.</span></span>

<span data-ttu-id="c626e-370">由於自訂化的關係，有可能會發生應該使用某個集合資料合約，但卻不慎使用另一個集合資料合約的情形。</span><span class="sxs-lookup"><span data-stu-id="c626e-370">Due to customizations, it is possible to inadvertently use one collection data contract where another is expected.</span></span> <span data-ttu-id="c626e-371">對此應該要設法避免。</span><span class="sxs-lookup"><span data-stu-id="c626e-371">This should be avoided.</span></span> <span data-ttu-id="c626e-372">請參閱下列型別。</span><span class="sxs-lookup"><span data-stu-id="c626e-372">See the following types.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#11](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#11)]
[!code-vb[c_collection_types_in_data_contracts#11](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#11)]

<span data-ttu-id="c626e-373">在此範例中， `Marks1` 的執行個體可以指派到 `testMarks`。</span><span class="sxs-lookup"><span data-stu-id="c626e-373">In this case, an instance of `Marks1` can be assigned to `testMarks`.</span></span> <span data-ttu-id="c626e-374">但是，不應使用 `Marks2` ，因為其資料合約不被視為相等於 `IList<int>` 資料合約。</span><span class="sxs-lookup"><span data-stu-id="c626e-374">However, `Marks2` should not be used because its data contract is not considered equivalent to the `IList<int>` data contract.</span></span> <span data-ttu-id="c626e-375">資料合約名稱是 "Marks2" 而非 "ArrayOfint"，而重複專案名稱是 ""，而 \<mark> 不是 " \<int> "。</span><span class="sxs-lookup"><span data-stu-id="c626e-375">The data contract name is "Marks2" and not "ArrayOfint", and the repeating element name is "\<mark>" and not "\<int>".</span></span>

<span data-ttu-id="c626e-376">下表中的規則適用於集合的多型指派。</span><span class="sxs-lookup"><span data-stu-id="c626e-376">The rules in the following table apply to polymorphic assignment of collections.</span></span>

|<span data-ttu-id="c626e-377">宣告的型別</span><span class="sxs-lookup"><span data-stu-id="c626e-377">Declared type</span></span>|<span data-ttu-id="c626e-378">指派非自訂的集合</span><span class="sxs-lookup"><span data-stu-id="c626e-378">Assigning a non-customized collection</span></span>|<span data-ttu-id="c626e-379">指派自訂的集合</span><span class="sxs-lookup"><span data-stu-id="c626e-379">Assigning a customized collection</span></span>|
|-------------------|--------------------------------------------|---------------------------------------|
|<span data-ttu-id="c626e-380">Object</span><span class="sxs-lookup"><span data-stu-id="c626e-380">Object</span></span>|<span data-ttu-id="c626e-381">合約名稱已經序列化。</span><span class="sxs-lookup"><span data-stu-id="c626e-381">Contract name is serialized.</span></span>|<span data-ttu-id="c626e-382">合約名稱已經序列化。</span><span class="sxs-lookup"><span data-stu-id="c626e-382">Contract name is serialized.</span></span><br /><br /> <span data-ttu-id="c626e-383">已使用自訂。</span><span class="sxs-lookup"><span data-stu-id="c626e-383">Customization is used.</span></span>|
|<span data-ttu-id="c626e-384">集合介面</span><span class="sxs-lookup"><span data-stu-id="c626e-384">Collection interface</span></span>|<span data-ttu-id="c626e-385">合約名稱未序列化。</span><span class="sxs-lookup"><span data-stu-id="c626e-385">Contract name is not serialized.</span></span>|<span data-ttu-id="c626e-386">合約名稱未序列化。</span><span class="sxs-lookup"><span data-stu-id="c626e-386">Contract name is not serialized.</span></span><br /><br /> <span data-ttu-id="c626e-387">不使用自訂。\*</span><span class="sxs-lookup"><span data-stu-id="c626e-387">Customization is not used.\*</span></span>|
|<span data-ttu-id="c626e-388">非自訂的集合</span><span class="sxs-lookup"><span data-stu-id="c626e-388">Non-customized collection</span></span>|<span data-ttu-id="c626e-389">合約名稱未序列化。</span><span class="sxs-lookup"><span data-stu-id="c626e-389">Contract name is not serialized.</span></span>|<span data-ttu-id="c626e-390">合約名稱已經序列化。</span><span class="sxs-lookup"><span data-stu-id="c626e-390">Contract name is serialized.</span></span><br /><br /> <span data-ttu-id="c626e-391">已使用自訂。\*\*</span><span class="sxs-lookup"><span data-stu-id="c626e-391">Customization is used.\*\*</span></span>|
|<span data-ttu-id="c626e-392">自訂的集合</span><span class="sxs-lookup"><span data-stu-id="c626e-392">Customized collection</span></span>|<span data-ttu-id="c626e-393">合約名稱已經序列化。</span><span class="sxs-lookup"><span data-stu-id="c626e-393">Contract name is serialized.</span></span> <span data-ttu-id="c626e-394">不使用自訂。\*\*</span><span class="sxs-lookup"><span data-stu-id="c626e-394">Customization is not used.\*\*</span></span>|<span data-ttu-id="c626e-395">合約名稱已經序列化。</span><span class="sxs-lookup"><span data-stu-id="c626e-395">Contract name is serialized.</span></span><br /><br /> <span data-ttu-id="c626e-396">會使用已指派類型的自訂。\*\*</span><span class="sxs-lookup"><span data-stu-id="c626e-396">Customization of the assigned type is used.\*\*</span></span>|

<span data-ttu-id="c626e-397">\*使用 <xref:System.Runtime.Serialization.NetDataContractSerializer> 類別時，在此情況下會使用自訂。</span><span class="sxs-lookup"><span data-stu-id="c626e-397">\*With the <xref:System.Runtime.Serialization.NetDataContractSerializer> class, customization is used in this case.</span></span> <span data-ttu-id="c626e-398">在此情況下， <xref:System.Runtime.Serialization.NetDataContractSerializer> 類別也會序列化實際的型別名稱，以便讓還原序列化如預期地運作。</span><span class="sxs-lookup"><span data-stu-id="c626e-398">The <xref:System.Runtime.Serialization.NetDataContractSerializer> class also serializes the actual type name in this case, so deserialization works as expected.</span></span>

<span data-ttu-id="c626e-399">\*\*這些情況會導致架構不正確實例，因此應該予以避免。</span><span class="sxs-lookup"><span data-stu-id="c626e-399">\*\*These cases result in schema-invalid instances and thus should be avoided.</span></span>

<span data-ttu-id="c626e-400">在合約名稱已經序列化的情況下，所指派的集合型別應該會在已知型別的清單中。</span><span class="sxs-lookup"><span data-stu-id="c626e-400">In the cases where the contract name is serialized, the assigned collection type should be in the known types list.</span></span> <span data-ttu-id="c626e-401">反之亦然：因為在名稱未經序列化的情況下，並不需要將型別加入至已知型別清單中。</span><span class="sxs-lookup"><span data-stu-id="c626e-401">The opposite is also true: in the cases where the name is not serialized, adding the type to the known types list is not required.</span></span>

<span data-ttu-id="c626e-402">衍生型別的陣列可以指派給基底型別的陣列。</span><span class="sxs-lookup"><span data-stu-id="c626e-402">An array of a derived type can be assigned to an array of a base type.</span></span> <span data-ttu-id="c626e-403">在此情況下，衍生型別的合約名稱會針對每個重複項目加以序列化。</span><span class="sxs-lookup"><span data-stu-id="c626e-403">In this case, the contract name for the derived type is serialized for each repeating element.</span></span> <span data-ttu-id="c626e-404">例如，如果型別 `Book` 是衍生自型別 `LibraryItem`，您就可以將 `Book` 的陣列指派到 `LibraryItem`的陣列。</span><span class="sxs-lookup"><span data-stu-id="c626e-404">For example, if a type `Book` derives from the type `LibraryItem`, you can assign an array of `Book` to an array of `LibraryItem`.</span></span> <span data-ttu-id="c626e-405">這點並不適用於其他集合型別。</span><span class="sxs-lookup"><span data-stu-id="c626e-405">This does not apply to other collection types.</span></span> <span data-ttu-id="c626e-406">例如，您無法將 `Generic List of Book` 指派到 `Generic List of LibraryItem`。</span><span class="sxs-lookup"><span data-stu-id="c626e-406">For example, you cannot assign a `Generic List of Book` to a `Generic List of LibraryItem`.</span></span> <span data-ttu-id="c626e-407">不過，您可以指派包含 `Generic List of LibraryItem` 執行個體的 `Book` 。</span><span class="sxs-lookup"><span data-stu-id="c626e-407">You can, however, assign a `Generic List of LibraryItem` that contains `Book` instances.</span></span> <span data-ttu-id="c626e-408">在陣列與非陣列的兩種情況下， `Book` 都應該會在已知型別清單中。</span><span class="sxs-lookup"><span data-stu-id="c626e-408">In both the array and the non-array case, `Book` should be in the known types list.</span></span>

## <a name="collections-and-object-reference-preservation"></a><span data-ttu-id="c626e-409">集合與物件參考保留</span><span class="sxs-lookup"><span data-stu-id="c626e-409">Collections and Object Reference Preservation</span></span>

<span data-ttu-id="c626e-410">當序列化程式在保留物件參考的模式下運作時，物件參考保留也會套用到集合。</span><span class="sxs-lookup"><span data-stu-id="c626e-410">When a serializer functions in a mode where it preserves object references, object reference preservation also applies to collections.</span></span> <span data-ttu-id="c626e-411">具體來說，就是整個集合與集合中所包含的個別項目都會保留其物件身分識別。</span><span class="sxs-lookup"><span data-stu-id="c626e-411">Specifically, object identity is preserved for both entire collections and individual items contained in collections.</span></span> <span data-ttu-id="c626e-412">若是字典，則會針對索引鍵/值組物件以及個別的索引鍵和值物件保留物件身分識別。</span><span class="sxs-lookup"><span data-stu-id="c626e-412">For dictionaries, object identity is preserved both for the key/value pair objects and the individual key and value objects.</span></span>

## <a name="see-also"></a><span data-ttu-id="c626e-413">另請參閱</span><span class="sxs-lookup"><span data-stu-id="c626e-413">See also</span></span>

- <xref:System.Runtime.Serialization.CollectionDataContractAttribute>
