---
title: 使用 XmlSerializer 類別
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- XmlSerializer [WCF], using
ms.assetid: c680602d-39d3-44f1-bf22-8e6654ad5069
ms.openlocfilehash: 2ef2d0eefb571f64040fabd16fd65fdfde7a626d
ms.sourcegitcommit: cdb295dd1db589ce5169ac9ff096f01fd0c2da9d
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 06/09/2020
ms.locfileid: "84600201"
---
# <a name="using-the-xmlserializer-class"></a><span data-ttu-id="1b238-102">使用 XmlSerializer 類別</span><span class="sxs-lookup"><span data-stu-id="1b238-102">Using the XmlSerializer Class</span></span>

<span data-ttu-id="1b238-103">Windows Communication Foundation （WCF）可以使用兩種不同的序列化技術，將您應用程式中的資料轉換成 XML，在用戶端與服務之間傳輸，這是一種稱為序列化的進程。</span><span class="sxs-lookup"><span data-stu-id="1b238-103">Windows Communication Foundation (WCF) can use two different serialization technologies to turn the data in your application into XML that is transmitted between clients and services, a process called serialization.</span></span>

## <a name="datacontractserializer-as-the-default"></a><span data-ttu-id="1b238-104">DataContractSerializer 為預設值</span><span class="sxs-lookup"><span data-stu-id="1b238-104">DataContractSerializer as the Default</span></span>

<span data-ttu-id="1b238-105">根據預設，WCF 會使用 <xref:System.Runtime.Serialization.DataContractSerializer> 類別來序列化資料類型。</span><span class="sxs-lookup"><span data-stu-id="1b238-105">By default WCF uses the <xref:System.Runtime.Serialization.DataContractSerializer> class to serialize data types.</span></span> <span data-ttu-id="1b238-106">這個序列化程式支援下列型別：</span><span class="sxs-lookup"><span data-stu-id="1b238-106">This serializer supports the following types:</span></span>

- <span data-ttu-id="1b238-107">基本型別 (例如，整數、字串和位元組陣列) 以及一些特殊型別，例如 <xref:System.Xml.XmlElement> 和 <xref:System.DateTime>，它們被視為基本型別。</span><span class="sxs-lookup"><span data-stu-id="1b238-107">Primitive types (for example, integers, strings, and byte arrays), as well as some special types, such as <xref:System.Xml.XmlElement> and <xref:System.DateTime>, which are treated as primitives.</span></span>

- <span data-ttu-id="1b238-108">資料合約類型 (以 <xref:System.Runtime.Serialization.DataContractAttribute> 屬性標示的類型)。</span><span class="sxs-lookup"><span data-stu-id="1b238-108">Data contract types (types marked with the <xref:System.Runtime.Serialization.DataContractAttribute> attribute).</span></span>

- <span data-ttu-id="1b238-109">以 <xref:System.SerializableAttribute> 屬性標示的型別，包括實作 <xref:System.Runtime.Serialization.ISerializable> 介面的型別。</span><span class="sxs-lookup"><span data-stu-id="1b238-109">Types marked with the <xref:System.SerializableAttribute> attribute, which include types that implement the <xref:System.Runtime.Serialization.ISerializable> interface.</span></span>

- <span data-ttu-id="1b238-110">實作 <xref:System.Xml.Serialization.IXmlSerializable> 介面的型別。</span><span class="sxs-lookup"><span data-stu-id="1b238-110">Types that implement the <xref:System.Xml.Serialization.IXmlSerializable> interface.</span></span>

- <span data-ttu-id="1b238-111">許多常用的集合型別，包括許多泛型集合型別。</span><span class="sxs-lookup"><span data-stu-id="1b238-111">Many common collection types, which include many generic collection types.</span></span>

<span data-ttu-id="1b238-112">許多 .NET Framework 類型都屬於後面兩個類別，因此可序列化。</span><span class="sxs-lookup"><span data-stu-id="1b238-112">Many .NET Framework types fall into the latter two categories and are thus serializable.</span></span> <span data-ttu-id="1b238-113">可序列化型別的陣列也是可序列化的。</span><span class="sxs-lookup"><span data-stu-id="1b238-113">Arrays of serializable types are also serializable.</span></span> <span data-ttu-id="1b238-114">如需完整清單，請參閱[指定服務合約中的資料傳輸](specifying-data-transfer-in-service-contracts.md)。</span><span class="sxs-lookup"><span data-stu-id="1b238-114">For a complete list, see [Specifying Data Transfer in Service Contracts](specifying-data-transfer-in-service-contracts.md).</span></span>

<span data-ttu-id="1b238-115"><xref:System.Runtime.Serialization.DataContractSerializer>與資料合約類型一起使用的，是撰寫新 WCF 服務的建議方式。</span><span class="sxs-lookup"><span data-stu-id="1b238-115">The <xref:System.Runtime.Serialization.DataContractSerializer>, used together with data contract types, is the recommended way to write new WCF services.</span></span> <span data-ttu-id="1b238-116">如需詳細資訊，請參閱[使用資料合約](using-data-contracts.md)。</span><span class="sxs-lookup"><span data-stu-id="1b238-116">For more information, see [Using Data Contracts](using-data-contracts.md).</span></span>

## <a name="when-to-use-the-xmlserializer-class"></a><span data-ttu-id="1b238-117">何時使用 XmlSerializer 類別</span><span class="sxs-lookup"><span data-stu-id="1b238-117">When to Use the XmlSerializer Class</span></span>

<span data-ttu-id="1b238-118">WCF 也支援 <xref:System.Xml.Serialization.XmlSerializer> 類別。</span><span class="sxs-lookup"><span data-stu-id="1b238-118">WCF also supports the <xref:System.Xml.Serialization.XmlSerializer> class.</span></span> <span data-ttu-id="1b238-119"><xref:System.Xml.Serialization.XmlSerializer>類別對 WCF 而言不是唯一的。</span><span class="sxs-lookup"><span data-stu-id="1b238-119">The <xref:System.Xml.Serialization.XmlSerializer> class is not unique to WCF.</span></span> <span data-ttu-id="1b238-120">這是 ASP.NET Web 服務所使用的相同序列化引擎。</span><span class="sxs-lookup"><span data-stu-id="1b238-120">It is the same serialization engine that ASP.NET Web services use.</span></span> <span data-ttu-id="1b238-121"><xref:System.Xml.Serialization.XmlSerializer> 類別支援的型別集範圍比 <xref:System.Runtime.Serialization.DataContractSerializer> 類別小多了，但允許對於結果 XML 有更多的控制權，並支援更多的 XML 結構描述定義語言 (XSD) 標準。</span><span class="sxs-lookup"><span data-stu-id="1b238-121">The <xref:System.Xml.Serialization.XmlSerializer> class supports a much narrower set of types than the <xref:System.Runtime.Serialization.DataContractSerializer> class, but allows much more control over the resulting XML and supports much more of the XML Schema definition language (XSD) standard.</span></span> <span data-ttu-id="1b238-122">它在可序列化型別上也不需要任何宣告式屬性。</span><span class="sxs-lookup"><span data-stu-id="1b238-122">It also does not require any declarative attributes on the serializable types.</span></span> <span data-ttu-id="1b238-123">如需詳細資訊，請參閱 .NET Framework 檔中的 XML 序列化主題。</span><span class="sxs-lookup"><span data-stu-id="1b238-123">For more information, see the XML Serialization topic in the .NET Framework documentation.</span></span> <span data-ttu-id="1b238-124"><xref:System.Xml.Serialization.XmlSerializer> 類別不支援資料合約類型。</span><span class="sxs-lookup"><span data-stu-id="1b238-124">The <xref:System.Xml.Serialization.XmlSerializer> class does not support data contract types.</span></span>

<span data-ttu-id="1b238-125">當使用 Svcutil 或 Visual Studio 中的**加入服務參考**功能來產生協力廠商服務的用戶端程式代碼，或存取協力廠商架構時，系統會自動為您選取適當的序列化程式。</span><span class="sxs-lookup"><span data-stu-id="1b238-125">When using Svcutil.exe or the **Add Service Reference** feature in Visual Studio to generate client code for a third-party service, or to access a third-party schema, an appropriate serializer is automatically selected for you.</span></span> <span data-ttu-id="1b238-126">如果結構描述與 <xref:System.Runtime.Serialization.DataContractSerializer> 不相容，便會選擇 <xref:System.Xml.Serialization.XmlSerializer>。</span><span class="sxs-lookup"><span data-stu-id="1b238-126">If the schema is not compatible with the <xref:System.Runtime.Serialization.DataContractSerializer>, the <xref:System.Xml.Serialization.XmlSerializer> is selected.</span></span>

## <a name="manually-switching-to-the-xmlserializer"></a><span data-ttu-id="1b238-127">手動切換至 XmlSerializer</span><span class="sxs-lookup"><span data-stu-id="1b238-127">Manually Switching to the XmlSerializer</span></span>

<span data-ttu-id="1b238-128">有時候，您可能必須手動切換至 <xref:System.Xml.Serialization.XmlSerializer>。</span><span class="sxs-lookup"><span data-stu-id="1b238-128">At times, you may have to manually switch to the <xref:System.Xml.Serialization.XmlSerializer>.</span></span> <span data-ttu-id="1b238-129">例如，這會發生在下列案例中：</span><span class="sxs-lookup"><span data-stu-id="1b238-129">This happens, for example, in the following cases:</span></span>

- <span data-ttu-id="1b238-130">將應用程式從 ASP.NET Web 服務遷移至 WCF 時，您可能會想要重複使用現有、 <xref:System.Xml.Serialization.XmlSerializer> 相容的類型，而不是建立新的資料合約類型。</span><span class="sxs-lookup"><span data-stu-id="1b238-130">When migrating an application from ASP.NET Web services to WCF, you may want to reuse existing, <xref:System.Xml.Serialization.XmlSerializer>-compatible types instead of creating new data contract types.</span></span>

- <span data-ttu-id="1b238-131">當出現在訊息中 XML 的精確控制權很重要，但 Web 服務描述語言 (WSDL) 文件無法使用時，例如，當使用必須符合與 DataContractSerializer 不相容的特定標準化、已發行的結構描述來建立服務時。</span><span class="sxs-lookup"><span data-stu-id="1b238-131">When precise control over the XML that appears in messages is important, but a Web Services Description Language (WSDL) document is not available, for example, when creating a service with types that have to comply to a certain standardized, published schema that is not compatible with the DataContractSerializer.</span></span>

- <span data-ttu-id="1b238-132">當建立遵循舊版 SOAP 編碼標準的服務時。</span><span class="sxs-lookup"><span data-stu-id="1b238-132">When creating services that follow the legacy SOAP Encoding standard.</span></span>

<span data-ttu-id="1b238-133">在這些案例和其他案例中，您可以將 <xref:System.Xml.Serialization.XmlSerializer> 屬性套用至您的服務，以手動切換至 `XmlSerializerFormatAttribute` 類別，如下列程式碼所示。</span><span class="sxs-lookup"><span data-stu-id="1b238-133">In these and other cases, you can manually switch to the <xref:System.Xml.Serialization.XmlSerializer> class by applying the `XmlSerializerFormatAttribute` attribute to your service, as shown in the following code.</span></span>

[!code-csharp[c_XmlSerializer#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_xmlserializer/cs/source.cs#1)]
[!code-vb[c_XmlSerializer#1](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_xmlserializer/vb/source.vb#1)]

## <a name="security-considerations"></a><span data-ttu-id="1b238-134">安全性考量</span><span class="sxs-lookup"><span data-stu-id="1b238-134">Security Considerations</span></span>

> [!NOTE]
> <span data-ttu-id="1b238-135">當切換序列化引擎時，小心是很重要的。</span><span class="sxs-lookup"><span data-stu-id="1b238-135">It is important to be careful when switching serialization engines.</span></span> <span data-ttu-id="1b238-136">根據所使用的序列化程式，相同的型別可以序列化為不同的 XML。</span><span class="sxs-lookup"><span data-stu-id="1b238-136">The same type can serialize to XML differently depending on the serializer being used.</span></span> <span data-ttu-id="1b238-137">如果您不小心使用到錯誤的序列化程式，您可能會將您不想洩露的型別資訊洩露出來。</span><span class="sxs-lookup"><span data-stu-id="1b238-137">If you accidentally use the wrong serializer, you might be disclosing information from the type that you did not intend to disclose.</span></span>

<span data-ttu-id="1b238-138">例如，當序列化資料合約類型時，<xref:System.Runtime.Serialization.DataContractSerializer> 類別只會序列化以 <xref:System.Runtime.Serialization.DataMemberAttribute> 屬性標示的成員。</span><span class="sxs-lookup"><span data-stu-id="1b238-138">For example, the <xref:System.Runtime.Serialization.DataContractSerializer> class only serializes members marked with the <xref:System.Runtime.Serialization.DataMemberAttribute> attribute when serializing data contract types.</span></span> <span data-ttu-id="1b238-139"><xref:System.Xml.Serialization.XmlSerializer> 類別會序列化 Public 成員。</span><span class="sxs-lookup"><span data-stu-id="1b238-139">The <xref:System.Xml.Serialization.XmlSerializer> class serializes any public member.</span></span> <span data-ttu-id="1b238-140">請參閱下列程式碼中的型別。</span><span class="sxs-lookup"><span data-stu-id="1b238-140">See the type in the following code.</span></span>

[!code-csharp[c_XmlSerializer#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_xmlserializer/cs/source.cs#2)]
[!code-vb[c_XmlSerializer#2](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_xmlserializer/vb/source.vb#2)]

<span data-ttu-id="1b238-141">如果型別不慎用於已選擇 <xref:System.Xml.Serialization.XmlSerializer> 類別的服務合約中，便會序列化原先可能不想處理的 `creditCardNumber` 成員。</span><span class="sxs-lookup"><span data-stu-id="1b238-141">If the type is inadvertently used in a service contract where the <xref:System.Xml.Serialization.XmlSerializer> class is selected, the `creditCardNumber` member is serialized, which is probably not intended.</span></span>

<span data-ttu-id="1b238-142">即使 <xref:System.Runtime.Serialization.DataContractSerializer> 類別是預設值，您仍然可以將 <xref:System.ServiceModel.DataContractFormatAttribute> 屬性套用至服務合約類型，明確地為服務選擇該類別 (雖然永遠不會有這個需要)。</span><span class="sxs-lookup"><span data-stu-id="1b238-142">Even though the <xref:System.Runtime.Serialization.DataContractSerializer> class is the default, you can explicitly select it for your service (although doing this should never be required) by applying the <xref:System.ServiceModel.DataContractFormatAttribute> attribute to the service contract type.</span></span>

<span data-ttu-id="1b238-143">用於此服務的序列化程式是合約的重要部分，且無法藉由選擇不同的繫結程序或變更其他組態設定來改變。</span><span class="sxs-lookup"><span data-stu-id="1b238-143">The serializer used for the service is an integral part of the contract and cannot be changed by selecting a different binding or by changing other configuration settings.</span></span>

<span data-ttu-id="1b238-144">其他重要的安全性考量適用於 <xref:System.Xml.Serialization.XmlSerializer> 類別。</span><span class="sxs-lookup"><span data-stu-id="1b238-144">Other important security considerations apply to the <xref:System.Xml.Serialization.XmlSerializer> class.</span></span> <span data-ttu-id="1b238-145">首先，強烈建議使用類別的任何 WCF 應用程式， <xref:System.Xml.Serialization.XmlSerializer> 都是使用受到保護而無法洩漏的金鑰來簽署。</span><span class="sxs-lookup"><span data-stu-id="1b238-145">First, it is strongly recommended that any WCF application that uses the <xref:System.Xml.Serialization.XmlSerializer> class is signed with a key that is safeguarded from disclosure.</span></span> <span data-ttu-id="1b238-146">這個建議適用於執行手動切換至 <xref:System.Xml.Serialization.XmlSerializer> 時，以及 (由 Svcutil.exe、「加入服務參考」或類似工具) 執行自動切換時。</span><span class="sxs-lookup"><span data-stu-id="1b238-146">This recommendation applies both when a manual switch to the <xref:System.Xml.Serialization.XmlSerializer> is performed and when an automatic switch is performed (by Svcutil.exe, Add Service Reference, or a similar tool).</span></span> <span data-ttu-id="1b238-147">這是因為 <xref:System.Xml.Serialization.XmlSerializer> 序列化引擎支援載入*預先產生的序列化元件*，只要它們是使用與應用程式相同的索引鍵來簽署。</span><span class="sxs-lookup"><span data-stu-id="1b238-147">This is because the <xref:System.Xml.Serialization.XmlSerializer> serialization engine supports the loading of *pre-generated serialization assemblies* as long as they are signed with the same key as the application.</span></span> <span data-ttu-id="1b238-148">未簽章的應用程式完全不受保護，如果惡意組件符合放在應用程式資料夾或全域組件快取中預先產生之序列化組件的預期名稱，便可能會受到攻擊。</span><span class="sxs-lookup"><span data-stu-id="1b238-148">An unsigned application is completely unprotected from the possibility of a malicious assembly matching the expected name of the pre-generated serialization assembly being placed in the application folder or the global assembly cache.</span></span> <span data-ttu-id="1b238-149">當然，攻擊者必須先取得這兩個位置其中之一的寫入存取權，才能嘗試這個動作。</span><span class="sxs-lookup"><span data-stu-id="1b238-149">Of course, an attacker must first gain write access to one of these two locations to attempt this action.</span></span>

<span data-ttu-id="1b238-150">另一個每當您使用 <xref:System.Xml.Serialization.XmlSerializer> 時都會存在的威脅，是與系統暫存資料夾有關的寫入存取權。</span><span class="sxs-lookup"><span data-stu-id="1b238-150">Another threat that exists whenever you use <xref:System.Xml.Serialization.XmlSerializer> is related to write access to the system temporary folder.</span></span> <span data-ttu-id="1b238-151"><xref:System.Xml.Serialization.XmlSerializer>序列化引擎會在此資料夾中建立並使用暫時的*序列化元件*。</span><span class="sxs-lookup"><span data-stu-id="1b238-151">The <xref:System.Xml.Serialization.XmlSerializer> serialization engine creates and uses temporary *serialization assemblies* in this folder.</span></span> <span data-ttu-id="1b238-152">您應該知道，暫存資料夾的任何寫入存取處理都可能會使用惡意程式碼來覆寫這些序列化組件。</span><span class="sxs-lookup"><span data-stu-id="1b238-152">You should be aware that any process with write access to the temporary folder may overwrite these serialization assemblies with malicious code.</span></span>

## <a name="rules-for-xmlserializer-support"></a><span data-ttu-id="1b238-153">XmlSerializer 支援的規則</span><span class="sxs-lookup"><span data-stu-id="1b238-153">Rules for XmlSerializer support</span></span>

<span data-ttu-id="1b238-154">您無法將與 <xref:System.Xml.Serialization.XmlSerializer> 相容的屬性直接套用至合約作業參數或傳回值。</span><span class="sxs-lookup"><span data-stu-id="1b238-154">You cannot directly apply <xref:System.Xml.Serialization.XmlSerializer>-compatible attributes to contract operation parameters or return values.</span></span> <span data-ttu-id="1b238-155">然而，可以將它們套用至具型別的訊息 (訊息合約本文部分)，如下列程式碼所示。</span><span class="sxs-lookup"><span data-stu-id="1b238-155">However, they can be applied to typed messages (message contract body parts), as shown in the following code.</span></span>

[!code-csharp[c_XmlSerializer#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_xmlserializer/cs/source.cs#3)]
[!code-vb[c_XmlSerializer#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_xmlserializer/vb/source.vb#3)]

<span data-ttu-id="1b238-156">當套用至具型別的訊息成員時，這些屬性會覆寫在具型別的訊息屬性上有衝突的屬性。</span><span class="sxs-lookup"><span data-stu-id="1b238-156">When applied to typed message members, these attributes override properties that conflict on the typed message attributes.</span></span> <span data-ttu-id="1b238-157">例如，在下列程式碼中，`ElementName` 會覆寫 `Name`。</span><span class="sxs-lookup"><span data-stu-id="1b238-157">For example, in the following code, `ElementName` overrides `Name`.</span></span>

[!code-csharp[c_XmlSerializer#4](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_xmlserializer/cs/source.cs#4)]
[!code-vb[c_XmlSerializer#4](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_xmlserializer/vb/source.vb#4)]

<span data-ttu-id="1b238-158">當使用 <xref:System.ServiceModel.MessageHeaderArrayAttribute> 時，不支援 <xref:System.Xml.Serialization.XmlSerializer> 屬性。</span><span class="sxs-lookup"><span data-stu-id="1b238-158">The <xref:System.ServiceModel.MessageHeaderArrayAttribute> attribute is not supported when using the <xref:System.Xml.Serialization.XmlSerializer>.</span></span>

> [!NOTE]
> <span data-ttu-id="1b238-159">在此情況下， <xref:System.Xml.Serialization.XmlSerializer> 會擲回下列例外狀況，這會在 WCF 之前釋放：「在架構最上層宣告的專案不能有 `maxOccurs` > 1。</span><span class="sxs-lookup"><span data-stu-id="1b238-159">In this case, the <xref:System.Xml.Serialization.XmlSerializer> throws the following exception, which is released prior to WCF: "An element declared at the top level of a schema cannot have `maxOccurs` > 1.</span></span> <span data-ttu-id="1b238-160">經由使用 `XmlArray` 或 `XmlArrayItem`，而不使用 `XmlElementAttribute`，或使用 Wrapped 參數樣式，來提供 "more" 的包裝函式項目」。</span><span class="sxs-lookup"><span data-stu-id="1b238-160">Provide a wrapper element for 'more' by using `XmlArray` or `XmlArrayItem` instead of `XmlElementAttribute`, or by using the Wrapped parameter style."</span></span>
>
> <span data-ttu-id="1b238-161">如果您收到此類例外狀況，請查看這種情況是否適用。</span><span class="sxs-lookup"><span data-stu-id="1b238-161">If you receive such an exception, investigate whether this situation applies.</span></span>

<span data-ttu-id="1b238-162">WCF 不支援 <xref:System.Xml.Serialization.SoapIncludeAttribute> <xref:System.Xml.Serialization.XmlIncludeAttribute> 訊息合約和作業合約中的和屬性; 請改用 <xref:System.Runtime.Serialization.KnownTypeAttribute> 屬性。</span><span class="sxs-lookup"><span data-stu-id="1b238-162">WCF does not support the <xref:System.Xml.Serialization.SoapIncludeAttribute> and <xref:System.Xml.Serialization.XmlIncludeAttribute> attributes in message contracts and operation contracts; use the <xref:System.Runtime.Serialization.KnownTypeAttribute> attribute instead.</span></span>

## <a name="types-that-implement-the-ixmlserializable-interface"></a><span data-ttu-id="1b238-163">實作 IXmlSerializable 介面的型別</span><span class="sxs-lookup"><span data-stu-id="1b238-163">Types that Implement the IXmlSerializable Interface</span></span>

<span data-ttu-id="1b238-164">實作 `IXmlSerializable` 介面的型別完全受到 `DataContractSerializer` 的支援。</span><span class="sxs-lookup"><span data-stu-id="1b238-164">Types that implement the `IXmlSerializable` interface are fully supported by the `DataContractSerializer`.</span></span> <span data-ttu-id="1b238-165"><xref:System.Xml.Serialization.XmlSchemaProviderAttribute> 屬性應永遠套用至這些型別，以控制其結構描述。</span><span class="sxs-lookup"><span data-stu-id="1b238-165">The <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> attribute should always be applied to these types to control their schema.</span></span>

> [!WARNING]
> <span data-ttu-id="1b238-166">如果您要序列化多型型別，必須將 <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> 套用至型別，以確保序列化正確型別。</span><span class="sxs-lookup"><span data-stu-id="1b238-166">If you are serializing polymorphic types you must apply the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> to the type to ensure the correct type is serialized.</span></span>

<span data-ttu-id="1b238-167">實作 `IXmlSerializable` 的型別有三種：代表任意內容的型別、代表單一項目的型別以及舊版 <xref:System.Data.DataSet> 型別。</span><span class="sxs-lookup"><span data-stu-id="1b238-167">There are three varieties of types that implement `IXmlSerializable`: types that represent arbitrary content, types that represent a single element, and legacy <xref:System.Data.DataSet> types.</span></span>

- <span data-ttu-id="1b238-168">內容型別是使用由 `XmlSchemaProviderAttribute` 屬性指定的結構描述提供者方法。</span><span class="sxs-lookup"><span data-stu-id="1b238-168">Content types use a schema provider method specified by the `XmlSchemaProviderAttribute` attribute.</span></span> <span data-ttu-id="1b238-169">此方法不會傳回 `null`，而屬性 (Attribute) 上的 <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> 屬性 (Property) 會保留為 `false` 的預設值。</span><span class="sxs-lookup"><span data-stu-id="1b238-169">The method does not return `null` and the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> property on the attribute is left at its default value of `false`.</span></span> <span data-ttu-id="1b238-170">這是 `IXmlSerializable` 型別最常見的使用。</span><span class="sxs-lookup"><span data-stu-id="1b238-170">This is the most common usage of `IXmlSerializable` types.</span></span>

- <span data-ttu-id="1b238-171">當 `IXmlSerializable` 型別必須控制自己的根項目名稱時，便會使用項目型別。</span><span class="sxs-lookup"><span data-stu-id="1b238-171">Element types are used when an `IXmlSerializable` type must control its own root element name.</span></span> <span data-ttu-id="1b238-172">如果要將型別標示為項目型別，請將 <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> 屬性 (Attribute) 上的 <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> 屬性 (Property) 設定為 `true`，或從結構描述提供者方法傳回 `null`。</span><span class="sxs-lookup"><span data-stu-id="1b238-172">To mark a type as an element type, either set the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> property on the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> attribute to `true` or return `null` from the schema provider method.</span></span> <span data-ttu-id="1b238-173">對於項目型別，是否具有結構描述提供者方法是選擇性的 – 您可以在 `null` 中指定 `XmlSchemaProviderAttribute` 來取代方法名稱。</span><span class="sxs-lookup"><span data-stu-id="1b238-173">Having a schema provider method is optional for element types – you may specify `null` instead of the method name in the `XmlSchemaProviderAttribute`.</span></span> <span data-ttu-id="1b238-174">然而，如果 `IsAny` 是 `true` 並已指定結構描述提供者方法，則此方法必須傳回 `null`。</span><span class="sxs-lookup"><span data-stu-id="1b238-174">However, if `IsAny` is `true` and a schema provider method is specified, the method must return `null`.</span></span>

- <span data-ttu-id="1b238-175">舊版 <xref:System.Data.DataSet> 型別是沒有以 `IXmlSerializable` 屬性標示的 `XmlSchemaProviderAttribute` 型別。</span><span class="sxs-lookup"><span data-stu-id="1b238-175">Legacy <xref:System.Data.DataSet> types are `IXmlSerializable` types that are not marked with the `XmlSchemaProviderAttribute` attribute.</span></span> <span data-ttu-id="1b238-176">相反地，它們是依賴 <xref:System.Xml.Serialization.IXmlSerializable.GetSchema%2A> 方法來產生結構描述。</span><span class="sxs-lookup"><span data-stu-id="1b238-176">Instead, they rely on the <xref:System.Xml.Serialization.IXmlSerializable.GetSchema%2A> method for schema generation.</span></span> <span data-ttu-id="1b238-177">在舊版 .NET Framework 中，這個模式是用於 `DataSet` 型別且其具型別的資料集會衍生類別，但這個模式現在已經過時且只為了舊版而支援。</span><span class="sxs-lookup"><span data-stu-id="1b238-177">This pattern is used for the `DataSet` type and its typed dataset derives a class in earlier versions of the .NET Framework, but is now obsolete and is supported only for legacy reasons.</span></span> <span data-ttu-id="1b238-178">請勿依賴這個模式，並永遠套用 `XmlSchemaProviderAttribute` 至您的 `IXmlSerializable` 型別。</span><span class="sxs-lookup"><span data-stu-id="1b238-178">Do not rely on this pattern and always apply the `XmlSchemaProviderAttribute` to your `IXmlSerializable` types.</span></span>

### <a name="ixmlserializable-content-types"></a><span data-ttu-id="1b238-179">IXmlSerializable 內容型別</span><span class="sxs-lookup"><span data-stu-id="1b238-179">IXmlSerializable Content Types</span></span>

<span data-ttu-id="1b238-180">當序列化實作 `IXmlSerializable` 且為上述定義的內容型別之型別的資料成員時，序列化程式會撰寫資料成員的包裝函式項目，並將控制權傳遞至 <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="1b238-180">When serializing a data member of a type that implements `IXmlSerializable` and is a content type as defined previously, the serializer writes the wrapper element for the data member and passes control to the <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> method.</span></span> <span data-ttu-id="1b238-181"><xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> 實作會撰寫任何 XML，包括將屬性加入至包裝函式項目。</span><span class="sxs-lookup"><span data-stu-id="1b238-181">The <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> implementation can write any XML, which includes adding attributes to the wrapper element.</span></span> <span data-ttu-id="1b238-182">在 `WriteXml` 完成之後，序列化程式會關閉項目。</span><span class="sxs-lookup"><span data-stu-id="1b238-182">After `WriteXml` is done, the serializer closes the element.</span></span>

<span data-ttu-id="1b238-183">當還原序列化實作 `IXmlSerializable` 且為上述定義的內容型別之型別的資料成員時，還原序列化程式會將 XML 讀取器放在資料成員的包裝函式項目上，並將控制權傳遞至 <xref:System.Xml.Serialization.IXmlSerializable.ReadXml%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="1b238-183">When deserializing a data member of a type that implements `IXmlSerializable` and is a content type as defined previously, the deserializer positions the XML reader on the wrapper element for the data member and passes control to the <xref:System.Xml.Serialization.IXmlSerializable.ReadXml%2A> method.</span></span> <span data-ttu-id="1b238-184">此方法必須讀取整個項目，包括開始和結束標記。</span><span class="sxs-lookup"><span data-stu-id="1b238-184">The method must read the entire element, including the start and end tags.</span></span> <span data-ttu-id="1b238-185">請確定您的 `ReadXml` 程式碼會處理項目是空白的案例。</span><span class="sxs-lookup"><span data-stu-id="1b238-185">Make sure your `ReadXml` code handles the case where the element is empty.</span></span> <span data-ttu-id="1b238-186">此外，您的 `ReadXml` 實作不應依賴以特定的方式為包裝函式項目命名。</span><span class="sxs-lookup"><span data-stu-id="1b238-186">Additionally, your `ReadXml` implementation should not rely on the wrapper element being named a particular way.</span></span> <span data-ttu-id="1b238-187">由序列化程式所選擇的名稱可能會有所不同。</span><span class="sxs-lookup"><span data-stu-id="1b238-187">The name is chosen by the serializer can vary.</span></span>

<span data-ttu-id="1b238-188">允許將 `IXmlSerializable` 內容型別多型指派為如型別 <xref:System.Object> 的資料成員。</span><span class="sxs-lookup"><span data-stu-id="1b238-188">It is permitted to assign `IXmlSerializable` content types polymorphically, for example, to data members of type <xref:System.Object>.</span></span> <span data-ttu-id="1b238-189">也允許型別執行個體為 null。</span><span class="sxs-lookup"><span data-stu-id="1b238-189">It is also permitted for the type instances to be null.</span></span> <span data-ttu-id="1b238-190">最後，可以使用 `IXmlSerializable` 型別並啟用物件圖形保留，以及搭配 <xref:System.Runtime.Serialization.NetDataContractSerializer>。</span><span class="sxs-lookup"><span data-stu-id="1b238-190">Finally, it is possible to use `IXmlSerializable` types with object graph preservation enabled and with the <xref:System.Runtime.Serialization.NetDataContractSerializer>.</span></span> <span data-ttu-id="1b238-191">所有這些功能都需要 WCF 序列化程式將特定屬性附加至包裝函式專案（XML 架構實例命名空間中的 "nil" 和 "type"，以及 WCF 特定命名空間中的 "Id"、"Ref"、"Type" 和 "Assembly"）。</span><span class="sxs-lookup"><span data-stu-id="1b238-191">All these features require the WCF serializer to attach certain attributes into the wrapper element ("nil" and "type" in the XML Schema Instance namespace and "Id", "Ref", "Type" and "Assembly" in a WCF-specific namespace).</span></span>

#### <a name="attributes-to-ignore-when-implementing-readxml"></a><span data-ttu-id="1b238-192">實作 ReadXml 時要忽略的屬性</span><span class="sxs-lookup"><span data-stu-id="1b238-192">Attributes to Ignore when Implementing ReadXml</span></span>

<span data-ttu-id="1b238-193">在將控制項傳遞至您的 `ReadXml` 程式碼之前，還原序列化程式會檢查 XML 項目、偵測這些特殊的 XML 屬性並進行動作。</span><span class="sxs-lookup"><span data-stu-id="1b238-193">Before passing control to your `ReadXml` code, the deserializer examines the XML element, detects these special XML attributes, and acts on them.</span></span> <span data-ttu-id="1b238-194">例如，如果 "nil" 為 `true`，便會還原序列化 null 值並且不會呼叫 `ReadXml`。</span><span class="sxs-lookup"><span data-stu-id="1b238-194">For example, if "nil" is `true`, a null value is deserialized and `ReadXml` is not called.</span></span> <span data-ttu-id="1b238-195">如果偵測到多型，則會還原序列化項目的內容，就如同它是不同的型別一樣。</span><span class="sxs-lookup"><span data-stu-id="1b238-195">If polymorphism is detected, the contents of the element are deserialized as if it was a different type.</span></span> <span data-ttu-id="1b238-196">會呼叫 `ReadXml` 的多型指派型別的實作。</span><span class="sxs-lookup"><span data-stu-id="1b238-196">The polymorphically-assigned type’s implementation of `ReadXml` is called.</span></span> <span data-ttu-id="1b238-197">在任何情況下，`ReadXml` 實作都應忽略這些特殊屬性，因為它們是由還原序列化程式所處理的。</span><span class="sxs-lookup"><span data-stu-id="1b238-197">In any case, a `ReadXml` implementation should ignore these special attributes because they are handled by the deserializer.</span></span>

### <a name="schema-considerations-for-ixmlserializable-content-types"></a><span data-ttu-id="1b238-198">IXmlSerializable 內容型別的結構描述考量</span><span class="sxs-lookup"><span data-stu-id="1b238-198">Schema Considerations for IXmlSerializable Content Types</span></span>

<span data-ttu-id="1b238-199">當匯出結構描述和 `IXmlSerializable` 內容型別時，會呼叫結構描述提供者方法。</span><span class="sxs-lookup"><span data-stu-id="1b238-199">When exporting schema and an `IXmlSerializable` content type, the schema provider method is called.</span></span> <span data-ttu-id="1b238-200"><xref:System.Xml.Schema.XmlSchemaSet> 會傳遞至結構描述提供者方法。</span><span class="sxs-lookup"><span data-stu-id="1b238-200">An <xref:System.Xml.Schema.XmlSchemaSet> is passed to the schema provider method.</span></span> <span data-ttu-id="1b238-201">此方法會將有效的結構描述新增至結構描述集。</span><span class="sxs-lookup"><span data-stu-id="1b238-201">The method can add any valid schema to the schema set.</span></span> <span data-ttu-id="1b238-202">結構描述集包含在發生結構描述匯出時已知的結構描述。</span><span class="sxs-lookup"><span data-stu-id="1b238-202">The schema set contains the schema that is already known at the time when schema export occurs.</span></span> <span data-ttu-id="1b238-203">當結構描述提供者方法必須將項目新增至結構描述集時，必須判斷有適當命名空間的 <xref:System.Xml.Schema.XmlSchema> 是否已經存在於此集合中。</span><span class="sxs-lookup"><span data-stu-id="1b238-203">When the schema provider method must add an item to the schema set, it must determine whether an <xref:System.Xml.Schema.XmlSchema> with the appropriate namespace already exists in the set.</span></span> <span data-ttu-id="1b238-204">如果是，結構描述提供者方法必須將新項目新增至現有的 `XmlSchema`。</span><span class="sxs-lookup"><span data-stu-id="1b238-204">If it does, the schema provider method must add the new item to the existing `XmlSchema`.</span></span> <span data-ttu-id="1b238-205">否則，就必須建立新的 `XmlSchema` 執行個體。</span><span class="sxs-lookup"><span data-stu-id="1b238-205">Otherwise, it must create a new `XmlSchema` instance.</span></span> <span data-ttu-id="1b238-206">如果是使用 `IXmlSerializable` 型別的陣列，這就很重要。</span><span class="sxs-lookup"><span data-stu-id="1b238-206">This is important if arrays of `IXmlSerializable` types are being used.</span></span> <span data-ttu-id="1b238-207">例如，如果您的 `IXmlSerializable` 型別在命名空間 "B" 中匯出為型別 "A"，就有可能在呼叫結構描述提供者方法時，結構描述集已經包含 "B" 的結構描述以保存 "ArrayOfA" 型別。</span><span class="sxs-lookup"><span data-stu-id="1b238-207">For example, if you have an `IXmlSerializable` type that gets exported as type "A" in namespace "B", it is possible that by the time the schema provider method is called the schema set already contains the schema for "B" to hold the "ArrayOfA" type.</span></span>

<span data-ttu-id="1b238-208">除了將型別新增至 <xref:System.Xml.Schema.XmlSchemaSet>，內容型別的結構描述提供者方法還必須傳回非 null 的值。</span><span class="sxs-lookup"><span data-stu-id="1b238-208">In addition to adding types to the <xref:System.Xml.Schema.XmlSchemaSet>, the schema provider method for content types must return a non-null value.</span></span> <span data-ttu-id="1b238-209">它會傳回 <xref:System.Xml.XmlQualifiedName>，指定用於指定的 `IXmlSerializable` 型別的結構描述型別的名稱。</span><span class="sxs-lookup"><span data-stu-id="1b238-209">It can return an <xref:System.Xml.XmlQualifiedName> that specifies the name of the schema type to use for the given `IXmlSerializable` type.</span></span> <span data-ttu-id="1b238-210">這個限定名稱也會做為型別的資料合約名稱和命名空間。</span><span class="sxs-lookup"><span data-stu-id="1b238-210">This qualified name also serves as the data contract name and namespace for the type.</span></span> <span data-ttu-id="1b238-211">當結構描述提供者方法傳回時，允許立即傳回不存在於結構描述集中的型別。</span><span class="sxs-lookup"><span data-stu-id="1b238-211">It is permitted to return a type that does not exist in the schema set immediately when the schema provider method returns.</span></span> <span data-ttu-id="1b238-212">然而，預期在匯出所有相關型別時 (在 <xref:System.Runtime.Serialization.XsdDataContractExporter.Export%2A> 上為所有相關型別呼叫 <xref:System.Runtime.Serialization.XsdDataContractExporter> 方法，並存取 <xref:System.Runtime.Serialization.XsdDataContractExporter.Schemas%2A> 屬性)，此型別會存在於結構描述集中。</span><span class="sxs-lookup"><span data-stu-id="1b238-212">However, it is expected that by the time all related types are exported (the <xref:System.Runtime.Serialization.XsdDataContractExporter.Export%2A> method is called for all relevant types on the <xref:System.Runtime.Serialization.XsdDataContractExporter> and the <xref:System.Runtime.Serialization.XsdDataContractExporter.Schemas%2A> property is accessed), the type exists in the schema set.</span></span> <span data-ttu-id="1b238-213">在完成所有相關 `Schemas` 呼叫之前存取 `Export` 屬性會造成 <xref:System.Xml.Schema.XmlSchemaException>。</span><span class="sxs-lookup"><span data-stu-id="1b238-213">Accessing the `Schemas` property before all relevant `Export` calls have been made can result in an <xref:System.Xml.Schema.XmlSchemaException>.</span></span> <span data-ttu-id="1b238-214">如需匯出程式的詳細資訊，請參閱[從類別匯出架構](exporting-schemas-from-classes.md)。</span><span class="sxs-lookup"><span data-stu-id="1b238-214">For more information about the export process, see [Exporting Schemas from Classes](exporting-schemas-from-classes.md).</span></span>

<span data-ttu-id="1b238-215">結構描述提供者方法也可能傳回 <xref:System.Xml.Schema.XmlSchemaType> 以使用。</span><span class="sxs-lookup"><span data-stu-id="1b238-215">The schema provider method can also return the <xref:System.Xml.Schema.XmlSchemaType> to use.</span></span> <span data-ttu-id="1b238-216">此型別可能是或不是匿名的。</span><span class="sxs-lookup"><span data-stu-id="1b238-216">The type may or may not be anonymous.</span></span> <span data-ttu-id="1b238-217">如果是匿名的，每當使用 `IXmlSerializable` 型別做為資料成員時，便會將 `IXmlSerializable` 型別的結構描述匯出為匿名型別。</span><span class="sxs-lookup"><span data-stu-id="1b238-217">If it is anonymous, the schema for the `IXmlSerializable` type is exported as an anonymous type every time the `IXmlSerializable` type is used as a data member.</span></span> <span data-ttu-id="1b238-218">`IXmlSerializable` 型別仍然會有資料合約名稱和命名空間。</span><span class="sxs-lookup"><span data-stu-id="1b238-218">The `IXmlSerializable` type still has a data contract name and namespace.</span></span> <span data-ttu-id="1b238-219">（這取決於[資料合約名稱](data-contract-names.md)中所述，不同之處在于 <xref:System.Runtime.Serialization.DataContractAttribute> 屬性不能用來自訂名稱）。如果不是匿名的，則必須是中的其中一個類型 `XmlSchemaSet` 。</span><span class="sxs-lookup"><span data-stu-id="1b238-219">(This is determined as described in [Data Contract Names](data-contract-names.md) except that the <xref:System.Runtime.Serialization.DataContractAttribute> attribute cannot be used to customize the name.) If it is not anonymous, it must be one of the types in the `XmlSchemaSet`.</span></span> <span data-ttu-id="1b238-220">這種情況等於傳回型別的 `XmlQualifiedName`。</span><span class="sxs-lookup"><span data-stu-id="1b238-220">This case is equivalent to returning the `XmlQualifiedName` of the type.</span></span>

<span data-ttu-id="1b238-221">此外，會匯出型別的全域項目宣告。</span><span class="sxs-lookup"><span data-stu-id="1b238-221">Additionally, a global element declaration is exported for the type.</span></span> <span data-ttu-id="1b238-222">如果型別沒有套用 <xref:System.Xml.Serialization.XmlRootAttribute> 屬性 (Attribute)，項目會有和資料合約相同的名稱及命名空間，且其 "nillable" 屬性 (Property) 也會為 `true`。</span><span class="sxs-lookup"><span data-stu-id="1b238-222">If the type does not have the <xref:System.Xml.Serialization.XmlRootAttribute> attribute applied to it, the element has the same name and namespace as the data contract, and its "nillable" property is `true`.</span></span> <span data-ttu-id="1b238-223">唯一的例外是架構命名空間（ `http://www.w3.org/2001/XMLSchema` ）–如果型別的資料合約是在這個命名空間中，則對應的全域專案會在空白命名空間中，因為禁止將新的專案加入架構命名空間中。</span><span class="sxs-lookup"><span data-stu-id="1b238-223">The only exception to this is the schema namespace (`http://www.w3.org/2001/XMLSchema`) – if the type’s data contract is in this namespace, the corresponding global element is in the blank namespace because it is forbidden to add new elements to the schema namespace.</span></span> <span data-ttu-id="1b238-224">如果型別已套用 `XmlRootAttribute` 屬性 (Attribute)，則會使用下列屬性 (Property) 匯出全域項目宣告：<xref:System.Xml.Serialization.XmlRootAttribute.ElementName%2A>、<xref:System.Xml.Serialization.XmlRootAttribute.Namespace%2A> 和 <xref:System.Xml.Serialization.XmlRootAttribute.IsNullable%2A> 屬性 (Property)。</span><span class="sxs-lookup"><span data-stu-id="1b238-224">If the type has the `XmlRootAttribute` attribute applied to it, the global element declaration is exported using the following: <xref:System.Xml.Serialization.XmlRootAttribute.ElementName%2A>, <xref:System.Xml.Serialization.XmlRootAttribute.Namespace%2A> and <xref:System.Xml.Serialization.XmlRootAttribute.IsNullable%2A> properties.</span></span> <span data-ttu-id="1b238-225">套用 `XmlRootAttribute` 的預設值是資料合約名稱、空白命名空間以及為 `true` 的 "nillable"。</span><span class="sxs-lookup"><span data-stu-id="1b238-225">The defaults with `XmlRootAttribute` applied are the data contract name, a blank namespace and "nillable" being `true`.</span></span>

<span data-ttu-id="1b238-226">相同的全域項目宣告規則亦適用於舊版資料集型別。</span><span class="sxs-lookup"><span data-stu-id="1b238-226">The same global element declaration rules apply to legacy dataset types.</span></span> <span data-ttu-id="1b238-227">請注意，`XmlRootAttribute` 無法覆寫透過自訂程式碼新增的全域項目宣告，不論是使用結構描述提供者方法新增至 `XmlSchemaSet` 或透過舊版資料集型別的 `GetSchema`。</span><span class="sxs-lookup"><span data-stu-id="1b238-227">Note that the `XmlRootAttribute` cannot override global element declarations added through custom code, either added to the `XmlSchemaSet` using the schema provider method or through `GetSchema` for legacy dataset types.</span></span>

### <a name="ixmlserializable-element-types"></a><span data-ttu-id="1b238-228">IXmlSerializable 項目型別</span><span class="sxs-lookup"><span data-stu-id="1b238-228">IXmlSerializable Element Types</span></span>

<span data-ttu-id="1b238-229">`IXmlSerializable` 項目型別會將 `IsAny` 屬性設定為 `true`，或讓其結構描述提供者方法傳回 `null`。</span><span class="sxs-lookup"><span data-stu-id="1b238-229">`IXmlSerializable` element types have either the `IsAny` property set to `true` or have their schema provider method return `null`.</span></span>

<span data-ttu-id="1b238-230">項目型別的序列化及還原序列化和內容型別的序列化及還原序列化十分類似。</span><span class="sxs-lookup"><span data-stu-id="1b238-230">Serializing and deserializing an element type is very similar to serializing and deserializing a content type.</span></span> <span data-ttu-id="1b238-231">然而，有一些重要的差異：</span><span class="sxs-lookup"><span data-stu-id="1b238-231">However, there are some important differences:</span></span>

- <span data-ttu-id="1b238-232">`WriteXml` 實作預期只撰寫一個項目 (其中當然可包含多個子項目)。</span><span class="sxs-lookup"><span data-stu-id="1b238-232">The `WriteXml` implementation is expected to write exactly one element (which could of course contain multiple child elements).</span></span> <span data-ttu-id="1b238-233">它不應在這個單一項目、多個同層項目或混合內容以外撰寫屬性。</span><span class="sxs-lookup"><span data-stu-id="1b238-233">It should not be writing attributes outside of this single element, multiple sibling elements or mixed content.</span></span> <span data-ttu-id="1b238-234">此項目可能是空白的。</span><span class="sxs-lookup"><span data-stu-id="1b238-234">The element may be empty.</span></span>

- <span data-ttu-id="1b238-235">`ReadXml` 實作不應讀取包裝函式項目。</span><span class="sxs-lookup"><span data-stu-id="1b238-235">The `ReadXml` implementation should not read the wrapper element.</span></span> <span data-ttu-id="1b238-236">它預期會讀取 `WriteXml` 所產生的一個項目。</span><span class="sxs-lookup"><span data-stu-id="1b238-236">It is expected to read the one element that `WriteXml` produces.</span></span>

- <span data-ttu-id="1b238-237">當定期序列化項目型別時 (例如，做為資料合約中的資料成員)，序列化程式會在呼叫 `WriteXml` 之前輸出包裝函式項目，就像使用內容型別一樣。</span><span class="sxs-lookup"><span data-stu-id="1b238-237">When serializing an element type regularly (for example, as a data member in a data contract), the serializer outputs a wrapper element before calling `WriteXml`, as with content types.</span></span> <span data-ttu-id="1b238-238">然而，當在最上層序列化項目型別時，序列化程式通常完全不會輸出包含 `WriteXml` 撰寫之項目的包裝函式項目，除非在 `DataContractSerializer` 或 `NetDataContractSerializer` 建構函式中建構序列化程式時已明確指定根名稱和命名空間。</span><span class="sxs-lookup"><span data-stu-id="1b238-238">However, when serializing an element type at the top level, the serializer does not normally output a wrapper element at all around the element that `WriteXml` writes, unless a root name and namespace are explicitly specified when constructing the serializer in the `DataContractSerializer` or `NetDataContractSerializer` constructors.</span></span> <span data-ttu-id="1b238-239">如需詳細資訊，請參閱[序列化和還原序列化](serialization-and-deserialization.md)。</span><span class="sxs-lookup"><span data-stu-id="1b238-239">For more information, see [Serialization and Deserialization](serialization-and-deserialization.md).</span></span>

- <span data-ttu-id="1b238-240">當在最上層序列化項目型別，但在建構期間沒有指定根名稱和命名空間時，<xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A> 和 <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> 基本上不會執行任何動作，而 <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObjectContent%2A> 會呼叫 `WriteXml`。</span><span class="sxs-lookup"><span data-stu-id="1b238-240">When serializing an element type at the top level without specifying the root name and namespace at construction time, <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A> and <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> essentially do nothing and <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObjectContent%2A> calls `WriteXml`.</span></span> <span data-ttu-id="1b238-241">在這個模式中，正在序列化的物件不得為 `null`，且無法多型指派。</span><span class="sxs-lookup"><span data-stu-id="1b238-241">In this mode, the object being serialized cannot be `null` and cannot be polymorphically assigned.</span></span> <span data-ttu-id="1b238-242">另外，物件圖形保留無法啟用，且 `NetDataContractSerializer` 無法使用。</span><span class="sxs-lookup"><span data-stu-id="1b238-242">Also, object graph preservation cannot enabled and the `NetDataContractSerializer` cannot be used.</span></span>

- <span data-ttu-id="1b238-243">當在最上層還原序列化元素型別，但在建構期間沒有指定根名稱和命名空間時，如果可以找到任何元素的起始，<xref:System.Runtime.Serialization.XmlObjectSerializer.IsStartObject%2A> 就會傳回 `true`。</span><span class="sxs-lookup"><span data-stu-id="1b238-243">When deserializing an element type at the top level without specifying the root name and namespace at construction time, <xref:System.Runtime.Serialization.XmlObjectSerializer.IsStartObject%2A> returns `true` if it can find the start of any element.</span></span> <span data-ttu-id="1b238-244"><xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> 參數設定為 `verifyObjectName` 的 `true` 在實際讀取物件之前，行為方式會和 `IsStartObject` 相同。</span><span class="sxs-lookup"><span data-stu-id="1b238-244"><xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> with the `verifyObjectName` parameter set to `true` behaves in the same way as `IsStartObject` before actually reading the object.</span></span> <span data-ttu-id="1b238-245">然後 `ReadObject` 就會將控制項傳遞給 `ReadXml` 方法。</span><span class="sxs-lookup"><span data-stu-id="1b238-245">`ReadObject` then passes control to `ReadXml` method.</span></span>

<span data-ttu-id="1b238-246">項目型別匯出的結構描述和前一節中所述的 `XmlElement` 型別相同，除了結構描述提供者方法可以將其他結構描述新增至 <xref:System.Xml.Schema.XmlSchemaSet>，就像內容型別一樣。</span><span class="sxs-lookup"><span data-stu-id="1b238-246">The schema exported for element types is the same as for the `XmlElement` type as described in an earlier section, except that the schema provider method can add any additional schema to the <xref:System.Xml.Schema.XmlSchemaSet> as with content types.</span></span> <span data-ttu-id="1b238-247">不允許使用 `XmlRootAttribute` 屬性搭配項目型別，也永遠不會為這些型別發出全域項目宣告。</span><span class="sxs-lookup"><span data-stu-id="1b238-247">Using the `XmlRootAttribute` attribute with element types is not allowed, and global element declarations are never emitted for these types.</span></span>

### <a name="differences-from-the-xmlserializer"></a><span data-ttu-id="1b238-248">與 XmlSerializer 的差異</span><span class="sxs-lookup"><span data-stu-id="1b238-248">Differences from the XmlSerializer</span></span>

<span data-ttu-id="1b238-249">`IXmlSerializable` 也會辨識 `XmlSchemaProviderAttribute` 介面和 `XmlRootAttribute` 和 <xref:System.Xml.Serialization.XmlSerializer> 屬性。</span><span class="sxs-lookup"><span data-stu-id="1b238-249">The `IXmlSerializable` interface and the `XmlSchemaProviderAttribute` and `XmlRootAttribute` attributes are also understood by the <xref:System.Xml.Serialization.XmlSerializer> .</span></span> <span data-ttu-id="1b238-250">然而，在資料合約模型中對於它們的處理方式有一些差異。</span><span class="sxs-lookup"><span data-stu-id="1b238-250">However, there are some differences in how these are treated in the data contract model.</span></span> <span data-ttu-id="1b238-251">下表顯示重要差異的摘要：</span><span class="sxs-lookup"><span data-stu-id="1b238-251">The important differences are summarized in the following list:</span></span>

- <span data-ttu-id="1b238-252">結構描述提供者方法必須可公開在 `XmlSerializer` 中使用，但不必公開在資料合約模型中使用。</span><span class="sxs-lookup"><span data-stu-id="1b238-252">The schema provider method must be public to be used in the `XmlSerializer`, but does not have to be public to be used in the data contract model.</span></span>

- <span data-ttu-id="1b238-253">當 `IsAny` 在資料合約模型中為 `true`，但未使用 `XmlSerializer` 時，便會呼叫結構描述提供者方法。</span><span class="sxs-lookup"><span data-stu-id="1b238-253">The schema provider method is called when `IsAny` is `true` in the data contract model but not with the `XmlSerializer`.</span></span>

- <span data-ttu-id="1b238-254">當沒有出現內容或舊版資料集型別的 `XmlRootAttribute` 屬性時，`XmlSerializer` 會在空白命名空間中匯出全域項目宣告。</span><span class="sxs-lookup"><span data-stu-id="1b238-254">When the `XmlRootAttribute` attribute is not present for content or legacy dataset types, the `XmlSerializer` exports a global element declaration in the blank namespace.</span></span> <span data-ttu-id="1b238-255">在資料合約模型中，所使用的命名空間通常是資料合約命名空間，如前所述。</span><span class="sxs-lookup"><span data-stu-id="1b238-255">In the data contract model, the namespace used is normally the data contract namespace as described earlier.</span></span>

<span data-ttu-id="1b238-256">在建立將搭配這兩種序列化技術使用的型別時，請注意這些差異。</span><span class="sxs-lookup"><span data-stu-id="1b238-256">Be aware of these differences when creating types that are used with both serialization technologies.</span></span>

### <a name="importing-ixmlserializable-schema"></a><span data-ttu-id="1b238-257">匯入 IXmlSerializable 結構描述</span><span class="sxs-lookup"><span data-stu-id="1b238-257">Importing IXmlSerializable Schema</span></span>

<span data-ttu-id="1b238-258">當匯入從 `IXmlSerializable` 型別產生的結構描述時，有一些可能性：</span><span class="sxs-lookup"><span data-stu-id="1b238-258">When importing a schema generated from `IXmlSerializable` types, there are a few possibilities:</span></span>

- <span data-ttu-id="1b238-259">產生的架構可能是有效的資料合約架構，如[資料合約架構參考](data-contract-schema-reference.md)中所述。</span><span class="sxs-lookup"><span data-stu-id="1b238-259">The generated schema may be a valid data contract schema as described in [Data Contract Schema Reference](data-contract-schema-reference.md).</span></span> <span data-ttu-id="1b238-260">在這種情況中，結構描述會如平常般匯入，並產生一般資料合約類型。</span><span class="sxs-lookup"><span data-stu-id="1b238-260">In this case, schema can be imported as usual and regular data contract types are generated.</span></span>

- <span data-ttu-id="1b238-261">所產生的結構描述可能不是有效的資料合約結構描述。</span><span class="sxs-lookup"><span data-stu-id="1b238-261">The generated schema may not be a valid data contract schema.</span></span> <span data-ttu-id="1b238-262">例如，您的結構描述提供者方法可能會產生結構描述，其中包含資料合約模型中不支援的 XML 屬性。</span><span class="sxs-lookup"><span data-stu-id="1b238-262">For example, your schema provider method may generate schema that involves XML attributes that are not supported in the data contract model.</span></span> <span data-ttu-id="1b238-263">在這種情況中，您可以將結構描述匯入為 `IXmlSerializable` 型別。</span><span class="sxs-lookup"><span data-stu-id="1b238-263">In this case, you can import the schema as `IXmlSerializable` types.</span></span> <span data-ttu-id="1b238-264">此匯入模式預設為不開啟，但可以很容易啟用–例如，使用 `/importXmlTypes` 命令列參數來切換至[System.servicemodel 中繼資料公用程式工具（Svcutil .exe）](../servicemodel-metadata-utility-tool-svcutil-exe.md)。</span><span class="sxs-lookup"><span data-stu-id="1b238-264">This import mode is not on by default but can easily be enabled – for example, with the `/importXmlTypes` command-line switch to the [ServiceModel Metadata Utility Tool (Svcutil.exe)](../servicemodel-metadata-utility-tool-svcutil-exe.md).</span></span> <span data-ttu-id="1b238-265">匯入架構中會詳細說明這種方式[來產生類別](importing-schema-to-generate-classes.md)。</span><span class="sxs-lookup"><span data-stu-id="1b238-265">This is described in detail in the [Importing Schema to Generate Classes](importing-schema-to-generate-classes.md).</span></span> <span data-ttu-id="1b238-266">請注意，您必須對您的型別執行個體直接使用 XML。</span><span class="sxs-lookup"><span data-stu-id="1b238-266">Note that you must work directly with the XML for your type instances.</span></span> <span data-ttu-id="1b238-267">您可能也會考慮使用不同的序列化技術，支援範圍更廣的結構描述 – 請參閱有關使用 `XmlSerializer` 的主題。</span><span class="sxs-lookup"><span data-stu-id="1b238-267">You may also consider using a different serialization technology that supports a wider range of schema – see the topic on using the `XmlSerializer`.</span></span>

- <span data-ttu-id="1b238-268">您可能會想要在 Proxy 中重複使用現有的 `IXmlSerializable` 型別，而非產生一個新的。</span><span class="sxs-lookup"><span data-stu-id="1b238-268">You may want to reuse your existing `IXmlSerializable` types in the proxy instead of generating new ones.</span></span> <span data-ttu-id="1b238-269">在這種情況中，「匯入結構描述以產生型別」主題中所說明的參照型別功能可用於指出要重複使用的型別。</span><span class="sxs-lookup"><span data-stu-id="1b238-269">In this case, the referenced types feature described in the Importing Schema to Generate Types topic can be used to indicate the type to reuse.</span></span> <span data-ttu-id="1b238-270">這會對應至在 svcutil.exe 上使用 `/reference` 參數，指定包含要重複使用之型別的組件。</span><span class="sxs-lookup"><span data-stu-id="1b238-270">This corresponds to using the `/reference` switch on svcutil.exe, which specifies the assembly that contains the types to reuse.</span></span>

### <a name="xmlserializer-legacy-behavior"></a><span data-ttu-id="1b238-271">XmlSerializer 舊版行為</span><span class="sxs-lookup"><span data-stu-id="1b238-271">XmlSerializer Legacy Behavior</span></span>

<span data-ttu-id="1b238-272">在 .NET Framework 4.0 及更早版本中，XmlSerializer 會將 C# 程式碼寫入檔案中，以產生暫時的序列化組件。</span><span class="sxs-lookup"><span data-stu-id="1b238-272">In the .NET Framework 4.0 and earlier, the XmlSerializer generated temporary serialization assemblies by writing C# code to a file.</span></span> <span data-ttu-id="1b238-273">接著將這個檔案編譯成組件。</span><span class="sxs-lookup"><span data-stu-id="1b238-273">The file was then compiled into an assembly.</span></span>  <span data-ttu-id="1b238-274">這種行為有一些不良的後果，例如減慢序列化程式的啟動時間。</span><span class="sxs-lookup"><span data-stu-id="1b238-274">This behavior had some undesirable consequences like slowing the startup time for the serializer.</span></span> <span data-ttu-id="1b238-275">在 .NET Framework 4.5 中，這種行為已變更，不需要使用編譯器就可以產生組件。</span><span class="sxs-lookup"><span data-stu-id="1b238-275">In .NET Framework 4.5, this behavior was changed to generate the assemblies without requiring use of the compiler.</span></span> <span data-ttu-id="1b238-276">某些開發人員可能會想要查看產生的 C# 程式碼。</span><span class="sxs-lookup"><span data-stu-id="1b238-276">Some developers may wish to see the generated C# code.</span></span> <span data-ttu-id="1b238-277">您可以藉由下列組態指定使用這個舊版行為：</span><span class="sxs-lookup"><span data-stu-id="1b238-277">You can specify to use this legacy behavior by the following configuration:</span></span>

```xml
<?xml version="1.0" encoding="utf-8" ?>
<configuration>
  <system.xml.serialization>
    <xmlSerializer tempFilesLocation='e:\temp\XmlSerializerBug' useLegacySerializerGeneration="true" />
  </system.xml.serialization>
  <system.diagnostics>
    <switches>
      <add name="XmlSerialization.Compilation" value="1" />
    </switches>
  </system.diagnostics>
</configuration>
```

<span data-ttu-id="1b238-278">如果您遇到相容性問題，例如無法使用 `XmlSerializer` 非公用的新覆寫來序列化衍生類別，您可以使用下列設定來切換回 `XMLSerializer` 舊版行為：</span><span class="sxs-lookup"><span data-stu-id="1b238-278">If you run into compatibility issues,  such as the `XmlSerializer` failing to serialize a derived class with a non-public new override, you can switch back to the  `XMLSerializer` legacy behavior by using the following configuration:</span></span>

```xml
<configuration>
  <appSettings>
    <add key="System:Xml:Serialization:UseLegacySerializerGeneration" value="true" />
  </appSettings>
</configuration>
```

<span data-ttu-id="1b238-279">除了上述設定之外，您還可以在執行 .NET Framework 4.5 或更新版本的電腦上使用下列設定：</span><span class="sxs-lookup"><span data-stu-id="1b238-279">As an alternative to the above configuration, you can use the following configuration on a machine running .NET Framework 4.5 or later version:</span></span>

```xml
<configuration>
  <system.xml.serialization>
    <xmlSerializer useLegacySerializerGeneration="true"/>
  </system.xml.serialization>
</configuration>
```

> [!NOTE]
> <span data-ttu-id="1b238-280">`<xmlSerializer useLegacySerializerGeneration="true"/>`參數僅適用于執行 .NET Framework 4.5 或更新版本的電腦。</span><span class="sxs-lookup"><span data-stu-id="1b238-280">The `<xmlSerializer useLegacySerializerGeneration="true"/>` switch only works on a machine running .NET Framework 4.5 or later version.</span></span> <span data-ttu-id="1b238-281">上述 `appSettings` 方法適用于所有 .NET Framework 版本。</span><span class="sxs-lookup"><span data-stu-id="1b238-281">The above `appSettings` approach works on all .NET Framework versions.</span></span>

## <a name="see-also"></a><span data-ttu-id="1b238-282">請參閱</span><span class="sxs-lookup"><span data-stu-id="1b238-282">See also</span></span>

- <xref:System.ServiceModel.DataContractFormatAttribute>
- <xref:System.Runtime.Serialization.DataContractSerializer>
- <xref:System.Xml.Serialization.XmlSerializer>
- <xref:System.ServiceModel.MessageHeaderArrayAttribute>
- [<span data-ttu-id="1b238-283">Specifying Data Transfer in Service Contracts</span><span class="sxs-lookup"><span data-stu-id="1b238-283">Specifying Data Transfer in Service Contracts</span></span>](specifying-data-transfer-in-service-contracts.md)
- [<span data-ttu-id="1b238-284">使用資料合約</span><span class="sxs-lookup"><span data-stu-id="1b238-284">Using Data Contracts</span></span>](using-data-contracts.md)
- [<span data-ttu-id="1b238-285">如何：使用 XmlSerializer 改善 WCF 用戶端應用程式的啟動時間</span><span class="sxs-lookup"><span data-stu-id="1b238-285">How to: Improve the Startup Time of WCF Client Applications using the XmlSerializer</span></span>](startup-time-of-wcf-client-applications-using-the-xmlserializer.md)
