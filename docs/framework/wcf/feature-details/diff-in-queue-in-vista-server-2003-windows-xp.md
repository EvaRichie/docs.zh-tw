---
title: Windows Vista、Windows Server 2003 和 Windows XP 之間的佇列功能差異
ms.date: 03/30/2017
helpviewer_keywords:
- queues [WCF], differences in operating systems
ms.assetid: aa809d93-d0a3-4ae6-a726-d015cca37c04
ms.openlocfilehash: abd81b5e7bf611fc6b4f446a82628b83130f2d54
ms.sourcegitcommit: cdb295dd1db589ce5169ac9ff096f01fd0c2da9d
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 06/09/2020
ms.locfileid: "84599200"
---
# <a name="differences-in-queuing-features-in-windows-vista-windows-server-2003-and-windows-xp"></a><span data-ttu-id="7611c-102">Windows Vista、Windows Server 2003 和 Windows XP 之間的佇列功能差異</span><span class="sxs-lookup"><span data-stu-id="7611c-102">Differences in Queuing Features in Windows Vista, Windows Server 2003, and Windows XP</span></span>
<span data-ttu-id="7611c-103">本主題摘要說明 Windows Vista、Windows Server 2003 和 Windows XP 之間的 Windows Communication Foundation （WCF）佇列功能差異。</span><span class="sxs-lookup"><span data-stu-id="7611c-103">This topic summarizes the differences in the Windows Communication Foundation (WCF) queues feature between Windows Vista, Windows Server 2003, and Windows XP.</span></span>  
  
## <a name="application-specific-dead-letter-queue"></a><span data-ttu-id="7611c-104">應用程式特定之寄不出的信件佇列</span><span class="sxs-lookup"><span data-stu-id="7611c-104">Application-Specific Dead-Letter Queue</span></span>  
 <span data-ttu-id="7611c-105">如果接收應用程式沒有及時讀取佇列訊息，則佇列訊息可以無限期保留在佇列中。</span><span class="sxs-lookup"><span data-stu-id="7611c-105">Queued messages can remain in the queue indefinitely if the receiving application does not read them in a timely fashion.</span></span> <span data-ttu-id="7611c-106">如果是時間緊急的訊息，這個行為並不合適。</span><span class="sxs-lookup"><span data-stu-id="7611c-106">This behavior is not advisable if the messages are time-sensitive.</span></span> <span data-ttu-id="7611c-107">時間緊急的訊息會在佇列繫結中設定 `TimeToLive` 屬性。</span><span class="sxs-lookup"><span data-stu-id="7611c-107">Time-sensitive messages have a `TimeToLive` property set in the queued binding.</span></span> <span data-ttu-id="7611c-108">這個屬性指出訊息在到期前可在佇列中停留的時間長度。</span><span class="sxs-lookup"><span data-stu-id="7611c-108">This property indicates how long the messages can be in the queue before they expire.</span></span> <span data-ttu-id="7611c-109">過期訊息會傳送至稱為「寄不出的信件佇列」的特殊佇列。</span><span class="sxs-lookup"><span data-stu-id="7611c-109">Expired messages are sent to a special queue called the dead-letter queue.</span></span> <span data-ttu-id="7611c-110">訊息最後也可以因為其他原因而放在寄不出的信件佇列中，例如超過佇列配額或經歷驗證失敗。</span><span class="sxs-lookup"><span data-stu-id="7611c-110">A message can also end up in a dead-letter queue for other reasons, such as exceeding a queue quota or experiencing an authentication failure.</span></span>  
  
 <span data-ttu-id="7611c-111">一般而言，所有共用佇列管理員的佇列應用程式都有單一整個系統之寄不出的信件佇列。</span><span class="sxs-lookup"><span data-stu-id="7611c-111">Typically, a single system-wide dead-letter queue exists for all queued applications that share a queue manager.</span></span> <span data-ttu-id="7611c-112">各個應用程式之寄不出的信件佇列都會允許佇列應用程式指定自己應用程式特定之寄不出的信件佇列，讓這些應用程式之間有更好的隔離。</span><span class="sxs-lookup"><span data-stu-id="7611c-112">A dead-letter queue for each application enables better isolation between queued applications that share a queue manager by allowing these applications to specify their own application-specific dead-letter queue.</span></span> <span data-ttu-id="7611c-113">與其他應用程式共用寄不出的信件佇列之應用程式必須瀏覽佇列，以尋找適用的訊息。</span><span class="sxs-lookup"><span data-stu-id="7611c-113">An application that shares a dead-letter queue with other applications has to browse the queue to find messages that are applicable to it.</span></span> <span data-ttu-id="7611c-114">使用應用程式特定之寄不出的信件佇列，可以向應用程式保證其寄不出的信件佇列中所有訊息都適用。</span><span class="sxs-lookup"><span data-stu-id="7611c-114">With an application-specific dead-letter queue, the application can be assured that all messages in its dead-letter queue are applicable to it.</span></span>  
  
 <span data-ttu-id="7611c-115">Windows Vista 提供應用程式特定的無效信件佇列。</span><span class="sxs-lookup"><span data-stu-id="7611c-115">Windows Vista provides for application-specific dead-letter queues.</span></span> <span data-ttu-id="7611c-116">應用程式特定的寄不出的信件佇列在 Windows Server 2003 和 Windows XP 中無法使用，而且應用程式必須使用全系統的無效信件佇列。</span><span class="sxs-lookup"><span data-stu-id="7611c-116">Application-specific dead-letter queues are not available in Windows Server 2003 and Windows XP, and applications must use the system-wide dead-letter queue.</span></span>  
  
## <a name="poison-message-handling"></a><span data-ttu-id="7611c-117">有害訊息處理</span><span class="sxs-lookup"><span data-stu-id="7611c-117">Poison-Message Handling</span></span>  
 <span data-ttu-id="7611c-118">有害訊息是超過嘗試傳遞至接收應用程式之次數上限的訊息。</span><span class="sxs-lookup"><span data-stu-id="7611c-118">A poison message is a message that has exceeded the maximum number of delivery attempts to the receiving application.</span></span> <span data-ttu-id="7611c-119">當從異動式佇列讀取訊息的應用程式因錯誤無法立即處理訊息時，便會引起這種情況。</span><span class="sxs-lookup"><span data-stu-id="7611c-119">This situation can arise when an application that reads a message from a transactional queue cannot process the message immediately because of errors.</span></span> <span data-ttu-id="7611c-120">如果應用程式中止收到佇列訊息的交易，會將訊息傳回佇列。</span><span class="sxs-lookup"><span data-stu-id="7611c-120">If the application aborts the transaction in which the queued message was received, it returns the message to the queue.</span></span> <span data-ttu-id="7611c-121">然後應用程式會嘗試在新的異動中再次擷取訊息。</span><span class="sxs-lookup"><span data-stu-id="7611c-121">The application then tries to retrieve the message again in a new transaction.</span></span> <span data-ttu-id="7611c-122">如果沒有更正造成錯誤的問題，接收應用程式會卡在接收及中止相同訊息的迴圈中，直到超過傳遞嘗試次數上限為止，而形成有害訊息。</span><span class="sxs-lookup"><span data-stu-id="7611c-122">If the problem that causes the error is not corrected, the receiving application can get stuck in a loop receiving and aborting the same message until it exceeds the maximum number of delivery attempts, and a poison message results.</span></span>  
  
 <span data-ttu-id="7611c-123">Windows Vista、Windows Server 2003 和 Windows XP 上的訊息佇列（MSMQ）與有害處理相關的主要差異包括下列各項：</span><span class="sxs-lookup"><span data-stu-id="7611c-123">The key differences between Message Queuing (MSMQ) on Windows Vista, Windows Server 2003, and Windows XP that are relevant to poison handling include the following:</span></span>  
  
- <span data-ttu-id="7611c-124">Windows Vista 中的 MSMQ 支援子佇列，而 Windows Server 2003 和 Windows XP 則不支援子佇列。</span><span class="sxs-lookup"><span data-stu-id="7611c-124">MSMQ in Windows Vista supports subqueues, while Windows Server 2003 and Windows XP do not support subqueues.</span></span> <span data-ttu-id="7611c-125">子佇列是在有害訊息處理中使用。</span><span class="sxs-lookup"><span data-stu-id="7611c-125">Subqueues are used in poison-message handling.</span></span> <span data-ttu-id="7611c-126">重試佇列和有害佇列都是應用程式佇列的子佇列，應用程式佇列是根據有害訊息處理設定而建立的。</span><span class="sxs-lookup"><span data-stu-id="7611c-126">The retry queues and the poison queue are subqueues to the application queue that is created based on the poison-message handling settings.</span></span> <span data-ttu-id="7611c-127">`MaxRetryCycles` 會指示要建立多少重試子佇列。</span><span class="sxs-lookup"><span data-stu-id="7611c-127">The `MaxRetryCycles` dictates how many retry subqueues to create.</span></span> <span data-ttu-id="7611c-128">因此，在 Windows Server 2003 或 Windows XP 上執行時， `MaxRetryCycles` 會忽略且 `ReceiveErrorHandling.Move` 不允許。</span><span class="sxs-lookup"><span data-stu-id="7611c-128">Therefore, when running on Windows Server 2003 or Windows XP, `MaxRetryCycles` are ignored and `ReceiveErrorHandling.Move` is not allowed.</span></span>  
  
- <span data-ttu-id="7611c-129">Windows Vista 中的 MSMQ 支援否定通知，而 Windows Server 2003 和 Windows XP 則否。</span><span class="sxs-lookup"><span data-stu-id="7611c-129">MSMQ in Windows Vista supports negative acknowledgment, while Windows Server 2003 and Windows XP do not.</span></span> <span data-ttu-id="7611c-130">來自接收佇列管理員的負認可會造成傳送佇列管理員將拒絕的訊息放在寄不出的信件佇列中。</span><span class="sxs-lookup"><span data-stu-id="7611c-130">A negative acknowledgment from the receiving queue manager causes the sending queue manager to place the rejected message in the dead-letter queue.</span></span> <span data-ttu-id="7611c-131">因此， `ReceiveErrorHandling.Reject` Windows Server 2003 和 WINDOWS XP 不允許使用。</span><span class="sxs-lookup"><span data-stu-id="7611c-131">As such, `ReceiveErrorHandling.Reject` is not allowed with Windows Server 2003 and Windows XP.</span></span>  
  
- <span data-ttu-id="7611c-132">Windows Vista 中的 MSMQ 支援訊息屬性，它會保留嘗試傳遞訊息的次數計數。</span><span class="sxs-lookup"><span data-stu-id="7611c-132">MSMQ in Windows Vista supports a message property that keeps count of the number of times message delivery is attempted.</span></span> <span data-ttu-id="7611c-133">Windows Server 2003 和 Windows XP 上無法使用此 [中止計數] 屬性。</span><span class="sxs-lookup"><span data-stu-id="7611c-133">This abort count property is not available on Windows Server 2003 and Windows XP.</span></span> <span data-ttu-id="7611c-134">WCF 會在記憶體中維護中止計數，因此當 Web 伺服陣列中的多個 WCF 服務讀取相同的訊息時，這個屬性可能不會包含正確的值。</span><span class="sxs-lookup"><span data-stu-id="7611c-134">WCF maintains the abort count in memory, so it is possible that this property may not contain an accurate value when the same message is read by more than one WCF service in a Web farm.</span></span>  
  
## <a name="remote-transactional-read"></a><span data-ttu-id="7611c-135">遠端交易式讀取</span><span class="sxs-lookup"><span data-stu-id="7611c-135">Remote Transactional Read</span></span>  
 <span data-ttu-id="7611c-136">Windows Vista 上的 MSMQ 支援遠端交易式讀取。</span><span class="sxs-lookup"><span data-stu-id="7611c-136">MSMQ on Windows Vista supports remote transactional reads.</span></span> <span data-ttu-id="7611c-137">這允許從佇列讀取的應用程式裝載在與裝載佇列不同的電腦上。</span><span class="sxs-lookup"><span data-stu-id="7611c-137">This allows an application that is reading from a queue to be hosted on a computer that is different from the computer on which the queue is hosted.</span></span> <span data-ttu-id="7611c-138">這可以確保讓服務的伺服陣列從中央佇列讀取的能力，以增加系統的整體輸送量。</span><span class="sxs-lookup"><span data-stu-id="7611c-138">This ensures the ability to have a farm of services reading from a central queue, which increases the overall throughput of the system.</span></span> <span data-ttu-id="7611c-139">它也可以確保當讀取及處理訊息、交易復原以及訊息保留在佇列中以供日後處理時，是否會發生失敗。</span><span class="sxs-lookup"><span data-stu-id="7611c-139">It also ensures that if a failure occurs when reading and processing the message, the transaction rolls back and the message remains in the queue for later processing.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="7611c-140">請參閱</span><span class="sxs-lookup"><span data-stu-id="7611c-140">See also</span></span>

- [<span data-ttu-id="7611c-141">使用無效信件佇列來處理訊息傳輸失敗</span><span class="sxs-lookup"><span data-stu-id="7611c-141">Using Dead-Letter Queues to Handle Message Transfer Failures</span></span>](using-dead-letter-queues-to-handle-message-transfer-failures.md)
- [<span data-ttu-id="7611c-142">有害訊息處理</span><span class="sxs-lookup"><span data-stu-id="7611c-142">Poison Message Handling</span></span>](poison-message-handling.md)
