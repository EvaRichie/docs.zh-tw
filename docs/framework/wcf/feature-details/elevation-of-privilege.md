---
title: 權限提高
ms.date: 03/30/2017
helpviewer_keywords:
- elevation of privilege [WCF]
- security [WCF], elevation of privilege
ms.assetid: 146e1c66-2a76-4ed3-98a5-fd77851a06d9
ms.openlocfilehash: 9c62e11eedaa3fa194522695a33bccf210d390df
ms.sourcegitcommit: bc293b14af795e0e999e3304dd40c0222cf2ffe4
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 11/26/2020
ms.locfileid: "96254216"
---
# <a name="elevation-of-privilege"></a><span data-ttu-id="0cf30-102">權限提高</span><span class="sxs-lookup"><span data-stu-id="0cf30-102">Elevation of Privilege</span></span>

<span data-ttu-id="0cf30-103">提高 *許可權的* 結果，是授與攻擊者授權許可權，但不超過最初授與的許可權。</span><span class="sxs-lookup"><span data-stu-id="0cf30-103">*Elevation of privilege* results from giving an attacker authorization permissions beyond those initially granted.</span></span> <span data-ttu-id="0cf30-104">例如，具有「唯讀」權限的攻擊者以不明方式將權限提高為「讀取和寫入」。</span><span class="sxs-lookup"><span data-stu-id="0cf30-104">For example, an attacker with a privilege set of "read only" permissions somehow elevates the set to include "read and write."</span></span>  
  
## <a name="trusted-sts-should-sign-saml-token-claims"></a><span data-ttu-id="0cf30-105">受信任的 STS 應該簽署 SAML 權杖宣告</span><span class="sxs-lookup"><span data-stu-id="0cf30-105">Trusted STS Should Sign SAML Token Claims</span></span>  

 <span data-ttu-id="0cf30-106">安全性判斷提示標記語言 (SAML) 權杖是一種泛型 XML 權杖，同時也是預設的發行權杖類型。</span><span class="sxs-lookup"><span data-stu-id="0cf30-106">A Security Assertions Markup Language (SAML) token is a generic XML token that is the default type for issued tokens.</span></span> <span data-ttu-id="0cf30-107">在典型的交換中，結尾 Web 服務所信任的安全性權杖服務 (STS) 可以建構 SAML 權杖。</span><span class="sxs-lookup"><span data-stu-id="0cf30-107">A SAML token can be constructed by a Security Token Service (STS) that the end Web service trusts in a typical exchange.</span></span> <span data-ttu-id="0cf30-108">SAML 權杖會在陳述式中包含宣告。</span><span class="sxs-lookup"><span data-stu-id="0cf30-108">SAML tokens contain claims in statements.</span></span> <span data-ttu-id="0cf30-109">攻擊者可從有效權杖中複製宣告、建立新的 SAML 權杖，然後使用不同的簽發者進行簽署。</span><span class="sxs-lookup"><span data-stu-id="0cf30-109">An attacker may copy the claims from a valid token, create a new SAML token, and sign it with a different issuer.</span></span> <span data-ttu-id="0cf30-110">其目的就是判斷伺服器是否正在驗證簽發者，如果不是的話，會運用弱點來建構 SAML 權杖，針對受信任 STS 原先要賦予的權限賦予更多的權限。</span><span class="sxs-lookup"><span data-stu-id="0cf30-110">The intent is to determine whether the server is validating issuers and, if not, utilize the weakness to construct SAML tokens that allow privileges beyond those intended by a trusted STS.</span></span>  
  
 <span data-ttu-id="0cf30-111"><xref:System.IdentityModel.Tokens.SamlAssertion> 類別會驗證 SAML 權杖中包含的數位簽章，而預設的 <xref:System.IdentityModel.Selectors.SamlSecurityTokenAuthenticator> 則要求當 <xref:System.ServiceModel.Security.IssuedTokenServiceCredential.CertificateValidationMode%2A> 類別的 <xref:System.ServiceModel.Security.IssuedTokenServiceCredential> 設為 <xref:System.ServiceModel.Security.X509CertificateValidationMode.ChainTrust> 時，必須使用有效的 X.509 憑證來簽署 SAML 權杖。</span><span class="sxs-lookup"><span data-stu-id="0cf30-111">The <xref:System.IdentityModel.Tokens.SamlAssertion> class verifies the digital signature contained within a SAML token, and the default <xref:System.IdentityModel.Selectors.SamlSecurityTokenAuthenticator> requires that SAML tokens be signed by an X.509 certificate that is valid when the <xref:System.ServiceModel.Security.IssuedTokenServiceCredential.CertificateValidationMode%2A> of the <xref:System.ServiceModel.Security.IssuedTokenServiceCredential> class is set to <xref:System.ServiceModel.Security.X509CertificateValidationMode.ChainTrust>.</span></span> <span data-ttu-id="0cf30-112">單是 `ChainTrust` 模式還不足以判斷 SAML 權杖的簽發者是否受信任。</span><span class="sxs-lookup"><span data-stu-id="0cf30-112">`ChainTrust` mode alone is insufficient to determine whether the issuer of the SAML token is trusted.</span></span> <span data-ttu-id="0cf30-113">需要更細微信任模型的服務可以使用授權與強制執行原則來檢查由已發行權杖驗證所產生的宣告集之簽發者，或是使用 <xref:System.ServiceModel.Security.IssuedTokenServiceCredential> 上的 X.509 驗證設定來限制允許的簽署憑證集。</span><span class="sxs-lookup"><span data-stu-id="0cf30-113">Services that require a more granular trust model can either use authorization and enforcement policies to check the issuer of the claim sets produced by issued token authentication or use the X.509 validation settings on <xref:System.ServiceModel.Security.IssuedTokenServiceCredential> to restrict the set of allowed signing certificates.</span></span> <span data-ttu-id="0cf30-114">如需詳細資訊，請參閱使用身分識別模型和[同盟和發行的權杖](federation-and-issued-tokens.md)來[管理宣告與授權](managing-claims-and-authorization-with-the-identity-model.md)。</span><span class="sxs-lookup"><span data-stu-id="0cf30-114">For more information, see [Managing Claims and Authorization with the Identity Model](managing-claims-and-authorization-with-the-identity-model.md) and [Federation and Issued Tokens](federation-and-issued-tokens.md).</span></span>  
  
## <a name="switching-identity-without-a-security-context"></a><span data-ttu-id="0cf30-115">切換不含安全性內容的身分識別</span><span class="sxs-lookup"><span data-stu-id="0cf30-115">Switching Identity Without a Security Context</span></span>  

 <span data-ttu-id="0cf30-116">以下僅適用于 WinFX。</span><span class="sxs-lookup"><span data-stu-id="0cf30-116">The following applies only to WinFX.</span></span>  
  
 <span data-ttu-id="0cf30-117">當用戶端與伺服器之間建立連線時，用戶端的身分識別不會變更，但在下列情況下：開啟 WCF 用戶端之後，如果下列所有條件都成立的話：</span><span class="sxs-lookup"><span data-stu-id="0cf30-117">When a connection is established between a client and server, the identity of the client does not change, except in one situation: after the WCF client is opened, if all of the following conditions are true:</span></span>  
  
- <span data-ttu-id="0cf30-118">建立安全性內容 (使用傳輸安全性會話或訊息安全性會話的程式) 關閉 (<xref:System.ServiceModel.NonDualMessageSecurityOverHttp.EstablishSecurityContext%2A> 屬性會設定為， `false` 以防訊息安全性或傳輸無法建立安全性會話時，會在傳輸安全性案例中使用。</span><span class="sxs-lookup"><span data-stu-id="0cf30-118">The procedures to establish a security context (using a transport security session or message security session) is switched off (<xref:System.ServiceModel.NonDualMessageSecurityOverHttp.EstablishSecurityContext%2A> property is set to `false` in case of message security or transport not capable of establishing security sessions is used in transport security case.</span></span> <span data-ttu-id="0cf30-119">HTTPS 即是此類傳輸的範例之一)。</span><span class="sxs-lookup"><span data-stu-id="0cf30-119">HTTPS is one example of such transport).</span></span>  
  
- <span data-ttu-id="0cf30-120">您目前使用 Windows 驗證。</span><span class="sxs-lookup"><span data-stu-id="0cf30-120">You are using Windows authentication.</span></span>  
  
- <span data-ttu-id="0cf30-121">您未明確設定認證。</span><span class="sxs-lookup"><span data-stu-id="0cf30-121">You do not explicitly set the credential.</span></span>  
  
- <span data-ttu-id="0cf30-122">您在模擬的安全性內容中呼叫服務。</span><span class="sxs-lookup"><span data-stu-id="0cf30-122">You are calling the service under the impersonated security context.</span></span>  
  
 <span data-ttu-id="0cf30-123">如果這些條件成立，用來向服務驗證用戶端的身分識別可能會變更 (可能不是模擬的身分識別，但在開啟 WCF 用戶端之後，仍) 進程身分識別。</span><span class="sxs-lookup"><span data-stu-id="0cf30-123">If these conditions are true, the identity used to authenticate the client to the service might change (it might not be the impersonated identity but the process identity instead) after the WCF client is opened.</span></span> <span data-ttu-id="0cf30-124">這是因為用來向服務驗證用戶端的 Windows 認證會隨著每個訊息一併傳輸，而用來驗證的認證則是從目前執行緒的 Windows 識別取得。</span><span class="sxs-lookup"><span data-stu-id="0cf30-124">This occurs because the Windows credential used to authenticate the client to the service is transmitted with every message, and the credential used for authentication is obtained from the current thread's Windows identity.</span></span> <span data-ttu-id="0cf30-125">如果目前執行緒的 Windows 識別變更 (例如，藉由模擬不同的呼叫者)，則附加至訊息並用來向服務驗證用戶端的認證可能會一併變更。</span><span class="sxs-lookup"><span data-stu-id="0cf30-125">If the Windows identity of the current thread changes (for example, by impersonating a different caller), the credential that is attached to the message and used to authenticate the client to the service might also change.</span></span>  
  
 <span data-ttu-id="0cf30-126">如果您希望在合併使用 Windows 驗證與模擬機制時擁有決定性行為，則您需要明確地設定 Windows 認證，或是需要建立服務的安全性內容。</span><span class="sxs-lookup"><span data-stu-id="0cf30-126">If you want to have deterministic behavior when using Windows authentication together with impersonation you need to explicitly set the Windows credential or you need to establish a security context with the service.</span></span> <span data-ttu-id="0cf30-127">若要這麼做，請使用訊息安全性工作階段或傳輸安全性工作階段。</span><span class="sxs-lookup"><span data-stu-id="0cf30-127">To do this, use a message security session or a transport security session.</span></span> <span data-ttu-id="0cf30-128">例如，net.tcp 傳輸可以提供傳輸安全性工作階段。</span><span class="sxs-lookup"><span data-stu-id="0cf30-128">For example, the net.tcp transport can provide a transport security session.</span></span> <span data-ttu-id="0cf30-129">此外，在呼叫服務時，只能使用同步版本的用戶端作業。</span><span class="sxs-lookup"><span data-stu-id="0cf30-129">Additionally, you must use only a synchronous version of client operations when calling the service.</span></span> <span data-ttu-id="0cf30-130">如果您建立訊息安全性內容，那麼與服務保持連線的時間不應該比設定的工作階段更新期間還長，因為身分識別也會在工作階段更新處理期間變更。</span><span class="sxs-lookup"><span data-stu-id="0cf30-130">If you establish a message security context, you should not keep the connection to the service open longer than the configured session renewal period, because the identity can also change during the session renewal process.</span></span>  
  
### <a name="credentials-capture"></a><span data-ttu-id="0cf30-131">認證擷取</span><span class="sxs-lookup"><span data-stu-id="0cf30-131">Credentials Capture</span></span>  

 <span data-ttu-id="0cf30-132">以下適用于 .NET Framework 3.5 和後續版本。</span><span class="sxs-lookup"><span data-stu-id="0cf30-132">The following applies to .NET Framework 3.5, and subsequent versions.</span></span>  
  
 <span data-ttu-id="0cf30-133">用戶端或服務所使用的認證，係依據目前的內容執行緒而定。</span><span class="sxs-lookup"><span data-stu-id="0cf30-133">Credentials used by the client or the service are based on the current context thread.</span></span> <span data-ttu-id="0cf30-134">認證會在呼叫用戶端或服務的 `Open` 方法時取得，如果是非同步呼叫 (Asynchronous Call)，則是在呼叫 `BeginOpen` 方法時取得。</span><span class="sxs-lookup"><span data-stu-id="0cf30-134">The credentials are obtained when the `Open` method (or `BeginOpen`, for asynchronous calls) of the client or service is called.</span></span> <span data-ttu-id="0cf30-135">對於 <xref:System.ServiceModel.ServiceHost> 和 <xref:System.ServiceModel.ClientBase%601> 類別而言，`Open` 和 `BeginOpen` 方法是繼承自 <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A> 類別的 <xref:System.ServiceModel.Channels.CommunicationObject.BeginOpen%2A> 和 <xref:System.ServiceModel.Channels.CommunicationObject> 方法。</span><span class="sxs-lookup"><span data-stu-id="0cf30-135">For both the <xref:System.ServiceModel.ServiceHost> and <xref:System.ServiceModel.ClientBase%601> classes, the `Open` and `BeginOpen` methods inherit from the <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A> and <xref:System.ServiceModel.Channels.CommunicationObject.BeginOpen%2A> methods of the <xref:System.ServiceModel.Channels.CommunicationObject> class.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="0cf30-136">使用 `BeginOpen` 方法時，所擷取的認證無法保證一定是呼叫該方法的處理序認證。</span><span class="sxs-lookup"><span data-stu-id="0cf30-136">When using the `BeginOpen` method, the credentials captured cannot be guaranteed to be the credentials of the process that calls the method.</span></span>  
  
## <a name="token-caches-allow-replay-using-obsolete-data"></a><span data-ttu-id="0cf30-137">權杖快取允許重新執行使用已過時資料</span><span class="sxs-lookup"><span data-stu-id="0cf30-137">Token Caches Allow Replay Using Obsolete Data</span></span>  

 <span data-ttu-id="0cf30-138">WCF 會使用本地安全機構 (LSA) `LogonUser` 函數，依使用者名稱和密碼來驗證使用者。</span><span class="sxs-lookup"><span data-stu-id="0cf30-138">WCF uses the local security authority (LSA) `LogonUser` function to authenticate users by user name and password.</span></span> <span data-ttu-id="0cf30-139">因為登入函式是成本高昂的作業，所以 WCF 可讓您快取代表已驗證使用者的權杖，以提升效能。</span><span class="sxs-lookup"><span data-stu-id="0cf30-139">Because the logon function is a costly operation, WCF allows you to cache tokens that represent authenticated users to increase performance.</span></span> <span data-ttu-id="0cf30-140">快取機制可儲存 `LogonUser` 的結果以供後續使用。</span><span class="sxs-lookup"><span data-stu-id="0cf30-140">The caching mechanism saves the results from `LogonUser` for subsequent uses.</span></span> <span data-ttu-id="0cf30-141">此機制預設為停用;若要啟用它，請將 <xref:System.ServiceModel.Security.UserNamePasswordServiceCredential.CacheLogonTokens%2A> 屬性設定為 `true` ，或使用的 `cacheLogonTokens` 屬性 [\<userNameAuthentication>](../../configure-apps/file-schema/wcf/usernameauthentication.md) 。</span><span class="sxs-lookup"><span data-stu-id="0cf30-141">This mechanism is disabled by default; to enable it, set the <xref:System.ServiceModel.Security.UserNamePasswordServiceCredential.CacheLogonTokens%2A> property to `true`, or use the `cacheLogonTokens` attribute of the [\<userNameAuthentication>](../../configure-apps/file-schema/wcf/usernameauthentication.md).</span></span>  
  
 <span data-ttu-id="0cf30-142">您可以將 <xref:System.ServiceModel.Security.UserNamePasswordServiceCredential.CachedLogonTokenLifetime%2A> 屬性 (Property) 設為 <xref:System.TimeSpan>，或是使用 `cachedLogonTokenLifetime` 項目的 `userNameAuthentication` 屬性 (Attribute) 為快取權杖設定存留時間 (TTL)；預設時間為 15 分鐘。</span><span class="sxs-lookup"><span data-stu-id="0cf30-142">You can set a Time to Live (TTL) for the cached tokens by setting the <xref:System.ServiceModel.Security.UserNamePasswordServiceCredential.CachedLogonTokenLifetime%2A> property to a <xref:System.TimeSpan>, or use the `cachedLogonTokenLifetime` attribute of the `userNameAuthentication` element; the default is 15 minutes.</span></span> <span data-ttu-id="0cf30-143">請注意，一旦快取了權杖，任何使用相同使用者名稱與密碼的用戶端都可以使用該權杖，就算使用者帳戶已從 Windows 中刪除，或當其密碼已經變更也是一樣。</span><span class="sxs-lookup"><span data-stu-id="0cf30-143">Note that while a token is cached, any client that presents the same user name and password can use the token, even if the user account is deleted from Windows or if its password has been changed.</span></span> <span data-ttu-id="0cf30-144">在 TTL 到期且權杖從快取中移除之前，WCF 可讓 (可能是惡意的) 使用者進行驗證。</span><span class="sxs-lookup"><span data-stu-id="0cf30-144">Until the TTL expires and the token is removed from the cache, WCF allows the (possibly malicious) user to authenticate.</span></span>  
  
 <span data-ttu-id="0cf30-145">若要緩解這個情況：請將 `cachedLogonTokenLifetime` 值設為使用者所需的最短時間範圍來減少可能遭受攻擊的時間範圍。</span><span class="sxs-lookup"><span data-stu-id="0cf30-145">To mitigate this: Decrease the attack window by setting the `cachedLogonTokenLifetime` value to the shortest time span your users need.</span></span>  
  
## <a name="issued-token-authorization-expiration-reset-to-large-value"></a><span data-ttu-id="0cf30-146">發行的權杖授權：到期日重設為較大值</span><span class="sxs-lookup"><span data-stu-id="0cf30-146">Issued Token Authorization: Expiration Reset to Large Value</span></span>  

 <span data-ttu-id="0cf30-147">在特定情況下，<xref:System.IdentityModel.Policy.AuthorizationContext.ExpirationTime%2A> 的 <xref:System.IdentityModel.Policy.AuthorizationContext> 屬性可以設為超出預期的較大值 (<xref:System.DateTime.MaxValue> 欄位值減掉一天，或是 9999 年 12 月 20 日)。</span><span class="sxs-lookup"><span data-stu-id="0cf30-147">Under certain conditions, the <xref:System.IdentityModel.Policy.AuthorizationContext.ExpirationTime%2A> property of the <xref:System.IdentityModel.Policy.AuthorizationContext> may be set to an unexpectedly larger value (the <xref:System.DateTime.MaxValue> field value minus one day, or December 20, 9999).</span></span>  
  
 <span data-ttu-id="0cf30-148">當您使用 <xref:System.ServiceModel.WSFederationHttpBinding> 以及任何將已發行權杖當成用戶端認證類型來使用的系統提供繫結時，就會發生這種情況。</span><span class="sxs-lookup"><span data-stu-id="0cf30-148">This occurs when using the <xref:System.ServiceModel.WSFederationHttpBinding> and any of the system-provided bindings that have an issued token as the client credential type.</span></span>  
  
 <span data-ttu-id="0cf30-149">當您使用下列其中一種方法來建立自訂繫結時，也會發生這種情況：</span><span class="sxs-lookup"><span data-stu-id="0cf30-149">This also occurs when you create custom bindings by using one of the following methods:</span></span>  
  
- <xref:System.ServiceModel.Channels.SecurityBindingElement.CreateIssuedTokenBindingElement%2A>  
  
- <xref:System.ServiceModel.Channels.SecurityBindingElement.CreateIssuedTokenForCertificateBindingElement%2A>  
  
- <xref:System.ServiceModel.Channels.SecurityBindingElement.CreateIssuedTokenForSslBindingElement%2A>  
  
- <xref:System.ServiceModel.Channels.SecurityBindingElement.CreateIssuedTokenOverTransportBindingElement%2A>  
  
 <span data-ttu-id="0cf30-150">若要緩解這個情況，授權原則必須檢查每個授權原則的動作與到期時間。</span><span class="sxs-lookup"><span data-stu-id="0cf30-150">To mitigate this, the authorization policy must check the action and the expiration time of each authorization policy.</span></span>  
  
## <a name="the-service-uses-a-different-certificate-than-the-client-intended"></a><span data-ttu-id="0cf30-151">服務使用的憑證不同於用戶端原先想要的憑證</span><span class="sxs-lookup"><span data-stu-id="0cf30-151">The Service Uses a Different Certificate Than the Client Intended</span></span>  

 <span data-ttu-id="0cf30-152">在特定情況下，用戶端可以使用 X.509 憑證來數位簽署訊息，並讓服務擷取與原先不同的憑證。</span><span class="sxs-lookup"><span data-stu-id="0cf30-152">Under certain conditions, a client can digitally sign a message with an X.509 certificate and have the service retrieve a different certificate than the intended one.</span></span>  
  
 <span data-ttu-id="0cf30-153">在下列狀況下可能會發生這種情形：</span><span class="sxs-lookup"><span data-stu-id="0cf30-153">This can occur under the following circumstances:</span></span>  
  
- <span data-ttu-id="0cf30-154">用戶端使用 X.509 憑證來數位簽署訊息，而且未將 X.509 憑證附加至訊息，只有使用其主體金鑰識別碼來參照憑證。</span><span class="sxs-lookup"><span data-stu-id="0cf30-154">The client digitally signs a message using an X.509 certificate and does not attach the X.509 certificate to the message, but rather just references the certificate using its subject key identifier.</span></span>  
  
- <span data-ttu-id="0cf30-155">服務的電腦包含兩個以上的憑證具有相同的公開金鑰，但是憑證中包含不同的資訊。</span><span class="sxs-lookup"><span data-stu-id="0cf30-155">The service's computer contains two or more certificates with the same public key, but they contain different information.</span></span>  
  
- <span data-ttu-id="0cf30-156">服務擷取的憑證符合主體主鑰識別碼，但不是用戶端原先想要使用的那組憑證。</span><span class="sxs-lookup"><span data-stu-id="0cf30-156">The service retrieves a certificate that matches the subject key identifier, but it is not the one the client intended to use.</span></span> <span data-ttu-id="0cf30-157">當 WCF 接收訊息並驗證簽章時，WCF 會將非預期的 x.509 憑證中的資訊對應到一組不同的宣告，而且可能會從用戶端預期的許可權提升。</span><span class="sxs-lookup"><span data-stu-id="0cf30-157">When WCF receives the message and verifies the signature, WCF maps the information in the unintended X.509 certificate to a set of claims that are different and potentially elevated from what the client expected.</span></span>  
  
 <span data-ttu-id="0cf30-158">若要緩解這個情況，請以另一種方式來參照 X.509 憑證，例如使用 <xref:System.ServiceModel.Security.Tokens.X509KeyIdentifierClauseType.IssuerSerial>。</span><span class="sxs-lookup"><span data-stu-id="0cf30-158">To mitigate this, reference the X.509 certificate another way, such as using <xref:System.ServiceModel.Security.Tokens.X509KeyIdentifierClauseType.IssuerSerial>.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="0cf30-159">另請參閱</span><span class="sxs-lookup"><span data-stu-id="0cf30-159">See also</span></span>

- [<span data-ttu-id="0cf30-160">安全性考量</span><span class="sxs-lookup"><span data-stu-id="0cf30-160">Security Considerations</span></span>](security-considerations-in-wcf.md)
- [<span data-ttu-id="0cf30-161">洩露資訊</span><span class="sxs-lookup"><span data-stu-id="0cf30-161">Information Disclosure</span></span>](information-disclosure.md)
- [<span data-ttu-id="0cf30-162">拒絕服務</span><span class="sxs-lookup"><span data-stu-id="0cf30-162">Denial of Service</span></span>](denial-of-service.md)
- [<span data-ttu-id="0cf30-163">重新執行攻擊</span><span class="sxs-lookup"><span data-stu-id="0cf30-163">Replay Attacks</span></span>](replay-attacks.md)
- [<span data-ttu-id="0cf30-164">竄改</span><span class="sxs-lookup"><span data-stu-id="0cf30-164">Tampering</span></span>](tampering.md)
- [<span data-ttu-id="0cf30-165">不支援的案例</span><span class="sxs-lookup"><span data-stu-id="0cf30-165">Unsupported Scenarios</span></span>](unsupported-scenarios.md)
