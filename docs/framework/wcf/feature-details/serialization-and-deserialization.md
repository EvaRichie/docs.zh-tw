---
title: 序列化和還原序列化
description: 瞭解 WCF 序列化引擎，這會在兩個方向的 .NET Framework 物件和 XML 之間轉譯。
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: 3d71814c-bda7-424b-85b7-15084ff9377a
ms.openlocfilehash: b770543eb09ed2edc1a028561e0cf41e74fab1cc
ms.sourcegitcommit: 2543a78be6e246aa010a01decf58889de53d1636
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 07/17/2020
ms.locfileid: "86444491"
---
# <a name="serialization-and-deserialization"></a><span data-ttu-id="06506-103">序列化和還原序列化</span><span class="sxs-lookup"><span data-stu-id="06506-103">Serialization and Deserialization</span></span>
<span data-ttu-id="06506-104">Windows Communication Foundation （WCF）包含新的序列化引擎，也就是 <xref:System.Runtime.Serialization.DataContractSerializer> 。</span><span class="sxs-lookup"><span data-stu-id="06506-104">Windows Communication Foundation (WCF) includes a new serialization engine, the <xref:System.Runtime.Serialization.DataContractSerializer>.</span></span> <span data-ttu-id="06506-105">會 <xref:System.Runtime.Serialization.DataContractSerializer> 在兩個方向的 .NET Framework 物件和 XML 之間轉譯。</span><span class="sxs-lookup"><span data-stu-id="06506-105">The <xref:System.Runtime.Serialization.DataContractSerializer> translates between .NET Framework objects and XML, in both directions.</span></span> <span data-ttu-id="06506-106">本主題會說明序列化程式的運作方式。</span><span class="sxs-lookup"><span data-stu-id="06506-106">This topic explains how the serializer works.</span></span>  
  
 <span data-ttu-id="06506-107">序列化 .NET Framework 物件時，序列化程式會瞭解各種不同的序列化程式設計模型，包括新的*資料合約*模型。</span><span class="sxs-lookup"><span data-stu-id="06506-107">When serializing .NET Framework objects, the serializer understands a variety of serialization programming models, including the new *data contract* model.</span></span> <span data-ttu-id="06506-108">如需完整的支援型別清單，請參閱 [Types Supported by the Data Contract Serializer](types-supported-by-the-data-contract-serializer.md)。</span><span class="sxs-lookup"><span data-stu-id="06506-108">For a full list of supported types, see [Types Supported by the Data Contract Serializer](types-supported-by-the-data-contract-serializer.md).</span></span> <span data-ttu-id="06506-109">如需資料合約的簡介，請參閱 [Using Data Contracts](using-data-contracts.md)。</span><span class="sxs-lookup"><span data-stu-id="06506-109">For an introduction to data contracts, see [Using Data Contracts](using-data-contracts.md).</span></span>  
  
 <span data-ttu-id="06506-110">還原序列化 XML 時，序列化程式會使用 <xref:System.Xml.XmlReader> 和 <xref:System.Xml.XmlWriter> 類別。</span><span class="sxs-lookup"><span data-stu-id="06506-110">When deserializing XML, the serializer uses the <xref:System.Xml.XmlReader> and <xref:System.Xml.XmlWriter> classes.</span></span> <span data-ttu-id="06506-111">它也支援 <xref:System.Xml.XmlDictionaryReader> 和 <xref:System.Xml.XmlDictionaryWriter> 類別，讓它在某些情況下產生優化的 xml，例如使用 WCF 二進位 XML 格式時。</span><span class="sxs-lookup"><span data-stu-id="06506-111">It also supports the <xref:System.Xml.XmlDictionaryReader> and <xref:System.Xml.XmlDictionaryWriter> classes to enable it to produce optimized XML in some cases, such as when using the WCF binary XML format.</span></span>  
  
 <span data-ttu-id="06506-112">WCF 也包含隨附的序列化程式，也就是 <xref:System.Runtime.Serialization.NetDataContractSerializer> 。</span><span class="sxs-lookup"><span data-stu-id="06506-112">WCF also includes a companion serializer, the <xref:System.Runtime.Serialization.NetDataContractSerializer>.</span></span> <span data-ttu-id="06506-113"><xref:System.Runtime.Serialization.NetDataContractSerializer>：</span><span class="sxs-lookup"><span data-stu-id="06506-113">The <xref:System.Runtime.Serialization.NetDataContractSerializer>:</span></span>

* <span data-ttu-id="06506-114">***不***安全。</span><span class="sxs-lookup"><span data-stu-id="06506-114">Is ***not*** secure.</span></span> <span data-ttu-id="06506-115">如需詳細資訊，請參閱[BinaryFormatter 安全性指南](/dotnet/standard/serialization/binaryformatter-security-guide)。</span><span class="sxs-lookup"><span data-stu-id="06506-115">For more information, see the [BinaryFormatter security guide](/dotnet/standard/serialization/binaryformatter-security-guide).</span></span>
* <span data-ttu-id="06506-116">類似于 <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> 和序列化程式， <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter> 因為它也會發出 .NET Framework 型別名稱做為序列化資料的一部分。</span><span class="sxs-lookup"><span data-stu-id="06506-116">Is similar to the <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> and <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter> serializers because it also emits .NET Framework type names as part of the serialized data.</span></span>
* <span data-ttu-id="06506-117">當序列化和還原序列化結束時，會使用相同的類型。</span><span class="sxs-lookup"><span data-stu-id="06506-117">Is used when the same types are shared on the serializing and the deserializing ends.</span></span>

 <span data-ttu-id="06506-118"><xref:System.Runtime.Serialization.DataContractSerializer>和都 <xref:System.Runtime.Serialization.NetDataContractSerializer> 衍生自一般基類， <xref:System.Runtime.Serialization.XmlObjectSerializer> 。</span><span class="sxs-lookup"><span data-stu-id="06506-118">Both <xref:System.Runtime.Serialization.DataContractSerializer> and <xref:System.Runtime.Serialization.NetDataContractSerializer> derive from a common base class, <xref:System.Runtime.Serialization.XmlObjectSerializer>.</span></span>  
  
> [!WARNING]
> <span data-ttu-id="06506-119"><xref:System.Runtime.Serialization.DataContractSerializer> 會將包含十六進位值低於 20 之控制字元的字串序列化成 XML 實體。</span><span class="sxs-lookup"><span data-stu-id="06506-119">The <xref:System.Runtime.Serialization.DataContractSerializer> serializes strings containing control characters with a hexadecimal value below 20 as XML entities.</span></span> <span data-ttu-id="06506-120">這可能會在將這類資料傳送至 WCF 服務時，導致非 WCF 用戶端發生問題。</span><span class="sxs-lookup"><span data-stu-id="06506-120">This may cause a problem with a non-WCF client when sending such data to a WCF service.</span></span>  
  
## <a name="creating-a-datacontractserializer-instance"></a><span data-ttu-id="06506-121">建立 DataContractSerializer 執行個體</span><span class="sxs-lookup"><span data-stu-id="06506-121">Creating a DataContractSerializer Instance</span></span>  
 <span data-ttu-id="06506-122">建構 <xref:System.Runtime.Serialization.DataContractSerializer> 的執行個體是很重要的步驟。</span><span class="sxs-lookup"><span data-stu-id="06506-122">Constructing an instance of the <xref:System.Runtime.Serialization.DataContractSerializer> is an important step.</span></span> <span data-ttu-id="06506-123">建構完成之後，您將無法變更任何設定。</span><span class="sxs-lookup"><span data-stu-id="06506-123">After construction, you cannot change any of the settings.</span></span>  
  
### <a name="specifying-the-root-type"></a><span data-ttu-id="06506-124">指定根型別</span><span class="sxs-lookup"><span data-stu-id="06506-124">Specifying the Root Type</span></span>  
 <span data-ttu-id="06506-125">「 *根型別* 」(Root Type) 是指已序列化或還原序列化之執行個體的型別。</span><span class="sxs-lookup"><span data-stu-id="06506-125">The *root type* is the type of which instances are serialized or deserialized.</span></span> <span data-ttu-id="06506-126"><xref:System.Runtime.Serialization.DataContractSerializer> 包含許多建構函式多載，但是，根型別至少必須透過 `type` 參數來提供。</span><span class="sxs-lookup"><span data-stu-id="06506-126">The <xref:System.Runtime.Serialization.DataContractSerializer> has many constructor overloads, but, at a minimum, a root type must be supplied using the `type` parameter.</span></span>  
  
 <span data-ttu-id="06506-127">針對特定根型別所建立的序列化程式無法用來序列化 (或還原序列化) 另一種型別，除非該型別衍生自根型別。</span><span class="sxs-lookup"><span data-stu-id="06506-127">A serializer created for a certain root type cannot be used to serialize (or deserialize) another type, unless the type is derived from the root type.</span></span> <span data-ttu-id="06506-128">以下範例顯示兩個類別。</span><span class="sxs-lookup"><span data-stu-id="06506-128">The following example shows two classes.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#1)]
 [!code-vb[c_StandaloneDataContractSerializer#1](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#1)]  
  
 <span data-ttu-id="06506-129">這個程式碼所建構的 `DataContractSerializer` 執行個體只能用來序列化或還原序列化 `Person` 類別的執行個體。</span><span class="sxs-lookup"><span data-stu-id="06506-129">This code constructs an instance of the `DataContractSerializer` that can be used only to serialize or deserialize instances of the `Person` class.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#2)]
 [!code-vb[c_StandaloneDataContractSerializer#2](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#2)]  
  
### <a name="specifying-known-types"></a><span data-ttu-id="06506-130">指定已知型別</span><span class="sxs-lookup"><span data-stu-id="06506-130">Specifying Known Types</span></span>  
 <span data-ttu-id="06506-131">如果透過 <xref:System.Runtime.Serialization.KnownTypeAttribute> 屬性或其他一些機制來序列化尚未處理的型別時運用了多型 (Polymorphism)，則必須透過 `knownTypes` 參數將可能的已知型別清單傳遞至序列化程式的建構函式中。</span><span class="sxs-lookup"><span data-stu-id="06506-131">If polymorphism is involved in the types being serialized that is not already handled using the <xref:System.Runtime.Serialization.KnownTypeAttribute> attribute or some other mechanism, a list of possible known types must be passed to the serializer’s constructor using the `knownTypes` parameter.</span></span> <span data-ttu-id="06506-132">如需已知類型的詳細資訊，請參閱[資料合約已知類型](data-contract-known-types.md)。</span><span class="sxs-lookup"><span data-stu-id="06506-132">For more information about known types, see [Data Contract Known Types](data-contract-known-types.md).</span></span>  
  
 <span data-ttu-id="06506-133">下列範例說明類別 ( `LibraryPatron`)，其中包含了特定型別的集合 ( `LibraryItem`)。</span><span class="sxs-lookup"><span data-stu-id="06506-133">The following example shows a class, `LibraryPatron`, that includes a collection of a specific type, the `LibraryItem`.</span></span> <span data-ttu-id="06506-134">第二個類別定義了 `LibraryItem` 型別。</span><span class="sxs-lookup"><span data-stu-id="06506-134">The second class defines the `LibraryItem` type.</span></span> <span data-ttu-id="06506-135">第三與第四個類別 (`Book` 和 `Newspaper`) 則繼承了 `LibraryItem` 類別。</span><span class="sxs-lookup"><span data-stu-id="06506-135">The third and four classes (`Book` and `Newspaper`) inherit from the `LibraryItem` class.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#3)]  
 [!code-vb[c_StandaloneDataContractSerializer#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#3)]  
  
 <span data-ttu-id="06506-136">下列程式碼會透過 `knownTypes` 參數來建構序列化程式的執行個體。</span><span class="sxs-lookup"><span data-stu-id="06506-136">The following code constructs an instance of the serializer using the `knownTypes` parameter.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#4](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#4)]
 [!code-vb[c_StandaloneDataContractSerializer#4](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#4)]  
  
### <a name="specifying-the-default-root-name-and-namespace"></a><span data-ttu-id="06506-137">指定預設的根名稱與命名空間</span><span class="sxs-lookup"><span data-stu-id="06506-137">Specifying the Default Root Name and Namespace</span></span>  
 <span data-ttu-id="06506-138">一般來說，在序列化物件時，最外部 XML 項目的預設名稱與命名空間會依據資料合約名稱與命名空間來決定。</span><span class="sxs-lookup"><span data-stu-id="06506-138">Normally, when an object is serialized, the default name and namespace of the outermost XML element are determined according to the data contract name and namespace.</span></span> <span data-ttu-id="06506-139">所有內部項目的名稱都會從資料成員名稱中決定，而其命名空間則是資料合約的命名空間。</span><span class="sxs-lookup"><span data-stu-id="06506-139">The names of all inner elements are determined from data member names, and their namespace is the data contract’s namespace.</span></span> <span data-ttu-id="06506-140">下列範例會在 `Name` 和 `Namespace` 類別的建構函式中設定 <xref:System.Runtime.Serialization.DataContractAttribute> 和 <xref:System.Runtime.Serialization.DataMemberAttribute> 值。</span><span class="sxs-lookup"><span data-stu-id="06506-140">The following example sets `Name` and `Namespace` values in the constructors of the <xref:System.Runtime.Serialization.DataContractAttribute> and <xref:System.Runtime.Serialization.DataMemberAttribute> classes.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#5](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#5)]
 [!code-vb[c_StandaloneDataContractSerializer#5](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#5)]  
  
 <span data-ttu-id="06506-141">序列化 `Person` 類別的執行個體會產生類似下列的 XML。</span><span class="sxs-lookup"><span data-stu-id="06506-141">Serializing an instance of the `Person` class produces XML similar to the following.</span></span>  
  
```xml  
<PersonContract xmlns="http://schemas.contoso.com">  
  <AddressMember>  
    <StreetMember>123 Main Street</StreetMember>  
   </AddressMember>  
</PersonContract>  
```  
  
 <span data-ttu-id="06506-142">但是，您可以將 `rootName` 和 `rootNamespace` 的參數值傳遞至 <xref:System.Runtime.Serialization.DataContractSerializer> 建構函式中，以自訂根項目的預設名稱和命名空間。</span><span class="sxs-lookup"><span data-stu-id="06506-142">However, you can customize the default name and namespace of the root element by passing the values of the `rootName` and `rootNamespace` parameters to the <xref:System.Runtime.Serialization.DataContractSerializer> constructor.</span></span> <span data-ttu-id="06506-143">請注意， `rootNamespace` 不會影響包含的項目 (對應至資料成員) 命名空間。</span><span class="sxs-lookup"><span data-stu-id="06506-143">Note that the `rootNamespace` does not affect the namespace of the contained elements that correspond to data members.</span></span> <span data-ttu-id="06506-144">它只會影響最外部項目的命名空間。</span><span class="sxs-lookup"><span data-stu-id="06506-144">It affects only the namespace of the outermost element.</span></span>  
  
 <span data-ttu-id="06506-145">這些值都可以傳遞做為 <xref:System.Xml.XmlDictionaryString> 類別的字串或執行個體，以便透過二進位 XML 格式加以最佳化。</span><span class="sxs-lookup"><span data-stu-id="06506-145">These values can be passed as strings or instances of the <xref:System.Xml.XmlDictionaryString> class to allow for their optimization using the binary XML format.</span></span>  
  
### <a name="setting-the-maximum-objects-quota"></a><span data-ttu-id="06506-146">設定最大物件數量配額</span><span class="sxs-lookup"><span data-stu-id="06506-146">Setting the Maximum Objects Quota</span></span>  
 <span data-ttu-id="06506-147">某些 `DataContractSerializer` 建構函式多載包含有 `maxItemsInObjectGraph` 參數。</span><span class="sxs-lookup"><span data-stu-id="06506-147">Some `DataContractSerializer` constructor overloads have a `maxItemsInObjectGraph` parameter.</span></span> <span data-ttu-id="06506-148">這項參數可決定序列化程式在單一 <xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> 方法呼叫中能夠序列化或還原序列化的最大物件數量</span><span class="sxs-lookup"><span data-stu-id="06506-148">This parameter determines the maximum number of objects the serializer serializes or deserializes in a single <xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> method call.</span></span> <span data-ttu-id="06506-149">(此方法一定會讀取一個根物件，但是這個物件可能會在其資料成員中又有其他物件。</span><span class="sxs-lookup"><span data-stu-id="06506-149">(The method always reads one root object, but this object may have other objects in its data members.</span></span> <span data-ttu-id="06506-150">這些物件可能會有其他物件等等）。預設值為65536。</span><span class="sxs-lookup"><span data-stu-id="06506-150">Those objects may have other objects, and so on.) The default is 65536.</span></span> <span data-ttu-id="06506-151">請注意，當序列化或還原序列化陣列時，每個陣列項目都視為個別物件。</span><span class="sxs-lookup"><span data-stu-id="06506-151">Note that when serializing or deserializing arrays, every array entry counts as a separate object.</span></span> <span data-ttu-id="06506-152">另外請注意，有些物件可能有大量記憶體表示，因此只有這個配額可能不足以防止阻絕服務攻擊。</span><span class="sxs-lookup"><span data-stu-id="06506-152">Also, note that some objects may have a large memory representation, and so this quota alone may not be sufficient to prevent a denial of service attack.</span></span> <span data-ttu-id="06506-153">如需詳細資訊，請參閱[資料的安全性考慮](security-considerations-for-data.md)。</span><span class="sxs-lookup"><span data-stu-id="06506-153">For more information, see [Security Considerations for Data](security-considerations-for-data.md).</span></span> <span data-ttu-id="06506-154">如果您需要將這個配額調高到預設值以上，請在傳送 (序列化) 和接收 (還原序列化) 端都執行這項操作，因為它會在讀取與寫入資料時同時套用。</span><span class="sxs-lookup"><span data-stu-id="06506-154">If you need to increase this quota beyond the default value, it is important to do so both on the sending (serializing) and receiving (deserializing) sides because it applies to both when reading and writing data.</span></span>  
  
### <a name="round-trips"></a><span data-ttu-id="06506-155">來回行程</span><span class="sxs-lookup"><span data-stu-id="06506-155">Round Trips</span></span>  
 <span data-ttu-id="06506-156">在一個作業中還原序列化物件後重新加以序列化的程序，我們稱為「 *來回行程* 」(Round Trip)。</span><span class="sxs-lookup"><span data-stu-id="06506-156">A *round trip* occurs when an object is deserialized and re-serialized in one operation.</span></span> <span data-ttu-id="06506-157">因此，它會從 XML 變成物件執行個體，並回到原本的 XML 資料流。</span><span class="sxs-lookup"><span data-stu-id="06506-157">Thus, it goes from XML to an object instance, and back again into an XML stream.</span></span>  
  
 <span data-ttu-id="06506-158">某些 `DataContractSerializer` 建構函式多載包含有 `ignoreExtensionDataObject` 參數 (預設為 `false` )。</span><span class="sxs-lookup"><span data-stu-id="06506-158">Some `DataContractSerializer` constructor overloads have an `ignoreExtensionDataObject` parameter, which is set to `false` by default.</span></span> <span data-ttu-id="06506-159">在此預設模式中，只要資料合約實作 <xref:System.Runtime.Serialization.IExtensibleDataObject> 介面，資料就可以從較新版的資料合約一路經由較舊版本的資料合約再傳回較新版的資料合約來完成無資料損失的來回行程。</span><span class="sxs-lookup"><span data-stu-id="06506-159">In this default mode, data can be sent on a round trip from a newer version of a data contract through an older version and back to the newer version without loss, as long as the data contract implements the <xref:System.Runtime.Serialization.IExtensibleDataObject> interface.</span></span> <span data-ttu-id="06506-160">例如，假定 `Person` 資料合約的第 1 版包含 `Name` 和 `PhoneNumber` 資料成員，而第 2 版新增了 `Nickname` 成員。</span><span class="sxs-lookup"><span data-stu-id="06506-160">For example, suppose version 1 of the `Person` data contract contains the `Name` and `PhoneNumber` data members, and version 2 adds a `Nickname` member.</span></span> <span data-ttu-id="06506-161">如果實作了 `IExtensibleDataObject` ，則當從第 2 版傳送資訊到第 1 版時，會儲存 `Nickname` 資料，然後在資料序列化期間重新將它發出，這樣一來，來回行程期間就不會損失任何資料。</span><span class="sxs-lookup"><span data-stu-id="06506-161">If `IExtensibleDataObject` is implemented, when sending information from version 2 to version 1, the `Nickname` data is stored, and then re-emitted when the data is serialized again; therefore, no data is lost in the round trip.</span></span> <span data-ttu-id="06506-162">如需詳細資訊，請參閱[向前相容資料合約](forward-compatible-data-contracts.md)和[資料合約版本控制](data-contract-versioning.md)。</span><span class="sxs-lookup"><span data-stu-id="06506-162">For more information, see [Forward-Compatible Data Contracts](forward-compatible-data-contracts.md) and [Data Contract Versioning](data-contract-versioning.md).</span></span>  
  
#### <a name="security-and-schema-validity-concerns-with-round-trips"></a><span data-ttu-id="06506-163">來回行程的安全性與結構描述有效性考量</span><span class="sxs-lookup"><span data-stu-id="06506-163">Security and Schema Validity Concerns with Round Trips</span></span>  
 <span data-ttu-id="06506-164">來回行程可能包含一些安全性意涵。</span><span class="sxs-lookup"><span data-stu-id="06506-164">Round trips may have security implications.</span></span> <span data-ttu-id="06506-165">例如，還原序列化與儲存大量的非直接關聯資料時，可能會帶來安全性風險。</span><span class="sxs-lookup"><span data-stu-id="06506-165">For example, deserializing and storing large amounts of extraneous data may be a security risk.</span></span> <span data-ttu-id="06506-166">由於重新發出這項資料時並無法加以驗證，特別是當牽涉到數位簽章時，因此可能會有一些安全上的考量。</span><span class="sxs-lookup"><span data-stu-id="06506-166">There may be security concerns about re-emitting this data that there is no way to verify, especially if digital signatures are involved.</span></span> <span data-ttu-id="06506-167">例如，在之前的案例中，第 1 版的端點可能會簽署包含惡意資料的 `Nickname` 值。</span><span class="sxs-lookup"><span data-stu-id="06506-167">For example, in the previous scenario, the version 1 endpoint could be signing a `Nickname` value that contains malicious data.</span></span> <span data-ttu-id="06506-168">最後，還是可能有一些結構描述上的有效性考量：端點可能想要一直發出能夠恪遵其陳述的合約規定，而非其他額外值的資料。</span><span class="sxs-lookup"><span data-stu-id="06506-168">Finally, there may be schema validity concerns: an endpoint may want to always emit data that strictly adheres to its stated contract and not any extra values.</span></span> <span data-ttu-id="06506-169">在先前的範例中，第 1 版端點的合約告知僅發出 `Name` 和 `PhoneNumber`，而且假如使用結構描述驗證法的話，發出額外的 `Nickname` 值將讓驗證失敗。</span><span class="sxs-lookup"><span data-stu-id="06506-169">In the previous example, the version 1 endpoint’s contract says that it emits only `Name` and `PhoneNumber`, and if schema validation is being used, emitting the extra `Nickname` value causes validation to fail.</span></span>  
  
#### <a name="enabling-and-disabling-round-trips"></a><span data-ttu-id="06506-170">啟用和停用來回行程</span><span class="sxs-lookup"><span data-stu-id="06506-170">Enabling and Disabling Round Trips</span></span>  
 <span data-ttu-id="06506-171">若要關閉來回行程，請勿實作 <xref:System.Runtime.Serialization.IExtensibleDataObject> 介面。</span><span class="sxs-lookup"><span data-stu-id="06506-171">To turn off round trips, do not implement the <xref:System.Runtime.Serialization.IExtensibleDataObject> interface.</span></span> <span data-ttu-id="06506-172">如果您無法掌控型別，請將 `ignoreExtensionDataObject` 參數設定為 `true` 來達到相同的效果。</span><span class="sxs-lookup"><span data-stu-id="06506-172">If you have no control over the types, set the `ignoreExtensionDataObject` parameter to `true` to achieve the same effect.</span></span>  
  
### <a name="object-graph-preservation"></a><span data-ttu-id="06506-173">物件圖形保留</span><span class="sxs-lookup"><span data-stu-id="06506-173">Object Graph Preservation</span></span>  
 <span data-ttu-id="06506-174">一般來說，序列化程式並不關心物件身分識別，如下列程式碼所示。</span><span class="sxs-lookup"><span data-stu-id="06506-174">Normally, the serializer does not care about object identity, as in the following code.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#6](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#6)]
 [!code-vb[c_StandaloneDataContractSerializer#6](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#6)]  
  
 <span data-ttu-id="06506-175">下列程式碼會建立採購單。</span><span class="sxs-lookup"><span data-stu-id="06506-175">The following code creates a purchase order.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#7](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#7)]
 [!code-vb[c_StandaloneDataContractSerializer#7](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#7)]  
  
 <span data-ttu-id="06506-176">請注意， `billTo` 和 `shipTo` 欄位都已設定為相同的物件執行個體。</span><span class="sxs-lookup"><span data-stu-id="06506-176">Notice that `billTo` and `shipTo` fields are set to the same object instance.</span></span> <span data-ttu-id="06506-177">但是，產生的 XML 卻重複產生了資訊，而且看起來就像下列 XML 一樣。</span><span class="sxs-lookup"><span data-stu-id="06506-177">However, the generated XML duplicates the information duplicated, and looks similar to the following XML.</span></span>  
  
```xml  
<PurchaseOrder>  
  <billTo><street>123 Main St.</street></billTo>  
  <shipTo><street>123 Main St.</street></shipTo>  
</PurchaseOrder>  
```  
  
 <span data-ttu-id="06506-178">但是，這種方法具有下列特性，而這些特性有時候可能會造成反效果：</span><span class="sxs-lookup"><span data-stu-id="06506-178">However, this approach has the following characteristics, which may be undesirable:</span></span>  
  
- <span data-ttu-id="06506-179">效能。</span><span class="sxs-lookup"><span data-stu-id="06506-179">Performance.</span></span> <span data-ttu-id="06506-180">複寫資料沒有效率。</span><span class="sxs-lookup"><span data-stu-id="06506-180">Replicating data is inefficient.</span></span>  
  
- <span data-ttu-id="06506-181">循環參照。</span><span class="sxs-lookup"><span data-stu-id="06506-181">Circular references.</span></span> <span data-ttu-id="06506-182">如果物件參照到它們，就算是經由其他物件來參照，藉由複寫作業來序列化會導致無限的迴圈</span><span class="sxs-lookup"><span data-stu-id="06506-182">If objects refer to themselves, even through other objects, serializing by replication results in an infinite loop.</span></span> <span data-ttu-id="06506-183">(如果發生這種情況的話，序列化程式會擲回 <xref:System.Runtime.Serialization.SerializationException> )。</span><span class="sxs-lookup"><span data-stu-id="06506-183">(The serializer throws a <xref:System.Runtime.Serialization.SerializationException> if this happens.)</span></span>  
  
- <span data-ttu-id="06506-184">語意。</span><span class="sxs-lookup"><span data-stu-id="06506-184">Semantics.</span></span> <span data-ttu-id="06506-185">有時候兩個參照是針對同一個物件，而不是針對兩個一樣的物件，這點要特別注意。</span><span class="sxs-lookup"><span data-stu-id="06506-185">Sometimes it is important to preserve the fact that two references are to the same object, and not to two identical objects.</span></span>  
  
 <span data-ttu-id="06506-186">因此，某些 `DataContractSerializer` 建構函式多載包含有 `preserveObjectReferences` 參數 (預設為 `false`)。</span><span class="sxs-lookup"><span data-stu-id="06506-186">For these reasons, some `DataContractSerializer` constructor overloads have a `preserveObjectReferences` parameter (the default is `false`).</span></span> <span data-ttu-id="06506-187">當此參數設定為時 `true` ，就會使用僅供 WCF 瞭解的特殊方法編碼物件參考。</span><span class="sxs-lookup"><span data-stu-id="06506-187">When this parameter is set to `true`, a special method of encoding object references, which only WCF understands, is used.</span></span> <span data-ttu-id="06506-188">設定為 `true`時，XML 程式碼範例就會類似如下所示。</span><span class="sxs-lookup"><span data-stu-id="06506-188">When set to `true`, the XML code example now resembles the following.</span></span>  
  
```xml  
<PurchaseOrder ser:id="1">  
  <billTo ser:id="2"><street ser:id="3">123 Main St.</street></billTo>  
  <shipTo ser:ref="2"/>  
</PurchaseOrder>  
```  
  
 <span data-ttu-id="06506-189">「Ser」命名空間是指標准序列化命名空間 `http://schemas.microsoft.com/2003/10/Serialization/` 。</span><span class="sxs-lookup"><span data-stu-id="06506-189">The "ser" namespace refers to the standard serialization namespace, `http://schemas.microsoft.com/2003/10/Serialization/`.</span></span> <span data-ttu-id="06506-190">每個資料片段只會序列化一次，並賦予一個 ID 號碼，後續使用時會導致參照到已經序列化的資料。</span><span class="sxs-lookup"><span data-stu-id="06506-190">Each piece of data is serialized only once and given an ID number, and subsequent uses result in a reference to the already serialized data.</span></span>  
  
> [!IMPORTANT]
> <span data-ttu-id="06506-191">如果 "id" 及 "ref" 這兩個屬性都出現在資料合約 `XMLElement`中，那麼會接受 "ref" 屬性而忽略 "id" 屬性。</span><span class="sxs-lookup"><span data-stu-id="06506-191">If both "id" and "ref" attributes are present in the data contract `XMLElement`, then the "ref" attribute is honored and the "id" attribute is ignored.</span></span>  
  
 <span data-ttu-id="06506-192">了解此模式的限制是很重要的：</span><span class="sxs-lookup"><span data-stu-id="06506-192">It is important to understand the limitations of this mode:</span></span>  
  
- <span data-ttu-id="06506-193">`DataContractSerializer` 產生的 XML ( `preserveObjectReferences` 設定為 `true` ) 無法與其他任何技術互通，而且只能由另一個 `DataContractSerializer` 執行個體存取 ( `preserveObjectReferences` 同樣設定為 `true`)。</span><span class="sxs-lookup"><span data-stu-id="06506-193">The XML the `DataContractSerializer` produces with `preserveObjectReferences` set to `true` is not interoperable with any other technologies, and can be accessed only by another `DataContractSerializer` instance, also with `preserveObjectReferences` set to `true`.</span></span>  
  
- <span data-ttu-id="06506-194">此功能不支援中繼資料 (結構描述)。</span><span class="sxs-lookup"><span data-stu-id="06506-194">There is no metadata (schema) support for this feature.</span></span> <span data-ttu-id="06506-195">產生的結構描述只有在 `preserveObjectReferences` 設定為 `false`時，才會有效。</span><span class="sxs-lookup"><span data-stu-id="06506-195">The schema that is produced is valid only for the case when `preserveObjectReferences` is set to `false`.</span></span>  
  
- <span data-ttu-id="06506-196">這項功能會導致序列化與還原序列化處理序執行得較慢。</span><span class="sxs-lookup"><span data-stu-id="06506-196">This feature may cause the serialization and deserialization process to run slower.</span></span> <span data-ttu-id="06506-197">雖然不需要複製資料，還是需要透過此模式來執行額外的物件比較。</span><span class="sxs-lookup"><span data-stu-id="06506-197">Although data does not have to be replicated, extra object comparisons must be performed in this mode.</span></span>  
  
> [!CAUTION]
> <span data-ttu-id="06506-198">啟用 `preserveObjectReferences` 模式時，請將 `maxItemsInObjectGraph` 值設定為正確的配額，這點請您要特別注意。</span><span class="sxs-lookup"><span data-stu-id="06506-198">When the `preserveObjectReferences` mode is enabled, it is especially important to set the `maxItemsInObjectGraph` value to the correct quota.</span></span> <span data-ttu-id="06506-199">因為陣列在此模式中的處理方式不同，攻擊者很容易就能夠建構小型的惡意訊息，導致大量的記憶體取用只受到 `maxItemsInObjectGraph` 配額的限制。</span><span class="sxs-lookup"><span data-stu-id="06506-199">Due to the way arrays are handled in this mode, it is easy for an attacker to construct a small malicious message that results in large memory consumption limited only by the `maxItemsInObjectGraph` quota.</span></span>  
  
### <a name="specifying-a-data-contract-surrogate"></a><span data-ttu-id="06506-200">指定資料合約代理</span><span class="sxs-lookup"><span data-stu-id="06506-200">Specifying a Data Contract Surrogate</span></span>  
 <span data-ttu-id="06506-201">某些 `DataContractSerializer` 建構函式多載包含有 `dataContractSurrogate` 參數 (可能會設定為 `null`)。</span><span class="sxs-lookup"><span data-stu-id="06506-201">Some `DataContractSerializer` constructor overloads have a `dataContractSurrogate` parameter, which may be set to `null`.</span></span> <span data-ttu-id="06506-202">另一方面，您可以用它來指定「 *資料合約代理*」(Data Contract Surrogate)，這是一種可實作 <xref:System.Runtime.Serialization.IDataContractSurrogate> 介面的型別。</span><span class="sxs-lookup"><span data-stu-id="06506-202">Otherwise, you can use it to specify a *data contract surrogate*, which is a type that implements the <xref:System.Runtime.Serialization.IDataContractSurrogate> interface.</span></span> <span data-ttu-id="06506-203">您可以接著使用此介面來自訂序列化與還原序列化處理序。</span><span class="sxs-lookup"><span data-stu-id="06506-203">You can then use the interface to customize the serialization and deserialization process.</span></span> <span data-ttu-id="06506-204">如需詳細資訊，請參閱[資料合約代理](../extending/data-contract-surrogates.md)。</span><span class="sxs-lookup"><span data-stu-id="06506-204">For more information, see [Data Contract Surrogates](../extending/data-contract-surrogates.md).</span></span>  
  
## <a name="serialization"></a><span data-ttu-id="06506-205">序列化</span><span class="sxs-lookup"><span data-stu-id="06506-205">Serialization</span></span>  
 <span data-ttu-id="06506-206">下列資訊將套用至任何繼承自 <xref:System.Runtime.Serialization.XmlObjectSerializer>的類別，包括 <xref:System.Runtime.Serialization.DataContractSerializer> 和 <xref:System.Runtime.Serialization.NetDataContractSerializer> 類別。</span><span class="sxs-lookup"><span data-stu-id="06506-206">The following information applies to any class that inherits from the <xref:System.Runtime.Serialization.XmlObjectSerializer>, including the <xref:System.Runtime.Serialization.DataContractSerializer> and <xref:System.Runtime.Serialization.NetDataContractSerializer> classes.</span></span>  
  
### <a name="simple-serialization"></a><span data-ttu-id="06506-207">簡單序列化</span><span class="sxs-lookup"><span data-stu-id="06506-207">Simple Serialization</span></span>  
 <span data-ttu-id="06506-208">序列化物件的最基本方式，就是將它傳遞給 <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObject%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="06506-208">The most basic way to serialize an object is to pass it to the <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObject%2A> method.</span></span> <span data-ttu-id="06506-209">有三種多載，各自負責寫入至 <xref:System.IO.Stream>、 <xref:System.Xml.XmlWriter>，或是 <xref:System.Xml.XmlDictionaryWriter>。</span><span class="sxs-lookup"><span data-stu-id="06506-209">There are three overloads, one each for writing to a <xref:System.IO.Stream>, an <xref:System.Xml.XmlWriter>, or an <xref:System.Xml.XmlDictionaryWriter>.</span></span> <span data-ttu-id="06506-210">在使用 <xref:System.IO.Stream> 多載的情況下，將輸出 UTF-8 編碼格式的 XML。</span><span class="sxs-lookup"><span data-stu-id="06506-210">With the <xref:System.IO.Stream> overload, the output is XML in the UTF-8 encoding.</span></span> <span data-ttu-id="06506-211">在使用 <xref:System.Xml.XmlDictionaryWriter> 多載的情況下，序列化程式會最佳化二進位 XML 的輸出。</span><span class="sxs-lookup"><span data-stu-id="06506-211">With the <xref:System.Xml.XmlDictionaryWriter> overload, the serializer optimizes its output for binary XML.</span></span>  
  
 <span data-ttu-id="06506-212">使用方法時 <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObject%2A> ，序列化程式會使用包裝函式專案的預設名稱和命名空間，並連同內容一起寫出（請參閱先前的「指定預設的根名稱和命名空間」一節）。</span><span class="sxs-lookup"><span data-stu-id="06506-212">When using the <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObject%2A> method, the serializer uses the default name and namespace for the wrapper element and writes it out along with the contents (see the previous "Specifying the Default Root Name and Namespace" section).</span></span>  
  
 <span data-ttu-id="06506-213">下列範例示範使用 <xref:System.Xml.XmlDictionaryWriter>來寫入。</span><span class="sxs-lookup"><span data-stu-id="06506-213">The following example demonstrates writing with an <xref:System.Xml.XmlDictionaryWriter>.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#8](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#8)]
 [!code-vb[c_StandaloneDataContractSerializer#8](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#8)]  
  
 <span data-ttu-id="06506-214">這會產生如下所示的 XML。</span><span class="sxs-lookup"><span data-stu-id="06506-214">This produces XML similar to the following.</span></span>  
  
```xml  
<Person>  
  <Name>Jay Hamlin</Name>  
  <Address>123 Main St.</Address>  
</Person>  
```  
  
### <a name="step-by-step-serialization"></a><span data-ttu-id="06506-215">逐步序列化</span><span class="sxs-lookup"><span data-stu-id="06506-215">Step-By-Step Serialization</span></span>  
 <span data-ttu-id="06506-216">請使用 <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A>、 <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObjectContent%2A>，以及 <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> 方法來分別寫入結束項目、物件內容，並關閉包裝函式項目。</span><span class="sxs-lookup"><span data-stu-id="06506-216">Use the <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A>, <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObjectContent%2A>, and <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> methods to write the end element, write the object contents, and close the wrapper element, respectively.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="06506-217">這些方法不包含 <xref:System.IO.Stream> 多載。</span><span class="sxs-lookup"><span data-stu-id="06506-217">There are no <xref:System.IO.Stream> overloads of these methods.</span></span>  
  
 <span data-ttu-id="06506-218">這項逐步序列化含有兩個常見的用途。</span><span class="sxs-lookup"><span data-stu-id="06506-218">This step-by-step serialization has two common uses.</span></span> <span data-ttu-id="06506-219">其中一個就是在 `WriteStartObject` 和 `WriteObjectContent`之間插入屬性或註解之類的內容，如下列範例所示。</span><span class="sxs-lookup"><span data-stu-id="06506-219">One is to insert contents such as attributes or comments between `WriteStartObject` and `WriteObjectContent`,  as shown in the following example.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#9](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#9)]
 [!code-vb[c_StandaloneDataContractSerializer#9](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#9)]  
  
 <span data-ttu-id="06506-220">這會產生如下所示的 XML。</span><span class="sxs-lookup"><span data-stu-id="06506-220">This produces XML similar to the following.</span></span>  
  
```xml  
<Person serializedBy="myCode">  
  <Name>Jay Hamlin</Name>  
  <Address>123 Main St.</Address>  
</Person>  
```  
  
 <span data-ttu-id="06506-221">另一個常見用途就是避免使用整個 <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A> 和 <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> ，並寫入您自己的自訂包裝函式項目 (或甚至一起略過不寫入包裝函式)，如下列程式碼所示。</span><span class="sxs-lookup"><span data-stu-id="06506-221">Another common use is to avoid using <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A> and <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> entirely, and to write your own custom wrapper element (or even skip writing a wrapper altogether), as shown in the following code.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#10](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#10)]
 [!code-vb[c_StandaloneDataContractSerializer#10](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#10)]  
  
 <span data-ttu-id="06506-222">這會產生如下所示的 XML。</span><span class="sxs-lookup"><span data-stu-id="06506-222">This produces XML similar to the following.</span></span>  
  
```xml  
<MyCustomWrapper>  
  <Name>Jay Hamlin</Name>  
  <Address>123 Main St.</Address>  
</MyCustomWrapper>  
```  
  
> [!NOTE]
> <span data-ttu-id="06506-223">使用逐步序列化可能產生結構描述無效的 XML。</span><span class="sxs-lookup"><span data-stu-id="06506-223">Using step-by-step serialization may result in schema-invalid XML.</span></span>  
  
## <a name="deserialization"></a><span data-ttu-id="06506-224">還原序列化</span><span class="sxs-lookup"><span data-stu-id="06506-224">Deserialization</span></span>  
 <span data-ttu-id="06506-225">下列資訊將套用至任何繼承自 <xref:System.Runtime.Serialization.XmlObjectSerializer>的類別，包括 <xref:System.Runtime.Serialization.DataContractSerializer> 和 <xref:System.Runtime.Serialization.NetDataContractSerializer> 類別。</span><span class="sxs-lookup"><span data-stu-id="06506-225">The following information applies to any class that inherits from the <xref:System.Runtime.Serialization.XmlObjectSerializer>, including the <xref:System.Runtime.Serialization.DataContractSerializer> and <xref:System.Runtime.Serialization.NetDataContractSerializer> classes.</span></span>  
  
 <span data-ttu-id="06506-226">還原序列化物件的最基本方式，就是呼叫其中一個 <xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> 方法多載。</span><span class="sxs-lookup"><span data-stu-id="06506-226">The most basic way to deserialize an object is to call one of the <xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> method overloads.</span></span> <span data-ttu-id="06506-227">有三種多載，各自負責使用 <xref:System.Xml.XmlDictionaryReader>、 `XmlReader`，或是 `Stream`來讀取。</span><span class="sxs-lookup"><span data-stu-id="06506-227">There are three overloads, one each for reading with a <xref:System.Xml.XmlDictionaryReader>, an `XmlReader`, or a `Stream`.</span></span> <span data-ttu-id="06506-228">請注意， `Stream` 多載會建立未由任何配額保護的文字 <xref:System.Xml.XmlDictionaryReader> ，而且只能用來讀取受信任資料。</span><span class="sxs-lookup"><span data-stu-id="06506-228">Note that the `Stream` overload creates a textual <xref:System.Xml.XmlDictionaryReader> that is not protected by any quotas, and should be used only to read trusted data.</span></span>  
  
 <span data-ttu-id="06506-229">同時請注意， `ReadObject` 方法傳回的物件必須轉換成適當的型別。</span><span class="sxs-lookup"><span data-stu-id="06506-229">Also note that the object the `ReadObject` method returns must be cast to the appropriate type.</span></span>  
  
 <span data-ttu-id="06506-230">下列程式碼會建構 <xref:System.Runtime.Serialization.DataContractSerializer> 和 <xref:System.Xml.XmlDictionaryReader>的執行個體，然後還原序列化 `Person` 執行個體。</span><span class="sxs-lookup"><span data-stu-id="06506-230">The following code constructs an instance of the <xref:System.Runtime.Serialization.DataContractSerializer> and an <xref:System.Xml.XmlDictionaryReader>, then deserializes a `Person` instance.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#11](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#11)]
 [!code-vb[c_StandaloneDataContractSerializer#11](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#11)]  
  
 <span data-ttu-id="06506-231">在呼叫 <xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> 方法之前，請將 XML 讀取器置於包裝函式項目或是位於包裝函式項目之前的非內容節點上。</span><span class="sxs-lookup"><span data-stu-id="06506-231">Before calling the <xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> method, position the XML reader on the wrapper element or on a non-content node that precedes the wrapper element.</span></span> <span data-ttu-id="06506-232">您可以呼叫 <xref:System.Xml.XmlReader.Read%2A> 或其衍生的 <xref:System.Xml.XmlReader> 方法，然後測試 <xref:System.Xml.XmlReader.NodeType%2A>來達到這個目的，如下列程式碼所示。</span><span class="sxs-lookup"><span data-stu-id="06506-232">You can do this by calling the <xref:System.Xml.XmlReader.Read%2A> method of the <xref:System.Xml.XmlReader> or its derivation, and testing the <xref:System.Xml.XmlReader.NodeType%2A>, as shown in the following code.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#12](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#12)]
 [!code-vb[c_StandaloneDataContractSerializer#12](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#12)]  
  
 <span data-ttu-id="06506-233">請注意，在將讀取器交給 `ReadObject`之前，可以讀取此包裝函式項目的屬性。</span><span class="sxs-lookup"><span data-stu-id="06506-233">Note that you can read attributes on this wrapper element before handing the reader to `ReadObject`.</span></span>  
  
 <span data-ttu-id="06506-234">使用其中一個簡單的多載時，還原序列化 `ReadObject` 程式會在包裝函式專案上尋找預設名稱和命名空間（請參閱上一節「指定預設的根名稱和命名空間」），如果找到未知的專案，則會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="06506-234">When using one of the simple `ReadObject` overloads, the deserializer looks for the default name and namespace on the wrapper element (see the preceding section, "Specifying the Default Root Name and Namespace") and throws an exception if it finds an unknown element.</span></span> <span data-ttu-id="06506-235">在先前的範例中，預期會使用 `<Person>` 包裝函式項目。</span><span class="sxs-lookup"><span data-stu-id="06506-235">In the preceding example, the `<Person>` wrapper element is expected.</span></span> <span data-ttu-id="06506-236"><xref:System.Runtime.Serialization.XmlObjectSerializer.IsStartObject%2A> 方法會被呼叫，以驗證讀取器位於如預期命名的項目上。</span><span class="sxs-lookup"><span data-stu-id="06506-236">The <xref:System.Runtime.Serialization.XmlObjectSerializer.IsStartObject%2A> method is called to verify that the reader is positioned on an element that is named as expected.</span></span>  
  
 <span data-ttu-id="06506-237">有一種方式可以停用此包裝函式項目名稱檢查；某些 `ReadObject` 方法的多載會採用布林參數 `verifyObjectName`(預設會設定為 `true` )。</span><span class="sxs-lookup"><span data-stu-id="06506-237">There is a way to disable this wrapper element name check; some overloads of the `ReadObject` method take the Boolean parameter `verifyObjectName`, which is set to `true` by default.</span></span> <span data-ttu-id="06506-238">一旦設定為 `false`，就會忽略包裝函式項目的名稱與命名空間。</span><span class="sxs-lookup"><span data-stu-id="06506-238">When set to `false`, the name and namespace of the wrapper element is ignored.</span></span> <span data-ttu-id="06506-239">讀取以先前所述之逐步序列化機制撰寫的 XML 時，這種方式很有用。</span><span class="sxs-lookup"><span data-stu-id="06506-239">This is useful for reading XML that was written using the step-by-step serialization mechanism described previously.</span></span>  
  
## <a name="using-the-netdatacontractserializer"></a><span data-ttu-id="06506-240">使用 NetDataContractSerializer</span><span class="sxs-lookup"><span data-stu-id="06506-240">Using the NetDataContractSerializer</span></span>  
 <span data-ttu-id="06506-241">和之間的主要差異在於 `DataContractSerializer` <xref:System.Runtime.Serialization.NetDataContractSerializer> 會 `DataContractSerializer` 使用資料合約名稱，而 `NetDataContractSerializer` 輸出會在序列化的 XML 中完整 .NET Framework 元件和類型名稱。</span><span class="sxs-lookup"><span data-stu-id="06506-241">The primary difference between the `DataContractSerializer` and the <xref:System.Runtime.Serialization.NetDataContractSerializer> is that the `DataContractSerializer` uses data contract names, whereas the `NetDataContractSerializer` outputs full .NET Framework assembly and type names in the serialized XML.</span></span> <span data-ttu-id="06506-242">也就是說，序列化與還原序列化端點兩者必須共用完全相同的型別。</span><span class="sxs-lookup"><span data-stu-id="06506-242">This means that the exact same types must be shared between the serialization and deserialization endpoints.</span></span> <span data-ttu-id="06506-243">這表示 `NetDataContractSerializer` 並不需要已知型別機制，因為要還原序列化的完全相同型別一律呈現已知狀態。</span><span class="sxs-lookup"><span data-stu-id="06506-243">This means that the known types mechanism is not required with the `NetDataContractSerializer` because the exact types to be deserialized are always known.</span></span>  
  
 <span data-ttu-id="06506-244">但是，還是會發生一些問題：</span><span class="sxs-lookup"><span data-stu-id="06506-244">However, several problems can occur:</span></span>  
  
- <span data-ttu-id="06506-245">安全性。</span><span class="sxs-lookup"><span data-stu-id="06506-245">Security.</span></span> <span data-ttu-id="06506-246">在還原序列化的 XML 中找到的任何型別會被載入。</span><span class="sxs-lookup"><span data-stu-id="06506-246">Any type found in the XML being deserialized is loaded.</span></span> <span data-ttu-id="06506-247">攻擊者會利用這個漏洞來強制載入惡意型別。</span><span class="sxs-lookup"><span data-stu-id="06506-247">This can be exploited to force the loading of malicious types.</span></span> <span data-ttu-id="06506-248">只有在使用「 `NetDataContractSerializer` 序列化繫結器 *」(Serialization Binder) 時，才應該針對不受信任的資料使用* (透過 <xref:System.Runtime.Serialization.NetDataContractSerializer.Binder%2A> 屬性或建構函式參數)。</span><span class="sxs-lookup"><span data-stu-id="06506-248">Using the `NetDataContractSerializer` with untrusted data should be done only if a *Serialization Binder* is used (using the <xref:System.Runtime.Serialization.NetDataContractSerializer.Binder%2A> property or constructor parameter).</span></span> <span data-ttu-id="06506-249">繫結器只允許載入安全型別。</span><span class="sxs-lookup"><span data-stu-id="06506-249">The binder permits only safe types to be loaded.</span></span> <span data-ttu-id="06506-250">繫結器機制與 <xref:System.Runtime.Serialization> 命名空間用途中的型別相同。</span><span class="sxs-lookup"><span data-stu-id="06506-250">The Binder mechanism is identical to the one that types in the <xref:System.Runtime.Serialization> namespace use.</span></span>  
  
- <span data-ttu-id="06506-251">版本控制。</span><span class="sxs-lookup"><span data-stu-id="06506-251">Versioning.</span></span> <span data-ttu-id="06506-252">在 XML 中使用完整的型別與組件名稱會嚴格限制型別的版本設定。</span><span class="sxs-lookup"><span data-stu-id="06506-252">Using full type and assembly names in the XML severely restricts how types can be versioned.</span></span> <span data-ttu-id="06506-253">下列為無法變更的項目：型別名稱、命名空間、組件名稱以及組件版本。</span><span class="sxs-lookup"><span data-stu-id="06506-253">The following cannot be changed: type names, namespaces, assembly names, and assembly versions.</span></span> <span data-ttu-id="06506-254">將 <xref:System.Runtime.Serialization.NetDataContractSerializer.AssemblyFormat%2A> 屬性或建構函式設定為 <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle.Simple> (而不是 <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle.Full> 的預設值) 可允許組件版本變更，但不適用於泛型參數型別。</span><span class="sxs-lookup"><span data-stu-id="06506-254">Setting the <xref:System.Runtime.Serialization.NetDataContractSerializer.AssemblyFormat%2A> property or constructor parameter to <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle.Simple> instead of the default value of <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle.Full> allows for assembly version changes, but not for generic parameter types.</span></span>  
  
- <span data-ttu-id="06506-255">互通性。</span><span class="sxs-lookup"><span data-stu-id="06506-255">Interoperability.</span></span> <span data-ttu-id="06506-256">因為 .NET Framework 類型和元件名稱包含在 XML 中，所以 .NET Framework 以外的平臺無法存取產生的資料。</span><span class="sxs-lookup"><span data-stu-id="06506-256">Because .NET Framework type and assembly names are included in the XML, platforms other than the .NET Framework cannot access the resulting data.</span></span>  
  
- <span data-ttu-id="06506-257">效能。</span><span class="sxs-lookup"><span data-stu-id="06506-257">Performance.</span></span> <span data-ttu-id="06506-258">寫出型別和組件名稱會大幅增加最後 XML 的大小。</span><span class="sxs-lookup"><span data-stu-id="06506-258">Writing out the type and assembly names significantly increases the size of the resulting XML.</span></span>  
  
 <span data-ttu-id="06506-259">這項機制類似于 .NET Framework 遠端處理（具體而言是和）所使用的二進位或 SOAP 序列化 <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter> 。</span><span class="sxs-lookup"><span data-stu-id="06506-259">This mechanism is similar to binary or SOAP serialization used by .NET Framework remoting (specifically, the <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> and the <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter>).</span></span>  
  
 <span data-ttu-id="06506-260">使用 `NetDataContractSerializer` 類似於使用 `DataContractSerializer`，除了下列幾點差異以外：</span><span class="sxs-lookup"><span data-stu-id="06506-260">Using the `NetDataContractSerializer` is similar to using the `DataContractSerializer`, with the following differences:</span></span>  
  
- <span data-ttu-id="06506-261">建構函式不會要求您指定根型別。</span><span class="sxs-lookup"><span data-stu-id="06506-261">The constructors do not require you to specify a root type.</span></span> <span data-ttu-id="06506-262">您可以使用相同的 `NetDataContractSerializer`執行個體來序列化任何型別。</span><span class="sxs-lookup"><span data-stu-id="06506-262">You can serialize any type with the same instance of the `NetDataContractSerializer`.</span></span>  
  
- <span data-ttu-id="06506-263">建構函式不接收已知型別清單。</span><span class="sxs-lookup"><span data-stu-id="06506-263">The constructors do not accept a list of known types.</span></span> <span data-ttu-id="06506-264">如果型別名稱已經序列化為 XML，就不需要建構函式機制。</span><span class="sxs-lookup"><span data-stu-id="06506-264">The known types mechanism is unnecessary if type names are serialized into the XML.</span></span>  
  
- <span data-ttu-id="06506-265">建構函式不接受資料合約代理。</span><span class="sxs-lookup"><span data-stu-id="06506-265">The constructors do not accept a data contract surrogate.</span></span> <span data-ttu-id="06506-266">反之，它們接受名為 <xref:System.Runtime.Serialization.ISurrogateSelector> (對應至 `surrogateSelector` 屬性) 的 <xref:System.Runtime.Serialization.NetDataContractSerializer.SurrogateSelector%2A> 參數。</span><span class="sxs-lookup"><span data-stu-id="06506-266">Instead, they accept an <xref:System.Runtime.Serialization.ISurrogateSelector> parameter called `surrogateSelector` (which maps to the <xref:System.Runtime.Serialization.NetDataContractSerializer.SurrogateSelector%2A> property).</span></span> <span data-ttu-id="06506-267">這是一項傳統的代理機制。</span><span class="sxs-lookup"><span data-stu-id="06506-267">This is a legacy surrogate mechanism.</span></span>  
  
- <span data-ttu-id="06506-268">建構函式接受 `assemblyFormat` 中 (對應至 <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle> 屬性) 名為 <xref:System.Runtime.Serialization.NetDataContractSerializer.AssemblyFormat%2A> 的參數。</span><span class="sxs-lookup"><span data-stu-id="06506-268">The constructors accept a parameter called `assemblyFormat` of the <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle> that maps to the <xref:System.Runtime.Serialization.NetDataContractSerializer.AssemblyFormat%2A> property.</span></span> <span data-ttu-id="06506-269">如先前所述，它可用來加強序列化程式的版本控制功能。</span><span class="sxs-lookup"><span data-stu-id="06506-269">As discussed previously, this can be used to enhance the versioning capabilities of the serializer.</span></span> <span data-ttu-id="06506-270">這與二進位或 SOAP 序列化中的 <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle> 機制相同。</span><span class="sxs-lookup"><span data-stu-id="06506-270">This is identical to the <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle> mechanism in binary or SOAP serialization.</span></span>  
  
- <span data-ttu-id="06506-271">建構函式接受稱為 <xref:System.Runtime.Serialization.StreamingContext> (對應至 `context` 屬性) 的 <xref:System.Runtime.Serialization.NetDataContractSerializer.Context%2A> 參數。</span><span class="sxs-lookup"><span data-stu-id="06506-271">The constructors accept a <xref:System.Runtime.Serialization.StreamingContext> parameter called `context` that maps to the <xref:System.Runtime.Serialization.NetDataContractSerializer.Context%2A> property.</span></span> <span data-ttu-id="06506-272">您可以透過這項參數將資訊傳遞至正要序列化的型別中。</span><span class="sxs-lookup"><span data-stu-id="06506-272">You can use this to pass information into types being serialized.</span></span> <span data-ttu-id="06506-273">這項用法與其他 <xref:System.Runtime.Serialization.StreamingContext> 類別使用的 <xref:System.Runtime.Serialization> 機制用法相同。</span><span class="sxs-lookup"><span data-stu-id="06506-273">This usage is identical to that of the <xref:System.Runtime.Serialization.StreamingContext> mechanism used in other <xref:System.Runtime.Serialization> classes.</span></span>  
  
- <span data-ttu-id="06506-274"><xref:System.Runtime.Serialization.NetDataContractSerializer.Serialize%2A> 和 <xref:System.Runtime.Serialization.NetDataContractSerializer.Deserialize%2A> 方法都是 <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObject%2A> 和 <xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> 方法的別名。</span><span class="sxs-lookup"><span data-stu-id="06506-274">The <xref:System.Runtime.Serialization.NetDataContractSerializer.Serialize%2A> and <xref:System.Runtime.Serialization.NetDataContractSerializer.Deserialize%2A> methods are aliases for the <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObject%2A> and <xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> methods.</span></span> <span data-ttu-id="06506-275">這些都是為了在使用二進位或 SOAP 序列化時提供更一致的程式設計模型而存在的。</span><span class="sxs-lookup"><span data-stu-id="06506-275">These exist to provide a more consistent programming model with binary or SOAP serialization.</span></span>  
  
 <span data-ttu-id="06506-276">如需這些功能的詳細資訊，請參閱[二進位序列化](../../../standard/serialization/binary-serialization.md)。</span><span class="sxs-lookup"><span data-stu-id="06506-276">For more information about these features, see [Binary Serialization](../../../standard/serialization/binary-serialization.md).</span></span>  
  
 <span data-ttu-id="06506-277">`NetDataContractSerializer` 和 `DataContractSerializer` 使用的 XML 格式一般都不相容。</span><span class="sxs-lookup"><span data-stu-id="06506-277">The XML formats that the `NetDataContractSerializer` and the `DataContractSerializer` use are normally not compatible.</span></span> <span data-ttu-id="06506-278">亦即，不支援使用其中一個序列化程式來序列化，並以另一個序列化程式來還原序列化的情況。</span><span class="sxs-lookup"><span data-stu-id="06506-278">That is, attempting to serialize with one of these serializers and deserialize with the other is not a supported scenario.</span></span>  
  
 <span data-ttu-id="06506-279">另請注意，不 `NetDataContractSerializer` 會針對物件圖形中的每個節點輸出完整的 .NET Framework 型別和元件名稱。</span><span class="sxs-lookup"><span data-stu-id="06506-279">Also, note that the `NetDataContractSerializer` does not output the full .NET Framework type and assembly name for each node in the object graph.</span></span> <span data-ttu-id="06506-280">它只會針對不夠清楚的部分來輸出資訊。</span><span class="sxs-lookup"><span data-stu-id="06506-280">It outputs that information only where it is ambiguous.</span></span> <span data-ttu-id="06506-281">亦即，它會在根物件層級以及任何多型案例中輸出。</span><span class="sxs-lookup"><span data-stu-id="06506-281">That is, it outputs at the root object level and for any polymorphic cases.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="06506-282">請參閱</span><span class="sxs-lookup"><span data-stu-id="06506-282">See also</span></span>

- <xref:System.Runtime.Serialization.DataContractSerializer>
- <xref:System.Runtime.Serialization.NetDataContractSerializer>
- <xref:System.Runtime.Serialization.XmlObjectSerializer>
- [<span data-ttu-id="06506-283">二進位序列化</span><span class="sxs-lookup"><span data-stu-id="06506-283">Binary Serialization</span></span>](../../../standard/serialization/binary-serialization.md)
- [<span data-ttu-id="06506-284">資料合約序列化程式支援的型別</span><span class="sxs-lookup"><span data-stu-id="06506-284">Types Supported by the Data Contract Serializer</span></span>](types-supported-by-the-data-contract-serializer.md)
