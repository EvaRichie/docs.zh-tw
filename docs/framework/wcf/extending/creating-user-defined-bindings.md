---
title: 建立使用者定義繫結
ms.date: 03/30/2017
helpviewer_keywords:
- user-defined bindings [WCF]
ms.assetid: c4960675-d701-4bc9-b400-36a752fdd08b
ms.openlocfilehash: ba40bcfd8a9e9fea1a422ed124b9a966819bf184
ms.sourcegitcommit: bc293b14af795e0e999e3304dd40c0222cf2ffe4
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 11/26/2020
ms.locfileid: "96257850"
---
# <a name="creating-user-defined-bindings"></a><span data-ttu-id="c66d4-102">建立使用者定義繫結</span><span class="sxs-lookup"><span data-stu-id="c66d4-102">Creating User-Defined Bindings</span></span>

<span data-ttu-id="c66d4-103">您有幾種方式可以建立系統不提供的繫結：</span><span class="sxs-lookup"><span data-stu-id="c66d4-103">There are several ways to create bindings not provided by the system:</span></span>  
  
- <span data-ttu-id="c66d4-104">依據 <xref:System.ServiceModel.Channels.CustomBinding> 類別來建立自訂繫結，此類別是一個容器，可供您填入繫結項目。</span><span class="sxs-lookup"><span data-stu-id="c66d4-104">Create a custom binding, based on the <xref:System.ServiceModel.Channels.CustomBinding> class, which is a container that you fill with binding elements.</span></span> <span data-ttu-id="c66d4-105">接著自訂繫結會新增至服務端點。</span><span class="sxs-lookup"><span data-stu-id="c66d4-105">The custom binding is then added to a service endpoint.</span></span> <span data-ttu-id="c66d4-106">您可以程式設計方式，或是透過應用程式組態檔來建立自訂繫結。</span><span class="sxs-lookup"><span data-stu-id="c66d4-106">You can create the custom binding either programmatically or in an application configuration file.</span></span> <span data-ttu-id="c66d4-107">若要使用應用程式組態檔的繫結項目，繫結項目必須延伸 <xref:System.ServiceModel.Configuration.BindingElementExtensionElement>。</span><span class="sxs-lookup"><span data-stu-id="c66d4-107">To use a binding element from an application configuration file, the binding element must extend <xref:System.ServiceModel.Configuration.BindingElementExtensionElement>.</span></span> <span data-ttu-id="c66d4-108">如需自訂系結的詳細資訊，請參閱 [自訂](custom-bindings.md) 系結和 <xref:System.ServiceModel.Channels.CustomBinding> 。</span><span class="sxs-lookup"><span data-stu-id="c66d4-108">For more information about custom bindings, see [Custom Bindings](custom-bindings.md) and <xref:System.ServiceModel.Channels.CustomBinding>.</span></span>  
  
- <span data-ttu-id="c66d4-109">您可以建立衍生自標準繫結的類別。</span><span class="sxs-lookup"><span data-stu-id="c66d4-109">You can create a class that derives from a standard binding.</span></span> <span data-ttu-id="c66d4-110">例如，您可以從 <xref:System.ServiceModel.WSHttpBinding> 衍生類別，並覆寫 <xref:System.ServiceModel.Channels.CustomBinding.CreateBindingElements%2A> 方法來取得繫結項目，並插入自訂繫結項目或是建立特定的安全值。</span><span class="sxs-lookup"><span data-stu-id="c66d4-110">For example, you can derive a class from <xref:System.ServiceModel.WSHttpBinding> and override <xref:System.ServiceModel.Channels.CustomBinding.CreateBindingElements%2A> method to obtain the binding elements and insert a custom binding element or establish a particular value for security.</span></span>  
  
- <span data-ttu-id="c66d4-111">您可以建立新的 <xref:System.ServiceModel.Channels.Binding> 型別以完全掌控整個繫結實作。</span><span class="sxs-lookup"><span data-stu-id="c66d4-111">You can create a new <xref:System.ServiceModel.Channels.Binding> type to completely control the entire binding implementation.</span></span>  
  
## <a name="the-order-of-binding-elements"></a><span data-ttu-id="c66d4-112">繫結項目的順序</span><span class="sxs-lookup"><span data-stu-id="c66d4-112">The Order of Binding Elements</span></span>  

 <span data-ttu-id="c66d4-113">每個繫結項目都代表傳送或接收訊息時的一個處理步驟。</span><span class="sxs-lookup"><span data-stu-id="c66d4-113">Each binding element represents a processing step when sending or receiving messages.</span></span> <span data-ttu-id="c66d4-114">在執行階段，繫結項目會建立通道和接聽項，它們是建立傳出和傳入通道堆疊的必要項目。</span><span class="sxs-lookup"><span data-stu-id="c66d4-114">At runtime, binding elements create the channels and listeners necessary to build outgoing and incoming channel stacks.</span></span>  
  
 <span data-ttu-id="c66d4-115">繫結項目主要分為三種：通訊協定繫結項目、編碼繫結項目，和傳輸繫結項目。</span><span class="sxs-lookup"><span data-stu-id="c66d4-115">There are three main types of binding elements: Protocol Binding Elements, Encoding Binding Elements and Transport Binding Elements.</span></span>  
  
 <span data-ttu-id="c66d4-116">通訊協定繫結項目 – 這些項目代表會處理訊息的較高階處理步驟。</span><span class="sxs-lookup"><span data-stu-id="c66d4-116">Protocol Binding Elements – These elements represent higher-level processing steps that act on messages.</span></span> <span data-ttu-id="c66d4-117">由這些繫結項目所建立的通道與接聽項，可以新增、移除，或是修改訊息內容。</span><span class="sxs-lookup"><span data-stu-id="c66d4-117">Channels and listeners created by these binding elements can add, remove, or modify the message content.</span></span> <span data-ttu-id="c66d4-118">特定繫結可能包含任意數量的通訊協定繫結項目，而這些項目每個都繼承自 <xref:System.ServiceModel.Channels.BindingElement>。</span><span class="sxs-lookup"><span data-stu-id="c66d4-118">A given binding may have an arbitrary number of protocol binding elements, each inheriting from <xref:System.ServiceModel.Channels.BindingElement>.</span></span> <span data-ttu-id="c66d4-119">Windows Communication Foundation (WCF) 包含數個通訊協定繫結項目，包括 <xref:System.ServiceModel.Channels.ReliableSessionBindingElement> 和 <xref:System.ServiceModel.Channels.SymmetricSecurityBindingElement> 。</span><span class="sxs-lookup"><span data-stu-id="c66d4-119">Windows Communication Foundation (WCF) includes several protocol binding elements, including the <xref:System.ServiceModel.Channels.ReliableSessionBindingElement> and the <xref:System.ServiceModel.Channels.SymmetricSecurityBindingElement>.</span></span>  
  
 <span data-ttu-id="c66d4-120">編碼繫結程序項目 – 這些項目代表訊息與準備好在網路上進行傳輸的編碼之間的轉換。</span><span class="sxs-lookup"><span data-stu-id="c66d4-120">Encoding Binding Element – These elements represent transformations between a message and an encoding ready for transmission on the wire.</span></span> <span data-ttu-id="c66d4-121">一般 WCF 系結只會包含一個編碼繫結項目。</span><span class="sxs-lookup"><span data-stu-id="c66d4-121">Typical WCF bindings include exactly one encoding binding element.</span></span> <span data-ttu-id="c66d4-122">編碼繫結項目範例包含 <xref:System.ServiceModel.Channels.MtomMessageEncodingBindingElement>、<xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement>，和 <xref:System.ServiceModel.Channels.TextMessageEncodingBindingElement>。</span><span class="sxs-lookup"><span data-stu-id="c66d4-122">Examples of encoding binding elements include the <xref:System.ServiceModel.Channels.MtomMessageEncodingBindingElement>, the <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement>, and the <xref:System.ServiceModel.Channels.TextMessageEncodingBindingElement>.</span></span> <span data-ttu-id="c66d4-123">如果某個繫結未指定編碼繫結項目，則會使用預設編碼。</span><span class="sxs-lookup"><span data-stu-id="c66d4-123">If an encoding binding element is not specified for a binding, a default encoding is used.</span></span> <span data-ttu-id="c66d4-124">當傳輸為 HTTP 和二進位格式，預設為文字。</span><span class="sxs-lookup"><span data-stu-id="c66d4-124">The default is text when the transport is HTTP and binary otherwise.</span></span>  
  
 <span data-ttu-id="c66d4-125">傳輸繫結項目 – 這些項目代表傳輸通訊協定上編碼訊息的傳輸。</span><span class="sxs-lookup"><span data-stu-id="c66d4-125">Transport Binding Element – These elements represent the transmission of an encoding message on a transport protocol.</span></span> <span data-ttu-id="c66d4-126">一般的 WCF 系結只包含一個會繼承自的傳輸繫結項目 <xref:System.ServiceModel.Channels.TransportBindingElement> 。</span><span class="sxs-lookup"><span data-stu-id="c66d4-126">Typical WCF bindings include exactly one transport binding element, which inherits from <xref:System.ServiceModel.Channels.TransportBindingElement>.</span></span> <span data-ttu-id="c66d4-127">傳輸繫結項目範例包含 <xref:System.ServiceModel.Channels.TcpTransportBindingElement>、<xref:System.ServiceModel.Channels.HttpTransportBindingElement> 和 <xref:System.ServiceModel.Channels.NamedPipeTransportBindingElement>。</span><span class="sxs-lookup"><span data-stu-id="c66d4-127">Examples of transport binding elements include the <xref:System.ServiceModel.Channels.TcpTransportBindingElement>, the <xref:System.ServiceModel.Channels.HttpTransportBindingElement>, and the <xref:System.ServiceModel.Channels.NamedPipeTransportBindingElement>.</span></span>  
  
 <span data-ttu-id="c66d4-128">建立新繫結時，新增的繫結項目順序非常重要。</span><span class="sxs-lookup"><span data-stu-id="c66d4-128">When creating new bindings, the order of the added binding elements is important.</span></span> <span data-ttu-id="c66d4-129">請務必遵守下列順序加入繫結項目：</span><span class="sxs-lookup"><span data-stu-id="c66d4-129">Always add binding elements in the following order:</span></span>  
  
|<span data-ttu-id="c66d4-130">層</span><span class="sxs-lookup"><span data-stu-id="c66d4-130">Layer</span></span>|<span data-ttu-id="c66d4-131">選項。</span><span class="sxs-lookup"><span data-stu-id="c66d4-131">Options</span></span>|<span data-ttu-id="c66d4-132">必要</span><span class="sxs-lookup"><span data-stu-id="c66d4-132">Required</span></span>|  
|-----------|-------------|--------------|  
|<span data-ttu-id="c66d4-133">異動流程</span><span class="sxs-lookup"><span data-stu-id="c66d4-133">Transaction Flow</span></span>|<xref:System.ServiceModel.Channels.TransactionFlowBindingElement?displayProperty=nameWithType>|<span data-ttu-id="c66d4-134">否</span><span class="sxs-lookup"><span data-stu-id="c66d4-134">No</span></span>|  
|<span data-ttu-id="c66d4-135">可靠性</span><span class="sxs-lookup"><span data-stu-id="c66d4-135">Reliability</span></span>|<xref:System.ServiceModel.Channels.ReliableSessionBindingElement?displayProperty=nameWithType>|<span data-ttu-id="c66d4-136">否</span><span class="sxs-lookup"><span data-stu-id="c66d4-136">No</span></span>|  
|<span data-ttu-id="c66d4-137">安全性</span><span class="sxs-lookup"><span data-stu-id="c66d4-137">Security</span></span>|<xref:System.ServiceModel.Channels.SecurityBindingElement?displayProperty=nameWithType>|<span data-ttu-id="c66d4-138">No</span><span class="sxs-lookup"><span data-stu-id="c66d4-138">No</span></span>|  
|<span data-ttu-id="c66d4-139">複合雙工</span><span class="sxs-lookup"><span data-stu-id="c66d4-139">Composite Duplex</span></span>|<xref:System.ServiceModel.Channels.CompositeDuplexBindingElement?displayProperty=nameWithType>|<span data-ttu-id="c66d4-140">否</span><span class="sxs-lookup"><span data-stu-id="c66d4-140">No</span></span>|  
|<span data-ttu-id="c66d4-141">編碼</span><span class="sxs-lookup"><span data-stu-id="c66d4-141">Encoding</span></span>|<span data-ttu-id="c66d4-142">文字、二進位、MTOM、自訂</span><span class="sxs-lookup"><span data-stu-id="c66d4-142">Text, Binary, MTOM, Custom</span></span>|<span data-ttu-id="c66d4-143">是\*</span><span class="sxs-lookup"><span data-stu-id="c66d4-143">Yes\*</span></span>|  
|<span data-ttu-id="c66d4-144">傳輸</span><span class="sxs-lookup"><span data-stu-id="c66d4-144">Transport</span></span>|<span data-ttu-id="c66d4-145">TCP、具名管道、HTTP、HTTPS、MSMQ、自訂</span><span class="sxs-lookup"><span data-stu-id="c66d4-145">TCP, Named Pipes, HTTP, HTTPS, MSMQ, Custom</span></span>|<span data-ttu-id="c66d4-146">是</span><span class="sxs-lookup"><span data-stu-id="c66d4-146">Yes</span></span>|  
  
<span data-ttu-id="c66d4-147">\*因為每個系結都需要編碼方式，所以如果未指定編碼方式，WCF 就會為您新增預設編碼方式。</span><span class="sxs-lookup"><span data-stu-id="c66d4-147">\*Because an encoding is required for each binding, if an encoding is not specified, WCF adds a default encoding for you.</span></span> <span data-ttu-id="c66d4-148">預設為 Text/XML (適用於 HTTP 和 HTTPS 傳輸) 和 Binary (適用於其他傳輸)。</span><span class="sxs-lookup"><span data-stu-id="c66d4-148">The default is Text/XML for the HTTP and HTTPS transports, and Binary otherwise.</span></span>  
  
## <a name="creating-a-new-binding-element"></a><span data-ttu-id="c66d4-149">建立新的繫結項目</span><span class="sxs-lookup"><span data-stu-id="c66d4-149">Creating a new Binding Element</span></span>  

 <span data-ttu-id="c66d4-150">除了 WCF 所提供的衍生型別之外 <xref:System.ServiceModel.Channels.BindingElement> ，您還可以建立自己的繫結項目。</span><span class="sxs-lookup"><span data-stu-id="c66d4-150">In addition to the types derived from <xref:System.ServiceModel.Channels.BindingElement> that are provided by WCF, you can create your own binding elements.</span></span> <span data-ttu-id="c66d4-151">這樣一來，您就可以自訂繫結程序堆疊的建立方式和內含的元件，並使用堆疊中其他系統提供型別共同組成自己的 <xref:System.ServiceModel.Channels.BindingElement>。</span><span class="sxs-lookup"><span data-stu-id="c66d4-151">This lets you customize the way the stack of bindings is created and the components that go in it by creating your own <xref:System.ServiceModel.Channels.BindingElement> that can be composed with the other system-provided types in the stack.</span></span>  
  
 <span data-ttu-id="c66d4-152">例如，如果您實作了可將訊息記錄至資料庫的 `LoggingBindingElement`，則您必須將其放置到通道堆疊中的傳輸通道上層。</span><span class="sxs-lookup"><span data-stu-id="c66d4-152">For example, if you implement a `LoggingBindingElement` that provides the ability to log the message to a database, you must place it above a transport channel in the channel stack.</span></span> <span data-ttu-id="c66d4-153">在此情況中，應用程式會建立由 `LoggingBindingElement` 和 `TcpTransportBindingElement` 組成的自訂繫結，如下列範例所示。</span><span class="sxs-lookup"><span data-stu-id="c66d4-153">In this case, the application creates a custom binding that composed the `LoggingBindingElement` with `TcpTransportBindingElement`, as in the following example.</span></span>  
  
```csharp  
Binding customBinding = new CustomBinding(  
  new LoggingBindingElement(),
  new TcpTransportBindingElement()  
);  
```  
  
 <span data-ttu-id="c66d4-154">撰寫新的繫結項目的方式，需視其明確的功能而定。</span><span class="sxs-lookup"><span data-stu-id="c66d4-154">How you write your new binding element depends on its exact functionality.</span></span> <span data-ttu-id="c66d4-155">其中一個範例（ [Transport： UDP](../samples/transport-udp.md)）提供如何執行一種繫結項目的詳細描述。</span><span class="sxs-lookup"><span data-stu-id="c66d4-155">One of the samples, [Transport: UDP](../samples/transport-udp.md), provides a detailed description of how to implement one kind of binding element.</span></span>  
  
## <a name="creating-a-new-binding"></a><span data-ttu-id="c66d4-156">建立新繫結</span><span class="sxs-lookup"><span data-stu-id="c66d4-156">Creating a New Binding</span></span>  

 <span data-ttu-id="c66d4-157">您可以透過下列兩種方式運用使用者建立的繫結項目。</span><span class="sxs-lookup"><span data-stu-id="c66d4-157">A user-created binding element can be used in two ways.</span></span> <span data-ttu-id="c66d4-158">上一節說明了第一種方式，亦即透過自訂繫結。</span><span class="sxs-lookup"><span data-stu-id="c66d4-158">The previous section illustrates the first way: through a custom binding.</span></span> <span data-ttu-id="c66d4-159">自訂繫結允許使用者根據任意一組繫結項目來建立自己的繫結，包括使用者建立的繫結。</span><span class="sxs-lookup"><span data-stu-id="c66d4-159">A custom binding allows the user to create their own binding based on an arbitrary set of binding elements, including user-created ones.</span></span>  
  
 <span data-ttu-id="c66d4-160">如果您在一個以上的應用程式中使用繫結，請建立自己的繫結並延伸 <xref:System.ServiceModel.Channels.Binding>。</span><span class="sxs-lookup"><span data-stu-id="c66d4-160">If you use the binding in more than one application, create your own binding and extend the <xref:System.ServiceModel.Channels.Binding>.</span></span> <span data-ttu-id="c66d4-161">這樣一來，每次當您想要使用繫結時，都不用重新手動建立自訂繫結。</span><span class="sxs-lookup"><span data-stu-id="c66d4-161">This avoids manually creating a custom binding every time you want to use it.</span></span> <span data-ttu-id="c66d4-162">使用者定義的繫結可讓您定義繫結行為，並包含使用者定義的繫結項目。</span><span class="sxs-lookup"><span data-stu-id="c66d4-162">A user-defined binding allows you to define the binding’s behavior and include user-defined binding elements.</span></span> <span data-ttu-id="c66d4-163">而且它已 *預先封裝*：您不需要在每次使用時重建系結。</span><span class="sxs-lookup"><span data-stu-id="c66d4-163">And it is *pre-packaged*: you do not have to rebuild the binding every time you use it.</span></span>  
  
 <span data-ttu-id="c66d4-164">使用者定義的繫結必須至少實作 <xref:System.ServiceModel.Channels.Binding.CreateBindingElements%2A> 方法和 <xref:System.ServiceModel.Channels.Binding.Scheme%2A> 屬性。</span><span class="sxs-lookup"><span data-stu-id="c66d4-164">At a minimum, a user-defined binding must implement the <xref:System.ServiceModel.Channels.Binding.CreateBindingElements%2A> method and the <xref:System.ServiceModel.Channels.Binding.Scheme%2A> property.</span></span>  
  
 <span data-ttu-id="c66d4-165"><xref:System.ServiceModel.Channels.Binding.CreateBindingElements%2A> 方法會傳回新的 <xref:System.ServiceModel.Channels.BindingElementCollection>，其中包含繫結的繫結項目。</span><span class="sxs-lookup"><span data-stu-id="c66d4-165">The <xref:System.ServiceModel.Channels.Binding.CreateBindingElements%2A> method returns a new <xref:System.ServiceModel.Channels.BindingElementCollection> that contains the binding elements for the binding.</span></span> <span data-ttu-id="c66d4-166">經過排序的集合應該會先包含通訊協定繫結項目，而後包含編碼繫結項目，最後才是包含傳輸繫結項目。</span><span class="sxs-lookup"><span data-stu-id="c66d4-166">The collection is ordered, and should contain the protocol binding elements first, followed by the encoding binding element, followed by the transport binding element.</span></span> <span data-ttu-id="c66d4-167">使用 WCF 系統提供的繫結項目時，您必須遵循 [自訂](custom-bindings.md)系結中指定的繫結項目排序規則。</span><span class="sxs-lookup"><span data-stu-id="c66d4-167">When using the WCF system-provided binding elements, you must follow the binding element ordering rules specified in [Custom Bindings](custom-bindings.md).</span></span> <span data-ttu-id="c66d4-168">此集合一律不得參考使用者定義的繫結類別所參考的物件；如此一來，繫結作者必須在每次呼叫 `Clone()` 時，傳回 <xref:System.ServiceModel.Channels.BindingElementCollection> 的 <xref:System.ServiceModel.Channels.Binding.CreateBindingElements%2A>。</span><span class="sxs-lookup"><span data-stu-id="c66d4-168">This collection should never reference objects referenced within the user-defined binding class; consequently, binding authors must return a `Clone()` of the <xref:System.ServiceModel.Channels.BindingElementCollection> on each call to <xref:System.ServiceModel.Channels.Binding.CreateBindingElements%2A>.</span></span>  
  
 <span data-ttu-id="c66d4-169"><xref:System.ServiceModel.Channels.Binding.Scheme%2A> 屬性代表繫結上正在使用的傳輸通訊協定的 URI 配置。</span><span class="sxs-lookup"><span data-stu-id="c66d4-169">The <xref:System.ServiceModel.Channels.Binding.Scheme%2A> property represents the URI scheme for the transport protocol in use on the binding.</span></span> <span data-ttu-id="c66d4-170">例如， *WSHttpBinding* 和 *NetTcpBinding* 會從其各自的屬性傳回 "HTTP" 和 "net.tcp" <xref:System.ServiceModel.Channels.Binding.Scheme%2A> 。</span><span class="sxs-lookup"><span data-stu-id="c66d4-170">For example, the *WSHttpBinding* and the *NetTcpBinding* return "http" and "net.tcp" from their respective <xref:System.ServiceModel.Channels.Binding.Scheme%2A> properties.</span></span>  
  
 <span data-ttu-id="c66d4-171">如需使用者定義繫結之選擇性方法與屬性的完整清單，請參閱 <xref:System.ServiceModel.Channels.Binding>。</span><span class="sxs-lookup"><span data-stu-id="c66d4-171">For a complete list of optional methods and properties for user-defined bindings, see <xref:System.ServiceModel.Channels.Binding>.</span></span>  
  
### <a name="example"></a><span data-ttu-id="c66d4-172">範例</span><span class="sxs-lookup"><span data-stu-id="c66d4-172">Example</span></span>  

 <span data-ttu-id="c66d4-173">此範例會在衍生自 `SampleProfileUdpBinding` 的 <xref:System.ServiceModel.Channels.Binding> 中實作設定檔繫結。</span><span class="sxs-lookup"><span data-stu-id="c66d4-173">This example implements profile binding in `SampleProfileUdpBinding`, which derives from <xref:System.ServiceModel.Channels.Binding>.</span></span> <span data-ttu-id="c66d4-174">`SampleProfileUdpBinding`中最多包含四個繫結項目：一個使用者建立的， `UdpTransportBindingElement` 以及三個系統提供的： `TextMessageEncodingBindingElement` 、 `CompositeDuplexBindingElement` 和 `ReliableSessionBindingElement` 。</span><span class="sxs-lookup"><span data-stu-id="c66d4-174">The `SampleProfileUdpBinding` contains up to four binding elements within it: one user-created `UdpTransportBindingElement`; and three system-provided: `TextMessageEncodingBindingElement`, `CompositeDuplexBindingElement`, and `ReliableSessionBindingElement`.</span></span>  
  
```csharp
public override BindingElementCollection CreateBindingElements()  
{
    BindingElementCollection bindingElements = new BindingElementCollection();  
    if (ReliableSessionEnabled)  
    {  
        bindingElements.Add(session);  
        bindingElements.Add(compositeDuplex);  
    }  
    bindingElements.Add(encoding);  
    bindingElements.Add(transport);  
    return bindingElements.Clone();  
}  
```  
  
## <a name="security-restrictions-with-duplex-contracts"></a><span data-ttu-id="c66d4-175">雙工合約的安全性限制</span><span class="sxs-lookup"><span data-stu-id="c66d4-175">Security Restrictions with Duplex Contracts</span></span>  

 <span data-ttu-id="c66d4-176">並非所有繫結程序項目都能彼此相容。</span><span class="sxs-lookup"><span data-stu-id="c66d4-176">Not all binding elements are compatible with each other.</span></span> <span data-ttu-id="c66d4-177">具體來說，安全性繫結項目一旦與雙工合約併用，會有一些限制。</span><span class="sxs-lookup"><span data-stu-id="c66d4-177">In particular, there are some restrictions on security binding elements when used with duplex contracts.</span></span>  
  
### <a name="one-shot-security"></a><span data-ttu-id="c66d4-178">單次安全性</span><span class="sxs-lookup"><span data-stu-id="c66d4-178">One-Shot Security</span></span>  

 <span data-ttu-id="c66d4-179">您可以藉由將設定元素的屬性設定為，來執行「一次」安全性，其中所有必要的安全性認證都會以單一訊息傳送 `negotiateServiceCredential` \<message> `false` 。</span><span class="sxs-lookup"><span data-stu-id="c66d4-179">You can implement "one-shot" security, where all the necessary security credentials are sent in a single message, by setting the `negotiateServiceCredential` attribute of the \<message> configuration element to `false`.</span></span>  
  
 <span data-ttu-id="c66d4-180">單次驗證無法與雙工合約一起使用。</span><span class="sxs-lookup"><span data-stu-id="c66d4-180">One-shot authentication does not work with duplex contracts.</span></span>  
  
 <span data-ttu-id="c66d4-181">對於要求-回覆合約來說，只有當安全性繫結項目底下的繫結堆疊支援建立 <xref:System.ServiceModel.Channels.IRequestChannel> 或 <xref:System.ServiceModel.Channels.IRequestSessionChannel> 執行個體時，才能使用單次驗證。</span><span class="sxs-lookup"><span data-stu-id="c66d4-181">For Request-Reply contracts, one-shot authentication works only if the binding stack below the security binding element supports creating <xref:System.ServiceModel.Channels.IRequestChannel> or <xref:System.ServiceModel.Channels.IRequestSessionChannel> instances.</span></span>  
  
 <span data-ttu-id="c66d4-182">對於單向合約來說，如果安全性繫結項目底下的繫結堆疊支援建立 <xref:System.ServiceModel.Channels.IRequestChannel>、<xref:System.ServiceModel.Channels.IRequestSessionChannel>、<xref:System.ServiceModel.Channels.IOutputChannel> 或 <xref:System.ServiceModel.Channels.IOutputSessionChannel> 執行個體時，就能使用單次驗證。</span><span class="sxs-lookup"><span data-stu-id="c66d4-182">For one-way contracts, one-shot authentication works if the binding stack below the security binding element supports creating <xref:System.ServiceModel.Channels.IRequestChannel>, <xref:System.ServiceModel.Channels.IRequestSessionChannel>, <xref:System.ServiceModel.Channels.IOutputChannel> or <xref:System.ServiceModel.Channels.IOutputSessionChannel> instances.</span></span>  
  
### <a name="cookie-mode-security-context-tokens"></a><span data-ttu-id="c66d4-183">Cookie 模式的安全性內容權杖</span><span class="sxs-lookup"><span data-stu-id="c66d4-183">Cookie-mode Security Context Tokens</span></span>  

 <span data-ttu-id="c66d4-184">Cookie 模式的安全性內容權杖無法搭配雙工合約一起使用。</span><span class="sxs-lookup"><span data-stu-id="c66d4-184">Cookie mode security context tokens cannot be used with duplex contracts.</span></span>  
  
 <span data-ttu-id="c66d4-185">對於要求-回覆合約來說，只有當安全性繫結項目底下的繫結堆疊支援建立 <xref:System.ServiceModel.Channels.IRequestChannel> 或 <xref:System.ServiceModel.Channels.IRequestSessionChannel> 執行個體時，才能使用 Cookie 模型的安全性內容權杖。</span><span class="sxs-lookup"><span data-stu-id="c66d4-185">For Request-Reply contracts, cookie-mode security context tokens work only if the binding stack below the security binding element supports creating <xref:System.ServiceModel.Channels.IRequestChannel> or <xref:System.ServiceModel.Channels.IRequestSessionChannel> instances.</span></span>  
  
 <span data-ttu-id="c66d4-186">對於單向合約來說，如果安全性繫結項目底下的繫結堆疊支援建立 <xref:System.ServiceModel.Channels.IRequestChannel> 或 <xref:System.ServiceModel.Channels.IRequestSessionChannel> 執行個體時，就能使用 Cookie 模型的安全性內容權杖。</span><span class="sxs-lookup"><span data-stu-id="c66d4-186">For one-way contracts, cookie-mode security context tokens works if the binding stack below the security binding element supports creating <xref:System.ServiceModel.Channels.IRequestChannel> or <xref:System.ServiceModel.Channels.IRequestSessionChannel> instances.</span></span>  
  
### <a name="session-mode-security-context-tokens"></a><span data-ttu-id="c66d4-187">工作階段模式的安全性內容權杖</span><span class="sxs-lookup"><span data-stu-id="c66d4-187">Session-mode Security Context Tokens</span></span>  

 <span data-ttu-id="c66d4-188">如果安全性繫結項目底下的繫結堆疊支援建立 <xref:System.ServiceModel.Channels.IDuplexChannel> 或 <xref:System.ServiceModel.Channels.IDuplexSessionChannel> 執行個體，就能在雙工合約上使用工作階段模式 SCT。</span><span class="sxs-lookup"><span data-stu-id="c66d4-188">Session mode SCT works for duplex contracts if the binding stack below the security binding element supports creating <xref:System.ServiceModel.Channels.IDuplexChannel> or <xref:System.ServiceModel.Channels.IDuplexSessionChannel> instances.</span></span>  
  
 <span data-ttu-id="c66d4-189">如果安全性繫結項目底下的繫結堆疊支援建立 <xref:System.ServiceModel.Channels.IDuplexChannel>、<xref:System.ServiceModel.Channels.IDuplexSessionChannel>、<xref:System.ServiceModel.Channels.IRequestChannel> 或 <xref:System.ServiceModel.Channels.IRequestSessionChannel> 執行個體，就能在要求-回覆合約上使用工作階段模式 SCT。</span><span class="sxs-lookup"><span data-stu-id="c66d4-189">Session mode SCT works for Request-Reply contracts if the binding stack below the security binding element supports creating <xref:System.ServiceModel.Channels.IDuplexChannel>, <xref:System.ServiceModel.Channels.IDuplexSessionChannel>, <xref:System.ServiceModel.Channels.IRequestChannel> or <xref:System.ServiceModel.Channels.IRequestSessionChannel>, instances.</span></span>  
  
 <span data-ttu-id="c66d4-190">如果安全性繫結項目底下的繫結堆疊支援建立 <xref:System.ServiceModel.Channels.IDuplexChannel>、<xref:System.ServiceModel.Channels.IDuplexSessionChannel>、<xref:System.ServiceModel.Channels.IRequestChannel> 或 <xref:System.ServiceModel.Channels.IRequestSessionChannel> 執行個體，就能在單向合約上使用工作階段模式 SCT。</span><span class="sxs-lookup"><span data-stu-id="c66d4-190">Session mode SCT works for 1-way contracts if the binding stack below the security binding element supports creating <xref:System.ServiceModel.Channels.IDuplexChannel>, <xref:System.ServiceModel.Channels.IDuplexSessionChannel>, <xref:System.ServiceModel.Channels.IRequestChannel> or <xref:System.ServiceModel.Channels.IRequestSessionChannel> instances.</span></span>  
  
## <a name="deriving-from-a-standard-binding"></a><span data-ttu-id="c66d4-191">衍生自標準繫結</span><span class="sxs-lookup"><span data-stu-id="c66d4-191">Deriving from a Standard Binding</span></span>  

 <span data-ttu-id="c66d4-192">您可以不建立全新的繫結類別，而改為擴充其中一個現有的系統提供繫結。</span><span class="sxs-lookup"><span data-stu-id="c66d4-192">Instead of creating an entirely new binding class, it may be possible for you to extend one of the existing system-provided bindings.</span></span> <span data-ttu-id="c66d4-193">與先前的情況非常類似，這次您必須覆寫 <xref:System.ServiceModel.Channels.Binding.CreateBindingElements%2A> 屬性的 <xref:System.ServiceModel.Channels.Binding.Scheme%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="c66d4-193">Much like the preceding case, you must override the <xref:System.ServiceModel.Channels.Binding.CreateBindingElements%2A> method and the <xref:System.ServiceModel.Channels.Binding.Scheme%2A> property.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="c66d4-194">另請參閱</span><span class="sxs-lookup"><span data-stu-id="c66d4-194">See also</span></span>

- <xref:System.ServiceModel.Channels.Binding>
- [<span data-ttu-id="c66d4-195">自訂繫結</span><span class="sxs-lookup"><span data-stu-id="c66d4-195">Custom Bindings</span></span>](custom-bindings.md)
