---
title: 選擇訊息交換模式
ms.date: 03/30/2017
ms.assetid: 0f502ca1-6a8e-4607-ba15-59198c0e6146
ms.openlocfilehash: 22c720beaa8dc70d2916a5b1d38819ad3d333a0f
ms.sourcegitcommit: bc293b14af795e0e999e3304dd40c0222cf2ffe4
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 11/26/2020
ms.locfileid: "96275654"
---
# <a name="choosing-a-message-exchange-pattern"></a><span data-ttu-id="d3695-102">選擇訊息交換模式</span><span class="sxs-lookup"><span data-stu-id="d3695-102">Choosing a Message Exchange Pattern</span></span>

<span data-ttu-id="d3695-103">撰寫自訂傳輸的第一個步驟，是決定您要開發的通道需要 (或 Mep) 的 *訊息交換模式* 。</span><span class="sxs-lookup"><span data-stu-id="d3695-103">The first step in writing a custom transport is to decide which *message exchange patterns* (or MEPs) are required for the channel you are developing.</span></span> <span data-ttu-id="d3695-104">本主題會說明可用的選項，並討論各種需求。</span><span class="sxs-lookup"><span data-stu-id="d3695-104">This topic describes the options available and discusses the various requirements.</span></span> <span data-ttu-id="d3695-105">這是 [開發通道](developing-channels.md)中所述之通道開發工作清單中的第一個工作。</span><span class="sxs-lookup"><span data-stu-id="d3695-105">This is the first task in the channel development task list described in [Developing Channels](developing-channels.md).</span></span>  
  
## <a name="six-message-exchange-patterns"></a><span data-ttu-id="d3695-106">六種訊息交換模式</span><span class="sxs-lookup"><span data-stu-id="d3695-106">Six Message Exchange Patterns</span></span>  

 <span data-ttu-id="d3695-107">您可以從三個 MEP 中選擇：</span><span class="sxs-lookup"><span data-stu-id="d3695-107">There are three MEPs to choose from:</span></span>  
  
- <span data-ttu-id="d3695-108">資料包 (<xref:System.ServiceModel.Channels.IInputChannel> 和 <xref:System.ServiceModel.Channels.IOutputChannel>)</span><span class="sxs-lookup"><span data-stu-id="d3695-108">Datagram (<xref:System.ServiceModel.Channels.IInputChannel> and <xref:System.ServiceModel.Channels.IOutputChannel>)</span></span>  
  
     <span data-ttu-id="d3695-109">使用資料包 MEP 時，用戶端會使用火災傳送訊息， *並忘記* exchange。</span><span class="sxs-lookup"><span data-stu-id="d3695-109">When using a datagram MEP, a client sends a message using a *fire and forget* exchange.</span></span> <span data-ttu-id="d3695-110">射後不理交換是一種需要以超出範圍之外的方式確認傳遞成功的交換。</span><span class="sxs-lookup"><span data-stu-id="d3695-110">A fire and forget exchange is one that requires out-of-band confirmation of successful delivery.</span></span> <span data-ttu-id="d3695-111">訊息可能會在傳輸時遺失而永遠無法抵達服務。</span><span class="sxs-lookup"><span data-stu-id="d3695-111">The message might be lost in transit and never reach the service.</span></span> <span data-ttu-id="d3695-112">即使傳送作業在用戶端已成功完成，也無法保證遠端端點已接收到該訊息。</span><span class="sxs-lookup"><span data-stu-id="d3695-112">If the send operation completes successfully at the client end, it does not guarantee that the remote endpoint has received the message.</span></span> <span data-ttu-id="d3695-113">資料包是訊息的基本建置組塊，您可以在資料包的最上層建立自己的通訊協定，其中包括可靠的通訊協定和安全的通訊協定。</span><span class="sxs-lookup"><span data-stu-id="d3695-113">The datagram is a fundamental building block for messaging, as you can build your own protocols on top of it—including reliable protocols and secure protocols.</span></span> <span data-ttu-id="d3695-114">用戶端資料包通道會實作 <xref:System.ServiceModel.Channels.IOutputChannel> 介面，服務資料包通道則會實作 <xref:System.ServiceModel.Channels.IInputChannel> 介面。</span><span class="sxs-lookup"><span data-stu-id="d3695-114">Client datagram channels implement the <xref:System.ServiceModel.Channels.IOutputChannel> interface and service datagram channels implement the <xref:System.ServiceModel.Channels.IInputChannel> interface.</span></span>  
  
- <span data-ttu-id="d3695-115">要求-回應 (<xref:System.ServiceModel.Channels.IRequestChannel> 和 <xref:System.ServiceModel.Channels.IReplyChannel>)</span><span class="sxs-lookup"><span data-stu-id="d3695-115">Request-Response (<xref:System.ServiceModel.Channels.IRequestChannel> and <xref:System.ServiceModel.Channels.IReplyChannel>)</span></span>  
  
     <span data-ttu-id="d3695-116">在此 MEP 中，會傳送訊息，而且會接收回覆。</span><span class="sxs-lookup"><span data-stu-id="d3695-116">In this MEP, a message is sent, and a reply is received.</span></span> <span data-ttu-id="d3695-117">此模式是由要求-回應組合所構成。</span><span class="sxs-lookup"><span data-stu-id="d3695-117">The pattern consists of request-response pairs.</span></span> <span data-ttu-id="d3695-118">遠端程序呼叫 (Remote Procedure Call，RPC) 與瀏覽器 GET 要求就是要求-回應呼叫的例子。</span><span class="sxs-lookup"><span data-stu-id="d3695-118">Examples of request-response calls are remote procedure calls (RPC) and browser GET requests.</span></span> <span data-ttu-id="d3695-119">這個模式又稱為半雙工。</span><span class="sxs-lookup"><span data-stu-id="d3695-119">This pattern is also known as half-duplex.</span></span> <span data-ttu-id="d3695-120">在此 MEP 中，用戶端通道會實作 <xref:System.ServiceModel.Channels.IRequestChannel>，服務通道則會實作 <xref:System.ServiceModel.Channels.IReplyChannel>。</span><span class="sxs-lookup"><span data-stu-id="d3695-120">In this MEP, client channels implement <xref:System.ServiceModel.Channels.IRequestChannel> and service channels implement <xref:System.ServiceModel.Channels.IReplyChannel>.</span></span>  
  
- <span data-ttu-id="d3695-121">雙工 (<xref:System.ServiceModel.Channels.IDuplexChannel>)</span><span class="sxs-lookup"><span data-stu-id="d3695-121">Duplex (<xref:System.ServiceModel.Channels.IDuplexChannel>)</span></span>  
  
     <span data-ttu-id="d3695-122">雙工 MEP 會允許用戶端傳送任意數目的訊息，並以任何順序接收這些訊息。</span><span class="sxs-lookup"><span data-stu-id="d3695-122">The duplex MEP allows an arbitrary number of messages to be sent by a client and received in any order.</span></span> <span data-ttu-id="d3695-123">雙工 MEP 就像是電話交談，談話中說出的每個字都是一則訊息。</span><span class="sxs-lookup"><span data-stu-id="d3695-123">The duplex MEP is like a phone conversation, where each word being spoken is a message.</span></span> <span data-ttu-id="d3695-124">由於兩端都可以透過此種 MEP 來傳送和接收訊息，所以由用戶端和服務通道所實作的介面會是 <xref:System.ServiceModel.Channels.IDuplexChannel>。</span><span class="sxs-lookup"><span data-stu-id="d3695-124">Because both sides can send and receive in this MEP, the interface implemented by the client and service channels is <xref:System.ServiceModel.Channels.IDuplexChannel>.</span></span>  
  
 <span data-ttu-id="d3695-125">![選擇訊息交換模式](./media/wcfc-basicthreemepsc.gif "wcfc_BasicThreeMEPsc")</span><span class="sxs-lookup"><span data-stu-id="d3695-125">![Choosing a message exchange pattern](./media/wcfc-basicthreemepsc.gif "wcfc_BasicThreeMEPsc")</span></span>  
<span data-ttu-id="d3695-126">三個基本訊息交換模式。</span><span class="sxs-lookup"><span data-stu-id="d3695-126">The three basic message exchange patterns.</span></span> <span data-ttu-id="d3695-127">從上到下：資料包、要求-回應及雙工。</span><span class="sxs-lookup"><span data-stu-id="d3695-127">Top to bottom: datagram, request-response, and duplex.</span></span>  
  
 <span data-ttu-id="d3695-128">這些 Mep 中的每一個也都可以支援 *會話*。</span><span class="sxs-lookup"><span data-stu-id="d3695-128">Each of these MEPs can also support *sessions*.</span></span> <span data-ttu-id="d3695-129">工作階段 (以及 <xref:System.ServiceModel.Channels.ISessionChannel%601?displayProperty=nameWithType> 型別的 <xref:System.ServiceModel.Channels.ISession?displayProperty=nameWithType> 實作) 會使在通道中傳送與接收的所有訊息相互關聯。</span><span class="sxs-lookup"><span data-stu-id="d3695-129">A session (and implementation of <xref:System.ServiceModel.Channels.ISessionChannel%601?displayProperty=nameWithType> of type <xref:System.ServiceModel.Channels.ISession?displayProperty=nameWithType>) correlates all messages sent and received on a channel.</span></span> <span data-ttu-id="d3695-130">要求-回應模式是獨立的兩個訊息工作階段，因為要求與回覆是相互關聯的。</span><span class="sxs-lookup"><span data-stu-id="d3695-130">The request-response pattern is a stand-alone two-message session, as the request and reply are correlated.</span></span> <span data-ttu-id="d3695-131">相較之下，支援工作階段的要求-回應模式，則表示在通道上的所有要求/回應組合都與彼此相互關聯。</span><span class="sxs-lookup"><span data-stu-id="d3695-131">In contrast, the request-response pattern that supports sessions implies that all request/response pairs on that channel are correlated with each other.</span></span> <span data-ttu-id="d3695-132">這樣您就可以從總計六個的 MEP 中進行選擇：</span><span class="sxs-lookup"><span data-stu-id="d3695-132">This gives you a total of six MEPs to choose from:</span></span>  
  
- <span data-ttu-id="d3695-133">資料包</span><span class="sxs-lookup"><span data-stu-id="d3695-133">Datagram</span></span>  
  
- <span data-ttu-id="d3695-134">要求-回應</span><span class="sxs-lookup"><span data-stu-id="d3695-134">Request-response</span></span>  
  
- <span data-ttu-id="d3695-135">雙工</span><span class="sxs-lookup"><span data-stu-id="d3695-135">Duplex</span></span>  
  
- <span data-ttu-id="d3695-136">搭配工作階段的資料包</span><span class="sxs-lookup"><span data-stu-id="d3695-136">Datagram with sessions</span></span>  
  
- <span data-ttu-id="d3695-137">搭配工作階段的要求-回應</span><span class="sxs-lookup"><span data-stu-id="d3695-137">Request-response with sessions</span></span>  
  
- <span data-ttu-id="d3695-138">搭配工作階段的雙工</span><span class="sxs-lookup"><span data-stu-id="d3695-138">Duplex with sessions</span></span>  
  
> [!NOTE]
> <span data-ttu-id="d3695-139">若是 UDP 傳輸，唯一支援的 MEP 是資料包，因為 UDP 原本就是射後不理 (Fire and Forget) 通訊協定。</span><span class="sxs-lookup"><span data-stu-id="d3695-139">For the UDP transport, the only MEP that is supported is datagram, because UDP is inherently a fire and forget protocol.</span></span>  
  
## <a name="sessions-and-sessionful-channels"></a><span data-ttu-id="d3695-140">工作階段和工作階段通道</span><span class="sxs-lookup"><span data-stu-id="d3695-140">Sessions and Sessionful Channels</span></span>  

 <span data-ttu-id="d3695-141">在網路世界中有連線導向的通訊協定 (例如 TCP)，以及無連線的通訊協定 (例如 UDP)。</span><span class="sxs-lookup"><span data-stu-id="d3695-141">In the networking world, there are connection-oriented protocols (for example, TCP) and connection-less protocols (for example, UDP).</span></span> <span data-ttu-id="d3695-142">WCF 使用詞彙會話來表示類似連接的邏輯抽象概念。</span><span class="sxs-lookup"><span data-stu-id="d3695-142">WCF uses the term session to mean a connection-like logical abstraction.</span></span> <span data-ttu-id="d3695-143">工作階段 WCF 通訊協定類似連線導向的網路通訊協定，而無工作階段的 WCF 通訊協定類似無連線的網路通訊協定。</span><span class="sxs-lookup"><span data-stu-id="d3695-143">Sessionful WCF protocols are similar to connection-oriented network protocols and sessionless WCF protocols are similar to connection-less network protocols.</span></span>  
  
 <span data-ttu-id="d3695-144">在通道物件模型中，每個邏輯工作階段都會顯示為工作階段通道的執行個體。</span><span class="sxs-lookup"><span data-stu-id="d3695-144">In the channel object model, each logical session manifests as an instance of a sessionful channel.</span></span> <span data-ttu-id="d3695-145">因此，由用戶端建立並由服務接受的每個新工作階段，都會對應到每一端上的新工作階段通道。</span><span class="sxs-lookup"><span data-stu-id="d3695-145">Therefore every new session created by the client, and accepted on the service, corresponds to a new sessionful channel on each side.</span></span> <span data-ttu-id="d3695-146">下圖的最上方顯示出無工作階段通道的結構，而下方則顯示工作階段通道的結構。</span><span class="sxs-lookup"><span data-stu-id="d3695-146">The following diagram shows, on the top, the structure of sessionless channels, and on the bottom, the structure of sessionful channels.</span></span>  
  
 <span data-ttu-id="d3695-147">![選擇訊息交換模式](./media/wcfc-sessionandsessionlesschannelsc.gif "wcfc_SessionAndSessionlessChannelsc")</span><span class="sxs-lookup"><span data-stu-id="d3695-147">![Choosing a message exchange pattern](./media/wcfc-sessionandsessionlesschannelsc.gif "wcfc_SessionAndSessionlessChannelsc")</span></span>  
  
 <span data-ttu-id="d3695-148">用戶端會建立新的工作階段通道並傳送訊息。</span><span class="sxs-lookup"><span data-stu-id="d3695-148">A client creates a new sessionful channel and sends a message.</span></span> <span data-ttu-id="d3695-149">在服務端上，通道接聽程式會接收此訊息，並偵測到該訊息屬於新的工作階段，因此它會建立新的工作階段通道，並會將其交給應用程式 (以回應在通道接聽程式上呼叫 AcceptChannel 的應用程式)。</span><span class="sxs-lookup"><span data-stu-id="d3695-149">On the service side, the channel listener receives this message and detects that it belongs to a new session so it creates a new sessionful channel and hands it to the application (in response to the application calling AcceptChannel on the channel listener).</span></span> <span data-ttu-id="d3695-150">接著，應用程式便會接收此訊息，以及所有透過該相同工作階段通道傳送的後續訊息。</span><span class="sxs-lookup"><span data-stu-id="d3695-150">The application then receives this message and all subsequent messages sent in the same session through the same sessionful channel.</span></span>  
  
 <span data-ttu-id="d3695-151">另一個用戶端 (或是相同的用戶端) 會建立新的工作階段並傳送訊息。</span><span class="sxs-lookup"><span data-stu-id="d3695-151">Another client (or the same client) creates a new sessionful and sends a message.</span></span> <span data-ttu-id="d3695-152">通道接聽程式會偵測出此訊息是存在於新的工作階段並建立新的工作階段通道，並重複這個程序。</span><span class="sxs-lookup"><span data-stu-id="d3695-152">The channel listener detects this message is in a new session and creates a new sessionful channel and the process repeats.</span></span>  
  
 <span data-ttu-id="d3695-153">若是沒有工作階段，通道與工作階段之間就不會有任何相互關聯。</span><span class="sxs-lookup"><span data-stu-id="d3695-153">Without sessions, there is no correlation between channels and sessions.</span></span> <span data-ttu-id="d3695-154">因此，通道接聽程式只會建立一個所有已接收訊息都要透過其中以傳遞到應用程式的通道。</span><span class="sxs-lookup"><span data-stu-id="d3695-154">Therefore a channel listener creates only one channel through which all received messages are delivered to the application.</span></span> <span data-ttu-id="d3695-155">由於沒有用來維持訊息順序的工作階段，所以，這時並不進行訊息排序。</span><span class="sxs-lookup"><span data-stu-id="d3695-155">There is also no message ordering because there is no session within which to maintain message order.</span></span> <span data-ttu-id="d3695-156">上圖的最上方說明了無工作階段的訊息交換。</span><span class="sxs-lookup"><span data-stu-id="d3695-156">The top portion of the preceding graphic illustrates a sessionless message exchange.</span></span>  
  
## <a name="starting-and-terminating-sessions"></a><span data-ttu-id="d3695-157">啟動和終止工作階段</span><span class="sxs-lookup"><span data-stu-id="d3695-157">Starting and Terminating Sessions</span></span>  

 <span data-ttu-id="d3695-158">只要建立新的工作階段通道，即可在用戶端上啟動工作階段。</span><span class="sxs-lookup"><span data-stu-id="d3695-158">Sessions are started on the client by simply creating a new sessionful channel.</span></span> <span data-ttu-id="d3695-159">當服務接收到在新工作階段中傳送的訊息時，這些工作階段便會在服務上啟動。</span><span class="sxs-lookup"><span data-stu-id="d3695-159">They are started on the service when the service receives a message that was sent in a new session.</span></span> <span data-ttu-id="d3695-160">同樣的，關閉或中止工作階段通道便會使工作階段終止。</span><span class="sxs-lookup"><span data-stu-id="d3695-160">Likewise, sessions are terminated by closing or aborting a sessionful channel.</span></span>  
  
 <span data-ttu-id="d3695-161">這種情況的例外是 <xref:System.ServiceModel.Channels.IDuplexSessionChannel>，這種通道會用來在雙工的工作階段通訊模式中同時傳送和接收訊息。</span><span class="sxs-lookup"><span data-stu-id="d3695-161">The exception to this is <xref:System.ServiceModel.Channels.IDuplexSessionChannel> which is used for both sending and receiving messages in a duplex, sessionful communication pattern.</span></span> <span data-ttu-id="d3695-162">有時會出現某一端希望停止傳送訊息但繼續接收訊息的情況，這時若是使用 <xref:System.ServiceModel.Channels.IDuplexSessionChannel> 便可提供一個機制，讓您能夠關閉輸出工作階段以表示您將不會傳送任何訊息，但是又使輸入工作階段維持開啟來讓您繼續接收訊息。</span><span class="sxs-lookup"><span data-stu-id="d3695-162">It is possible that one side will want to stop sending messages but continue to receive messages therefore when using <xref:System.ServiceModel.Channels.IDuplexSessionChannel> there is a mechanism that lets you close the output session indicating you will not send any more messages but keep the input session opened allowing you to continue to receive messages.</span></span>  
  
 <span data-ttu-id="d3695-163">一般而言，工作階段是在傳出端上被關閉，而不是在傳入端上。</span><span class="sxs-lookup"><span data-stu-id="d3695-163">In general, sessions are closed on the outgoing side and not on the incoming side.</span></span> <span data-ttu-id="d3695-164">也就是說，工作階段輸出通道可以被關閉，並進而正常地終止工作階段。</span><span class="sxs-lookup"><span data-stu-id="d3695-164">That is, sessionful output channels can be closed, thereby cleanly terminating the session.</span></span> <span data-ttu-id="d3695-165">關閉工作階段輸出通道，會造成對應的工作階段輸入通道將 null 傳回給在 <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A?displayProperty=nameWithType> 上呼叫 <xref:System.ServiceModel.Channels.IDuplexSessionChannel> 的應用程式。</span><span class="sxs-lookup"><span data-stu-id="d3695-165">Closing a sessionful output channel causes the corresponding sessionful input channel to return null to the application calling <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A?displayProperty=nameWithType> on the <xref:System.ServiceModel.Channels.IDuplexSessionChannel>.</span></span>  
  
 <span data-ttu-id="d3695-166">不過，除非 <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A?displayProperty=nameWithType> 上的 <xref:System.ServiceModel.Channels.IDuplexSessionChannel> 傳回 null 以表示工作階段已關閉，否則，應該不要關閉工作階段輸入通道。</span><span class="sxs-lookup"><span data-stu-id="d3695-166">However sessionful input channels should not be closed unless <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A?displayProperty=nameWithType> on the <xref:System.ServiceModel.Channels.IDuplexSessionChannel> returns null, indicating that the session is already closed.</span></span> <span data-ttu-id="d3695-167">如果 <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A?displayProperty=nameWithType> 上的 <xref:System.ServiceModel.Channels.IDuplexSessionChannel> 沒有傳回 null，這時關閉工作階段輸入通道時可能會擲回例外狀況，因為該通道可能會在關閉時收到未預期的訊息。</span><span class="sxs-lookup"><span data-stu-id="d3695-167">If <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A?displayProperty=nameWithType> on the <xref:System.ServiceModel.Channels.IDuplexSessionChannel> has not returned null, closing a sessionful input channel may throw an exception because it may receive unexpected messages while closing.</span></span> <span data-ttu-id="d3695-168">如果接收端希望在傳送端終止工作階段之前先行終止，它就應該在輸入通道上呼叫 <xref:System.ServiceModel.ICommunicationObject.Abort%2A>，如此就會立即終止該工作階段。</span><span class="sxs-lookup"><span data-stu-id="d3695-168">If a receiver wishes to terminate a session before the sender does, it should call <xref:System.ServiceModel.ICommunicationObject.Abort%2A> on the input channel, which abruptly terminates the session.</span></span>  
  
## <a name="writing-sessionful-channels"></a><span data-ttu-id="d3695-169">撰寫工作階段通道</span><span class="sxs-lookup"><span data-stu-id="d3695-169">Writing Sessionful Channels</span></span>  

 <span data-ttu-id="d3695-170">身為工作階段通道作者，您的通道必須進行一些動作才能提供工作階段。</span><span class="sxs-lookup"><span data-stu-id="d3695-170">As a sessionful channel author, there are a few things your channel must do to provide sessions.</span></span> <span data-ttu-id="d3695-171">在傳送端上，您的通道必須執行下列動作：</span><span class="sxs-lookup"><span data-stu-id="d3695-171">On the send side, your channel needs to:</span></span>  
  
- <span data-ttu-id="d3695-172">對於每個新通道，建立新的工作階段，並使這個工作階段與屬於唯一字串的新工作階段識別碼產生關聯。</span><span class="sxs-lookup"><span data-stu-id="d3695-172">For each new channel, create a new session and associate it with a new session id which is a unique string.</span></span> <span data-ttu-id="d3695-173">或是從堆疊中低於您的工作階段通道中，取得新的工作階段。</span><span class="sxs-lookup"><span data-stu-id="d3695-173">Or obtain a new session from the sessionful channel below you in the stack.</span></span>  
  
- <span data-ttu-id="d3695-174">對於使用這個通道傳送的每則訊息，如果工作階段是由您的通道建立 (而非從低於您的通道層中取得此工作階段)，您就需要使訊息與此工作階段產生關聯。</span><span class="sxs-lookup"><span data-stu-id="d3695-174">For each message sent using this channel, if your channel created the session (as opposed to obtaining it from the layer below you), you need to associate the message with the session.</span></span> <span data-ttu-id="d3695-175">若是通訊協定通道，通常是新增 SOAP 標頭來做到這點。</span><span class="sxs-lookup"><span data-stu-id="d3695-175">For protocol channels, this is typically done by adding a SOAP header.</span></span> <span data-ttu-id="d3695-176">若是傳輸通道，通常是建立新傳輸連線、或是將工作階段資訊新增到框架處理通訊協定來做到這點。</span><span class="sxs-lookup"><span data-stu-id="d3695-176">For transport channels, this is typically done by creating a new transport connection or adding session information to the framing protocol.</span></span>  
  
- <span data-ttu-id="d3695-177">對於使用這個通道傳送的每則訊息，您必須提供上述的傳遞保證。</span><span class="sxs-lookup"><span data-stu-id="d3695-177">For each message sent using this channel, you need to provide the delivery guarantees mentioned above.</span></span> <span data-ttu-id="d3695-178">如果您是依賴在您之下的通道來提供工作階段，該通道也將會提供傳遞保證。</span><span class="sxs-lookup"><span data-stu-id="d3695-178">If you are relying on the channel below you to provide the session, that channel will also provide the delivery guarantees.</span></span> <span data-ttu-id="d3695-179">如果您是自己提供工作階段，您就必須實作這些保證以做為通訊協定的一部分。</span><span class="sxs-lookup"><span data-stu-id="d3695-179">If you’re providing the session yourself, you need to implement those guarantees as part of your protocol.</span></span> <span data-ttu-id="d3695-180">一般而言，如果您要撰寫假設兩端都有 WCF 的通訊協定通道，您可能會需要 TCP 傳輸或可信賴傳訊通道，並依賴其中一種來提供工作階段。</span><span class="sxs-lookup"><span data-stu-id="d3695-180">In general, if you are writing a protocol channel that assumes WCF on both sides you may require the TCP transport or the Reliable Messaging channel and rely on either one to provide a session.</span></span>  
  
- <span data-ttu-id="d3695-181">當某一端在您的通道上呼叫 <xref:System.ServiceModel.ICommunicationObject.Close%2A?displayProperty=nameWithType> 時，執行必要的工作來關閉使用指定或預設逾時的工作階段。</span><span class="sxs-lookup"><span data-stu-id="d3695-181">When <xref:System.ServiceModel.ICommunicationObject.Close%2A?displayProperty=nameWithType> is called on your channel, perform the necessary work to close the session using either the specified timeout or the default one.</span></span> <span data-ttu-id="d3695-182">這點就像在您以下的通道呼叫 <xref:System.ServiceModel.ICommunicationObject.Close%2A> (如果只從其中取得工作階段)、傳送特殊的 SOAP 訊號，或是關閉傳輸連線一樣簡單。</span><span class="sxs-lookup"><span data-stu-id="d3695-182">This can be as simple as calling <xref:System.ServiceModel.ICommunicationObject.Close%2A> on the channel below you (if you just obtained the session from it) or sending a special SOAP message or closing a transport connection.</span></span>  
  
- <span data-ttu-id="d3695-183">當某一端在您的通道上呼叫 <xref:System.ServiceModel.ICommunicationObject.Abort%2A> 時，立即終止工作階段而不執行 I/O。</span><span class="sxs-lookup"><span data-stu-id="d3695-183">When <xref:System.ServiceModel.ICommunicationObject.Abort%2A> is called on your channel, terminate the session abruptly without performing I/O.</span></span> <span data-ttu-id="d3695-184">這可能表示不進行任何動作，或是牽涉到中止網路連線或其他一些資源。</span><span class="sxs-lookup"><span data-stu-id="d3695-184">This may mean doing nothing or may involve aborting a network connection or some other resource.</span></span>  
  
 <span data-ttu-id="d3695-185">在接收端上，您的通道必須執行下列動作：</span><span class="sxs-lookup"><span data-stu-id="d3695-185">On the receive side, your channel needs to:</span></span>  
  
- <span data-ttu-id="d3695-186">對於每則傳入訊息，通道接聽程式都必須偵測其所屬於的工作階段。</span><span class="sxs-lookup"><span data-stu-id="d3695-186">For each incoming message, the channel listener must detect the session it belongs to.</span></span> <span data-ttu-id="d3695-187">如果這是工作階段中的第一則訊息，通道接聽程式就必須建立新的通道，並從對 <xref:System.ServiceModel.Channels.IChannelListener%601.AcceptChannel%2A?displayProperty=nameWithType> 的呼叫將其傳回。</span><span class="sxs-lookup"><span data-stu-id="d3695-187">If this is the first message in the session, the channel listener must create a new channel and return it from the call to <xref:System.ServiceModel.Channels.IChannelListener%601.AcceptChannel%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d3695-188">否則，通道接聽程式就必須找到對應至該工作階段的現有通道，並透過該通道傳遞訊息。</span><span class="sxs-lookup"><span data-stu-id="d3695-188">Otherwise the channel listener must find the existing channel that corresponds to the session and deliver the message through that channel.</span></span>  
  
- <span data-ttu-id="d3695-189">如果您的通道會提供工作階段 (以及必要的傳遞保證)，接收端就可能需要執行一些動作，像是重新排列訊息或傳送認可。</span><span class="sxs-lookup"><span data-stu-id="d3695-189">If your channel is providing the session (along with the required delivery guarantees) the receive side may be required to perform some actions such as re-order messages or send acknowledgements.</span></span>  
  
- <span data-ttu-id="d3695-190">當某一端在您的通道上呼叫 <xref:System.ServiceModel.ICommunicationObject.Close%2A> 時，執行必要的工作來關閉使用指定或預設逾時的工作階段。</span><span class="sxs-lookup"><span data-stu-id="d3695-190">When <xref:System.ServiceModel.ICommunicationObject.Close%2A> is called on your channel, perform the necessary work to close the session either the specified timeout or the default one.</span></span> <span data-ttu-id="d3695-191">如果通道在等候關閉逾時到期的期間收到訊息，這時可能會造成例外狀況。</span><span class="sxs-lookup"><span data-stu-id="d3695-191">This could result in exceptions if the channel receives a message while waiting for the close timeout to expire.</span></span> <span data-ttu-id="d3695-192">這是因為通道在收到訊息時將是處於 Closing 狀態，所以可能會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="d3695-192">That’s because the channel will be in the Closing state when it receives a message so it would throw.</span></span>  
  
- <span data-ttu-id="d3695-193">當某一端在您的通道上呼叫 <xref:System.ServiceModel.ICommunicationObject.Abort%2A> 時，立即終止工作階段而不執行 I/O。</span><span class="sxs-lookup"><span data-stu-id="d3695-193">When <xref:System.ServiceModel.ICommunicationObject.Abort%2A> is called on your channel, terminate the session abruptly without performing I/O.</span></span> <span data-ttu-id="d3695-194">同樣地，這可能表示不進行任何動作，或是牽涉到中止網路連線或其他一些資源。</span><span class="sxs-lookup"><span data-stu-id="d3695-194">Again, this may mean doing nothing or may involve aborting a network connection or some other resource.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="d3695-195">另請參閱</span><span class="sxs-lookup"><span data-stu-id="d3695-195">See also</span></span>

- [<span data-ttu-id="d3695-196">通道模型概觀</span><span class="sxs-lookup"><span data-stu-id="d3695-196">Channel Model Overview</span></span>](channel-model-overview.md)
