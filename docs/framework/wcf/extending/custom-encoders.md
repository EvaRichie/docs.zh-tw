---
title: 自訂編碼器
ms.date: 03/30/2017
ms.assetid: fa0e1d7f-af36-4bf4-aac9-cd4eab95bc4f
ms.openlocfilehash: c2ad0c947afd293d0923faa3e9d914b6911ce941
ms.sourcegitcommit: bc293b14af795e0e999e3304dd40c0222cf2ffe4
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 11/26/2020
ms.locfileid: "96254775"
---
# <a name="custom-encoders"></a><span data-ttu-id="47cc5-102">自訂編碼器</span><span class="sxs-lookup"><span data-stu-id="47cc5-102">Custom Encoders</span></span>

<span data-ttu-id="47cc5-103">本主題討論如何建立自訂編碼器。</span><span class="sxs-lookup"><span data-stu-id="47cc5-103">This topic discusses how to create custom encoders.</span></span>  
  
 <span data-ttu-id="47cc5-104">在 Windows Communication Foundation 的 WCF)  (中，您 *可以使用系結來指定* 如何在端點之間的網路之間傳輸資料。</span><span class="sxs-lookup"><span data-stu-id="47cc5-104">In Windows Communication Foundation (WCF), you use a *binding* to specify how to transfer data across a network between endpoints.</span></span> <span data-ttu-id="47cc5-105">系結是由 *綁定* 項的序列所組成。</span><span class="sxs-lookup"><span data-stu-id="47cc5-105">A binding is made up of a sequence of *binding elements*.</span></span> <span data-ttu-id="47cc5-106">系結包含選擇性通訊協定繫結項目，例如安全性、必要的 *訊息編碼器* 繫結項目，以及必要的傳輸繫結項目。</span><span class="sxs-lookup"><span data-stu-id="47cc5-106">A binding includes optional protocol binding elements such as security, a required *Message Encoder* binding element, and a required transport binding element.</span></span> <span data-ttu-id="47cc5-107">訊息編碼器是由訊息編碼繫結項目表示。</span><span class="sxs-lookup"><span data-stu-id="47cc5-107">A message encoder is represented by a message encoding binding element.</span></span> <span data-ttu-id="47cc5-108">WCF 中包含三個訊息編碼器：二進位、訊息傳輸優化機制 (MTOM) 和文字。</span><span class="sxs-lookup"><span data-stu-id="47cc5-108">Three message encoders are included in WCF: Binary, Message Transmission Optimization Mechanism (MTOM), and Text.</span></span>  
  
 <span data-ttu-id="47cc5-109">訊息編碼繫結項目會序列化傳出的 <xref:System.ServiceModel.Channels.Message> 並將它傳遞至傳輸，或者從傳輸接收序列化形式的訊息，如果有通訊協定層，就將訊息傳遞給它，如果不存在，則傳遞給應用程式。</span><span class="sxs-lookup"><span data-stu-id="47cc5-109">A message encoding binding element serializes an outgoing <xref:System.ServiceModel.Channels.Message> and passes it to the transport, or receives the serialized form of a message from the transport and passes it to the protocol layer if present, or to the application, if not present.</span></span>  
  
 <span data-ttu-id="47cc5-110">訊息編碼器會進行 <xref:System.ServiceModel.Channels.Message> 執行個體與網路傳輸表示之間的相互轉換。</span><span class="sxs-lookup"><span data-stu-id="47cc5-110">Message encoders transform <xref:System.ServiceModel.Channels.Message> instances to and from a wire representation.</span></span> <span data-ttu-id="47cc5-111">雖然一般描述編碼器在通道堆疊中的位置是在傳輸層之上，但卻是在傳輸層之內。</span><span class="sxs-lookup"><span data-stu-id="47cc5-111">Although encoders are described as sitting above the transport layer in the channel stack, they reside inside the transport layer.</span></span> <span data-ttu-id="47cc5-112">傳輸 (例如，HTTP) 會根據傳輸標準的需求將訊息格式化。</span><span class="sxs-lookup"><span data-stu-id="47cc5-112">Transports (for example HTTP) format the message according to the requirements of the transport standard.</span></span> <span data-ttu-id="47cc5-113">編碼器 (例如，文字 XML) 則只是對訊息進行編碼。</span><span class="sxs-lookup"><span data-stu-id="47cc5-113">Encoders (for example Text Xml) just encode the message.</span></span>  
  
 <span data-ttu-id="47cc5-114">當連接到已經存在的用戶端或伺服器時，可能由不得您選擇使用特定的訊息編碼。</span><span class="sxs-lookup"><span data-stu-id="47cc5-114">When connecting to a preexisting client or server, you may not have a choice about using a particular message encoding.</span></span> <span data-ttu-id="47cc5-115">不過，您可以透過多個端點來存取 WCF 服務，而每個端點都有不同的訊息編碼器。</span><span class="sxs-lookup"><span data-stu-id="47cc5-115">However, WCF services can be made accessible through multiple endpoints, each with a different message encoder.</span></span> <span data-ttu-id="47cc5-116">當單一編碼器的輸送量無法涵蓋服務的整個使用群時，請考慮透過多個端點公開您的服務。</span><span class="sxs-lookup"><span data-stu-id="47cc5-116">When a single encoder does not cover the entire audience for your service, consider exposing your service over multiple endpoints.</span></span> <span data-ttu-id="47cc5-117">然後，用戶端應用程式便可以選擇最適用的端點。</span><span class="sxs-lookup"><span data-stu-id="47cc5-117">Client applications can then choose the endpoint that is best for them.</span></span> <span data-ttu-id="47cc5-118">使用多個端點可讓您將各種不同訊息編碼器的優點與其他繫結程序項目相結合。</span><span class="sxs-lookup"><span data-stu-id="47cc5-118">Using multiple endpoints allows you to combine the advantages of different message encoders with other binding elements.</span></span>  
  
## <a name="system-provided-encoders"></a><span data-ttu-id="47cc5-119">系統提供的編碼器</span><span class="sxs-lookup"><span data-stu-id="47cc5-119">System-Provided Encoders</span></span>  

 <span data-ttu-id="47cc5-120">WCF 提供數個系統提供的系結，其設計目的是要涵蓋最常見的應用程式案例。</span><span class="sxs-lookup"><span data-stu-id="47cc5-120">WCF provides several system-provided bindings that are designed to cover the most common application scenarios.</span></span> <span data-ttu-id="47cc5-121">這些繫結程序中的每一個都結合了傳輸、訊息編碼器和其他選項 (例如，安全性)。</span><span class="sxs-lookup"><span data-stu-id="47cc5-121">Each of these bindings combine a transport, message encoder, and other options (security, for example).</span></span> <span data-ttu-id="47cc5-122">本主題說明如何擴充 WCF 中 `Text` 包含的、 `Binary` 和 `MTOM` 訊息編碼器，或建立您自己的自訂編碼器。</span><span class="sxs-lookup"><span data-stu-id="47cc5-122">This topic describes how to extend the `Text`, `Binary`, and `MTOM` message encoders that are included in WCF, or create your own custom encoder.</span></span> <span data-ttu-id="47cc5-123">文字訊息編碼器同時支援純 XML 編碼及 SOAP 編碼。</span><span class="sxs-lookup"><span data-stu-id="47cc5-123">The text message encoder supports both a plain XML encoding as well as SOAP encodings.</span></span> <span data-ttu-id="47cc5-124">文字訊息編碼器的純 XML 編碼模式稱為 POX ("Plain Old XML") 編碼器，與文字為主的 SOAP 編碼有所區別。</span><span class="sxs-lookup"><span data-stu-id="47cc5-124">The plain XML encoding mode of the text message encoder is called the POX ("Plain Old XML") encoder to distinguish it from the text-based SOAP encoding.</span></span>  
  
 <span data-ttu-id="47cc5-125">如需系統提供之系結所提供之繫結項目組合的詳細資訊，請參閱 [選擇傳輸](../feature-details/choosing-a-transport.md)的對應章節。</span><span class="sxs-lookup"><span data-stu-id="47cc5-125">For more information about the combinations of binding elements provided by the system-provided bindings, see the corresponding section in [Choosing a Transport](../feature-details/choosing-a-transport.md).</span></span>  
  
## <a name="how-to-work-with-system-provided-encoders"></a><span data-ttu-id="47cc5-126">如何使用系統提供的編碼器</span><span class="sxs-lookup"><span data-stu-id="47cc5-126">How to Work with System-Provided Encoders</span></span>  

 <span data-ttu-id="47cc5-127">您可以使用衍生自 <xref:System.ServiceModel.Channels.MessageEncodingBindingElement> 的類別，將編碼方式加入至繫結。</span><span class="sxs-lookup"><span data-stu-id="47cc5-127">An encoding is added to a binding using a class derived from <xref:System.ServiceModel.Channels.MessageEncodingBindingElement>.</span></span>  
  
 <span data-ttu-id="47cc5-128">WCF 提供下列衍生自類別的繫結項目類型 <xref:System.ServiceModel.Channels.MessageEncodingBindingElement> ，可提供文字、二進位和訊息傳輸優化機制 (MTOM) 編碼：</span><span class="sxs-lookup"><span data-stu-id="47cc5-128">WCF provides the following types of binding elements derived from the <xref:System.ServiceModel.Channels.MessageEncodingBindingElement> class that can provide for text, binary and Message Transmission Optimization Mechanism (MTOM) encoding:</span></span>  
  
- <span data-ttu-id="47cc5-129"><xref:System.ServiceModel.Channels.TextMessageEncodingBindingElement>：互通性最佳、但效率最差的 XML 訊息編碼器。</span><span class="sxs-lookup"><span data-stu-id="47cc5-129"><xref:System.ServiceModel.Channels.TextMessageEncodingBindingElement>: The most interoperable, but the least efficient encoder for XML messages.</span></span> <span data-ttu-id="47cc5-130">Web 服務或 Web 服務用戶端通常可以瞭解文字 XML。</span><span class="sxs-lookup"><span data-stu-id="47cc5-130">A Web service or Web service client can generally understand textual XML.</span></span> <span data-ttu-id="47cc5-131">不過，將大型二進位資料區塊當做文字來傳輸是沒有效率的。</span><span class="sxs-lookup"><span data-stu-id="47cc5-131">However, transmitting large blocks of binary data as text is not efficient.</span></span>  
  
- <span data-ttu-id="47cc5-132"><xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement>：表示繫結項目，這個繫結項目會指定用於二進位 XML 訊息的字元編碼和訊息版本處理。</span><span class="sxs-lookup"><span data-stu-id="47cc5-132"><xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement>: Represents the binding element that specifies the character encoding and message versioning used for binary-based XML messages.</span></span> <span data-ttu-id="47cc5-133">這是最有效率的編碼選項，但互通性最低，因為它只有 WCF 端點支援。</span><span class="sxs-lookup"><span data-stu-id="47cc5-133">This is most efficient of the encoding options, but the least interoperable, because it is only supported by WCF endpoints.</span></span>  
  
- <span data-ttu-id="47cc5-134"><xref:System.ServiceModel.Channels.MtomMessageEncodingBindingElement>：表示繫結項目，這個繫結項目會為使用訊息傳輸最佳化機制 (MTOM) 編碼的訊息指定字元編碼和訊息版本處理。</span><span class="sxs-lookup"><span data-stu-id="47cc5-134"><xref:System.ServiceModel.Channels.MtomMessageEncodingBindingElement>: Represents the binding element that specifies the character encoding and message versioning used for a message using a Message Transmission Optimization Mechanism (MTOM) encoding.</span></span> <span data-ttu-id="47cc5-135">MTOM 是在 WCF 訊息中傳輸二進位資料的有效技術。</span><span class="sxs-lookup"><span data-stu-id="47cc5-135">MTOM is an efficient technology for transmitting binary data in WCF messages.</span></span> <span data-ttu-id="47cc5-136">MTOM 編碼器會嘗試在效率和互通性之間保持平衡。</span><span class="sxs-lookup"><span data-stu-id="47cc5-136">The MTOM encoder attempts to balance between efficiency and interoperability.</span></span> <span data-ttu-id="47cc5-137">MTOM 編碼方式會以文字格式傳輸大部分的 XML，但是在傳輸大型區塊的二進位資料時，會依照原狀來傳送 (不轉換成文字)，好讓這些資料最佳化。</span><span class="sxs-lookup"><span data-stu-id="47cc5-137">The MTOM encoding transmits most XML in textual form, but optimizes large blocks of binary data by transmitting them as-is, without conversion to text.</span></span>  
  
 <span data-ttu-id="47cc5-138">繫結項目會建立二進位、MTOM 或文字的 <xref:System.ServiceModel.Channels.MessageEncoderFactory>。</span><span class="sxs-lookup"><span data-stu-id="47cc5-138">The binding element creates a binary, MTOM, or text <xref:System.ServiceModel.Channels.MessageEncoderFactory>.</span></span> <span data-ttu-id="47cc5-139">處理站會建立二進位、MTOM 或文字的 <xref:System.ServiceModel.Channels.MessageEncoderFactory> 執行個體。</span><span class="sxs-lookup"><span data-stu-id="47cc5-139">The factory creates a binary, MTOM, or text <xref:System.ServiceModel.Channels.MessageEncoderFactory> instance.</span></span> <span data-ttu-id="47cc5-140">一般而言，只會有一個執行個體。</span><span class="sxs-lookup"><span data-stu-id="47cc5-140">Typically, there is only a single instance.</span></span> <span data-ttu-id="47cc5-141">不過，如果是使用工作階段，就可以提供不同的編碼器給每個工作階段。</span><span class="sxs-lookup"><span data-stu-id="47cc5-141">However if sessions are used, a different encoder may be provided to each session.</span></span> <span data-ttu-id="47cc5-142">二進位編碼器會利用這種方式來協調動態字典 (請參閱＜XML 基礎結構＞)。</span><span class="sxs-lookup"><span data-stu-id="47cc5-142">The Binary encoder makes use of this to coordinate dynamic dictionaries (see XML Infrastructure).</span></span>  
  
 <span data-ttu-id="47cc5-143"><xref:System.ServiceModel.Channels.MessageEncoder.ReadMessage%2A> 和 <xref:System.ServiceModel.Channels.MessageEncoder.WriteMessage%2A> 方法是編碼器的核心。</span><span class="sxs-lookup"><span data-stu-id="47cc5-143">The <xref:System.ServiceModel.Channels.MessageEncoder.ReadMessage%2A> and <xref:System.ServiceModel.Channels.MessageEncoder.WriteMessage%2A> methods are the core of the encoders.</span></span> <span data-ttu-id="47cc5-144">這些方法會提供從資料流或 <xref:System.Byte> 陣列讀取訊息的功能。</span><span class="sxs-lookup"><span data-stu-id="47cc5-144">The methods provide for reading a message from a stream or from a <xref:System.Byte> array.</span></span> <span data-ttu-id="47cc5-145">當傳輸在緩衝模式中運作時，會使用位元組陣列。</span><span class="sxs-lookup"><span data-stu-id="47cc5-145">Byte arrays are used when the transport is operating in buffered mode.</span></span> <span data-ttu-id="47cc5-146">訊息一定會寫入資料流。</span><span class="sxs-lookup"><span data-stu-id="47cc5-146">Messages are always written to streams.</span></span> <span data-ttu-id="47cc5-147">如果傳輸必須緩衝訊息，就會提供執行緩衝處理的資料流。</span><span class="sxs-lookup"><span data-stu-id="47cc5-147">If the transport must buffer the message, it provides a stream that does the buffering.</span></span>  
  
 <span data-ttu-id="47cc5-148">其他成員則會使用支援內容、媒體類型和 <xref:System.ServiceModel.Channels.MessageEncoder.MessageVersion%2A>。</span><span class="sxs-lookup"><span data-stu-id="47cc5-148">The rest of the members work with support content, media types, and <xref:System.ServiceModel.Channels.MessageEncoder.MessageVersion%2A>.</span></span> <span data-ttu-id="47cc5-149">傳輸會呼叫這些編碼器方法來測試是否可以藉此解碼傳入的訊息，或者判斷傳出的訊息是否對此編碼器為有效。</span><span class="sxs-lookup"><span data-stu-id="47cc5-149">The transport calls these encoder methods to test whether the incoming message can be decoded by it, or to determine if the outgoing message is valid for this encoder.</span></span>  
  
 <span data-ttu-id="47cc5-150">這三個編碼器實作中的每一個都會新增與特定編碼有關的屬性，而且是完全可設定的。</span><span class="sxs-lookup"><span data-stu-id="47cc5-150">Each of the three encoder implementations adds properties that are relevant to the specific encodings and is fully configurable.</span></span> <span data-ttu-id="47cc5-151">這些編碼器也會公開具有安全預設值的讀取器配額。</span><span class="sxs-lookup"><span data-stu-id="47cc5-151">The encoders also expose reader quotas that have secure defaults.</span></span> <span data-ttu-id="47cc5-152">如需配額的詳細討論，請參閱＜XML 基礎結構＞。</span><span class="sxs-lookup"><span data-stu-id="47cc5-152">See XML Infrastructure for a discussion of the quotas.</span></span>  
  
## <a name="features-of-system-provided-encoders"></a><span data-ttu-id="47cc5-153">系統提供之編碼器的功能</span><span class="sxs-lookup"><span data-stu-id="47cc5-153">Features of System-Provided Encoders</span></span>  

 <span data-ttu-id="47cc5-154">系統提供的編碼器具有許多功能。</span><span class="sxs-lookup"><span data-stu-id="47cc5-154">There are a number of features provided by the system-provided encoders.</span></span>  
  
### <a name="pooling"></a><span data-ttu-id="47cc5-155">Pooling</span><span class="sxs-lookup"><span data-stu-id="47cc5-155">Pooling</span></span>  

 <span data-ttu-id="47cc5-156">每個編碼器實作都會盡可能嘗試集中共用。</span><span class="sxs-lookup"><span data-stu-id="47cc5-156">Each of the encoder implementations tries to pool as much as possible.</span></span> <span data-ttu-id="47cc5-157">減少配置是改善 Managed 程式碼效能的主要方法。</span><span class="sxs-lookup"><span data-stu-id="47cc5-157">Reducing allocations is a key way to improve the performance of managed code.</span></span> <span data-ttu-id="47cc5-158">為了達成這種共用，這些實作會使用 `SynchronizedPool` 類別。</span><span class="sxs-lookup"><span data-stu-id="47cc5-158">To accomplish this pooling, the implementations use the `SynchronizedPool` class.</span></span> <span data-ttu-id="47cc5-159">C# 檔案包含這個類別使用的其他最佳化方法的描述。</span><span class="sxs-lookup"><span data-stu-id="47cc5-159">The C# file contains a description of the additional optimizations used by this class.</span></span>  
  
 <span data-ttu-id="47cc5-160">為了避免替每一個訊息配置新的 <xref:System.Xml.XmlDictionaryReader> 和 <xref:System.Xml.XmlDictionaryWriter> 執行個體，編碼器會共用並重新初始化這些執行個體。</span><span class="sxs-lookup"><span data-stu-id="47cc5-160"><xref:System.Xml.XmlDictionaryReader> and <xref:System.Xml.XmlDictionaryWriter> instances are pooled and reinitialized to prevent allocating new ones for each message.</span></span> <span data-ttu-id="47cc5-161">對於讀取器，會在呼叫 `OnClose` 時由 `Close()` 回呼取回讀取器。</span><span class="sxs-lookup"><span data-stu-id="47cc5-161">For the readers, an `OnClose` callback reclaims the reader when `Close()` is called.</span></span> <span data-ttu-id="47cc5-162">編碼器也會回收建構訊息時使用的某些訊息狀態物件。</span><span class="sxs-lookup"><span data-stu-id="47cc5-162">The encoder also recycles some message state objects used when constructing messages.</span></span> <span data-ttu-id="47cc5-163">您可以在三個衍生自 `MaxReadPoolSize` 的每一個類別上，透過其 `MaxWritePoolSize` 和 <xref:System.ServiceModel.Channels.MessageEncodingBindingElement> 屬性來設定這些集區的大小。</span><span class="sxs-lookup"><span data-stu-id="47cc5-163">The sizes of these pools are configurable by the `MaxReadPoolSize` and `MaxWritePoolSize` properties on each of the three classes derived from <xref:System.ServiceModel.Channels.MessageEncodingBindingElement>.</span></span>  
  
### <a name="binary-encoding"></a><span data-ttu-id="47cc5-164">二進位編碼方式</span><span class="sxs-lookup"><span data-stu-id="47cc5-164">Binary Encoding</span></span>  

 <span data-ttu-id="47cc5-165">當二進位編碼使用工作階段時，必須將動態字典字串傳達至訊息的接收者。</span><span class="sxs-lookup"><span data-stu-id="47cc5-165">When binary encoding uses sessions, the dynamic dictionary string must be communicated to the receiver of the message.</span></span> <span data-ttu-id="47cc5-166">做法是在訊息前面加上動態字典字串。</span><span class="sxs-lookup"><span data-stu-id="47cc5-166">This is done by prefixing the message with the dynamic dictionary strings.</span></span> <span data-ttu-id="47cc5-167">接收者會剝取這些字串，然後將它們加入至工作階段，再處理訊息。</span><span class="sxs-lookup"><span data-stu-id="47cc5-167">The receiver strips off the strings, adds them to the session, and processes the message.</span></span> <span data-ttu-id="47cc5-168">為了正確傳遞字典字串，傳輸需要獲得緩衝。</span><span class="sxs-lookup"><span data-stu-id="47cc5-168">Correctly passing dictionary strings requires that the transport be buffered.</span></span>  
  
 <span data-ttu-id="47cc5-169">內部的 `AddSessionInformationToMessage` 方法會將字串附加至訊息。</span><span class="sxs-lookup"><span data-stu-id="47cc5-169">The strings are appended to the message by an internal `AddSessionInformationToMessage` method.</span></span> <span data-ttu-id="47cc5-170">它會將 UTF-8 格式的字串新增到訊息前頭並加上這些字串的長度，</span><span class="sxs-lookup"><span data-stu-id="47cc5-170">It adds the strings as UTF-8 to the front of the message prefixed with their length.</span></span> <span data-ttu-id="47cc5-171">然後在整個字典標頭前面加上其資料的長度。</span><span class="sxs-lookup"><span data-stu-id="47cc5-171">The entire dictionary header is then prefixed with the length of its data.</span></span> <span data-ttu-id="47cc5-172">內部的 `ExtractSessionInformationFromMessage` 方法則會執行反向作業。</span><span class="sxs-lookup"><span data-stu-id="47cc5-172">The reverse operation is performed by an internal `ExtractSessionInformationFromMessage` method.</span></span>  
  
 <span data-ttu-id="47cc5-173">除了處理動態字典索引鍵之外，還會以獨特的方式來接收緩衝的工作階段訊息。</span><span class="sxs-lookup"><span data-stu-id="47cc5-173">In addition to processing dynamic dictionary keys, buffered sessionful messages are received in a unique way.</span></span> <span data-ttu-id="47cc5-174">二進位編碼器並非在文件上建立讀取器，然後加以處理，而是使用內部的 `MessagePatterns` 類別來拆解二進位資料流。</span><span class="sxs-lookup"><span data-stu-id="47cc5-174">Instead of creating a reader over the document and processing it, the binary encoder uses the internal `MessagePatterns` class to deconstruct the binary stream.</span></span> <span data-ttu-id="47cc5-175">其概念是，大部分的訊息都有一組特定的標頭，這些標頭是由 WCF 產生時依特定順序顯示。</span><span class="sxs-lookup"><span data-stu-id="47cc5-175">The idea is that most messages have a certain set of headers that show up in a certain order when generated by WCF.</span></span> <span data-ttu-id="47cc5-176">模式系統會根據其需求分解訊息。</span><span class="sxs-lookup"><span data-stu-id="47cc5-176">The pattern system breaks the message apart based on what it expects.</span></span> <span data-ttu-id="47cc5-177">如果分解成功，這個系統就會將 <xref:System.ServiceModel.Channels.MessageHeaders> 物件初始化，而不剖析 XML。</span><span class="sxs-lookup"><span data-stu-id="47cc5-177">If it is successful, it initializes a <xref:System.ServiceModel.Channels.MessageHeaders> object without parsing the XML.</span></span> <span data-ttu-id="47cc5-178">如果失敗，則退而求其次，使用標準的方法。</span><span class="sxs-lookup"><span data-stu-id="47cc5-178">If not, it falls back to the standard method.</span></span>  
  
### <a name="mtom-encoding"></a><span data-ttu-id="47cc5-179">MTOM 編碼方式</span><span class="sxs-lookup"><span data-stu-id="47cc5-179">MTOM Encoding</span></span>  

 <span data-ttu-id="47cc5-180"><xref:System.ServiceModel.Channels.MtomMessageEncodingBindingElement> 類別具有另一個名為 <xref:System.ServiceModel.Channels.MtomMessageEncodingBindingElement.MaxBufferSize%2A> 的組態屬性。</span><span class="sxs-lookup"><span data-stu-id="47cc5-180">The <xref:System.ServiceModel.Channels.MtomMessageEncodingBindingElement> class has an additional configuration property called <xref:System.ServiceModel.Channels.MtomMessageEncodingBindingElement.MaxBufferSize%2A>.</span></span> <span data-ttu-id="47cc5-181">這個屬性可以設定允許繫結項目在讀取訊息過程中緩衝資料數量的上限。</span><span class="sxs-lookup"><span data-stu-id="47cc5-181">This places an upper bound on how much data it is allowed to buffer during the process of reading a message.</span></span> <span data-ttu-id="47cc5-182">可能需要將 XML 資訊集 (Infoset) 或其他 MIME 部分加以緩衝，才能將所有 MIME 部分重組成單一訊息。</span><span class="sxs-lookup"><span data-stu-id="47cc5-182">The XML Information Set (Infoset), or other MIME parts, may need to be buffered to reassemble all the MIME parts into a single message.</span></span>  
  
 <span data-ttu-id="47cc5-183">為能搭配 HTTP 而正常運作，內部 MTOM 訊息編碼器類別提供了一些適用於 `GetContentType` (同樣是內部的) 和 `WriteMessage` (公用的且可覆寫) 的內部 API。</span><span class="sxs-lookup"><span data-stu-id="47cc5-183">To work correctly with HTTP, the internal MTOM message encoder class provides some internal APIs for `GetContentType` (which is also internal) and `WriteMessage`, which is public and can be overridden.</span></span> <span data-ttu-id="47cc5-184">編碼器必須進行更多的通訊，才能確保 HTTP 標頭中的值與 MIME 標頭中的值一致。</span><span class="sxs-lookup"><span data-stu-id="47cc5-184">More communication must occur to ensure values in the HTTP headers agree with values in the MIME headers.</span></span>  
  
 <span data-ttu-id="47cc5-185">MTOM 訊息編碼器會在內部使用 WCF 的文字讀取器，類似于文字編碼器。</span><span class="sxs-lookup"><span data-stu-id="47cc5-185">Internally, the MTOM message encoder uses WCF's text readers, and is similar to the Text encoder.</span></span> <span data-ttu-id="47cc5-186">但是有所不同，主要差異在於最佳化大型二進位區塊 (即「二進位大型物件」(BLOB)) 的方式；在這些區塊嵌入至訊息位元組之前，MTOM 訊息編碼器並不會將它們轉換為 Base-64 編碼，</span><span class="sxs-lookup"><span data-stu-id="47cc5-186">The main difference is that it optimizes large chunks of binary, or "Binary Large Objects" (BLOBs), by not converting them to Base-64 encoding prior to being embedded into the message bytes.</span></span> <span data-ttu-id="47cc5-187">而是讓這些 BLOB 繼續以未經壓縮的狀態存在，並且將它們當做 MIME 附件來參考。</span><span class="sxs-lookup"><span data-stu-id="47cc5-187">Instead, these BLOBs are kept extracted, and referenced as the MIME attachments.</span></span>  
  
## <a name="writing-your-own-encoder"></a><span data-ttu-id="47cc5-188">撰寫您自己的編碼器</span><span class="sxs-lookup"><span data-stu-id="47cc5-188">Writing your own Encoder</span></span>  

 <span data-ttu-id="47cc5-189">若要實作您自己的自訂訊息編碼器，您必須提供下列抽象基底類別的自訂實作：</span><span class="sxs-lookup"><span data-stu-id="47cc5-189">To implement your own custom message encoder, you must provide custom implementations of the following abstract base classes:</span></span>  
  
- <xref:System.ServiceModel.Channels.MessageEncoder>  
  
- <xref:System.ServiceModel.Channels.MessageEncoderFactory>  
  
- <xref:System.ServiceModel.Channels.MessageEncodingBindingElement>  
  
 <span data-ttu-id="47cc5-190">訊息由「記憶體中」表示變成「可寫入至資料流」表示的轉換功能是封裝在 <xref:System.ServiceModel.Channels.MessageEncoder> 類別中，這個類別可以當做支援特定類型 XML 編碼之 XML 讀取器和 XML 寫入器的處理站使用。</span><span class="sxs-lookup"><span data-stu-id="47cc5-190">Converting from the in-memory representation of a message to a representation that can be written to a stream is encapsulated within the <xref:System.ServiceModel.Channels.MessageEncoder> class, which serves as a factory for XML readers and XML writers that support specific types of XML encodings.</span></span>  
  
- <span data-ttu-id="47cc5-191">在這個類別中，您必須加以覆寫的主要方法如下：</span><span class="sxs-lookup"><span data-stu-id="47cc5-191">The key methods of this class that you must override are:</span></span>  
  
- <span data-ttu-id="47cc5-192"><xref:System.ServiceModel.Channels.MessageEncoder.WriteMessage%2A>，這個方法會接受 <xref:System.ServiceModel.Channels.MessageEncodingBindingElement> 物件，並將它寫入至 <xref:System.IO.Stream> 物件。</span><span class="sxs-lookup"><span data-stu-id="47cc5-192"><xref:System.ServiceModel.Channels.MessageEncoder.WriteMessage%2A> which takes a <xref:System.ServiceModel.Channels.MessageEncodingBindingElement> object and writes it into a <xref:System.IO.Stream> object.</span></span>  
  
- <span data-ttu-id="47cc5-193"><xref:System.ServiceModel.Channels.MessageEncoder.ReadMessage%2A>，這個方法會接受 <xref:System.IO.Stream> 物件和最大標頭大小，然後傳回 <xref:System.ServiceModel.Channels.Message> 物件。</span><span class="sxs-lookup"><span data-stu-id="47cc5-193"><xref:System.ServiceModel.Channels.MessageEncoder.ReadMessage%2A> which takes a <xref:System.IO.Stream> object and a maximum header size and returns a <xref:System.ServiceModel.Channels.Message> object.</span></span>  
  
 <span data-ttu-id="47cc5-194">在處理標準傳輸通訊協定與自訂編碼之間轉換的這些方法中，它就是您要撰寫的程式碼。</span><span class="sxs-lookup"><span data-stu-id="47cc5-194">It is the code you write in these methods that handles conversion between the standard transport protocol, and your customized encoding.</span></span>  
  
 <span data-ttu-id="47cc5-195">接下來，您必須針對建立自訂編碼器的處理站類別編寫程式碼。</span><span class="sxs-lookup"><span data-stu-id="47cc5-195">Next you need to code a factory class that creates your custom encoder.</span></span> <span data-ttu-id="47cc5-196">覆寫 <xref:System.ServiceModel.Channels.MessageEncoderFactory.Encoder%2A>，以傳回自訂 <xref:System.ServiceModel.Channels.MessageEncoder> 的執行個體。</span><span class="sxs-lookup"><span data-stu-id="47cc5-196">Override the <xref:System.ServiceModel.Channels.MessageEncoderFactory.Encoder%2A> to return an instance of your custom <xref:System.ServiceModel.Channels.MessageEncoder>.</span></span>  
  
 <span data-ttu-id="47cc5-197">最後，覆寫 <xref:System.ServiceModel.Channels.MessageEncoderFactory> 方法以傳回這個處理站的執行個體，讓自訂的 <xref:System.ServiceModel.Channels.MessageEncodingBindingElement.CreateMessageEncoderFactory%2A> 連接到用於設定服務或用戶端的繫結項目堆疊。</span><span class="sxs-lookup"><span data-stu-id="47cc5-197">Then connect your custom <xref:System.ServiceModel.Channels.MessageEncoderFactory> to the binding element stack used to configure the service or client by overriding the <xref:System.ServiceModel.Channels.MessageEncodingBindingElement.CreateMessageEncoderFactory%2A> method to return an instance of this factory.</span></span>  
  
 <span data-ttu-id="47cc5-198">WCF 提供兩個範例，其中使用範例程式碼來說明此程式： [自訂訊息編碼器：自訂文字編碼器](../samples/custom-message-encoder-custom-text-encoder.md) 和 [自訂訊息編碼器：壓縮編碼器](../samples/custom-message-encoder-compression-encoder.md)。</span><span class="sxs-lookup"><span data-stu-id="47cc5-198">There are two samples provided with WCF that illustrate this process with sample code: [Custom Message Encoder: Custom Text Encoder](../samples/custom-message-encoder-custom-text-encoder.md) and [Custom Message Encoder: Compression Encoder](../samples/custom-message-encoder-compression-encoder.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="47cc5-199">另請參閱</span><span class="sxs-lookup"><span data-stu-id="47cc5-199">See also</span></span>

- <xref:System.ServiceModel.Channels.MessageEncodingBindingElement>
- <xref:System.ServiceModel.Channels.MessageEncoderFactory>
- <xref:System.ServiceModel.Channels.MessageEncoder>
- [<span data-ttu-id="47cc5-200">資料傳輸架構概觀</span><span class="sxs-lookup"><span data-stu-id="47cc5-200">Data Transfer Architectural Overview</span></span>](../feature-details/data-transfer-architectural-overview.md)
- [<span data-ttu-id="47cc5-201">選擇訊息編碼器</span><span class="sxs-lookup"><span data-stu-id="47cc5-201">Choosing a Message Encoder</span></span>](../feature-details/choosing-a-message-encoder.md)
- [<span data-ttu-id="47cc5-202">選擇傳輸</span><span class="sxs-lookup"><span data-stu-id="47cc5-202">Choosing a Transport</span></span>](../feature-details/choosing-a-transport.md)
