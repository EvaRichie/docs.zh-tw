---
title: WCF 簡化功能
ms.date: 03/30/2017
ms.assetid: 4535a511-6064-4da0-b361-80262a891663
ms.openlocfilehash: 8a818ec0852cfae20ef23fede04b55b08a7449a5
ms.sourcegitcommit: d8020797a6657d0fbbdff362b80300815f682f94
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 11/24/2020
ms.locfileid: "95732914"
---
# <a name="wcf-simplification-features"></a><span data-ttu-id="299c2-102">WCF 簡化功能</span><span class="sxs-lookup"><span data-stu-id="299c2-102">WCF Simplification Features</span></span>

<span data-ttu-id="299c2-103">本主題探討讓撰寫 WCF 應用程式更簡單的新功能。</span><span class="sxs-lookup"><span data-stu-id="299c2-103">This topic discusses new features that make writing WCF applications simpler.</span></span>

## <a name="simplified-generated-configuration-files"></a><span data-ttu-id="299c2-104">簡化產生的組態檔</span><span class="sxs-lookup"><span data-stu-id="299c2-104">Simplified Generated Configuration Files</span></span>

<span data-ttu-id="299c2-105">當您在 Visual Studio 中加入服務參考，或使用 SvcUtil.exe 工具時，用戶端組態檔就會產生。</span><span class="sxs-lookup"><span data-stu-id="299c2-105">When you add a service reference in Visual Studio or use the SvcUtil.exe tool a client configuration file is generated.</span></span> <span data-ttu-id="299c2-106">在舊版 WCF 中，這些組態檔會包含所有繫結屬性的值，即使值為預設值，也是如此。</span><span class="sxs-lookup"><span data-stu-id="299c2-106">In previous versions of WCF these configuration files contained the value of every binding property even if its value is the default value.</span></span> <span data-ttu-id="299c2-107">在 WCF 4.5 中產生的組態檔只會包含那些設定成非預設值的繫結屬性。</span><span class="sxs-lookup"><span data-stu-id="299c2-107">In WCF 4.5 the generated configuration files contain only those binding properties that are set to a non-default value.</span></span>

<span data-ttu-id="299c2-108">下列是 WCF 3.0 所產生之組態檔的範例。</span><span class="sxs-lookup"><span data-stu-id="299c2-108">The following is an example of a configuration file generated by WCF 3.0.</span></span>

```xml
<?xml version="1.0" encoding="utf-8"?>
<configuration>
    <system.serviceModel>
        <bindings>
            <basicHttpBinding>
                <binding name="BasicHttpBinding_IService1" closeTimeout="00:01:00"
                    openTimeout="00:01:00" receiveTimeout="00:10:00" sendTimeout="00:01:00"
                    allowCookies="false" bypassProxyOnLocal="false"
                    hostNameComparisonMode="StrongWildcard" maxBufferSize="65536"
                    maxBufferPoolSize="524288" maxReceivedMessageSize="65536"
                    messageEncoding="Text" textEncoding="utf-8" transferMode="Buffered"
                    useDefaultWebProxy="true">
                    <readerQuotas maxDepth="32" maxStringContentLength="8192"
                        maxArrayLength="16384" maxBytesPerRead="4096"
                        maxNameTableCharCount="16384" />
                    <security mode="None">
                        <transport clientCredentialType="None" proxyCredentialType="None"
                            realm="" />
                        <message clientCredentialType="UserName" algorithmSuite="Default" />
                    </security>
                </binding>
            </basicHttpBinding>
        </bindings>
        <client>
            <endpoint address="http://localhost:36906/Service1.svc" binding="basicHttpBinding"
                bindingConfiguration="BasicHttpBinding_IService1" contract="IService1"
                name="BasicHttpBinding_IService1" />
        </client>
    </system.serviceModel>
</configuration>
```

<span data-ttu-id="299c2-109">下列是 WCF 4.5 所產生之相同組態檔的範例。</span><span class="sxs-lookup"><span data-stu-id="299c2-109">The following is an example of the same configuration file generated by WCF 4.5.</span></span>

```xml
<?xml version="1.0" encoding="utf-8"?>
<configuration>
    <system.serviceModel>
        <bindings>
            <basicHttpBinding>
                <binding name="BasicHttpBinding_IService1" />
            </basicHttpBinding>
        </bindings>
        <client>
            <endpoint address="http://localhost:36906/Service1.svc" binding="basicHttpBinding"
                bindingConfiguration="BasicHttpBinding_IService1" contract="IService1"
                name="BasicHttpBinding_IService1" />
        </client>
    </system.serviceModel>
</configuration>
```

## <a name="contract-first-development"></a><span data-ttu-id="299c2-110">合約優先開發</span><span class="sxs-lookup"><span data-stu-id="299c2-110">Contract-First Development</span></span>

<span data-ttu-id="299c2-111">WCF 現可支援合約優先開發。</span><span class="sxs-lookup"><span data-stu-id="299c2-111">WCF now has support for contract-first development.</span></span> <span data-ttu-id="299c2-112">svcutil.exe 工具具有/serviceContract 參數，可讓您從 WSDL 檔案產生服務和資料合約。</span><span class="sxs-lookup"><span data-stu-id="299c2-112">The svcutil.exe tool has a /serviceContract switch which allows you to generate service and data contracts from a WSDL document.</span></span>

## <a name="add-service-reference-from-a-portable-subset-project"></a><span data-ttu-id="299c2-113">從可攜式子集專案加入服務參考</span><span class="sxs-lookup"><span data-stu-id="299c2-113">Add Service Reference From a Portable Subset Project</span></span>

<span data-ttu-id="299c2-114">可移植子集專案可讓 .NET 元件程式設計人員維護單一來源樹狀結構和組建系統，同時仍支援多個 .NET 執行 (桌面、Silverlight、Windows Phone 和 Xbox) 。</span><span class="sxs-lookup"><span data-stu-id="299c2-114">Portable subset projects enable .NET assembly programmers to maintain a single source tree and build system while still supporting multiple .NET implementations (desktop, Silverlight, Windows Phone, and Xbox).</span></span> <span data-ttu-id="299c2-115">可移植子集專案只參考 .NET 的可移植程式庫，這些是可在任何 .NET 執行上使用的元件。</span><span class="sxs-lookup"><span data-stu-id="299c2-115">Portable subset projects only reference .NET portable libraries that are assemblies that can be used on any .NET implementation.</span></span> <span data-ttu-id="299c2-116">開發人員的體驗與在任何其他 WCF 用戶端應用程式內加入服務參考相同。</span><span class="sxs-lookup"><span data-stu-id="299c2-116">The developer experience is the same as adding a service reference within any other WCF client application.</span></span> <span data-ttu-id="299c2-117">如需詳細資訊，請參閱 [便攜子集專案中的加入服務參考](add-service-reference-in-a-portable-subset-project.md)。</span><span class="sxs-lookup"><span data-stu-id="299c2-117">For more information, see [Add Service Reference in a Portable Subset Project](add-service-reference-in-a-portable-subset-project.md).</span></span>

## <a name="aspnet-compatibility-mode-default-changed"></a><span data-ttu-id="299c2-118">ASP.NET 相容模式預設值已變更</span><span class="sxs-lookup"><span data-stu-id="299c2-118">ASP.NET Compatibility Mode Default Changed</span></span>

<span data-ttu-id="299c2-119">WCF 會在寫入 WCF 服務時提供 ASP.NET 相容模式，將 ASP.NET HTTP 管線功能的完整存取權限授與開發人員。</span><span class="sxs-lookup"><span data-stu-id="299c2-119">WCF provides ASP.NET compatibility mode to grant developers full access to the features in the ASP.NET HTTP pipeline when writing WCF services.</span></span> <span data-ttu-id="299c2-120">若要使用此模式，您必須 `aspNetCompatibilityEnabled` 在 web.config 的區段中，將屬性設定為 true [\<serviceHostingEnvironment>](../configure-apps/file-schema/wcf/servicehostingenvironment.md) 。此外，此 appDomain 中的任何服務都必須將 `RequirementsMode` 其上的屬性 <xref:System.ServiceModel.Activation.AspNetCompatibilityRequirementsAttribute> 設定 <xref:System.ServiceModel.Activation.AspNetCompatibilityRequirementsMode.Allowed> 為 <xref:System.ServiceModel.Activation.AspNetCompatibilityRequirementsMode.Required> 或。</span><span class="sxs-lookup"><span data-stu-id="299c2-120">To use this mode, you must set the `aspNetCompatibilityEnabled` attribute to true in the [\<serviceHostingEnvironment>](../configure-apps/file-schema/wcf/servicehostingenvironment.md) section of web.config. Additionally, any service in this appDomain needs to have the `RequirementsMode` property on its <xref:System.ServiceModel.Activation.AspNetCompatibilityRequirementsAttribute> set to <xref:System.ServiceModel.Activation.AspNetCompatibilityRequirementsMode.Allowed> or <xref:System.ServiceModel.Activation.AspNetCompatibilityRequirementsMode.Required>.</span></span> <span data-ttu-id="299c2-121">根據預設， <xref:System.ServiceModel.Activation.AspNetCompatibilityRequirementsAttribute> 現在會設定為 <xref:System.ServiceModel.Activation.AspNetCompatibilityRequirementsMode.Allowed> ，而預設的 WCF 服務應用程式範本會將 `aspNetCompatibilityEnabled` 屬性設定為 `true` 。</span><span class="sxs-lookup"><span data-stu-id="299c2-121">By default <xref:System.ServiceModel.Activation.AspNetCompatibilityRequirementsAttribute> is now set to <xref:System.ServiceModel.Activation.AspNetCompatibilityRequirementsMode.Allowed> and the default WCF service application template sets the `aspNetCompatibilityEnabled` attribute to `true`.</span></span> <span data-ttu-id="299c2-122">如需詳細資訊，請參閱 Windows Communication Foundation 4.5 和[WCF 服務和 ASP.NET](./feature-details/wcf-services-and-aspnet.md)[的新功能](whats-new.md)。</span><span class="sxs-lookup"><span data-stu-id="299c2-122">For more information, see [What's New in Windows Communication Foundation 4.5](whats-new.md) and [WCF Services and ASP.NET](./feature-details/wcf-services-and-aspnet.md).</span></span>

## <a name="streaming-improvements"></a><span data-ttu-id="299c2-123">資料流的改進</span><span class="sxs-lookup"><span data-stu-id="299c2-123">Streaming Improvements</span></span>

- <span data-ttu-id="299c2-124">WCF 已新增對非同步資料流的支援。</span><span class="sxs-lookup"><span data-stu-id="299c2-124">New support for asynchronous streaming has been added to WCF.</span></span> <span data-ttu-id="299c2-125">若要啟用非同步資料流，請將 <xref:System.ServiceModel.Description.DispatcherSynchronizationBehavior> 端點行為加入至服務主機，並將其 <xref:System.ServiceModel.Description.DispatcherSynchronizationBehavior.AsynchronousSendEnabled%2A> 屬性設定為 `true`。</span><span class="sxs-lookup"><span data-stu-id="299c2-125">To enable asynchronous streaming, add the  <xref:System.ServiceModel.Description.DispatcherSynchronizationBehavior> endpoint behavior to the service host and set its <xref:System.ServiceModel.Description.DispatcherSynchronizationBehavior.AsynchronousSendEnabled%2A> property to `true`.</span></span> <span data-ttu-id="299c2-126">當服務將已進行資料流處理的訊息傳送到多個用戶端，而這些用戶端的讀取速度緩慢時，這個做法可以提高延展性。</span><span class="sxs-lookup"><span data-stu-id="299c2-126">This can benefit scalability when a service is sending streamed messages to multiple clients which are reading slowly.</span></span> <span data-ttu-id="299c2-127">WCF 不再針對個別用戶端封鎖執行緒，並且會釋放執行緒以服務另一個用戶端。</span><span class="sxs-lookup"><span data-stu-id="299c2-127">WCF does not block one thread per client anymore and will free up the thread to service another client.</span></span>

- <span data-ttu-id="299c2-128">已移除訊息緩衝在服務由 IIS 裝載時的限制。</span><span class="sxs-lookup"><span data-stu-id="299c2-128">Removed limitations around buffering of messages when a service is IIS hosted.</span></span> <span data-ttu-id="299c2-129">在舊版 WCF 中，當收到使用資料流訊息傳輸之 IIS 裝載服務的訊息時，ASP.NET 在傳送訊息到 WCF 之前會緩衝整個訊息。</span><span class="sxs-lookup"><span data-stu-id="299c2-129">In previous versions of WCF when receiving a message for an IIS-hosted service that used streaming message transfer, ASP.NET would buffer the entire message before sending it to WCF.</span></span> <span data-ttu-id="299c2-130">這將導致大量記憶體消耗。</span><span class="sxs-lookup"><span data-stu-id="299c2-130">This would cause large memory consumption.</span></span> <span data-ttu-id="299c2-131">此緩衝已在 .NET Framework 4.5 中移除，而現在由 IIS 裝載的 WCF 服務可以在接收到整個訊息之前開始處理傳入的資料流程，藉此啟用真正的串流處理。</span><span class="sxs-lookup"><span data-stu-id="299c2-131">This buffering has been removed in .NET Framework 4.5 and now IIS-hosted WCF services can start processing the incoming stream before the entire message has been received, thereby enabling true streaming.</span></span> <span data-ttu-id="299c2-132">這允許 WCF 立即對訊息做出回應，並使效能有所提升。</span><span class="sxs-lookup"><span data-stu-id="299c2-132">This allows WCF to respond immediately to messages and allows improved performance.</span></span> <span data-ttu-id="299c2-133">此外，您不再需要指定 `maxRequestLength` (ASP.NET 對傳入要求的大小限制) 的值。</span><span class="sxs-lookup"><span data-stu-id="299c2-133">In addition, you no longer have to specify a value for `maxRequestLength`, the ASP.NET size limit on incoming requests.</span></span> <span data-ttu-id="299c2-134">如果設定這個屬性，則會將其忽略。</span><span class="sxs-lookup"><span data-stu-id="299c2-134">If this property is set, it is ignored.</span></span> <span data-ttu-id="299c2-135">如需詳細資訊， `maxRequestLength` 請參閱[ \<httpRuntime> configuration 元素](/previous-versions/dotnet/netframework-1.1/e1f13641(v=vs.71))。</span><span class="sxs-lookup"><span data-stu-id="299c2-135">For more information about `maxRequestLength` see [\<httpRuntime> configuration element](/previous-versions/dotnet/netframework-1.1/e1f13641(v=vs.71)).</span></span> <span data-ttu-id="299c2-136">您仍然需要設定 maxAllowedContentLength。如需詳細資訊，請參閱 [IIS 要求限制](/previous-versions/iis/settings-schema/ms689462(v=vs.90))。</span><span class="sxs-lookup"><span data-stu-id="299c2-136">You will still need to configure the maxAllowedContentLength, For more information, see [IIS Request Limits](/previous-versions/iis/settings-schema/ms689462(v=vs.90)).</span></span>

## <a name="new-transport-default-values"></a><span data-ttu-id="299c2-137">新的傳輸預設值</span><span class="sxs-lookup"><span data-stu-id="299c2-137">New Transport Default Values</span></span>

<span data-ttu-id="299c2-138">下列資料表說明已變更的設定以及可找到其他資訊的位置。</span><span class="sxs-lookup"><span data-stu-id="299c2-138">The following table describes the settings that have changed and where to find additional information.</span></span>

|<span data-ttu-id="299c2-139">屬性</span><span class="sxs-lookup"><span data-stu-id="299c2-139">Property</span></span>|<span data-ttu-id="299c2-140">開啟</span><span class="sxs-lookup"><span data-stu-id="299c2-140">On</span></span>|<span data-ttu-id="299c2-141">新的預設值</span><span class="sxs-lookup"><span data-stu-id="299c2-141">New Default</span></span>|<span data-ttu-id="299c2-142">相關資訊</span><span class="sxs-lookup"><span data-stu-id="299c2-142">More Information</span></span>|
|--------------|--------|-----------------|----------------------|
|<span data-ttu-id="299c2-143">channelInitializationTimeout</span><span class="sxs-lookup"><span data-stu-id="299c2-143">channelInitializationTimeout</span></span>|<xref:System.ServiceModel.NetTcpBinding>|<span data-ttu-id="299c2-144">30 秒</span><span class="sxs-lookup"><span data-stu-id="299c2-144">30 seconds</span></span>|<span data-ttu-id="299c2-145">這個屬性會決定 TCP 連接使用 .NET 框架通訊協定來自行驗證的時間長度。</span><span class="sxs-lookup"><span data-stu-id="299c2-145">This property determines how long a TCP connection can take to authenticate itself using the .NET Framing protocol.</span></span> <span data-ttu-id="299c2-146">用戶端必須先傳送一些初始資料，讓伺服器有足夠的資訊來執行驗證。</span><span class="sxs-lookup"><span data-stu-id="299c2-146">A client needs to send some initial data before the server has enough information to perform authentication.</span></span> <span data-ttu-id="299c2-147">逾時會故意設定為小於 ReceiveTimeout (10 分鐘)，使未經驗證的惡意用戶端無法長時間保持與伺服器的連接。</span><span class="sxs-lookup"><span data-stu-id="299c2-147">This timeout is intentionally made smaller than the ReceiveTimeout (10 min) so that malicious unauthenticated clients do not keep the connections tied up to the server for long.</span></span> <span data-ttu-id="299c2-148">預設值為 30 秒。</span><span class="sxs-lookup"><span data-stu-id="299c2-148">The default value is 30 seconds.</span></span> <span data-ttu-id="299c2-149">如需相關資訊， <xref:System.ServiceModel.Channels.ConnectionOrientedTransportBindingElement.ChannelInitializationTimeout%2A></span><span class="sxs-lookup"><span data-stu-id="299c2-149">For more information about <xref:System.ServiceModel.Channels.ConnectionOrientedTransportBindingElement.ChannelInitializationTimeout%2A></span></span>|
|<span data-ttu-id="299c2-150">listenBacklog</span><span class="sxs-lookup"><span data-stu-id="299c2-150">listenBacklog</span></span>|<xref:System.ServiceModel.NetTcpBinding>|<span data-ttu-id="299c2-151">16 \* 處理器數目</span><span class="sxs-lookup"><span data-stu-id="299c2-151">16 \* number of processors</span></span>|<span data-ttu-id="299c2-152">此為通訊端層級的屬性，用來說明要排入佇列之「擱置接受」要求的數目。</span><span class="sxs-lookup"><span data-stu-id="299c2-152">This socket-level property describes the number of "pending accept" requests to be queued.</span></span> <span data-ttu-id="299c2-153">如果接聽待辦項目佇列已滿，將會拒絕新的通訊端要求。</span><span class="sxs-lookup"><span data-stu-id="299c2-153">If the listen backlog queue fills up, new socket requests will be rejected.</span></span> <span data-ttu-id="299c2-154">如需相關資訊， <xref:System.ServiceModel.NetTcpBinding.ListenBacklog%2A></span><span class="sxs-lookup"><span data-stu-id="299c2-154">For more information about <xref:System.ServiceModel.NetTcpBinding.ListenBacklog%2A></span></span>|
|<span data-ttu-id="299c2-155">maxPendingAccepts</span><span class="sxs-lookup"><span data-stu-id="299c2-155">maxPendingAccepts</span></span>|<span data-ttu-id="299c2-156">ConnectionOrientedTransportBindingElement</span><span class="sxs-lookup"><span data-stu-id="299c2-156">ConnectionOrientedTransportBindingElement</span></span><br /><br /> <span data-ttu-id="299c2-157">SMSvcHost.exe</span><span class="sxs-lookup"><span data-stu-id="299c2-157">SMSvcHost.exe</span></span>|<span data-ttu-id="299c2-158">2 \* 用於傳輸的處理器數量</span><span class="sxs-lookup"><span data-stu-id="299c2-158">2 \* number of processors for transport</span></span><br /><br /> <span data-ttu-id="299c2-159">SMSvcHost.exe 4 個 \* 處理器數目</span><span class="sxs-lookup"><span data-stu-id="299c2-159">4 \* number of processors for SMSvcHost.exe</span></span>|<span data-ttu-id="299c2-160">這個屬性會限制伺服器可以在接聽程式上等待的通道數量。</span><span class="sxs-lookup"><span data-stu-id="299c2-160">This property limits the number of channels that the server can have waiting on a listener.</span></span> <span data-ttu-id="299c2-161">MaxPendingAccepts 太低時，會有一小段時間間隔讓所有等待中的通道開始提供連接服務，但不會有任何新的通道開始接聽。</span><span class="sxs-lookup"><span data-stu-id="299c2-161">When MaxPendingAccepts is too low, there will be a small interval of time in which all of the waiting channels have started servicing connections, but no new channels have begun listening.</span></span> <span data-ttu-id="299c2-162">在這段時間間隔內出現的連接都會失敗，因為伺服器上沒有任何要等待的連接。</span><span class="sxs-lookup"><span data-stu-id="299c2-162">A connection can arrive during this interval and will fail because nothing is waiting for it on the server.</span></span> <span data-ttu-id="299c2-163">這個屬性可以藉由將 <xref:System.ServiceModel.Channels.ConnectionOrientedTransportBindingElement.MaxPendingConnections%2A> 屬性設為較大數目的方式進行設定。</span><span class="sxs-lookup"><span data-stu-id="299c2-163">This property can be configured by setting the <xref:System.ServiceModel.Channels.ConnectionOrientedTransportBindingElement.MaxPendingConnections%2A> property to a larger number.</span></span> <span data-ttu-id="299c2-164">如需詳細資訊，請參閱 <xref:System.ServiceModel.Channels.ConnectionOrientedTransportBindingElement.MaxPendingAccepts%2A> 和設定 [Net.tcp 埠共用服務](./feature-details/configuring-the-net-tcp-port-sharing-service.md)</span><span class="sxs-lookup"><span data-stu-id="299c2-164">For more information, see <xref:System.ServiceModel.Channels.ConnectionOrientedTransportBindingElement.MaxPendingAccepts%2A> and [Configuring the Net.TCP Port Sharing Service](./feature-details/configuring-the-net-tcp-port-sharing-service.md)</span></span>|
|<span data-ttu-id="299c2-165">maxPendingConnections</span><span class="sxs-lookup"><span data-stu-id="299c2-165">maxPendingConnections</span></span>|<span data-ttu-id="299c2-166">ConnectionOrientedTransportBindingElement</span><span class="sxs-lookup"><span data-stu-id="299c2-166">ConnectionOrientedTransportBindingElement</span></span>|<span data-ttu-id="299c2-167">12 \* 處理器的數量</span><span class="sxs-lookup"><span data-stu-id="299c2-167">12 \* number of processors</span></span>|<span data-ttu-id="299c2-168">這個屬性控制傳輸已接受但未經 ServiceModel 發送器擷取的連接數量。</span><span class="sxs-lookup"><span data-stu-id="299c2-168">This property controls how many connections a transport has accepted but have not been picked up by the ServiceModel Dispatcher.</span></span> <span data-ttu-id="299c2-169">若要設定這個值，請使用繫結上的 `MaxConnections` 或繫結項目上的 `maxOutboundConnectionsPerEndpoint`。</span><span class="sxs-lookup"><span data-stu-id="299c2-169">To set this value, use `MaxConnections` on the binding or `maxOutboundConnectionsPerEndpoint` on the binding element.</span></span> <span data-ttu-id="299c2-170">如需相關資訊， <xref:System.ServiceModel.Channels.ConnectionOrientedTransportBindingElement.MaxPendingConnections%2A></span><span class="sxs-lookup"><span data-stu-id="299c2-170">For more information about <xref:System.ServiceModel.Channels.ConnectionOrientedTransportBindingElement.MaxPendingConnections%2A></span></span>|
|<span data-ttu-id="299c2-171">receiveTimeout</span><span class="sxs-lookup"><span data-stu-id="299c2-171">receiveTimeout</span></span>|<span data-ttu-id="299c2-172">SMSvcHost.exe</span><span class="sxs-lookup"><span data-stu-id="299c2-172">SMSvcHost.exe</span></span>|<span data-ttu-id="299c2-173">30 秒</span><span class="sxs-lookup"><span data-stu-id="299c2-173">30 seconds</span></span>|<span data-ttu-id="299c2-174">這個屬性會指定讀取 TCP 框架資料以及從基礎連線執行連線分派的逾時。</span><span class="sxs-lookup"><span data-stu-id="299c2-174">This property specifies the timeout for reading the TCP framing data and performing connection dispatching from the underlying connections.</span></span> <span data-ttu-id="299c2-175">這個屬性的用途是設定 SMSvcHost.exe 服務持續投入讀取傳入連接之前序編碼資料的時間上限。</span><span class="sxs-lookup"><span data-stu-id="299c2-175">This exists to put a cap on the amount of time SMSvcHost.exe service is kept engaged to read the preamble data from an incoming connection.</span></span> <span data-ttu-id="299c2-176">如需詳細資訊，請參閱設定 [Net.tcp 埠共用服務](./feature-details/configuring-the-net-tcp-port-sharing-service.md)。</span><span class="sxs-lookup"><span data-stu-id="299c2-176">For more information, see [Configuring the Net.TCP Port Sharing Service](./feature-details/configuring-the-net-tcp-port-sharing-service.md).</span></span>|

> [!NOTE]
> <span data-ttu-id="299c2-177">只有在包含 .NET Framework 4.5 的電腦上部署 WCF 服務時，才會使用這些新的預設值。</span><span class="sxs-lookup"><span data-stu-id="299c2-177">These new defaults are used only if you deploy the WCF service on a machine with .NET Framework 4.5.</span></span> <span data-ttu-id="299c2-178">如果您在包含 .NET Framework 4.0 的電腦上部署相同服務，就會使用 .NET Framework 4.0 的預設值。</span><span class="sxs-lookup"><span data-stu-id="299c2-178">If you deploy the same service on a machine with .NET Framework 4.0, then the .NET Framework 4.0 defaults are used.</span></span> <span data-ttu-id="299c2-179">在這些情況下，建議您明確地設定這些設定。</span><span class="sxs-lookup"><span data-stu-id="299c2-179">In such cases it is recommended to configure these settings explicitly.</span></span>

## <a name="xmldictionaryreaderquotas"></a><span data-ttu-id="299c2-180">XmlDictionaryReaderQuotas</span><span class="sxs-lookup"><span data-stu-id="299c2-180">XmlDictionaryReaderQuotas</span></span>

<span data-ttu-id="299c2-181"><xref:System.Xml.XmlDictionaryReaderQuotas> 包含 XML 字典讀取器的可設定配額值，這些值會限制編碼器在建立訊息時使用的記憶體量。</span><span class="sxs-lookup"><span data-stu-id="299c2-181"><xref:System.Xml.XmlDictionaryReaderQuotas> contains configurable quota values for XML dictionary readers which limit the amount of memory utilized by an encoder while creating a message.</span></span> <span data-ttu-id="299c2-182">雖然這些配額是可設定的，但變更為預設值可降低開發人員必須明確設定這些值的機率。</span><span class="sxs-lookup"><span data-stu-id="299c2-182">While these quotas are configurable, the default values have changed to lessen the possibility that a developer will need to set them explicitly.</span></span> <span data-ttu-id="299c2-183">目前尚未變更 `MaxReceivedMessageSize` 配額，因此這個配額仍然可以限制記憶體耗用，避免您遇到必須處理 <xref:System.Xml.XmlDictionaryReaderQuotas> 的複雜狀況。</span><span class="sxs-lookup"><span data-stu-id="299c2-183">`MaxReceivedMessageSize` quota has not been changed so that it can still limit memory consumption preventing the need for you to deal with the complexity of the <xref:System.Xml.XmlDictionaryReaderQuotas>.</span></span> <span data-ttu-id="299c2-184">下表顯示配額、新的預設值和每個配額用途的簡要說明。</span><span class="sxs-lookup"><span data-stu-id="299c2-184">The following table shows the quotas, their new default values and a brief explanation of what each quota is used for.</span></span>

|<span data-ttu-id="299c2-185">配額名稱</span><span class="sxs-lookup"><span data-stu-id="299c2-185">Quota Name</span></span>|<span data-ttu-id="299c2-186">預設值</span><span class="sxs-lookup"><span data-stu-id="299c2-186">Default Value</span></span>|<span data-ttu-id="299c2-187">描述</span><span class="sxs-lookup"><span data-stu-id="299c2-187">Description</span></span>|
|----------------|-------------------|-----------------|
|<xref:System.Xml.XmlDictionaryReaderQuotas.MaxArrayLength%2A>|<span data-ttu-id="299c2-188">Int32.MaxValue</span><span class="sxs-lookup"><span data-stu-id="299c2-188">Int32.MaxValue</span></span>|<span data-ttu-id="299c2-189">取得和設定允許的陣列長度上限。</span><span class="sxs-lookup"><span data-stu-id="299c2-189">Gets and sets the maximum allowed array length.</span></span> <span data-ttu-id="299c2-190">這個配額會限制 XML 讀取器將會傳回之基本陣列的大小上限，包括位元組陣列。</span><span class="sxs-lookup"><span data-stu-id="299c2-190">This quota limits the maximum size of an array of primitives that the XML reader returns, including byte arrays.</span></span> <span data-ttu-id="299c2-191">這個配額不會限制 XML 讀取器本身的記憶體消耗，但會限制正在使用讀取器之任何元件中的記憶體消耗。</span><span class="sxs-lookup"><span data-stu-id="299c2-191">This quota does not limit memory consumption in the XML reader itself, but in whatever component that is using the reader.</span></span> <span data-ttu-id="299c2-192">例如，當 <xref:System.Runtime.Serialization.DataContractSerializer> 使用以 <xref:System.Xml.XmlDictionaryReaderQuotas.MaxArrayLength%2A>保護的讀取器時，它不會還原序列化大於這個配額的位元組陣列。</span><span class="sxs-lookup"><span data-stu-id="299c2-192">For example, when the <xref:System.Runtime.Serialization.DataContractSerializer> uses a reader secured with <xref:System.Xml.XmlDictionaryReaderQuotas.MaxArrayLength%2A>, it does not deserialize byte arrays larger than this quota.</span></span>|
|<xref:System.Xml.XmlDictionaryReaderQuotas.MaxBytesPerRead%2A>|<span data-ttu-id="299c2-193">Int32.MaxValue</span><span class="sxs-lookup"><span data-stu-id="299c2-193">Int32.MaxValue</span></span>|<span data-ttu-id="299c2-194">取得和設定允許每個讀取動作傳回的位元組上限。</span><span class="sxs-lookup"><span data-stu-id="299c2-194">Gets and sets the maximum allowed bytes returned for each read.</span></span> <span data-ttu-id="299c2-195">這個配額會限制讀取項目開始標記和其屬性時，在單一「讀取」作業中讀取的位元組數目。</span><span class="sxs-lookup"><span data-stu-id="299c2-195">This quota limits the number of bytes that are read in a single Read operation when reading the element start tag and its attributes.</span></span> <span data-ttu-id="299c2-196">(在非資料流處理的情況中，項目名稱本身不會納入配額的計數)。</span><span class="sxs-lookup"><span data-stu-id="299c2-196">(In non-streamed cases, the element name itself is not counted against the quota).</span></span> <span data-ttu-id="299c2-197">使用太多 XML 屬性可能會耗盡不當比例的處理時間，因為必須檢查屬性名稱的唯一性。</span><span class="sxs-lookup"><span data-stu-id="299c2-197">Having too many XML attributes may use up disproportionate processing time because attribute names have to be checked for uniqueness.</span></span> <span data-ttu-id="299c2-198"><xref:System.Xml.XmlDictionaryReaderQuotas.MaxBytesPerRead%2A> 可降低這個威脅。</span><span class="sxs-lookup"><span data-stu-id="299c2-198"><xref:System.Xml.XmlDictionaryReaderQuotas.MaxBytesPerRead%2A> mitigates this threat.</span></span>|
|<xref:System.Xml.XmlDictionaryReaderQuotas.MaxDepth%2A>|<span data-ttu-id="299c2-199">128 個節點深</span><span class="sxs-lookup"><span data-stu-id="299c2-199">128 nodes deep</span></span>|<span data-ttu-id="299c2-200">這個配額會限制 XML 項目的最大巢狀結構深度。</span><span class="sxs-lookup"><span data-stu-id="299c2-200">This quota limits the maximum nesting depth of XML elements.</span></span> <span data-ttu-id="299c2-201"><xref:System.Xml.XmlDictionaryReaderQuotas.MaxDepth%2A> 會與 <xref:System.Xml.XmlDictionaryReaderQuotas.MaxBytesPerRead%2A>互動：由於讀取器永遠會為目前項目和其所有祖系將資料保存在記憶體中，因此讀取器的最大記憶體消耗與這兩個設定的產品是成比例的。</span><span class="sxs-lookup"><span data-stu-id="299c2-201"><xref:System.Xml.XmlDictionaryReaderQuotas.MaxDepth%2A> interacts with <xref:System.Xml.XmlDictionaryReaderQuotas.MaxBytesPerRead%2A>: the reader always keeps data in memory for the current element and all of its ancestors, so the maximum memory consumption of the reader is proportional to the product of these two settings.</span></span> <span data-ttu-id="299c2-202">當還原序列化深度巢狀物件圖形時，會強制還原序列化程式存取整個堆疊並擲回無法復原的 <xref:System.StackOverflowException>。</span><span class="sxs-lookup"><span data-stu-id="299c2-202">When deserializing a deeply-nested object graph, the deserializer is forced to access the entire stack and throw an unrecoverable <xref:System.StackOverflowException>.</span></span> <span data-ttu-id="299c2-203">在 <xref:System.Runtime.Serialization.DataContractSerializer> 和 <xref:System.Xml.Serialization.XmlSerializer>兩者的 XML 巢狀結構和物件巢狀結構之間有直接的相互關聯。</span><span class="sxs-lookup"><span data-stu-id="299c2-203">A direct correlation exists between XML nesting and object nesting for both the <xref:System.Runtime.Serialization.DataContractSerializer> and the <xref:System.Xml.Serialization.XmlSerializer>.</span></span> <span data-ttu-id="299c2-204"><xref:System.Xml.XmlDictionaryReaderQuotas.MaxDepth%2A> 是用來降低這個威脅。</span><span class="sxs-lookup"><span data-stu-id="299c2-204"><xref:System.Xml.XmlDictionaryReaderQuotas.MaxDepth%2A> is used to mitigate this threat.</span></span>|
|<xref:System.Xml.XmlDictionaryReaderQuotas.MaxNameTableCharCount%2A>|<span data-ttu-id="299c2-205">Int32.MaxValue</span><span class="sxs-lookup"><span data-stu-id="299c2-205">Int32.MaxValue</span></span>|<span data-ttu-id="299c2-206">這個配額會限制名稱表格中允許的最大字元數目。</span><span class="sxs-lookup"><span data-stu-id="299c2-206">This quota limits the maximum number of characters allowed in a nametable.</span></span> <span data-ttu-id="299c2-207">名稱表格包含會在處理 XML 文件時遇到的特定字串 (例如命名空間和前置詞)。</span><span class="sxs-lookup"><span data-stu-id="299c2-207">The nametable contains certain strings (such as namespaces and prefixes) that are encountered when processing an XML document.</span></span> <span data-ttu-id="299c2-208">當這些字串在記憶體中緩衝時可使用這個配額，以防止在應該進行資料流處理時過度緩衝處理。</span><span class="sxs-lookup"><span data-stu-id="299c2-208">As these strings are buffered in memory, this quota is used to prevent excessive buffering when streaming is expected.</span></span>|
|<xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A>|<span data-ttu-id="299c2-209">Int32.MaxValue</span><span class="sxs-lookup"><span data-stu-id="299c2-209">Int32.MaxValue</span></span>|<span data-ttu-id="299c2-210">這個配額會限制 XML 讀取器傳回的字串大小上限。</span><span class="sxs-lookup"><span data-stu-id="299c2-210">This quota limits the maximum string size that the XML reader returns.</span></span> <span data-ttu-id="299c2-211">這個配額不會限制 XML 讀取器本身的記憶體消耗，但會限制正在使用讀取器之元件中的記憶體消耗。</span><span class="sxs-lookup"><span data-stu-id="299c2-211">This quota does not limit memory consumption in the XML reader itself, but in the component that is using the reader.</span></span> <span data-ttu-id="299c2-212">例如，當 <xref:System.Runtime.Serialization.DataContractSerializer> 使用以 <xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A>保護的讀取器時，它不會還原序列化大於這個配額的字串。</span><span class="sxs-lookup"><span data-stu-id="299c2-212">For example, when the <xref:System.Runtime.Serialization.DataContractSerializer> uses a reader secured with <xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A>, it does not deserialize strings larger than this quota.</span></span>|

> [!IMPORTANT]
> <span data-ttu-id="299c2-213">如需保護資料安全的詳細資訊，請參閱 [資料安全性考慮下的](./feature-details/security-considerations-for-data.md) 「安全使用 XML」。</span><span class="sxs-lookup"><span data-stu-id="299c2-213">Refer to "Using XML Safely" under [Security Considerations for Data](./feature-details/security-considerations-for-data.md) for more information about securing your data.</span></span>

> [!NOTE]
> <span data-ttu-id="299c2-214">只有在包含 .NET Framework 4.5 的電腦上部署 WCF 服務時，才會使用這些新的預設值。</span><span class="sxs-lookup"><span data-stu-id="299c2-214">These new defaults are used only if you deploy the WCF service on a machine with .NET Framework 4.5.</span></span> <span data-ttu-id="299c2-215">如果您在包含 .NET Framework 4.0 的電腦上部署相同服務，就會使用 .NET Framework 4.0 的預設值。</span><span class="sxs-lookup"><span data-stu-id="299c2-215">If you deploy the same service on a machine with .NET Framework 4.0, then the .NET Framework 4.0 defaults are used.</span></span> <span data-ttu-id="299c2-216">在這些情況下，建議您明確地設定這些設定。</span><span class="sxs-lookup"><span data-stu-id="299c2-216">In such cases it is recommended to configure these settings explicitly.</span></span>

## <a name="wcf-configuration-validation"></a><span data-ttu-id="299c2-217">WCF 組態驗證</span><span class="sxs-lookup"><span data-stu-id="299c2-217">WCF Configuration Validation</span></span>

<span data-ttu-id="299c2-218">Visual Studio 現在有一部分建置流程會驗證 WCF 組態檔。</span><span class="sxs-lookup"><span data-stu-id="299c2-218">As part of the build process within Visual Studio, WCF configuration files are now validated.</span></span> <span data-ttu-id="299c2-219">如果驗證失敗，將會在 Visual Studio 中顯示驗證錯誤或警告的清單。</span><span class="sxs-lookup"><span data-stu-id="299c2-219">A list of validation errors or warnings are displayed in Visual Studio if the validation fails.</span></span>

## <a name="xml-editor-tooltips"></a><span data-ttu-id="299c2-220">XML 編輯器工具提示</span><span class="sxs-lookup"><span data-stu-id="299c2-220">XML Editor Tooltips</span></span>

<span data-ttu-id="299c2-221">為了協助新的和現有的 WCF 服務開發人員設定其服務，現在每個屬於服務組態檔之一部分的組態項目及其屬性，Visual Studio XML 編輯器都有提供工具提示。</span><span class="sxs-lookup"><span data-stu-id="299c2-221">In order to help new and existing WCF service developers to configure their services, the Visual Studio XML editor now provides tooltips for every configuration element and its properties that is part of the service configuration file.</span></span>

## <a name="basichttpbinding-improvements"></a><span data-ttu-id="299c2-222">BasicHttpBinding 的改進</span><span class="sxs-lookup"><span data-stu-id="299c2-222">BasicHttpBinding Improvements</span></span>

1. <span data-ttu-id="299c2-223">可讓單一 WCF 端點回應不同的驗證模式。</span><span class="sxs-lookup"><span data-stu-id="299c2-223">Enables a single WCF endpoint to respond to different authentication modes.</span></span>

2. <span data-ttu-id="299c2-224">可讓 WCF 服務的安全性設定由 IIS 來控制</span><span class="sxs-lookup"><span data-stu-id="299c2-224">Enables a WCF service’s security settings to be controlled by IIS</span></span>
