---
title: 傳送和接收錯誤
description: 瞭解當發生錯誤狀況時，服務或雙工用戶端如何傳送 SOAP 錯誤，以及用戶端或服務應用程式如何處理這些錯誤。
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- handling faults [WCF], sending
ms.assetid: 7be6fb96-ce2a-450b-aebe-f932c6a4bc5d
ms.openlocfilehash: 23f63fde2755a29cd545d3aefe699cad8dbecb3b
ms.sourcegitcommit: 358a28048f36a8dca39a9fe6e6ac1f1913acadd5
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 06/23/2020
ms.locfileid: "85244318"
---
# <a name="sending-and-receiving-faults"></a><span data-ttu-id="c99cb-103">傳送和接收錯誤</span><span class="sxs-lookup"><span data-stu-id="c99cb-103">Sending and Receiving Faults</span></span>

<span data-ttu-id="c99cb-104">SOAP 錯誤會將錯誤狀況資訊從服務傳送到用戶端，而在雙工案例中，則是以互通的方式從用戶端傳送到服務。</span><span class="sxs-lookup"><span data-stu-id="c99cb-104">SOAP faults convey error condition information from a service to a client and in the duplex case from a client to a service in an interoperable way.</span></span> <span data-ttu-id="c99cb-105">一般來說，服務會定義自訂錯誤內容，並指定透過哪項作業來傳回這些內容</span><span class="sxs-lookup"><span data-stu-id="c99cb-105">Typically a service defines custom fault content and specifies which operations can return them.</span></span> <span data-ttu-id="c99cb-106">（如需詳細資訊，請參閱[定義和指定錯誤](defining-and-specifying-faults.md)）。本主題討論當發生對應的錯誤狀況，以及用戶端或服務應用程式如何處理這些錯誤時，服務或雙工用戶端可以傳送這些錯誤的方式。</span><span class="sxs-lookup"><span data-stu-id="c99cb-106">(For more information, see [Defining and Specifying Faults](defining-and-specifying-faults.md).) This topic discusses how a service or duplex client can send those faults when the corresponding error condition has occurred and how a client or service application handles these faults.</span></span> <span data-ttu-id="c99cb-107">如需 Windows Communication Foundation （WCF）應用程式中錯誤處理的總覽，請參閱[指定和處理合約和服務中](specifying-and-handling-faults-in-contracts-and-services.md)的錯誤。</span><span class="sxs-lookup"><span data-stu-id="c99cb-107">For an overview of error handling in Windows Communication Foundation (WCF) applications, see [Specifying and Handling Faults in Contracts and Services](specifying-and-handling-faults-in-contracts-and-services.md).</span></span>

## <a name="sending-soap-faults"></a><span data-ttu-id="c99cb-108">傳送 SOAP 錯誤</span><span class="sxs-lookup"><span data-stu-id="c99cb-108">Sending SOAP Faults</span></span>

<span data-ttu-id="c99cb-109">已宣告的 SOAP 錯誤是其中作業具有指定自訂 SOAP 錯誤類型之 <xref:System.ServiceModel.FaultContractAttribute?displayProperty=nameWithType>的 SOAP 錯誤。</span><span class="sxs-lookup"><span data-stu-id="c99cb-109">Declared SOAP faults are those in which an operation has a <xref:System.ServiceModel.FaultContractAttribute?displayProperty=nameWithType> that specifies a custom SOAP fault type.</span></span> <span data-ttu-id="c99cb-110">未宣告的 SOAP 錯誤則是在作業的合約中未指定的 SOAP 錯誤。</span><span class="sxs-lookup"><span data-stu-id="c99cb-110">Undeclared SOAP faults are those that are not specified in the contract for an operation.</span></span>

### <a name="sending-declared-faults"></a><span data-ttu-id="c99cb-111">傳送已宣告的錯誤</span><span class="sxs-lookup"><span data-stu-id="c99cb-111">Sending Declared Faults</span></span>

<span data-ttu-id="c99cb-112">若要傳送已宣告的 SOAP 錯誤，請偵測包含適當 SOAP 錯誤的錯誤情況並擲回新的 <xref:System.ServiceModel.FaultException%601?displayProperty=nameWithType>，其中的型別參數為該作業之 <xref:System.ServiceModel.FaultContractAttribute> 中所指定的新物件型別。</span><span class="sxs-lookup"><span data-stu-id="c99cb-112">To send a declared SOAP fault, detect the error condition for which the SOAP fault is appropriate and throw a new <xref:System.ServiceModel.FaultException%601?displayProperty=nameWithType> where the type parameter is a new object of the type specified in the <xref:System.ServiceModel.FaultContractAttribute> for that operation.</span></span> <span data-ttu-id="c99cb-113">下列程式碼範例將示範如何使用 <xref:System.ServiceModel.FaultContractAttribute> 來指定 `SampleMethod` 作業可以傳回 SOAP 錯誤，連同 `GreetingFault` 的詳細型別。</span><span class="sxs-lookup"><span data-stu-id="c99cb-113">The following code example shows the use of <xref:System.ServiceModel.FaultContractAttribute> to specify that the `SampleMethod` operation can return a SOAP fault with the detail type of `GreetingFault`.</span></span>

[!code-csharp[FaultContractAttribute#4](../../../samples/snippets/csharp/VS_Snippets_CFX/faultcontractattribute/cs/services.cs#4)]
[!code-vb[FaultContractAttribute#4](../../../samples/snippets/visualbasic/VS_Snippets_CFX/faultcontractattribute/vb/services.vb#4)]

<span data-ttu-id="c99cb-114">若要將 `GreetingFault` 錯誤資訊傳送到用戶端，請捕捉適當的錯誤情況並擲回包含新的 <xref:System.ServiceModel.FaultException%601?displayProperty=nameWithType> 物件之新的 `GreetingFault` (屬於 `GreetingFault` 型別) 做為引數，如下列程式碼範例所示。</span><span class="sxs-lookup"><span data-stu-id="c99cb-114">To convey the `GreetingFault` error information to the client, catch the appropriate error condition and throw a new <xref:System.ServiceModel.FaultException%601?displayProperty=nameWithType> of type `GreetingFault` with a new `GreetingFault` object as the argument, as in the following code example.</span></span> <span data-ttu-id="c99cb-115">如果用戶端是 WCF 用戶端應用程式，它會將此視為屬於類型的 managed 例外狀況 <xref:System.ServiceModel.FaultException%601?displayProperty=nameWithType> `GreetingFault` 。</span><span class="sxs-lookup"><span data-stu-id="c99cb-115">If the client is an WCF client application, it experiences this as a managed exception where the type is <xref:System.ServiceModel.FaultException%601?displayProperty=nameWithType> of type `GreetingFault`.</span></span>

[!code-csharp[FaultContractAttribute#5](../../../samples/snippets/csharp/VS_Snippets_CFX/faultcontractattribute/cs/services.cs#5)]
[!code-vb[FaultContractAttribute#5](../../../samples/snippets/visualbasic/VS_Snippets_CFX/faultcontractattribute/vb/services.vb#5)]

### <a name="sending-undeclared-faults"></a><span data-ttu-id="c99cb-116">傳送未宣告的錯誤</span><span class="sxs-lookup"><span data-stu-id="c99cb-116">Sending Undeclared Faults</span></span>

<span data-ttu-id="c99cb-117">傳送未宣告的錯誤可能非常適合用來在 WCF 應用程式中快速診斷和偵測問題，但它的實用性會受到限制。</span><span class="sxs-lookup"><span data-stu-id="c99cb-117">Sending undeclared faults can be very useful to quickly diagnose and debug problems in WCF applications, but its usefulness as a debugging tool is limited.</span></span> <span data-ttu-id="c99cb-118">在偵錯時，使用 <xref:System.ServiceModel.Description.ServiceDebugBehavior.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType> 屬性是較普遍的建議做法。</span><span class="sxs-lookup"><span data-stu-id="c99cb-118">More generally, when debugging it is recommended that you use the <xref:System.ServiceModel.Description.ServiceDebugBehavior.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="c99cb-119">當您將此值設為 true，用戶端會碰到諸如 <xref:System.ServiceModel.FaultException%601> 類別的 <xref:System.ServiceModel.ExceptionDetail> 例外狀況之類的錯誤。</span><span class="sxs-lookup"><span data-stu-id="c99cb-119">When you set this value to true, clients experience such faults as <xref:System.ServiceModel.FaultException%601> exceptions of type <xref:System.ServiceModel.ExceptionDetail>.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="c99cb-120">因為 managed 例外狀況可以公開內部應用程式資訊，所以將 <xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType> 或設定 <xref:System.ServiceModel.Description.ServiceDebugBehavior.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType> 為 `true` 可允許 WCF 用戶端取得內部服務作業例外狀況的相關資訊，包括個人標識或其他機密資訊。</span><span class="sxs-lookup"><span data-stu-id="c99cb-120">Because managed exceptions can expose internal application information, setting <xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType> or <xref:System.ServiceModel.Description.ServiceDebugBehavior.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType> to `true` can permit WCF clients to obtain information about internal service operation exceptions, including personally identifiable or other sensitive information.</span></span>
>
> <span data-ttu-id="c99cb-121">因此，若您只是暫時對服務應用程式進行偵錯，才建議把 <xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType> 或 <xref:System.ServiceModel.Description.ServiceDebugBehavior.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType> 設為 `true`。</span><span class="sxs-lookup"><span data-stu-id="c99cb-121">Therefore, setting <xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType> or <xref:System.ServiceModel.Description.ServiceDebugBehavior.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType> to `true` is only recommended as a way of temporarily debugging a service application.</span></span> <span data-ttu-id="c99cb-122">此外，若某個方法以這種方式傳回未處理的 Managed 例外狀況，則該方法的 WSDL 不會包含 <xref:System.ServiceModel.FaultException%601> 型別之 <xref:System.ServiceModel.ExceptionDetail> 的合約。</span><span class="sxs-lookup"><span data-stu-id="c99cb-122">In addition, the WSDL for a method that returns unhandled managed exceptions in this way does not contain the contract for the <xref:System.ServiceModel.FaultException%601> of type <xref:System.ServiceModel.ExceptionDetail>.</span></span> <span data-ttu-id="c99cb-123">用戶端必須預期會有未知的 SOAP 錯誤（以物件的形式傳回給 WCF 用戶端 <xref:System.ServiceModel.FaultException?displayProperty=nameWithType> ），才能正確取得偵錯工具資訊。</span><span class="sxs-lookup"><span data-stu-id="c99cb-123">Clients must expect the possibility of an unknown SOAP fault (returned to WCF clients as <xref:System.ServiceModel.FaultException?displayProperty=nameWithType> objects) to obtain the debugging information properly.</span></span>

<span data-ttu-id="c99cb-124">若要傳送未宣告的 SOAP 錯誤，請擲回 <xref:System.ServiceModel.FaultException?displayProperty=nameWithType> 物件 (亦即，不是泛型 <xref:System.ServiceModel.FaultException%601> 型別)，並將字串傳送至建構函式。</span><span class="sxs-lookup"><span data-stu-id="c99cb-124">To send an undeclared SOAP fault, throw a <xref:System.ServiceModel.FaultException?displayProperty=nameWithType> object (that is, not the generic type <xref:System.ServiceModel.FaultException%601>) and pass the string to the constructor.</span></span> <span data-ttu-id="c99cb-125">這會公開給 WCF 用戶端應用程式，做為擲回的 <xref:System.ServiceModel.FaultException?displayProperty=nameWithType> 例外狀況，其中字串可透過呼叫方法來取得 <xref:System.ServiceModel.FaultException%601.ToString%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="c99cb-125">This is exposed to the WCF client applications as a thrown <xref:System.ServiceModel.FaultException?displayProperty=nameWithType> exception where the string is available by calling the <xref:System.ServiceModel.FaultException%601.ToString%2A?displayProperty=nameWithType> method.</span></span>

> [!NOTE]
> <span data-ttu-id="c99cb-126">如果您宣告 String 型別的 SOAP 錯誤，則請將此項目做為 <xref:System.ServiceModel.FaultException%601> 擲回服務 (當中的型別參數是一個 <xref:System.String?displayProperty=nameWithType>，而字串值則是指派給 <xref:System.ServiceModel.FaultException%601.Detail%2A?displayProperty=nameWithType> 屬性，而且無法透過 <xref:System.ServiceModel.FaultException%601.ToString%2A?displayProperty=nameWithType> 取得)。</span><span class="sxs-lookup"><span data-stu-id="c99cb-126">If you declare a SOAP fault of type string, and then throw this in your service as a <xref:System.ServiceModel.FaultException%601> where the type parameter is a <xref:System.String?displayProperty=nameWithType> the string value is assigned to the <xref:System.ServiceModel.FaultException%601.Detail%2A?displayProperty=nameWithType> property, and is not available from <xref:System.ServiceModel.FaultException%601.ToString%2A?displayProperty=nameWithType>.</span></span>

## <a name="handling-faults"></a><span data-ttu-id="c99cb-127">處理錯誤</span><span class="sxs-lookup"><span data-stu-id="c99cb-127">Handling Faults</span></span>

<span data-ttu-id="c99cb-128">在 WCF 用戶端中，在與用戶端應用程式感興趣的通訊期間發生的 SOAP 錯誤，會引發為 managed 例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c99cb-128">In WCF clients, SOAP faults that occur during communication that are of interest to client applications are raised as managed exceptions.</span></span> <span data-ttu-id="c99cb-129">雖然在執行任何程式時可能會發生許多例外狀況，但使用 WCF 用戶端程式設計模型的應用程式可能會預期會因通訊而處理下列兩種類型的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c99cb-129">While there are many exceptions that can occur during the execution of any program, applications using the WCF client programming model can expect to handle exceptions of the following two types as a result of communication.</span></span>

- <xref:System.TimeoutException>

- <xref:System.ServiceModel.CommunicationException>

<span data-ttu-id="c99cb-130">當作業超出指定的逾時期間，就會擲回 <xref:System.TimeoutException> 物件。</span><span class="sxs-lookup"><span data-stu-id="c99cb-130"><xref:System.TimeoutException> objects are thrown when an operation exceeds the specified timeout period.</span></span>

<span data-ttu-id="c99cb-131">當服務或用戶端上出現一些可修復的通訊錯誤情況，就會擲回 <xref:System.ServiceModel.CommunicationException> 物件。</span><span class="sxs-lookup"><span data-stu-id="c99cb-131"><xref:System.ServiceModel.CommunicationException> objects are thrown when there is some recoverable communication error condition on either the service or the client.</span></span>

<span data-ttu-id="c99cb-132"><xref:System.ServiceModel.CommunicationException> 類別包含兩個重要的衍生型別，分別是 <xref:System.ServiceModel.FaultException> 和泛型 <xref:System.ServiceModel.FaultException%601> 型別。</span><span class="sxs-lookup"><span data-stu-id="c99cb-132">The <xref:System.ServiceModel.CommunicationException> class has two important derived types, <xref:System.ServiceModel.FaultException> and the generic <xref:System.ServiceModel.FaultException%601> type.</span></span>

<span data-ttu-id="c99cb-133">當接聽項收到未預期的或於作業合約中指定的錯誤，就會擲回 <xref:System.ServiceModel.FaultException> 例外狀況；當針對應用程式進行偵錯，且服務的 <xref:System.ServiceModel.Description.ServiceDebugBehavior.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType> 屬性設為 `true` 時，就很容易發生這個情況。</span><span class="sxs-lookup"><span data-stu-id="c99cb-133"><xref:System.ServiceModel.FaultException> exceptions are thrown when a listener receives a fault that is not expected or specified in the operation contract; usually this occurs when the application is being debugged and the service has the <xref:System.ServiceModel.Description.ServiceDebugBehavior.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType> property set to `true`.</span></span>

<span data-ttu-id="c99cb-134">收到作業合約中指定的錯誤時，用戶端會擲回 <xref:System.ServiceModel.FaultException%601> 例外狀況，以回應雙向作業 (也就是具有 <xref:System.ServiceModel.OperationContractAttribute> 屬性，且將 <xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A> 設為 `false` 的方法)。</span><span class="sxs-lookup"><span data-stu-id="c99cb-134"><xref:System.ServiceModel.FaultException%601> exceptions are thrown on the client when a fault that is specified in the operation contract is received in response to a two-way operation (that is, a method with an <xref:System.ServiceModel.OperationContractAttribute> attribute with <xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A> set to `false`).</span></span>

> [!NOTE]
> <span data-ttu-id="c99cb-135">當 WCF 服務將 <xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType> 或 <xref:System.ServiceModel.Description.ServiceDebugBehavior.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType> 屬性設定為時 `true` ，用戶端會將此體驗為未宣告 <xref:System.ServiceModel.FaultException%601> 的類型 <xref:System.ServiceModel.ExceptionDetail> 。</span><span class="sxs-lookup"><span data-stu-id="c99cb-135">When an WCF service has the <xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType> or <xref:System.ServiceModel.Description.ServiceDebugBehavior.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType> property set to `true` the client experiences this as an undeclared <xref:System.ServiceModel.FaultException%601> of type <xref:System.ServiceModel.ExceptionDetail>.</span></span> <span data-ttu-id="c99cb-136">用戶端可以捕捉此特定錯誤，或是在 <xref:System.ServiceModel.FaultException> 的 catch 區塊中處理此錯誤。</span><span class="sxs-lookup"><span data-stu-id="c99cb-136">Clients can either catch this specific fault or handle the fault in a catch block for <xref:System.ServiceModel.FaultException>.</span></span>

<span data-ttu-id="c99cb-137">一般來說，只有 <xref:System.ServiceModel.FaultException%601>、<xref:System.TimeoutException>，和 <xref:System.ServiceModel.CommunicationException> 例外狀況會與用戶端及服務相關。</span><span class="sxs-lookup"><span data-stu-id="c99cb-137">Typically, only <xref:System.ServiceModel.FaultException%601>, <xref:System.TimeoutException>, and <xref:System.ServiceModel.CommunicationException> exceptions are of interest to clients and services.</span></span>

> [!NOTE]
> <span data-ttu-id="c99cb-138">而其他例外狀況，當然一定會發生。</span><span class="sxs-lookup"><span data-stu-id="c99cb-138">Other exceptions, of course, do occur.</span></span> <span data-ttu-id="c99cb-139">未預期的例外狀況包含 <xref:System.OutOfMemoryException?displayProperty=nameWithType> 之類的災難性失敗；一般來說，應用程式應該不會捕捉到這類方法。</span><span class="sxs-lookup"><span data-stu-id="c99cb-139">Unexpected exceptions include catastrophic failures like <xref:System.OutOfMemoryException?displayProperty=nameWithType>; typically applications should not catch such methods.</span></span>

### <a name="catch-fault-exceptions-in-the-correct-order"></a><span data-ttu-id="c99cb-140">以正確順序來捕捉錯誤例外狀況</span><span class="sxs-lookup"><span data-stu-id="c99cb-140">Catch Fault Exceptions in the Correct Order</span></span>

<span data-ttu-id="c99cb-141">由於 <xref:System.ServiceModel.FaultException%601> 係衍生自 <xref:System.ServiceModel.FaultException>，而 <xref:System.ServiceModel.FaultException> 則是衍生自 <xref:System.ServiceModel.CommunicationException>，請務必以正確順序來捕捉這些例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c99cb-141">Because <xref:System.ServiceModel.FaultException%601> derives from <xref:System.ServiceModel.FaultException>, and <xref:System.ServiceModel.FaultException> derives from <xref:System.ServiceModel.CommunicationException>, it is important to catch these exceptions in the proper order.</span></span> <span data-ttu-id="c99cb-142">例如，假如在您第一次捕捉 <xref:System.ServiceModel.CommunicationException> 時使用 try/catch 區塊，則所有指定與未指定的 SOAP 錯誤都會就地處理；而且一律不會叫用任何後續的 catch 區塊來處理自訂 <xref:System.ServiceModel.FaultException%601> 例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c99cb-142">If, for example, you have a try/catch block in which you first catch <xref:System.ServiceModel.CommunicationException>, all specified and unspecified SOAP faults are handled there; any subsequent catch blocks to handle a custom <xref:System.ServiceModel.FaultException%601> exception are never invoked.</span></span>

<span data-ttu-id="c99cb-143">請記住，一項作業可以傳回的指定錯誤數量不限。</span><span class="sxs-lookup"><span data-stu-id="c99cb-143">Remember that one operation can return any number of specified faults.</span></span> <span data-ttu-id="c99cb-144">每一項錯誤都具有唯一的型別，而且必須個別處理。</span><span class="sxs-lookup"><span data-stu-id="c99cb-144">Each fault is a unique type and must be handled separately.</span></span>

### <a name="handle-exceptions-when-closing-the-channel"></a><span data-ttu-id="c99cb-145">關閉通道時處理例外狀況</span><span class="sxs-lookup"><span data-stu-id="c99cb-145">Handle Exceptions When Closing the Channel</span></span>

<span data-ttu-id="c99cb-146">上述討論大多與處理應用程式訊息時所傳送的錯誤有關，也就是用戶端應用程式在 WCF 用戶端物件上呼叫作業時，會明確傳送的訊息。</span><span class="sxs-lookup"><span data-stu-id="c99cb-146">Most of the preceding discussion has to do with faults sent in the course of processing application messages, that is, messages explicitly sent by the client when the client application calls operations on the WCF client object.</span></span>

<span data-ttu-id="c99cb-147">就算是本機物件，處理物件也可能引發或遮罩在回收處理序期間所發生的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c99cb-147">Even with local objects disposing the object can either raise or mask exceptions that occur during the recycling process.</span></span> <span data-ttu-id="c99cb-148">當您使用 WCF 用戶端物件時，可能會發生類似的問題。</span><span class="sxs-lookup"><span data-stu-id="c99cb-148">Something similar can occur when you use WCF client objects.</span></span> <span data-ttu-id="c99cb-149">當您呼叫作業時，事實上您是透過已建立的連線來傳送訊息。</span><span class="sxs-lookup"><span data-stu-id="c99cb-149">When you call operations you are sending messages over an established connection.</span></span> <span data-ttu-id="c99cb-150">如果連線無法完全關閉，或是已經關閉，則關閉通道會擲回例外狀況，就算所有作業都正常傳回也是一樣。</span><span class="sxs-lookup"><span data-stu-id="c99cb-150">Closing the channel can throw exceptions if the connection cannot be cleanly closed or is already closed, even if all the operations returned properly.</span></span>

<span data-ttu-id="c99cb-151">一般來說，用戶端物件通道可透過下列其中一種方式來關閉：</span><span class="sxs-lookup"><span data-stu-id="c99cb-151">Typically, client object channels are closed in one of the following ways:</span></span>

- <span data-ttu-id="c99cb-152">當 WCF 用戶端物件被回收時。</span><span class="sxs-lookup"><span data-stu-id="c99cb-152">When the WCF client object is recycled.</span></span>

- <span data-ttu-id="c99cb-153">當用戶端應用程式呼叫 <xref:System.ServiceModel.ClientBase%601.Close%2A?displayProperty=nameWithType> 時。</span><span class="sxs-lookup"><span data-stu-id="c99cb-153">When the client application calls <xref:System.ServiceModel.ClientBase%601.Close%2A?displayProperty=nameWithType>.</span></span>

- <span data-ttu-id="c99cb-154">當用戶端應用程式呼叫 <xref:System.ServiceModel.ICommunicationObject.Close%2A?displayProperty=nameWithType> 時。</span><span class="sxs-lookup"><span data-stu-id="c99cb-154">When the client application calls <xref:System.ServiceModel.ICommunicationObject.Close%2A?displayProperty=nameWithType>.</span></span>

- <span data-ttu-id="c99cb-155">當用戶端應用程式呼叫某個正在終止工作階段作業的作業時。</span><span class="sxs-lookup"><span data-stu-id="c99cb-155">When the client application calls an operation that is a terminating operation for a session.</span></span>

<span data-ttu-id="c99cb-156">不管什麼情況，關閉通道都會讓通道開始關閉任何基礎通道，進而傳送訊息以支援應用程式層級的複雜功能。</span><span class="sxs-lookup"><span data-stu-id="c99cb-156">In all cases, closing the channel instructs the channel to begin closing any underlying channels that may be sending messages to support complex functionality at the application level.</span></span> <span data-ttu-id="c99cb-157">例如，當合約需要工作階段嘗試透過繫結來建立工作階段時 (方法是藉由與服務通道交換訊息，直到建立工作階段為止)。</span><span class="sxs-lookup"><span data-stu-id="c99cb-157">For example, when a contract requires sessions a binding attempts to establish a session by exchanging messages with the service channel until a session is established.</span></span> <span data-ttu-id="c99cb-158">一旦通道關閉，基礎工作階段通道會通知服務，工作階段已經終止。</span><span class="sxs-lookup"><span data-stu-id="c99cb-158">When the channel is closed, the underlying session channel notifies the service that the session is terminated.</span></span> <span data-ttu-id="c99cb-159">在此情況下，如果通道已經中止、關閉，或是因為其他原因而無法使用 (例如，當網路纜線已拔除時)，用戶端通道將無法通知服務通道，告知工作階段已終止且可能擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c99cb-159">In this case, if the channel has already aborted, closed, or is otherwise unusable (for example, when a network cable is unplugged), the client channel cannot inform the service channel that the session is terminated and an exception can result.</span></span>

### <a name="abort-the-channel-if-necessary"></a><span data-ttu-id="c99cb-160">必要時中止通道</span><span class="sxs-lookup"><span data-stu-id="c99cb-160">Abort the Channel If Necessary</span></span>

<span data-ttu-id="c99cb-161">由於關閉通道也可能會擲回例外狀況，因此我們建議您除了以正確順序來捕捉錯誤例外狀況外，務必記得要中止用來呼叫 catch 區塊的通道。</span><span class="sxs-lookup"><span data-stu-id="c99cb-161">Because closing the channel can also throw exceptions, then, it is recommended that in addition to catching fault exceptions in the correct order, it is important to abort the channel that was used in making the call in the catch block.</span></span>

<span data-ttu-id="c99cb-162">如果錯誤傳送了與某項作業相關的特定錯誤資訊，而其他作業也可能透過它來傳送資訊時，就不需要中止通道 (儘管這些情況很罕見)。</span><span class="sxs-lookup"><span data-stu-id="c99cb-162">If the fault conveys error information specific to an operation and it remains possible that others can use it, there is no need to abort the channel (although these cases are rare).</span></span> <span data-ttu-id="c99cb-163">在其他任何情況中，建議您中止通道。</span><span class="sxs-lookup"><span data-stu-id="c99cb-163">In all other cases, it is recommended that you abort the channel.</span></span> <span data-ttu-id="c99cb-164">如需示範所有這些點的範例，請參閱[預期的例外](./samples/expected-exceptions.md)狀況。</span><span class="sxs-lookup"><span data-stu-id="c99cb-164">For a sample that demonstrates all of these points, see [Expected Exceptions](./samples/expected-exceptions.md).</span></span>

<span data-ttu-id="c99cb-165">下列程式碼範例將說明如何透過基本用戶端應用程式來處理 SOAP 錯誤例外狀況，包括已宣告與未宣告的錯誤。</span><span class="sxs-lookup"><span data-stu-id="c99cb-165">The following code example shows how to handle SOAP fault exceptions in a basic client application, including a declared fault and an undeclared fault.</span></span>

> [!NOTE]
> <span data-ttu-id="c99cb-166">此範例程式碼不會使用 `using` 建構。</span><span class="sxs-lookup"><span data-stu-id="c99cb-166">This sample code does not use the `using` construct.</span></span> <span data-ttu-id="c99cb-167">由於關閉通道可能會擲回例外狀況，因此建議應用程式先建立 WCF 用戶端，然後在相同的 try 區塊中開啟、使用和關閉 WCF 用戶端。</span><span class="sxs-lookup"><span data-stu-id="c99cb-167">Because closing channels can throw exceptions, it is recommended that applications create a WCF client first, and then open, use, and close the WCF client in the same try block.</span></span> <span data-ttu-id="c99cb-168">如需詳細資訊，請參閱[Wcf 用戶端總覽](wcf-client-overview.md)和[使用關閉和中止來發行 WCF 用戶端資源](./samples/use-close-abort-release-wcf-client-resources.md)。</span><span class="sxs-lookup"><span data-stu-id="c99cb-168">For details, see [WCF Client Overview](wcf-client-overview.md) and [Use Close and Abort to release WCF client resources](./samples/use-close-abort-release-wcf-client-resources.md).</span></span>

[!code-csharp[FaultContractAttribute#3](../../../samples/snippets/csharp/VS_Snippets_CFX/faultcontractattribute/cs/client.cs#3)]
[!code-vb[FaultContractAttribute#3](../../../samples/snippets/visualbasic/VS_Snippets_CFX/faultcontractattribute/vb/client.vb#3)]

## <a name="see-also"></a><span data-ttu-id="c99cb-169">另請參閱</span><span class="sxs-lookup"><span data-stu-id="c99cb-169">See also</span></span>

- <xref:System.ServiceModel.FaultException>
- <xref:System.ServiceModel.FaultException%601>
- <xref:System.ServiceModel.CommunicationException?displayProperty=nameWithType>
- [<span data-ttu-id="c99cb-170">預期的例外狀況</span><span class="sxs-lookup"><span data-stu-id="c99cb-170">Expected Exceptions</span></span>](./samples/expected-exceptions.md)
- [<span data-ttu-id="c99cb-171">使用關閉和中止發行 WCF 用戶端資源</span><span class="sxs-lookup"><span data-stu-id="c99cb-171">Use Close and Abort to release WCF client resources</span></span>](./samples/use-close-abort-release-wcf-client-resources.md)
