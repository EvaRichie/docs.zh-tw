---
title: 控制資源使用並改善效能
ms.date: 03/30/2017
ms.assetid: 9a829669-5f76-4c88-80ec-92d0c62c0660
ms.openlocfilehash: f06dd0b7e66ae783b2f268551f15c5e6e8369b7f
ms.sourcegitcommit: bc293b14af795e0e999e3304dd40c0222cf2ffe4
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 11/26/2020
ms.locfileid: "96255061"
---
# <a name="controlling-resource-consumption-and-improving-performance"></a><span data-ttu-id="96c2c-102">控制資源使用並改善效能</span><span class="sxs-lookup"><span data-stu-id="96c2c-102">Controlling Resource Consumption and Improving Performance</span></span>

<span data-ttu-id="96c2c-103">本主題說明 Windows Communication Foundation (WCF) 架構的不同區域中的各種屬性，以控制資源耗用量並影響效能標準。</span><span class="sxs-lookup"><span data-stu-id="96c2c-103">This topic describes various properties in different areas of the Windows Communication Foundation (WCF) architecture that work to control resource consumption and affect performance metrics.</span></span>

## <a name="properties-that-constrain-resource-consumption-in-wcf"></a><span data-ttu-id="96c2c-104">WCF 中限制資源消耗的屬性</span><span class="sxs-lookup"><span data-stu-id="96c2c-104">Properties that Constrain Resource Consumption in WCF</span></span>

 <span data-ttu-id="96c2c-105">Windows Communication Foundation (WCF) 針對安全性或效能用途，在特定類型的進程上套用條件約束。</span><span class="sxs-lookup"><span data-stu-id="96c2c-105">Windows Communication Foundation (WCF) applies constraints on certain types of processes for either security or performance purposes.</span></span> <span data-ttu-id="96c2c-106">這些限制主要有兩種形式，可能是配額與節流閥。</span><span class="sxs-lookup"><span data-stu-id="96c2c-106">These constraints come in two main forms, either quotas and throttles.</span></span> <span data-ttu-id="96c2c-107">當達到或超過時，*配額* 會限制在系統中的某個時間點觸發立即例外狀況。</span><span class="sxs-lookup"><span data-stu-id="96c2c-107">*Quotas* are limits that when reached or exceeded trigger an immediate exception at some point in the system.</span></span> <span data-ttu-id="96c2c-108">節流 *是不會立即* 擲回例外狀況的限制。</span><span class="sxs-lookup"><span data-stu-id="96c2c-108">*Throttles* are limits that do not immediately cause an exception to be thrown.</span></span> <span data-ttu-id="96c2c-109">相反地，當達到節流閥限制時，仍將持續處理，但會在節流閥的值所設定的限制範圍內。</span><span class="sxs-lookup"><span data-stu-id="96c2c-109">Instead, when a throttle limit is reached, processing continues but within the limits set by that throttle value.</span></span> <span data-ttu-id="96c2c-110">此限制處理可能在其他地方觸發例外狀況，不過需視應用程式而定。</span><span class="sxs-lookup"><span data-stu-id="96c2c-110">This limited processing might trigger an exception elsewhere, but this depends upon the application.</span></span>

 <span data-ttu-id="96c2c-111">除了配額與節流閥之間的差異外，有些限制屬性位於序列化層級，有些位於傳輸層級，有些則在應用程式層級。</span><span class="sxs-lookup"><span data-stu-id="96c2c-111">In addition to the distinction between quotas and throttles, some constraining properties are located at the serialization level, some at the transport level, and some at the application level.</span></span> <span data-ttu-id="96c2c-112">例如，全由系統提供的傳輸繫結項目實作之 <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A?displayProperty=nameWithType> 配額，預設為 65,536 位元組，防止惡意用戶端利用消耗過多記憶體的方式，對服務發動阻絕服務攻擊 </span><span class="sxs-lookup"><span data-stu-id="96c2c-112">For example, the quota <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A?displayProperty=nameWithType>, which is implemented by all system-supplied transport binding elements, is set to 65,536 bytes by default to hinder malicious clients from engaging in denial-of-service attacks against a service by causing excessive memory consumption.</span></span> <span data-ttu-id="96c2c-113">(一般而言，您可調低此值以增進效能)。</span><span class="sxs-lookup"><span data-stu-id="96c2c-113">(Typically, you can increase performance by lowering this value.)</span></span>

 <span data-ttu-id="96c2c-114">序列化配額的範例為 <xref:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph%2A?displayProperty=nameWithType> 屬性，這種屬性會指定序列化程式在單一 <xref:System.Runtime.Serialization.DataContractSerializer.ReadObject%2A> 方法呼叫中，序列化或還原序列化的物件最大數量。</span><span class="sxs-lookup"><span data-stu-id="96c2c-114">An example of a serialization quota is the <xref:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph%2A?displayProperty=nameWithType> property, which specifies the maximum number of objects that the serializer serializes or deserializes in a single <xref:System.Runtime.Serialization.DataContractSerializer.ReadObject%2A> method call.</span></span> <span data-ttu-id="96c2c-115">應用程式層級的節流閥範例為 <xref:System.ServiceModel.Dispatcher.ServiceThrottle.MaxConcurrentSessions%2A?displayProperty=nameWithType> 屬性，其預設的同時工作階段通道連線數為 10 </span><span class="sxs-lookup"><span data-stu-id="96c2c-115">An example of an application-level throttle is the <xref:System.ServiceModel.Dispatcher.ServiceThrottle.MaxConcurrentSessions%2A?displayProperty=nameWithType> property, which by default restricts the number of concurrent sessionful channel connections to 10.</span></span> <span data-ttu-id="96c2c-116">(與配額不同，若達到此節流閥值，應用程式會持續處理，但不接受新工作階段通道，也就是說在其他工作階段通道結束之前，新用戶端將無法連接)。</span><span class="sxs-lookup"><span data-stu-id="96c2c-116">(Unlike the quotas, if this throttle value is reached, the application continues processing but accepts no new sessionful channels, which means that new clients cannot connect until one of the other sessionful channels is ended.)</span></span>

 <span data-ttu-id="96c2c-117">這些控制項在設計上是要提供緩和特定類型攻擊的現成方法，或是改善效能度量資訊，例如記憶體使用量、啟動時間等等。</span><span class="sxs-lookup"><span data-stu-id="96c2c-117">These controls are designed to provide an out-of-the-box mitigation against certain types of attacks or to improve performance metrics such as memory footprint, start-up time, and so on.</span></span> <span data-ttu-id="96c2c-118">然而，根據應用程式而定，這些控制項會阻礙服務應用程式的效能，甚至造成應用程式無法運作。</span><span class="sxs-lookup"><span data-stu-id="96c2c-118">However, depending on the application, these controls can impede service application performance or prevent the application from working at all.</span></span> <span data-ttu-id="96c2c-119">例如，設計處理視訊資料流的應用程式，可能很容易就超過預設的 <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A?displayProperty=nameWithType> 屬性。</span><span class="sxs-lookup"><span data-stu-id="96c2c-119">For example, an application designed to stream video can easily exceed the default <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="96c2c-120">本主題概述在所有 WCF 層級套用至應用程式的各種控制項，並描述取得有關設定是否阻礙應用程式之詳細資訊的各種方法，並說明修正各種問題的方式。</span><span class="sxs-lookup"><span data-stu-id="96c2c-120">This topic provides an overview of the various controls applied to applications at all levels of WCF, describes various ways to obtain more information about whether a setting is hindering your application, and describes ways to correct various problems.</span></span> <span data-ttu-id="96c2c-121">多數節流閥與某些配額可在應用程式層級取得，即使基底屬性為序列化或傳輸限制。</span><span class="sxs-lookup"><span data-stu-id="96c2c-121">Most throttles and some quotas are available at the application level, even when the base property is a serialization or transport constraint.</span></span> <span data-ttu-id="96c2c-122">例如，您可設定 <xref:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph%2A?displayProperty=nameWithType> 屬性使用服務類別上的 <xref:System.ServiceModel.ServiceBehaviorAttribute.MaxItemsInObjectGraph%2A?displayProperty=nameWithType> 屬性。</span><span class="sxs-lookup"><span data-stu-id="96c2c-122">For example, you can set the <xref:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph%2A?displayProperty=nameWithType> property using the <xref:System.ServiceModel.ServiceBehaviorAttribute.MaxItemsInObjectGraph%2A?displayProperty=nameWithType> property on the service class.</span></span>

> [!NOTE]
> <span data-ttu-id="96c2c-123">如果您有特定的問題，您應該先閱讀 [WCF 疑難排解快速入門](wcf-troubleshooting-quickstart.md) ，以查看您的問題是否 (，以及是否在其中列出解決方案) 。</span><span class="sxs-lookup"><span data-stu-id="96c2c-123">If you have a particular problem, you should first read the [WCF Troubleshooting Quickstart](wcf-troubleshooting-quickstart.md) to see whether your problem (and a solution) is listed there.</span></span>

 <span data-ttu-id="96c2c-124">限制序列化進程的屬性會列在 [資料的安全性考慮](./feature-details/security-considerations-for-data.md)中。</span><span class="sxs-lookup"><span data-stu-id="96c2c-124">Properties that restrict serialization processes are listed in [Security Considerations for Data](./feature-details/security-considerations-for-data.md).</span></span> <span data-ttu-id="96c2c-125">限制與傳輸相關的資源耗用量的屬性會列在 [傳輸配額](./feature-details/transport-quotas.md)中。</span><span class="sxs-lookup"><span data-stu-id="96c2c-125">Properties that restrict the consumption of resources related to transports are listed in [Transport Quotas](./feature-details/transport-quotas.md).</span></span> <span data-ttu-id="96c2c-126">限制消耗應用程式層資源的屬性為 <xref:System.ServiceModel.Dispatcher.ServiceThrottle> 類別之成員。</span><span class="sxs-lookup"><span data-stu-id="96c2c-126">Properties that restrict the consumption of resources at the application layer are the members of the <xref:System.ServiceModel.Dispatcher.ServiceThrottle> class.</span></span>

## <a name="detecting-application-and-performance-issues-related-to-quota-settings"></a><span data-ttu-id="96c2c-127">偵測應用程式及與配額設定值相關的效能問題</span><span class="sxs-lookup"><span data-stu-id="96c2c-127">Detecting Application and Performance Issues Related to Quota Settings</span></span>

 <span data-ttu-id="96c2c-128">上述值的預設值選取原則是讓各種應用程式類別都能有基本應用程式功能，同時提供對一般安全性問題的基本保護。</span><span class="sxs-lookup"><span data-stu-id="96c2c-128">The defaults of the preceding values have been chosen to enable basic application functionality across a wide range of application types while providing basic protection against common security issues.</span></span> <span data-ttu-id="96c2c-129">然而，不同應用程式的設計可能會超出一個或更多個節流閥的設定值 (雖然在其他方面，應用程式依然安全，且一如往常般運作)。</span><span class="sxs-lookup"><span data-stu-id="96c2c-129">However, different application designs might exceed one or more throttle settings although the application otherwise is secure and would work as designed.</span></span> <span data-ttu-id="96c2c-130">出現這些狀況時，您必須找出是哪些節流閥值被超過以及超過多少，然後決定應對方法以增加應用程式的輸送量。</span><span class="sxs-lookup"><span data-stu-id="96c2c-130">In these cases, you must identify which throttle values are being exceeded and at what level, and decide on the appropriate course of action to increase application throughput.</span></span>

 <span data-ttu-id="96c2c-131">一般而言，撰寫應用程式與偵錯時，您會在組態檔或以程式設計的方式，將 <xref:System.ServiceModel.Description.ServiceDebugBehavior.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType> 屬性設為 `true`。</span><span class="sxs-lookup"><span data-stu-id="96c2c-131">Typically, when writing the application and debugging it, you set the <xref:System.ServiceModel.Description.ServiceDebugBehavior.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType> property to `true` in the configuration file or programmatically.</span></span> <span data-ttu-id="96c2c-132">這會指示 WCF 將服務例外狀況堆疊追蹤傳回給用戶端應用程式以供查看。</span><span class="sxs-lookup"><span data-stu-id="96c2c-132">This instructs WCF to return service exception stack traces to the client application for viewing.</span></span> <span data-ttu-id="96c2c-133">此功能會報告多數的應用程式層級例外狀況，顯示可能造成問題的配額值 (若該值為問題所在)。</span><span class="sxs-lookup"><span data-stu-id="96c2c-133">This feature reports most application-level exceptions in such a way as to display which quota settings might be involved, if that is the problem.</span></span>

 <span data-ttu-id="96c2c-134">有些例外狀況會在執行階段在低於應用程式層可見範圍之下發生，並且無法使用此機制傳回，這些例外可能無法透過自訂的 <xref:System.ServiceModel.Dispatcher.IErrorHandler?displayProperty=nameWithType> 實作來處理。</span><span class="sxs-lookup"><span data-stu-id="96c2c-134">Some exceptions happen at run time below the visibility of the application layer and are not returned using this mechanism, and they might not be handled by a custom <xref:System.ServiceModel.Dispatcher.IErrorHandler?displayProperty=nameWithType> implementation.</span></span> <span data-ttu-id="96c2c-135">如果您處於像是 Microsoft Visual Studio 的開發環境之下，這些例外狀況大多會自動顯示。</span><span class="sxs-lookup"><span data-stu-id="96c2c-135">If you are in a development environment like Microsoft Visual Studio, most of these exceptions are displayed automatically.</span></span> <span data-ttu-id="96c2c-136">不過，某些例外可由開發環境設定（例如 [Just My Code](/visualstudio/debugger/just-my-code) Visual Studio）遮罩。</span><span class="sxs-lookup"><span data-stu-id="96c2c-136">However, some exceptions can be masked by development environment settings such as [Just My Code](/visualstudio/debugger/just-my-code) Visual Studio.</span></span>

 <span data-ttu-id="96c2c-137">無論開發環境的功能有哪些，您都可以使用 WCF 追蹤和訊息記錄的功能來偵測所有例外狀況，並調整應用程式的效能。</span><span class="sxs-lookup"><span data-stu-id="96c2c-137">Regardless of the capabilities of your development environment, you can use capabilities of WCF tracing and message logging to debug all exceptions and tune the performance of your applications.</span></span> <span data-ttu-id="96c2c-138">如需詳細資訊，請參閱 [使用追蹤對您的應用程式進行疑難排解](./diagnostics/tracing/using-tracing-to-troubleshoot-your-application.md)。</span><span class="sxs-lookup"><span data-stu-id="96c2c-138">For more information, see [Using Tracing to Troubleshoot Your Application](./diagnostics/tracing/using-tracing-to-troubleshoot-your-application.md).</span></span>

## <a name="performance-issues-and-xmlserializer"></a><span data-ttu-id="96c2c-139">效能問題與 XmlSerializer</span><span class="sxs-lookup"><span data-stu-id="96c2c-139">Performance Issues and XmlSerializer</span></span>

 <span data-ttu-id="96c2c-140">使用資料型別 (可使用 <xref:System.Xml.Serialization.XmlSerializer> 加以序列化) 的服務和用戶端應用程式會在執行階段針對這些資料型別產生和編譯序列化程式碼，這可能會導致啟動的效能變慢。</span><span class="sxs-lookup"><span data-stu-id="96c2c-140">Services and client applications that use data types that are serializable using the <xref:System.Xml.Serialization.XmlSerializer> generate and compile serialization code for those data types at run time, which can result in slow start-up performance.</span></span>

> [!NOTE]
> <span data-ttu-id="96c2c-141">預先產生的序列化程式碼只能用於用戶端應用程式中，而不能用於服務中。</span><span class="sxs-lookup"><span data-stu-id="96c2c-141">Pre-generated serialization code can be used only in client applications and not in services.</span></span>

 <span data-ttu-id="96c2c-142">[System.servicemodel Metadata Utility Tool ( # A0) ](servicemodel-metadata-utility-tool-svcutil-exe.md)可以從應用程式的已編譯元件產生必要的序列化程式碼，藉此改善這些應用程式的啟動效能。</span><span class="sxs-lookup"><span data-stu-id="96c2c-142">The [ServiceModel Metadata Utility Tool (Svcutil.exe)](servicemodel-metadata-utility-tool-svcutil-exe.md) can improve start-up performance for these applications by generating the necessary serialization code from the compiled assemblies for the application.</span></span> <span data-ttu-id="96c2c-143">如需詳細資訊，請參閱 [如何：使用 XmlSerializer 改善 WCF 用戶端應用程式的啟動時間](./feature-details/startup-time-of-wcf-client-applications-using-the-xmlserializer.md)。</span><span class="sxs-lookup"><span data-stu-id="96c2c-143">For more information, see [How to: Improve the Startup Time of WCF Client Applications using the XmlSerializer](./feature-details/startup-time-of-wcf-client-applications-using-the-xmlserializer.md).</span></span>

## <a name="performance-issues-when-hosting-wcf-services-under-aspnet"></a><span data-ttu-id="96c2c-144">在 ASP.NET 下裝載 WCF 服務時的效能問題</span><span class="sxs-lookup"><span data-stu-id="96c2c-144">Performance Issues When Hosting WCF Services Under ASP.NET</span></span>

<span data-ttu-id="96c2c-145">在 IIS 和 ASP.NET 下裝載 WCF 服務時，IIS 和 ASP.NET 的組態設定可能會影響 WCF 服務的處理量和記憶體使用量。</span><span class="sxs-lookup"><span data-stu-id="96c2c-145">When a WCF service is hosted under IIS and ASP.NET, the configuration settings of IIS and ASP.NET can affect the throughput and memory footprint of the WCF service.</span></span>  <span data-ttu-id="96c2c-146">如需有關 ASP.NET 效能的詳細資訊，請參閱 [改善 ASP.NET 效能](/previous-versions/msp-n-p/ff647787(v=pandp.10))。</span><span class="sxs-lookup"><span data-stu-id="96c2c-146">For more information about ASP.NET performance, see [Improving ASP.NET Performance](/previous-versions/msp-n-p/ff647787(v=pandp.10)).</span></span> <span data-ttu-id="96c2c-147">一個可能會造成意外結果的設定是 <xref:System.Web.Configuration.ProcessModelSection.MinWorkerThreads%2A> 的屬性 <xref:System.Web.Configuration.ProcessModelSection>。</span><span class="sxs-lookup"><span data-stu-id="96c2c-147">One setting that might have unintended consequences is <xref:System.Web.Configuration.ProcessModelSection.MinWorkerThreads%2A>, which is a property of the <xref:System.Web.Configuration.ProcessModelSection>.</span></span> <span data-ttu-id="96c2c-148">如果您的應用程式有固定或少量的用戶端，將 <xref:System.Web.Configuration.ProcessModelSection.MinWorkerThreads%2A> 設定為 2 可能會讓 CPU 使用率接近 100% 的多處理器電腦提高處理量。</span><span class="sxs-lookup"><span data-stu-id="96c2c-148">If your application has a fixed or small number of clients, setting <xref:System.Web.Configuration.ProcessModelSection.MinWorkerThreads%2A> to 2 might provide a throughput boost on a multiprocessor machine that has a CPU utilization close to 100%.</span></span> <span data-ttu-id="96c2c-149">但提高效能有其代價：這也會造成記憶體使用量增加，因而減少延展性。</span><span class="sxs-lookup"><span data-stu-id="96c2c-149">This increase in performance comes with a cost: it will also cause an increase in memory usage, which could reduce scalability.</span></span>

## <a name="see-also"></a><span data-ttu-id="96c2c-150">另請參閱</span><span class="sxs-lookup"><span data-stu-id="96c2c-150">See also</span></span>

- [<span data-ttu-id="96c2c-151">系統管理與診斷</span><span class="sxs-lookup"><span data-stu-id="96c2c-151">Administration and Diagnostics</span></span>](./diagnostics/index.md)
- [<span data-ttu-id="96c2c-152">大型資料與資料流</span><span class="sxs-lookup"><span data-stu-id="96c2c-152">Large Data and Streaming</span></span>](./feature-details/large-data-and-streaming.md)
