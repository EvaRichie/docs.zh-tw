---
title: releaseHandleFailed MDA
description: 請參閱 releaseHandleFailed managed 偵錯工具（MDA），這可能會因為 .NET 中的資源或記憶體流失而啟用。
ms.date: 03/30/2017
helpviewer_keywords:
- managed debugging assistants (MDAs), handles
- release handle failed
- CriticalHandle class, run-time errors
- releaseHandleFailed MDA
- ReleaseHandle method
- SafeHandle class, run-time errors
- MDAs (managed debugging assistants), handles
ms.assetid: 44cd98ba-95e5-40a1-874d-e8e163612c51
ms.openlocfilehash: 167a304b4571aa35f758a2054caf6ae1c60a3c60
ms.sourcegitcommit: c23d9666ec75b91741da43ee3d91c317d68c7327
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 07/01/2020
ms.locfileid: "85803634"
---
# <a name="releasehandlefailed-mda"></a><span data-ttu-id="d78de-103">releaseHandleFailed MDA</span><span class="sxs-lookup"><span data-stu-id="d78de-103">releaseHandleFailed MDA</span></span>
<span data-ttu-id="d78de-104">當衍生自 <xref:System.Runtime.InteropServices.SafeHandle> 或 <xref:System.Runtime.InteropServices.CriticalHandle> 之類別的 <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> 方法傳回 `false` 時，會啟動 `releaseHandleFailed` Managed 偵錯助理 (MDA) 來通知開發人員。</span><span class="sxs-lookup"><span data-stu-id="d78de-104">The `releaseHandleFailed` managed debugging assistant (MDA) is activated is to notify developers when the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method of a class derived from <xref:System.Runtime.InteropServices.SafeHandle> or <xref:System.Runtime.InteropServices.CriticalHandle> returns `false`.</span></span>  
  
## <a name="symptoms"></a><span data-ttu-id="d78de-105">徵狀</span><span class="sxs-lookup"><span data-stu-id="d78de-105">Symptoms</span></span>  
 <span data-ttu-id="d78de-106">資源或記憶體流失。</span><span class="sxs-lookup"><span data-stu-id="d78de-106">Resource or memory leaks.</span></span>  <span data-ttu-id="d78de-107">如果衍生自 <xref:System.Runtime.InteropServices.SafeHandle> 或 <xref:System.Runtime.InteropServices.CriticalHandle> 之類別的 <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> 方法失敗，則該類別所封裝的資源可能尚未釋出或清除。</span><span class="sxs-lookup"><span data-stu-id="d78de-107">If the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method of the class deriving from <xref:System.Runtime.InteropServices.SafeHandle> or <xref:System.Runtime.InteropServices.CriticalHandle> fails, then the resource encapsulated by the class might not have been released or cleaned up.</span></span>  
  
## <a name="cause"></a><span data-ttu-id="d78de-108">原因</span><span class="sxs-lookup"><span data-stu-id="d78de-108">Cause</span></span>  
 <span data-ttu-id="d78de-109">如果使用者建立衍生自 <xref:System.Runtime.InteropServices.SafeHandle> 或 <xref:System.Runtime.InteropServices.CriticalHandle> 的類別，則必須提供 <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> 方法的實作；因此，這是個別資源特有的情況。</span><span class="sxs-lookup"><span data-stu-id="d78de-109">Users must provide the implementation of the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method if they create classes that derive from <xref:System.Runtime.InteropServices.SafeHandle> or <xref:System.Runtime.InteropServices.CriticalHandle>; thus, the circumstances are specific to the individual resource.</span></span> <span data-ttu-id="d78de-110">不過，需求如下：</span><span class="sxs-lookup"><span data-stu-id="d78de-110">However, the requirements are as follows:</span></span>  
  
- <span data-ttu-id="d78de-111"><xref:System.Runtime.InteropServices.SafeHandle> 和 <xref:System.Runtime.InteropServices.CriticalHandle> 類型代表重要處理序資源周圍的包裝函式。</span><span class="sxs-lookup"><span data-stu-id="d78de-111"><xref:System.Runtime.InteropServices.SafeHandle> and <xref:System.Runtime.InteropServices.CriticalHandle> types represent wrappers around vital process resources.</span></span> <span data-ttu-id="d78de-112">記憶體遺漏會使處理序過一段時間後即無法使用。</span><span class="sxs-lookup"><span data-stu-id="d78de-112">A memory leak would make the process unusable over time.</span></span>  
  
- <span data-ttu-id="d78de-113"><xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> 方法執行其函式時，絕不能失敗。</span><span class="sxs-lookup"><span data-stu-id="d78de-113">The <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method must not fail to perform its function.</span></span> <span data-ttu-id="d78de-114">一旦處理序取得這類資源，<xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> 是將其釋出的唯一方式。</span><span class="sxs-lookup"><span data-stu-id="d78de-114">Once the process acquires such a resource, <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> is the only way to release it.</span></span> <span data-ttu-id="d78de-115">因此，失敗即代表資源流失。</span><span class="sxs-lookup"><span data-stu-id="d78de-115">Therefore, failure implies resource leaks.</span></span>  
  
- <span data-ttu-id="d78de-116">在 <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> 執行期間，如果發生任何失敗，而導致無法釋出資源，就是 <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> 方法本身實作中的 Bug。</span><span class="sxs-lookup"><span data-stu-id="d78de-116">Any failure that does occur during the execution of <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>, impeding the release of the resource, is a bug in the implementation of the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method itself.</span></span> <span data-ttu-id="d78de-117">即使該程式碼呼叫別人撰寫的程式碼來執行其函式，程式設計師都有責任確保合約的履行。</span><span class="sxs-lookup"><span data-stu-id="d78de-117">It is the responsibility of the programmer to ensure that the contract is fulfilled, even if that code calls code authored by someone else to perform its function.</span></span>  
  
## <a name="resolution"></a><span data-ttu-id="d78de-118">解決方案</span><span class="sxs-lookup"><span data-stu-id="d78de-118">Resolution</span></span>  
 <span data-ttu-id="d78de-119">如果是程式碼所使用的特定 <xref:System.Runtime.InteropServices.SafeHandle> (或 <xref:System.Runtime.InteropServices.CriticalHandle>) 類型引發了 MDA 通知，則應檢閱程式碼，尋找從 <xref:System.Runtime.InteropServices.SafeHandle> 擷取未經處理的控制代碼值並複製在他處的地方。</span><span class="sxs-lookup"><span data-stu-id="d78de-119">The code that uses the specific <xref:System.Runtime.InteropServices.SafeHandle> (or <xref:System.Runtime.InteropServices.CriticalHandle>) type that raised the MDA notification should be reviewed, looking for places where the raw handle value is extracted from the <xref:System.Runtime.InteropServices.SafeHandle> and copied elsewhere.</span></span> <span data-ttu-id="d78de-120">這是 <xref:System.Runtime.InteropServices.SafeHandle> 或 <xref:System.Runtime.InteropServices.CriticalHandle> 實作中造成失敗的一般原因，因為執行階段後來就不會再追蹤未經處理之控制代碼值的使用狀況。</span><span class="sxs-lookup"><span data-stu-id="d78de-120">This is the usual cause of failures within <xref:System.Runtime.InteropServices.SafeHandle> or <xref:System.Runtime.InteropServices.CriticalHandle> implementations, because the usage of the raw handle value is then no longer tracked by the runtime.</span></span> <span data-ttu-id="d78de-121">如果未經處理的控制代碼複本隨後關閉，可能會導致後來的 <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> 呼叫失敗，因為是在相同的控制代碼上嘗試關閉，而現在為無效。</span><span class="sxs-lookup"><span data-stu-id="d78de-121">If the raw handle copy is subsequently closed, it can cause a later <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> call to fail because the close is attempted on the same handle, which is now invalid.</span></span>  
  
 <span data-ttu-id="d78de-122">有很多種方式會發生不正確的控制代碼重複：</span><span class="sxs-lookup"><span data-stu-id="d78de-122">There are a number of ways in which incorrect handle duplication can occur:</span></span>  
  
- <span data-ttu-id="d78de-123">尋找對 <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> 方法的呼叫。</span><span class="sxs-lookup"><span data-stu-id="d78de-123">Look for calls to the <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> method.</span></span> <span data-ttu-id="d78de-124">呼叫此方法機會應該非常少，如果您發現了，該呼叫周圍應該會有對 <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> 和 <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> 方法的呼叫。</span><span class="sxs-lookup"><span data-stu-id="d78de-124">Calls to this method should be exceedingly rare, and any that you find should be surrounded by calls to the <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> and <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> methods.</span></span> <span data-ttu-id="d78de-125">後面這二個方法會指定可安全使用未經處理之控制代碼值的程式碼區域。</span><span class="sxs-lookup"><span data-stu-id="d78de-125">These latter methods specify the region of code in which the raw handle value may be safely used.</span></span> <span data-ttu-id="d78de-126">在此區域之外，或是如果參考計數從未在第一時間遞增，則可隨時在另一個執行緒上呼叫 <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> 或 <xref:System.Runtime.InteropServices.SafeHandle.Close%2A>，以使控制代碼值失效。</span><span class="sxs-lookup"><span data-stu-id="d78de-126">Outside this region, or if the reference count is never incremented in the first place, the handle value can be invalidated at any time by a call to <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> or <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> on another thread.</span></span> <span data-ttu-id="d78de-127">在追蹤所有使用 <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> 的地方後，您應遵循未經處理之控制代碼所採用的路徑，確保不會將它交給最後會呼叫 `CloseHandle` 的某個元件，或是將會釋放控制代碼的其他低階原生方法。</span><span class="sxs-lookup"><span data-stu-id="d78de-127">Once all uses of <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> have been tracked down, you should follow the path the raw handle takes to ensure it is not handed off to some component that will eventually call `CloseHandle` or another low-level native method that will release the handle.</span></span>  
  
- <span data-ttu-id="d78de-128">確定用來初始化 <xref:System.Runtime.InteropServices.SafeHandle> (具有有效之未經處理的控制代碼值) 的程式碼擁有控制代碼。</span><span class="sxs-lookup"><span data-stu-id="d78de-128">Ensure that the code that is used to initialize the <xref:System.Runtime.InteropServices.SafeHandle> with a valid raw handle value owns the handle.</span></span> <span data-ttu-id="d78de-129">如果您在非程式碼擁有的控制代碼周圍構成 <xref:System.Runtime.InteropServices.SafeHandle>，而沒有在基底建構函式中，將 `ownsHandle` 參數設為 `false`，則 <xref:System.Runtime.InteropServices.SafeHandle> 和真正的控制代碼擁有者可以嘗試關閉此控制代碼，如果 <xref:System.Runtime.InteropServices.SafeHandle> 競爭失敗，就會導致 <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> 發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="d78de-129">If you form a <xref:System.Runtime.InteropServices.SafeHandle> around a handle your code does not own without setting the `ownsHandle` parameter to `false` in the base constructor, then both the <xref:System.Runtime.InteropServices.SafeHandle> and the real handle owner can try to close the handle, leading to an error in <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> if the <xref:System.Runtime.InteropServices.SafeHandle> loses the race.</span></span>  
  
- <span data-ttu-id="d78de-130">當 <xref:System.Runtime.InteropServices.SafeHandle> 在應用程式定義域之間封送處理時，請確認所使用的 <xref:System.Runtime.InteropServices.SafeHandle> 衍生已標示為可序列化。</span><span class="sxs-lookup"><span data-stu-id="d78de-130">When a <xref:System.Runtime.InteropServices.SafeHandle> is marshaled between application domains, confirm the <xref:System.Runtime.InteropServices.SafeHandle> derivation being used has been marked as serializable.</span></span> <span data-ttu-id="d78de-131">衍生自 <xref:System.Runtime.InteropServices.SafeHandle> 的類別極少會被可序列化，若發生此情況下，其應實作 <xref:System.Runtime.Serialization.ISerializable> 介面，或使用其他技術手動控制序列化和還原序列化程序。</span><span class="sxs-lookup"><span data-stu-id="d78de-131">In the rare cases where a class derived from <xref:System.Runtime.InteropServices.SafeHandle> has been made serializable, it should implement the <xref:System.Runtime.Serialization.ISerializable> interface or use one of the other techniques for controlling the serialization and deserialization process manually.</span></span> <span data-ttu-id="d78de-132">這是必要的，因為預設的序列化動作是要建立所含括之未經處理控制代碼值的位元複製，這會導致兩個 <xref:System.Runtime.InteropServices.SafeHandle> 執行個體以為它們擁有相同的控制代碼。</span><span class="sxs-lookup"><span data-stu-id="d78de-132">This is required because the default serialization action is to create a bitwise clone of the enclosed raw handle value, resulting in two <xref:System.Runtime.InteropServices.SafeHandle> instances thinking they own the same handle.</span></span> <span data-ttu-id="d78de-133">這兩個執行個體都會嘗試在某個時間點，在相同的控制代碼上呼叫 <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>。</span><span class="sxs-lookup"><span data-stu-id="d78de-133">Both will try to call <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> on the same handle at some point.</span></span> <span data-ttu-id="d78de-134">第二個這麼做的 <xref:System.Runtime.InteropServices.SafeHandle> 將會失敗。</span><span class="sxs-lookup"><span data-stu-id="d78de-134">The second <xref:System.Runtime.InteropServices.SafeHandle> to do this will fail.</span></span> <span data-ttu-id="d78de-135">序列化 <xref:System.Runtime.InteropServices.SafeHandle> 時，正確的做法是為您的原生控制代碼類型呼叫 `DuplicateHandle` 函式或類似的函式，以建立不同的合法控制代碼複本。</span><span class="sxs-lookup"><span data-stu-id="d78de-135">The correct course of action when serializing a <xref:System.Runtime.InteropServices.SafeHandle> is to call the `DuplicateHandle` function or a similar function for your native handle type to make a distinct legal handle copy.</span></span> <span data-ttu-id="d78de-136">如果您的控制代碼類型不支援這麼做，則將其含括在內的 <xref:System.Runtime.InteropServices.SafeHandle> 類型無法成為可序列化。</span><span class="sxs-lookup"><span data-stu-id="d78de-136">If your handle type does not support this then the <xref:System.Runtime.InteropServices.SafeHandle> type wrapping it cannot be made serializable.</span></span>  
  
- <span data-ttu-id="d78de-137">若要追蹤哪裡有控制代碼提早關閉，導致最後呼叫 <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> 方法時失敗，您可以將偵錯工具中斷點放在要用來釋放控制代碼的原生常式上，例如 `CloseHandle` 函式。</span><span class="sxs-lookup"><span data-stu-id="d78de-137">It may be possible to track where a handle is being closed early, leading to a failure when the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method is finally called, by placing a debugger breakpoint on the native routine used to release the handle, for example the `CloseHandle` function.</span></span> <span data-ttu-id="d78de-138">在有壓力的情況下，或甚至是中型功能測試，都不能這麼做，因為這類常式經常要處理極高的流量。</span><span class="sxs-lookup"><span data-stu-id="d78de-138">This may not be possible for stress scenarios or even medium-sized functional tests due to the heavy traffic such routines often deal with.</span></span> <span data-ttu-id="d78de-139">為了擷取呼叫端的身分識別 (或可能是完整的堆疊追蹤)，以及所要釋放之控制代碼的值，檢測用來呼叫原生釋放方法的程式碼可能會有所幫助。</span><span class="sxs-lookup"><span data-stu-id="d78de-139">It may help to instrument the code that calls the native release method, in order to capture the identity of the caller, or possibly a full stack trace, and the value of the handle being released.</span></span>  <span data-ttu-id="d78de-140">控制代碼值可以和這個 MDA 所報告的值做比較。</span><span class="sxs-lookup"><span data-stu-id="d78de-140">The handle value can be compared with the value reported by this MDA.</span></span>  
  
- <span data-ttu-id="d78de-141">請注意，某些原生控制代碼類型 (例如可透過 `CloseHandle` 函式釋放的所有 Win32 控制代碼)，會共用相同的控制代碼命名空間。</span><span class="sxs-lookup"><span data-stu-id="d78de-141">Note that some native handle types, such as all the Win32 handles that can be released via the `CloseHandle` function, share the same handle namespace.</span></span> <span data-ttu-id="d78de-142">一個控制代碼類型的錯誤釋放，可能會造成另一個控制代碼類型的問題。</span><span class="sxs-lookup"><span data-stu-id="d78de-142">An erroneous release of one handle type can cause problems with another.</span></span> <span data-ttu-id="d78de-143">比方說，不小心將 Win32 事件處理常式關閉兩次，可能會導致明顯無關的檔案控制代碼永久關閉。</span><span class="sxs-lookup"><span data-stu-id="d78de-143">For instance, accidentally closing a Win32 event handle twice might lead to an apparently unrelated file handle being closed prematurely.</span></span> <span data-ttu-id="d78de-144">當已釋放控制代碼，而控制代碼值變成可用來追蹤另一個資源，而該資源可能是另一種類型時，就會發生這種情況。</span><span class="sxs-lookup"><span data-stu-id="d78de-144">This happens when the handle is released and the handle value becomes available for use to track another resource, potentially of another type.</span></span> <span data-ttu-id="d78de-145">如果發生這種情況，接著又有錯誤的第二次釋放，不相關之執行緒的控制代碼可能會失效。</span><span class="sxs-lookup"><span data-stu-id="d78de-145">If this happens and is followed by an erroneous second release, the handle of an unrelated thread might be invalidated.</span></span>  
  
## <a name="effect-on-the-runtime"></a><span data-ttu-id="d78de-146">對執行階段的影響</span><span class="sxs-lookup"><span data-stu-id="d78de-146">Effect on the Runtime</span></span>  
 <span data-ttu-id="d78de-147">此 MDA 對 CLR 沒有影響。</span><span class="sxs-lookup"><span data-stu-id="d78de-147">This MDA has no effect on the CLR.</span></span>  
  
## <a name="output"></a><span data-ttu-id="d78de-148">輸出</span><span class="sxs-lookup"><span data-stu-id="d78de-148">Output</span></span>  
 <span data-ttu-id="d78de-149">訊息指出 <xref:System.Runtime.InteropServices.SafeHandle> 或 <xref:System.Runtime.InteropServices.CriticalHandle> 無法適當地釋放控制代碼。</span><span class="sxs-lookup"><span data-stu-id="d78de-149">A message indicating that a <xref:System.Runtime.InteropServices.SafeHandle> or a <xref:System.Runtime.InteropServices.CriticalHandle> failed to properly release the handle.</span></span> <span data-ttu-id="d78de-150">例如：</span><span class="sxs-lookup"><span data-stu-id="d78de-150">For example:</span></span>  
  
```output
"A SafeHandle or CriticalHandle of type 'MyBrokenSafeHandle'
failed to properly release the handle with value 0x0000BEEF. This
usually indicates that the handle was released incorrectly via
another means (such as extracting the handle using DangerousGetHandle
and closing it directly or building another SafeHandle around it."  
```  
  
## <a name="configuration"></a><span data-ttu-id="d78de-151">組態</span><span class="sxs-lookup"><span data-stu-id="d78de-151">Configuration</span></span>  
  
```xml  
<mdaConfig>  
  <assistants>  
    <releaseHandleFailed/>  
  </assistants>  
</mdaConfig>  
```  
  
## <a name="example"></a><span data-ttu-id="d78de-152">範例</span><span class="sxs-lookup"><span data-stu-id="d78de-152">Example</span></span>  
 <span data-ttu-id="d78de-153">以下是可啟動 `releaseHandleFailed` MDA 的程式碼範例。</span><span class="sxs-lookup"><span data-stu-id="d78de-153">The following is a code example that can activate the `releaseHandleFailed` MDA.</span></span>  
  
```csharp
bool ReleaseHandle()  
{  
    // Calling the Win32 CloseHandle function to release the
    // native handle wrapped by this SafeHandle. This method returns
    // false on failure, but should only fail if the input is invalid
    // (which should not happen here). The method specifically must not
    // fail simply because of lack of resources or other transient
    // failures beyond the user’s control. That would make it unacceptable
    // to call CloseHandle as part of the implementation of this method.  
    return CloseHandle(handle);  
}  
```  
  
## <a name="see-also"></a><span data-ttu-id="d78de-154">另請參閱</span><span class="sxs-lookup"><span data-stu-id="d78de-154">See also</span></span>

- <xref:System.Runtime.InteropServices.MarshalAsAttribute>
- [<span data-ttu-id="d78de-155">使用 Managed 偵錯助理診斷錯誤</span><span class="sxs-lookup"><span data-stu-id="d78de-155">Diagnosing Errors with Managed Debugging Assistants</span></span>](diagnosing-errors-with-managed-debugging-assistants.md)
- [<span data-ttu-id="d78de-156">Interop 封送處理</span><span class="sxs-lookup"><span data-stu-id="d78de-156">Interop Marshaling</span></span>](../interop/interop-marshaling.md)
