---
title: 安全性和遠端處理考量
description: 瞭解遠端處理方面的安全性考慮，這可讓您設定應用程式域、進程或電腦之間的透明呼叫。
ms.date: 03/30/2017
helpviewer_keywords:
- code security, remoting
- remoting, security
- security [.NET Framework], remoting
- secure coding, remoting
ms.assetid: 125d2ab8-55a4-4e5f-af36-a7d401a37ab0
ms.openlocfilehash: 883c20483c4d315a45e1f4dab959d42cbb6e3c4b
ms.sourcegitcommit: bc293b14af795e0e999e3304dd40c0222cf2ffe4
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 11/26/2020
ms.locfileid: "96288199"
---
# <a name="security-and-remoting-considerations"></a><span data-ttu-id="318db-103">安全性和遠端處理考量</span><span class="sxs-lookup"><span data-stu-id="318db-103">Security and Remoting Considerations</span></span>

[!INCLUDE[net_security_note](../../../includes/net-security-note-md.md)]

<span data-ttu-id="318db-104">遠端處理可讓您設定應用程式定義域、處理序或電腦之間的透明呼叫。</span><span class="sxs-lookup"><span data-stu-id="318db-104">Remoting allows you to set up transparent calling between application domains, processes, or computers.</span></span> <span data-ttu-id="318db-105">不過，程式碼存取安全性堆疊查核行程無法跨處理序或電腦界限 (只會在同一個處理序的不同應用程式定義域之間套用)。</span><span class="sxs-lookup"><span data-stu-id="318db-105">However, the code access security stack walk cannot cross process or machine boundaries (it does apply between application domains of the same process).</span></span>  
  
 <span data-ttu-id="318db-106">所有可遠端處理的類別 (衍生自 <xref:System.MarshalByRefObject> 類別) 都必須確保安全。</span><span class="sxs-lookup"><span data-stu-id="318db-106">Any class that is remotable (derived from a <xref:System.MarshalByRefObject> class) needs to take responsibility for security.</span></span> <span data-ttu-id="318db-107">程式碼應該只在可隱含信任呼叫端程式碼的封閉式環境中使用，或者遠端處理呼叫的設計方式，應該使受保護的程式碼不容易遭到惡意使用之外部項目的攻擊。</span><span class="sxs-lookup"><span data-stu-id="318db-107">Either the code should be used only in closed environments where the calling code can be implicitly trusted, or remoting calls should be designed so that they do not subject protected code to outside entry that could be used maliciously.</span></span>  
  
 <span data-ttu-id="318db-108">一般而言，您永遠不應該公開以宣告式 [LinkDemand](link-demands.md) 和安全性檢查保護的方法、屬性或事件 <xref:System.Security.Permissions.SecurityAction.InheritanceDemand> 。</span><span class="sxs-lookup"><span data-stu-id="318db-108">Generally, you should never expose methods, properties, or events that are protected by declarative [LinkDemand](link-demands.md) and <xref:System.Security.Permissions.SecurityAction.InheritanceDemand> security checks.</span></span> <span data-ttu-id="318db-109">進行遠端處理時，系統不會強制執行這些檢查。</span><span class="sxs-lookup"><span data-stu-id="318db-109">With remoting, these checks are not enforced.</span></span> <span data-ttu-id="318db-110">其他安全性檢查（例如 <xref:System.Security.Permissions.SecurityAction.Demand> 、 [Assert](using-the-assert-method.md)等）可在進程內的應用程式域之間執行，但無法在跨進程或跨電腦的情況下運作。</span><span class="sxs-lookup"><span data-stu-id="318db-110">Other security checks, such as <xref:System.Security.Permissions.SecurityAction.Demand>, [Assert](using-the-assert-method.md), and so on, work between application domains within a process but do not work in cross-process or cross-machine scenarios.</span></span>  
  
## <a name="protected-objects"></a><span data-ttu-id="318db-111">受保護的物件</span><span class="sxs-lookup"><span data-stu-id="318db-111">Protected objects</span></span>  

 <span data-ttu-id="318db-112">某些物件本身有安全性狀態。</span><span class="sxs-lookup"><span data-stu-id="318db-112">Some objects hold security state in themselves.</span></span> <span data-ttu-id="318db-113">這些物件不應該傳遞至不受信任的程式碼，這類程式碼可能會接著取得超出其所有權限的安全性授權。</span><span class="sxs-lookup"><span data-stu-id="318db-113">These objects should not be passed to untrusted code, which would then acquire security authorization beyond its own permissions.</span></span>  
  
 <span data-ttu-id="318db-114">建立 <xref:System.IO.FileStream> 物件即為一例。</span><span class="sxs-lookup"><span data-stu-id="318db-114">One example is creating a <xref:System.IO.FileStream> object.</span></span> <span data-ttu-id="318db-115">建立該物件時需要 <xref:System.Security.Permissions.FileIOPermission>；如果成功，則會傳回檔案物件。</span><span class="sxs-lookup"><span data-stu-id="318db-115">The <xref:System.Security.Permissions.FileIOPermission> is demanded at the time of creation and, if it succeeds, the file object is returned.</span></span> <span data-ttu-id="318db-116">不過，如果在未提供檔案權限的情況下，將這個物件參考傳遞至程式碼，則能夠從這個特定檔案讀取物件並將物件寫入檔案。</span><span class="sxs-lookup"><span data-stu-id="318db-116">However, if this object reference is passed to code without file permissions, the object will be able to read and write to this particular file.</span></span>  
  
 <span data-ttu-id="318db-117">這類物件最簡單的防禦方式就是要求任何程式碼的相同 **FileIOPermission** ，以透過公用 API 元素取得物件參考。</span><span class="sxs-lookup"><span data-stu-id="318db-117">The simplest defense for such an object is to demand the same **FileIOPermission** of any code that seeks to get the object reference through a public API element.</span></span>  
  
## <a name="application-domain-crossing-issues"></a><span data-ttu-id="318db-118">跨應用程式定義域的問題</span><span class="sxs-lookup"><span data-stu-id="318db-118">Application domain crossing issues</span></span>  

 <span data-ttu-id="318db-119">若要將程式碼隔離到 Managed 裝載環境中，通常會產生多個子應用程式定義域，這些應用程式定義域具有降低各種組件之權限層級的明確原則。</span><span class="sxs-lookup"><span data-stu-id="318db-119">To isolate code in managed hosting environments, it is common to generate multiple child application domains with explicit policy reducing the permission levels for various assemblies.</span></span> <span data-ttu-id="318db-120">不過，這些組件的原則在預設應用程式定義域中會保持不變。</span><span class="sxs-lookup"><span data-stu-id="318db-120">However, the policy for those assemblies remains unchanged in the default application domain.</span></span> <span data-ttu-id="318db-121">如果其中一個子應用程式定義域可強制預設應用程式定義域載入組件，則會失去程式碼隔離的效果，而且強制載入之組件中的類型將能夠在較高的信任層級執行程式碼。</span><span class="sxs-lookup"><span data-stu-id="318db-121">If one of the child application domains can force the default application domain to load an assembly, the effect of code isolation is lost and types in the forcibly loaded assembly will be able to run code at a higher level of trust.</span></span>  
  
 <span data-ttu-id="318db-122">應用程式定義域可強制另一個應用程式定義域載入組件，並透過呼叫另一個應用程式定義域所裝載的物件 Proxy，來執行包含在組件中的程式碼。</span><span class="sxs-lookup"><span data-stu-id="318db-122">An application domain can force another application domain to load an assembly and run code contained therein by calling a proxy to an object hosted in the other application domain.</span></span> <span data-ttu-id="318db-123">若要取得跨應用程式定義域的 Proxy，裝載該物件的應用程式定義域必須透過方法呼叫參數或傳回值來發佈一個 Proxy。</span><span class="sxs-lookup"><span data-stu-id="318db-123">To obtain a cross-application-domain proxy, the application domain hosting the object must distribute one through a method call parameter or return value.</span></span> <span data-ttu-id="318db-124">或者，如果剛建立應用程式定義域，則建立者預設會有 <xref:System.AppDomain> 物件的 Proxy。</span><span class="sxs-lookup"><span data-stu-id="318db-124">Or, if the application domain was just created, the creator has a proxy to the <xref:System.AppDomain> object by default.</span></span> <span data-ttu-id="318db-125">因此，為了避免破壞程式碼隔離，信任層級較高的應用程式定義域不應該將以傳址方式封送處理的物件參考 (衍生自 <xref:System.MarshalByRefObject> 的類別執行個體)，從其定義域散發到信任層級較低的應用程式定義域。</span><span class="sxs-lookup"><span data-stu-id="318db-125">Thus, to avoid breaking code isolation, an application domain with a higher level of trust should not distribute references to marshaled-by-reference objects (instances of classes derived from <xref:System.MarshalByRefObject>) in its domain to application domains with lower levels of trust.</span></span>  
  
 <span data-ttu-id="318db-126">預設應用程式定義域在建立子應用程式定義域時，通常會在每個子應用程式定義域中包含一個控制項物件。</span><span class="sxs-lookup"><span data-stu-id="318db-126">Usually, the default application domain creates the child application domains with a control object in each one.</span></span> <span data-ttu-id="318db-127">這個控制項物件會管理新的應用程式定義域，有時會接受來自預設應用程式定義域的命令，但實際上不會直接連絡定義域。</span><span class="sxs-lookup"><span data-stu-id="318db-127">The control object manages the new application domain and occasionally takes orders from the default application domain, but it cannot actually contact the domain directly.</span></span> <span data-ttu-id="318db-128">預設應用程式定義域有時會對控制項物件呼叫其 Proxy。</span><span class="sxs-lookup"><span data-stu-id="318db-128">Occasionally, the default application domain calls its proxy to the control object.</span></span> <span data-ttu-id="318db-129">不過也有些情況，必須對預設應用程式定義域回呼控制項物件。</span><span class="sxs-lookup"><span data-stu-id="318db-129">However, there might be cases in which it is necessary for the control object to call back to the default application domain.</span></span> <span data-ttu-id="318db-130">在這些情況下，預設應用程式定義域會將以傳址方式封送處理的回呼物件，傳遞給控制項物件的建構函式。</span><span class="sxs-lookup"><span data-stu-id="318db-130">In these cases, the default application domain passes a marshal-by-reference callback object to the constructor of the control object.</span></span> <span data-ttu-id="318db-131">再由控制項物件負責保護這個 Proxy。</span><span class="sxs-lookup"><span data-stu-id="318db-131">It is the responsibility of the control object to protect this proxy.</span></span> <span data-ttu-id="318db-132">如果控制項物件將 proxy 放在公用類別的公用靜態欄位上，或公開 proxy，則會開啟其他程式碼的危險機制來回呼預設的應用程式域。</span><span class="sxs-lookup"><span data-stu-id="318db-132">If the control object placed the proxy on a public static field of a public class or otherwise publicly exposed the proxy, a dangerous mechanism for other code to call back into the default application domain would be opened up.</span></span> <span data-ttu-id="318db-133">因此，控制項物件一律會受到隱含信任，以保密 Proxy。</span><span class="sxs-lookup"><span data-stu-id="318db-133">For this reason, control objects are always implicitly trusted to keep the proxy private.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="318db-134">另請參閱</span><span class="sxs-lookup"><span data-stu-id="318db-134">See also</span></span>

- [<span data-ttu-id="318db-135">安全程式碼撰寫方針</span><span class="sxs-lookup"><span data-stu-id="318db-135">Secure Coding Guidelines</span></span>](../../standard/security/secure-coding-guidelines.md)
