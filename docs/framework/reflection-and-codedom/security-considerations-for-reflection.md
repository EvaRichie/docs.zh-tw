---
title: 反映的安全性考量
description: 瞭解 .NET 中反映的安全性考慮。 允許取得類型和成員的相關資訊，但存取成員有限制。
ms.date: 03/30/2017
helpviewer_keywords:
- permissions [.NET Framework], reflection
- MethodInfo parameters
- reflection, security
- partial trust,reflection
- nonpublic members
- reflection,partial trust
- link demands
ms.assetid: 42d9dc2a-8fcc-4ff3-b002-4ff260ef3dc5
ms.openlocfilehash: 0465cbd5ceb7d4f44bb6d10865fcbd17b8ed7af6
ms.sourcegitcommit: 3d84eac0818099c9949035feb96bbe0346358504
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 07/21/2020
ms.locfileid: "86865251"
---
# <a name="security-considerations-for-reflection"></a><span data-ttu-id="05e2e-104">反映的安全性考量</span><span class="sxs-lookup"><span data-stu-id="05e2e-104">Security Considerations for Reflection</span></span>

<span data-ttu-id="05e2e-105">反映可讓您取得類型和成員的相關資訊，以及存取成員 (也就是呼叫方法和建構函式、取得和設定屬性值、加入和移除事件處理常式等等)。</span><span class="sxs-lookup"><span data-stu-id="05e2e-105">Reflection provides the ability to obtain information about types and members, and to access members (that is, to call methods and constructors, to get and set property values, to add and remove event handlers, and so on).</span></span> <span data-ttu-id="05e2e-106">不限制使用反映來取得類型和成員的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="05e2e-106">The use of reflection to obtain information about types and members is not restricted.</span></span> <span data-ttu-id="05e2e-107">所有程式碼都可以使用反映來執行下列工作：</span><span class="sxs-lookup"><span data-stu-id="05e2e-107">All code can use reflection to perform the following tasks:</span></span>

- <span data-ttu-id="05e2e-108">列舉類型和成員，並檢查其中繼資料。</span><span class="sxs-lookup"><span data-stu-id="05e2e-108">Enumerate types and members, and examine their metadata.</span></span>

- <span data-ttu-id="05e2e-109">列舉及檢查組件和模組。</span><span class="sxs-lookup"><span data-stu-id="05e2e-109">Enumerate and examine assemblies and modules.</span></span>

<span data-ttu-id="05e2e-110">相對地，使用反映來存取成員有所限制。</span><span class="sxs-lookup"><span data-stu-id="05e2e-110">Using reflection to access members, by contrast, is subject to restrictions.</span></span> <span data-ttu-id="05e2e-111">從 .NET Framework 4 開始，只有受信任的程式碼才能使用反映存取安全性關鍵成員。</span><span class="sxs-lookup"><span data-stu-id="05e2e-111">Beginning with the .NET Framework 4, only trusted code can use reflection to access security-critical members.</span></span> <span data-ttu-id="05e2e-112">此外，只有受信任的程式碼能夠使用反映來存取已編譯程式碼無法直接存取的非公用成員。</span><span class="sxs-lookup"><span data-stu-id="05e2e-112">Furthermore, only trusted code can use reflection to access nonpublic members that would not be directly accessible to compiled code.</span></span> <span data-ttu-id="05e2e-113">最後，使用反映存取安全性關鍵成員的程式碼必須擁有安全關鍵成員所要求的任何權限，就如同編譯的程式碼。</span><span class="sxs-lookup"><span data-stu-id="05e2e-113">Finally, code that uses reflection to access a safe-critical member must have whatever permissions the safe-critical member demands, just as with compiled code.</span></span>

<span data-ttu-id="05e2e-114">受限於所需的權限，程式碼可以使用反映來執行下列類型的存取：</span><span class="sxs-lookup"><span data-stu-id="05e2e-114">Subject to necessary permissions, code can use reflection to perform the following kinds of access:</span></span>

- <span data-ttu-id="05e2e-115">存取非安全性關鍵的公用成員。</span><span class="sxs-lookup"><span data-stu-id="05e2e-115">Access public members that are not security-critical.</span></span>

- <span data-ttu-id="05e2e-116">存取可供已編譯程式碼存取的非公用成員 (前提是這些成員不是安全性關鍵成員)。</span><span class="sxs-lookup"><span data-stu-id="05e2e-116">Access nonpublic members that would be accessible to compiled code, if those members are not security-critical.</span></span> <span data-ttu-id="05e2e-117">這類非公用成員的範例包括：</span><span class="sxs-lookup"><span data-stu-id="05e2e-117">Examples of such nonpublic members include:</span></span>

  - <span data-ttu-id="05e2e-118">呼叫程式碼基底類別的 Protected 成員。</span><span class="sxs-lookup"><span data-stu-id="05e2e-118">Protected members of the calling code's base classes.</span></span> <span data-ttu-id="05e2e-119">(在反映中，這稱為系列層級的存取。)</span><span class="sxs-lookup"><span data-stu-id="05e2e-119">(In reflection, this is referred to as family-level access.)</span></span>

  - <span data-ttu-id="05e2e-120">呼叫程式碼組件中的 `internal` 成員 (在 Visual Basic 中為 `Friend` 成員)。</span><span class="sxs-lookup"><span data-stu-id="05e2e-120">`internal` members (`Friend` members in Visual Basic) in the calling code's assembly.</span></span> <span data-ttu-id="05e2e-121">(在反映中，這稱為組件層級存取。)</span><span class="sxs-lookup"><span data-stu-id="05e2e-121">(In reflection, this is referred to as assembly-level access.)</span></span>

  - <span data-ttu-id="05e2e-122">包含呼叫程式碼之類別的其他執行個體的私用成員。</span><span class="sxs-lookup"><span data-stu-id="05e2e-122">Private members of other instances of the class that contains the calling code.</span></span>

<span data-ttu-id="05e2e-123">例如，在沙箱化應用程式定義域中執行的程式碼，僅限於此清單中所描述的存取權，除非應用程式定義域授與其他權限。</span><span class="sxs-lookup"><span data-stu-id="05e2e-123">For example, code that is run in a sandboxed application domain is limited to the access described in this list, unless the application domain grants additional permissions.</span></span>

<span data-ttu-id="05e2e-124">從 .NET Framework 2.0 Service Pack 1 開始，嘗試存取通常無法存取的成員時，系統會要求目標物件的授權集，加上具有 <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> 旗標的 <xref:System.Security.Permissions.ReflectionPermission>。</span><span class="sxs-lookup"><span data-stu-id="05e2e-124">Starting with the .NET Framework 2.0 Service Pack 1, attempting to access members that are normally inaccessible generates a demand for the grant set of the target object plus <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> flag.</span></span> <span data-ttu-id="05e2e-125">以完全信任執行的程式碼 (例如從命令列啟動之應用程式中的程式碼)，一律可以滿足這些權限。</span><span class="sxs-lookup"><span data-stu-id="05e2e-125">Code that is running with full trust (for example, code in an application that is launched from the command line) can always satisfy these permissions.</span></span> <span data-ttu-id="05e2e-126">(這取決於存取安全性關鍵成員時的限制，本文稍後將會說明)。</span><span class="sxs-lookup"><span data-stu-id="05e2e-126">(This is subject to limitations in accessing security-critical members, as described later in this article.)</span></span>

<span data-ttu-id="05e2e-127">(選擇性) 沙箱應用程式定義域可以授權有 <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> 旗標的 <xref:System.Security.Permissions.ReflectionPermission>，本文稍後的[存取通常無法存取的成員](#accessingNormallyInaccessible)一節將會說明。</span><span class="sxs-lookup"><span data-stu-id="05e2e-127">Optionally, a sandboxed application domain can grant <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> flag, as described in the section [Accessing Members That Are Normally Inaccessible](#accessingNormallyInaccessible), later in this article.</span></span>

<a name="accessingSecurityCritical"></a>

## <a name="accessing-security-critical-members"></a><span data-ttu-id="05e2e-128">存取安全性關鍵成員</span><span class="sxs-lookup"><span data-stu-id="05e2e-128">Accessing Security-Critical Members</span></span>

<span data-ttu-id="05e2e-129">如果成員有 <xref:System.Security.SecurityCriticalAttribute>、屬於具有 <xref:System.Security.SecurityCriticalAttribute> 的類型，或位於安全性關鍵組件中，就是安全性關鍵成員。</span><span class="sxs-lookup"><span data-stu-id="05e2e-129">A member is security-critical if it has the <xref:System.Security.SecurityCriticalAttribute>, if it belongs to a type that has the <xref:System.Security.SecurityCriticalAttribute>, or if it is in a security-critical assembly.</span></span> <span data-ttu-id="05e2e-130">從 .NET Framework 4 開始，存取安全性關鍵成員的規則如下：</span><span class="sxs-lookup"><span data-stu-id="05e2e-130">Beginning with the .NET Framework 4, the rules for accessing security-critical members are as follows:</span></span>

- <span data-ttu-id="05e2e-131">透明程式碼無法使用反映來存取安全性關鍵成員，即使是完全受信任的程式碼也一樣。</span><span class="sxs-lookup"><span data-stu-id="05e2e-131">Transparent code cannot use reflection to access security-critical members, even if the code is fully trusted.</span></span> <span data-ttu-id="05e2e-132">會擲回 <xref:System.MethodAccessException>、<xref:System.FieldAccessException> 或 <xref:System.TypeAccessException>。</span><span class="sxs-lookup"><span data-stu-id="05e2e-132">A <xref:System.MethodAccessException>, <xref:System.FieldAccessException>, or <xref:System.TypeAccessException> is thrown.</span></span>

- <span data-ttu-id="05e2e-133">使用部分信任來執行的程式碼會視為透明。</span><span class="sxs-lookup"><span data-stu-id="05e2e-133">Code that is running with partial trust is treated as transparent.</span></span>

<span data-ttu-id="05e2e-134">無論是由已編譯程式碼直接存取安全性關鍵成員，或是使用反映來存取安全性關鍵成員，這些規則都一樣。</span><span class="sxs-lookup"><span data-stu-id="05e2e-134">These rules are the same whether a security-critical member is accessed directly by compiled code, or accessed by using reflection.</span></span>

<span data-ttu-id="05e2e-135">從命令列執行的應用程式程式碼會以完全信任來執行。</span><span class="sxs-lookup"><span data-stu-id="05e2e-135">Application code that is run from the command line runs with full trust.</span></span> <span data-ttu-id="05e2e-136">只要不是標示為透明，就可以使用反映來存取安全性關鍵成員。</span><span class="sxs-lookup"><span data-stu-id="05e2e-136">As long as it is not marked as transparent, it can use reflection to access security-critical members.</span></span> <span data-ttu-id="05e2e-137">以部分信任來執行相同的程式碼時 (例如，在沙箱化應用程式定義域中)，組件的信任層級可決定它是否能夠存取安全性關鍵程式碼：如果組件有強式名稱，並安裝在全域組件快取中，則其為受信任的組件，可以呼叫安全性關鍵成員。</span><span class="sxs-lookup"><span data-stu-id="05e2e-137">When the same code is run with partial trust (for example, in a sandboxed application domain) the assembly's trust level determines whether it can access security-critical code: If the assembly has a strong name and is installed in the global assembly cache, it is a trusted assembly and can call security-critical members.</span></span> <span data-ttu-id="05e2e-138">如果不受信任，則會變成透明 (即使它不是標示為透明)，而且不能存取安全性關鍵成員。</span><span class="sxs-lookup"><span data-stu-id="05e2e-138">If it is not trusted, it becomes transparent even though it was not marked as transparent, and it cannot access security-critical members.</span></span>

<span data-ttu-id="05e2e-139">如需 .NET Framework 4 的安全模型詳細資訊，請參閱[安全性變更](https://docs.microsoft.com/previous-versions/dotnet/framework/security/security-changes)。</span><span class="sxs-lookup"><span data-stu-id="05e2e-139">For more information about the security model in the .NET Framework 4, see [Security Changes](https://docs.microsoft.com/previous-versions/dotnet/framework/security/security-changes).</span></span>

## <a name="reflection-and-transparency"></a><span data-ttu-id="05e2e-140">反映和透明度</span><span class="sxs-lookup"><span data-stu-id="05e2e-140">Reflection and Transparency</span></span>

<span data-ttu-id="05e2e-141">從 .NET Framework 4 開始，通用語言執行平台可以從數個因素來決定型別或成員的透明度，包括組件和應用程式定義域二者的信任層級。</span><span class="sxs-lookup"><span data-stu-id="05e2e-141">Beginning with the .NET Framework 4, the common language runtime determines the transparency level of a type or member from several factors, including the trust level of the assembly and the trust level of the application domain.</span></span> <span data-ttu-id="05e2e-142">反映提供 <xref:System.Type.IsSecurityCritical%2A>、<xref:System.Type.IsSecuritySafeCritical%2A> 和 <xref:System.Type.IsSecurityTransparent%2A> 屬性，可讓您探索類型的透明度。</span><span class="sxs-lookup"><span data-stu-id="05e2e-142">Reflection provides the <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, and <xref:System.Type.IsSecurityTransparent%2A> properties to enable you to discover the transparency level of a type.</span></span> <span data-ttu-id="05e2e-143">下表顯示這些屬性的有效組合。</span><span class="sxs-lookup"><span data-stu-id="05e2e-143">The following table shows the valid combinations of these properties.</span></span>

|<span data-ttu-id="05e2e-144">安全性層級</span><span class="sxs-lookup"><span data-stu-id="05e2e-144">Security level</span></span>|<span data-ttu-id="05e2e-145">IsSecurityCritical</span><span class="sxs-lookup"><span data-stu-id="05e2e-145">IsSecurityCritical</span></span>|<span data-ttu-id="05e2e-146">IsSecuritySafeCritical</span><span class="sxs-lookup"><span data-stu-id="05e2e-146">IsSecuritySafeCritical</span></span>|<span data-ttu-id="05e2e-147">IsSecurityTransparent</span><span class="sxs-lookup"><span data-stu-id="05e2e-147">IsSecurityTransparent</span></span>|
|--------------------|------------------------|----------------------------|---------------------------|
|<span data-ttu-id="05e2e-148">重要</span><span class="sxs-lookup"><span data-stu-id="05e2e-148">Critical</span></span>|`true`|`false`|`false`|
|<span data-ttu-id="05e2e-149">安全關鍵</span><span class="sxs-lookup"><span data-stu-id="05e2e-149">Safe-critical</span></span>|`true`|`true`|`false`|
|<span data-ttu-id="05e2e-150">透明</span><span class="sxs-lookup"><span data-stu-id="05e2e-150">Transparent</span></span>|`false`|`false`|`true`|

<span data-ttu-id="05e2e-151">使用這些屬性會比檢查組件及其類型的安全性註釋、檢查目前的信任層級，以及嘗試複製執行階段規則更簡單。</span><span class="sxs-lookup"><span data-stu-id="05e2e-151">Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span> <span data-ttu-id="05e2e-152">例如，相同的類型從命令列執行時，就是安全性關鍵，在沙箱化應用程式定義域中執行時，就是安全性透明。</span><span class="sxs-lookup"><span data-stu-id="05e2e-152">For example, the same type can be security-critical when it is run from the command line, or security-transparent when it is run in a sandboxed application domain.</span></span>

<span data-ttu-id="05e2e-153"><xref:System.Reflection.MethodBase>、<xref:System.Reflection.FieldInfo>、<xref:System.Reflection.Emit.TypeBuilder>、<xref:System.Reflection.Emit.MethodBuilder> 和 <xref:System.Reflection.Emit.DynamicMethod> 類別上有類似的屬性。</span><span class="sxs-lookup"><span data-stu-id="05e2e-153">There are similar properties on the <xref:System.Reflection.MethodBase>, <xref:System.Reflection.FieldInfo>, <xref:System.Reflection.Emit.TypeBuilder>, <xref:System.Reflection.Emit.MethodBuilder>, and <xref:System.Reflection.Emit.DynamicMethod> classes.</span></span> <span data-ttu-id="05e2e-154">(針對其他反映和反映發出抽象，安全性屬性 (security attribute) 會套用至相關聯的方法；例如，以屬性 (property) 來說，安全性屬性會套用至屬性存取子 (property accessor)。</span><span class="sxs-lookup"><span data-stu-id="05e2e-154">(For other reflection and reflection emit abstractions, security attributes are applied to the associated methods; for example, in the case of properties they are applied to the property accessors.)</span></span>

<a name="accessingNormallyInaccessible"></a>

## <a name="accessing-members-that-are-normally-inaccessible"></a><span data-ttu-id="05e2e-155">存取通常無法存取的成員</span><span class="sxs-lookup"><span data-stu-id="05e2e-155">Accessing Members That Are Normally Inaccessible</span></span>

<span data-ttu-id="05e2e-156">若要使用反映來叫用無法存取的成員 (根據 Common Language Runtime 的存取範圍規則)，您的程式碼必須被授與下列兩個權限之一：</span><span class="sxs-lookup"><span data-stu-id="05e2e-156">To use reflection to invoke members that are inaccessible according to the accessibility rules of the common language runtime, your code must be granted one of two permissions:</span></span>

- <span data-ttu-id="05e2e-157">若要允許程式碼叫用任何非公用成員：您的程式碼必須被授與具有 <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> 旗標的 <xref:System.Security.Permissions.ReflectionPermission>。</span><span class="sxs-lookup"><span data-stu-id="05e2e-157">To allow code to invoke any nonpublic member:Your code must be granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> flag.</span></span>

  > [!NOTE]
  > <span data-ttu-id="05e2e-158">根據預設，安全性原則會拒絕將此權限授與源自網際網路的程式碼。</span><span class="sxs-lookup"><span data-stu-id="05e2e-158">By default, security policy denies this permission to code that originates from the Internet.</span></span> <span data-ttu-id="05e2e-159">此權限絕不能授與源自網際網路的程式碼。</span><span class="sxs-lookup"><span data-stu-id="05e2e-159">This permission should never be granted to code that originates from the Internet.</span></span>

- <span data-ttu-id="05e2e-160">若要允許程式碼叫用任何非公用成員，只要包含被叫用成員的組件授與集，與包含叫用程式碼的組件授與集相同，或是其授權集的子集：您的程式碼必須被授與具有 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 旗標的  <xref:System.Security.Permissions.ReflectionPermission>。</span><span class="sxs-lookup"><span data-stu-id="05e2e-160">To allow code to invoke any nonpublic member, as long as the grant set of the assembly that contains the invoked member is the same as, or a subset of, the grant set of the assembly that contains the invoking code: Your code must be granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag.</span></span>

<span data-ttu-id="05e2e-161">例如，假設您將網際網路權限，以及具有 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 旗標的 <xref:System.Security.Permissions.ReflectionPermission>，授與應用程式定義域，然後執行網際網路應用程式來搭配兩個組件 A 和 B。</span><span class="sxs-lookup"><span data-stu-id="05e2e-161">For example, suppose you grant an application domain Internet permissions plus <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag, and then run an Internet application with two assemblies, A and B.</span></span>

- <span data-ttu-id="05e2e-162">組件 A 可以使用反映來存取組件 B 的私用成員，因為組件 B 的授權集不包含未授與 A 的任何權限。</span><span class="sxs-lookup"><span data-stu-id="05e2e-162">Assembly A can use reflection to access private members of assembly B, because the grant set of assembly B does not include any permissions that A has not been granted.</span></span>

- <span data-ttu-id="05e2e-163">組件 A 無法使用反射來存取 .NET Framework 組件的私有成員 (例如 mscorlib.dll)，因為 mscorlib.dll 為完全受信任，擁有尚未授與組件 A 的權限。當程式碼存取安全性查核在執行階段查核堆疊時，會擲回 <xref:System.MemberAccessException>。</span><span class="sxs-lookup"><span data-stu-id="05e2e-163">Assembly A cannot use reflection to access private members of .NET Framework assemblies such as mscorlib.dll, because mscorlib.dll is fully trusted and therefore has permissions that have not been granted to assembly A. A <xref:System.MemberAccessException> is thrown when code access security walks the stack at run time.</span></span>

## <a name="serialization"></a><span data-ttu-id="05e2e-164">序列化</span><span class="sxs-lookup"><span data-stu-id="05e2e-164">Serialization</span></span>

<span data-ttu-id="05e2e-165">進行序列化時，不論存取範圍為何，具有 <xref:System.Security.Permissions.SecurityPermissionAttribute.SerializationFormatter%2A?displayProperty=nameWithType> 旗標的 <xref:System.Security.Permissions.SecurityPermission> 都可讓您取得或設定可序列化類型的成員。</span><span class="sxs-lookup"><span data-stu-id="05e2e-165">For serialization, <xref:System.Security.Permissions.SecurityPermission> with the <xref:System.Security.Permissions.SecurityPermissionAttribute.SerializationFormatter%2A?displayProperty=nameWithType> flag provides the ability to get and set members of serializable types, regardless of accessibility.</span></span> <span data-ttu-id="05e2e-166">此權限可讓程式碼探索及變更執行個體的私用狀態。</span><span class="sxs-lookup"><span data-stu-id="05e2e-166">This permission enables code to discover and change the private state of an instance.</span></span> <span data-ttu-id="05e2e-167">(除了授與適當的權限，也必須在中繼資料中將該類型[標示](../../standard/attributes/applying-attributes.md)為可序列化。)</span><span class="sxs-lookup"><span data-stu-id="05e2e-167">(In addition to being granted the appropriate permissions, the type must be [marked](../../standard/attributes/applying-attributes.md) as serializable in metadata.)</span></span>

## <a name="parameters-of-type-methodinfo"></a><span data-ttu-id="05e2e-168">MethodInfo 類型的參數</span><span class="sxs-lookup"><span data-stu-id="05e2e-168">Parameters of Type MethodInfo</span></span>

<span data-ttu-id="05e2e-169">避免撰寫採用 <xref:System.Reflection.MethodInfo> 參數的公用成員，特別是針對受信任的程式碼。</span><span class="sxs-lookup"><span data-stu-id="05e2e-169">Avoid writing public members that take <xref:System.Reflection.MethodInfo> parameters, especially for trusted code.</span></span> <span data-ttu-id="05e2e-170">這類成員比較容易受到惡意程式碼攻擊。</span><span class="sxs-lookup"><span data-stu-id="05e2e-170">Such members might be more vulnerable to malicious code.</span></span> <span data-ttu-id="05e2e-171">例如，請考慮採用 <xref:System.Reflection.MethodInfo> 參數之高度信任程式碼中的公用成員。</span><span class="sxs-lookup"><span data-stu-id="05e2e-171">For example, consider a public member in highly trusted code that takes a <xref:System.Reflection.MethodInfo> parameter.</span></span> <span data-ttu-id="05e2e-172">假設公用成員在所提供的參數上間接呼叫 <xref:System.Reflection.MethodBase.Invoke%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="05e2e-172">Assume that the public member indirectly calls the <xref:System.Reflection.MethodBase.Invoke%2A> method on the supplied parameter.</span></span> <span data-ttu-id="05e2e-173">如果公用成員沒有執行必要的權限檢查，呼叫 <xref:System.Reflection.MethodBase.Invoke%2A> 方法一定會成功，因為安全性系統會判定呼叫者是受高度信任。</span><span class="sxs-lookup"><span data-stu-id="05e2e-173">If the public member does not perform the necessary permission checks, the call to the <xref:System.Reflection.MethodBase.Invoke%2A> method will always succeed, because the security system determines that the caller is highly trusted.</span></span> <span data-ttu-id="05e2e-174">即使惡意程式碼沒有直接叫用方法的權限，它還是可以藉由呼叫公用成員來間接執行。</span><span class="sxs-lookup"><span data-stu-id="05e2e-174">Even if malicious code does not have the permission to directly invoke the method, it can still do so indirectly by calling the public member.</span></span>

## <a name="version-information"></a><span data-ttu-id="05e2e-175">版本資訊</span><span class="sxs-lookup"><span data-stu-id="05e2e-175">Version Information</span></span>

- <span data-ttu-id="05e2e-176">從 .NET Framework 4 開始，透明程式碼無法使用反映來存取安全性關鍵的成員。</span><span class="sxs-lookup"><span data-stu-id="05e2e-176">Beginning with the .NET Framework 4, transparent code cannot use reflection to access security-critical members.</span></span>

- <span data-ttu-id="05e2e-177">在 .NET Framework 2.0 Service Pack 1 中推出 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 旗標。</span><span class="sxs-lookup"><span data-stu-id="05e2e-177">The <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag is introduced in the .NET Framework 2.0 Service Pack 1.</span></span> <span data-ttu-id="05e2e-178">先前版本的 .NET Framework 針對使用反射來存取非公用成員程式碼需要 <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> 旗標。</span><span class="sxs-lookup"><span data-stu-id="05e2e-178">Earlier versions of the .NET Framework require the <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> flag for code that uses reflection to access nonpublic members.</span></span> <span data-ttu-id="05e2e-179">絕不要將此權限授與部分受信任的程式碼。</span><span class="sxs-lookup"><span data-stu-id="05e2e-179">This is a permission that should never be granted to partially trusted code.</span></span>

- <span data-ttu-id="05e2e-180">從 .NET Framework 2.0 開始，使用反映來取得非公開型別和成員的相關資訊時不需要任何權限。</span><span class="sxs-lookup"><span data-stu-id="05e2e-180">Beginning with the .NET Framework 2.0, using reflection to obtain information about nonpublic types and members does not require any permissions.</span></span> <span data-ttu-id="05e2e-181">在舊版中，會需要具有 <xref:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation?displayProperty=nameWithType> 旗標的 <xref:System.Security.Permissions.ReflectionPermission>。</span><span class="sxs-lookup"><span data-stu-id="05e2e-181">In earlier versions, <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation?displayProperty=nameWithType> flag is required.</span></span>

## <a name="see-also"></a><span data-ttu-id="05e2e-182">另請參閱</span><span class="sxs-lookup"><span data-stu-id="05e2e-182">See also</span></span>

- <xref:System.Security.Permissions.ReflectionPermissionFlag>
- <xref:System.Security.Permissions.ReflectionPermission>
- <xref:System.Security.Permissions.SecurityPermission>
- [<span data-ttu-id="05e2e-183">安全性變更</span><span class="sxs-lookup"><span data-stu-id="05e2e-183">Security Changes</span></span>](https://docs.microsoft.com/previous-versions/dotnet/framework/security/security-changes)
- [<span data-ttu-id="05e2e-184">代碼啟用安全性</span><span class="sxs-lookup"><span data-stu-id="05e2e-184">Code Access Security</span></span>](../misc/code-access-security.md)
- [<span data-ttu-id="05e2e-185">反映發出中的安全性問題</span><span class="sxs-lookup"><span data-stu-id="05e2e-185">Security Issues in Reflection Emit</span></span>](security-issues-in-reflection-emit.md)
- [<span data-ttu-id="05e2e-186">檢視類型資訊</span><span class="sxs-lookup"><span data-stu-id="05e2e-186">Viewing Type Information</span></span>](viewing-type-information.md)
- [<span data-ttu-id="05e2e-187">套用屬性</span><span class="sxs-lookup"><span data-stu-id="05e2e-187">Applying Attributes</span></span>](../../standard/attributes/applying-attributes.md)
- [<span data-ttu-id="05e2e-188">存取自訂屬性</span><span class="sxs-lookup"><span data-stu-id="05e2e-188">Accessing Custom Attributes</span></span>](accessing-custom-attributes.md)
