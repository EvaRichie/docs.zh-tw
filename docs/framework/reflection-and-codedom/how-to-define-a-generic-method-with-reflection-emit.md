---
title: 作法：使用反映發出定義泛型方法
description: 定義具有反映發出的泛型方法。 其中一個範例會建立具有兩個型別參數的泛型方法。 第二個範例顯示如何發出方法主體。
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- generics [.NET Framework], reflection emit
- reflection emit, generic methods
- generics [.NET Framework], dynamic types
ms.assetid: 93892fa4-90b3-4ec4-b147-4bec9880de2b
ms.openlocfilehash: 3b85fb480e5862daa3b2800f75392adbe92348f2
ms.sourcegitcommit: 3d84eac0818099c9949035feb96bbe0346358504
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 07/21/2020
ms.locfileid: "86865134"
---
# <a name="how-to-define-a-generic-method-with-reflection-emit"></a><span data-ttu-id="00b5f-105">作法：使用反映發出定義泛型方法</span><span class="sxs-lookup"><span data-stu-id="00b5f-105">How to: Define a Generic Method with Reflection Emit</span></span>

<span data-ttu-id="00b5f-106">第一個程序示範如何建立有兩個類型參數的簡單泛型方法，以及如何將類別條件約束、介面條件約束和特殊條件約束套用至類型參數。</span><span class="sxs-lookup"><span data-stu-id="00b5f-106">The first procedure shows how to create a simple generic method with two type parameters, and how to apply class constraints, interface constraints, and special constraints to the type parameters.</span></span>

<span data-ttu-id="00b5f-107">第二個程序示範如何發出方法主體，以及如何使用泛型方法的類型參數建立泛型型別的執行個體並呼叫其方法。</span><span class="sxs-lookup"><span data-stu-id="00b5f-107">The second procedure shows how to emit the method body, and how to use the type parameters of the generic method to create instances of generic types and to call their methods.</span></span>

<span data-ttu-id="00b5f-108">第三個程序示範如何叫用泛型方法。</span><span class="sxs-lookup"><span data-stu-id="00b5f-108">The third procedure shows how to invoke the generic method.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="00b5f-109">方法不是只因為屬於泛型型別並使用該類型的類型參數，而成為泛型。</span><span class="sxs-lookup"><span data-stu-id="00b5f-109">A method is not generic just because it belongs to a generic type and uses the type parameters of that type.</span></span> <span data-ttu-id="00b5f-110">方法只有在有自己的類型參數清單時，才會是泛型。</span><span class="sxs-lookup"><span data-stu-id="00b5f-110">A method is generic only if it has its own type parameter list.</span></span> <span data-ttu-id="00b5f-111">泛型方法可以出現在非泛型型別中，如本例所示。</span><span class="sxs-lookup"><span data-stu-id="00b5f-111">A generic method can appear on a nongeneric type, as in this example.</span></span> <span data-ttu-id="00b5f-112">如需泛型型別的非泛型方法範例，請參閱[如何︰使用反映發出定義泛型型別](how-to-define-a-generic-type-with-reflection-emit.md)。</span><span class="sxs-lookup"><span data-stu-id="00b5f-112">For an example of a nongeneric method on a generic type, see [How to: Define a Generic Type with Reflection Emit](how-to-define-a-generic-type-with-reflection-emit.md).</span></span>

### <a name="to-define-a-generic-method"></a><span data-ttu-id="00b5f-113">定義泛型方法</span><span class="sxs-lookup"><span data-stu-id="00b5f-113">To define a generic method</span></span>

1. <span data-ttu-id="00b5f-114">開始之前，最好先查看使用高階語言撰寫時的泛型方法顯示方式。</span><span class="sxs-lookup"><span data-stu-id="00b5f-114">Before beginning, it is useful to look at how the generic method appears when written using a high-level language.</span></span> <span data-ttu-id="00b5f-115">下列程式碼和呼叫泛型方法的程式碼一起包含在本主題的範例程式碼中。</span><span class="sxs-lookup"><span data-stu-id="00b5f-115">The following code is included in the example code for this topic, along with code to call the generic method.</span></span> <span data-ttu-id="00b5f-116">方法有兩個類型參數 `TInput`和`TOutput`，第二個必須是參考型別 (`class`)，必須有無參數建構函式 (`new`)，且必須實作 `ICollection(Of TInput)` (C# 為 `ICollection<TInput>`)。</span><span class="sxs-lookup"><span data-stu-id="00b5f-116">The method has two type parameters, `TInput` and `TOutput`, the second of which must be a reference type (`class`), must have a parameterless constructor (`new`), and must implement `ICollection(Of TInput)` (`ICollection<TInput>` in C#).</span></span> <span data-ttu-id="00b5f-117">此介面條件約束確保 <xref:System.Collections.Generic.ICollection%601.Add%2A?displayProperty=nameWithType> 方法可用來將項目新增至該方法所建立的 `TOutput` 集合。</span><span class="sxs-lookup"><span data-stu-id="00b5f-117">This interface constraint ensures that the <xref:System.Collections.Generic.ICollection%601.Add%2A?displayProperty=nameWithType> method can be used to add elements to the `TOutput` collection that the method creates.</span></span> <span data-ttu-id="00b5f-118">方法具有一個型式參數 `input`，這是一個 `TInput` 陣列。</span><span class="sxs-lookup"><span data-stu-id="00b5f-118">The method has one formal parameter, `input`, which is an array of `TInput`.</span></span> <span data-ttu-id="00b5f-119">此方法會建立類型 `TOutput` 的集合，並將 `input` 的項目複製至集合。</span><span class="sxs-lookup"><span data-stu-id="00b5f-119">The method creates a collection of type `TOutput` and copies the elements of `input` to the collection.</span></span>

    [!code-csharp[GenericMethodHowTo#20](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#20)]
    [!code-vb[GenericMethodHowTo#20](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#20)]

2. <span data-ttu-id="00b5f-120">定義動態組件和動態模組，以包含泛型方法所屬的類型。</span><span class="sxs-lookup"><span data-stu-id="00b5f-120">Define a dynamic assembly and a dynamic module to contain the type the generic method belongs to.</span></span> <span data-ttu-id="00b5f-121">在此情況下，組件僅有一個模組，名為 `DemoMethodBuilder1`，而且模組名稱是組件名稱加上副檔名。</span><span class="sxs-lookup"><span data-stu-id="00b5f-121">In this case, the assembly has only one module, named `DemoMethodBuilder1`, and the module name is the same as the assembly name plus an extension.</span></span> <span data-ttu-id="00b5f-122">在本例中，組件儲存到磁碟並執行，因此指定了 <xref:System.Reflection.Emit.AssemblyBuilderAccess.RunAndSave?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="00b5f-122">In this example, the assembly is saved to disk and also executed, so <xref:System.Reflection.Emit.AssemblyBuilderAccess.RunAndSave?displayProperty=nameWithType> is specified.</span></span> <span data-ttu-id="00b5f-123">您可以使用 [Ildasm.exe (IL 反組譯工具)](../tools/ildasm-exe-il-disassembler.md) 檢查 DemoMethodBuilder1.dll，並比較它和 Microsoft 中繼語言 (MSIL) 在步驟 1 中顯示的方法。</span><span class="sxs-lookup"><span data-stu-id="00b5f-123">You can use the [Ildasm.exe (IL Disassembler)](../tools/ildasm-exe-il-disassembler.md) to examine DemoMethodBuilder1.dll and to compare it to the Microsoft intermediate language (MSIL) for the method shown in step 1.</span></span>

    [!code-csharp[GenericMethodHowTo#2](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#2)]
    [!code-vb[GenericMethodHowTo#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#2)]

3. <span data-ttu-id="00b5f-124">定義泛型方法所屬的類型。</span><span class="sxs-lookup"><span data-stu-id="00b5f-124">Define the type the generic method belongs to.</span></span> <span data-ttu-id="00b5f-125">類型不必是泛型。</span><span class="sxs-lookup"><span data-stu-id="00b5f-125">The type does not have to be generic.</span></span> <span data-ttu-id="00b5f-126">泛型方法可以屬於泛型或非泛型型別。</span><span class="sxs-lookup"><span data-stu-id="00b5f-126">A generic method can belong to either a generic or nongeneric type.</span></span> <span data-ttu-id="00b5f-127">在本例中，類型是類別、不是泛型，且名為 `DemoType`。</span><span class="sxs-lookup"><span data-stu-id="00b5f-127">In this example, the type is a class, is not generic, and is named `DemoType`.</span></span>

    [!code-csharp[GenericMethodHowTo#3](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#3)]
    [!code-vb[GenericMethodHowTo#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#3)]

4. <span data-ttu-id="00b5f-128">定義泛型方法。</span><span class="sxs-lookup"><span data-stu-id="00b5f-128">Define the generic method.</span></span> <span data-ttu-id="00b5f-129">如果泛型方法的型式參數類型是由泛型方法的泛型型別參數所指定，請使用 <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%29> 方法多載來定義方法。</span><span class="sxs-lookup"><span data-stu-id="00b5f-129">If the types of a generic method's formal parameters are specified by generic type parameters of the generic method, use the <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%29> method overload to define the method.</span></span> <span data-ttu-id="00b5f-130">方法的泛型型別參數尚未定義，因此您無法在對 <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A> 的呼叫中指定方法的型式參數類型。</span><span class="sxs-lookup"><span data-stu-id="00b5f-130">The generic type parameters of the method are not yet defined, so you cannot specify the types of the method's formal parameters in the call to <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A>.</span></span> <span data-ttu-id="00b5f-131">在本例中，方法名為 `Factory`。</span><span class="sxs-lookup"><span data-stu-id="00b5f-131">In this example, the method is named `Factory`.</span></span> <span data-ttu-id="00b5f-132">方法是公用且 `static` (Visual Basic 為 `Shared`)。</span><span class="sxs-lookup"><span data-stu-id="00b5f-132">The method is public and `static` (`Shared` in Visual Basic).</span></span>

    [!code-csharp[GenericMethodHowTo#4](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#4)]
    [!code-vb[GenericMethodHowTo#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#4)]

5. <span data-ttu-id="00b5f-133">將包含參數名稱的字串陣列傳遞至 <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> 方法，以定義 `DemoMethod` 的泛型型別參數。</span><span class="sxs-lookup"><span data-stu-id="00b5f-133">Define the generic type parameters of `DemoMethod` by passing an array of strings containing the names of the parameters to the <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="00b5f-134">這會讓方法成為泛型方法。</span><span class="sxs-lookup"><span data-stu-id="00b5f-134">This makes the method a generic method.</span></span> <span data-ttu-id="00b5f-135">下列程式碼使 `Factory` 成為具有類型參數 `TInput` 和 `TOutput` 的泛型方法。</span><span class="sxs-lookup"><span data-stu-id="00b5f-135">The following code makes `Factory` a generic method with type parameters `TInput` and `TOutput`.</span></span> <span data-ttu-id="00b5f-136">為更方便閱讀程式碼，會建立有這些名稱的變數以保留代表兩個類型參數的 <xref:System.Reflection.Emit.GenericTypeParameterBuilder> 物件。</span><span class="sxs-lookup"><span data-stu-id="00b5f-136">To make the code easier to read, variables with these names are created to hold the <xref:System.Reflection.Emit.GenericTypeParameterBuilder> objects representing the two type parameters.</span></span>

    [!code-csharp[GenericMethodHowTo#5](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#5)]
    [!code-vb[GenericMethodHowTo#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#5)]

6. <span data-ttu-id="00b5f-137">或者將特殊條件約束新增至類型參數。</span><span class="sxs-lookup"><span data-stu-id="00b5f-137">Optionally add special constraints to the type parameters.</span></span> <span data-ttu-id="00b5f-138">使用 <xref:System.Reflection.Emit.GenericTypeParameterBuilder.SetGenericParameterAttributes%2A> 方法新增特殊條件約束。</span><span class="sxs-lookup"><span data-stu-id="00b5f-138">Special constraints are added using the <xref:System.Reflection.Emit.GenericTypeParameterBuilder.SetGenericParameterAttributes%2A> method.</span></span> <span data-ttu-id="00b5f-139">在本例中，`TOutput` 受限為參考型別，且具有無參數建構函式。</span><span class="sxs-lookup"><span data-stu-id="00b5f-139">In this example, `TOutput` is constrained to be a reference type and to have a parameterless constructor.</span></span>

    [!code-csharp[GenericMethodHowTo#6](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#6)]
    [!code-vb[GenericMethodHowTo#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#6)]

7. <span data-ttu-id="00b5f-140">或者將類別和介面條件約束新增至類型參數。</span><span class="sxs-lookup"><span data-stu-id="00b5f-140">Optionally add class and interface constraints to the type parameters.</span></span> <span data-ttu-id="00b5f-141">在本例中，類型參數 `TOutput` 受限為實作 `ICollection(Of TInput)` (C# 為 `ICollection<TInput>`) 介面的類型。</span><span class="sxs-lookup"><span data-stu-id="00b5f-141">In this example, type parameter `TOutput` is constrained to types that implement the `ICollection(Of TInput)` (`ICollection<TInput>` in C#) interface.</span></span> <span data-ttu-id="00b5f-142">這會確保 <xref:System.Collections.Generic.ICollection%601.Add%2A> 方法可用來新增項目。</span><span class="sxs-lookup"><span data-stu-id="00b5f-142">This ensures that the <xref:System.Collections.Generic.ICollection%601.Add%2A> method can be used to add elements.</span></span>

    [!code-csharp[GenericMethodHowTo#7](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#7)]
    [!code-vb[GenericMethodHowTo#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#7)]

8. <span data-ttu-id="00b5f-143">使用 <xref:System.Reflection.Emit.MethodBuilder.SetParameters%2A> 方法定義方法的型式參數。</span><span class="sxs-lookup"><span data-stu-id="00b5f-143">Define the formal parameters of the method, using the <xref:System.Reflection.Emit.MethodBuilder.SetParameters%2A> method.</span></span> <span data-ttu-id="00b5f-144">在本例中，`Factory` 方法有一個參數，是 `TInput` 的陣列。</span><span class="sxs-lookup"><span data-stu-id="00b5f-144">In this example, the `Factory` method has one parameter, an array of `TInput`.</span></span> <span data-ttu-id="00b5f-145">此類型是透過對代表 `TInput` 的 <xref:System.Reflection.Emit.GenericTypeParameterBuilder> 呼叫 <xref:System.Type.MakeArrayType%2A> 方法所建立。</span><span class="sxs-lookup"><span data-stu-id="00b5f-145">This type is created by calling the <xref:System.Type.MakeArrayType%2A> method on the <xref:System.Reflection.Emit.GenericTypeParameterBuilder> that represents `TInput`.</span></span> <span data-ttu-id="00b5f-146"><xref:System.Reflection.Emit.MethodBuilder.SetParameters%2A> 的引數是 <xref:System.Type> 物件的陣列。</span><span class="sxs-lookup"><span data-stu-id="00b5f-146">The argument of <xref:System.Reflection.Emit.MethodBuilder.SetParameters%2A> is an array of <xref:System.Type> objects.</span></span>

    [!code-csharp[GenericMethodHowTo#8](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#8)]
    [!code-vb[GenericMethodHowTo#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#8)]

9. <span data-ttu-id="00b5f-147">使用 <xref:System.Reflection.Emit.MethodBuilder.SetReturnType%2A> 方法定義方法的傳回類型。</span><span class="sxs-lookup"><span data-stu-id="00b5f-147">Define the return type for the method, using the <xref:System.Reflection.Emit.MethodBuilder.SetReturnType%2A> method.</span></span> <span data-ttu-id="00b5f-148">在本例中，會傳回 `TOutput` 的執行個體。</span><span class="sxs-lookup"><span data-stu-id="00b5f-148">In this example, an instance of `TOutput` is returned.</span></span>

    [!code-csharp[GenericMethodHowTo#9](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#9)]
    [!code-vb[GenericMethodHowTo#9](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#9)]

10. <span data-ttu-id="00b5f-149">使用 <xref:System.Reflection.Emit.ILGenerator> 發出方法主體。</span><span class="sxs-lookup"><span data-stu-id="00b5f-149">Emit the method body, using <xref:System.Reflection.Emit.ILGenerator>.</span></span> <span data-ttu-id="00b5f-150">如需詳細資訊，請參閱發出方法主體所伴隨的程序。</span><span class="sxs-lookup"><span data-stu-id="00b5f-150">For details, see the accompanying procedure for emitting the method body.</span></span>

    > [!IMPORTANT]
    > <span data-ttu-id="00b5f-151">當您向泛型型別的方法發出呼叫，而這些類型的類型引數是泛型方法的類型參數時，您必須使用 <xref:System.Reflection.Emit.TypeBuilder> 類別的 `static`<xref:System.Reflection.Emit.TypeBuilder.GetConstructor%28System.Type%2CSystem.Reflection.ConstructorInfo%29>、<xref:System.Reflection.Emit.TypeBuilder.GetMethod%28System.Type%2CSystem.Reflection.MethodInfo%29> 和 <xref:System.Reflection.Emit.TypeBuilder.GetField%28System.Type%2CSystem.Reflection.FieldInfo%29> 方法多載取得方法的建構形式。</span><span class="sxs-lookup"><span data-stu-id="00b5f-151">When you emit calls to methods of generic types, and the type arguments of those types are type parameters of the generic method, you must use the `static`<xref:System.Reflection.Emit.TypeBuilder.GetConstructor%28System.Type%2CSystem.Reflection.ConstructorInfo%29>, <xref:System.Reflection.Emit.TypeBuilder.GetMethod%28System.Type%2CSystem.Reflection.MethodInfo%29>, and <xref:System.Reflection.Emit.TypeBuilder.GetField%28System.Type%2CSystem.Reflection.FieldInfo%29> method overloads of the <xref:System.Reflection.Emit.TypeBuilder> class to obtain constructed forms of the methods.</span></span> <span data-ttu-id="00b5f-152">發出方法主體的伴隨程序會示範此作業。</span><span class="sxs-lookup"><span data-stu-id="00b5f-152">The accompanying procedure for emitting the method body demonstrates this.</span></span>

11. <span data-ttu-id="00b5f-153">完成包含方法的類型，並儲存組件。</span><span class="sxs-lookup"><span data-stu-id="00b5f-153">Complete the type that contains the method and save the assembly.</span></span> <span data-ttu-id="00b5f-154">叫用泛型方法伴隨的程序將示範叫用此完成的方法的兩種方式。</span><span class="sxs-lookup"><span data-stu-id="00b5f-154">The accompanying procedure for invoking the generic method shows two ways to invoke the completed method.</span></span>

    [!code-csharp[GenericMethodHowTo#14](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#14)]
    [!code-vb[GenericMethodHowTo#14](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#14)]

<a name="procedureSection1"></a>

### <a name="to-emit-the-method-body"></a><span data-ttu-id="00b5f-155">發出方法主體</span><span class="sxs-lookup"><span data-stu-id="00b5f-155">To emit the method body</span></span>

1. <span data-ttu-id="00b5f-156">取得程式碼產生器，並宣告區域變數和標籤。</span><span class="sxs-lookup"><span data-stu-id="00b5f-156">Get a code generator and declare local variables and labels.</span></span> <span data-ttu-id="00b5f-157">宣告區域變數是使用 <xref:System.Reflection.Emit.ILGenerator.DeclareLocal%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="00b5f-157">The <xref:System.Reflection.Emit.ILGenerator.DeclareLocal%2A> method is used to declare local variables.</span></span> <span data-ttu-id="00b5f-158">`Factory` 方法有四個區域變數︰`retVal` 保留方法傳回的新 `TOutput`，`ic` 在投射到 `ICollection(Of TInput)` 時保留 `TOutput` (C# 為`ICollection<TInput>`)，`input` 保留 `TInput` 物件的輸入陣列，而 `index` 則逐一查看陣列。</span><span class="sxs-lookup"><span data-stu-id="00b5f-158">The `Factory` method has four local variables: `retVal` to hold the new `TOutput` that is returned by the method, `ic` to hold the `TOutput` when it is cast to `ICollection(Of TInput)` (`ICollection<TInput>` in C#), `input` to hold the input array of `TInput` objects, and `index` to iterate through the array.</span></span> <span data-ttu-id="00b5f-159">此方法也有兩個標籤，一個是進入迴圈 (`enterLoop`)，另一個用於迴圈的頂端 (`loopAgain`)，使用 <xref:System.Reflection.Emit.ILGenerator.DefineLabel%2A> 方法所定義。</span><span class="sxs-lookup"><span data-stu-id="00b5f-159">The method also has two labels, one to enter the loop (`enterLoop`) and one for the top of the loop (`loopAgain`), defined using the <xref:System.Reflection.Emit.ILGenerator.DefineLabel%2A> method.</span></span>

    <span data-ttu-id="00b5f-160">此方法做的第一件事是使用 <xref:System.Reflection.Emit.OpCodes.Ldarg_0> 作業碼載入其引數，並使用 <xref:System.Reflection.Emit.OpCodes.Stloc_S> 作業碼將它儲存在區域變數 `input` 中。</span><span class="sxs-lookup"><span data-stu-id="00b5f-160">The first thing the method does is to load its argument using <xref:System.Reflection.Emit.OpCodes.Ldarg_0> opcode and to store it in the local variable `input` using <xref:System.Reflection.Emit.OpCodes.Stloc_S> opcode.</span></span>

    [!code-csharp[GenericMethodHowTo#10](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#10)]
    [!code-vb[GenericMethodHowTo#10](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#10)]

2. <span data-ttu-id="00b5f-161">使用 <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> 方法的泛型方法多載，發出程式碼以建立 `TOutput` 的執行個體。</span><span class="sxs-lookup"><span data-stu-id="00b5f-161">Emit code to create an instance of `TOutput`, using the generic method overload of the <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="00b5f-162">指定的類型需要有無參數建構函式才能使用此多載，這是在 `TOutput` 新增該條件約束的原因。</span><span class="sxs-lookup"><span data-stu-id="00b5f-162">Using this overload requires the specified type to have a parameterless constructor, which is the reason for adding that constraint to `TOutput`.</span></span> <span data-ttu-id="00b5f-163">將 `TOutput` 傳遞到 <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A>，以建立建構的泛型方法。</span><span class="sxs-lookup"><span data-stu-id="00b5f-163">Create the constructed generic method by passing `TOutput` to <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A>.</span></span> <span data-ttu-id="00b5f-164">發出程式碼以呼叫方法後，再使用 <xref:System.Reflection.Emit.OpCodes.Stloc_S> 發出程式碼將它儲存在區域變數 `retVal` 中。</span><span class="sxs-lookup"><span data-stu-id="00b5f-164">After emitting code to call the method, emit code to store it in the local variable `retVal` using <xref:System.Reflection.Emit.OpCodes.Stloc_S></span></span>

    [!code-csharp[GenericMethodHowTo#11](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#11)]
    [!code-vb[GenericMethodHowTo#11](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#11)]

3. <span data-ttu-id="00b5f-165">發出程式碼將新的 `TOutput` 物件投射成 `ICollection(Of TInput)`，並將它儲存在區域變數 `ic` 中。</span><span class="sxs-lookup"><span data-stu-id="00b5f-165">Emit code to cast the new `TOutput` object to `ICollection(Of TInput)` and store it in the local variable `ic`.</span></span>

    [!code-csharp[GenericMethodHowTo#31](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#31)]
    [!code-vb[GenericMethodHowTo#31](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#31)]

4. <span data-ttu-id="00b5f-166">取得代表 <xref:System.Collections.Generic.ICollection%601.Add%2A?displayProperty=nameWithType> 方法的 <xref:System.Reflection.MethodInfo>。</span><span class="sxs-lookup"><span data-stu-id="00b5f-166">Get a <xref:System.Reflection.MethodInfo> representing the <xref:System.Collections.Generic.ICollection%601.Add%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="00b5f-167">方法作用於 `ICollection(Of TInput)` (C# 為 `ICollection<TInput>`)，因此有必要取得專門針對該建構類型的 `Add` 方法。</span><span class="sxs-lookup"><span data-stu-id="00b5f-167">The method is acting on an `ICollection(Of TInput)` (`ICollection<TInput>` in C#), so it is necessary to get the `Add` method specific to that constructed type.</span></span> <span data-ttu-id="00b5f-168">您不能使用 <xref:System.Type.GetMethod%2A> 方法直接從 `icollOfTInput` 取得此 <xref:System.Reflection.MethodInfo>，因為已使用 <xref:System.Reflection.Emit.GenericTypeParameterBuilder> 建構的類型不支援 <xref:System.Type.GetMethod%2A>。</span><span class="sxs-lookup"><span data-stu-id="00b5f-168">You cannot use the <xref:System.Type.GetMethod%2A> method to get this <xref:System.Reflection.MethodInfo> directly from `icollOfTInput`, because <xref:System.Type.GetMethod%2A> is not supported on a type that has been constructed with a <xref:System.Reflection.Emit.GenericTypeParameterBuilder>.</span></span> <span data-ttu-id="00b5f-169">請改呼叫 `icoll` 的 <xref:System.Type.GetMethod%2A>，它包含 <xref:System.Collections.Generic.ICollection%601> 泛型介面的泛型型別定義。</span><span class="sxs-lookup"><span data-stu-id="00b5f-169">Instead, call <xref:System.Type.GetMethod%2A> on `icoll`, which contains the generic type definition for the <xref:System.Collections.Generic.ICollection%601> generic interface.</span></span> <span data-ttu-id="00b5f-170">然後使用 <xref:System.Reflection.Emit.TypeBuilder.GetMethod%28System.Type%2CSystem.Reflection.MethodInfo%29>`static` 方法產生建構類型的 <xref:System.Reflection.MethodInfo>。</span><span class="sxs-lookup"><span data-stu-id="00b5f-170">Then use the <xref:System.Reflection.Emit.TypeBuilder.GetMethod%28System.Type%2CSystem.Reflection.MethodInfo%29>`static` method to produce the <xref:System.Reflection.MethodInfo> for the constructed type.</span></span> <span data-ttu-id="00b5f-171">下列程式碼可示範這項處理。</span><span class="sxs-lookup"><span data-stu-id="00b5f-171">The following code demonstrates this.</span></span>

    [!code-csharp[GenericMethodHowTo#12](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#12)]
    [!code-vb[GenericMethodHowTo#12](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#12)]

5. <span data-ttu-id="00b5f-172">載入 32 位元的整數 0 並將其儲存在變數中，以發出程式碼來初始化 `index` 變數。</span><span class="sxs-lookup"><span data-stu-id="00b5f-172">Emit code to initialize the `index` variable, by loading a 32-bit integer 0 and storing it in the variable.</span></span> <span data-ttu-id="00b5f-173">發出程式碼以分支到標籤 `enterLoop`。</span><span class="sxs-lookup"><span data-stu-id="00b5f-173">Emit code to branch to the label `enterLoop`.</span></span> <span data-ttu-id="00b5f-174">此標籤尚未標示，因為它是在迴圈內。</span><span class="sxs-lookup"><span data-stu-id="00b5f-174">This label has not yet been marked, because it is inside the loop.</span></span> <span data-ttu-id="00b5f-175">下個步驟會發出此迴圈的程式碼。</span><span class="sxs-lookup"><span data-stu-id="00b5f-175">Code for the loop is emitted in the next step.</span></span>

    [!code-csharp[GenericMethodHowTo#32](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#32)]
    [!code-vb[GenericMethodHowTo#32](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#32)]

6. <span data-ttu-id="00b5f-176">發出此迴圈的程式碼。</span><span class="sxs-lookup"><span data-stu-id="00b5f-176">Emit code for the loop.</span></span> <span data-ttu-id="00b5f-177">第一個步驟是呼叫有 `loopAgain` 標籤的 <xref:System.Reflection.Emit.ILGenerator.MarkLabel%2A>，來標記迴圈頂端。</span><span class="sxs-lookup"><span data-stu-id="00b5f-177">The first step is to mark the top of the loop, by calling <xref:System.Reflection.Emit.ILGenerator.MarkLabel%2A> with the `loopAgain` label.</span></span> <span data-ttu-id="00b5f-178">使用標籤的分支陳述式現在會分支到程式碼的這個點。</span><span class="sxs-lookup"><span data-stu-id="00b5f-178">Branch statements that use the label will now branch to this point in the code.</span></span> <span data-ttu-id="00b5f-179">下個步驟推送 `TOutput` 物件、投射到 `ICollection(Of TInput)`，再到堆疊。</span><span class="sxs-lookup"><span data-stu-id="00b5f-179">The next step is to push the `TOutput` object, cast to `ICollection(Of TInput)`, onto the stack.</span></span> <span data-ttu-id="00b5f-180">它不是立即需要，但要就位以待呼叫 `Add` 方法。</span><span class="sxs-lookup"><span data-stu-id="00b5f-180">It is not needed immediately, but needs to be in position for calling the `Add` method.</span></span> <span data-ttu-id="00b5f-181">接下來，將輸入陣列推送至堆疊，再將包含目前索引的 `index` 變數推送至陣列。</span><span class="sxs-lookup"><span data-stu-id="00b5f-181">Next the input array is pushed onto the stack, then the `index` variable containing the current index into the array.</span></span> <span data-ttu-id="00b5f-182"><xref:System.Reflection.Emit.OpCodes.Ldelem> 作業碼會從堆疊取出索引和陣列，並將索引的陣列項目推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="00b5f-182">The <xref:System.Reflection.Emit.OpCodes.Ldelem> opcode pops the index and the array off the stack and pushes the indexed array element onto the stack.</span></span> <span data-ttu-id="00b5f-183">堆疊已就緒可呼叫 <xref:System.Collections.Generic.ICollection%601.Add%2A?displayProperty=nameWithType> 方法，它會從堆疊取出集合和新的項目，並將項目新增至集合。</span><span class="sxs-lookup"><span data-stu-id="00b5f-183">The stack is now ready for the call to the <xref:System.Collections.Generic.ICollection%601.Add%2A?displayProperty=nameWithType> method, which pops the collection and the new element off the stack and adds the element to the collection.</span></span>

    <span data-ttu-id="00b5f-184">迴圈中其餘的程式碼會遞增索引，並測試看迴圈是否已結束︰索引和 32 位元整數 1 會推送到堆疊並相加，將總和留在堆疊上，總和會儲存在 `index` 中。</span><span class="sxs-lookup"><span data-stu-id="00b5f-184">The rest of the code in the loop increments the index and tests to see whether the loop is finished: The index and a 32-bit integer 1 are pushed onto the stack and added, leaving the sum on the stack; the sum is stored in `index`.</span></span> <span data-ttu-id="00b5f-185">呼叫 <xref:System.Reflection.Emit.ILGenerator.MarkLabel%2A> 以將此點設定為迴圈的進入點。</span><span class="sxs-lookup"><span data-stu-id="00b5f-185"><xref:System.Reflection.Emit.ILGenerator.MarkLabel%2A> is called to set this point as the entry point for the loop.</span></span> <span data-ttu-id="00b5f-186">再次載入索引。</span><span class="sxs-lookup"><span data-stu-id="00b5f-186">The index is loaded again.</span></span> <span data-ttu-id="00b5f-187">輸入陣列會推送到堆疊，並發出 <xref:System.Reflection.Emit.OpCodes.Ldlen> 取得其長度。</span><span class="sxs-lookup"><span data-stu-id="00b5f-187">The input array is pushed on the stack, and <xref:System.Reflection.Emit.OpCodes.Ldlen> is emitted to get its length.</span></span> <span data-ttu-id="00b5f-188">索引和長度現在都在堆疊上，而 <xref:System.Reflection.Emit.OpCodes.Clt> 會發出以比較兩者。</span><span class="sxs-lookup"><span data-stu-id="00b5f-188">The index and the length are now on the stack, and <xref:System.Reflection.Emit.OpCodes.Clt> is emitted to compare them.</span></span> <span data-ttu-id="00b5f-189">如果索引小於長度，<xref:System.Reflection.Emit.OpCodes.Brtrue_S> 就會分支回到迴圈的開頭。</span><span class="sxs-lookup"><span data-stu-id="00b5f-189">If the index is less than the length, <xref:System.Reflection.Emit.OpCodes.Brtrue_S> branches back to the beginning of the loop.</span></span>

    [!code-csharp[GenericMethodHowTo#13](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#13)]
    [!code-vb[GenericMethodHowTo#13](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#13)]

7. <span data-ttu-id="00b5f-190">發出程式碼將 `TOutput` 物件推送至堆疊，並從方法傳回。</span><span class="sxs-lookup"><span data-stu-id="00b5f-190">Emit code to push the `TOutput` object onto the stack and return from the method.</span></span> <span data-ttu-id="00b5f-191">區域變數 `retVal` 和 `ic` 同時包含新 `TOutput` 的參考；`ic` 僅用於存取 <xref:System.Collections.Generic.ICollection%601.Add%2A?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="00b5f-191">The local variables `retVal` and `ic` both contain references to the new `TOutput`; `ic` is used only to access the <xref:System.Collections.Generic.ICollection%601.Add%2A?displayProperty=nameWithType> method.</span></span>

    [!code-csharp[GenericMethodHowTo#33](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#33)]
    [!code-vb[GenericMethodHowTo#33](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#33)]

<a name="procedureSection2"></a>

### <a name="to-invoke-the-generic-method"></a><span data-ttu-id="00b5f-192">叫用泛型方法。</span><span class="sxs-lookup"><span data-stu-id="00b5f-192">To invoke the generic method</span></span>

1. <span data-ttu-id="00b5f-193">`Factory` 是泛型方法定義。</span><span class="sxs-lookup"><span data-stu-id="00b5f-193">`Factory` is a generic method definition.</span></span> <span data-ttu-id="00b5f-194">為叫用它，您必須將類型指派給其泛型型別參數。</span><span class="sxs-lookup"><span data-stu-id="00b5f-194">In order to invoke it, you must assign types to its generic type parameters.</span></span> <span data-ttu-id="00b5f-195">請使用 <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> 方法完成此作業。</span><span class="sxs-lookup"><span data-stu-id="00b5f-195">Use the <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> method to do this.</span></span> <span data-ttu-id="00b5f-196">下列程式碼會建立建構泛型方法，為 `TInput` 指定 <xref:System.String>，為 `TOutput` 指定 `List(Of String)` (C# 為 `List<string>`)，並顯示代表方法的字串。</span><span class="sxs-lookup"><span data-stu-id="00b5f-196">The following code creates a constructed generic method, specifying <xref:System.String> for `TInput` and `List(Of String)` (`List<string>` in C#) for `TOutput`, and displays a string representation of the method.</span></span>

    [!code-csharp[GenericMethodHowTo#21](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#21)]
    [!code-vb[GenericMethodHowTo#21](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#21)]

2. <span data-ttu-id="00b5f-197">若要叫用晚期繫結方法，請使用 <xref:System.Reflection.MethodBase.Invoke%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="00b5f-197">To invoke the method late-bound, use the <xref:System.Reflection.MethodBase.Invoke%2A> method.</span></span> <span data-ttu-id="00b5f-198">下列程式碼會建立 <xref:System.Object> 的陣列，將其唯一項目包含為字串陣列，並將其當成泛型方法的引數清單傳遞。</span><span class="sxs-lookup"><span data-stu-id="00b5f-198">The following code creates an array of <xref:System.Object>, containing as its only element an array of strings, and passes it as the argument list for the generic method.</span></span> <span data-ttu-id="00b5f-199"><xref:System.Reflection.MethodBase.Invoke%2A> 的第一個參數為 Null 參考，因為方法是 `static`。</span><span class="sxs-lookup"><span data-stu-id="00b5f-199">The first parameter of <xref:System.Reflection.MethodBase.Invoke%2A> is a null reference because the method is `static`.</span></span> <span data-ttu-id="00b5f-200">傳回值會投射到 `List(Of String)`，並顯示其第一個項目。</span><span class="sxs-lookup"><span data-stu-id="00b5f-200">The return value is cast to `List(Of String)`, and its first element is displayed.</span></span>

    [!code-csharp[GenericMethodHowTo#22](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#22)]
    [!code-vb[GenericMethodHowTo#22](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#22)]

3. <span data-ttu-id="00b5f-201">若要使用委派叫用方法，您必須有符合建構泛型方法簽章的委派。</span><span class="sxs-lookup"><span data-stu-id="00b5f-201">To invoke the method using a delegate, you must have a delegate that matches the signature of the constructed generic method.</span></span> <span data-ttu-id="00b5f-202">執行此作業的簡單方法是建立泛型委派。</span><span class="sxs-lookup"><span data-stu-id="00b5f-202">An easy way to do this is to create a generic delegate.</span></span> <span data-ttu-id="00b5f-203">下列程式碼會使用 <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29?displayProperty=nameWithType> 方法多載建立在範例程式碼中定義之泛型委派 `D` 的執行個體，並叫用委派。</span><span class="sxs-lookup"><span data-stu-id="00b5f-203">The following code creates an instance of the generic delegate `D` defined in the example code, using the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29?displayProperty=nameWithType> method overload, and invokes the delegate.</span></span> <span data-ttu-id="00b5f-204">委派執行優於晚期繫結呼叫。</span><span class="sxs-lookup"><span data-stu-id="00b5f-204">Delegates perform better than late-bound calls.</span></span>

    [!code-csharp[GenericMethodHowTo#23](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#23)]
    [!code-vb[GenericMethodHowTo#23](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#23)]

4. <span data-ttu-id="00b5f-205">您也可以從指向已儲存組件的程式呼叫發出的方法。</span><span class="sxs-lookup"><span data-stu-id="00b5f-205">The emitted method can also be called from a program that refers to the saved assembly.</span></span>

## <a name="example"></a><span data-ttu-id="00b5f-206">範例</span><span class="sxs-lookup"><span data-stu-id="00b5f-206">Example</span></span>

<span data-ttu-id="00b5f-207">下列程式碼範例會建立具有泛型方法 `Factory` 的非泛型型別 `DemoType`。</span><span class="sxs-lookup"><span data-stu-id="00b5f-207">The following code example creates a nongeneric type, `DemoType`, with a generic method, `Factory`.</span></span> <span data-ttu-id="00b5f-208">此方法有兩個泛型型別參數：`TInput` 指定輸入類型，而 `TOutput` 指定輸出類型。</span><span class="sxs-lookup"><span data-stu-id="00b5f-208">This method has two generic type parameters, `TInput` to specify an input type and `TOutput` to specify an output type.</span></span> <span data-ttu-id="00b5f-209">`TOutput` 類型參數受限實作 `ICollection<TInput>` (Visual Basic 為 `ICollection(Of TInput)`)、為參考型別，且具有無參數建構函式。</span><span class="sxs-lookup"><span data-stu-id="00b5f-209">The `TOutput` type parameter is constrained to implement `ICollection<TInput>` (`ICollection(Of TInput)` in Visual Basic), to be a reference type, and to have a parameterless constructor.</span></span>

<span data-ttu-id="00b5f-210">方法具有一個型式參數，這是一個 `TInput` 陣列。</span><span class="sxs-lookup"><span data-stu-id="00b5f-210">The method has one formal parameter, which is an array of `TInput`.</span></span> <span data-ttu-id="00b5f-211">此方法會傳回 `TOutput` 的執行個體，包含該輸入陣列的所有項目。</span><span class="sxs-lookup"><span data-stu-id="00b5f-211">The method returns an instance of `TOutput` that contains all the elements of the input array.</span></span> <span data-ttu-id="00b5f-212">`TOutput` 可以是任何實作 <xref:System.Collections.Generic.ICollection%601> 泛型介面的泛型集合類型。</span><span class="sxs-lookup"><span data-stu-id="00b5f-212">`TOutput` can be any generic collection type that implements the <xref:System.Collections.Generic.ICollection%601> generic interface.</span></span>

<span data-ttu-id="00b5f-213">執行程式碼時，動態組件會儲存為 DemoGenericMethod1.dll，以及可以使用檢查[Ildasm.exe （IL 反組譯工具）](../tools/ildasm-exe-il-disassembler.md)。</span><span class="sxs-lookup"><span data-stu-id="00b5f-213">When the code is executed, the dynamic assembly is saved as DemoGenericMethod1.dll, and can be examined using the [Ildasm.exe (IL Disassembler)](../tools/ildasm-exe-il-disassembler.md).</span></span>

> [!NOTE]
> <span data-ttu-id="00b5f-214">若要瞭解如何發出程式碼的好方法是撰寫執行的工作，您嘗試發出，並可用於檢查編譯器所產生的 MSIL 反組譯工具的 Visual Basic、 C# 或 Visual c + + 程式。</span><span class="sxs-lookup"><span data-stu-id="00b5f-214">A good way to learn how to emit code is to write a Visual Basic, C#, or Visual C++ program that performs the task you are trying to emit, and use the disassembler to examine the MSIL produced by the compiler.</span></span>

<span data-ttu-id="00b5f-215">程式碼範例包含相當於發出的方法的原始程式碼。</span><span class="sxs-lookup"><span data-stu-id="00b5f-215">The code example includes source code that is equivalent to the emitted method.</span></span> <span data-ttu-id="00b5f-216">發出的方法會叫用晚期繫結，也使用泛型委派宣告在程式碼範例。</span><span class="sxs-lookup"><span data-stu-id="00b5f-216">The emitted method is invoked late-bound and also by using a generic delegate declared in the code example.</span></span>

[!code-csharp[GenericMethodHowTo#1](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#1)]
[!code-vb[GenericMethodHowTo#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#1)]

## <a name="see-also"></a><span data-ttu-id="00b5f-217">另請參閱</span><span class="sxs-lookup"><span data-stu-id="00b5f-217">See also</span></span>

- <xref:System.Reflection.Emit.MethodBuilder>
- [<span data-ttu-id="00b5f-218">作法：使用反映發出定義泛型型別</span><span class="sxs-lookup"><span data-stu-id="00b5f-218">How to: Define a Generic Type with Reflection Emit</span></span>](how-to-define-a-generic-type-with-reflection-emit.md)
