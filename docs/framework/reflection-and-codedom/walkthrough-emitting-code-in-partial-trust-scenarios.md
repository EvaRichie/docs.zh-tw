---
title: 逐步解說：在部分信任情節中發出程式碼
description: 請參閱如何在部分信任案例中發出程式碼。 反映發出會使用相同的 Api，但某些功能在部分信任的程式碼中需要特殊許可權。
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- reflection emit, anonymously hosted dynamic methods
- partial trust, reflection
- partial trust, emitting dynamic methods
- reflection emit, partial trust scenarios
- anonymously hosted dynamic methods [.NET Framework]
- emitting dynamic assemblies,partial trust scenarios
- reflection emit, dynamic methods
- dynamic methods
ms.assetid: c45be261-2a9d-4c4e-9bd6-27f0931b7d25
ms.openlocfilehash: 70adb3ce67b45459b18741948092a912f6173731
ms.sourcegitcommit: 3d84eac0818099c9949035feb96bbe0346358504
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 07/21/2020
ms.locfileid: "86865186"
---
# <a name="walkthrough-emitting-code-in-partial-trust-scenarios"></a><span data-ttu-id="ec8bf-104">逐步解說：在部分信任情節中發出程式碼</span><span class="sxs-lookup"><span data-stu-id="ec8bf-104">Walkthrough: Emitting Code in Partial Trust Scenarios</span></span>

<span data-ttu-id="ec8bf-105">反映發出在完整或部分信任中使用相同的 API 集合，但在部分信任程式碼中，有些功能需要特殊權限。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-105">Reflection emit uses the same API set in full or partial trust, but some features require special permissions in partially trusted code.</span></span> <span data-ttu-id="ec8bf-106">此外，反映發出還有一項匿名裝載動態方法的功能，設計搭配部分信任使用並可供安全性透明組件使用。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-106">In addition, reflection emit has a feature, anonymously hosted dynamic methods, that is designed to be used with partial trust and by security-transparent assemblies.</span></span>

> [!NOTE]
> <span data-ttu-id="ec8bf-107">在 .NET Framework 3.5 之前，發出程式碼需要 <xref:System.Security.Permissions.ReflectionPermission> 及 <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> 旗標。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-107">Before .NET Framework 3.5, emitting code required <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flag.</span></span> <span data-ttu-id="ec8bf-108">根據預設，此權限包含在 `FullTrust` 和 `Intranet` 具名權限集合中，不在 `Internet` 權限集合中。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-108">This permission is included by default in the `FullTrust` and `Intranet` named permission sets, but not in the `Internet` permission set.</span></span> <span data-ttu-id="ec8bf-109">因此，只有在程式庫有 <xref:System.Security.SecurityCriticalAttribute> 屬性，同時執行了 <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit> 的 <xref:System.Security.PermissionSet.Assert%2A> 方法，才能從部分信任使用該程式庫。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-109">Therefore, a library could be used from partial trust only if it had the <xref:System.Security.SecurityCriticalAttribute> attribute and also executed an <xref:System.Security.PermissionSet.Assert%2A> method for <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit>.</span></span> <span data-ttu-id="ec8bf-110">這類程式庫需要仔細的安全性檢閱，因為編碼錯誤可能會造成安全性漏洞。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-110">Such libraries require careful security review because coding errors could result in security holes.</span></span> <span data-ttu-id="ec8bf-111">.NET Framework 3.5 允許在部分信任案例中發出程式碼，而不需提出任何安全性要求，因為產生的程式碼本質上並非有權限的作業。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-111">The .NET Framework 3.5 allows code to be emitted in partial trust scenarios without issuing any security demands, because generating code is not inherently a privileged operation.</span></span> <span data-ttu-id="ec8bf-112">也就是產生的程式碼之權限不會比發出程式碼的組件還多。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-112">That is, the generated code has no more permissions than the assembly that emits it.</span></span> <span data-ttu-id="ec8bf-113">這可讓發出程式碼的程式庫成為安全性透明的，並移除判斷提示 <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit> 的需要，讓撰寫安全的程式庫不需要仔細的安全性檢閱。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-113">This enables libraries that emit code to be security-transparent and removes the need to assert <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit>, so that writing a secure library does not require such a thorough security review.</span></span>

<span data-ttu-id="ec8bf-114">本逐步解說將說明下列工作：</span><span class="sxs-lookup"><span data-stu-id="ec8bf-114">This walkthrough illustrates the following tasks:</span></span>

- <span data-ttu-id="ec8bf-115">[設定簡單沙箱以測試部分信任程式碼](#Setting_up)。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-115">[Setting up a simple sandbox for testing partially trusted code](#Setting_up).</span></span>

  > [!IMPORTANT]
  > <span data-ttu-id="ec8bf-116">這是實驗部分信任程式碼的簡單方法。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-116">This is a simple way to experiment with code in partial trust.</span></span> <span data-ttu-id="ec8bf-117">若要執行實際來自不受信任位置的程式碼，請參閱[如何：在沙箱中執行部分信任的程式碼](../misc/how-to-run-partially-trusted-code-in-a-sandbox.md)。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-117">To run code that actually comes from untrusted locations, see [How to: Run Partially Trusted Code in a Sandbox](../misc/how-to-run-partially-trusted-code-in-a-sandbox.md).</span></span>

- <span data-ttu-id="ec8bf-118">[在部分信任的應用程式定義域中執行程式碼](#Running_code)。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-118">[Running code in partially trusted application domains](#Running_code).</span></span>

- <span data-ttu-id="ec8bf-119">[使用匿名裝載的動態方法，發出並執行部分信任的程式碼](#Using_methods)。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-119">[Using anonymously hosted dynamic methods to emit and execute code in partial trust](#Using_methods).</span></span>

<span data-ttu-id="ec8bf-120">如需在部分信任案例中發出程式碼的詳細資訊，請參閱[反映發出中的安全性問題](security-issues-in-reflection-emit.md)。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-120">For more information about emitting code in partial trust scenarios, see [Security Issues in Reflection Emit](security-issues-in-reflection-emit.md).</span></span>

<span data-ttu-id="ec8bf-121">如需這些程序所示範程式碼的完整清單，請參閱本逐步解說結尾的[範例](#Example)一節。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-121">For a complete listing of the code shown in these procedures, see the [Example section](#Example) at the end of this walkthrough.</span></span>

<a name="Setting_up"></a>

## <a name="setting-up-partially-trusted-locations"></a><span data-ttu-id="ec8bf-122">設定部分信任的位置</span><span class="sxs-lookup"><span data-stu-id="ec8bf-122">Setting up Partially Trusted Locations</span></span>

<span data-ttu-id="ec8bf-123">下列兩項程序會示範如何從您可以測試部分信任程式碼的位置設定位置。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-123">The following two procedures show how to set up locations from which you can test code with partial trust.</span></span>

- <span data-ttu-id="ec8bf-124">第一項程序示範如何建立沙箱應用程式定義域，程式碼在其中會獲授與網際網路權限。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-124">The first procedure shows how to create a sandboxed application domain in which code is granted Internet permissions.</span></span>

- <span data-ttu-id="ec8bf-125">第二項程序顯示如何將有 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 旗標的 <xref:System.Security.Permissions.ReflectionPermission>，新增至部分信任的應用程式定義域，以便存取相同或較低信任組件中的私用資料。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-125">The second procedure shows how to add <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag to a partially trusted application domain, to enable access to private data in assemblies of equal or lesser trust.</span></span>

### <a name="creating-sandboxed-application-domains"></a><span data-ttu-id="ec8bf-126">建立沙箱應用程式定義域</span><span class="sxs-lookup"><span data-stu-id="ec8bf-126">Creating Sandboxed Application Domains</span></span>

<span data-ttu-id="ec8bf-127">若要建立可用部分信任執行組件的應用程式定義域，您必須使用 <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> 方法多載來建立應用程式定義域，指定將權限集授與這些組件。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-127">To create an application domain in which your assemblies run with partial trust, you must specify the set of permissions to be granted to the assemblies by using the <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> method overload to create the application domain.</span></span> <span data-ttu-id="ec8bf-128">指定授權集最簡單的方式，是從安全性原則擷取具名權限集。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-128">The easiest way to specify the grant set is to retrieve a named permission set from security policy.</span></span>

<span data-ttu-id="ec8bf-129">下列程序會建立沙箱應用程式定義域，用部分信任的執行程式碼，測試發出的程式碼只能存取公用類型公用成員的案例。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-129">The following procedure creates a sandboxed application domain that runs your code with partial trust, to test scenarios in which emitted code can access only public members of public types.</span></span> <span data-ttu-id="ec8bf-130">後續程序示範如何新增 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess>，測試發出的程式碼可以存取非公用類型和成員的案例，而這些類型和成員所在組件具有相同或較低的權限。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-130">A subsequent procedure shows how to add <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess>, to test scenarios in which emitted code can access nonpublic types and members in assemblies that are granted equal or lesser permissions.</span></span>

#### <a name="to-create-an-application-domain-with-partial-trust"></a><span data-ttu-id="ec8bf-131">建立部份信任的應用程式定義域</span><span class="sxs-lookup"><span data-stu-id="ec8bf-131">To create an application domain with partial trust</span></span>

1. <span data-ttu-id="ec8bf-132">建立權限集，以授與沙箱應用程式定義域中的組件。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-132">Create a permission set to grant to the assemblies in the sandboxed application domain.</span></span> <span data-ttu-id="ec8bf-133">在此情況下，會使用網際網路區域的權限集。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-133">In this case, the permission set of the Internet zone is used.</span></span>

    [!code-csharp[HowToEmitCodeInPartialTrust#2](../../../samples/snippets/csharp/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/cs/source.cs#2)]
    [!code-vb[HowToEmitCodeInPartialTrust#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/vb/source.vb#2)]

2. <span data-ttu-id="ec8bf-134">建立 <xref:System.AppDomainSetup> 物件來初始化具有應用程式路徑的應用程式定義域。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-134">Create an <xref:System.AppDomainSetup> object to initialize the application domain with an application path.</span></span>

    > [!IMPORTANT]
    > <span data-ttu-id="ec8bf-135">為簡單起見，此程式碼範例會使用目前的資料夾。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-135">For simplicity, this code example uses the current folder.</span></span> <span data-ttu-id="ec8bf-136">若要執行實際來自網際網路的程式碼，不受信任的程式碼請使用另外的資料夾，依[如何：在沙箱中執行部分信任的程式碼](../misc/how-to-run-partially-trusted-code-in-a-sandbox.md)中所述。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-136">To run code that actually comes from the Internet, use a separate folder for the untrusted code, as described in [How to: Run Partially Trusted Code in a Sandbox](../misc/how-to-run-partially-trusted-code-in-a-sandbox.md).</span></span>

    [!code-csharp[HowToEmitCodeInPartialTrust#3](../../../samples/snippets/csharp/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/cs/source.cs#3)]
    [!code-vb[HowToEmitCodeInPartialTrust#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/vb/source.vb#3)]

3. <span data-ttu-id="ec8bf-137">建立應用程式定義域，指定應用程式定義域安裝資訊，以及在應用程式定義域中執行的所有組件授權集。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-137">Create the application domain, specifying the application domain setup information and the grant set for all assemblies that execute in the application domain.</span></span>

    [!code-csharp[HowToEmitCodeInPartialTrust#5](../../../samples/snippets/csharp/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/cs/source.cs#5)]
    [!code-vb[HowToEmitCodeInPartialTrust#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/vb/source.vb#5)]

    <span data-ttu-id="ec8bf-138"><xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> 方法多載的最後一個參數可讓您指定組件集合，授與完全信任，而不是應用程式定義域的授權集。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-138">The last parameter of the <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> method overload enables you to specify a set of assemblies that are to be granted full trust, instead of the grant set of the application domain.</span></span> <span data-ttu-id="ec8bf-139">因為這些組件位於全域組件快取，所以您不必指定應用程式使用的 .NET Framework 組件。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-139">You do not have to specify the .NET Framework assemblies that your application uses, because those assemblies are in the global assembly cache.</span></span> <span data-ttu-id="ec8bf-140">全域組件快取中的組件一律為完全信任。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-140">Assemblies in the global assembly cache are always fully trusted.</span></span> <span data-ttu-id="ec8bf-141">您可以使用這個參數指定不在全域組件快取中的強式名稱組件。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-141">You can use this parameter to specify strong-named assemblies that are not in the global assembly cache.</span></span>

### <a name="adding-restrictedmemberaccess-to-sandboxed-domains"></a><span data-ttu-id="ec8bf-142">將 RestrictedMemberAccess 新增至沙箱定義域</span><span class="sxs-lookup"><span data-stu-id="ec8bf-142">Adding RestrictedMemberAccess to Sandboxed Domains</span></span>

<span data-ttu-id="ec8bf-143">主應用程式可以允許匿名裝載的動態方法，存取組件中的私用資料，這些組件的信任層級都等於或低於發出程式碼的組件信任層級。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-143">Host applications can allow anonymously hosted dynamic methods to have access to private data in assemblies that have trust levels equal to or less than the trust level of the assembly that emits the code.</span></span> <span data-ttu-id="ec8bf-144">若要啟用此有限功能以略過 Just-In-Time (JIT) 可視性檢查，主應用程式會將具有 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> (RMA) 旗標的 <xref:System.Security.Permissions.ReflectionPermission> 物件新增至授權集。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-144">To enable this restricted ability to skip just-in-time (JIT) visibility checks, the host application adds a <xref:System.Security.Permissions.ReflectionPermission> object with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> (RMA) flag to the grant set.</span></span>

<span data-ttu-id="ec8bf-145">例如，主機可能會授與網際網路應用程式加上 RMA 的網際網路權限，讓網際網路應用程式可以發出程式碼，存取自己組件中的私用資料。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-145">For example, a host might grant Internet applications Internet permissions plus RMA, so that an Internet application can emit code that accesses private data in its own assemblies.</span></span> <span data-ttu-id="ec8bf-146">因為存取已限制在相同或較低信任的組件，所以網際網路應用程式無法存取完全信任組件的成員，例如 .NET Framework 組件。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-146">Because the access is limited to assemblies of equal or lesser trust, an Internet application cannot access members of fully trusted assemblies such as .NET Framework assemblies.</span></span>

> [!NOTE]
> <span data-ttu-id="ec8bf-147">為防止提高權限，建構匿名裝載的動態方法時，會包含發出組件的堆疊資訊。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-147">To prevent elevation of privilege, stack information for the emitting assembly is included when anonymously hosted dynamic methods are constructed.</span></span> <span data-ttu-id="ec8bf-148">叫用方法時會檢查堆疊資訊。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-148">When the method is invoked, the stack information is checked.</span></span> <span data-ttu-id="ec8bf-149">因此，從完全信任程式碼叫用的匿名裝載動態方法，其信任層級仍限於發出組件的信任層級。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-149">Thus, an anonymously hosted dynamic method that is invoked from fully trusted code is still limited to the trust level of the emitting assembly.</span></span>

#### <a name="to-create-an-application-domain-with-partial-trust-plus-rma"></a><span data-ttu-id="ec8bf-150">建立加上 RMA 的部份信任應用程式定義域</span><span class="sxs-lookup"><span data-stu-id="ec8bf-150">To create an application domain with partial trust plus RMA</span></span>

1. <span data-ttu-id="ec8bf-151">建立具有 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess>(RMA) 旗標的新 <xref:System.Security.Permissions.ReflectionPermission> 物件，並使用 <xref:System.Security.PermissionSet.SetPermission%2A?displayProperty=nameWithType> 方法將權限新增至授權集。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-151">Create a new <xref:System.Security.Permissions.ReflectionPermission> object with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess> (RMA) flag, and use the <xref:System.Security.PermissionSet.SetPermission%2A?displayProperty=nameWithType> method to add the permission to the grant set.</span></span>

    [!code-csharp[HowToEmitCodeInPartialTrust#7](../../../samples/snippets/csharp/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/cs/source.cs#7)]
    [!code-vb[HowToEmitCodeInPartialTrust#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/vb/source.vb#7)]

    <span data-ttu-id="ec8bf-152">權限若未包含在內，<xref:System.Security.PermissionSet.AddPermission%2A> 方法會將權限新增至授權集。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-152">The <xref:System.Security.PermissionSet.AddPermission%2A> method adds the permission to the grant set if it is not already included.</span></span> <span data-ttu-id="ec8bf-153">如果授權集已包含權限，指定的旗標就會新增至現有的權限。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-153">If the permission is already included in the grant set, the specified flags are added to the existing permission.</span></span>

    > [!NOTE]
    > <span data-ttu-id="ec8bf-154">RMA 是匿名裝載動態方法的功能。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-154">RMA is a feature of anonymously hosted dynamic methods.</span></span> <span data-ttu-id="ec8bf-155">當一般的動態方法略過 JIT 可見度檢查時，發出的程式碼需要完全信任。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-155">When ordinary dynamic methods skip JIT visibility checks, the emitted code requires full trust.</span></span>

2. <span data-ttu-id="ec8bf-156">建立應用程式定義域，指定應用程式定義域安裝資訊及授權集。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-156">Create the application domain, specifying the application domain setup information and the grant set.</span></span>

    [!code-csharp[HowToEmitCodeInPartialTrust#8](../../../samples/snippets/csharp/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/cs/source.cs#8)]
    [!code-vb[HowToEmitCodeInPartialTrust#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/vb/source.vb#8)]

<a name="Running_code"></a>

## <a name="running-code-in-sandboxed-application-domains"></a><span data-ttu-id="ec8bf-157">在沙箱應用程式定義域中執行程式碼</span><span class="sxs-lookup"><span data-stu-id="ec8bf-157">Running Code in Sandboxed Application Domains</span></span>

<span data-ttu-id="ec8bf-158">下列程序說明如何使用可在應用程式定義域中執行的方法來定義類別、如何在定義域中建立類別的執行個體，以及如何執行其方法。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-158">The following procedure explains how to define a class by using methods that can be executed in an application domain, how to create an instance of the class in the domain, and how to execute its methods.</span></span>

#### <a name="to-define-and-execute-a-method-in-an-application-domain"></a><span data-ttu-id="ec8bf-159">在應用程式定義域中定義及執行方法</span><span class="sxs-lookup"><span data-stu-id="ec8bf-159">To define and execute a method in an application domain</span></span>

1. <span data-ttu-id="ec8bf-160">定義衍生自 <xref:System.MarshalByRefObject> 的類別。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-160">Define a class that derives from <xref:System.MarshalByRefObject>.</span></span> <span data-ttu-id="ec8bf-161">這可讓您在其他的應用程式定義域中建立類別的執行個體，以及跨應用程式定義域界限進行方法呼叫。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-161">This enables you to create instances of the class in other application domains and to make method calls across application domain boundaries.</span></span> <span data-ttu-id="ec8bf-162">本例中的類別名為 `Worker`。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-162">The class in this example is named `Worker`.</span></span>

    [!code-csharp[HowToEmitCodeInPartialTrust#10](../../../samples/snippets/csharp/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/cs/source.cs#10)]
    [!code-vb[HowToEmitCodeInPartialTrust#10](../../../samples/snippets/visualbasic/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/vb/source.vb#10)]

2. <span data-ttu-id="ec8bf-163">定義公用方法，包含您想要執行的程式碼。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-163">Define a public method that contains the code you want to execute.</span></span> <span data-ttu-id="ec8bf-164">在此範例中，程式碼會發出簡單的動態方法、建立委派來執行方法，並叫用委派。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-164">In this example, the code emits a simple dynamic method, creates a delegate to execute the method, and invokes the delegate.</span></span>

    [!code-csharp[HowToEmitCodeInPartialTrust#11](../../../samples/snippets/csharp/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/cs/source.cs#11)]
    [!code-vb[HowToEmitCodeInPartialTrust#11](../../../samples/snippets/visualbasic/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/vb/source.vb#11)]

3. <span data-ttu-id="ec8bf-165">在您的主程式中，取得組件的顯示名稱。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-165">In your main program, get the display name of your assembly.</span></span> <span data-ttu-id="ec8bf-166">當您在沙箱應用程式定義域中建立 `Worker` 類別的執行個體時，會使用此名稱。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-166">This name is used when you create instances of the `Worker` class in the sandboxed application domain.</span></span>

    [!code-csharp[HowToEmitCodeInPartialTrust#14](../../../samples/snippets/csharp/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/cs/source.cs#14)]
    [!code-vb[HowToEmitCodeInPartialTrust#14](../../../samples/snippets/visualbasic/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/vb/source.vb#14)]

4. <span data-ttu-id="ec8bf-167">在您的主程式中建立沙箱應用程式定義域，如本逐步解說的[第一項程序](#Setting_up)中所述。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-167">In your main program, create a sandboxed application domain, as described in [the first procedure](#Setting_up) in this walkthrough.</span></span> <span data-ttu-id="ec8bf-168">因為 `SimpleEmitDemo` 方法只使用公用方法，所以您不必新增任何權限到 `Internet` 權限集。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-168">You do not have to add any permissions to the `Internet` permission set, because the `SimpleEmitDemo` method uses only public methods.</span></span>

5. <span data-ttu-id="ec8bf-169">在您的主程式中，在沙箱應用程式定義域中建立 `Worker` 類別的執行個體。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-169">In your main program, create an instance of the `Worker` class in the sandboxed application domain.</span></span>

    [!code-csharp[HowToEmitCodeInPartialTrust#12](../../../samples/snippets/csharp/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/cs/source.cs#12)]
    [!code-vb[HowToEmitCodeInPartialTrust#12](../../../samples/snippets/visualbasic/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/vb/source.vb#12)]

    <span data-ttu-id="ec8bf-170"><xref:System.AppDomain.CreateInstanceAndUnwrap%2A> 方法會在目標應用程式定義域中建立物件，傳回可以用來呼叫物件屬性和方法的 proxy。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-170">The <xref:System.AppDomain.CreateInstanceAndUnwrap%2A> method creates the object in the target application domain and returns a proxy that can be used to call the properties and methods of the object.</span></span>

    > [!NOTE]
    > <span data-ttu-id="ec8bf-171">如果您在 Visual Studio 中使用此程式碼，則必須變更類別名稱以包含命名空間。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-171">If you use this code in Visual Studio, you must change the name of the class to include the namespace.</span></span> <span data-ttu-id="ec8bf-172">命名空間是專案的預設名稱。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-172">By default, the namespace is the name of the project.</span></span> <span data-ttu-id="ec8bf-173">例如，如果專案是 "PartialTrust"，則類別名稱必須是 "PartialTrust.Worker"。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-173">For example, if the project is "PartialTrust", the class name must be "PartialTrust.Worker".</span></span>

6. <span data-ttu-id="ec8bf-174">新增程式碼以呼叫 `SimpleEmitDemo` 方法。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-174">Add code to call the `SimpleEmitDemo` method.</span></span> <span data-ttu-id="ec8bf-175">呼叫會跨應用程式定義域界限封送處理，而程式碼則在沙箱應用程式定義域中執行。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-175">The call is marshaled across the application domain boundary, and the code is executed in the sandboxed application domain.</span></span>

    [!code-csharp[HowToEmitCodeInPartialTrust#13](../../../samples/snippets/csharp/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/cs/source.cs#13)]
    [!code-vb[HowToEmitCodeInPartialTrust#13](../../../samples/snippets/visualbasic/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/vb/source.vb#13)]

<a name="Using_methods"></a>

## <a name="using-anonymously-hosted-dynamic-methods"></a><span data-ttu-id="ec8bf-176">使用匿名裝載的動態方法</span><span class="sxs-lookup"><span data-stu-id="ec8bf-176">Using Anonymously Hosted Dynamic Methods</span></span>

<span data-ttu-id="ec8bf-177">匿名裝載動態方法與系統提供的透明組件相關聯。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-177">Anonymously hosted dynamic methods are associated with a transparent assembly that is provided by the system.</span></span> <span data-ttu-id="ec8bf-178">因此，它們所包含的程式碼是透明的。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-178">Therefore, the code they contain is transparent.</span></span> <span data-ttu-id="ec8bf-179">另一方面，一般的動態方法必須與現有的模組相關聯 (不論是直接指定或推斷的相關聯類型)），並接受該模組的安全性層級。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-179">Ordinary dynamic methods, on the other hand, must be associated with an existing module (whether directly specified or inferred from an associated type), and take their security level from that module.</span></span>

> [!NOTE]
> <span data-ttu-id="ec8bf-180">動態方法與提供匿名裝載之組件建立關聯的唯一方法，是使用下列程序中描述的建構函式。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-180">The only way to associate a dynamic method with the assembly that provides anonymous hosting is to use the constructors that are described in the following procedure.</span></span> <span data-ttu-id="ec8bf-181">您不能在匿名裝載的組件中明確指定模組。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-181">You cannot explicitly specify a module in the anonymous hosting assembly.</span></span>

<span data-ttu-id="ec8bf-182">一般的動態方法可以存取相關聯模組的內部成員，或相關聯類型的私用成員。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-182">Ordinary dynamic methods have access to the internal members of the module they are associated with, or to the private members of the type they are associated with.</span></span> <span data-ttu-id="ec8bf-183">因為匿名裝載的動態方法和其他程式碼是分開的，所以它們不能存取私用資料。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-183">Because anonymously hosted dynamic methods are isolated from other code, they do not have access to private data.</span></span> <span data-ttu-id="ec8bf-184">但是，它們在有限的情況下可以略過 JIT 可見度檢查，存取私用資料。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-184">However, they do have a restricted ability to skip JIT visibility checks to gain access to private data.</span></span> <span data-ttu-id="ec8bf-185">這項功能僅限於信任層級等於或低於發出程式碼組件信任層級的組件。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-185">This ability is limited to assemblies that have trust levels equal to or less than the trust level of the assembly that emits the code.</span></span>

<span data-ttu-id="ec8bf-186">為防止提高權限，建構匿名裝載的動態方法時，會包含發出組件的堆疊資訊。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-186">To prevent elevation of privilege, stack information for the emitting assembly is included when anonymously hosted dynamic methods are constructed.</span></span> <span data-ttu-id="ec8bf-187">叫用方法時會檢查堆疊資訊。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-187">When the method is invoked, the stack information is checked.</span></span> <span data-ttu-id="ec8bf-188">從完全信任程式碼叫用的匿名裝載動態方法，其信任層級仍限於發出組件的信任層級。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-188">An anonymously hosted dynamic method that is invoked from fully trusted code is still limited to the trust level of the assembly that emitted it.</span></span>

#### <a name="to-use-anonymously-hosted-dynamic-methods"></a><span data-ttu-id="ec8bf-189">使用匿名裝載的動態方法</span><span class="sxs-lookup"><span data-stu-id="ec8bf-189">To use anonymously hosted dynamic methods</span></span>

- <span data-ttu-id="ec8bf-190">使用不指定相關聯模組或類型的建構函式，建立匿名裝載的動態方法。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-190">Create an anonymously hosted dynamic method by using a constructor that does not specify an associated module or type.</span></span>

  [!code-csharp[HowToEmitCodeInPartialTrust#15](../../../samples/snippets/csharp/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/cs/source.cs#15)]
  [!code-vb[HowToEmitCodeInPartialTrust#15](../../../samples/snippets/visualbasic/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/vb/source.vb#15)]

  <span data-ttu-id="ec8bf-191">如果匿名裝載的動態方法只使用公用類型和方法，就不需要限制成員存取，也不必略過 JIT 可見度檢查。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-191">If an anonymously hosted dynamic method uses only public types and methods, it does not require restricted member access and does not have to skip JIT visibility checks.</span></span>

  <span data-ttu-id="ec8bf-192">不需要特殊權限也可以發出動態方法，但發出的程式碼需要所用類型和方法要求的權限。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-192">No special permissions are required to emit a dynamic method, but the emitted code requires the permissions that are demanded by the types and methods it uses.</span></span> <span data-ttu-id="ec8bf-193">例如，如果發出的程式碼呼叫存取檔案的方法，它需要 <xref:System.Security.Permissions.FileIOPermission>。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-193">For example, if the emitted code calls a method that accesses a file, it requires <xref:System.Security.Permissions.FileIOPermission>.</span></span> <span data-ttu-id="ec8bf-194">如果信任層級不包含該權限，則執行發出的程式碼時，會擲回安全性例外狀況。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-194">If the trust level does not include that permission, a security exception is thrown when the emitted code is executed.</span></span> <span data-ttu-id="ec8bf-195">這裡顯示的程式碼會發出只使用 <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 方法的動態方法。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-195">The code shown here emits a dynamic method that uses only the <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="ec8bf-196">因此，程式碼可以從部分信任的位置執行。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-196">Therefore, the code can be executed from partially trusted locations.</span></span>

- <span data-ttu-id="ec8bf-197">或者，使用 <xref:System.Reflection.Emit.DynamicMethod.%23ctor%28System.String%2CSystem.Type%2CSystem.Type%5B%5D%2CSystem.Boolean%29> 建構函式並指定 `restrictedSkipVisibility` 參數的 `true`，建立有限功能的匿名裝載動態方法以略過 JIT 可見度檢查。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-197">Alternatively, create an anonymously hosted dynamic method with restricted ability to skip JIT visibility checks, by using the <xref:System.Reflection.Emit.DynamicMethod.%23ctor%28System.String%2CSystem.Type%2CSystem.Type%5B%5D%2CSystem.Boolean%29> constructor and specifying `true` for the `restrictedSkipVisibility` parameter.</span></span>

  [!code-csharp[HowToEmitCodeInPartialTrust#16](../../../samples/snippets/csharp/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/cs/source.cs#16)]
  [!code-vb[HowToEmitCodeInPartialTrust#16](../../../samples/snippets/visualbasic/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/vb/source.vb#16)]

  <span data-ttu-id="ec8bf-198">限制是匿名裝載的動態方法只可以存取信任層級等於或低於發出組件信任層級的組件私用資料。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-198">The restriction is that the anonymously hosted dynamic method can access private data only in assemblies with trust levels equal to or less than the trust level of the emitting assembly.</span></span> <span data-ttu-id="ec8bf-199">例如，如果動態方法是以網際網路信任執行，它就可以存取也以網際網路信任執行的其他組件私有資料，但無法存取 .NET Framework 組件的私有資料。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-199">For example, if the dynamic method is executing with Internet trust, it can access private data in other assemblies that are also executing with Internet trust, but it cannot access private data of .NET Framework assemblies.</span></span> <span data-ttu-id="ec8bf-200">.NET Framework 組件安裝在全域組件快取中，一律為完全信任。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-200">.NET Framework assemblies are installed in the global assembly cache and are always fully trusted.</span></span>

  <span data-ttu-id="ec8bf-201">只有當主應用程式授權有 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 旗標的 <xref:System.Security.Permissions.ReflectionPermission> 時，匿名裝載動態方法才可以使用此有限功能略過 JIT 可見度檢查。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-201">Anonymously hosted dynamic methods can use this restricted ability to skip JIT visibility checks only if the host application grants <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag.</span></span> <span data-ttu-id="ec8bf-202">叫用方法時才要求此權限。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-202">The demand for this permission is made when the method is invoked.</span></span>

  > [!NOTE]
  > <span data-ttu-id="ec8bf-203">建構動態方法時會包含發出組件的呼叫堆疊資訊。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-203">Call stack information for the emitting assembly is included when the dynamic method is constructed.</span></span> <span data-ttu-id="ec8bf-204">因此，會要求發出組件的權限，而不是叫用方法的組件權限。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-204">Therefore, the demand is made against the permissions of the emitting assembly instead of the assembly that invokes the method.</span></span> <span data-ttu-id="ec8bf-205">這可防止以提高的權限執行發出的程式碼。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-205">This prevents the emitted code from being executed with elevated permissions.</span></span>

  <span data-ttu-id="ec8bf-206">本逐步解說結尾的[完整程式碼範例](#Example)會示範有限成員存取的用法和限制。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-206">The [complete code example](#Example) at the end of this walkthrough demonstrates the use and limitations of restricted member access.</span></span> <span data-ttu-id="ec8bf-207">其 `Worker` 類別有一方法，可以建立匿名裝載動態方法，有受限或不受限制略過可視性檢查的功能，而此範例會示範在不同信任層級的應用程式定義域中執行此方法的結果。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-207">Its `Worker` class includes a method that can create anonymously hosted dynamic methods with or without the restricted ability to skip visibility checks, and the example shows the result of executing this method in application domains that have different trust levels.</span></span>

  > [!NOTE]
  > <span data-ttu-id="ec8bf-208">有限略過可視性檢查是匿名裝載動態方法的功能。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-208">The restricted ability to skip visibility checks is a feature of anonymously hosted dynamic methods.</span></span> <span data-ttu-id="ec8bf-209">當一般的動態方法略過 JIT 可見度檢查時，它們必須獲授與完全信任。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-209">When ordinary dynamic methods skip JIT visibility checks, they must be granted full trust.</span></span>

<a name="Example"></a>

## <a name="example"></a><span data-ttu-id="ec8bf-210">範例</span><span class="sxs-lookup"><span data-stu-id="ec8bf-210">Example</span></span>

### <a name="description"></a><span data-ttu-id="ec8bf-211">描述</span><span class="sxs-lookup"><span data-stu-id="ec8bf-211">Description</span></span>

<span data-ttu-id="ec8bf-212">下列程式碼範例示範如何使用 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess> 旗標允許匿名裝載動態方法略過 JIT 可見度檢查，但僅限於所在信任層級與發出程式碼的組件信任層級相同或較低的目標成員。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-212">The following code example demonstrates the use of the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess> flag to allow anonymously hosted dynamic methods to skip JIT visibility checks, but only when the target member is at an equal or lower level of trust than the assembly that emits the code.</span></span>

<span data-ttu-id="ec8bf-213">此範例會定義 `Worker` 類別，可跨應用程式定義域界限封送處理。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-213">The example defines a `Worker` class that can be marshaled across application domain boundaries.</span></span> <span data-ttu-id="ec8bf-214">此類別有兩個 `AccessPrivateMethod` 方法多載，可以發出和執行動態方法。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-214">The class has two `AccessPrivateMethod` method overloads that emit and execute dynamic methods.</span></span> <span data-ttu-id="ec8bf-215">第一個多載會發出動態方法，呼叫 `Worker` 類別的私用 `PrivateMethod`方法，而且可以發出包含或不含 JIT 可見度檢查的動態方法。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-215">The first overload emits a dynamic method that calls the private `PrivateMethod` method of the `Worker` class, and it can emit the dynamic method with or without JIT visibility checks.</span></span> <span data-ttu-id="ec8bf-216">第二個多載會發出動態方法，存取 <xref:System.String> 類別的 `internal` 屬性 (Visual Basic 為 `Friend` 屬性)。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-216">The second overload emits a dynamic method that accesses an `internal` property (`Friend` property in Visual Basic) of the <xref:System.String> class.</span></span>

<span data-ttu-id="ec8bf-217">範例會使用協助程式方法來建立限於 `Internet` 權限的授權集，然後使用 <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> 方法多載來指定在使用此授權集的定義域中執行的所有程式碼，建立應用程式定義域。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-217">The example uses a helper method to create a grant set limited to `Internet` permissions, and then creates an application domain, using the <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> method overload to specify that all code that executes in the domain uses this grant set.</span></span> <span data-ttu-id="ec8bf-218">此範例會在應用程式定義域中建立 `Worker` 類別的執行個體，並執行兩次 `AccessPrivateMethod` 方法。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-218">The example creates an instance of the `Worker` class in the application domain, and executes the `AccessPrivateMethod` method two times.</span></span>

- <span data-ttu-id="ec8bf-219">第一次執行 `AccessPrivateMethod` 方法時，會強制執行 JIT 可見度檢查。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-219">The first time the `AccessPrivateMethod` method is executed, JIT visibility checks are enforced.</span></span> <span data-ttu-id="ec8bf-220">因為 JIT 可見度檢查會阻止動態方法存取私用方法，所以叫用動態方法會失敗。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-220">The dynamic method fails when it is invoked, because JIT visibility checks prevent it from accessing the private method.</span></span>

- <span data-ttu-id="ec8bf-221">第二次執行 `AccessPrivateMethod` 方法時，會略過 JIT 可見度檢查。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-221">The second time the `AccessPrivateMethod` method is executed, JIT visibility checks are skipped.</span></span> <span data-ttu-id="ec8bf-222">因為 `Internet` 授權集未授與足夠的權限以略過可見性檢查，所以動態方法在編譯時失敗。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-222">The dynamic method fails when it is compiled, because the `Internet` grant set does not grant sufficient permissions to skip visibility checks.</span></span>

<span data-ttu-id="ec8bf-223">此範例會將具有 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 的 <xref:System.Security.Permissions.ReflectionPermission> 新增至授權集。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-223">The example adds <xref:System.Security.Permissions.ReflectionPermission> with <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> to the grant set.</span></span> <span data-ttu-id="ec8bf-224">然後，此範例會建立第二個定義域，指定將新授權集的權限授與在定義域中執行的所有程式碼。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-224">The example then creates a second domain, specifying that all code that executes in the domain is granted the permissions in the new grant set.</span></span> <span data-ttu-id="ec8bf-225">此範例會在新的應用程式定義域中建立 `Worker` 類別的執行個體，並執行 `AccessPrivateMethod` 方法的兩個多載。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-225">The example creates an instance of the `Worker` class in the new application domain, and executes both overloads of the `AccessPrivateMethod` method.</span></span>

- <span data-ttu-id="ec8bf-226">執行 `AccessPrivateMethod` 方法的第一個多載，並略過 JIT 可見度檢查。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-226">The first overload of the `AccessPrivateMethod` method is executed, and JIT visibility checks are skipped.</span></span> <span data-ttu-id="ec8bf-227">動態方法成功編譯並執行，因為發出程式碼的組件和包含私用方法的組件相同。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-227">The dynamic method compiles and executes successfully, because the assembly that emits the code is the same as the assembly that contains the private method.</span></span> <span data-ttu-id="ec8bf-228">因此，信任層級是相等的。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-228">Therefore, the trust levels are equal.</span></span> <span data-ttu-id="ec8bf-229">如果包含 `Worker` 類別的應用程式曾有數個組件，則同樣的程序對這些組件任一個都會成功，因為它們位於相同的信任層級。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-229">If the application that contains the `Worker` class had several assemblies, the same process would succeed for any one of those assemblies, because they would all be at the same trust level.</span></span>

- <span data-ttu-id="ec8bf-230">執行 `AccessPrivateMethod` 方法的第二個多載，再次略過 JIT 可見度檢查。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-230">The second overload of the `AccessPrivateMethod` method is executed, and again JIT visibility checks are skipped.</span></span> <span data-ttu-id="ec8bf-231">這次在編譯時，動態方法會失敗，因為它會嘗試存取 `internal` `FirstChar` 類別的屬性 <xref:System.String> 。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-231">This time the dynamic method fails when it is compiled, because it tries to access the `internal` `FirstChar` property of the <xref:System.String> class.</span></span> <span data-ttu-id="ec8bf-232">包含 <xref:System.String> 類別的組件為完全信任。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-232">The assembly that contains the <xref:System.String> class is fully trusted.</span></span> <span data-ttu-id="ec8bf-233">因此，它的信任層級高於發出程式碼的組件。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-233">Therefore, it is at a higher level of trust than the assembly that emits the code.</span></span>

<span data-ttu-id="ec8bf-234">這項比較會示範 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 如何啟用部分信任的程式碼，略跳過其他部分信任程式碼的可見度檢查，卻不危及信任程式碼的安全性。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-234">This comparison shows how <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> enables partially trusted code to skip visibility checks for other partially trusted code without compromising the security of trusted code.</span></span>

### <a name="code"></a><span data-ttu-id="ec8bf-235">程式碼</span><span class="sxs-lookup"><span data-stu-id="ec8bf-235">Code</span></span>

[!code-csharp[HowToEmitCodeInPartialTrust#1](../../../samples/snippets/csharp/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/cs/source.cs#1)]
[!code-vb[HowToEmitCodeInPartialTrust#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/vb/source.vb#1)]

## <a name="compiling-the-code"></a><span data-ttu-id="ec8bf-236">編譯程式碼</span><span class="sxs-lookup"><span data-stu-id="ec8bf-236">Compiling the Code</span></span>

- <span data-ttu-id="ec8bf-237">如果您在 Visual Studio 中建置此程式碼範例，則當您將它傳遞給 <xref:System.AppDomain.CreateInstanceAndUnwrap%2A> 方法時，必須變更類別名稱以包含命名空間。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-237">If you build this code example in Visual Studio, you must change the name of the class to include the namespace when you pass it to the <xref:System.AppDomain.CreateInstanceAndUnwrap%2A> method.</span></span> <span data-ttu-id="ec8bf-238">命名空間是專案的預設名稱。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-238">By default, the namespace is the name of the project.</span></span> <span data-ttu-id="ec8bf-239">例如，如果專案是 "PartialTrust"，則類別名稱必須是 "PartialTrust.Worker"。</span><span class="sxs-lookup"><span data-stu-id="ec8bf-239">For example, if the project is "PartialTrust", the class name must be "PartialTrust.Worker".</span></span>

## <a name="see-also"></a><span data-ttu-id="ec8bf-240">另請參閱</span><span class="sxs-lookup"><span data-stu-id="ec8bf-240">See also</span></span>

- [<span data-ttu-id="ec8bf-241">反映發出中的安全性問題</span><span class="sxs-lookup"><span data-stu-id="ec8bf-241">Security Issues in Reflection Emit</span></span>](security-issues-in-reflection-emit.md)
- [<span data-ttu-id="ec8bf-242">如何：在沙箱中執行部分信任的程式碼</span><span class="sxs-lookup"><span data-stu-id="ec8bf-242">How to: Run Partially Trusted Code in a Sandbox</span></span>](../misc/how-to-run-partially-trusted-code-in-a-sandbox.md)
