---
title: SQL Server 中的快照隔離
description: 閱讀 SQL Server 中快照集隔離與資料列版本設定的總覽，並瞭解如何管理隔離等級的平行存取。
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: 43ae5dd3-50f5-43a8-8d01-e37a61664176
ms.openlocfilehash: 4934c031eb9dfb26d60c5233937cbc65ca60d4f7
ms.sourcegitcommit: 5b475c1855b32cf78d2d1bbb4295e4c236f39464
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 09/24/2020
ms.locfileid: "91183074"
---
# <a name="snapshot-isolation-in-sql-server"></a><span data-ttu-id="e9504-103">SQL Server 中的快照隔離</span><span class="sxs-lookup"><span data-stu-id="e9504-103">Snapshot Isolation in SQL Server</span></span>

<span data-ttu-id="e9504-104">快照集隔離可增強 OLTP 應用程式的並行存取。</span><span class="sxs-lookup"><span data-stu-id="e9504-104">Snapshot isolation enhances concurrency for OLTP applications.</span></span>  
  
## <a name="understanding-snapshot-isolation-and-row-versioning"></a><span data-ttu-id="e9504-105">瞭解快照集隔離及資料列版本控制</span><span class="sxs-lookup"><span data-stu-id="e9504-105">Understanding Snapshot Isolation and Row Versioning</span></span>  

 <span data-ttu-id="e9504-106">一旦啟用快照集隔離，就必須維護每個交易的更新資料列版本。</span><span class="sxs-lookup"><span data-stu-id="e9504-106">Once snapshot isolation is enabled, updated row versions for each transaction must be maintained.</span></span>  <span data-ttu-id="e9504-107">在 SQL Server 2019 之前，這些版本儲存在 **tempdb**中。</span><span class="sxs-lookup"><span data-stu-id="e9504-107">Prior to SQL Server 2019, these versions were stored in **tempdb**.</span></span> <span data-ttu-id="e9504-108">SQL Server 2019 引進了新功能，加速資料庫復原 (ADR) 需要有自己的一組資料列版本。</span><span class="sxs-lookup"><span data-stu-id="e9504-108">SQL Server 2019 introduces a new feature, Accelerated Database Recovery (ADR) which requires its own set of row versions.</span></span>  <span data-ttu-id="e9504-109">因此，從 SQL Server 2019，如果未啟用 ADR，資料列版本會保留在 **tempdb** 中，一律為。</span><span class="sxs-lookup"><span data-stu-id="e9504-109">So, as of SQL Server 2019, if ADR is not enabled, row versions are kept in **tempdb** as always.</span></span>  <span data-ttu-id="e9504-110">如果 ADR 已啟用，則與快照集隔離和 ADR 相關的所有資料列版本都會保留在 ADR 的持續版本存放區中， (PVS) （位於使用者指定之檔案群組中的使用者資料庫中）。</span><span class="sxs-lookup"><span data-stu-id="e9504-110">If ADR is enabled, then all row versions, both related to snapshot isolation and ADR, are kept in ADR's Persistent Version Store (PVS), which is located in the user database in a filegroup which the user specifies.</span></span> <span data-ttu-id="e9504-111">唯一的交易序號會識別每個交易，而且會針對每個資料列版本記錄這些唯一的編號。</span><span class="sxs-lookup"><span data-stu-id="e9504-111">A unique transaction sequence number identifies each transaction, and these unique numbers are recorded for each row version.</span></span> <span data-ttu-id="e9504-112">交易適用於在交易序號之前具有序號的最新資料列版本。</span><span class="sxs-lookup"><span data-stu-id="e9504-112">The transaction works with the most recent row versions having a sequence number before the sequence number of the transaction.</span></span> <span data-ttu-id="e9504-113">交易會忽略在交易開始之後所建立的較新資料列版本。</span><span class="sxs-lookup"><span data-stu-id="e9504-113">Newer row versions created after the transaction has begun are ignored by the transaction.</span></span>  
  
 <span data-ttu-id="e9504-114">「快照集」一詞反映了交易中的所有查詢都會根據交易開始時資料庫的狀態，看到資料庫的相同版本或快照集。</span><span class="sxs-lookup"><span data-stu-id="e9504-114">The term "snapshot" reflects the fact that all queries in the transaction see the same version, or snapshot, of the database, based on the state of the database at the moment in time when the transaction begins.</span></span> <span data-ttu-id="e9504-115">在快照集交易中的基礎資料列或資料頁面上沒有鎖定，這允許其他交易執行，而不會被之前未完成的交易封鎖。</span><span class="sxs-lookup"><span data-stu-id="e9504-115">No locks are acquired on the underlying data rows or data pages in a snapshot transaction, which permits other transactions to execute without being blocked by a prior uncompleted transaction.</span></span> <span data-ttu-id="e9504-116">修改資料的交易不會封鎖讀取資料的交易，而讀取資料的交易不會封鎖寫入資料的交易，因為它們通常會在 SQL Server 中預設的 READ COMMITTED 隔離等級之下。</span><span class="sxs-lookup"><span data-stu-id="e9504-116">Transactions that modify data do not block transactions that read data, and transactions that read data do not block transactions that write data, as they normally would under the default READ COMMITTED isolation level in SQL Server.</span></span> <span data-ttu-id="e9504-117">此非封鎖性的行為也會大幅降低複雜交易發生死結的可能性。</span><span class="sxs-lookup"><span data-stu-id="e9504-117">This non-blocking behavior also significantly reduces the likelihood of deadlocks for complex transactions.</span></span>  
  
 <span data-ttu-id="e9504-118">快照集隔離會使用開放式並行存取模型。</span><span class="sxs-lookup"><span data-stu-id="e9504-118">Snapshot isolation uses an optimistic concurrency model.</span></span> <span data-ttu-id="e9504-119">如果快照集交易嘗試認可自交易開始後已變更的資料修改，交易將會回復並引發錯誤。</span><span class="sxs-lookup"><span data-stu-id="e9504-119">If a snapshot transaction attempts to commit modifications to data that has changed since the transaction began, the transaction will roll back and an error will be raised.</span></span> <span data-ttu-id="e9504-120">您可以針對存取要修改之資料的 SELECT 陳述式使用 UPDLOCK 提示，以避免發生這種情況。</span><span class="sxs-lookup"><span data-stu-id="e9504-120">You can avoid this by using UPDLOCK hints for SELECT statements that access data to be modified.</span></span> <span data-ttu-id="e9504-121">如需詳細資訊，請參閱《SQL Server 線上叢書》中的＜鎖定提示＞。</span><span class="sxs-lookup"><span data-stu-id="e9504-121">See "Locking Hints" in SQL Server Books Online for more information.</span></span>  
  
 <span data-ttu-id="e9504-122">在交易中使用快照集隔離之前，必須先透過設定 [ALLOW_SNAPSHOT_ISOLATION ON] 資料庫選項將其啟用。</span><span class="sxs-lookup"><span data-stu-id="e9504-122">Snapshot isolation must be enabled by setting the ALLOW_SNAPSHOT_ISOLATION ON database option before it is used in transactions.</span></span> <span data-ttu-id="e9504-123">如此會啟動在暫存資料庫 (**tempdb**) 中儲存資料列版本的機制。</span><span class="sxs-lookup"><span data-stu-id="e9504-123">This activates the mechanism for storing row versions in the temporary database (**tempdb**).</span></span> <span data-ttu-id="e9504-124">您必須在使用 Transact-SQL ALTER DATABASE 陳述式的每個資料庫中啟用快照集隔離。</span><span class="sxs-lookup"><span data-stu-id="e9504-124">You must enable snapshot isolation in each database that uses it with the Transact-SQL ALTER DATABASE statement.</span></span> <span data-ttu-id="e9504-125">在這方面，快照集隔離與 READ COMMITTED、REPEATABLE READ、SERIALIZABLE 和 READ UNCOMMITTED 的傳統隔離等級不同，上述等級不需要任何設定。</span><span class="sxs-lookup"><span data-stu-id="e9504-125">In this respect, snapshot isolation differs from the traditional isolation levels of READ COMMITTED, REPEATABLE READ, SERIALIZABLE, and READ UNCOMMITTED, which require no configuration.</span></span> <span data-ttu-id="e9504-126">下列陳述式會啟用快照集隔離，並以 SNAPSHOT 取代預設的 READ COMMITTED 行為：</span><span class="sxs-lookup"><span data-stu-id="e9504-126">The following statements activate snapshot isolation and replace the default READ COMMITTED behavior with SNAPSHOT:</span></span>  
  
```sql  
ALTER DATABASE MyDatabase  
SET ALLOW_SNAPSHOT_ISOLATION ON  
  
ALTER DATABASE MyDatabase  
SET READ_COMMITTED_SNAPSHOT ON  
```  
  
 <span data-ttu-id="e9504-127">設定 [READ_COMMITTED_SNAPSHOT ON] 選項可讓您存取預設 READ COMMITTED 隔離等級下已建立版本的資料列。</span><span class="sxs-lookup"><span data-stu-id="e9504-127">Setting the READ_COMMITTED_SNAPSHOT ON option allows access to versioned rows under the default READ COMMITTED isolation level.</span></span> <span data-ttu-id="e9504-128">如果 [READ_COMMITTED_SNAPSHOT] 選項設定為 [OFF]，您必須明確設定每個工作階段的快照集隔離等級，才能存取已建立版本的資料列。</span><span class="sxs-lookup"><span data-stu-id="e9504-128">If the READ_COMMITTED_SNAPSHOT option is set to OFF, you must explicitly set the Snapshot isolation level for each session in order to access versioned rows.</span></span>  
  
## <a name="managing-concurrency-with-isolation-levels"></a><span data-ttu-id="e9504-129">使用隔離等級管理並行存取</span><span class="sxs-lookup"><span data-stu-id="e9504-129">Managing Concurrency with Isolation Levels</span></span>  

 <span data-ttu-id="e9504-130">Transact-SQL 陳述式執行時所用的隔離等級會決定其鎖定與資料列版本設定行為。</span><span class="sxs-lookup"><span data-stu-id="e9504-130">The isolation level under which a Transact-SQL statement executes determines its locking and row versioning behavior.</span></span> <span data-ttu-id="e9504-131">隔離等級具有全連線的範圍，一旦針對連線使用 SET TRANSACTION ISOLATION LEVEL 陳述式進行設定，就會維持有效狀態，直到連線關閉或設定了另一個隔離等級為止。</span><span class="sxs-lookup"><span data-stu-id="e9504-131">An isolation level has connection-wide scope, and once set for a connection with the SET TRANSACTION ISOLATION LEVEL statement, it remains in effect until the connection is closed or another isolation level is set.</span></span> <span data-ttu-id="e9504-132">當連線關閉並返回集區時，會保留最後一個 SET TRANSACTION ISOLATION LEVEL 陳述式的隔離等級。</span><span class="sxs-lookup"><span data-stu-id="e9504-132">When a connection is closed and returned to the pool, the isolation level from the last SET TRANSACTION ISOLATION LEVEL statement is retained.</span></span> <span data-ttu-id="e9504-133">重複使用共用連線的後續連線，會使用在共用連線時有效的隔離等級。</span><span class="sxs-lookup"><span data-stu-id="e9504-133">Subsequent connections reusing a pooled connection use the isolation level that was in effect at the time the connection is pooled.</span></span>  
  
 <span data-ttu-id="e9504-134">在連線內發出的個別查詢可以包含鎖定提示，以修改單一陳述式或交易的隔離，但不會影響連線的隔離等級。</span><span class="sxs-lookup"><span data-stu-id="e9504-134">Individual queries issued within a connection can contain lock hints that modify the isolation for a single statement or transaction but do not affect the isolation level of the connection.</span></span> <span data-ttu-id="e9504-135">在預存程序或函式中設定的隔離等級或鎖定提示，並不會變更呼叫它們之連線的隔離等級，而且只會在預存程序或函式呼叫的持續時間內有效。</span><span class="sxs-lookup"><span data-stu-id="e9504-135">Isolation levels or lock hints set in stored procedures or functions do not change the isolation level of the connection that calls them and are in effect only for the duration of the stored procedure or function call.</span></span>  
  
 <span data-ttu-id="e9504-136">舊版的 SQL Server 支援四種 SQL-92 標準中定義的隔離等級：</span><span class="sxs-lookup"><span data-stu-id="e9504-136">Four isolation levels defined in the SQL-92 standard were supported in early versions of SQL Server:</span></span>  
  
- <span data-ttu-id="e9504-137">READ UNCOMMITTED 是最不嚴格的隔離等級，因為這會忽略其他交易所進行的鎖定。</span><span class="sxs-lookup"><span data-stu-id="e9504-137">READ UNCOMMITTED is the least restrictive isolation level because it ignores locks placed by other transactions.</span></span> <span data-ttu-id="e9504-138">在 READ UNCOMMITTED 下執行的交易可以讀取其他交易尚未認可的已修改資料值；這些稱為「中途」讀取。</span><span class="sxs-lookup"><span data-stu-id="e9504-138">Transactions executing under READ UNCOMMITTED can read modified data values that have not yet been committed by other transactions; these are called "dirty" reads.</span></span>  
  
- <span data-ttu-id="e9504-139">READ COMMITTED 是 SQL Server 的預設隔離等級。</span><span class="sxs-lookup"><span data-stu-id="e9504-139">READ COMMITTED is the default isolation level for SQL Server.</span></span> <span data-ttu-id="e9504-140">這會透過指定陳述式無法讀取已修改但尚未由其他交易認可的資料值，來防止中途讀取。</span><span class="sxs-lookup"><span data-stu-id="e9504-140">It prevents dirty reads by specifying that statements cannot read data values that have been modified but not yet committed by other transactions.</span></span> <span data-ttu-id="e9504-141">其他交易仍然可以在目前交易內個別陳述式的執行之間修改、插入或刪除資料，導致無法重複的讀取或「虛設項目」資料。</span><span class="sxs-lookup"><span data-stu-id="e9504-141">Other transactions can still modify, insert, or delete data between executions of individual statements within the current transaction, resulting in non-repeatable reads, or "phantom" data.</span></span>  
  
- <span data-ttu-id="e9504-142">REPEATABLE READ 是比 READ COMMITTED 嚴格的隔離等級。</span><span class="sxs-lookup"><span data-stu-id="e9504-142">REPEATABLE READ is a more restrictive isolation level than READ COMMITTED.</span></span> <span data-ttu-id="e9504-143">其包含 READ COMMITTED，而且會額外指定在目前的交易認可之前，沒有其他交易可修改或刪除目前交易已讀取的資料。</span><span class="sxs-lookup"><span data-stu-id="e9504-143">It encompasses READ COMMITTED and additionally specifies that no other transactions can modify or delete data that has been read by the current transaction until the current transaction commits.</span></span> <span data-ttu-id="e9504-144">並行存取低於 READ COMMITTED，因為在交易期間會保留讀取資料上的共用鎖定，而不是在每個陳述式結尾處釋放。</span><span class="sxs-lookup"><span data-stu-id="e9504-144">Concurrency is lower than for READ COMMITTED because shared locks on read data are held for the duration of the transaction instead of being released at the end of each statement.</span></span>  
  
- <span data-ttu-id="e9504-145">SERIALIZABLE 是限制最嚴格的隔離等級，原因為其鎖定了索引鍵的整個範圍，且會將鎖定保留到交易完成。</span><span class="sxs-lookup"><span data-stu-id="e9504-145">SERIALIZABLE is the most restrictive isolation level, because it locks entire ranges of keys and holds the locks until the transaction is complete.</span></span> <span data-ttu-id="e9504-146">其包含 REPEATABLE READ，並加上一個限制，就是在交易完成之前，其他交易無法將新資料列插入至已由交易讀取的範圍。</span><span class="sxs-lookup"><span data-stu-id="e9504-146">It encompasses REPEATABLE READ and adds the restriction that other transactions cannot insert new rows into ranges that have been read by the transaction until the transaction is complete.</span></span>  
  
 <span data-ttu-id="e9504-147">如需詳細資訊，請參閱[交易鎖定與資料列版本設定指南](/sql/relational-databases/sql-server-transaction-locking-and-row-versioning-guide)。</span><span class="sxs-lookup"><span data-stu-id="e9504-147">For more information, refer to the [Transaction Locking and Row Versioning Guide](/sql/relational-databases/sql-server-transaction-locking-and-row-versioning-guide).</span></span>  
  
### <a name="snapshot-isolation-level-extensions"></a><span data-ttu-id="e9504-148">快照隔離等級擴充</span><span class="sxs-lookup"><span data-stu-id="e9504-148">Snapshot Isolation Level Extensions</span></span>  

 <span data-ttu-id="e9504-149">SQL Server 在引進 SNAPSHOT 隔離等級的同時，還引進了 SQL-92 隔離等級的延伸模組及 READ COMMITTED 的其他實作。</span><span class="sxs-lookup"><span data-stu-id="e9504-149">SQL Server introduced extensions to the SQL-92 isolation levels with the introduction of the SNAPSHOT isolation level and an additional implementation of READ COMMITTED.</span></span> <span data-ttu-id="e9504-150">READ_COMMITTED_SNAPSHOT 隔離等級可透明地取代所有交易的 READ COMMITTED。</span><span class="sxs-lookup"><span data-stu-id="e9504-150">The READ_COMMITTED_SNAPSHOT isolation level can transparently replace READ COMMITTED for all transactions.</span></span>  
  
- <span data-ttu-id="e9504-151">SNAPSHOT 隔離會指定交易內讀取的資料永遠不會反映其他同時交易所做的變更。</span><span class="sxs-lookup"><span data-stu-id="e9504-151">SNAPSHOT isolation specifies that data read within a transaction will never reflect changes made by other simultaneous transactions.</span></span> <span data-ttu-id="e9504-152">交易會使用在交易開始時已存在的資料列版本。</span><span class="sxs-lookup"><span data-stu-id="e9504-152">The transaction uses the data row versions that exist when the transaction begins.</span></span> <span data-ttu-id="e9504-153">讀取時不會對資料進行鎖定，因此 SNAPSHOT 交易不會封鎖其他交易寫入資料。</span><span class="sxs-lookup"><span data-stu-id="e9504-153">No locks are placed on the data when it is read, so SNAPSHOT transactions do not block other transactions from writing data.</span></span> <span data-ttu-id="e9504-154">寫入資料的交易不會封鎖快照集交易讀取資料。</span><span class="sxs-lookup"><span data-stu-id="e9504-154">Transactions that write data do not block snapshot transactions from reading data.</span></span> <span data-ttu-id="e9504-155">您必須透過設定 [ALLOW_SNAPSHOT_ISOLATION] 資料庫選項來啟用快照集隔離，才能使用該功能。</span><span class="sxs-lookup"><span data-stu-id="e9504-155">You need to enable snapshot isolation by setting the ALLOW_SNAPSHOT_ISOLATION database option in order to use it.</span></span>  
  
- <span data-ttu-id="e9504-156">當資料庫中啟用快照集隔離時，[READ_COMMITTED_SNAPSHOT] 資料庫選項會決定預設 READ COMMITTED 隔離等級的行為。</span><span class="sxs-lookup"><span data-stu-id="e9504-156">The READ_COMMITTED_SNAPSHOT database option determines the behavior of the default READ COMMITTED isolation level when snapshot isolation is enabled in a database.</span></span> <span data-ttu-id="e9504-157">如果您未明確指定 [READ_COMMITTED_SNAPSHOT ON]，則會將 [READ COMMITTED] 套用至所有隱含交易。</span><span class="sxs-lookup"><span data-stu-id="e9504-157">If you do not explicitly specify READ_COMMITTED_SNAPSHOT ON, READ COMMITTED is applied to all implicit transactions.</span></span> <span data-ttu-id="e9504-158">這會產生與設定 [READ_COMMITTED_SNAPSHOT OFF] \(預設值\) 相同的行為。</span><span class="sxs-lookup"><span data-stu-id="e9504-158">This produces the same behavior as setting READ_COMMITTED_SNAPSHOT OFF (the default).</span></span> <span data-ttu-id="e9504-159">當 [READ_COMMITTED_SNAPSHOT OFF] 生效時，資料庫引擎會使用共用鎖定來強制執行預設的隔離等級。</span><span class="sxs-lookup"><span data-stu-id="e9504-159">When READ_COMMITTED_SNAPSHOT OFF is in effect, the Database Engine uses shared locks to enforce the default isolation level.</span></span> <span data-ttu-id="e9504-160">如果將 [READ_COMMITTED_SNAPSHOT] 資料庫選項設定為 [ON]，資料庫引擎就會使用資料列版本設定與快照集隔離作為預設值，而不是使用鎖定來保護資料。</span><span class="sxs-lookup"><span data-stu-id="e9504-160">If you set the READ_COMMITTED_SNAPSHOT database option to ON, the database engine uses row versioning and snapshot isolation as the default, instead of using locks to protect the data.</span></span>  
  
## <a name="how-snapshot-isolation-and-row-versioning-work"></a><span data-ttu-id="e9504-161">快照集隔離及資料列版本控制的運作方式</span><span class="sxs-lookup"><span data-stu-id="e9504-161">How Snapshot Isolation and Row Versioning Work</span></span>  

 <span data-ttu-id="e9504-162">啟用 SNAPSHOT 隔離等級之後，每次更新資料列時，SQL Server 資料庫引擎都會在 **tempdb** 中儲存原始資料列的複本，並將交易序號新增至資料列。</span><span class="sxs-lookup"><span data-stu-id="e9504-162">When the SNAPSHOT isolation level is enabled, each time a row is updated, the SQL Server Database Engine stores a copy of the original row in **tempdb**, and adds a transaction sequence number to the row.</span></span> <span data-ttu-id="e9504-163">以下是事件的發生順序：</span><span class="sxs-lookup"><span data-stu-id="e9504-163">The following is the sequence of events that occurs:</span></span>  
  
- <span data-ttu-id="e9504-164">系統會起始新交易，並指派交易序號給新交易。</span><span class="sxs-lookup"><span data-stu-id="e9504-164">A new transaction is initiated, and it is assigned a transaction sequence number.</span></span>  
  
- <span data-ttu-id="e9504-165">資料庫引擎會讀取交易內的資料列，並從 **tempdb** 擷取序號與該交易序號最接近且低於它的資料列版本。</span><span class="sxs-lookup"><span data-stu-id="e9504-165">The Database Engine reads a row within the transaction and retrieves the row version from **tempdb** whose sequence number is closest to, and lower than, the transaction sequence number.</span></span>  
  
- <span data-ttu-id="e9504-166">資料庫引擎會檢查當快照集交易開始時，交易序號是否不在作用中未認可交易的交易序號清單中。</span><span class="sxs-lookup"><span data-stu-id="e9504-166">The Database Engine checks to see if the transaction sequence number is not in the list of transaction sequence numbers of the uncommitted transactions active when the snapshot transaction started.</span></span>  
  
- <span data-ttu-id="e9504-167">交易從 **tempdb** 讀取交易開始時的資料列版本。</span><span class="sxs-lookup"><span data-stu-id="e9504-167">The transaction reads the version of the row from **tempdb** that was current as of the start of the transaction.</span></span> <span data-ttu-id="e9504-168">您不會在交易開始之後看到插入的新資料列，因為那些序號值將會高於交易序號的值。</span><span class="sxs-lookup"><span data-stu-id="e9504-168">It will not see new rows inserted after the transaction was started because those sequence number values will be higher than the value of the transaction sequence number.</span></span>  
  
- <span data-ttu-id="e9504-169">目前的交易可以看到交易開始後刪除的資料列，原因為 **tempdb** 中會有一個序號值較低的資料列版本。</span><span class="sxs-lookup"><span data-stu-id="e9504-169">The current transaction will see rows that were deleted after the transaction began, because there will be a row version in **tempdb** with a lower sequence number value.</span></span>  
  
 <span data-ttu-id="e9504-170">快照集隔離的淨效應是交易會看到交易開始時已存在的所有資料，而不會在底層資料表上接受或進行任何鎖定。</span><span class="sxs-lookup"><span data-stu-id="e9504-170">The net effect of snapshot isolation is that the transaction sees all of the data as it existed at the start of the transaction, without honoring or placing any locks on the underlying tables.</span></span> <span data-ttu-id="e9504-171">這能夠會在發生競爭的情況下造成效能提升。</span><span class="sxs-lookup"><span data-stu-id="e9504-171">This can result in performance improvements in situations where there is contention.</span></span>  
  
 <span data-ttu-id="e9504-172">快照集交易一律會使用開放式並行存取控制，並將保留任何會防止其他交易更新資料列的鎖定。</span><span class="sxs-lookup"><span data-stu-id="e9504-172">A snapshot transaction always uses optimistic concurrency control, withholding any locks that would prevent other transactions from updating rows.</span></span> <span data-ttu-id="e9504-173">如果快照集交易嘗試認可在交易開始後所變更資料列的更新，則會回復交易，並引發錯誤。</span><span class="sxs-lookup"><span data-stu-id="e9504-173">If a snapshot transaction attempts to commit an update to a row that was changed after the transaction began, the transaction is rolled back, and an error is raised.</span></span>  
  
## <a name="working-with-snapshot-isolation-in-adonet"></a><span data-ttu-id="e9504-174">在 ADO.NET 中使用快照集隔離</span><span class="sxs-lookup"><span data-stu-id="e9504-174">Working with Snapshot Isolation in ADO.NET</span></span>  

 <span data-ttu-id="e9504-175">ADO.NET 中透過 <xref:System.Data.SqlClient.SqlTransaction> 類別支援快照集隔離。</span><span class="sxs-lookup"><span data-stu-id="e9504-175">Snapshot isolation is supported in ADO.NET by the <xref:System.Data.SqlClient.SqlTransaction> class.</span></span> <span data-ttu-id="e9504-176">如果已啟用資料庫的快照集隔離，但並未設定 READ_COMMITTED_SNAPSHOT ON，則必須在呼叫 <xref:System.Data.SqlClient.SqlConnection.BeginTransaction%2A> 方法時，使用 **IsolationLevel.Snapshot** 列舉值來初始化 <xref:System.Data.SqlClient.SqlTransaction>。</span><span class="sxs-lookup"><span data-stu-id="e9504-176">If a database has been enabled for snapshot isolation but is not configured for READ_COMMITTED_SNAPSHOT ON, you must initiate a <xref:System.Data.SqlClient.SqlTransaction> using the **IsolationLevel.Snapshot** enumeration value when calling the <xref:System.Data.SqlClient.SqlConnection.BeginTransaction%2A> method.</span></span> <span data-ttu-id="e9504-177">此程式碼片段會假設連線是開啟的 <xref:System.Data.SqlClient.SqlConnection> 物件。</span><span class="sxs-lookup"><span data-stu-id="e9504-177">This code fragment assumes that connection is an open <xref:System.Data.SqlClient.SqlConnection> object.</span></span>  
  
```vb  
Dim sqlTran As SqlTransaction = _  
  connection.BeginTransaction(IsolationLevel.Snapshot)  
```  
  
```csharp  
SqlTransaction sqlTran =
  connection.BeginTransaction(IsolationLevel.Snapshot);  
```  
  
### <a name="example"></a><span data-ttu-id="e9504-178">範例</span><span class="sxs-lookup"><span data-stu-id="e9504-178">Example</span></span>  

 <span data-ttu-id="e9504-179">下列範例示範不同的隔離等級如何透過嘗試存取鎖定的資料來運作，而且這不適合在實際執行的程式碼中使用。</span><span class="sxs-lookup"><span data-stu-id="e9504-179">The following example demonstrates how the different isolation levels behave by attempting to access locked data, and it is not intended to be used in production code.</span></span>  
  
 <span data-ttu-id="e9504-180">該程式碼會連線至 SQL Server 中的 **AdventureWorks** 範例資料庫，並會建立名為 **TestSnapshot** 的資料表並插入一個資料列。</span><span class="sxs-lookup"><span data-stu-id="e9504-180">The code connects to the **AdventureWorks** sample database in SQL Server and creates a table named **TestSnapshot** and inserts one row of data.</span></span> <span data-ttu-id="e9504-181">此程式碼會使用 ALTER DATABASE Transact-SQL 陳述式來開啟資料庫的快照集隔離，但不會設定 [READ_COMMITTED_SNAPSHOT 選項]，讓預設的 READ COMMITTED 隔離等級行為生效。</span><span class="sxs-lookup"><span data-stu-id="e9504-181">The code uses the ALTER DATABASE Transact-SQL statement to turn on snapshot isolation for the database, but it does not set the READ_COMMITTED_SNAPSHOT option, leaving the default READ COMMITTED isolation-level behavior in effect.</span></span> <span data-ttu-id="e9504-182">然後此程式碼會執行下列動作：</span><span class="sxs-lookup"><span data-stu-id="e9504-182">The code then performs the following actions:</span></span>  
  
- <span data-ttu-id="e9504-183">其會開始但不會完成 sqlTransaction1，這會使用 SERIALIZABLE 隔離等級來啟動更新交易。</span><span class="sxs-lookup"><span data-stu-id="e9504-183">It begins, but does not complete, sqlTransaction1, which uses the SERIALIZABLE isolation level to start an update transaction.</span></span> <span data-ttu-id="e9504-184">這具有鎖定資料表的效果。</span><span class="sxs-lookup"><span data-stu-id="e9504-184">This has the effect of locking the table.</span></span>  
  
- <span data-ttu-id="e9504-185">其會開啟第二個連線並使用 SNAPSHOT 隔離等級初始化第二筆交易，以讀取 **TestSnapshot** 資料表中的資料。</span><span class="sxs-lookup"><span data-stu-id="e9504-185">It opens a second connection and initiates a second transaction using the SNAPSHOT isolation level to read the data in the **TestSnapshot** table.</span></span> <span data-ttu-id="e9504-186">因為已啟用快照集隔離，所以此交易可以讀取 sqlTransaction1 開始之前已存在的資料。</span><span class="sxs-lookup"><span data-stu-id="e9504-186">Because snapshot isolation is enabled, this transaction can read the data that existed before sqlTransaction1 started.</span></span>  
  
- <span data-ttu-id="e9504-187">其會開啟第三個連線，並使用 READ COMMITTED 隔離等級來起始交易，以嘗試讀取資料表中的資料。</span><span class="sxs-lookup"><span data-stu-id="e9504-187">It opens a third connection and initiates a transaction using the READ COMMITTED isolation level to attempt to read the data in the table.</span></span> <span data-ttu-id="e9504-188">在此情況下，程式碼無法讀取資料，因為它無法讀取超過第一個交易中的資料表鎖定，以及下班時間。如果使用了可重複讀取和可序列化的隔離等級，則會發生相同的結果，因為這些隔離等級也無法讀取在第一個交易中所放置的鎖定之後。</span><span class="sxs-lookup"><span data-stu-id="e9504-188">In this case, the code cannot read the data because it cannot read past the locks placed on the table in the first transaction and times out. The same result would occur if the REPEATABLE READ and SERIALIZABLE isolation levels were used because these isolation levels also cannot read past the locks placed in the first transaction.</span></span>  
  
- <span data-ttu-id="e9504-189">其會開啟第四個連線，並使用 READ UNCOMMITTED 隔離等級來起始交易，這會在 sqlTransaction1 中執行未認可值的中途讀取。</span><span class="sxs-lookup"><span data-stu-id="e9504-189">It opens a fourth connection and initiates a transaction using the READ UNCOMMITTED isolation level, which performs a dirty read of the uncommitted value in sqlTransaction1.</span></span> <span data-ttu-id="e9504-190">如果未認可第一個交易，這個值可能永遠不會實際存在於資料庫中。</span><span class="sxs-lookup"><span data-stu-id="e9504-190">This value may never actually exist in the database if the first transaction is not committed.</span></span>  
  
- <span data-ttu-id="e9504-191">其會復原第一筆交易，並藉由刪除 **TestSnapshot** 資料表及停用 **AdventureWorks** 資料庫的快照集隔離來進行清除。</span><span class="sxs-lookup"><span data-stu-id="e9504-191">It rolls back the first transaction and cleans up by deleting the **TestSnapshot** table and turning off snapshot isolation for the **AdventureWorks** database.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="e9504-192">下列範例會使用相同的連接字串，但會關閉連線共用。</span><span class="sxs-lookup"><span data-stu-id="e9504-192">The following examples use the same connection string with connection pooling turned off.</span></span> <span data-ttu-id="e9504-193">如果連線已共用，重設其隔離等級並不會重設伺服器的隔離等級。</span><span class="sxs-lookup"><span data-stu-id="e9504-193">If a connection is pooled, resetting its isolation level does not reset the isolation level at the server.</span></span> <span data-ttu-id="e9504-194">因此，使用相同共用內部連線的後續連線，會以其設定至共用連線的隔離等級啟動。</span><span class="sxs-lookup"><span data-stu-id="e9504-194">As a result, subsequent connections that use the same pooled inner connection start with their isolation levels set to that of the pooled connection.</span></span> <span data-ttu-id="e9504-195">關閉連線共用的替代方法是為每個連線明確設定隔離等級。</span><span class="sxs-lookup"><span data-stu-id="e9504-195">An alternative to turning off connection pooling is to set the isolation level explicitly for each connection.</span></span>  
  
 [!code-csharp[DataWorks SnapshotIsolation.Demo#1](../../../../../samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks SnapshotIsolation.Demo/CS/source.cs#1)]
 [!code-vb[DataWorks SnapshotIsolation.Demo#1](../../../../../samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks SnapshotIsolation.Demo/VB/source.vb#1)]  
  
### <a name="example"></a><span data-ttu-id="e9504-196">範例</span><span class="sxs-lookup"><span data-stu-id="e9504-196">Example</span></span>  

 <span data-ttu-id="e9504-197">下列範例示範修改資料時，快照集隔離的行為。</span><span class="sxs-lookup"><span data-stu-id="e9504-197">The following example demonstrates the behavior of snapshot isolation when data is being modified.</span></span> <span data-ttu-id="e9504-198">此程式碼會執行下列動作：</span><span class="sxs-lookup"><span data-stu-id="e9504-198">The code performs the following actions:</span></span>  
  
- <span data-ttu-id="e9504-199">連線至 **AdventureWorks** 範例資料庫並啟用 SNAPSHOT 隔離。</span><span class="sxs-lookup"><span data-stu-id="e9504-199">Connects to the **AdventureWorks** sample database and enables SNAPSHOT isolation.</span></span>  
  
- <span data-ttu-id="e9504-200">建立名為 **TestSnapshotUpdate** 的資料表並插入三列範例資料。</span><span class="sxs-lookup"><span data-stu-id="e9504-200">Creates a table named **TestSnapshotUpdate** and inserts three rows of sample data.</span></span>  
  
- <span data-ttu-id="e9504-201">會使用 SNAPSHOT 隔離來開始 (但不會完成) sqlTransaction1。</span><span class="sxs-lookup"><span data-stu-id="e9504-201">Begins, but does not complete, sqlTransaction1 using SNAPSHOT isolation.</span></span> <span data-ttu-id="e9504-202">已在交易中選取了三個資料列。</span><span class="sxs-lookup"><span data-stu-id="e9504-202">Three rows of data are selected in the transaction.</span></span>  
  
- <span data-ttu-id="e9504-203">為 **AdventureWorks** 建立第二個 **SqlConnection**，並建立第二個使用 READ COMMITTED 隔離等級的交易，其會更新 sqlTransaction1 中所選取其中一個資料列內的值。</span><span class="sxs-lookup"><span data-stu-id="e9504-203">Creates a second **SqlConnection** to **AdventureWorks** and creates a second transaction using the READ COMMITTED isolation level that updates a value in one of the rows selected in sqlTransaction1.</span></span>  
  
- <span data-ttu-id="e9504-204">認可 sqlTransaction2。</span><span class="sxs-lookup"><span data-stu-id="e9504-204">Commits sqlTransaction2.</span></span>  
  
- <span data-ttu-id="e9504-205">返回 sqlTransaction1，並嘗試更新 sqlTransaction1 已認可的相同資料列。</span><span class="sxs-lookup"><span data-stu-id="e9504-205">Returns to sqlTransaction1 and attempts to update the same row that sqlTransaction1 already committed.</span></span> <span data-ttu-id="e9504-206">會引發錯誤 3960，並自動復原 sqlTransaction1。</span><span class="sxs-lookup"><span data-stu-id="e9504-206">Error 3960 is raised, and sqlTransaction1 is rolled back automatically.</span></span> <span data-ttu-id="e9504-207">**SqlException.Number** 及 **SqlException.Message** 顯示在 [主控台] 視窗中。</span><span class="sxs-lookup"><span data-stu-id="e9504-207">The **SqlException.Number** and **SqlException.Message** are displayed in the Console window.</span></span>  
  
- <span data-ttu-id="e9504-208">執行清除程式碼以關閉 **AdventureWorks** 中的快照集隔離，並刪除 **TestSnapshotUpdate** 資料表。</span><span class="sxs-lookup"><span data-stu-id="e9504-208">Executes clean-up code to turn off snapshot isolation in **AdventureWorks** and delete the **TestSnapshotUpdate** table.</span></span>  
  
 [!code-csharp[DataWorks SnapshotIsolation.DemoUpdate#1](../../../../../samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks SnapshotIsolation.DemoUpdate/CS/source.cs#1)]
 [!code-vb[DataWorks SnapshotIsolation.DemoUpdate#1](../../../../../samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks SnapshotIsolation.DemoUpdate/VB/source.vb#1)]  
  
### <a name="using-lock-hints-with-snapshot-isolation"></a><span data-ttu-id="e9504-209">搭配使用鎖定提示與快照集隔離</span><span class="sxs-lookup"><span data-stu-id="e9504-209">Using Lock Hints with Snapshot Isolation</span></span>  

 <span data-ttu-id="e9504-210">在上一個範例中，第一個交易會選取資料，第二個交易可以在第一個交易即將完成之前更新資料，進而導致當第一個交易嘗試更新相同的資料列時發生更新衝突。</span><span class="sxs-lookup"><span data-stu-id="e9504-210">In the previous example, the first transaction selects data, and a second transaction updates the data before the first transaction is able to complete, causing an update conflict when the first transaction tries to update the same row.</span></span> <span data-ttu-id="e9504-211">您可以透過在交易開始時提供鎖定提示，以減少長時間執行之快照集交易中發生更新衝突的機會。</span><span class="sxs-lookup"><span data-stu-id="e9504-211">You can reduce the chance of update conflicts in long-running snapshot transactions by supplying lock hints at the beginning of the transaction.</span></span> <span data-ttu-id="e9504-212">下列 SELECT 陳述式使用 UPDLOCK 提示來鎖定選取的資料列：</span><span class="sxs-lookup"><span data-stu-id="e9504-212">The following SELECT statement uses the UPDLOCK hint to lock the selected rows:</span></span>  
  
```sql  
SELECT * FROM TestSnapshotUpdate WITH (UPDLOCK)
  WHERE PriKey BETWEEN 1 AND 3  
```  
  
 <span data-ttu-id="e9504-213">使用 UPDLOCK 鎖定提示會封鎖在第一個交易完成之前嘗試更新資料列的任何資料列。</span><span class="sxs-lookup"><span data-stu-id="e9504-213">Using the UPDLOCK lock hint blocks any rows attempting to update the rows before the first transaction completes.</span></span> <span data-ttu-id="e9504-214">這可確保選取的資料列之後在交易中更新時不會發生衝突。</span><span class="sxs-lookup"><span data-stu-id="e9504-214">This guarantees that the selected rows have no conflicts when they are updated later in the transaction.</span></span> <span data-ttu-id="e9504-215">請參閱《SQL Server 線上叢書》中的＜鎖定提示＞。</span><span class="sxs-lookup"><span data-stu-id="e9504-215">See "Locking Hints" in SQL Server Books Online.</span></span>  
  
 <span data-ttu-id="e9504-216">如果您的應用程式有許多衝突，快照集隔離可能就不是最佳選擇。</span><span class="sxs-lookup"><span data-stu-id="e9504-216">If your application has many conflicts, snapshot isolation may not be the best choice.</span></span> <span data-ttu-id="e9504-217">提示應該只在真正需要時才使用。</span><span class="sxs-lookup"><span data-stu-id="e9504-217">Hints should only be used when really needed.</span></span> <span data-ttu-id="e9504-218">您的應用程式不應該設計成會持續依賴鎖定提示來執行其作業。</span><span class="sxs-lookup"><span data-stu-id="e9504-218">Your application should not be designed so that it constantly relies on lock hints for its operation.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="e9504-219">另請參閱</span><span class="sxs-lookup"><span data-stu-id="e9504-219">See also</span></span>

- <span data-ttu-id="e9504-220">[SQL Server and ADO.NET](index.md) (SQL Server 和 ADO.NET)</span><span class="sxs-lookup"><span data-stu-id="e9504-220">[SQL Server and ADO.NET](index.md)</span></span>
- <span data-ttu-id="e9504-221">[ADO.NET 概觀](../ado-net-overview.md) \(部分機器翻譯\)</span><span class="sxs-lookup"><span data-stu-id="e9504-221">[ADO.NET Overview](../ado-net-overview.md)</span></span>
- [<span data-ttu-id="e9504-222">交易鎖定與資料列版本設定指南</span><span class="sxs-lookup"><span data-stu-id="e9504-222">Transaction Locking and Row Versioning Guide</span></span>](/sql/relational-databases/sql-server-transaction-locking-and-row-versioning-guide)
