---
title: SQL-CLR 類型對應
ms.date: 07/23/2018
ms.assetid: 4ed76327-54a7-414b-82a9-7579bfcec04b
ms.openlocfilehash: 6d0a1bca5baade1bab6042bb7b7ab8e2d1353360
ms.sourcegitcommit: 27a15a55019f6b5f2733961738babe94aec0def3
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 09/15/2020
ms.locfileid: "90555597"
---
# <a name="sql-clr-type-mapping"></a><span data-ttu-id="38754-102">SQL-CLR 類型對應</span><span class="sxs-lookup"><span data-stu-id="38754-102">SQL-CLR Type Mapping</span></span>
<span data-ttu-id="38754-103">在 LINQ to SQL 中，關聯式資料庫的資料模型會對應至以您選擇之程式語言表示的物件模型 (Object Model)。</span><span class="sxs-lookup"><span data-stu-id="38754-103">In LINQ to SQL, the data model of a relational database maps to an object model that is expressed in the programming language of your choice.</span></span> <span data-ttu-id="38754-104">執行應用程式時，LINQ to SQL 會將物件模型中的 Language Integrated Query (LINQ) 轉譯成 SQL，並將這些查詢傳送至資料庫進行執行。</span><span class="sxs-lookup"><span data-stu-id="38754-104">When the application runs, LINQ to SQL translates the language-integrated queries in the object model into SQL and sends them to the database for execution.</span></span> <span data-ttu-id="38754-105">當資料庫傳回結果時，LINQ to SQL 會將結果轉譯回您可以在自己的程式語言中處理的物件。</span><span class="sxs-lookup"><span data-stu-id="38754-105">When the database returns the results, LINQ to SQL translates the results back to objects that you can work with in your own programming language.</span></span>  
  
 <span data-ttu-id="38754-106">為了在物件模型和資料庫之間轉譯資料，必須定義型別 *對應* 。</span><span class="sxs-lookup"><span data-stu-id="38754-106">In order to translate data between the object model and the database, a *type mapping* must be defined.</span></span> <span data-ttu-id="38754-107">LINQ to SQL 會使用型別對應來比對每個 Common Language Runtime (CLR) 型別與特定 SQL Server 型別。</span><span class="sxs-lookup"><span data-stu-id="38754-107">LINQ to SQL uses a type mapping to match each common language runtime (CLR) type with a particular SQL Server type.</span></span> <span data-ttu-id="38754-108">您可以使用以屬性 (Attribute) 為基礎的對應，在物件模型內部定義型別對應和其他對應資訊，例如資料庫結構與資料表關聯性 (Relationship)。</span><span class="sxs-lookup"><span data-stu-id="38754-108">You can define type mappings and other mapping information, such as database structure and table relationships, inside the object model with attribute-based mapping.</span></span> <span data-ttu-id="38754-109">此外，您也可以使用外部對應檔案，在物件模型外部指定對應資訊。</span><span class="sxs-lookup"><span data-stu-id="38754-109">Alternatively, you can specify the mapping information outside the object model with an external mapping file.</span></span> <span data-ttu-id="38754-110">如需詳細資訊，請參閱以 [屬性為基礎的對應](attribute-based-mapping.md) 和 [外部對應](external-mapping.md)。</span><span class="sxs-lookup"><span data-stu-id="38754-110">For more information, see [Attribute-Based Mapping](attribute-based-mapping.md) and [External Mapping](external-mapping.md).</span></span>  
  
 <span data-ttu-id="38754-111">這個主題將討論下列重點：</span><span class="sxs-lookup"><span data-stu-id="38754-111">This topic discusses the following points:</span></span>  
  
- [<span data-ttu-id="38754-112">預設型別對應</span><span class="sxs-lookup"><span data-stu-id="38754-112">Default Type Mapping</span></span>](#DefaultTypeMapping)  
  
- [<span data-ttu-id="38754-113">型別對應的執行階段行為對照表</span><span class="sxs-lookup"><span data-stu-id="38754-113">Type Mapping Run-time Behavior Matrix</span></span>](#BehaviorMatrix)  
  
- [<span data-ttu-id="38754-114">CLR 與 SQL 執行之間的行為差異</span><span class="sxs-lookup"><span data-stu-id="38754-114">Behavior Differences Between CLR and SQL Execution</span></span>](#BehaviorDiffs)  
  
- [<span data-ttu-id="38754-115">Enum 對應</span><span class="sxs-lookup"><span data-stu-id="38754-115">Enum Mapping</span></span>](#EnumMapping)  
  
- [<span data-ttu-id="38754-116">數字對應</span><span class="sxs-lookup"><span data-stu-id="38754-116">Numeric Mapping</span></span>](#NumericMapping)  
  
- [<span data-ttu-id="38754-117">文字和 XML 對應</span><span class="sxs-lookup"><span data-stu-id="38754-117">Text and XML Mapping</span></span>](#TextMapping)  
  
- [<span data-ttu-id="38754-118">日期和時間對應</span><span class="sxs-lookup"><span data-stu-id="38754-118">Date and Time Mapping</span></span>](#DateMapping)  
  
- [<span data-ttu-id="38754-119">二進位對應</span><span class="sxs-lookup"><span data-stu-id="38754-119">Binary Mapping</span></span>](#BinaryMapping)  
  
- [<span data-ttu-id="38754-120">其他對應</span><span class="sxs-lookup"><span data-stu-id="38754-120">Miscellaneous Mapping</span></span>](#MiscMapping)  
  
<a name="DefaultTypeMapping"></a>
## <a name="default-type-mapping"></a><span data-ttu-id="38754-121">預設型別對應</span><span class="sxs-lookup"><span data-stu-id="38754-121">Default Type Mapping</span></span>  
 <span data-ttu-id="38754-122">您可以使用物件關聯式設計工具 (O/R 設計工具) 或 SQLMetal 命令列工具，自動建立物件模型或外部對應檔案。</span><span class="sxs-lookup"><span data-stu-id="38754-122">You can create the object model or external mapping file automatically with the Object Relational Designer (O/R Designer) or the SQLMetal command-line tool.</span></span> <span data-ttu-id="38754-123">這些工具的預設型別對應會定義選擇哪些 CLR 型別來對應至 SQL Server 資料庫內部的資料行。</span><span class="sxs-lookup"><span data-stu-id="38754-123">The default type mappings for these tools define which CLR types are chosen to map to columns inside the SQL Server database.</span></span> <span data-ttu-id="38754-124">如需使用這些工具的詳細資訊，請參閱 [建立物件模型](creating-the-object-model.md)。</span><span class="sxs-lookup"><span data-stu-id="38754-124">For more information about using these tools, see [Creating the Object Model](creating-the-object-model.md).</span></span>  
  
 <span data-ttu-id="38754-125">您也可以根據物件模型或外部對應檔案中的對應資訊，使用 <xref:System.Data.Linq.DataContext.CreateDatabase%2A> 方法來建立 SQL Server 資料庫。</span><span class="sxs-lookup"><span data-stu-id="38754-125">You can also use the <xref:System.Data.Linq.DataContext.CreateDatabase%2A> method to create a SQL Server database based on the mapping information in the object model or external mapping file.</span></span> <span data-ttu-id="38754-126"><xref:System.Data.Linq.DataContext.CreateDatabase%2A> 方法的預設型別對應會定義建立哪些 SQL Server 資料行型別來對應至物件模型中的 CLR 型別。</span><span class="sxs-lookup"><span data-stu-id="38754-126">The default type mappings for the <xref:System.Data.Linq.DataContext.CreateDatabase%2A> method define which type of SQL Server columns are created to map to the CLR types in the object model.</span></span> <span data-ttu-id="38754-127">如需詳細資訊，請參閱 [如何：動態建立資料庫](how-to-dynamically-create-a-database.md)。</span><span class="sxs-lookup"><span data-stu-id="38754-127">For more information, see [How to: Dynamically Create a Database](how-to-dynamically-create-a-database.md).</span></span>  
  
<a name="BehaviorMatrix"></a>
## <a name="type-mapping-run-time-behavior-matrix"></a><span data-ttu-id="38754-128">型別對應的執行階段行為對照表</span><span class="sxs-lookup"><span data-stu-id="38754-128">Type Mapping Run-time Behavior Matrix</span></span>  
 <span data-ttu-id="38754-129">下圖顯示從資料庫中擷取資料或將資料儲存至資料庫時，特定型別對應的預期執行階段行為。</span><span class="sxs-lookup"><span data-stu-id="38754-129">The following diagram shows the expected run-time behavior of specific type mappings when data is retrieved from or saved to the database.</span></span> <span data-ttu-id="38754-130">除了序列化 (Serialization) 以外，LINQ to SQL 不支援此對照表中未指定之任何 CLR 或 SQL Server 資料型別之間的對應。</span><span class="sxs-lookup"><span data-stu-id="38754-130">With the exception of serialization, LINQ to SQL does not support mapping between any CLR or SQL Server data types that are not specified in this matrix.</span></span> <span data-ttu-id="38754-131">如需有關序列化支援的詳細資訊，請參閱 [二進位序列化](#BinarySerialization)。</span><span class="sxs-lookup"><span data-stu-id="38754-131">For more information on serialization support, see [Binary Serialization](#BinarySerialization).</span></span>  

![SQL Server 至 SQL CLR 資料類型對應表](./media/sql-clr-type-mapping.png)

> [!NOTE]
> <span data-ttu-id="38754-133">在資料庫之間來回轉譯時，某些型別對應可能會造成溢位或資料遺失的例外狀況 (Exception)。</span><span class="sxs-lookup"><span data-stu-id="38754-133">Some type mappings may result in overflow or data loss exceptions while translating to or from the database.</span></span>  
  
### <a name="custom-type-mapping"></a><span data-ttu-id="38754-134">自訂類型對應</span><span class="sxs-lookup"><span data-stu-id="38754-134">Custom Type Mapping</span></span>  
 <span data-ttu-id="38754-135">在 LINQ to SQL 中，您不會受限於 O/R 設計工具、SQLMetal 和 <xref:System.Data.Linq.DataContext.CreateDatabase%2A> 方法的預設型別對應。</span><span class="sxs-lookup"><span data-stu-id="38754-135">With LINQ to SQL, you are not limited to the default type mappings used by the O/R Designer, SQLMetal, and the <xref:System.Data.Linq.DataContext.CreateDatabase%2A> method.</span></span> <span data-ttu-id="38754-136">您可以在 DBML 檔案中明確指定自訂型別對應，藉以建立這些對應。</span><span class="sxs-lookup"><span data-stu-id="38754-136">You can create custom type mappings by explicitly specifying them in a DBML file.</span></span> <span data-ttu-id="38754-137">然後，您就可以使用該 DBML 檔案來建立物件模型程式碼和對應檔案。</span><span class="sxs-lookup"><span data-stu-id="38754-137">Then you can use that DBML file to create the object model code and mapping file.</span></span> <span data-ttu-id="38754-138">如需詳細資訊，請參閱 [SQL CLR 自訂類型](sql-clr-custom-type-mappings.md)對應。</span><span class="sxs-lookup"><span data-stu-id="38754-138">For more information, see [SQL-CLR Custom Type Mappings](sql-clr-custom-type-mappings.md).</span></span>  
  
<a name="BehaviorDiffs"></a>
## <a name="behavior-differences-between-clr-and-sql-execution"></a><span data-ttu-id="38754-139">CLR 與 SQL 執行之間的行為差異</span><span class="sxs-lookup"><span data-stu-id="38754-139">Behavior Differences Between CLR and SQL Execution</span></span>  
 <span data-ttu-id="38754-140">由於 CLR 與 SQL Server 之間存在精確度和執行差異，所以您可能會收到不同的結果或產生不同的行為，端視執行計算的位置而定。</span><span class="sxs-lookup"><span data-stu-id="38754-140">Because of differences in precision and execution between the CLR and SQL Server, you may receive different results or experience different behavior depending on where you perform your calculations.</span></span> <span data-ttu-id="38754-141">在 LINQ to SQL 查詢中執行的計算實際上會轉譯成 Transact-SQL，然後在 SQL Server 資料庫上執行。</span><span class="sxs-lookup"><span data-stu-id="38754-141">Calculations performed in LINQ to SQL queries are actually translated to Transact-SQL and then executed on the SQL Server database.</span></span> <span data-ttu-id="38754-142">在 LINQ to SQL 查詢外部執行的計算則會在 CLR 的內容中執行。</span><span class="sxs-lookup"><span data-stu-id="38754-142">Calculations performed outside LINQ to SQL queries are executed within the context of the CLR.</span></span>  
  
 <span data-ttu-id="38754-143">例如，下面是 CLR 與 SQL Server 之間的一些行為差異：</span><span class="sxs-lookup"><span data-stu-id="38754-143">For example, the following are some differences in behavior between the CLR and SQL Server:</span></span>  
  
- <span data-ttu-id="38754-144">SQL Server 排序某些資料型別的方式與 CLR 中對等資料型別的排序方式不同。</span><span class="sxs-lookup"><span data-stu-id="38754-144">SQL Server orders some data types differently than data of equivalent type in the CLR.</span></span> <span data-ttu-id="38754-145">例如，SQL Server 資料型別 `UNIQUEIDENTIFIER` 的排序方式就與 CLR 資料型別 <xref:System.Guid?displayProperty=nameWithType> 的排序方式不同。</span><span class="sxs-lookup"><span data-stu-id="38754-145">For example, SQL Server data of type `UNIQUEIDENTIFIER` is ordered differently than CLR data of type <xref:System.Guid?displayProperty=nameWithType>.</span></span>  
  
- <span data-ttu-id="38754-146">SQL Server 處理某些字串比較作業的方式與 CLR 不同。</span><span class="sxs-lookup"><span data-stu-id="38754-146">SQL Server handles some string comparison operations differently than the CLR.</span></span> <span data-ttu-id="38754-147">在 SQL Server 中，字串比較行為會因伺服器的定序 (Collation) 設定而不同。</span><span class="sxs-lookup"><span data-stu-id="38754-147">In SQL Server, string comparison behavior depends on the collation settings on the server.</span></span> <span data-ttu-id="38754-148">如需詳細資訊，請參閱 Microsoft SQL Server 線上叢書中的 [使用](/previous-versions/sql/sql-server-2008-r2/ms187582(v=sql.105)) 定序。</span><span class="sxs-lookup"><span data-stu-id="38754-148">For more information, see [Working with Collations](/previous-versions/sql/sql-server-2008-r2/ms187582(v=sql.105)) in the Microsoft SQL Server Books Online.</span></span>  
  
- <span data-ttu-id="38754-149">SQL Server 與 CLR 可能會針對某些對應函式傳回不同的值。</span><span class="sxs-lookup"><span data-stu-id="38754-149">SQL Server may return different values for some mapped functions than the CLR.</span></span> <span data-ttu-id="38754-150">例如，等號比較函式便有所不同，因為如果兩個字串只有尾端泛空白字元 (White Space) 不同，SQL Server 就會將它們視為相等，而 CLR 則會將它們視為不相等。</span><span class="sxs-lookup"><span data-stu-id="38754-150">For example, equality functions will differ because SQL Server considers two strings to be equal if they only differ in trailing white space; whereas the CLR considers them to be not equal.</span></span>  
  
<a name="EnumMapping"></a>
## <a name="enum-mapping"></a><span data-ttu-id="38754-151">Enum 對應</span><span class="sxs-lookup"><span data-stu-id="38754-151">Enum Mapping</span></span>  
 <span data-ttu-id="38754-152">LINQ to SQL 支援以下列兩種方式將 CLR <xref:System.Enum?displayProperty=nameWithType> 型別對應至 SQL Server 型別：</span><span class="sxs-lookup"><span data-stu-id="38754-152">LINQ to SQL supports mapping the CLR <xref:System.Enum?displayProperty=nameWithType> type to SQL Server types in two ways:</span></span>  
  
- <span data-ttu-id="38754-153">對應至 SQL 數字型別 (`TINYINT`、`SMALLINT`、`INT`、`BIGINT`)</span><span class="sxs-lookup"><span data-stu-id="38754-153">Mapping to SQL numeric types (`TINYINT`, `SMALLINT`, `INT`, `BIGINT`)</span></span>  
  
     <span data-ttu-id="38754-154">當您將 CLR <xref:System.Enum?displayProperty=nameWithType> 型別對應至 SQL 數字型別 (Numeric Type) 時，就會將 CLR <xref:System.Enum?displayProperty=nameWithType> 的基礎整數值對應至 SQL Server 資料庫資料行的值。</span><span class="sxs-lookup"><span data-stu-id="38754-154">When you map a CLR <xref:System.Enum?displayProperty=nameWithType> type to a SQL numeric type, you map the underlying integer value of the CLR <xref:System.Enum?displayProperty=nameWithType> to the value of the SQL Server database column.</span></span> <span data-ttu-id="38754-155">例如，如果名為 <xref:System.Enum?displayProperty=nameWithType> 的 `DaysOfWeek` 包含名為 `Tue` 而且具有基礎整數值 3 的成員，則該成員就會對應至資料庫值 3。</span><span class="sxs-lookup"><span data-stu-id="38754-155">For example, if a <xref:System.Enum?displayProperty=nameWithType> named `DaysOfWeek` contains a member named `Tue` with an underlying integer value of 3, that member maps to a database value of 3.</span></span>  
  
- <span data-ttu-id="38754-156">對應至 SQL 文字型別 (`CHAR`、`NCHAR`、`VARCHAR`、`NVARCHAR`)</span><span class="sxs-lookup"><span data-stu-id="38754-156">Mapping to SQL text types (`CHAR`, `NCHAR`, `VARCHAR`, `NVARCHAR`)</span></span>  
  
     <span data-ttu-id="38754-157">當您將 CLR <xref:System.Enum?displayProperty=nameWithType> 型別對應至 SQL 文字型別時，SQL 資料庫值會對應至 CLR <xref:System.Enum?displayProperty=nameWithType> 成員的名稱。</span><span class="sxs-lookup"><span data-stu-id="38754-157">When you map a CLR <xref:System.Enum?displayProperty=nameWithType> type to a SQL text type, the SQL database value is mapped to the names of the CLR <xref:System.Enum?displayProperty=nameWithType> members.</span></span> <span data-ttu-id="38754-158">例如，如果名為 <xref:System.Enum?displayProperty=nameWithType> 的 `DaysOfWeek` 包含名為 `Tue` 而且具有基礎整數值 3 的成員，則該成員就會對應至資料庫值 `Tue`。</span><span class="sxs-lookup"><span data-stu-id="38754-158">For example, if a <xref:System.Enum?displayProperty=nameWithType> named `DaysOfWeek` contains a member named `Tue` with an underlying integer value of 3, that member maps to a database value of `Tue`.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="38754-159">將 SQL 文字型別對應至 CLR <xref:System.Enum?displayProperty=nameWithType> 時，請單獨在對應的 SQL 資料行中加入 <xref:System.Enum> 成員的名稱。</span><span class="sxs-lookup"><span data-stu-id="38754-159">When mapping SQL text types to a CLR <xref:System.Enum?displayProperty=nameWithType>, include only the names of the <xref:System.Enum> members in the mapped SQL column.</span></span> <span data-ttu-id="38754-160"><xref:System.Enum> 對應的 SQL 資料行不支援其他值。</span><span class="sxs-lookup"><span data-stu-id="38754-160">Other values are not supported in the <xref:System.Enum>-mapped SQL column.</span></span>  
  
 <span data-ttu-id="38754-161">O/R 設計工具和 SQLMetal 命令列工具無法自動將 SQL 型別對應至 CLR <xref:System.Enum> 類別 (Class)。</span><span class="sxs-lookup"><span data-stu-id="38754-161">The O/R Designer and SQLMetal command-line tool cannot automatically map a SQL type to a CLR <xref:System.Enum> class.</span></span> <span data-ttu-id="38754-162">您必須針對供 O/R 設計工具和 SQLMetal 使用自訂 DBML 檔案，藉以明確設定此對應。</span><span class="sxs-lookup"><span data-stu-id="38754-162">You must explicitly configure this mapping by customizing a DBML file for use by the O/R Designer and SQLMetal.</span></span> <span data-ttu-id="38754-163">如需自訂類型對應的詳細資訊，請參閱 [SQL CLR 自訂類型](sql-clr-custom-type-mappings.md)對應。</span><span class="sxs-lookup"><span data-stu-id="38754-163">For more information about custom type mapping, see [SQL-CLR Custom Type Mappings](sql-clr-custom-type-mappings.md).</span></span>  
  
 <span data-ttu-id="38754-164">因為用於列舉的 SQL 資料行與其他數值和文字資料行的類型相同;這些工具將無法辨識您的意圖和預設為對應，如下列 [數值對應](#NumericMapping) 和 [文字和 XML 對應](#TextMapping) 章節所述。</span><span class="sxs-lookup"><span data-stu-id="38754-164">Because a SQL column intended for enumeration will be of the same type as other numeric and text columns; these tools will not recognize your intent and default to mapping as described in the following [Numeric Mapping](#NumericMapping) and [Text and XML Mapping](#TextMapping) sections.</span></span> <span data-ttu-id="38754-165">如需使用 DBML 檔案產生程式碼的詳細資訊，請參閱 [LINQ to SQL 中的程式碼產生](code-generation-in-linq-to-sql.md)。</span><span class="sxs-lookup"><span data-stu-id="38754-165">For more information about generating code with the DBML file, see [Code Generation in LINQ to SQL](code-generation-in-linq-to-sql.md).</span></span>  
  
 <span data-ttu-id="38754-166"><xref:System.Data.Linq.DataContext.CreateDatabase%2A?displayProperty=nameWithType> 方法會建立數字型別的 SQL 資料行來對應 CLR <xref:System.Enum?displayProperty=nameWithType> 型別。</span><span class="sxs-lookup"><span data-stu-id="38754-166">The <xref:System.Data.Linq.DataContext.CreateDatabase%2A?displayProperty=nameWithType> method creates a SQL column of numeric type to map a CLR <xref:System.Enum?displayProperty=nameWithType> type.</span></span>  
  
<a name="NumericMapping"></a>
## <a name="numeric-mapping"></a><span data-ttu-id="38754-167">數字對應</span><span class="sxs-lookup"><span data-stu-id="38754-167">Numeric Mapping</span></span>  
 <span data-ttu-id="38754-168">LINQ to SQL 可讓您對應許多 CLR 和 SQL Server 數字型別。</span><span class="sxs-lookup"><span data-stu-id="38754-168">LINQ to SQL lets you map many CLR and SQL Server numeric types.</span></span> <span data-ttu-id="38754-169">下表顯示根據資料庫建置物件模型或外部對應檔案時，O/R 設計工具和 SQLMetal 所選取的 CLR 型別。</span><span class="sxs-lookup"><span data-stu-id="38754-169">The following table shows the CLR types that O/R Designer and SQLMetal select when building an object model or external mapping file based on your database.</span></span>  
  
|<span data-ttu-id="38754-170">SQL Server 類型</span><span class="sxs-lookup"><span data-stu-id="38754-170">SQL Server Type</span></span>|<span data-ttu-id="38754-171">O/R 設計工具和 SQLMetal 所使用的預設 CLR 型別對應</span><span class="sxs-lookup"><span data-stu-id="38754-171">Default CLR Type mapping used by O/R Designer and SQLMetal</span></span>|  
|---------------------|-----------------------------------------------------------------|  
|`BIT`|<xref:System.Boolean?displayProperty=nameWithType>|  
|`TINYINT`|<xref:System.Int16?displayProperty=nameWithType>|  
|`INT`|<xref:System.Int32?displayProperty=nameWithType>|  
|`BIGINT`|<xref:System.Int64?displayProperty=nameWithType>|  
|`SMALLMONEY`|<xref:System.Decimal?displayProperty=nameWithType>|  
|`MONEY`|<xref:System.Decimal?displayProperty=nameWithType>|  
|`DECIMAL`|<xref:System.Decimal?displayProperty=nameWithType>|  
|`NUMERIC`|<xref:System.Decimal?displayProperty=nameWithType>|  
|`REAL/FLOAT(24)`|<xref:System.Single?displayProperty=nameWithType>|  
|`FLOAT/FLOAT(53)`|<xref:System.Double?displayProperty=nameWithType>|  
  
 <span data-ttu-id="38754-172">下表顯示 <xref:System.Data.Linq.DataContext.CreateDatabase%2A?displayProperty=nameWithType> 方法用於定義建立哪些 SQL 資料行型別來對應至 CLR 型別 (定義於物件模型或外部對應檔案中) 的預設型別對應。</span><span class="sxs-lookup"><span data-stu-id="38754-172">The next table shows the default type mappings used by the <xref:System.Data.Linq.DataContext.CreateDatabase%2A?displayProperty=nameWithType> method to define which type of SQL columns are created to map to the CLR types defined in your object model or external mapping file.</span></span>  
  
|<span data-ttu-id="38754-173">CLR 型別</span><span class="sxs-lookup"><span data-stu-id="38754-173">CLR Type</span></span>|<span data-ttu-id="38754-174"><xref:System.Data.Linq.DataContext.CreateDatabase%2A?displayProperty=nameWithType> 所使用的預設 SQL Server 型別</span><span class="sxs-lookup"><span data-stu-id="38754-174">Default SQL Server Type used by <xref:System.Data.Linq.DataContext.CreateDatabase%2A?displayProperty=nameWithType></span></span>|  
|--------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|  
|<xref:System.Boolean?displayProperty=nameWithType>|`BIT`|  
|<xref:System.Byte?displayProperty=nameWithType>|`TINYINT`|  
|<xref:System.Int16?displayProperty=nameWithType>|`SMALLINT`|  
|<xref:System.Int32?displayProperty=nameWithType>|`INT`|  
|<xref:System.Int64?displayProperty=nameWithType>|`BIGINT`|  
|<xref:System.SByte?displayProperty=nameWithType>|`SMALLINT`|  
|<xref:System.UInt16?displayProperty=nameWithType>|`INT`|  
|<xref:System.UInt32?displayProperty=nameWithType>|`BIGINT`|  
|<xref:System.UInt64?displayProperty=nameWithType>|`DECIMAL(20)`|  
|<xref:System.Decimal?displayProperty=nameWithType>|`DECIMAL(29,4)`|  
|<xref:System.Single?displayProperty=nameWithType>|`REAL`|  
|<xref:System.Double?displayProperty=nameWithType>|`FLOAT`|  
  
 <span data-ttu-id="38754-175">雖然還有許多其他數字對應可供您選擇，但是在資料庫之間來回轉譯時，某些對應可能會造成溢位或資料遺失的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="38754-175">There are many other numeric mappings you can choose, but some may result in overflow or data loss exceptions while translating to or from the database.</span></span> <span data-ttu-id="38754-176">如需詳細資訊，請參閱 [類型對應執行時間行為矩陣](#BehaviorMatrix)。</span><span class="sxs-lookup"><span data-stu-id="38754-176">For more information, see the [Type Mapping Run Time Behavior Matrix](#BehaviorMatrix).</span></span>  
  
### <a name="decimal-and-money-types"></a><span data-ttu-id="38754-177">Decimal 和 Money 型別</span><span class="sxs-lookup"><span data-stu-id="38754-177">Decimal and Money Types</span></span>  
 <span data-ttu-id="38754-178">SQL Server 類型的預設有效位數 `DECIMAL` (小數點左邊和右邊的18個小數位數) 遠小於 <xref:System.Decimal?displayProperty=nameWithType> 預設會與它配對之 CLR 類型的精確度。</span><span class="sxs-lookup"><span data-stu-id="38754-178">The default precision of SQL Server `DECIMAL` type (18 decimal digits to the left and right of the decimal point) is much smaller than the precision of the CLR <xref:System.Decimal?displayProperty=nameWithType> type that it is paired with by default.</span></span> <span data-ttu-id="38754-179">當您將資料儲存至資料庫時，這可能會導致精確度遺失。</span><span class="sxs-lookup"><span data-stu-id="38754-179">This can result in precision loss when you save data to the database.</span></span> <span data-ttu-id="38754-180">不過，如果 SQL Server `DECIMAL` 型別設定為大於 29 個位數的精確度，可能會發生完全相反的情況。</span><span class="sxs-lookup"><span data-stu-id="38754-180">However, just the opposite can happen if the SQL Server `DECIMAL` type is configured with greater than 29 digits of precision.</span></span> <span data-ttu-id="38754-181">當 SQL Server `DECIMAL` 型別已經設定為大於 CLR <xref:System.Decimal?displayProperty=nameWithType> 的精確度時，如果從資料庫中擷取資料，就可能會發生精確度遺失。</span><span class="sxs-lookup"><span data-stu-id="38754-181">When a SQL Server `DECIMAL` type has been configured with a greater precision than the CLR <xref:System.Decimal?displayProperty=nameWithType>, precision loss can occur when retrieving data from the database.</span></span>  
  
 <span data-ttu-id="38754-182">SQL Server `MONEY` 和 `SMALLMONEY` 型別 (預設也會與 CLR <xref:System.Decimal?displayProperty=nameWithType> 型別搭配使用) 具有更小的精確度，而且將資料儲存至資料庫時，可能會造成溢位或資料遺失的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="38754-182">The SQL Server `MONEY` and `SMALLMONEY` types, which are also paired with the CLR <xref:System.Decimal?displayProperty=nameWithType> type by default, have a much smaller precision, which can result in overflow or data loss exceptions when saving data to the database.</span></span>  
  
<a name="TextMapping"></a>
## <a name="text-and-xml-mapping"></a><span data-ttu-id="38754-183">文字和 XML 對應</span><span class="sxs-lookup"><span data-stu-id="38754-183">Text and XML Mapping</span></span>  
 <span data-ttu-id="38754-184">還有許多以文字為基礎的型別和 XML 型別，可讓您透過 LINQ to SQL 進行對應。</span><span class="sxs-lookup"><span data-stu-id="38754-184">There are also many text-based and XML types that you can map with LINQ to SQL.</span></span> <span data-ttu-id="38754-185">下表顯示根據資料庫建置物件模型或外部對應檔案時，O/R 設計工具和 SQLMetal 所選取的 CLR 型別。</span><span class="sxs-lookup"><span data-stu-id="38754-185">The following table shows the CLR types that O/R Designer and SQLMetal select when building an object model or external mapping file based on your database.</span></span>  
  
|<span data-ttu-id="38754-186">SQL Server 類型</span><span class="sxs-lookup"><span data-stu-id="38754-186">SQL Server Type</span></span>|<span data-ttu-id="38754-187">O/R 設計工具和 SQLMetal 所使用的預設 CLR 型別對應</span><span class="sxs-lookup"><span data-stu-id="38754-187">Default CLR Type mapping used by O/R Designer and SQLMetal</span></span>|  
|---------------------|-----------------------------------------------------------------|  
|`CHAR`|<xref:System.String?displayProperty=nameWithType>|  
|`NCHAR`|<xref:System.String?displayProperty=nameWithType>|  
|`VARCHAR`|<xref:System.String?displayProperty=nameWithType>|  
|`NVARCHAR`|<xref:System.String?displayProperty=nameWithType>|  
|`TEXT`|<xref:System.String?displayProperty=nameWithType>|  
|`NTEXT`|<xref:System.String?displayProperty=nameWithType>|  
|`XML`|<xref:System.Xml.Linq.XElement?displayProperty=nameWithType>|  
  
 <span data-ttu-id="38754-188">下表顯示 <xref:System.Data.Linq.DataContext.CreateDatabase%2A?displayProperty=nameWithType> 方法用於定義建立哪些 SQL 資料行型別來對應至 CLR 型別 (定義於物件模型或外部對應檔案中) 的預設型別對應。</span><span class="sxs-lookup"><span data-stu-id="38754-188">The next table shows the default type mappings used by the <xref:System.Data.Linq.DataContext.CreateDatabase%2A?displayProperty=nameWithType> method to define which type of SQL columns are created to map to the CLR types defined in your object model or external mapping file.</span></span>  
  
|<span data-ttu-id="38754-189">CLR 型別</span><span class="sxs-lookup"><span data-stu-id="38754-189">CLR Type</span></span>|<span data-ttu-id="38754-190"><xref:System.Data.Linq.DataContext.CreateDatabase%2A?displayProperty=nameWithType> 所使用的預設 SQL Server 型別</span><span class="sxs-lookup"><span data-stu-id="38754-190">Default SQL Server Type used by <xref:System.Data.Linq.DataContext.CreateDatabase%2A?displayProperty=nameWithType></span></span>|  
|--------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|  
|<xref:System.Char?displayProperty=nameWithType>|`NCHAR(1)`|  
|<xref:System.String?displayProperty=nameWithType>|`NVARCHAR(4000)`|  
|<span data-ttu-id="38754-191"><xref:System.Char?displayProperty=nameWithType>[]</span><span class="sxs-lookup"><span data-stu-id="38754-191"><xref:System.Char?displayProperty=nameWithType>[]</span></span>|`NVARCHAR(4000)`|  
|<span data-ttu-id="38754-192">實作 `Parse()` 和 `ToString()` 的自訂型別</span><span class="sxs-lookup"><span data-stu-id="38754-192">Custom type implementing `Parse()` and `ToString()`</span></span>|`NVARCHAR(MAX)`|  
  
 <span data-ttu-id="38754-193">雖然還有許多其他以文字為基礎的對應和 XML 對應可供您選擇，但是在資料庫之間來回轉譯時，某些對應可能會造成溢位或資料遺失的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="38754-193">There are many other text-based and XML mappings you can choose, but some may result in overflow or data loss exceptions while translating to or from the database.</span></span> <span data-ttu-id="38754-194">如需詳細資訊，請參閱 [類型對應執行時間行為矩陣](#BehaviorMatrix)。</span><span class="sxs-lookup"><span data-stu-id="38754-194">For more information, see the [Type Mapping Run Time Behavior Matrix](#BehaviorMatrix).</span></span>  
  
### <a name="xml-types"></a><span data-ttu-id="38754-195">XML 型別</span><span class="sxs-lookup"><span data-stu-id="38754-195">XML Types</span></span>  
 <span data-ttu-id="38754-196">從 Microsoft SQL Server 2005 開始，就提供了 SQL Server `XML` 資料型別。</span><span class="sxs-lookup"><span data-stu-id="38754-196">The SQL Server `XML` data type is available starting in Microsoft SQL Server 2005.</span></span> <span data-ttu-id="38754-197">您可以將 SQL Server `XML` 資料類型對應至 <xref:System.Xml.Linq.XElement>、<xref:System.Xml.Linq.XDocument> 或 <xref:System.String>。</span><span class="sxs-lookup"><span data-stu-id="38754-197">You can map the SQL Server `XML` data type to <xref:System.Xml.Linq.XElement>, <xref:System.Xml.Linq.XDocument>, or <xref:System.String>.</span></span> <span data-ttu-id="38754-198">如果資料行儲存的 XML 片段無法讀入 <xref:System.Xml.Linq.XElement> 中，則該資料行必須對應至 <xref:System.String>，以免發生執行階段錯誤。</span><span class="sxs-lookup"><span data-stu-id="38754-198">If the column stores XML fragments that cannot be read into <xref:System.Xml.Linq.XElement>, the column must be mapped to <xref:System.String> to avoid run-time errors.</span></span> <span data-ttu-id="38754-199">必須對應至 <xref:System.String> 的 XML 片段包括：</span><span class="sxs-lookup"><span data-stu-id="38754-199">XML fragments that must be mapped to <xref:System.String> include the following:</span></span>  
  
- <span data-ttu-id="38754-200">XML 項目的序列</span><span class="sxs-lookup"><span data-stu-id="38754-200">A sequence of XML elements</span></span>  
  
- <span data-ttu-id="38754-201">屬性</span><span class="sxs-lookup"><span data-stu-id="38754-201">Attributes</span></span>  
  
- <span data-ttu-id="38754-202">公用識別項 (PI)</span><span class="sxs-lookup"><span data-stu-id="38754-202">Public Identifiers (PI)</span></span>  
  
- <span data-ttu-id="38754-203">註解</span><span class="sxs-lookup"><span data-stu-id="38754-203">Comments</span></span>  
  
 <span data-ttu-id="38754-204">雖然您可以 <xref:System.Xml.Linq.XElement> 將和對應 <xref:System.Xml.Linq.XDocument> 至 SQL Server （如 [類型對應執行時間行為矩陣](#BehaviorMatrix)中所示），但方法沒有 <xref:System.Data.Linq.DataContext.CreateDatabase%2A?displayProperty=nameWithType> 這些類型的預設 SQL Server 類型對應。</span><span class="sxs-lookup"><span data-stu-id="38754-204">Although you can map <xref:System.Xml.Linq.XElement> and <xref:System.Xml.Linq.XDocument> to SQL Server as shown in the [Type Mapping Run Time Behavior Matrix](#BehaviorMatrix), the <xref:System.Data.Linq.DataContext.CreateDatabase%2A?displayProperty=nameWithType> method has no default SQL Server type mapping for these types.</span></span>  
  
### <a name="custom-types"></a><span data-ttu-id="38754-205">自訂型別</span><span class="sxs-lookup"><span data-stu-id="38754-205">Custom Types</span></span>  
 <span data-ttu-id="38754-206">如果類別可執行 `Parse()` 和 `ToString()` ，則您可以將物件對應至任何 SQL 文字類型， (、、、、、 `CHAR` `NCHAR` `VARCHAR` `NVARCHAR` `TEXT` `NTEXT` `XML`) 。</span><span class="sxs-lookup"><span data-stu-id="38754-206">If a class implements `Parse()` and `ToString()`, you can map the object to any SQL text type (`CHAR`, `NCHAR`, `VARCHAR`, `NVARCHAR`, `TEXT`, `NTEXT`, `XML`).</span></span> <span data-ttu-id="38754-207">此物件會透過將 `ToString()` 所傳回的值傳送至對應的資料庫資料行，儲存在資料庫中。</span><span class="sxs-lookup"><span data-stu-id="38754-207">The object is stored in the database by sending the value returned by `ToString()` to the mapped database column.</span></span> <span data-ttu-id="38754-208">此物件的重建方式是針對資料庫所傳回的字串叫用 (Invoke) `Parse()`。</span><span class="sxs-lookup"><span data-stu-id="38754-208">The object is reconstructed by invoking `Parse()` on the string returned by the database.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="38754-209">LINQ to SQL 不支援使用 <xref:System.Xml.Serialization.IXmlSerializable?displayProperty=nameWithType> 進行序列化。</span><span class="sxs-lookup"><span data-stu-id="38754-209">LINQ to SQL does not support serialization by using <xref:System.Xml.Serialization.IXmlSerializable?displayProperty=nameWithType>.</span></span>  
  
<a name="DateMapping"></a>
## <a name="date-and-time-mapping"></a><span data-ttu-id="38754-210">日期和時間對應</span><span class="sxs-lookup"><span data-stu-id="38754-210">Date and Time Mapping</span></span>  
 <span data-ttu-id="38754-211">在 LINQ to SQL 中，您可以對應許多 SQL Server 日期和時間型別。</span><span class="sxs-lookup"><span data-stu-id="38754-211">With LINQ to SQL, you can map many SQL Server date and time types.</span></span> <span data-ttu-id="38754-212">下表顯示根據資料庫建置物件模型或外部對應檔案時，O/R 設計工具和 SQLMetal 所選取的 CLR 型別。</span><span class="sxs-lookup"><span data-stu-id="38754-212">The following table shows the CLR types that O/R Designer and SQLMetal select when building an object model or external mapping file based on your database.</span></span>  
  
|<span data-ttu-id="38754-213">SQL Server 類型</span><span class="sxs-lookup"><span data-stu-id="38754-213">SQL Server Type</span></span>|<span data-ttu-id="38754-214">O/R 設計工具和 SQLMetal 所使用的預設 CLR 型別對應</span><span class="sxs-lookup"><span data-stu-id="38754-214">Default CLR Type mapping used by O/R Designer and SQLMetal</span></span>|  
|---------------------|-----------------------------------------------------------------|  
|`SMALLDATETIME`|<xref:System.DateTime?displayProperty=nameWithType>|  
|`DATETIME`|<xref:System.DateTime?displayProperty=nameWithType>|  
|`DATETIME2`|<xref:System.DateTime?displayProperty=nameWithType>|  
|`DATETIMEOFFSET`|<xref:System.DateTimeOffset?displayProperty=nameWithType>|  
|`DATE`|<xref:System.DateTime?displayProperty=nameWithType>|  
|`TIME`|<xref:System.TimeSpan?displayProperty=nameWithType>|  
  
 <span data-ttu-id="38754-215">下表顯示 <xref:System.Data.Linq.DataContext.CreateDatabase%2A?displayProperty=nameWithType> 方法用於定義建立哪些 SQL 資料行型別來對應至 CLR 型別 (定義於物件模型或外部對應檔案中) 的預設型別對應。</span><span class="sxs-lookup"><span data-stu-id="38754-215">The next table shows the default type mappings used by the <xref:System.Data.Linq.DataContext.CreateDatabase%2A?displayProperty=nameWithType> method to define which type of SQL columns are created to map to the CLR types defined in your object model or external mapping file.</span></span>  
  
|<span data-ttu-id="38754-216">CLR 型別</span><span class="sxs-lookup"><span data-stu-id="38754-216">CLR Type</span></span>|<span data-ttu-id="38754-217"><xref:System.Data.Linq.DataContext.CreateDatabase%2A?displayProperty=nameWithType> 所使用的預設 SQL Server 型別</span><span class="sxs-lookup"><span data-stu-id="38754-217">Default SQL Server Type used by <xref:System.Data.Linq.DataContext.CreateDatabase%2A?displayProperty=nameWithType></span></span>|  
|--------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|  
|<xref:System.DateTime?displayProperty=nameWithType>|`DATETIME`|  
|<xref:System.DateTimeOffset?displayProperty=nameWithType>|`DATETIMEOFFSET`|  
|<xref:System.TimeSpan?displayProperty=nameWithType>|`TIME`|  
  
 <span data-ttu-id="38754-218">雖然還有許多其他日期和時間對應可供您選擇，但是在資料庫之間來回轉譯時，某些對應可能會造成溢位或資料遺失的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="38754-218">There are many other date and time mappings you can choose, but some may result in overflow or data loss exceptions while translating to or from the database.</span></span> <span data-ttu-id="38754-219">如需詳細資訊，請參閱 [類型對應執行時間行為矩陣](#BehaviorMatrix)。</span><span class="sxs-lookup"><span data-stu-id="38754-219">For more information, see the [Type Mapping Run Time Behavior Matrix](#BehaviorMatrix).</span></span>  
  
> [!NOTE]
> <span data-ttu-id="38754-220">從 Microsoft SQL Server 2008 開始，就提供了 SQL Server 型別 `DATETIME2`、`DATETIMEOFFSET`、`DATE` 和 `TIME`。</span><span class="sxs-lookup"><span data-stu-id="38754-220">The SQL Server types `DATETIME2`, `DATETIMEOFFSET`, `DATE`, and `TIME` are available starting with Microsoft SQL Server 2008.</span></span> <span data-ttu-id="38754-221">從 .NET Framework 3.5 版 SP1 開始，LINQ to SQL 支援對應至這些新的型別。</span><span class="sxs-lookup"><span data-stu-id="38754-221">LINQ to SQL supports mapping to these new types starting with the .NET Framework version 3.5 SP1.</span></span>  
  
### <a name="systemdatetime"></a><span data-ttu-id="38754-222">System.Datetime</span><span class="sxs-lookup"><span data-stu-id="38754-222">System.Datetime</span></span>  
 <span data-ttu-id="38754-223">CLR <xref:System.DateTime?displayProperty=nameWithType> 型別的範圍和精確度大於 SQL Server `DATETIME` 型別的範圍和精確度，而這是 <xref:System.Data.Linq.DataContext.CreateDatabase%2A?displayProperty=nameWithType> 方法的預設型別對應。</span><span class="sxs-lookup"><span data-stu-id="38754-223">The range and precision of the CLR <xref:System.DateTime?displayProperty=nameWithType> type is greater than the range and precision of the SQL Server `DATETIME` type, which is the default type mapping for the <xref:System.Data.Linq.DataContext.CreateDatabase%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="38754-224">若要協助避免與超出 `DATETIME` 範圍之日期相關的例外狀況，請使用 `DATETIME2` (從 Microsoft SQL Server 2008 開始提供)。</span><span class="sxs-lookup"><span data-stu-id="38754-224">To help avoid exceptions related to dates outside the range of `DATETIME`, use `DATETIME2`, which is available starting with Microsoft SQL Server 2008.</span></span> <span data-ttu-id="38754-225">`DATETIME2` 可以符合 CLR 的範圍和精確度 <xref:System.DateTime?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="38754-225">`DATETIME2` can match the range and precision of the CLR <xref:System.DateTime?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="38754-226">SQL Server 日期沒有 <xref:System.TimeZone> 的概念，而這是 CLR 中完全支援的功能。</span><span class="sxs-lookup"><span data-stu-id="38754-226">SQL Server dates have no concept of <xref:System.TimeZone>, a feature that is richly supported in the CLR.</span></span> <span data-ttu-id="38754-227">不論原始 <xref:System.TimeZone> 資訊為何，<xref:System.TimeZone> 值會原樣儲存至資料庫，而不進行 <xref:System.DateTimeKind> 轉換。</span><span class="sxs-lookup"><span data-stu-id="38754-227"><xref:System.TimeZone> values are saved as is to the database without <xref:System.TimeZone> conversion, regardless of the original <xref:System.DateTimeKind> information.</span></span> <span data-ttu-id="38754-228">從資料庫擷取 <xref:System.DateTime> 值時，這個值會原樣載入至 <xref:System.DateTime>，並將 <xref:System.DateTimeKind> 設為 <xref:System.DateTimeKind.Unspecified> 中。</span><span class="sxs-lookup"><span data-stu-id="38754-228">When <xref:System.DateTime> values are retrieved from the database, their value is loaded as is into a <xref:System.DateTime> with a <xref:System.DateTimeKind> of <xref:System.DateTimeKind.Unspecified>.</span></span> <span data-ttu-id="38754-229">如需有關支援之方法的詳細資訊 <xref:System.DateTime?displayProperty=nameWithType> ，請參閱 System.string [方法](system-datetime-methods.md)。</span><span class="sxs-lookup"><span data-stu-id="38754-229">For more information about supported <xref:System.DateTime?displayProperty=nameWithType> methods, see [System.DateTime Methods](system-datetime-methods.md).</span></span>  
  
### <a name="systemtimespan"></a><span data-ttu-id="38754-230">System.TimeSpan</span><span class="sxs-lookup"><span data-stu-id="38754-230">System.TimeSpan</span></span>  
 <span data-ttu-id="38754-231">Microsoft SQL Server 2008 和 .NET Framework 3.5 SP1 可讓您將 CLR <xref:System.TimeSpan?displayProperty=nameWithType> 型別對應至 SQL Server `TIME` 型別。</span><span class="sxs-lookup"><span data-stu-id="38754-231">Microsoft SQL Server 2008 and the .NET Framework 3.5 SP1 let you map the CLR <xref:System.TimeSpan?displayProperty=nameWithType> type to the SQL Server `TIME` type.</span></span> <span data-ttu-id="38754-232">不過，CLR <xref:System.TimeSpan?displayProperty=nameWithType> 所支援的範圍與 SQL Server `TIME` 型別所支援的範圍之間具有大幅差異。</span><span class="sxs-lookup"><span data-stu-id="38754-232">However, there is a large difference between the range that the CLR <xref:System.TimeSpan?displayProperty=nameWithType> supports and what the SQL Server `TIME` type supports.</span></span> <span data-ttu-id="38754-233">將小於 0 或大於 23:59:59.9999999 小時的值對應至 SQL `TIME` 將會造成溢位的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="38754-233">Mapping values less than 0 or greater than 23:59:59.9999999 hours to the SQL `TIME` will result in overflow exceptions.</span></span> <span data-ttu-id="38754-234">如需詳細資訊，請參閱 [系統 TimeSpan 方法](system-timespan-methods.md)。</span><span class="sxs-lookup"><span data-stu-id="38754-234">For more information, see [System.TimeSpan Methods](system-timespan-methods.md).</span></span>  
  
 <span data-ttu-id="38754-235">在 Microsoft SQL Server 2000 和 SQL Server 2005 中，您無法將資料庫欄位對應至 <xref:System.TimeSpan>。</span><span class="sxs-lookup"><span data-stu-id="38754-235">In Microsoft SQL Server 2000 and SQL Server 2005, you cannot map database fields to <xref:System.TimeSpan>.</span></span> <span data-ttu-id="38754-236">但是，支援 <xref:System.TimeSpan> 的作業，因為 <xref:System.TimeSpan> 值可以從 <xref:System.DateTime> 減法傳回，或引進運算式中做為常值或繫結變數。</span><span class="sxs-lookup"><span data-stu-id="38754-236">However, operations on <xref:System.TimeSpan> are supported because <xref:System.TimeSpan> values can be returned from <xref:System.DateTime> subtraction or introduced into an expression as a literal or bound variable.</span></span>  
  
<a name="BinaryMapping"></a>
## <a name="binary-mapping"></a><span data-ttu-id="38754-237">二進位對應</span><span class="sxs-lookup"><span data-stu-id="38754-237">Binary Mapping</span></span>  
 <span data-ttu-id="38754-238">可對應至 CLR 型別 <xref:System.Data.Linq.Binary?displayProperty=nameWithType> 的 SQL Server 型別有許多種。</span><span class="sxs-lookup"><span data-stu-id="38754-238">There are many SQL Server types that can map to the CLR type <xref:System.Data.Linq.Binary?displayProperty=nameWithType>.</span></span> <span data-ttu-id="38754-239">下表顯示根據資料庫建置物件模型或外部對應檔案時，導致 O/R 設計工具和 SQLMetal 定義 CLR <xref:System.Data.Linq.Binary?displayProperty=nameWithType> 型別的 SQL Server 型別。</span><span class="sxs-lookup"><span data-stu-id="38754-239">The following table shows the SQL Server types that cause O/R Designer and SQLMetal to define a CLR <xref:System.Data.Linq.Binary?displayProperty=nameWithType> type when building an object model or external mapping file based on your database.</span></span>  
  
|<span data-ttu-id="38754-240">SQL Server 類型</span><span class="sxs-lookup"><span data-stu-id="38754-240">SQL Server Type</span></span>|<span data-ttu-id="38754-241">O/R 設計工具和 SQLMetal 所使用的預設 CLR 型別對應</span><span class="sxs-lookup"><span data-stu-id="38754-241">Default CLR Type mapping used by O/R Designer and SQLMetal</span></span>|  
|---------------------|-----------------------------------------------------------------|  
|`BINARY(50)`|<xref:System.Data.Linq.Binary?displayProperty=nameWithType>|  
|`VARBINARY(50)`|<xref:System.Data.Linq.Binary?displayProperty=nameWithType>|  
|`VARBINARY(MAX)`|<xref:System.Data.Linq.Binary?displayProperty=nameWithType>|  
|<span data-ttu-id="38754-242">`VARBINARY(MAX)` 使用 `FILESTREAM` 屬性</span><span class="sxs-lookup"><span data-stu-id="38754-242">`VARBINARY(MAX)` with the `FILESTREAM` attribute</span></span>|<xref:System.Data.Linq.Binary?displayProperty=nameWithType>|  
|`IMAGE`|<xref:System.Data.Linq.Binary?displayProperty=nameWithType>|  
|`TIMESTAMP`|<xref:System.Data.Linq.Binary?displayProperty=nameWithType>|  
  
 <span data-ttu-id="38754-243">下表顯示 <xref:System.Data.Linq.DataContext.CreateDatabase%2A?displayProperty=nameWithType> 方法用於定義建立哪些 SQL 資料行型別來對應至 CLR 型別 (定義於物件模型或外部對應檔案中) 的預設型別對應。</span><span class="sxs-lookup"><span data-stu-id="38754-243">The next table shows the default type mappings used by the <xref:System.Data.Linq.DataContext.CreateDatabase%2A?displayProperty=nameWithType> method to define which type of SQL columns are created to map to the CLR types defined in your object model or external mapping file.</span></span>  
  
|<span data-ttu-id="38754-244">CLR 型別</span><span class="sxs-lookup"><span data-stu-id="38754-244">CLR Type</span></span>|<span data-ttu-id="38754-245"><xref:System.Data.Linq.DataContext.CreateDatabase%2A?displayProperty=nameWithType> 所使用的預設 SQL Server 型別</span><span class="sxs-lookup"><span data-stu-id="38754-245">Default SQL Server Type used by <xref:System.Data.Linq.DataContext.CreateDatabase%2A?displayProperty=nameWithType></span></span>|  
|--------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|  
|<xref:System.Data.Linq.Binary?displayProperty=nameWithType>|`VARBINARY(MAX)`|  
|<xref:System.Byte?displayProperty=nameWithType>|`VARBINARY(MAX)`|  
|<xref:System.Runtime.Serialization.ISerializable?displayProperty=nameWithType>|`VARBINARY(MAX)`|  
  
 <span data-ttu-id="38754-246">雖然還有許多其他二進位對應可供您選擇，但是在資料庫之間來回轉譯時，某些對應可能會造成溢位或資料遺失的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="38754-246">There are many other binary mappings you can choose, but some may result in overflow or data loss exceptions while translating to or from the database.</span></span> <span data-ttu-id="38754-247">如需詳細資訊，請參閱 [類型對應執行時間行為矩陣](#BehaviorMatrix)。</span><span class="sxs-lookup"><span data-stu-id="38754-247">For more information, see the [Type Mapping Run Time Behavior Matrix](#BehaviorMatrix).</span></span>  
  
### <a name="sql-server-filestream"></a><span data-ttu-id="38754-248">SQL Server FILESTREAM</span><span class="sxs-lookup"><span data-stu-id="38754-248">SQL Server FILESTREAM</span></span>  
 <span data-ttu-id="38754-249">從 Microsoft SQL Server 2008 開始，就提供了 `FILESTREAM` 資料行的 `VARBINARY(MAX)` 屬性。從 .NET Framework 3.5 版 SP1 開始，您就可以透過 LINQ to SQL 對應至此屬性。</span><span class="sxs-lookup"><span data-stu-id="38754-249">The `FILESTREAM` attribute for `VARBINARY(MAX)` columns is available starting with Microsoft SQL Server 2008; you can map to it with LINQ to SQL starting with the .NET Framework version 3.5 SP1.</span></span>  
  
 <span data-ttu-id="38754-250">雖然您可以將具有 `VARBINARY(MAX)` 屬性的 `FILESTREAM` 資料行對應至 <xref:System.Data.Linq.Binary> 物件，但是 <xref:System.Data.Linq.DataContext.CreateDatabase%2A?displayProperty=nameWithType> 方法無法自動建立具有 `FILESTREAM` 屬性的資料行。</span><span class="sxs-lookup"><span data-stu-id="38754-250">Although you can map `VARBINARY(MAX)` columns with the `FILESTREAM` attribute to <xref:System.Data.Linq.Binary> objects, the <xref:System.Data.Linq.DataContext.CreateDatabase%2A?displayProperty=nameWithType> method is unable to automatically create columns with the `FILESTREAM` attribute.</span></span> <span data-ttu-id="38754-251">如需的詳細資訊 `FILESTREAM` ，請參閱 [FILESTREAM 總覽](/previous-versions/sql/sql-server-2008-r2/bb933993(v=sql.105))。</span><span class="sxs-lookup"><span data-stu-id="38754-251">For more information about `FILESTREAM`, see [FILESTREAM Overview](/previous-versions/sql/sql-server-2008-r2/bb933993(v=sql.105)).</span></span>  
  
<a name="BinarySerialization"></a>
### <a name="binary-serialization"></a><span data-ttu-id="38754-252">二進位序列化</span><span class="sxs-lookup"><span data-stu-id="38754-252">Binary Serialization</span></span>  
 <span data-ttu-id="38754-253">如果某個類別實作 <xref:System.Runtime.Serialization.ISerializable> 介面，您就可以將物件序列化成任何 SQL 二進位欄位 (`BINARY`、`VARBINARY` 或 `IMAGE`)。</span><span class="sxs-lookup"><span data-stu-id="38754-253">If a class implements the <xref:System.Runtime.Serialization.ISerializable> interface, you can serialize an object to any SQL binary field (`BINARY`, `VARBINARY`, `IMAGE`).</span></span> <span data-ttu-id="38754-254">此物件會根據 <xref:System.Runtime.Serialization.ISerializable> 介面的實作方式序列化和還原序列化。</span><span class="sxs-lookup"><span data-stu-id="38754-254">The object is serialized and deserialized according to how the <xref:System.Runtime.Serialization.ISerializable> interface is implemented.</span></span> <span data-ttu-id="38754-255">如需詳細資訊，請參閱 [二進位序列化](../../../../../standard/serialization/binary-serialization.md)。</span><span class="sxs-lookup"><span data-stu-id="38754-255">For more information, see [Binary Serialization](../../../../../standard/serialization/binary-serialization.md).</span></span>
  
<a name="MiscMapping"></a>
## <a name="miscellaneous-mapping"></a><span data-ttu-id="38754-256">其他對應</span><span class="sxs-lookup"><span data-stu-id="38754-256">Miscellaneous Mapping</span></span>  
 <span data-ttu-id="38754-257">下表顯示尚未提及之某些其他型別的預設型別對應。</span><span class="sxs-lookup"><span data-stu-id="38754-257">The following table shows the default type mappings for some miscellaneous types that have not yet been mentioned.</span></span> <span data-ttu-id="38754-258">下表顯示根據資料庫建置物件模型或外部對應檔案時，O/R 設計工具和 SQLMetal 所選取的 CLR 型別。</span><span class="sxs-lookup"><span data-stu-id="38754-258">The following table shows the CLR types that O/R Designer and SQLMetal select when building an object model or external mapping file based on your database.</span></span>  
  
|<span data-ttu-id="38754-259">SQL Server 類型</span><span class="sxs-lookup"><span data-stu-id="38754-259">SQL Server Type</span></span>|<span data-ttu-id="38754-260">O/R 設計工具和 SQLMetal 所使用的預設 CLR 型別對應</span><span class="sxs-lookup"><span data-stu-id="38754-260">Default CLR Type mapping used by O/R Designer and SQLMetal</span></span>|  
|---------------------|-----------------------------------------------------------------|  
|`UNIQUEIDENTIFIER`|<xref:System.Guid?displayProperty=nameWithType>|  
|`SQL_VARIANT`|<xref:System.Object?displayProperty=nameWithType>|  
  
 <span data-ttu-id="38754-261">下表顯示 <xref:System.Data.Linq.DataContext.CreateDatabase%2A?displayProperty=nameWithType> 方法用於定義建立哪些 SQL 資料行型別來對應至 CLR 型別 (定義於物件模型或外部對應檔案中) 的預設型別對應。</span><span class="sxs-lookup"><span data-stu-id="38754-261">The next table shows the default type mappings used by the <xref:System.Data.Linq.DataContext.CreateDatabase%2A?displayProperty=nameWithType> method to define which type of SQL columns are created to map to the CLR types defined in your object model or external mapping file.</span></span>  
  
|<span data-ttu-id="38754-262">CLR 型別</span><span class="sxs-lookup"><span data-stu-id="38754-262">CLR Type</span></span>|<span data-ttu-id="38754-263"><xref:System.Data.Linq.DataContext.CreateDatabase%2A?displayProperty=nameWithType> 所使用的預設 SQL Server 型別</span><span class="sxs-lookup"><span data-stu-id="38754-263">Default SQL Server Type used by <xref:System.Data.Linq.DataContext.CreateDatabase%2A?displayProperty=nameWithType></span></span>|  
|--------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|  
|<xref:System.Guid?displayProperty=nameWithType>|`UNIQUEIDENTIFIER`|  
|<xref:System.Object?displayProperty=nameWithType>|`SQL_VARIANT`|  
  
 <span data-ttu-id="38754-264">LINQ to SQL 不支援這些其他型別的任何其他型別對應。</span><span class="sxs-lookup"><span data-stu-id="38754-264">LINQ to SQL does not support any other type mappings for these miscellaneous types.</span></span>  <span data-ttu-id="38754-265">如需詳細資訊，請參閱 [類型對應執行時間行為矩陣](#BehaviorMatrix)。</span><span class="sxs-lookup"><span data-stu-id="38754-265">For more information, see the [Type Mapping Run Time Behavior Matrix](#BehaviorMatrix).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="38754-266">另請參閱</span><span class="sxs-lookup"><span data-stu-id="38754-266">See also</span></span>

- [<span data-ttu-id="38754-267">屬性架構對應</span><span class="sxs-lookup"><span data-stu-id="38754-267">Attribute-Based Mapping</span></span>](attribute-based-mapping.md)
- [<span data-ttu-id="38754-268">外部對應</span><span class="sxs-lookup"><span data-stu-id="38754-268">External Mapping</span></span>](external-mapping.md)
- [<span data-ttu-id="38754-269">資料類型與函式</span><span class="sxs-lookup"><span data-stu-id="38754-269">Data Types and Functions</span></span>](data-types-and-functions.md)
- [<span data-ttu-id="38754-270">SQL-CLR 類型不符</span><span class="sxs-lookup"><span data-stu-id="38754-270">SQL-CLR Type Mismatches</span></span>](sql-clr-type-mismatches.md)
