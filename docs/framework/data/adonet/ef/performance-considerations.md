---
title: 效能考量 (Entity Framework)
description: 瞭解 ADO.NET Entity Framework 的效能特性，以及協助改善 Entity Framework 應用程式效能的考慮。
ms.date: 03/30/2017
ms.assetid: 61913f3b-4f42-4d9b-810f-2a13c2388a4a
ms.openlocfilehash: 2bdf088309dd178c1eef4cfb0b7e093b1f6be606
ms.sourcegitcommit: 27a15a55019f6b5f2733961738babe94aec0def3
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 09/15/2020
ms.locfileid: "90557459"
---
# <a name="performance-considerations-entity-framework"></a><span data-ttu-id="c852d-103">效能考量 (Entity Framework)</span><span class="sxs-lookup"><span data-stu-id="c852d-103">Performance Considerations (Entity Framework)</span></span>
<span data-ttu-id="c852d-104">本主題說明 ADO.NET Entity Framework 的效能特性，並提供一些考量因素以協助提升 Entity Framework 應用程式的效能。</span><span class="sxs-lookup"><span data-stu-id="c852d-104">This topic describes performance characteristics of the ADO.NET Entity Framework and provides some considerations to help improve the performance of Entity Framework applications.</span></span>  
  
## <a name="stages-of-query-execution"></a><span data-ttu-id="c852d-105">查詢執行的階段</span><span class="sxs-lookup"><span data-stu-id="c852d-105">Stages of Query Execution</span></span>  
 <span data-ttu-id="c852d-106">為進一步了解 Entity Framework 中的查詢效能，了解針對概念模型執行查詢並傳回資料做為物件時發生的作業，對您有所幫助。</span><span class="sxs-lookup"><span data-stu-id="c852d-106">In order to better understand the performance of queries in the Entity Framework, it is helpful to understand the operations that occur when a query executes against a conceptual model and returns data as objects.</span></span> <span data-ttu-id="c852d-107">以下資料表說明這一系列的作業。</span><span class="sxs-lookup"><span data-stu-id="c852d-107">The following table describes this series of operations.</span></span>  
  
|<span data-ttu-id="c852d-108">作業</span><span class="sxs-lookup"><span data-stu-id="c852d-108">Operation</span></span>|<span data-ttu-id="c852d-109">相對成本</span><span class="sxs-lookup"><span data-stu-id="c852d-109">Relative Cost</span></span>|<span data-ttu-id="c852d-110">頻率</span><span class="sxs-lookup"><span data-stu-id="c852d-110">Frequency</span></span>|<span data-ttu-id="c852d-111">註解</span><span class="sxs-lookup"><span data-stu-id="c852d-111">Comments</span></span>|  
|---------------|-------------------|---------------|--------------|  
|<span data-ttu-id="c852d-112">載入中繼資料</span><span class="sxs-lookup"><span data-stu-id="c852d-112">Loading metadata</span></span>|<span data-ttu-id="c852d-113">中</span><span class="sxs-lookup"><span data-stu-id="c852d-113">Moderate</span></span>|<span data-ttu-id="c852d-114">在每個應用程式定義域中執行一次。</span><span class="sxs-lookup"><span data-stu-id="c852d-114">Once in each application domain.</span></span>|<span data-ttu-id="c852d-115">Entity Framework 使用的模型和對應中繼資料會載入至 <xref:System.Data.Metadata.Edm.MetadataWorkspace>。</span><span class="sxs-lookup"><span data-stu-id="c852d-115">Model and mapping metadata used by the Entity Framework is loaded into a <xref:System.Data.Metadata.Edm.MetadataWorkspace>.</span></span> <span data-ttu-id="c852d-116">這個中繼資料會在全域中作快取，並在相同的應用程式定義域中，提供給其他 <xref:System.Data.Objects.ObjectContext> 執行個體使用。</span><span class="sxs-lookup"><span data-stu-id="c852d-116">This metadata is cached globally and is available to other instances of <xref:System.Data.Objects.ObjectContext> in the same application domain.</span></span>|  
|<span data-ttu-id="c852d-117">開啟資料庫連接</span><span class="sxs-lookup"><span data-stu-id="c852d-117">Opening the database connection</span></span>|<span data-ttu-id="c852d-118">適中<sup>1</sup></span><span class="sxs-lookup"><span data-stu-id="c852d-118">Moderate<sup>1</sup></span></span>|<span data-ttu-id="c852d-119">需要時。</span><span class="sxs-lookup"><span data-stu-id="c852d-119">As needed.</span></span>|<span data-ttu-id="c852d-120">因為對資料庫的開啟連接會耗用寶貴的資源，Entity Framework 只會在需要時開啟和關閉資料庫連接。</span><span class="sxs-lookup"><span data-stu-id="c852d-120">Because an open connection to the database consumes a valuable resource, the Entity Framework opens and closes the database connection only as needed.</span></span> <span data-ttu-id="c852d-121">您也可以明確開啟連接。</span><span class="sxs-lookup"><span data-stu-id="c852d-121">You can also explicitly open the connection.</span></span> <span data-ttu-id="c852d-122">如需詳細資訊，請參閱 [管理連接和交易](/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100))。</span><span class="sxs-lookup"><span data-stu-id="c852d-122">For more information, see [Managing Connections and Transactions](/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span></span>|  
|<span data-ttu-id="c852d-123">產生檢視</span><span class="sxs-lookup"><span data-stu-id="c852d-123">Generating views</span></span>|<span data-ttu-id="c852d-124">高</span><span class="sxs-lookup"><span data-stu-id="c852d-124">High</span></span>|<span data-ttu-id="c852d-125">在每個應用程式定義域中執行一次。</span><span class="sxs-lookup"><span data-stu-id="c852d-125">Once in each application domain.</span></span> <span data-ttu-id="c852d-126">(可以預先產生。)</span><span class="sxs-lookup"><span data-stu-id="c852d-126">(Can be pre-generated.)</span></span>|<span data-ttu-id="c852d-127">在 Entity Framework 可以針對概念模型執行查詢，或儲存變更至資料來源之前，Entity Framework 必須產生本地查詢檢視集，才能存取資料庫。</span><span class="sxs-lookup"><span data-stu-id="c852d-127">Before the Entity Framework can execute a query against a conceptual model or save changes to the data source, it must generate a set of local query views to access the database.</span></span> <span data-ttu-id="c852d-128">由於產生這些檢視的成本很高，您可以預先產生檢視，在設計階段就把這些檢視加入至專案。</span><span class="sxs-lookup"><span data-stu-id="c852d-128">Because of the high cost of generating these views, you can pre-generate the views and add them to the project at design-time.</span></span> <span data-ttu-id="c852d-129">如需詳細資訊，請參閱 [如何：預先產生視圖，以改善查詢效能](/previous-versions/dotnet/netframework-4.0/bb896240(v=vs.100))。</span><span class="sxs-lookup"><span data-stu-id="c852d-129">For more information, see [How to: Pre-Generate Views to Improve Query Performance](/previous-versions/dotnet/netframework-4.0/bb896240(v=vs.100)).</span></span>|  
|<span data-ttu-id="c852d-130">準備查詢</span><span class="sxs-lookup"><span data-stu-id="c852d-130">Preparing the query</span></span>|<span data-ttu-id="c852d-131">中等<sup>2</sup></span><span class="sxs-lookup"><span data-stu-id="c852d-131">Moderate<sup>2</sup></span></span>|<span data-ttu-id="c852d-132">針對每個唯一查詢執行一次。</span><span class="sxs-lookup"><span data-stu-id="c852d-132">Once for each unique query.</span></span>|<span data-ttu-id="c852d-133">包括組成查詢命令、根據模型和對應的中繼資料產生命令樹，以及定義傳回資料的形式等成本。</span><span class="sxs-lookup"><span data-stu-id="c852d-133">Includes the costs to compose the query command, generate a command tree based on model and mapping metadata, and define the shape of the returned data.</span></span> <span data-ttu-id="c852d-134">由於現在會快取 Entity SQL 查詢命令和 LINQ 查詢，因此後續執行相同查詢時可減少些許時間。</span><span class="sxs-lookup"><span data-stu-id="c852d-134">Because now both Entity SQL query commands and LINQ queries are cached, later executions of the same query take less time.</span></span> <span data-ttu-id="c852d-135">之後執行時您仍可以使用已編譯的 LINQ 查詢減少這種成本，且已編譯查詢可能比自動快取的 LINQ 查詢更有效率。</span><span class="sxs-lookup"><span data-stu-id="c852d-135">You can still use compiled LINQ queries to reduce this cost in later executions and compiled queries can be more efficient than LINQ queries that are automatically cached.</span></span> <span data-ttu-id="c852d-136">如需詳細資訊，請參閱 [ (LINQ to Entities) 的已編譯查詢 ](./language-reference/compiled-queries-linq-to-entities.md)。</span><span class="sxs-lookup"><span data-stu-id="c852d-136">For more information, see [Compiled Queries  (LINQ to Entities)](./language-reference/compiled-queries-linq-to-entities.md).</span></span> <span data-ttu-id="c852d-137">如需 LINQ 查詢執行的一般資訊，請參閱 [LINQ to Entities](./language-reference/linq-to-entities.md)。</span><span class="sxs-lookup"><span data-stu-id="c852d-137">For general information about LINQ query execution, see [LINQ to Entities](./language-reference/linq-to-entities.md).</span></span> <span data-ttu-id="c852d-138">**注意：** `Enumerable.Contains` 不會自動快取將運算子套用至記憶體中集合的 LINQ to Entities 查詢。</span><span class="sxs-lookup"><span data-stu-id="c852d-138">**Note:**  LINQ to Entities queries that apply the `Enumerable.Contains` operator to in-memory collections are not automatically cached.</span></span> <span data-ttu-id="c852d-139">此外也不允許在已編譯的 LINQ 查詢中參數化記憶體中的集合。</span><span class="sxs-lookup"><span data-stu-id="c852d-139">Also parameterizing in-memory collections in compiled LINQ queries is not allowed.</span></span>|  
|<span data-ttu-id="c852d-140">執行查詢</span><span class="sxs-lookup"><span data-stu-id="c852d-140">Executing the query</span></span>|<span data-ttu-id="c852d-141">低<sup>2</sup></span><span class="sxs-lookup"><span data-stu-id="c852d-141">Low<sup>2</sup></span></span>|<span data-ttu-id="c852d-142">針對每個查詢執行一次。</span><span class="sxs-lookup"><span data-stu-id="c852d-142">Once for each query.</span></span>|<span data-ttu-id="c852d-143">使用 ADO.NET 資料提供者，針對資料來源執行命令的成本。</span><span class="sxs-lookup"><span data-stu-id="c852d-143">The cost of executing the command against the data source by using the ADO.NET data provider.</span></span> <span data-ttu-id="c852d-144">由於大部分的資料來源都會對查詢計畫作快取，後續執行相同查詢命令可能會減少些許時間。</span><span class="sxs-lookup"><span data-stu-id="c852d-144">Because most data sources cache query plans, later executions of the same query may take even less time.</span></span>|  
|<span data-ttu-id="c852d-145">載入和使用型別</span><span class="sxs-lookup"><span data-stu-id="c852d-145">Loading and validating types</span></span>|<span data-ttu-id="c852d-146">低<sup>3</sup></span><span class="sxs-lookup"><span data-stu-id="c852d-146">Low<sup>3</sup></span></span>|<span data-ttu-id="c852d-147">針對每個 <xref:System.Data.Objects.ObjectContext> 執行個體執行一次。</span><span class="sxs-lookup"><span data-stu-id="c852d-147">Once for each <xref:System.Data.Objects.ObjectContext> instance.</span></span>|<span data-ttu-id="c852d-148">載入型別，並針對概念模型定義的型別進行驗證。</span><span class="sxs-lookup"><span data-stu-id="c852d-148">Types are loaded and validated against the types that the conceptual model defines.</span></span>|  
|<span data-ttu-id="c852d-149">追蹤</span><span class="sxs-lookup"><span data-stu-id="c852d-149">Tracking</span></span>|<span data-ttu-id="c852d-150">低<sup>3</sup></span><span class="sxs-lookup"><span data-stu-id="c852d-150">Low<sup>3</sup></span></span>|<span data-ttu-id="c852d-151">針對每個查詢傳回的物件執行一次。</span><span class="sxs-lookup"><span data-stu-id="c852d-151">Once for each object that a query returns.</span></span> <span data-ttu-id="c852d-152"><sup>4</sup></span><span class="sxs-lookup"><span data-stu-id="c852d-152"><sup>4</sup></span></span>|<span data-ttu-id="c852d-153">如果查詢使用 <xref:System.Data.Objects.MergeOption.NoTracking> 合併選項，這個階段不會影響效能。</span><span class="sxs-lookup"><span data-stu-id="c852d-153">If a query uses the <xref:System.Data.Objects.MergeOption.NoTracking> merge option, this stage does not affect performance.</span></span><br /><br /> <span data-ttu-id="c852d-154">如果查詢使用 <xref:System.Data.Objects.MergeOption.AppendOnly>、<xref:System.Data.Objects.MergeOption.PreserveChanges> 或 <xref:System.Data.Objects.MergeOption.OverwriteChanges> 合併選項，會在 <xref:System.Data.Objects.ObjectStateManager> 中追蹤查詢結果。</span><span class="sxs-lookup"><span data-stu-id="c852d-154">If the query uses the <xref:System.Data.Objects.MergeOption.AppendOnly>, <xref:System.Data.Objects.MergeOption.PreserveChanges>, or <xref:System.Data.Objects.MergeOption.OverwriteChanges> merge option, query results are tracked in the <xref:System.Data.Objects.ObjectStateManager>.</span></span> <span data-ttu-id="c852d-155">針對查詢傳回的每一個已追蹤物件產生 <xref:System.Data.EntityKey>，並用來建立 <xref:System.Data.Objects.ObjectStateEntry> 中的 <xref:System.Data.Objects.ObjectStateManager>。</span><span class="sxs-lookup"><span data-stu-id="c852d-155">An <xref:System.Data.EntityKey> is generated for each tracked object that the query returns and is used to create an <xref:System.Data.Objects.ObjectStateEntry> in the <xref:System.Data.Objects.ObjectStateManager>.</span></span> <span data-ttu-id="c852d-156">如果可以針對 <xref:System.Data.Objects.ObjectStateEntry>，找到現有的 <xref:System.Data.EntityKey>，則會回傳現有的物件。</span><span class="sxs-lookup"><span data-stu-id="c852d-156">If an existing <xref:System.Data.Objects.ObjectStateEntry> can be found for the <xref:System.Data.EntityKey>, the existing object is returned.</span></span> <span data-ttu-id="c852d-157">如果使用 <xref:System.Data.Objects.MergeOption.PreserveChanges> 或 <xref:System.Data.Objects.MergeOption.OverwriteChanges> 選項，傳回前會先更新物件。</span><span class="sxs-lookup"><span data-stu-id="c852d-157">If the <xref:System.Data.Objects.MergeOption.PreserveChanges>, or <xref:System.Data.Objects.MergeOption.OverwriteChanges> option is used, the object is updated before it is returned.</span></span><br /><br /> <span data-ttu-id="c852d-158">如需詳細資訊，請參閱 [識別解析、狀態管理及變更追蹤](/previous-versions/dotnet/netframework-4.0/bb896269(v=vs.100))。</span><span class="sxs-lookup"><span data-stu-id="c852d-158">For more information, see [Identity Resolution, State Management, and Change Tracking](/previous-versions/dotnet/netframework-4.0/bb896269(v=vs.100)).</span></span>|  
|<span data-ttu-id="c852d-159">具體化物件</span><span class="sxs-lookup"><span data-stu-id="c852d-159">Materializing the objects</span></span>|<span data-ttu-id="c852d-160">適中<sup>3</sup></span><span class="sxs-lookup"><span data-stu-id="c852d-160">Moderate<sup>3</sup></span></span>|<span data-ttu-id="c852d-161">針對每個查詢傳回的物件執行一次。</span><span class="sxs-lookup"><span data-stu-id="c852d-161">Once for each object that a query returns.</span></span> <span data-ttu-id="c852d-162"><sup>4</sup></span><span class="sxs-lookup"><span data-stu-id="c852d-162"><sup>4</sup></span></span>|<span data-ttu-id="c852d-163">讀取傳回之 <xref:System.Data.Common.DbDataReader> 物件、建立物件和設定屬性值的程序，是根據 <xref:System.Data.Common.DbDataRecord> 類別之每一個執行個體上的值。</span><span class="sxs-lookup"><span data-stu-id="c852d-163">The process of reading the returned <xref:System.Data.Common.DbDataReader> object and creating objects and setting property values that are based on the values in each instance of the <xref:System.Data.Common.DbDataRecord> class.</span></span> <span data-ttu-id="c852d-164">如果物件已於 <xref:System.Data.Objects.ObjectContext> 中存在，且查詢使用 <xref:System.Data.Objects.MergeOption.AppendOnly> 或 <xref:System.Data.Objects.MergeOption.PreserveChanges> 合併選項，則這個階段不會影響效能。</span><span class="sxs-lookup"><span data-stu-id="c852d-164">If the object already exists in the <xref:System.Data.Objects.ObjectContext> and the query uses the <xref:System.Data.Objects.MergeOption.AppendOnly> or <xref:System.Data.Objects.MergeOption.PreserveChanges> merge options, this stage does not affect performance.</span></span> <span data-ttu-id="c852d-165">如需詳細資訊，請參閱 [識別解析、狀態管理及變更追蹤](/previous-versions/dotnet/netframework-4.0/bb896269(v=vs.100))。</span><span class="sxs-lookup"><span data-stu-id="c852d-165">For more information, see [Identity Resolution, State Management, and Change Tracking](/previous-versions/dotnet/netframework-4.0/bb896269(v=vs.100)).</span></span>|  
  
 <span data-ttu-id="c852d-166"><sup>1</sup> 當資料來源提供者執行連接共用時，開啟連接的成本會分散到集區。</span><span class="sxs-lookup"><span data-stu-id="c852d-166"><sup>1</sup> When a data source provider implements connection pooling, the cost of opening a connection is distributed across the pool.</span></span> <span data-ttu-id="c852d-167">SQL Server 的 .NET 提供者支援連接共用。</span><span class="sxs-lookup"><span data-stu-id="c852d-167">The .NET Provider for SQL Server supports connection pooling.</span></span>  
  
 <span data-ttu-id="c852d-168"><sup>2</sup> 成本會隨著查詢複雜度增加而增加。</span><span class="sxs-lookup"><span data-stu-id="c852d-168"><sup>2</sup> Cost increases with increased query complexity.</span></span>  
  
 <span data-ttu-id="c852d-169"><sup>3</sup> 總成本會隨著查詢所傳回的物件數目比例增加。</span><span class="sxs-lookup"><span data-stu-id="c852d-169"><sup>3</sup> Total cost increases proportional to the number of objects returned by the query.</span></span>  
  
 <span data-ttu-id="c852d-170"><sup>4</sup> EntityClient 查詢不需要此額外負荷，因為 EntityClient 查詢會傳回 <xref:System.Data.EntityClient.EntityDataReader> 而非物件。</span><span class="sxs-lookup"><span data-stu-id="c852d-170"><sup>4</sup> This overhead is not required for EntityClient queries because EntityClient queries return an <xref:System.Data.EntityClient.EntityDataReader> instead of objects.</span></span> <span data-ttu-id="c852d-171">如需詳細資訊，請參閱 [適用於 Entity Framework 的 EntityClient 提供者](entityclient-provider-for-the-entity-framework.md)。</span><span class="sxs-lookup"><span data-stu-id="c852d-171">For more information, see [EntityClient Provider for the Entity Framework](entityclient-provider-for-the-entity-framework.md).</span></span>  
  
## <a name="additional-considerations"></a><span data-ttu-id="c852d-172">其他考量</span><span class="sxs-lookup"><span data-stu-id="c852d-172">Additional Considerations</span></span>  
 <span data-ttu-id="c852d-173">下列其他考量可能會影響 Entity Framework 應用程式的效能。</span><span class="sxs-lookup"><span data-stu-id="c852d-173">The following are other considerations that may affect the performance of Entity Framework applications.</span></span>  
  
### <a name="query-execution"></a><span data-ttu-id="c852d-174">查詢執行</span><span class="sxs-lookup"><span data-stu-id="c852d-174">Query Execution</span></span>  
 <span data-ttu-id="c852d-175">由於查詢可能會耗用資源，請考量查詢在程式碼裡的執行點，以及在哪部電腦上執行。</span><span class="sxs-lookup"><span data-stu-id="c852d-175">Because queries can be resource intensive, consider at what point in your code and on what computer a query is executed.</span></span>  
  
#### <a name="deferred-versus-immediate-execution"></a><span data-ttu-id="c852d-176">延後執行與立即執行</span><span class="sxs-lookup"><span data-stu-id="c852d-176">Deferred versus immediate execution</span></span>  
 <span data-ttu-id="c852d-177">建立 <xref:System.Data.Objects.ObjectQuery%601> 或 LINQ 查詢時，可能不會立即執行查詢。</span><span class="sxs-lookup"><span data-stu-id="c852d-177">When you create an <xref:System.Data.Objects.ObjectQuery%601> or LINQ query, the query may not be executed immediately.</span></span> <span data-ttu-id="c852d-178">查詢執行會延後，直到需要結果時才執行，例如在 `foreach` (C#) 或 `For Each` (Visual Basic) 列舉期間，或指定填滿 <xref:System.Collections.Generic.List%601> 集合時。</span><span class="sxs-lookup"><span data-stu-id="c852d-178">Query execution is deferred until the results are needed, such as during a `foreach` (C#) or `For Each` (Visual Basic) enumeration or when it is assigned to fill a <xref:System.Collections.Generic.List%601> collection.</span></span> <span data-ttu-id="c852d-179">呼叫 <xref:System.Data.Objects.ObjectQuery%601.Execute%2A> 上的 <xref:System.Data.Objects.ObjectQuery%601> 方法，或呼叫會傳回單一查詢的 LINQ 方法 (例如 <xref:System.Linq.Enumerable.First%2A> 或 <xref:System.Linq.Enumerable.Any%2A>) 時，會立即開始執行查詢。</span><span class="sxs-lookup"><span data-stu-id="c852d-179">Query execution begins immediately when you call the <xref:System.Data.Objects.ObjectQuery%601.Execute%2A> method on an <xref:System.Data.Objects.ObjectQuery%601> or when you call a LINQ method that returns a singleton query, such as <xref:System.Linq.Enumerable.First%2A> or <xref:System.Linq.Enumerable.Any%2A>.</span></span> <span data-ttu-id="c852d-180">如需詳細資訊，請參閱[ (LINQ to Entities) ](./language-reference/query-execution.md)的[物件查詢](/previous-versions/dotnet/netframework-4.0/bb896241(v=vs.100))和查詢執行。</span><span class="sxs-lookup"><span data-stu-id="c852d-180">For more information, see [Object Queries](/previous-versions/dotnet/netframework-4.0/bb896241(v=vs.100)) and [Query Execution (LINQ to Entities)](./language-reference/query-execution.md).</span></span>  
  
#### <a name="client-side-execution-of-linq-queries"></a><span data-ttu-id="c852d-181">LINQ 查詢的用戶端執行</span><span class="sxs-lookup"><span data-stu-id="c852d-181">Client-side execution of LINQ queries</span></span>  
 <span data-ttu-id="c852d-182">雖然 LINQ 查詢的執行會發生在裝載資料來源的電腦上，一個 LINQ 查詢中的某些部分可以在用戶端電腦上進行評估。</span><span class="sxs-lookup"><span data-stu-id="c852d-182">Although the execution of a LINQ query occurs on the computer that hosts the data source, some parts of a LINQ query may be evaluated on the client computer.</span></span> <span data-ttu-id="c852d-183">如需詳細資訊，請參閱 [ (LINQ to Entities) 的「查詢執行 ](./language-reference/query-execution.md)的儲存執行」區段。</span><span class="sxs-lookup"><span data-stu-id="c852d-183">For more information, see the Store Execution section of [Query Execution (LINQ to Entities)](./language-reference/query-execution.md).</span></span>  
  
### <a name="query-and-mapping-complexity"></a><span data-ttu-id="c852d-184">查詢和對應複雜度</span><span class="sxs-lookup"><span data-stu-id="c852d-184">Query and Mapping Complexity</span></span>  
 <span data-ttu-id="c852d-185">在實體模型中，個別查詢和對應的複雜度對於查詢的效能有重大影響。</span><span class="sxs-lookup"><span data-stu-id="c852d-185">The complexity of individual queries and of the mapping in the entity model will have a significant effect on query performance.</span></span>  
  
#### <a name="mapping-complexity"></a><span data-ttu-id="c852d-186">對應複雜度</span><span class="sxs-lookup"><span data-stu-id="c852d-186">Mapping complexity</span></span>  
 <span data-ttu-id="c852d-187">在概念模型中的實體以及儲存體模型中的資料表之間，擁有比簡單的一對一對應更複雜的模型，因此，所產生的命令比擁有一對一對應的模型更複雜。</span><span class="sxs-lookup"><span data-stu-id="c852d-187">Models that are more complex than a simple one-to-one mapping between entities in the conceptual model and tables in the storage model generate more complex commands than models that have a one-to-one mapping.</span></span>  
  
#### <a name="query-complexity"></a><span data-ttu-id="c852d-188">查詢複雜度</span><span class="sxs-lookup"><span data-stu-id="c852d-188">Query complexity</span></span>  
 <span data-ttu-id="c852d-189">在命令中需要大量聯結的查詢會針對資料來源進行執行，否則傳回的大量資料可能會以下列方式影響效能：</span><span class="sxs-lookup"><span data-stu-id="c852d-189">Queries that require a large number of joins in the commands that are executed against the data source or that return a large amount of data may affect performance in the following ways:</span></span>  
  
- <span data-ttu-id="c852d-190">針對概念模型進行的查詢看似簡單，但可能會導致針對資料來源執行更複雜的查詢。</span><span class="sxs-lookup"><span data-stu-id="c852d-190">Queries against a conceptual model that seem simple may result in the execution of more complex queries against the data source.</span></span> <span data-ttu-id="c852d-191">發生這個問題的原因是 Entity Framework 會將針對概念模型的查詢轉譯為針對資料來源的同等查詢。</span><span class="sxs-lookup"><span data-stu-id="c852d-191">This can occur because the Entity Framework translates a query against a conceptual model into an equivalent query against the data source.</span></span> <span data-ttu-id="c852d-192">當概念模型中的單一實體集對應至資料來源中一個以上的資料表，或當實體之間的關聯性對應至聯結資料表時，針對資料來源查詢執行的查詢命令可能需要一個以上的聯結。</span><span class="sxs-lookup"><span data-stu-id="c852d-192">When a single entity set in the conceptual model maps to more than one table in the data source, or when a relationship between entities is mapped to a join table, the query command executed against the data source query may require one or more joins.</span></span>  
  
    > [!NOTE]
    > <span data-ttu-id="c852d-193">請使用 <xref:System.Data.Objects.ObjectQuery.ToTraceString%2A> 的 <xref:System.Data.Objects.ObjectQuery%601> 方法或 <xref:System.Data.EntityClient.EntityCommand> 類別，檢視針對資料來源而執行之指定查詢的命令。</span><span class="sxs-lookup"><span data-stu-id="c852d-193">Use the <xref:System.Data.Objects.ObjectQuery.ToTraceString%2A> method of the <xref:System.Data.Objects.ObjectQuery%601> or <xref:System.Data.EntityClient.EntityCommand> classes to view the commands that are executed against the data source for a given query.</span></span> <span data-ttu-id="c852d-194">如需詳細資訊，請參閱 [如何：查看存放區命令](/previous-versions/dotnet/netframework-4.0/bb896348(v=vs.100))。</span><span class="sxs-lookup"><span data-stu-id="c852d-194">For more information, see [How to: View the Store Commands](/previous-versions/dotnet/netframework-4.0/bb896348(v=vs.100)).</span></span>  
  
- <span data-ttu-id="c852d-195">巢狀 Entity SQL 查詢可在伺服器上建立聯結，並傳回大量資料列。</span><span class="sxs-lookup"><span data-stu-id="c852d-195">Nested Entity SQL queries may create joins on the server and can return a large number of rows.</span></span>  
  
     <span data-ttu-id="c852d-196">下列是投影子句中巢狀查詢的範例：</span><span class="sxs-lookup"><span data-stu-id="c852d-196">The following is an example of a nested query in a projection clause:</span></span>  
  
    ```sql  
    SELECT c, (SELECT c, (SELECT c FROM AdventureWorksModel.Vendor AS c  ) As Inner2
        FROM AdventureWorksModel.JobCandidate AS c  ) As Inner1
        FROM AdventureWorksModel.EmployeeDepartmentHistory AS c  
    ```  
  
     <span data-ttu-id="c852d-197">此外，這類查詢會使查詢管線產生單一查詢，並重複跨巢狀查詢的物件。</span><span class="sxs-lookup"><span data-stu-id="c852d-197">In addition, such queries cause the query pipeline to generate a single query with duplication of objects across nested queries.</span></span> <span data-ttu-id="c852d-198">因此，單一資料行可能會重複多次。</span><span class="sxs-lookup"><span data-stu-id="c852d-198">Because of this, a single column may be duplicated multiple times.</span></span> <span data-ttu-id="c852d-199">在某些些資料庫上 (包括 SQL Server)，這個工作會使 TempDB 資料表變得非常大，降低伺服器的效能。</span><span class="sxs-lookup"><span data-stu-id="c852d-199">On some databases, including SQL Server, this can cause the TempDB table to grow very large, which can decrease server performance.</span></span> <span data-ttu-id="c852d-200">您執行巢狀查詢時應特別注意。</span><span class="sxs-lookup"><span data-stu-id="c852d-200">Care should be taken when you execute nested queries.</span></span>  
  
- <span data-ttu-id="c852d-201">如果用戶端正在執行耗用資源與結果集大小成正比的作業，任何傳回大量資料的查詢可能會使效能降低。</span><span class="sxs-lookup"><span data-stu-id="c852d-201">Any queries that return a large amount of data can cause decreased performance if the client is performing operations that consume resources in a way that is proportional to the size of the result set.</span></span> <span data-ttu-id="c852d-202">在這種情況下，您應該考慮依查詢限制傳回的資料量。</span><span class="sxs-lookup"><span data-stu-id="c852d-202">In such cases, you should consider limiting the amount of data returned by the query.</span></span> <span data-ttu-id="c852d-203">如需詳細資訊，請參閱 [如何：逐頁查看查詢結果](/previous-versions/dotnet/netframework-4.0/bb738702(v=vs.100))。</span><span class="sxs-lookup"><span data-stu-id="c852d-203">For more information, see [How to: Page Through Query Results](/previous-versions/dotnet/netframework-4.0/bb738702(v=vs.100)).</span></span>  
  
 <span data-ttu-id="c852d-204">由 Entity Framework 自動產生的任何命令，會比由資料庫開發人員明確撰寫的類似命令更為複雜。</span><span class="sxs-lookup"><span data-stu-id="c852d-204">Any commands automatically generated by the Entity Framework may be more complex than similar commands written explicitly by a database developer.</span></span> <span data-ttu-id="c852d-205">如果您需要明確控制針對資料來源執行的命令，請考慮資料表值函式的對應或預存程序。</span><span class="sxs-lookup"><span data-stu-id="c852d-205">If you need explicit control over the commands executed against your data source, consider defining a mapping to a table-valued function or stored procedure.</span></span>  
  
#### <a name="relationships"></a><span data-ttu-id="c852d-206">關聯性</span><span class="sxs-lookup"><span data-stu-id="c852d-206">Relationships</span></span>  
 <span data-ttu-id="c852d-207">為最佳化查詢效能，您必須定義實體 (作為實體模型中的關聯和資料來源中的邏輯關聯性) 之間的關聯性，。</span><span class="sxs-lookup"><span data-stu-id="c852d-207">For optimal query performance, you must define relationships between entities both as associations in the entity model and as logical relationships in the data source.</span></span>  
  
### <a name="query-paths"></a><span data-ttu-id="c852d-208">查詢路徑</span><span class="sxs-lookup"><span data-stu-id="c852d-208">Query Paths</span></span>  
 <span data-ttu-id="c852d-209">根據預設，執行 <xref:System.Data.Objects.ObjectQuery%601> 時，不會傳回相關物件 (即使物件表示關聯性本身)。</span><span class="sxs-lookup"><span data-stu-id="c852d-209">By default, when you execute an <xref:System.Data.Objects.ObjectQuery%601>, related objects are not returned (although objects that represent the relationships themselves are).</span></span> <span data-ttu-id="c852d-210">您可以利用下列三種方法中的任何一種方式載入相關物件：</span><span class="sxs-lookup"><span data-stu-id="c852d-210">You can load related objects in one of three ways:</span></span>  
  
1. <span data-ttu-id="c852d-211">在執行 <xref:System.Data.Objects.ObjectQuery%601> 之前設定查詢路徑。</span><span class="sxs-lookup"><span data-stu-id="c852d-211">Set the query path before the <xref:System.Data.Objects.ObjectQuery%601> is executed.</span></span>  
  
2. <span data-ttu-id="c852d-212">在物件公開的導覽屬性上呼叫 `Load` 方法。</span><span class="sxs-lookup"><span data-stu-id="c852d-212">Call the `Load` method on the navigation property that the object exposes.</span></span>  
  
3. <span data-ttu-id="c852d-213">將 <xref:System.Data.Objects.ObjectContextOptions.LazyLoadingEnabled%2A> 上的 <xref:System.Data.Objects.ObjectContext> 選項設定為 `true`。</span><span class="sxs-lookup"><span data-stu-id="c852d-213">Set the <xref:System.Data.Objects.ObjectContextOptions.LazyLoadingEnabled%2A> option on the <xref:System.Data.Objects.ObjectContext> to `true`.</span></span> <span data-ttu-id="c852d-214">請注意，當您使用 [實體資料模型設計](/previous-versions/dotnet/netframework-4.0/cc716685(v=vs.100))工具產生物件層程式碼時，就會自動完成這項操作。</span><span class="sxs-lookup"><span data-stu-id="c852d-214">Note that this is done automatically when you generate object-layer code with the [Entity Data Model Designer](/previous-versions/dotnet/netframework-4.0/cc716685(v=vs.100)).</span></span> <span data-ttu-id="c852d-215">如需詳細資訊，請參閱產生的程式 [代碼總覽](/previous-versions/dotnet/netframework-4.0/cc982041(v=vs.100))。</span><span class="sxs-lookup"><span data-stu-id="c852d-215">For more information see [Generated Code Overview](/previous-versions/dotnet/netframework-4.0/cc982041(v=vs.100)).</span></span>  
  
 <span data-ttu-id="c852d-216">考慮要使用哪一種方式時，請特別留意，在對資料庫要求的數目與單一查詢所傳回的資料量之間，必須有所取捨。</span><span class="sxs-lookup"><span data-stu-id="c852d-216">When you consider which option to use, be aware that there is a tradeoff between the number of requests against the database and the amount of data returned in a single query.</span></span> <span data-ttu-id="c852d-217">如需詳細資訊，請參閱 [載入相關物件](/previous-versions/dotnet/netframework-4.0/bb896272(v=vs.100))。</span><span class="sxs-lookup"><span data-stu-id="c852d-217">For more information, see [Loading Related Objects](/previous-versions/dotnet/netframework-4.0/bb896272(v=vs.100)).</span></span>  
  
#### <a name="using-query-paths"></a><span data-ttu-id="c852d-218">使用查詢路徑</span><span class="sxs-lookup"><span data-stu-id="c852d-218">Using query paths</span></span>  
 <span data-ttu-id="c852d-219">查詢路徑會定義查詢傳回的物件圖形。</span><span class="sxs-lookup"><span data-stu-id="c852d-219">Query paths define the graph of objects that a query returns.</span></span> <span data-ttu-id="c852d-220">定義查詢路徑時，只需針對資料庫進行單一要求，即可傳回此路徑定義的所有物件。</span><span class="sxs-lookup"><span data-stu-id="c852d-220">When you define a query path, only a single request against the database is required to return all objects that the path defines.</span></span> <span data-ttu-id="c852d-221">使用查詢路徑可能會使表面上簡單的物件查詢變成要針對資料來源執行複雜的命令。</span><span class="sxs-lookup"><span data-stu-id="c852d-221">Using query paths can result in complex commands being executed against the data source from seemingly simple object queries.</span></span> <span data-ttu-id="c852d-222">發生這種情況是因為必須進行一或多次聯結才能在單一查詢中傳回相關物件。</span><span class="sxs-lookup"><span data-stu-id="c852d-222">This occurs because one or more joins are required to return related objects in a single query.</span></span> <span data-ttu-id="c852d-223">在針對複雜實體模型 (例如具有繼承的實體或包含多對多關聯性的路徑) 的查詢中，這種複雜性會變得更大。</span><span class="sxs-lookup"><span data-stu-id="c852d-223">This complexity is greater in queries against a complex entity model, such as an entity with inheritance or a path that includes many-to-many relationships.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="c852d-224">使用 <xref:System.Data.Objects.ObjectQuery.ToTraceString%2A> 方法可查看將會由 <xref:System.Data.Objects.ObjectQuery%601> 產生的命令。</span><span class="sxs-lookup"><span data-stu-id="c852d-224">Use the <xref:System.Data.Objects.ObjectQuery.ToTraceString%2A> method to see the command that will be generated by an <xref:System.Data.Objects.ObjectQuery%601>.</span></span> <span data-ttu-id="c852d-225">如需詳細資訊，請參閱 [如何：查看存放區命令](/previous-versions/dotnet/netframework-4.0/bb896348(v=vs.100))。</span><span class="sxs-lookup"><span data-stu-id="c852d-225">For more information, see [How to: View the Store Commands](/previous-versions/dotnet/netframework-4.0/bb896348(v=vs.100)).</span></span>  
  
 <span data-ttu-id="c852d-226">如果查詢路徑包含太多相關物件，或是物件包含太多資料列資料，資料來源可能會無法完成查詢。</span><span class="sxs-lookup"><span data-stu-id="c852d-226">When a query path includes too many related objects or the objects contain too much row data, the data source might be unable to complete the query.</span></span> <span data-ttu-id="c852d-227">如果查詢需要超過資料來源能力的中繼暫時儲存體，就會發生這種情況。</span><span class="sxs-lookup"><span data-stu-id="c852d-227">This occurs if the query requires intermediate temporary storage that exceeds the capabilities of the data source.</span></span> <span data-ttu-id="c852d-228">發生這種情況時，請明確載入相關物件來降低資料來源查詢的複雜性。</span><span class="sxs-lookup"><span data-stu-id="c852d-228">When this occurs, you can reduce the complexity of the data source query by explicitly loading related objects.</span></span>  
  
#### <a name="explicitly-loading-related-objects"></a><span data-ttu-id="c852d-229">明確載入相關物件</span><span class="sxs-lookup"><span data-stu-id="c852d-229">Explicitly loading related objects</span></span>  
 <span data-ttu-id="c852d-230">您可以呼叫傳回 `Load` 之導覽屬性上的 <xref:System.Data.Objects.DataClasses.EntityCollection%601> 方法，或是呼叫 <xref:System.Data.Objects.DataClasses.EntityReference%601>，以明確載入相關物件。</span><span class="sxs-lookup"><span data-stu-id="c852d-230">You can explicitly load related objects by calling the `Load` method on a navigation property that returns an <xref:System.Data.Objects.DataClasses.EntityCollection%601> or <xref:System.Data.Objects.DataClasses.EntityReference%601>.</span></span> <span data-ttu-id="c852d-231">明確載入物件必須在每次呼叫 `Load` 時反覆存取資料庫一次。</span><span class="sxs-lookup"><span data-stu-id="c852d-231">Explicitly loading objects requires a round-trip to the database every time `Load` is called.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="c852d-232">在傳回的物件集合中執行迴圈時，如果呼叫 `Load`，例如使用 `foreach` 陳述式時 (Visual Basic 中的 `For Each`)，資料來源特定的提供者必須支援單一連接上的多個作用中結果集。</span><span class="sxs-lookup"><span data-stu-id="c852d-232">if you call `Load` while looping through a collection of returned objects, such as when you use the `foreach` statement (`For Each` in Visual Basic), the data source-specific provider must support multiple active results sets on a single connection.</span></span> <span data-ttu-id="c852d-233">若為 SQL Server 資料庫，您必須在提供者連接字串中指定 `MultipleActiveResultSets = true` 的值。</span><span class="sxs-lookup"><span data-stu-id="c852d-233">For a SQL Server database, you must specify a value of `MultipleActiveResultSets = true` in the provider connection string.</span></span>  
  
 <span data-ttu-id="c852d-234">當實體上沒有 <xref:System.Data.Objects.ObjectContext.LoadProperty%2A> 或 <xref:System.Data.Objects.DataClasses.EntityCollection%601> 屬性時，您也可以使用 <xref:System.Data.Objects.DataClasses.EntityReference%601> 方法。</span><span class="sxs-lookup"><span data-stu-id="c852d-234">You can also use the <xref:System.Data.Objects.ObjectContext.LoadProperty%2A> method when there is no <xref:System.Data.Objects.DataClasses.EntityCollection%601> or <xref:System.Data.Objects.DataClasses.EntityReference%601> properties on entities.</span></span> <span data-ttu-id="c852d-235">這在您使用 POCO 實體時很有用。</span><span class="sxs-lookup"><span data-stu-id="c852d-235">This is useful when you are using POCO entities.</span></span>  
  
 <span data-ttu-id="c852d-236">雖然明確載入相關物件將降低聯結數量和多餘資料量，`Load` 卻需要重複的資料庫連接，當明確載入大量物件時，這可能會耗用大量成本。</span><span class="sxs-lookup"><span data-stu-id="c852d-236">Although explicitly loading related objects will reduce the number of joins and reduced the amount of redundant data, `Load` requires repeated connections to the database, which can become costly when explicitly loading a large number of objects.</span></span>  
  
### <a name="saving-changes"></a><span data-ttu-id="c852d-237">儲存變更</span><span class="sxs-lookup"><span data-stu-id="c852d-237">Saving Changes</span></span>  
 <span data-ttu-id="c852d-238">呼叫 <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> 上的 <xref:System.Data.Objects.ObjectContext> 方法時，會針對內容中每一個已加入、已更新或已刪除的物件，產生另一個建立、更新或刪除的命令。</span><span class="sxs-lookup"><span data-stu-id="c852d-238">When you call the <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> method on an <xref:System.Data.Objects.ObjectContext>, a separate create, update, or delete command is generated for every added, updated, or deleted object in the context.</span></span> <span data-ttu-id="c852d-239">這些命令會在單一異動中的資料來源上執行。</span><span class="sxs-lookup"><span data-stu-id="c852d-239">These commands are executed on the data source in a single transaction.</span></span> <span data-ttu-id="c852d-240">若含有查詢，建立、更新和刪除作業的效能會依概念模型中對應的複雜度而有所不同。</span><span class="sxs-lookup"><span data-stu-id="c852d-240">As with queries, the performance of create, update, and delete operations depends on the complexity of the mapping in the conceptual model.</span></span>  
  
### <a name="distributed-transactions"></a><span data-ttu-id="c852d-241">分散式交易</span><span class="sxs-lookup"><span data-stu-id="c852d-241">Distributed Transactions</span></span>  
 <span data-ttu-id="c852d-242">在明確異動中，需要由分散式異動協調器 (DTC) 管理之資源的作業，會比不需要 DTC 的相似作業耗用更多成本。</span><span class="sxs-lookup"><span data-stu-id="c852d-242">Operations in an explicit transaction that require resources that are managed by the distributed transaction coordinator (DTC) will be much more expensive than a similar operation that does not require the DTC.</span></span> <span data-ttu-id="c852d-243">提升至 DTC 會發生以下狀況：</span><span class="sxs-lookup"><span data-stu-id="c852d-243">Promotion to the DTC will occur in the following situations:</span></span>  
  
- <span data-ttu-id="c852d-244">包含針對 SQL Server 2000 資料庫或其他資料來源之作業的明確異動，永遠會將明確異動提升至 DTC。</span><span class="sxs-lookup"><span data-stu-id="c852d-244">An explicit transaction with an operation against a SQL Server 2000 database or other data source that always promote explicit transactions to the DTC.</span></span>  
  
- <span data-ttu-id="c852d-245">當連接由 Entity Framework 管理時，具有對 SQL Server 2005 之作業的明確交易。</span><span class="sxs-lookup"><span data-stu-id="c852d-245">An explicit transaction with an operation against SQL Server 2005 when the connection is managed by the Entity Framework.</span></span> <span data-ttu-id="c852d-246">發生這種情況的原因是，只要在單一交易內關閉並重新開啟連接（這是 Entity Framework 的預設行為），SQL Server 2005 就會升級至 DTC。</span><span class="sxs-lookup"><span data-stu-id="c852d-246">This occurs because SQL Server 2005 promotes to a DTC whenever a connection is closed and reopened within a single transaction, which is the default behavior of the Entity Framework.</span></span> <span data-ttu-id="c852d-247">使用 SQL Server 2008 就不會發生 DTC 提升。</span><span class="sxs-lookup"><span data-stu-id="c852d-247">This DTC promotion does not occur when using SQL Server 2008.</span></span> <span data-ttu-id="c852d-248">若要在使用 SQL Server 2005 時防止這個問題發生，您必須明確開啟和關閉交易內的連接。</span><span class="sxs-lookup"><span data-stu-id="c852d-248">To avoid this promotion when using SQL Server 2005, you must explicitly open and close the connection within the transaction.</span></span> <span data-ttu-id="c852d-249">如需詳細資訊，請參閱 [管理連接和交易](/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100))。</span><span class="sxs-lookup"><span data-stu-id="c852d-249">For more information, see [Managing Connections and Transactions](/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span></span>  
  
 <span data-ttu-id="c852d-250">當一個或多個作業在 <xref:System.Transactions> 交易內執行時，會使用明確交易。</span><span class="sxs-lookup"><span data-stu-id="c852d-250">An explicit transaction is used when one or more operations are executed inside a <xref:System.Transactions> transaction.</span></span> <span data-ttu-id="c852d-251">如需詳細資訊，請參閱 [管理連接和交易](/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100))。</span><span class="sxs-lookup"><span data-stu-id="c852d-251">For more information, see [Managing Connections and Transactions](/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span></span>  
  
## <a name="strategies-for-improving-performance"></a><span data-ttu-id="c852d-252">提升效能的策略</span><span class="sxs-lookup"><span data-stu-id="c852d-252">Strategies for Improving Performance</span></span>  
 <span data-ttu-id="c852d-253">您可以利用下列策略，改善 Entity Framework 中查詢的整體效能。</span><span class="sxs-lookup"><span data-stu-id="c852d-253">You can improve the overall performance of queries in the Entity Framework by using the following strategies.</span></span>  
  
#### <a name="pre-generate-views"></a><span data-ttu-id="c852d-254">預先產生檢視</span><span class="sxs-lookup"><span data-stu-id="c852d-254">Pre-generate views</span></span>  
 <span data-ttu-id="c852d-255">應用程式第一次執行查詢時，根據實體模型產生檢視會耗用大量成本。</span><span class="sxs-lookup"><span data-stu-id="c852d-255">Generating views based on an entity model is a significant cost the first time that an application executes a query.</span></span> <span data-ttu-id="c852d-256">請使用 EdmGen.exe 公用程式，預先產生做為 Visual Basic 或 C# 程式碼檔案的檢視表，在設計期間就可以加入至專案中。</span><span class="sxs-lookup"><span data-stu-id="c852d-256">Use the EdmGen.exe utility to pre-generate views as a Visual Basic or C# code file that can be added to the project during design.</span></span> <span data-ttu-id="c852d-257">您也可以使用文字範本轉換工具組來產生預先編譯的檢閱表。</span><span class="sxs-lookup"><span data-stu-id="c852d-257">You could also use the Text Template Transformation Toolkit to generate pre-compiled views.</span></span> <span data-ttu-id="c852d-258">預先產生的檢視表會在執行階段進行驗證，以確保與指定之實體模型的目前版本一致。</span><span class="sxs-lookup"><span data-stu-id="c852d-258">Pre-generated views are validated at runtime to ensure that they are consistent with the current version of the specified entity model.</span></span> <span data-ttu-id="c852d-259">如需詳細資訊，請參閱 [如何：預先產生視圖，以改善查詢效能](/previous-versions/dotnet/netframework-4.0/bb896240(v=vs.100))。</span><span class="sxs-lookup"><span data-stu-id="c852d-259">For more information, see [How to: Pre-Generate Views to Improve Query Performance](/previous-versions/dotnet/netframework-4.0/bb896240(v=vs.100)).</span></span>
  
 <span data-ttu-id="c852d-260">當您處理非常大的模型時，必須考量以下事項：</span><span class="sxs-lookup"><span data-stu-id="c852d-260">When working with very large models, the following consideration applies:</span></span>  
  
 <span data-ttu-id="c852d-261">.NET 中繼資料格式會將給定二進位格式的使用者字串字元數目限制為 16,777,215 (0xFFFFFF)。</span><span class="sxs-lookup"><span data-stu-id="c852d-261">The .NET metadata format limits the number of user string characters in a given binary to 16,777,215 (0xFFFFFF).</span></span> <span data-ttu-id="c852d-262">如果您要產生非常大型模型的視圖，而且 view 檔案達到這個大小限制，您會看到「沒有可用的邏輯空間可建立更多使用者字串」。</span><span class="sxs-lookup"><span data-stu-id="c852d-262">If you are generating views for a very large model and the view file reaches this size limit, you will get the "No logical space left to create more user strings."</span></span> <span data-ttu-id="c852d-263">編譯錯誤。</span><span class="sxs-lookup"><span data-stu-id="c852d-263">compile error.</span></span> <span data-ttu-id="c852d-264">這個大小限制適用於所有 Managed 二進位檔。</span><span class="sxs-lookup"><span data-stu-id="c852d-264">This size limitation applies to all managed binaries.</span></span> <span data-ttu-id="c852d-265">如需詳細資訊，請參閱示範如何避免在使用大型和複雜模型時發生錯誤的 [blog](/archive/blogs/appfabriccat/solving-the-no-logical-space-left-to-create-more-user-strings-error-and-improving-performance-of-pre-generated-views-in-visual-studio-net4-entity-framework) 。</span><span class="sxs-lookup"><span data-stu-id="c852d-265">For more information see the [blog](/archive/blogs/appfabriccat/solving-the-no-logical-space-left-to-create-more-user-strings-error-and-improving-performance-of-pre-generated-views-in-visual-studio-net4-entity-framework) that demonstrates how to avoid the error when working with large and complex models.</span></span>  
  
#### <a name="consider-using-the-notracking-merge-option-for-queries"></a><span data-ttu-id="c852d-266">考慮針對查詢使用 NoTracking 合併選項</span><span class="sxs-lookup"><span data-stu-id="c852d-266">Consider using the NoTracking merge option for queries</span></span>  
 <span data-ttu-id="c852d-267">追蹤在物件內容中傳回的物件是必要成本。</span><span class="sxs-lookup"><span data-stu-id="c852d-267">There is a cost required to track returned objects in the object context.</span></span> <span data-ttu-id="c852d-268">偵測物件的變更，並確保相同邏輯實體的多個要求能傳回相同物件執行個體，需要將物件附加至 <xref:System.Data.Objects.ObjectContext> 執行個體。</span><span class="sxs-lookup"><span data-stu-id="c852d-268">Detecting changes to objects and ensuring that multiple requests for the same logical entity return the same object instance requires that objects be attached to an <xref:System.Data.Objects.ObjectContext> instance.</span></span> <span data-ttu-id="c852d-269">如果您不打算對物件進行更新或刪除，也不需要識別管理，請考慮在 <xref:System.Data.Objects.MergeOption.NoTracking> 執行查詢時使用合併選項。</span><span class="sxs-lookup"><span data-stu-id="c852d-269">If you do not plan to make updates or deletes to objects and do not require identity management, consider using the <xref:System.Data.Objects.MergeOption.NoTracking> merge options when you execute queries.</span></span>  
  
#### <a name="return-the-correct-amount-of-data"></a><span data-ttu-id="c852d-270">傳回正確的資料量</span><span class="sxs-lookup"><span data-stu-id="c852d-270">Return the correct amount of data</span></span>  
 <span data-ttu-id="c852d-271">在某些情況下，<xref:System.Data.Objects.ObjectQuery%601.Include%2A> 方法指定查詢路徑會比較快速，因為需要反覆存取資料庫的次數較少。</span><span class="sxs-lookup"><span data-stu-id="c852d-271">In some scenarios, specifying a query path using the <xref:System.Data.Objects.ObjectQuery%601.Include%2A> method is much faster because it requires fewer round trips to the database.</span></span> <span data-ttu-id="c852d-272">不過，在其他情況下，額外反覆存取資料庫以載入相關物件可能會比較快速，因為較簡單的查詢加上較少的聯結，可產生較少的資料重複。</span><span class="sxs-lookup"><span data-stu-id="c852d-272">However, in other scenarios, additional round trips to the database to load related objects may be faster because the simpler queries with fewer joins result in less redundancy of data.</span></span> <span data-ttu-id="c852d-273">因此，我們建議您測試各種不同的擷取相關物件方法。</span><span class="sxs-lookup"><span data-stu-id="c852d-273">Because of this, we recommend that you test the performance of various ways to retrieve related objects.</span></span> <span data-ttu-id="c852d-274">如需詳細資訊，請參閱 [載入相關物件](/previous-versions/dotnet/netframework-4.0/bb896272(v=vs.100))。</span><span class="sxs-lookup"><span data-stu-id="c852d-274">For more information, see [Loading Related Objects](/previous-versions/dotnet/netframework-4.0/bb896272(v=vs.100)).</span></span>  
  
 <span data-ttu-id="c852d-275">若要防止單一查詢傳回太多資料，請考慮將查詢結果分頁成多個可管理的群組。</span><span class="sxs-lookup"><span data-stu-id="c852d-275">To avoid returning too much data in a single query, consider paging the results of the query into more manageable groups.</span></span> <span data-ttu-id="c852d-276">如需詳細資訊，請參閱 [如何：逐頁查看查詢結果](/previous-versions/dotnet/netframework-4.0/bb738702(v=vs.100))。</span><span class="sxs-lookup"><span data-stu-id="c852d-276">For more information, see [How to: Page Through Query Results](/previous-versions/dotnet/netframework-4.0/bb738702(v=vs.100)).</span></span>  
  
#### <a name="limit-the-scope-of-the-objectcontext"></a><span data-ttu-id="c852d-277">限制 ObjectContext 的範圍</span><span class="sxs-lookup"><span data-stu-id="c852d-277">Limit the scope of the ObjectContext</span></span>  
 <span data-ttu-id="c852d-278">在大多數的情況下，您應該在 <xref:System.Data.Objects.ObjectContext> 陳述式 (Visual Basic 中的 `using`) 中，建立 `Using…End Using` 執行個體。</span><span class="sxs-lookup"><span data-stu-id="c852d-278">In most cases, you should create an <xref:System.Data.Objects.ObjectContext> instance within a `using` statement (`Using…End Using` in Visual Basic).</span></span> <span data-ttu-id="c852d-279">確保當程式碼存在陳述式區塊時，與內容物件關聯的資源會自動公開，這麼做可以提高效能。</span><span class="sxs-lookup"><span data-stu-id="c852d-279">This can increase performance by ensuring that the resources associated with the object context are disposed automatically when the code exits the statement block.</span></span> <span data-ttu-id="c852d-280">不過，當控制項繫結至由物件內容管理的物件時，只要繫結是必要且為手動公開的，則應維護 <xref:System.Data.Objects.ObjectContext> 執行個體。</span><span class="sxs-lookup"><span data-stu-id="c852d-280">However, when controls are bound to objects managed by the object context, the <xref:System.Data.Objects.ObjectContext> instance should be maintained as long as the binding is needed and disposed of manually.</span></span> <span data-ttu-id="c852d-281">如需詳細資訊，請參閱 [管理連接和交易](/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100))。</span><span class="sxs-lookup"><span data-stu-id="c852d-281">For more information, see [Managing Connections and Transactions](/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span></span>  
  
#### <a name="consider-opening-the-database-connection-manually"></a><span data-ttu-id="c852d-282">考慮手動開啟資料庫連接</span><span class="sxs-lookup"><span data-stu-id="c852d-282">Consider opening the database connection manually</span></span>  
 <span data-ttu-id="c852d-283">當您的應用程式執行一系列的物件查詢，或是經常呼叫 <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> 將 create、update 和 delete 作業保存到資料來源時，Entity Framework 必須持續開啟並關閉與資料來源的連接。</span><span class="sxs-lookup"><span data-stu-id="c852d-283">When your application executes a series of object queries or frequently calls <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> to persist create, update, and delete operations to the data source, the Entity Framework must continuously open and close the connection to the data source.</span></span> <span data-ttu-id="c852d-284">在這些情況下，請考慮在這些連接開始時，手動開啟連接，然後當作業完成時，關閉或處置連接。</span><span class="sxs-lookup"><span data-stu-id="c852d-284">In these situations, consider manually opening the connection at the start of these operations and either closing or disposing of the connection when the operations are complete.</span></span> <span data-ttu-id="c852d-285">如需詳細資訊，請參閱 [管理連接和交易](/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100))。</span><span class="sxs-lookup"><span data-stu-id="c852d-285">For more information, see [Managing Connections and Transactions](/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span></span>  
  
## <a name="performance-data"></a><span data-ttu-id="c852d-286">效能資料</span><span class="sxs-lookup"><span data-stu-id="c852d-286">Performance Data</span></span>  
 <span data-ttu-id="c852d-287">Entity Framework 的某些效能資料會在下列 [ADO.NET team blog](/archive/blogs/adonet/)文章中發佈：</span><span class="sxs-lookup"><span data-stu-id="c852d-287">Some performance data for the Entity Framework is published in the following posts on the [ADO.NET team blog](/archive/blogs/adonet/):</span></span>  
  
- [<span data-ttu-id="c852d-288">瀏覽 ADO.NET Entity Framework 的效能 - 第 1 部分 (英文)</span><span class="sxs-lookup"><span data-stu-id="c852d-288">Exploring the Performance of the ADO.NET Entity Framework - Part 1</span></span>](/archive/blogs/adonet/exploring-the-performance-of-the-ado-net-entity-framework-part-1)  
  
- [<span data-ttu-id="c852d-289">瀏覽 ADO.NET Entity Framework 的效能 - 第 2 部分 (英文)</span><span class="sxs-lookup"><span data-stu-id="c852d-289">Exploring the Performance of the ADO.NET Entity Framework – Part 2</span></span>](/archive/blogs/adonet/exploring-the-performance-of-the-ado-net-entity-framework-part-2)  
  
- [<span data-ttu-id="c852d-290">ADO.NET Entity Framework 效能比較 (英文)</span><span class="sxs-lookup"><span data-stu-id="c852d-290">ADO.NET Entity Framework Performance Comparison</span></span>](/archive/blogs/adonet/ado-net-entity-framework-performance-comparison)  
  
## <a name="see-also"></a><span data-ttu-id="c852d-291">另請參閱</span><span class="sxs-lookup"><span data-stu-id="c852d-291">See also</span></span>

- [<span data-ttu-id="c852d-292">開發及部署考量因素</span><span class="sxs-lookup"><span data-stu-id="c852d-292">Development and Deployment Considerations</span></span>](development-and-deployment-considerations.md)
