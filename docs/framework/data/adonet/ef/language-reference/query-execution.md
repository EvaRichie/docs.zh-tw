---
title: 查詢執行
description: 瞭解 LINQ to Entities 查詢執行的不同方式，包括延後查詢執行、立即執行查詢和儲存執行。
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: c0e6cf23-63ac-47dd-bfe9-d5bdca826fac
ms.openlocfilehash: e776df6d35b6cc8c24cd83e902bc4d050347343b
ms.sourcegitcommit: 33deec3e814238fb18a49b2a7e89278e27888291
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 06/02/2020
ms.locfileid: "84286788"
---
# <a name="query-execution"></a><span data-ttu-id="f1259-103">查詢執行</span><span class="sxs-lookup"><span data-stu-id="f1259-103">Query Execution</span></span>
<span data-ttu-id="f1259-104">使用者建立 LINQ 查詢之後，查詢就會轉換成命令樹。</span><span class="sxs-lookup"><span data-stu-id="f1259-104">After a LINQ query is created by a user, it is converted to a command tree.</span></span> <span data-ttu-id="f1259-105">命令樹一種可與 Entity Framework 比較的查詢表示方式。</span><span class="sxs-lookup"><span data-stu-id="f1259-105">A command tree is a representation of a query that is compatible with the Entity Framework.</span></span> <span data-ttu-id="f1259-106">接下來命令樹會針對資料來源執行。</span><span class="sxs-lookup"><span data-stu-id="f1259-106">The command tree is then executed against the data source.</span></span> <span data-ttu-id="f1259-107">查詢執行期間會評估所有查詢運算式 (也就是查詢的所有元件)，包括結果具體化中使用的運算式。</span><span class="sxs-lookup"><span data-stu-id="f1259-107">At query execution time, all query expressions (that is, all components of the query) are evaluated, including those expressions that are used in result materialization.</span></span>  
  
 <span data-ttu-id="f1259-108">查詢運算式執行的時間點可能會變動。</span><span class="sxs-lookup"><span data-stu-id="f1259-108">At what point query expressions are executed can vary.</span></span> <span data-ttu-id="f1259-109">LINQ 查詢一定是在重複處理查詢變數時執行，而不是在查詢變數建立後執行。</span><span class="sxs-lookup"><span data-stu-id="f1259-109">LINQ queries are always executed when the query variable is iterated over, not when the query variable is created.</span></span> <span data-ttu-id="f1259-110">這稱為「*延後執行*」。</span><span class="sxs-lookup"><span data-stu-id="f1259-110">This is called *deferred execution*.</span></span> <span data-ttu-id="f1259-111">您也可以強制查詢立即執行，這對於快取查詢結果很有用處。</span><span class="sxs-lookup"><span data-stu-id="f1259-111">You can also force a query to execute immediately, which is useful for caching query results.</span></span> <span data-ttu-id="f1259-112">本主題稍後將提供這方面的說明。</span><span class="sxs-lookup"><span data-stu-id="f1259-112">This is described later in this topic.</span></span>  
  
 <span data-ttu-id="f1259-113">執行 LINQ to Entities 查詢時，查詢中的某些運算式可能會在伺服器上執行，而某些部分則可能在本機用戶端上執行。</span><span class="sxs-lookup"><span data-stu-id="f1259-113">When a LINQ to Entities query is executed, some expressions in the query might be executed on the server and some parts might be executed locally on the client.</span></span> <span data-ttu-id="f1259-114">在伺服器上執行查詢以前，會先在用戶端評估運算式。</span><span class="sxs-lookup"><span data-stu-id="f1259-114">Client-side evaluation of an expression takes place before the query is executed on the server.</span></span> <span data-ttu-id="f1259-115">如果運算式是在用戶端上評估，該評估的結果會代替查詢中的運算式，然後會在伺服器上執行查詢。</span><span class="sxs-lookup"><span data-stu-id="f1259-115">If an expression is evaluated on the client, the result of that evaluation is substituted for the expression in the query, and the query is then executed on the server.</span></span> <span data-ttu-id="f1259-116">由於查詢會在資料存來源執行，所以資料來源組態會覆寫用戶端中指定的行為。</span><span class="sxs-lookup"><span data-stu-id="f1259-116">Because queries are executed on the data source, the data source configuration overrides the behavior specified in the client.</span></span> <span data-ttu-id="f1259-117">例如，null 值的處理和數值的有效位數都會因伺服器設定而異。</span><span class="sxs-lookup"><span data-stu-id="f1259-117">For example, null value handling and numerical precision depend on the server settings.</span></span> <span data-ttu-id="f1259-118">在伺服器上執行查詢的期間擲回的任何例外狀況，都會直接傳遞給用戶端。</span><span class="sxs-lookup"><span data-stu-id="f1259-118">Any exceptions thrown during query execution on the server are passed directly up to the client.</span></span>  

> [!TIP]
> <span data-ttu-id="f1259-119">如需資料表格式中查詢運算子的方便摘要，讓您快速識別操作員的執行行為，請參閱[依執行方式分類標準查詢運算子（c #）](../../../../../csharp/programming-guide/concepts/linq/classification-of-standard-query-operators-by-manner-of-execution.md)。</span><span class="sxs-lookup"><span data-stu-id="f1259-119">For a convenient summary of query operators in table format, which lets you quickly identify an operator's execution behavior, see [Classification of Standard Query Operators by Manner of Execution (C#)](../../../../../csharp/programming-guide/concepts/linq/classification-of-standard-query-operators-by-manner-of-execution.md).</span></span>

## <a name="deferred-query-execution"></a><span data-ttu-id="f1259-120">延後查詢執行</span><span class="sxs-lookup"><span data-stu-id="f1259-120">Deferred query execution</span></span>  
 <span data-ttu-id="f1259-121">在傳回值序列的查詢中，查詢變數本身絕不會保存查詢結果，只會儲存查詢命令而已。</span><span class="sxs-lookup"><span data-stu-id="f1259-121">In a query that returns a sequence of values, the query variable itself never holds the query results and only stores the query commands.</span></span> <span data-ttu-id="f1259-122">查詢的執行會延後，直到在 `foreach` 或 `For Each` 迴圈 (Loop) 中反覆查看查詢變數為止。</span><span class="sxs-lookup"><span data-stu-id="f1259-122">Execution of the query is deferred until the query variable is iterated over in a `foreach` or `For Each` loop.</span></span> <span data-ttu-id="f1259-123">這就是所謂的*延後執行*;也就是說，查詢執行會在查詢經過一段時間之後發生。</span><span class="sxs-lookup"><span data-stu-id="f1259-123">This is known as *deferred execution*; that is, query execution occurs some time after the query is constructed.</span></span> <span data-ttu-id="f1259-124">這表示您可以隨時都可以執行查詢。</span><span class="sxs-lookup"><span data-stu-id="f1259-124">This means that you can execute a query as frequently as you want to.</span></span> <span data-ttu-id="f1259-125">例如，當您擁有一個正由其他應用程式更新的資料庫時，這就很有用。</span><span class="sxs-lookup"><span data-stu-id="f1259-125">This is useful when, for example, you have a database that is being updated by other applications.</span></span> <span data-ttu-id="f1259-126">您可以在應用程式中建立擷取最新資訊的查詢，然後重複執行此查詢，以便每次都傳回更新的資訊。</span><span class="sxs-lookup"><span data-stu-id="f1259-126">In your application, you can create a query to retrieve the latest information and repeatedly execute the query, returning the updated information every time.</span></span>  
  
 <span data-ttu-id="f1259-127">延後執行可結合多個查詢或擴充單一查詢。</span><span class="sxs-lookup"><span data-stu-id="f1259-127">Deferred execution enables multiple queries to be combined or a query to be extended.</span></span> <span data-ttu-id="f1259-128">擴充單一查詢時，它會修改成包含新的作業，而且最終的執行將反映這些變更。</span><span class="sxs-lookup"><span data-stu-id="f1259-128">When a query is extended, it is modified to include the new operations, and the eventual execution will reflect the changes.</span></span> <span data-ttu-id="f1259-129">在下列範例中，第一個查詢會傳回所有產品。</span><span class="sxs-lookup"><span data-stu-id="f1259-129">In the following example, the first query returns all the products.</span></span> <span data-ttu-id="f1259-130">第二個查詢會使用 `Where` 來擴充第一個查詢，以便傳回大小為 "L" 的所有產品：</span><span class="sxs-lookup"><span data-stu-id="f1259-130">The second query extends the first by using `Where` to return all the products of size "L":</span></span>  
  
 [!code-csharp[DP L2E Conceptual Examples#Composing1](../../../../../../samples/snippets/csharp/VS_Snippets_Data/DP L2E Conceptual Examples/CS/Program.cs#composing1)]
 [!code-vb[DP L2E Conceptual Examples#Composing1](../../../../../../samples/snippets/visualbasic/VS_Snippets_Data/DP L2E Conceptual Examples/VB/Module1.vb#composing1)]  
  
 <span data-ttu-id="f1259-131">在查詢執行之後，所有後續查詢都會使用記憶體中的 LINQ 運算子。</span><span class="sxs-lookup"><span data-stu-id="f1259-131">After a query has been executed all successive queries will use the in-memory LINQ operators.</span></span> <span data-ttu-id="f1259-132">使用 `foreach` 或 `For Each` 陳述式或呼叫其中一個 LINQ 轉換運算子來重複處理查詢變數，將會造成立即執行。</span><span class="sxs-lookup"><span data-stu-id="f1259-132">Iterating over the query variable by using a `foreach` or `For Each` statement or by calling one of the LINQ conversion operators will cause immediate execution.</span></span> <span data-ttu-id="f1259-133">這些轉換運算子包咶：<xref:System.Linq.Enumerable.ToList%2A>、<xref:System.Linq.Enumerable.ToArray%2A>、<xref:System.Linq.Enumerable.ToLookup%2A> 和 <xref:System.Linq.Enumerable.ToDictionary%2A>。</span><span class="sxs-lookup"><span data-stu-id="f1259-133">These conversion operators include the following: <xref:System.Linq.Enumerable.ToList%2A>, <xref:System.Linq.Enumerable.ToArray%2A>, <xref:System.Linq.Enumerable.ToLookup%2A>, and <xref:System.Linq.Enumerable.ToDictionary%2A>.</span></span>  
  
## <a name="immediate-query-execution"></a><span data-ttu-id="f1259-134">立即執行查詢</span><span class="sxs-lookup"><span data-stu-id="f1259-134">Immediate Query Execution</span></span>  
 <span data-ttu-id="f1259-135">產生一連串值的查詢會延後執行，但是傳回單一值的查詢則是立即執行。</span><span class="sxs-lookup"><span data-stu-id="f1259-135">In contrast to the deferred execution of queries that produce a sequence of values, queries that return a singleton value are executed immediately.</span></span> <span data-ttu-id="f1259-136">單一子句查詢的某些範例包括 <xref:System.Linq.Enumerable.Average%2A>、<xref:System.Linq.Enumerable.Count%2A>、<xref:System.Linq.Enumerable.First%2A> 和 <xref:System.Linq.Enumerable.Max%2A>。</span><span class="sxs-lookup"><span data-stu-id="f1259-136">Some examples of singleton queries are <xref:System.Linq.Enumerable.Average%2A>, <xref:System.Linq.Enumerable.Count%2A>, <xref:System.Linq.Enumerable.First%2A>, and <xref:System.Linq.Enumerable.Max%2A>.</span></span> <span data-ttu-id="f1259-137">這些查詢會立即執行是因為查詢必須產生用來計算單一結果的序列。</span><span class="sxs-lookup"><span data-stu-id="f1259-137">These execute immediately because the query must produce a sequence to calculate the singleton result.</span></span> <span data-ttu-id="f1259-138">您也可以用強制方式立即執行。</span><span class="sxs-lookup"><span data-stu-id="f1259-138">You can also force immediate execution.</span></span> <span data-ttu-id="f1259-139">如果您要快取查詢結果，這種方式就很有用處。</span><span class="sxs-lookup"><span data-stu-id="f1259-139">This is useful when you want to cache the results of a query.</span></span> <span data-ttu-id="f1259-140">如果要強制不是產生單一值的查詢立即執行，您可以在查詢或查詢變數上呼叫 <xref:System.Linq.Enumerable.ToList%2A> 方法、<xref:System.Linq.Enumerable.ToDictionary%2A> 方法，或 <xref:System.Linq.Enumerable.ToArray%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="f1259-140">To force immediate execution of a query that does not produce a singleton value, you can call the <xref:System.Linq.Enumerable.ToList%2A> method, the <xref:System.Linq.Enumerable.ToDictionary%2A> method, or the <xref:System.Linq.Enumerable.ToArray%2A> method on a query or query variable.</span></span> <span data-ttu-id="f1259-141">以下範例使用 <xref:System.Linq.Enumerable.ToArray%2A> 方法將序列立即評估為陣列。</span><span class="sxs-lookup"><span data-stu-id="f1259-141">The following example uses the <xref:System.Linq.Enumerable.ToArray%2A> method to immediately evaluate a sequence into an array.</span></span>  
  
 [!code-csharp[DP L2E Examples#ToArray](../../../../../../samples/snippets/csharp/VS_Snippets_Data/DP L2E Examples/CS/Program.cs#toarray)]
 [!code-vb[DP L2E Examples#ToArray](../../../../../../samples/snippets/visualbasic/VS_Snippets_Data/DP L2E Examples/VB/Module1.vb#toarray)]  
  
 <span data-ttu-id="f1259-142">您也可以將 `foreach` 或 `For Each` 迴圈緊接在查詢運算式之後，用這種方式來強制執行，但是呼叫 <xref:System.Linq.Enumerable.ToList%2A> 或 <xref:System.Linq.Enumerable.ToArray%2A> 必須快取單一集合物件中的所有資料。</span><span class="sxs-lookup"><span data-stu-id="f1259-142">You could also force execution by putting the `foreach` or `For Each` loop immediately after the query expression, but by calling <xref:System.Linq.Enumerable.ToList%2A> or <xref:System.Linq.Enumerable.ToArray%2A> you cache all the data in a single collection object.</span></span>  
  
## <a name="store-execution"></a><span data-ttu-id="f1259-143">存放區執行</span><span class="sxs-lookup"><span data-stu-id="f1259-143">Store Execution</span></span>  
 <span data-ttu-id="f1259-144">一般而言，LINQ to Entities 中的運算式是在伺服器上評估，而運算式的行為也不會依照 Common Language Runtime (CLR) 語意，而是依照資料來源的語意。</span><span class="sxs-lookup"><span data-stu-id="f1259-144">In general, expressions in LINQ to Entities are evaluated on the server, and the behavior of the expression should not be expected to follow common language runtime (CLR) semantics, but those of the data source.</span></span> <span data-ttu-id="f1259-145">不過這種情況也有例外，例如運算式在用戶端上執行時就不是這種情況。</span><span class="sxs-lookup"><span data-stu-id="f1259-145">There are exceptions to this, however, such as when the expression is executed on the client.</span></span> <span data-ttu-id="f1259-146">舉例來講，如果伺服器與用戶端是在不同的時區，這種情況可能會導致無法預期的結果。</span><span class="sxs-lookup"><span data-stu-id="f1259-146">This could cause unexpected results, for example when the server and client are in different time zones.</span></span>  
  
 <span data-ttu-id="f1259-147">查詢中的某些運算式可能會在用戶端上執行。</span><span class="sxs-lookup"><span data-stu-id="f1259-147">Some expressions in the query might be executed on the client.</span></span> <span data-ttu-id="f1259-148">一般而言，大部分查詢執行應該都是發生在伺服器上。</span><span class="sxs-lookup"><span data-stu-id="f1259-148">In general, most query execution is expected to occur on the server.</span></span> <span data-ttu-id="f1259-149">除了針對對應到資料來源的查詢項目執行的方法之外，查詢中也常常有可以在本機執行的運算式。</span><span class="sxs-lookup"><span data-stu-id="f1259-149">Aside from methods executed against query elements mapped to the data source, there are often expressions in the query that can be executed locally.</span></span> <span data-ttu-id="f1259-150">查詢運算式的本機執行會產生可以使用在查詢執行或結果建構中的值。</span><span class="sxs-lookup"><span data-stu-id="f1259-150">Local execution of a query expression yields a value that can be used in the query execution or result construction.</span></span>  
  
 <span data-ttu-id="f1259-151">某些運算永遠是在用戶端執行，例如值的繫結、子運算式、來自結束的子查詢，以及物件具體化成為查詢結果。</span><span class="sxs-lookup"><span data-stu-id="f1259-151">Certain operations are always executed on the client, such as binding of values, sub expressions, sub queries from closures, and materialization of objects into query results.</span></span> <span data-ttu-id="f1259-152">這種情況的最終效果就是這些項目 (例如參數值) 無法在執行期間更新。</span><span class="sxs-lookup"><span data-stu-id="f1259-152">The net effect of this is that these elements (for example, parameter values) cannot be updated during the execution.</span></span> <span data-ttu-id="f1259-153">匿名型別可以用內嵌方式建構在資料來源上，但不應視為必須如此。</span><span class="sxs-lookup"><span data-stu-id="f1259-153">Anonymous types can be constructed inline on the data source, but should not be assumed to do so.</span></span> <span data-ttu-id="f1259-154">內嵌群組也可以建構在資料來源中，但這並不適用於每個執行個體。</span><span class="sxs-lookup"><span data-stu-id="f1259-154">Inline groupings can be constructed in the data source, as well, but this should not be assumed in every instance.</span></span> <span data-ttu-id="f1259-155">一般而言，最好不要假設何者是建構在伺服器上。</span><span class="sxs-lookup"><span data-stu-id="f1259-155">In general, it is best not to make any assumptions about what is constructed on the server.</span></span>  
  
 <span data-ttu-id="f1259-156">本節說明程式碼在用戶端上以本機方式執行的案例。</span><span class="sxs-lookup"><span data-stu-id="f1259-156">This section describes the scenarios in which code is executed locally on the client.</span></span> <span data-ttu-id="f1259-157">如需在本機執行哪些運算式類型的詳細資訊，請參閱[LINQ to Entities 查詢中的運算式](expressions-in-linq-to-entities-queries.md)。</span><span class="sxs-lookup"><span data-stu-id="f1259-157">For more information about which types of expressions are executed locally, see [Expressions in LINQ to Entities Queries](expressions-in-linq-to-entities-queries.md).</span></span>  
  
### <a name="literals-and-parameters"></a><span data-ttu-id="f1259-158">常值和參數</span><span class="sxs-lookup"><span data-stu-id="f1259-158">Literals and Parameters</span></span>  
 <span data-ttu-id="f1259-159">區域變數 (例如以下範例中的 `orderID` 變數) 會在用戶端上評估。</span><span class="sxs-lookup"><span data-stu-id="f1259-159">Local variables, such as the `orderID` variable in the following example, are evaluated on the client.</span></span>  
  
 [!code-csharp[DP L2E Conceptual Examples#LiteralParameter1](../../../../../../samples/snippets/csharp/VS_Snippets_Data/DP L2E Conceptual Examples/CS/Program.cs#literalparameter1)]
 [!code-vb[DP L2E Conceptual Examples#LiteralParameter1](../../../../../../samples/snippets/visualbasic/VS_Snippets_Data/DP L2E Conceptual Examples/VB/Module1.vb#literalparameter1)]  
  
 <span data-ttu-id="f1259-160">方法參數也是在用戶端上評估。</span><span class="sxs-lookup"><span data-stu-id="f1259-160">Method parameters are also evaluated on the client.</span></span> <span data-ttu-id="f1259-161">以下傳入 `orderID` 方法的 `MethodParameterExample` 參數就是這種範例。</span><span class="sxs-lookup"><span data-stu-id="f1259-161">The `orderID` parameter passed into the `MethodParameterExample` method, below, is an example.</span></span>  
  
 [!code-csharp[DP L2E Conceptual Examples#MethodParameterExample](../../../../../../samples/snippets/csharp/VS_Snippets_Data/DP L2E Conceptual Examples/CS/Program.cs#methodparameterexample)]
 [!code-vb[DP L2E Conceptual Examples#MethodParameterExample](../../../../../../samples/snippets/visualbasic/VS_Snippets_Data/DP L2E Conceptual Examples/VB/Module1.vb#methodparameterexample)]  
  
### <a name="casting-literals-on-the-client"></a><span data-ttu-id="f1259-162">在用戶端上將常值轉型</span><span class="sxs-lookup"><span data-stu-id="f1259-162">Casting Literals on the Client</span></span>  
 <span data-ttu-id="f1259-163">從 `null` 轉型為 CLR 型別是在用戶端上執行：</span><span class="sxs-lookup"><span data-stu-id="f1259-163">Casting from `null` to a CLR type is executed on the client:</span></span>  
  
 [!code-csharp[DP L2E Conceptual Examples#NullCastToString](../../../../../../samples/snippets/csharp/VS_Snippets_Data/DP L2E Conceptual Examples/CS/Program.cs#nullcasttostring)]
 [!code-vb[DP L2E Conceptual Examples#NullCastToString](../../../../../../samples/snippets/visualbasic/VS_Snippets_Data/DP L2E Conceptual Examples/VB/Module1.vb#nullcasttostring)]  
  
 <span data-ttu-id="f1259-164">轉型為某種型別 (例如何為 null 的 <xref:System.Decimal>) 是在用戶端上執行：</span><span class="sxs-lookup"><span data-stu-id="f1259-164">Casting to a type, such as a nullable <xref:System.Decimal>, is executed on the client:</span></span>  
  
 [!code-csharp[DP L2E Conceptual Examples#CastToNullable](../../../../../../samples/snippets/csharp/VS_Snippets_Data/DP L2E Conceptual Examples/CS/Program.cs#casttonullable)]
 [!code-vb[DP L2E Conceptual Examples#CastToNullable](../../../../../../samples/snippets/visualbasic/VS_Snippets_Data/DP L2E Conceptual Examples/VB/Module1.vb#casttonullable)]  
  
### <a name="constructors-for-literals"></a><span data-ttu-id="f1259-165">常值的建構函式</span><span class="sxs-lookup"><span data-stu-id="f1259-165">Constructors for Literals</span></span>  
 <span data-ttu-id="f1259-166">可以對應到概念模型類型的新 CLR 類型是在用戶端上執行：</span><span class="sxs-lookup"><span data-stu-id="f1259-166">New CLR types that can be mapped to conceptual model types are executed on the client:</span></span>  
  
 [!code-csharp[DP L2E Conceptual Examples#ConstructorForLiteral](../../../../../../samples/snippets/csharp/VS_Snippets_Data/DP L2E Conceptual Examples/CS/Program.cs#constructorforliteral)]
 [!code-vb[DP L2E Conceptual Examples#ConstructorForLiteral](../../../../../../samples/snippets/visualbasic/VS_Snippets_Data/DP L2E Conceptual Examples/VB/Module1.vb#constructorforliteral)]  
  
 <span data-ttu-id="f1259-167">新陣列也是在用戶端上執行。</span><span class="sxs-lookup"><span data-stu-id="f1259-167">New arrays are also executed on the client.</span></span>  
  
## <a name="store-exceptions"></a><span data-ttu-id="f1259-168">存放區例外狀況</span><span class="sxs-lookup"><span data-stu-id="f1259-168">Store Exceptions</span></span>  
 <span data-ttu-id="f1259-169">在查詢執行期間遭遇的任何存放區錯誤都會傳遞到用戶端，不予對應或處理。</span><span class="sxs-lookup"><span data-stu-id="f1259-169">Any store errors that are encountered during query execution are passed up to the client, and are not mapped or handled.</span></span>  
  
## <a name="store-configuration"></a><span data-ttu-id="f1259-170">存放區組態</span><span class="sxs-lookup"><span data-stu-id="f1259-170">Store Configuration</span></span>  
 <span data-ttu-id="f1259-171">查詢在存放區上執行時，存放區組態會取代所有用戶端行為，並且對所有運算和運算式表示存放區語意。</span><span class="sxs-lookup"><span data-stu-id="f1259-171">When the query executes on the store, the store configuration overrides all client behaviors, and store semantics are expressed for all operations and expressions.</span></span> <span data-ttu-id="f1259-172">這可能會在 null 比較、GUID 順序、涉及非精確資料型別 (例如浮點數型別或 <xref:System.DateTime>) 之運算的有效位數和精確度，以及字串運算等範圍造成 CLR 和存放區執行之間的行為差異。</span><span class="sxs-lookup"><span data-stu-id="f1259-172">This can result in a difference in behavior between CLR and store execution in areas such as null comparisons, GUID ordering, precision and accuracy of operations involving non-precise data types (such as floating point types or <xref:System.DateTime>), and string operations.</span></span> <span data-ttu-id="f1259-173">檢查查詢結果時請務必留意這些情況。</span><span class="sxs-lookup"><span data-stu-id="f1259-173">It is important to keep this in mind when examining query results.</span></span>  
  
 <span data-ttu-id="f1259-174">例如，下面是 CLR 與 SQL Server 之間的一些行為差異：</span><span class="sxs-lookup"><span data-stu-id="f1259-174">For example, the following are some differences in behavior between the CLR and SQL Server:</span></span>  
  
- <span data-ttu-id="f1259-175">SQL Server 排序 GUID 的方式與 CLR 不同。</span><span class="sxs-lookup"><span data-stu-id="f1259-175">SQL Server orders GUIDs differently than the CLR.</span></span>  
  
- <span data-ttu-id="f1259-176">在 SQL Server 上處理 Decimal 型別時也會有結果有效位數的差異。</span><span class="sxs-lookup"><span data-stu-id="f1259-176">There can also be differences in result precision when dealing with the Decimal type on SQL Server.</span></span> <span data-ttu-id="f1259-177">這是因為 SQL Server 的 decimal 型別要求固定有效位數所造成。</span><span class="sxs-lookup"><span data-stu-id="f1259-177">This is due to the fixed precision requirements of the SQL Server decimal type.</span></span> <span data-ttu-id="f1259-178">舉例來講，<xref:System.Decimal> 值 0.0、0.0 和 1.0 的平均在用戶端的記憶體中為 0.3333333333333333333333333333，但是在存放區則為 0.333333 (依據 SQL Server 之 decimal 型別的預設有效位數)。</span><span class="sxs-lookup"><span data-stu-id="f1259-178">For example, the average of <xref:System.Decimal> values 0.0, 0.0, and 1.0 is 0.3333333333333333333333333333 in memory on the client, but 0.333333 in the store (based on the default precision for SQL Server’s decimal type).</span></span>  
  
- <span data-ttu-id="f1259-179">某些字串比較運算在 SQL Server 中的處理方式也不同於 CLR。</span><span class="sxs-lookup"><span data-stu-id="f1259-179">Some string comparison operations are also handled differently in SQL Server than in the CLR.</span></span> <span data-ttu-id="f1259-180">字串比較行為會因伺服器上的定序設定而異。</span><span class="sxs-lookup"><span data-stu-id="f1259-180">String comparison behavior depends on the collation settings on the server.</span></span>  
  
- <span data-ttu-id="f1259-181">函式或方法呼叫包含在 LINQ to Entities 查詢中時會對應到 Entity Framework 中的標準函式，然後再轉譯成 Transact-SQL 並且在 SQL Server 資料庫上執行。</span><span class="sxs-lookup"><span data-stu-id="f1259-181">Function or method calls, when included in a LINQ to Entities query, are mapped to canonical functions in the Entity Framework, which are then translated to Transact-SQL and executed on the SQL Server database.</span></span> <span data-ttu-id="f1259-182">但在某些情況下這些對應函式所表現的行為可能會不同於基底類別庫中的實作。</span><span class="sxs-lookup"><span data-stu-id="f1259-182">There are cases when the behavior these mapped functions exhibit might differ from the implementation in the base class libraries.</span></span> <span data-ttu-id="f1259-183">舉例來講，以空字串為參數呼叫 <xref:System.String.Contains%2A>、<xref:System.String.StartsWith%2A> 和 <xref:System.String.EndsWith%2A> 方法，在 CLR 中執行時將會傳回 `true`，但是在 SQL Server 中執行時卻會傳回 `false`。</span><span class="sxs-lookup"><span data-stu-id="f1259-183">For example, calling the <xref:System.String.Contains%2A>, <xref:System.String.StartsWith%2A>, and <xref:System.String.EndsWith%2A> methods with an empty string as a parameter will return `true` when executed in the CLR, but will return `false` when executed in SQL Server.</span></span> <span data-ttu-id="f1259-184"><xref:System.String.EndsWith%2A> 方法也會傳回不同的結果，因為假如兩個字串只有結尾泛空白字元不同，SQL Server 會將它們視為相等，但 CLR 卻會將它們視為不相等。</span><span class="sxs-lookup"><span data-stu-id="f1259-184">The <xref:System.String.EndsWith%2A> method can also return different results because SQL Server considers two strings to be equal if they only differ in trailing white space, whereas the CLR considers them to be not equal.</span></span> <span data-ttu-id="f1259-185">以下範例就是說明這種情況：</span><span class="sxs-lookup"><span data-stu-id="f1259-185">This is illustrated by the following example:</span></span>  
  
 [!code-csharp[DP L2E Conceptual Examples#CanonicalFuncVsCLRBaseType](../../../../../../samples/snippets/csharp/VS_Snippets_Data/DP L2E Conceptual Examples/CS/Program.cs#canonicalfuncvsclrbasetype)]
 [!code-vb[DP L2E Conceptual Examples#CanonicalFuncVsCLRBaseType](../../../../../../samples/snippets/visualbasic/VS_Snippets_Data/DP L2E Conceptual Examples/VB/Module1.vb#canonicalfuncvsclrbasetype)]
