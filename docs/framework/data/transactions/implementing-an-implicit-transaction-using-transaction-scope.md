---
title: 使用交易範圍實作隱含交易
description: 在 .NET 中使用 TransactionScope 類別來執行隱含交易。 這個類別會提供一個方法，將程式碼區塊標示為參與交易。
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: 49d1706a-1e0c-4c85-9704-75c908372eb9
ms.openlocfilehash: 48dd96dbba89a33cfce7d1b4efb776ef4ce4fada
ms.sourcegitcommit: 6219b1e1feccb16d88656444210fed3297f5611e
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 06/22/2020
ms.locfileid: "85141922"
---
# <a name="implementing-an-implicit-transaction-using-transaction-scope"></a><span data-ttu-id="676b2-104">使用交易範圍實作隱含交易</span><span class="sxs-lookup"><span data-stu-id="676b2-104">Implementing an Implicit Transaction using Transaction Scope</span></span>
<span data-ttu-id="676b2-105"><xref:System.Transactions.TransactionScope> 類別提供一個簡單的方式，讓您不用與交易互動，即可將一段程式碼標記為參與交易。</span><span class="sxs-lookup"><span data-stu-id="676b2-105">The <xref:System.Transactions.TransactionScope> class provides a simple way to mark a block of code as participating in a transaction, without requiring you to interact with the transaction itself.</span></span> <span data-ttu-id="676b2-106">交易範圍可以自動選取並管理環境交易。</span><span class="sxs-lookup"><span data-stu-id="676b2-106">A transaction scope can select and manage the ambient transaction automatically.</span></span> <span data-ttu-id="676b2-107">由於 <xref:System.Transactions.TransactionScope> 類別非常容易使用且很有效率，在您開發交易應用程式時，建議您善加利用。</span><span class="sxs-lookup"><span data-stu-id="676b2-107">Due to its ease of use and efficiency, it is recommended that you use the <xref:System.Transactions.TransactionScope> class when developing a transaction application.</span></span>  
  
 <span data-ttu-id="676b2-108">此外，您不需要特別針對交易登記資源。</span><span class="sxs-lookup"><span data-stu-id="676b2-108">In addition, you do not need to enlist resources explicitly with the transaction.</span></span> <span data-ttu-id="676b2-109">任何的 <xref:System.Transactions> 資源管理員 (例如 SQL Server 2005) 都可以偵測到範圍所建立的環境交易並自動加以登記。</span><span class="sxs-lookup"><span data-stu-id="676b2-109">Any <xref:System.Transactions> resource manager (such as SQL Server 2005) can detect the existence of an ambient transaction created by the scope and automatically enlist.</span></span>  
  
## <a name="creating-a-transaction-scope"></a><span data-ttu-id="676b2-110">建立交易範圍</span><span class="sxs-lookup"><span data-stu-id="676b2-110">Creating a transaction scope</span></span>  
 <span data-ttu-id="676b2-111">下列範例說明了 <xref:System.Transactions.TransactionScope> 類別的簡易用途。</span><span class="sxs-lookup"><span data-stu-id="676b2-111">The following sample shows a simple usage of the <xref:System.Transactions.TransactionScope> class.</span></span>  
  
 [!code-csharp[TransactionScope#1](../../../../samples/snippets/csharp/VS_Snippets_Remoting/TransactionScope/cs/ScopeWithSQL.cs#1)]
 [!code-vb[TransactionScope#1](../../../../samples/snippets/visualbasic/VS_Snippets_Remoting/TransactionScope/vb/ScopeWithSQL.vb#1)]  
  
 <span data-ttu-id="676b2-112">當您建立新的物件之後，就會啟動交易範圍 <xref:System.Transactions.TransactionScope> 。</span><span class="sxs-lookup"><span data-stu-id="676b2-112">The transaction scope is started once you create a new <xref:System.Transactions.TransactionScope> object.</span></span>  <span data-ttu-id="676b2-113">如程式碼範例所示，建議您使用語句來建立範圍 `using` 。</span><span class="sxs-lookup"><span data-stu-id="676b2-113">As illustrated in the code sample, it is recommended that you create scopes with a `using` statement.</span></span> <span data-ttu-id="676b2-114">`using`語句在 c # 和 Visual Basic 中都有提供，而且其運作方式類似于 `try` ... `finally` 區塊，以確保已適當處置範圍。</span><span class="sxs-lookup"><span data-stu-id="676b2-114">The `using` statement is available both in C# and in Visual Basic, and works like a `try`...`finally` block to ensure that the scope is disposed of properly.</span></span>  
  
 <span data-ttu-id="676b2-115">當具現化 <xref:System.Transactions.TransactionScope> 時，交易管理員會決定要參與哪個交易。</span><span class="sxs-lookup"><span data-stu-id="676b2-115">When you instantiate <xref:System.Transactions.TransactionScope>, the transaction manager determines which transaction to participate in.</span></span> <span data-ttu-id="676b2-116">一旦決定後，範圍永遠會參與該異動。</span><span class="sxs-lookup"><span data-stu-id="676b2-116">Once determined, the scope always participates in that transaction.</span></span> <span data-ttu-id="676b2-117">此決策是根據兩個因素而定：環境異動是否存在，以及建構函式中的 `TransactionScopeOption` 參數值。</span><span class="sxs-lookup"><span data-stu-id="676b2-117">The decision is based on two factors: whether an ambient transaction is present and the value of the `TransactionScopeOption` parameter in the constructor.</span></span> <span data-ttu-id="676b2-118">環境交易就是要在其中執行程式碼的交易。</span><span class="sxs-lookup"><span data-stu-id="676b2-118">The ambient transaction is the transaction within which your code executes.</span></span> <span data-ttu-id="676b2-119">您可以呼叫 <xref:System.Transactions.Transaction.Current%2A?displayProperty=nameWithType> 類別的靜態 <xref:System.Transactions.Transaction> 屬性，取得環境交易的參考。</span><span class="sxs-lookup"><span data-stu-id="676b2-119">You can obtain a reference to the ambient transaction by calling the static <xref:System.Transactions.Transaction.Current%2A?displayProperty=nameWithType> property of the <xref:System.Transactions.Transaction> class.</span></span> <span data-ttu-id="676b2-120">如需如何使用此參數的詳細資訊，請參閱本主題的[使用 TransactionScopeOption 管理交易流程](#ManageTxFlow)一節。</span><span class="sxs-lookup"><span data-stu-id="676b2-120">For more information on how this parameter is used, see the [Managing transaction flow using TransactionScopeOption](#ManageTxFlow) section of this topic.</span></span>  
  
## <a name="completing-a-transaction-scope"></a><span data-ttu-id="676b2-121">完成交易範圍</span><span class="sxs-lookup"><span data-stu-id="676b2-121">Completing a transaction scope</span></span>  
 <span data-ttu-id="676b2-122">當您的應用程式完成所有要在交易中執行的工作後，您應該只呼叫 <xref:System.Transactions.TransactionScope.Complete%2A?displayProperty=nameWithType> 方法一次，以通知交易管理員可以接受認可交易。</span><span class="sxs-lookup"><span data-stu-id="676b2-122">When your application completes all the work it wants to perform in a transaction, you should call the <xref:System.Transactions.TransactionScope.Complete%2A?displayProperty=nameWithType> method only once to inform the transaction manager that it is acceptable to commit the transaction.</span></span> <span data-ttu-id="676b2-123">將呼叫放入 <xref:System.Transactions.TransactionScope.Complete%2A> 做為區塊中的最後一個語句是很好的作法 `using` 。</span><span class="sxs-lookup"><span data-stu-id="676b2-123">It is very good practice to put the call to <xref:System.Transactions.TransactionScope.Complete%2A> as the last statement in the `using` block.</span></span>  
  
 <span data-ttu-id="676b2-124">無法呼叫這個方法會中止交易，因為交易管理員將此視為系統失敗，或相當於交易範圍內所擲回的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="676b2-124">Failing to call this method aborts the transaction, because the transaction manager interprets this as a system failure, or equivalent to an exception thrown within the scope of the transaction.</span></span> <span data-ttu-id="676b2-125">不過，呼叫此方法並不保證會認可交易，</span><span class="sxs-lookup"><span data-stu-id="676b2-125">However, calling this method does not guarantee that the transaction wil be committed.</span></span> <span data-ttu-id="676b2-126">這只是將您的狀態告知異動管理員的方式。</span><span class="sxs-lookup"><span data-stu-id="676b2-126">It is merely a way of informing the transaction manager of your status.</span></span> <span data-ttu-id="676b2-127">在呼叫 <xref:System.Transactions.TransactionScope.Complete%2A> 方法後，您便無法再透過 <xref:System.Transactions.Transaction.Current%2A> 屬性存取環境交易，且嘗試這麼做會導致擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="676b2-127">After calling the <xref:System.Transactions.TransactionScope.Complete%2A> method, you can no longer access the ambient transaction by using the <xref:System.Transactions.Transaction.Current%2A> property, and attempting to do so will result in an exception being thrown.</span></span>  
  
 <span data-ttu-id="676b2-128">如果 <xref:System.Transactions.TransactionScope> 物件一開始就建立交易，則交易管理員認可交易的實際工作會在區塊的最後一行程式碼之後發生 `using` 。</span><span class="sxs-lookup"><span data-stu-id="676b2-128">If the <xref:System.Transactions.TransactionScope> object created the transaction initially, the actual work of committing the transaction by the transaction manager occurs after the last line of code in the `using` block.</span></span> <span data-ttu-id="676b2-129">如果該物件沒有建立交易，則每當 <xref:System.Transactions.CommittableTransaction.Commit%2A> 物件的擁有者呼叫 <xref:System.Transactions.CommittableTransaction> 時，便會發生認可。</span><span class="sxs-lookup"><span data-stu-id="676b2-129">If it did not create the transaction, the commit occurs whenever <xref:System.Transactions.CommittableTransaction.Commit%2A> is called by the owner of the <xref:System.Transactions.CommittableTransaction> object.</span></span> <span data-ttu-id="676b2-130">此時，交易管理員會呼叫資源管理員，並根據是否在物件上呼叫方法，通知它們認可或復原 <xref:System.Transactions.TransactionScope.Complete%2A> <xref:System.Transactions.TransactionScope> 。</span><span class="sxs-lookup"><span data-stu-id="676b2-130">At that point the transaction manager calls the resource managers and informs them to either commit or rollback, based on whether the <xref:System.Transactions.TransactionScope.Complete%2A> method was called on the <xref:System.Transactions.TransactionScope> object.</span></span>  
  
 <span data-ttu-id="676b2-131">`using`語句可確保 <xref:System.Transactions.TransactionScope.Dispose%2A> <xref:System.Transactions.TransactionScope> 即使發生例外狀況，也會呼叫物件的方法。</span><span class="sxs-lookup"><span data-stu-id="676b2-131">The `using` statement ensures that the <xref:System.Transactions.TransactionScope.Dispose%2A> method of the <xref:System.Transactions.TransactionScope> object is called even if an exception occurs.</span></span> <span data-ttu-id="676b2-132"><xref:System.Transactions.TransactionScope.Dispose%2A> 方法會標記交易範圍的結尾。</span><span class="sxs-lookup"><span data-stu-id="676b2-132">The <xref:System.Transactions.TransactionScope.Dispose%2A> method marks the end of the transaction scope.</span></span> <span data-ttu-id="676b2-133">在呼叫這個方法後發生的例外狀況不太可能會影響異動。</span><span class="sxs-lookup"><span data-stu-id="676b2-133">Exceptions that occur after calling this method may not affect the transaction.</span></span> <span data-ttu-id="676b2-134">這個方法也會將環境交易還原至其先前狀態。</span><span class="sxs-lookup"><span data-stu-id="676b2-134">This method also restores the ambient transaction to it previous state.</span></span>  
  
 <span data-ttu-id="676b2-135">如果範圍建立了交易，而且交易中止，則會擲回 <xref:System.Transactions.TransactionAbortedException>。</span><span class="sxs-lookup"><span data-stu-id="676b2-135">A <xref:System.Transactions.TransactionAbortedException> is thrown if the scope creates the transaction, and the transaction is aborted.</span></span> <span data-ttu-id="676b2-136">如果交易管理員無法做出認可決定，則會擲回 <xref:System.Transactions.TransactionInDoubtException>。</span><span class="sxs-lookup"><span data-stu-id="676b2-136">A <xref:System.Transactions.TransactionInDoubtException> is thrown if the transaction manager cannot reach a Commit decision.</span></span> <span data-ttu-id="676b2-137">如果認可交易，則不會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="676b2-137">No exception is thrown if the transaction is committed.</span></span>  
  
## <a name="rolling-back-a-transaction"></a><span data-ttu-id="676b2-138">復原交易</span><span class="sxs-lookup"><span data-stu-id="676b2-138">Rolling back a transaction</span></span>  
 <span data-ttu-id="676b2-139">如果您想復原交易，就不應該呼叫交易範圍內的 <xref:System.Transactions.TransactionScope.Complete%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="676b2-139">If you want to rollback a transaction, you should not call the <xref:System.Transactions.TransactionScope.Complete%2A> method within the transaction scope.</span></span> <span data-ttu-id="676b2-140">例如，您可以擲回範圍內的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="676b2-140">For example, you can throw an exception within the scope.</span></span> <span data-ttu-id="676b2-141">這樣可復原在範圍內參與的交易。</span><span class="sxs-lookup"><span data-stu-id="676b2-141">The transaction in which it participates in will be rolled back.</span></span>  
  
## <a name="managing-transaction-flow-using-transactionscopeoption"></a><a name="ManageTxFlow"></a><span data-ttu-id="676b2-142">使用 TransactionScopeOption 管理交易流程</span><span class="sxs-lookup"><span data-stu-id="676b2-142">Managing transaction flow using TransactionScopeOption</span></span>  
 <span data-ttu-id="676b2-143">您可以從使用本身範圍的方法中，呼叫使用 <xref:System.Transactions.TransactionScope> 的方法來巢狀化交易範圍，如下列範例中的 `RootMethod` 方法所示：</span><span class="sxs-lookup"><span data-stu-id="676b2-143">Transaction scope can be nested by calling a method that uses a <xref:System.Transactions.TransactionScope> from within a method that uses its own scope, as is the case with the `RootMethod` method in the following example,</span></span>  
  
```csharp  
void RootMethod()
{
    using(TransactionScope scope = new TransactionScope())
    {
        /* Perform transactional work here */
        SomeMethod();
        scope.Complete();
    }
}

void SomeMethod()
{
    using(TransactionScope scope = new TransactionScope())
    {
        /* Perform transactional work here */
        scope.Complete();
    }
}
```  
  
 <span data-ttu-id="676b2-144">最上層的交易範圍，我們稱為根範圍。</span><span class="sxs-lookup"><span data-stu-id="676b2-144">The top-most transaction scope is referred to as the root scope.</span></span>  
  
 <span data-ttu-id="676b2-145"><xref:System.Transactions.TransactionScope> 類別提供了幾項多載的建構函式以接受 <xref:System.Transactions.TransactionScopeOption> 型別的列舉，用來定義範圍的交易行為。</span><span class="sxs-lookup"><span data-stu-id="676b2-145">The <xref:System.Transactions.TransactionScope> class provides several overloaded constructors that accept an enumeration of the type <xref:System.Transactions.TransactionScopeOption>, which defines the transactional behavior of the scope.</span></span>  
  
 <span data-ttu-id="676b2-146"><xref:System.Transactions.TransactionScope> 物件包含三個選項：</span><span class="sxs-lookup"><span data-stu-id="676b2-146">A <xref:System.Transactions.TransactionScope> object has three options:</span></span>  
  
- <span data-ttu-id="676b2-147">聯結環境交易，如果環境交易不存在的話，則建立新的環境交易。</span><span class="sxs-lookup"><span data-stu-id="676b2-147">Join the ambient transaction, or create a new one if one does not exist.</span></span>  
  
- <span data-ttu-id="676b2-148">成為新的根範圍，意思就是開始新的交易並讓交易成為本身範圍中的新環境交易。</span><span class="sxs-lookup"><span data-stu-id="676b2-148">Be a new root scope, that is, start a new transaction and have that transaction be the new ambient transaction inside its own scope.</span></span>  
  
- <span data-ttu-id="676b2-149">完全不會參與交易。</span><span class="sxs-lookup"><span data-stu-id="676b2-149">Not take part in a transaction at all.</span></span> <span data-ttu-id="676b2-150">最後也不會產生環境交易。</span><span class="sxs-lookup"><span data-stu-id="676b2-150">There is no ambient transaction as a result.</span></span>  
  
 <span data-ttu-id="676b2-151">如果使用 <xref:System.Transactions.TransactionScopeOption.Required> 來具現化範圍，且存在環境交易，則範圍會聯結該交易。</span><span class="sxs-lookup"><span data-stu-id="676b2-151">If the scope is instantiated with <xref:System.Transactions.TransactionScopeOption.Required>, and an ambient transaction is present, the scope joins that transaction.</span></span> <span data-ttu-id="676b2-152">另一方面，如果不存在環境交易，則範圍會建立新的交易並成為根範圍。</span><span class="sxs-lookup"><span data-stu-id="676b2-152">If, on the other hand, there is no ambient transaction, then the scope creates a new transaction, and become the root scope.</span></span> <span data-ttu-id="676b2-153">這是預設值。</span><span class="sxs-lookup"><span data-stu-id="676b2-153">This is the default value.</span></span> <span data-ttu-id="676b2-154">如果使用 <xref:System.Transactions.TransactionScopeOption.Required>，則範圍內的程式碼不管本身是否為根，或僅僅聯結環境交易，都不需要做出不一樣的行為。</span><span class="sxs-lookup"><span data-stu-id="676b2-154">When <xref:System.Transactions.TransactionScopeOption.Required> is used, the code inside the scope does not need to behave differently whether it is the root or just joining the ambient transaction.</span></span> <span data-ttu-id="676b2-155">在兩種情況中，程式碼的行為應該完全一樣。</span><span class="sxs-lookup"><span data-stu-id="676b2-155">It should operate identically in both cases.</span></span>  
  
 <span data-ttu-id="676b2-156">如果使用 <xref:System.Transactions.TransactionScopeOption.RequiresNew> 來具現化範圍，則一律成為根範圍。</span><span class="sxs-lookup"><span data-stu-id="676b2-156">If the scope is instantiated with <xref:System.Transactions.TransactionScopeOption.RequiresNew>, it is always the root scope.</span></span> <span data-ttu-id="676b2-157">它會開始新的交易，且其交易會成為範圍內全新的環境交易。</span><span class="sxs-lookup"><span data-stu-id="676b2-157">It starts a new transaction, and its transaction becomes the new ambient transaction inside the scope.</span></span>  
  
 <span data-ttu-id="676b2-158">如果使用 <xref:System.Transactions.TransactionScopeOption.Suppress> 來具現化範圍，則永遠不會參與交易，不管是否存在環境交易皆然。</span><span class="sxs-lookup"><span data-stu-id="676b2-158">If the scope is instantiated with <xref:System.Transactions.TransactionScopeOption.Suppress>, it never takes part in a transaction, regardless of whether an ambient transaction is present.</span></span> <span data-ttu-id="676b2-159">以這個值具現化的範圍一律會做 `null` 為其環境交易。</span><span class="sxs-lookup"><span data-stu-id="676b2-159">A scope instantiated with this value always have `null` as its ambient transaction.</span></span>  
  
 <span data-ttu-id="676b2-160">茲將上列所有選項摘列至下表。</span><span class="sxs-lookup"><span data-stu-id="676b2-160">The above options are summarized in the following table.</span></span>  
  
|<span data-ttu-id="676b2-161">TransactionScopeOption</span><span class="sxs-lookup"><span data-stu-id="676b2-161">TransactionScopeOption</span></span>|<span data-ttu-id="676b2-162">環境交易</span><span class="sxs-lookup"><span data-stu-id="676b2-162">Ambient Transaction</span></span>|<span data-ttu-id="676b2-163">範圍會參與</span><span class="sxs-lookup"><span data-stu-id="676b2-163">The scope takes part in</span></span>|  
|----------------------------|-------------------------|-----------------------------|  
|<span data-ttu-id="676b2-164">必要</span><span class="sxs-lookup"><span data-stu-id="676b2-164">Required</span></span>|<span data-ttu-id="676b2-165">No</span><span class="sxs-lookup"><span data-stu-id="676b2-165">No</span></span>|<span data-ttu-id="676b2-166">新交易 (將為根)</span><span class="sxs-lookup"><span data-stu-id="676b2-166">New Transaction (will be the root)</span></span>|  
|<span data-ttu-id="676b2-167">必須是新交易</span><span class="sxs-lookup"><span data-stu-id="676b2-167">Requires New</span></span>|<span data-ttu-id="676b2-168">No</span><span class="sxs-lookup"><span data-stu-id="676b2-168">No</span></span>|<span data-ttu-id="676b2-169">新交易 (將為根)</span><span class="sxs-lookup"><span data-stu-id="676b2-169">New Transaction (will be the root)</span></span>|  
|<span data-ttu-id="676b2-170">隱藏</span><span class="sxs-lookup"><span data-stu-id="676b2-170">Suppress</span></span>|<span data-ttu-id="676b2-171">No</span><span class="sxs-lookup"><span data-stu-id="676b2-171">No</span></span>|<span data-ttu-id="676b2-172">無交易</span><span class="sxs-lookup"><span data-stu-id="676b2-172">No Transaction</span></span>|  
|<span data-ttu-id="676b2-173">必要</span><span class="sxs-lookup"><span data-stu-id="676b2-173">Required</span></span>|<span data-ttu-id="676b2-174">Yes</span><span class="sxs-lookup"><span data-stu-id="676b2-174">Yes</span></span>|<span data-ttu-id="676b2-175">環境交易</span><span class="sxs-lookup"><span data-stu-id="676b2-175">Ambient  Transaction</span></span>|  
|<span data-ttu-id="676b2-176">必須是新交易</span><span class="sxs-lookup"><span data-stu-id="676b2-176">Requires New</span></span>|<span data-ttu-id="676b2-177">Yes</span><span class="sxs-lookup"><span data-stu-id="676b2-177">Yes</span></span>|<span data-ttu-id="676b2-178">新交易 (將為根)</span><span class="sxs-lookup"><span data-stu-id="676b2-178">New Transaction (will be the root)</span></span>|  
|<span data-ttu-id="676b2-179">隱藏</span><span class="sxs-lookup"><span data-stu-id="676b2-179">Suppress</span></span>|<span data-ttu-id="676b2-180">Yes</span><span class="sxs-lookup"><span data-stu-id="676b2-180">Yes</span></span>|<span data-ttu-id="676b2-181">無交易</span><span class="sxs-lookup"><span data-stu-id="676b2-181">No Transaction</span></span>|  
  
 <span data-ttu-id="676b2-182">當 <xref:System.Transactions.TransactionScope> 物件聯結了現有的環境交易時，處理範圍物件可能不會結束交易，除非範圍中止交易。</span><span class="sxs-lookup"><span data-stu-id="676b2-182">When a <xref:System.Transactions.TransactionScope> object joins an existing ambient transaction, disposing of the scope object may not end the transaction, unless the scope aborts the transaction.</span></span> <span data-ttu-id="676b2-183">如果範圍交易是由根範圍所建立，則只有當根範圍已經處理完畢後才會呼叫 <xref:System.Transactions.CommittableTransaction.Commit%2A>。</span><span class="sxs-lookup"><span data-stu-id="676b2-183">If the ambient transaction was created by a root scope, only when the root scope is disposed of, does <xref:System.Transactions.CommittableTransaction.Commit%2A> get called on the transaction.</span></span> <span data-ttu-id="676b2-184">如果交易是手動建立的，則會在中止時或是建立者認可時結束。</span><span class="sxs-lookup"><span data-stu-id="676b2-184">If the transaction was created manually, the transaction ends when it is either aborted, or committed by its creator.</span></span>  
  
 <span data-ttu-id="676b2-185">下列範例所顯示的 <xref:System.Transactions.TransactionScope> 物件可建立三個巢狀範圍物件，而且每個物件都使用不同的 <xref:System.Transactions.TransactionScopeOption> 值來具現化。</span><span class="sxs-lookup"><span data-stu-id="676b2-185">The following example shows a <xref:System.Transactions.TransactionScope> object that creates three nested scope objects, each instantiated with a different <xref:System.Transactions.TransactionScopeOption> value.</span></span>  
  
```csharp  
using(TransactionScope scope1 = new TransactionScope())
//Default is Required
{
    using(TransactionScope scope2 = new TransactionScope(TransactionScopeOption.Required))
    {
        //...
    }

    using(TransactionScope scope3 = new TransactionScope(TransactionScopeOption.RequiresNew))
    {
        //...  
    }
  
    using(TransactionScope scope4 = new TransactionScope(TransactionScopeOption.Suppress))
    {
        //...  
    }
}
```  
  
 <span data-ttu-id="676b2-186">在此範例程式碼區段中，不使用任何環境交易，而是以 `scope1` 來建立新範圍 (<xref:System.Transactions.TransactionScopeOption.Required>)。</span><span class="sxs-lookup"><span data-stu-id="676b2-186">The example shows a code block without any ambient transaction creating a new scope (`scope1`) with <xref:System.Transactions.TransactionScopeOption.Required>.</span></span> <span data-ttu-id="676b2-187">`scope1` 範圍在建立新交易 (交易 A) 時會成為根範圍，並讓交易 A 成為環境交易。</span><span class="sxs-lookup"><span data-stu-id="676b2-187">The scope `scope1` is a root scope as it creates a new transaction (Transaction A) and makes Transaction A the ambient transaction.</span></span> <span data-ttu-id="676b2-188">`Scope1`然後再建立三個物件，每個都有不同的 <xref:System.Transactions.TransactionScopeOption> 值。</span><span class="sxs-lookup"><span data-stu-id="676b2-188">`Scope1` then creates three more objects, each with a different <xref:System.Transactions.TransactionScopeOption> value.</span></span> <span data-ttu-id="676b2-189">例如，`scope2` 是由 <xref:System.Transactions.TransactionScopeOption.Required> 所建立，而且因為環境交易已經存在，該範圍就會聯結由 `scope1` 所建立的第一個交易。</span><span class="sxs-lookup"><span data-stu-id="676b2-189">For example, `scope2` is created with <xref:System.Transactions.TransactionScopeOption.Required>, and since there is an ambient transaction, it joins the first transaction created by `scope1`.</span></span> <span data-ttu-id="676b2-190">請注意，`scope3` 是新交易的根範圍，而且 `scope4` 不包含任何環境交易。</span><span class="sxs-lookup"><span data-stu-id="676b2-190">Note that `scope3` is the root scope of a new transaction, and that `scope4` has no ambient transaction.</span></span>  
  
 <span data-ttu-id="676b2-191">儘管預設且最常用的 <xref:System.Transactions.TransactionScopeOption> 值是 <xref:System.Transactions.TransactionScopeOption.Required>，其他所有值每個都具有唯一的用途。</span><span class="sxs-lookup"><span data-stu-id="676b2-191">Although the default and most commonly used value of <xref:System.Transactions.TransactionScopeOption> is <xref:System.Transactions.TransactionScopeOption.Required>, each of the other values has its unique purpose.</span></span>  

### <a name="non-transactional-code-inside-a-transaction-scope"></a><span data-ttu-id="676b2-192">交易範圍內的非交易式程式碼</span><span class="sxs-lookup"><span data-stu-id="676b2-192">Non-transactional code inside a transaction scope</span></span>

 <span data-ttu-id="676b2-193"><xref:System.Transactions.TransactionScopeOption.Suppress>當您想要保留程式碼區段所執行的作業，而且不想在作業失敗時中止環境交易時，會很有用。</span><span class="sxs-lookup"><span data-stu-id="676b2-193"><xref:System.Transactions.TransactionScopeOption.Suppress> is useful when you want to preserve the operations performed by the code section, and do not want to abort the ambient transaction if the operations fail.</span></span> <span data-ttu-id="676b2-194">例如，當您想要執行記錄或稽核作業，或是當您想要將事件發行到訂閱者時 (不管您的環境交易是否已經認可或中止)。</span><span class="sxs-lookup"><span data-stu-id="676b2-194">For example, when you want to perform logging or audit operations, or when you want to publish events to subscribers regardless of whether your ambient transaction commits or aborts.</span></span> <span data-ttu-id="676b2-195">此值可允許您在交易範圍內保有一段非交易式程式碼，如下列範例所示。</span><span class="sxs-lookup"><span data-stu-id="676b2-195">This value allows you to have a non-transactional code section inside a transaction scope, as shown in the following example.</span></span>  
  
```csharp  
using(TransactionScope scope1 = new TransactionScope())
{
    try
    {
        //Start of non-transactional section
        using(TransactionScope scope2 = new
            TransactionScope(TransactionScopeOption.Suppress))  
        {  
            //Do non-transactional work here  
        }  
        //Restores ambient transaction here
   }
   catch {}  
   //Rest of scope1
}
```  
  
### <a name="voting-inside-a-nested-scope"></a><span data-ttu-id="676b2-196">在巢狀範圍內投票</span><span class="sxs-lookup"><span data-stu-id="676b2-196">Voting inside a nested scope</span></span>  
 <span data-ttu-id="676b2-197">雖然巢狀範圍可以聯結根範圍的環境交易，呼叫巢狀範圍中的 <xref:System.Transactions.TransactionScope.Complete%2A> 不會對根範圍有任何影響。</span><span class="sxs-lookup"><span data-stu-id="676b2-197">Although a nested scope can join the ambient transaction of the root scope, calling <xref:System.Transactions.TransactionScope.Complete%2A> in the nested scope has no affect on the root scope.</span></span> <span data-ttu-id="676b2-198">只有當從根範圍一直到最後一個巢狀範圍的所有範圍都投票認可交易，交易才算真正受到認可。</span><span class="sxs-lookup"><span data-stu-id="676b2-198">Only if all the scopes from the root scope down to the last nested scope vote to commit the transaction, will the transaction be committed.</span></span> <span data-ttu-id="676b2-199">若不在巢狀範圍中呼叫 <xref:System.Transactions.TransactionScope.Complete%2A>，將影響根範圍，因為環境交易會立即中止。</span><span class="sxs-lookup"><span data-stu-id="676b2-199">Not calling <xref:System.Transactions.TransactionScope.Complete%2A> in a nested scope will affect the root scope as the ambient transaction will immediately be aborted.</span></span>  
  
## <a name="setting-the-transactionscope-timeout"></a><span data-ttu-id="676b2-200">設定 TransactionScope 逾時</span><span class="sxs-lookup"><span data-stu-id="676b2-200">Setting the TransactionScope timeout</span></span>  
 <span data-ttu-id="676b2-201">某些多載的 <xref:System.Transactions.TransactionScope> 建構函式可接受 <xref:System.TimeSpan> 型別的值，以控制交易的逾時。</span><span class="sxs-lookup"><span data-stu-id="676b2-201">Some of the overloaded constructors of <xref:System.Transactions.TransactionScope> accept a value of type <xref:System.TimeSpan>, which is used to control the timeout of the transaction.</span></span> <span data-ttu-id="676b2-202">設為零的逾時代表無限逾時。</span><span class="sxs-lookup"><span data-stu-id="676b2-202">A timeout set to zero means an infinite timeout.</span></span> <span data-ttu-id="676b2-203">無限逾時最主要用在偵錯上。當您想要藉由逐步執行程式碼來隔離商務邏輯中的某個問題，但是不想要在嘗試找到問題之前讓進行偵錯的交易發生逾時，就可以使用無限逾時。</span><span class="sxs-lookup"><span data-stu-id="676b2-203">Infinite timeout is useful mostly for debugging, when you want to isolate a problem in your business logic by stepping through your code, and you do not want the transaction you debug to time out while you attempt to locate the problem.</span></span> <span data-ttu-id="676b2-204">在其他所有情況下使用無限逾時值時請務必特別小心，因為它會在碰到交易死結時覆寫防護措施。</span><span class="sxs-lookup"><span data-stu-id="676b2-204">Be extremely careful using the infinite timeout value in all other cases, because it overrides the safeguards against transaction deadlocks.</span></span>  
  
 <span data-ttu-id="676b2-205">在下列兩種情況中，通常您需要將 <xref:System.Transactions.TransactionScope> 逾時值設為預設以外的值。</span><span class="sxs-lookup"><span data-stu-id="676b2-205">You typically set the <xref:System.Transactions.TransactionScope> timeout to values other than default in two cases.</span></span> <span data-ttu-id="676b2-206">第一個情況是在開發階段，當您想要測試應用程式處理中止交易的方式時。</span><span class="sxs-lookup"><span data-stu-id="676b2-206">The first is during development, when you want to test the way your application handles aborted transactions.</span></span> <span data-ttu-id="676b2-207">您可以將逾時值設為較小的值 (例如 1 毫秒)，藉此讓交易失敗，並據此觀察錯誤處理程式碼。</span><span class="sxs-lookup"><span data-stu-id="676b2-207">By setting the timeout to a small value (such as one millisecond), you cause your transaction to fail and can thus observe your error handling code.</span></span> <span data-ttu-id="676b2-208">第二個情況是當您認為資源爭用情況涉及範圍並導致死結時，可以將此值設為小於預設逾時值。</span><span class="sxs-lookup"><span data-stu-id="676b2-208">The second case in which you set the value to be less than the default timeout is when you believe that the scope is involved in resource contention, resulting in deadlocks.</span></span> <span data-ttu-id="676b2-209">在此情況中，您希望儘快中止交易，而且不想等候預設逾時時間到期。</span><span class="sxs-lookup"><span data-stu-id="676b2-209">In that case, you want to abort the transaction as soon as possible and not wait for the default timeout to expire.</span></span>  
  
 <span data-ttu-id="676b2-210">當範圍聯結了環境交易但卻指定了小於環境交易所設定的逾時值時，就會在 <xref:System.Transactions.TransactionScope> 物件上強制執行新的、時間較短的逾時值，而且範圍必須在指定的巢狀時間內結束，否則交易會自動中止。</span><span class="sxs-lookup"><span data-stu-id="676b2-210">When a scope joins an ambient transaction but specifies a smaller timeout than the one the ambient transaction is set to, the new, shorter timeout is enforced on the <xref:System.Transactions.TransactionScope> object, and the scope must end within the nested time specified, or the transaction is automatically aborted.</span></span> <span data-ttu-id="676b2-211">如果巢狀範圍的逾時值大於環境交易的逾時值，將無法產生任何作用。</span><span class="sxs-lookup"><span data-stu-id="676b2-211">If the nested scope's timeout is more than that of the ambient transaction, it has no effect.</span></span>  
  
## <a name="setting-the-transactionscope-isolation-level"></a><span data-ttu-id="676b2-212">設定 TransactionScope 隔離等級</span><span class="sxs-lookup"><span data-stu-id="676b2-212">Setting the TransactionScope isolation level</span></span>  
 <span data-ttu-id="676b2-213">某些多載的 <xref:System.Transactions.TransactionScope> 建構函式可接受 <xref:System.Transactions.TransactionOptions> 型別的結構，以便指定逾時值以外的隔離等級。</span><span class="sxs-lookup"><span data-stu-id="676b2-213">Some of the overloaded constructors of <xref:System.Transactions.TransactionScope> accept a structure of type <xref:System.Transactions.TransactionOptions> to specify an isolation level, in addition to a timeout value.</span></span> <span data-ttu-id="676b2-214">根據預設，交易會在隔離等級設為 <xref:System.Transactions.IsolationLevel.Serializable> 時執行。</span><span class="sxs-lookup"><span data-stu-id="676b2-214">By default, the transaction executes with isolation level set to <xref:System.Transactions.IsolationLevel.Serializable>.</span></span> <span data-ttu-id="676b2-215">在讀取頻繁的系統上，常常會選取使用 <xref:System.Transactions.IsolationLevel.Serializable> 以外的隔離等級。</span><span class="sxs-lookup"><span data-stu-id="676b2-215">Selecting an isolation level other than <xref:System.Transactions.IsolationLevel.Serializable> is commonly used for read-intensive systems.</span></span> <span data-ttu-id="676b2-216">要這麼做之前，需要先對交易處理理論、交易本身的語意、牽涉到的並行問題，以及對系統一致性的影響有很深入的了解才行。</span><span class="sxs-lookup"><span data-stu-id="676b2-216">This requires a solid understanding of transaction processing theory and the semantics of the transaction itself, the concurrency issues involved, and the consequences for system consistency.</span></span>  
  
 <span data-ttu-id="676b2-217">此外，並非所有資源管理員都支援所有隔離等級，而且這些等級可能會選擇參與比所設定等級還要高的交易。</span><span class="sxs-lookup"><span data-stu-id="676b2-217">In addition, not all resource managers support all levels of isolation, and they may elect to take part in the transaction at a higher level than the one configured.</span></span>  
  
 <span data-ttu-id="676b2-218">包括 <xref:System.Transactions.IsolationLevel.Serializable> 的每個隔離等級都很容易因為其他交易項目存取相同資訊而產生不一致的情況。</span><span class="sxs-lookup"><span data-stu-id="676b2-218">Every isolation level besides <xref:System.Transactions.IsolationLevel.Serializable> is susceptible to inconsistency resulting from other transactions accessing the same information.</span></span> <span data-ttu-id="676b2-219">各種隔離等級的差異在於讀取/寫入鎖定的使用方式。</span><span class="sxs-lookup"><span data-stu-id="676b2-219">The difference between the different isolation levels is in the way read and write locks are used.</span></span> <span data-ttu-id="676b2-220">鎖定只有在交易項目存取資源管理員中的資料時才能暫停，或者可在認可或中止交易之前一直保持暫停。</span><span class="sxs-lookup"><span data-stu-id="676b2-220">A lock can be held only when the transaction accesses the data in the resource manager, or it can be held until the transaction is committed or aborted.</span></span> <span data-ttu-id="676b2-221">前者對於輸送量會有幫助，而後者則是容易保持一致性。</span><span class="sxs-lookup"><span data-stu-id="676b2-221">The former is better for throughput, the latter for consistency.</span></span> <span data-ttu-id="676b2-222">兩種鎖定方式加上兩種作業 (讀/寫) 方式，總共是四種基本的隔離等級。</span><span class="sxs-lookup"><span data-stu-id="676b2-222">The two kinds of locks and the two kinds of operations (read/write) give four basic isolation levels.</span></span> <span data-ttu-id="676b2-223">如需相關資訊，請參閱 <xref:System.Transactions.IsolationLevel> 。</span><span class="sxs-lookup"><span data-stu-id="676b2-223">See <xref:System.Transactions.IsolationLevel> for more information.</span></span>  
  
 <span data-ttu-id="676b2-224">在使用巢狀 <xref:System.Transactions.TransactionScope> 物件時，如果想要聯結環境交易，則所有巢狀範圍必須設定為使用完全相同的隔離等級。</span><span class="sxs-lookup"><span data-stu-id="676b2-224">When using nested <xref:System.Transactions.TransactionScope> objects, all nested scopes must be configured to use exactly the same isolation level if they want to join the ambient transaction.</span></span> <span data-ttu-id="676b2-225">如果巢狀 <xref:System.Transactions.TransactionScope> 物件嘗試聯結環境交易，但卻指定了不同的隔離等級，則會擲回 <xref:System.ArgumentException>。</span><span class="sxs-lookup"><span data-stu-id="676b2-225">If a nested <xref:System.Transactions.TransactionScope> object tries to join the ambient transaction yet it specifies a different isolation level, an <xref:System.ArgumentException> is thrown.</span></span>  
  
## <a name="interop-with-com"></a><span data-ttu-id="676b2-226">和 COM+ 互通</span><span class="sxs-lookup"><span data-stu-id="676b2-226">Interop with COM+</span></span>  
 <span data-ttu-id="676b2-227">當您建立新的 <xref:System.Transactions.TransactionScope> 執行個體時，可以使用其中一個建構函式中的 <xref:System.Transactions.EnterpriseServicesInteropOption> 列舉型別來指定與 COM+ 的互動方式。</span><span class="sxs-lookup"><span data-stu-id="676b2-227">When you create a new <xref:System.Transactions.TransactionScope> instance, you can use the <xref:System.Transactions.EnterpriseServicesInteropOption> enumeration in one of the constructors to specify how to interact with COM+.</span></span> <span data-ttu-id="676b2-228">如需這方面的詳細資訊，請參閱[與企業服務和 COM + 交易的互通性](interoperability-with-enterprise-services-and-com-transactions.md)。</span><span class="sxs-lookup"><span data-stu-id="676b2-228">For more information on this, see [Interoperability with Enterprise Services and COM+ Transactions](interoperability-with-enterprise-services-and-com-transactions.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="676b2-229">另請參閱</span><span class="sxs-lookup"><span data-stu-id="676b2-229">See also</span></span>

- <xref:System.Transactions.Transaction.Clone%2A>
- <xref:System.Transactions.TransactionScope>
