---
title: 啟用 LINQ Querying2 的資料來源
ms.date: 07/20/2015
ms.assetid: c412f0cf-ff0e-4993-ab3d-1b49e23f00f8
ms.openlocfilehash: a60527f0594964ec9642cdd565fd06eb5d46cf85
ms.sourcegitcommit: bf5c5850654187705bc94cc40ebfb62fe346ab02
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 09/23/2020
ms.locfileid: "91078342"
---
# <a name="enabling-a-data-source-for-linq-querying"></a><span data-ttu-id="b6a1f-102">啟用資料來源以進行 LINQ 查詢</span><span class="sxs-lookup"><span data-stu-id="b6a1f-102">Enabling a Data Source for LINQ Querying</span></span>

<span data-ttu-id="b6a1f-103">有多種方式可以擴充 LINQ，讓任何資料來源可在 LINQ 模式中進行查詢。</span><span class="sxs-lookup"><span data-stu-id="b6a1f-103">There are various ways to extend LINQ to enable any data source to be queried in the LINQ pattern.</span></span> <span data-ttu-id="b6a1f-104">資料來源可能是資料結構、Web 服務、檔案系統或資料庫等等。</span><span class="sxs-lookup"><span data-stu-id="b6a1f-104">The data source might be a data structure, a Web service, a file system, or a database, to name some.</span></span> <span data-ttu-id="b6a1f-105">LINQ 模式方便用戶端查詢已啟用 LINQ 查詢的資料來源，因為查詢的語法和模式不會變更。</span><span class="sxs-lookup"><span data-stu-id="b6a1f-105">The LINQ pattern makes it easy for clients to query a data source for which LINQ querying is enabled, because the syntax and pattern of the query does not change.</span></span> <span data-ttu-id="b6a1f-106">LINQ 可以擴充至這些資料來源的方式包括下列各項：</span><span class="sxs-lookup"><span data-stu-id="b6a1f-106">The ways in which LINQ can be extended to these data sources include the following:</span></span>

- <span data-ttu-id="b6a1f-107"><xref:System.Collections.Generic.IEnumerable%601>在類型中執行介面，以啟用該類型的 LINQ to Objects 查詢。</span><span class="sxs-lookup"><span data-stu-id="b6a1f-107">Implementing the <xref:System.Collections.Generic.IEnumerable%601> interface in a type to enable LINQ to Objects querying of that type.</span></span>

- <span data-ttu-id="b6a1f-108">建立擴充類型的標準查詢運算子方法（例如 <xref:System.Linq.Enumerable.Where%2A> 和 <xref:System.Linq.Enumerable.Select%2A> ），以啟用該類型的自訂 LINQ 查詢。</span><span class="sxs-lookup"><span data-stu-id="b6a1f-108">Creating standard query operator methods such as <xref:System.Linq.Enumerable.Where%2A> and <xref:System.Linq.Enumerable.Select%2A> that extend a type, to enable custom LINQ querying of that type.</span></span>

- <span data-ttu-id="b6a1f-109">為資料來源建立實作 <xref:System.Linq.IQueryable%601> 介面的提供者。</span><span class="sxs-lookup"><span data-stu-id="b6a1f-109">Creating a provider for your data source that implements the <xref:System.Linq.IQueryable%601> interface.</span></span> <span data-ttu-id="b6a1f-110">實作為此介面的提供者會以運算式樹狀架構的形式接收 LINQ 查詢，它可以用自訂方式（例如遠端）執行。</span><span class="sxs-lookup"><span data-stu-id="b6a1f-110">A provider that implements this interface receives LINQ queries in the form of expression trees, which it can execute in a custom way, for example remotely.</span></span>

- <span data-ttu-id="b6a1f-111">為數據源建立利用現有 LINQ 技術的提供者。</span><span class="sxs-lookup"><span data-stu-id="b6a1f-111">Creating a provider for your data source that takes advantage of an existing LINQ technology.</span></span> <span data-ttu-id="b6a1f-112">這種提供者不只會啟用查詢功能，也會插入、更新及刪除使用者定義類型的作業和對應。</span><span class="sxs-lookup"><span data-stu-id="b6a1f-112">Such a provider would enable not only querying, but also insert, update, and delete operations and mapping for user-defined types.</span></span>

<span data-ttu-id="b6a1f-113">本主題將討論這些選項。</span><span class="sxs-lookup"><span data-stu-id="b6a1f-113">This topic discusses these options.</span></span>

## <a name="how-to-enable-linq-querying-of-your-data-source"></a><span data-ttu-id="b6a1f-114">如何啟用資料來源的 LINQ 查詢功能</span><span class="sxs-lookup"><span data-stu-id="b6a1f-114">How to Enable LINQ Querying of Your Data Source</span></span>

### <a name="in-memory-data"></a><span data-ttu-id="b6a1f-115">記憶體中的資料</span><span class="sxs-lookup"><span data-stu-id="b6a1f-115">In-Memory Data</span></span>

 <span data-ttu-id="b6a1f-116">您可以使用兩種方式來啟用記憶體中資料的 LINQ 查詢。</span><span class="sxs-lookup"><span data-stu-id="b6a1f-116">There are two ways you can enable LINQ querying of in-memory data.</span></span> <span data-ttu-id="b6a1f-117">如果資料是實作為的型別 <xref:System.Collections.Generic.IEnumerable%601> ，您可以使用 LINQ to Objects 來查詢資料。</span><span class="sxs-lookup"><span data-stu-id="b6a1f-117">If the data is of a type that implements <xref:System.Collections.Generic.IEnumerable%601>, you can query the data by using LINQ to Objects.</span></span> <span data-ttu-id="b6a1f-118">如果透過實作為型別來啟用型別的列舉並不合理 <xref:System.Collections.Generic.IEnumerable%601> ，您可以在該型別中定義 linq 標準查詢運算子方法，或是建立可延伸型別的 linq 標準查詢運算子方法。</span><span class="sxs-lookup"><span data-stu-id="b6a1f-118">If it does not make sense to enable enumeration of your type by implementing the <xref:System.Collections.Generic.IEnumerable%601> interface, you can define LINQ standard query operator methods in that type or create LINQ standard query operator methods that extend the type.</span></span> <span data-ttu-id="b6a1f-119">標準查詢運算子的自訂實作 (Implementation) 應該會使用延後執行 (Deferred Execution) 來傳回結果。</span><span class="sxs-lookup"><span data-stu-id="b6a1f-119">Custom implementations of the standard query operators should use deferred execution to return the results.</span></span>

### <a name="remote-data"></a><span data-ttu-id="b6a1f-120">遠端資料</span><span class="sxs-lookup"><span data-stu-id="b6a1f-120">Remote Data</span></span>

 <span data-ttu-id="b6a1f-121">啟用遠端資料源之 LINQ 查詢的最佳選項是執行 <xref:System.Linq.IQueryable%601> 介面。</span><span class="sxs-lookup"><span data-stu-id="b6a1f-121">The best option for enabling LINQ querying of a remote data source is to implement the <xref:System.Linq.IQueryable%601> interface.</span></span> <span data-ttu-id="b6a1f-122">不過，這與擴充資料來源之提供者 (例如 [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)]) 不同。</span><span class="sxs-lookup"><span data-stu-id="b6a1f-122">However, this differs from extending a provider such as [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] for a data source.</span></span> <span data-ttu-id="b6a1f-123">在 Visual Studio 2008 中，沒有任何提供者模型可用來將現有的 LINQ 技術（例如 [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] ）擴充至其他資料來源類型。</span><span class="sxs-lookup"><span data-stu-id="b6a1f-123">No provider models for extending existing LINQ technologies, such as [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)], to other types of data source are available in Visual Studio 2008.</span></span>

## <a name="iqueryable-linq-providers"></a><span data-ttu-id="b6a1f-124">IQueryable LINQ 提供者</span><span class="sxs-lookup"><span data-stu-id="b6a1f-124">IQueryable LINQ Providers</span></span>

 <span data-ttu-id="b6a1f-125">執行的 LINQ 提供者 <xref:System.Linq.IQueryable%601> 在其複雜性上可能會有很大的差異。</span><span class="sxs-lookup"><span data-stu-id="b6a1f-125">LINQ providers that implement <xref:System.Linq.IQueryable%601> can vary widely in their complexity.</span></span> <span data-ttu-id="b6a1f-126">本節將討論不同層次的複雜度。</span><span class="sxs-lookup"><span data-stu-id="b6a1f-126">This section discusses the different levels of complexity.</span></span>

 <span data-ttu-id="b6a1f-127">複雜度較低的 `IQueryable` 提供者可能會與 Web 服務的單一方法互動。</span><span class="sxs-lookup"><span data-stu-id="b6a1f-127">A less complex `IQueryable` provider might interface with a single method of a Web service.</span></span> <span data-ttu-id="b6a1f-128">這種類型的提供者非常特別，因為它預期本身所處理的查詢中應該有特定的資訊。</span><span class="sxs-lookup"><span data-stu-id="b6a1f-128">This type of provider is very specific because it expects specific information in the queries that it handles.</span></span> <span data-ttu-id="b6a1f-129">這種提供者具有封閉類型系統，可能會公開單一結果類型。</span><span class="sxs-lookup"><span data-stu-id="b6a1f-129">It has a closed type system, perhaps exposing a single result type.</span></span> <span data-ttu-id="b6a1f-130">多數的查詢執行工作都是在本機進行，例如利用標準查詢運算子的 <xref:System.Linq.Enumerable> 實作。</span><span class="sxs-lookup"><span data-stu-id="b6a1f-130">Most of the execution of the query occurs locally, for example by using the <xref:System.Linq.Enumerable> implementations of the standard query operators.</span></span> <span data-ttu-id="b6a1f-131">複雜度較低的提供者可能只會在代表查詢的運算式樹狀架構中檢查一個方法呼叫運算式，並讓查詢的其餘邏輯在其他地方處理。</span><span class="sxs-lookup"><span data-stu-id="b6a1f-131">A less complex provider might examine only one method call expression in the expression tree that represents the query, and let the remaining logic of the query be handled elsewhere.</span></span>

 <span data-ttu-id="b6a1f-132">複雜度中等的 `IQueryable` 提供者可能以具有部分表示查詢語言的資料來源為目標。</span><span class="sxs-lookup"><span data-stu-id="b6a1f-132">An `IQueryable` provider of medium complexity might target a data source that has a partially expressive query language.</span></span> <span data-ttu-id="b6a1f-133">若以 Web 服務做為目標，則其可能與該 Web 服務的多個方法連結，並依據查詢所提出的問題來選取要呼叫的方法。</span><span class="sxs-lookup"><span data-stu-id="b6a1f-133">If it targets a Web service, it might interface with more than one method of the Web service and select the method to call based on the question that the query poses.</span></span> <span data-ttu-id="b6a1f-134">中等複雜度的提供者擁有的類型系統雖然比簡單提供者更為多樣化，但仍然為固定類型系統。</span><span class="sxs-lookup"><span data-stu-id="b6a1f-134">A provider of medium complexity would have a richer type system than a simple provider, but it would still be a fixed type system.</span></span> <span data-ttu-id="b6a1f-135">例如，提供者可能會公開具有可周遊的一對多關聯性 (One-To-Many Relationship)，但卻不會提供使用者定義類型的對應。</span><span class="sxs-lookup"><span data-stu-id="b6a1f-135">For example, the provider might expose types that have one-to-many relationships that can be traversed, but it would not provide mapping technology for user-defined types.</span></span>

 <span data-ttu-id="b6a1f-136">複雜的 `IQueryable` 提供者（例如 [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] 提供者）可能會將完整的 LINQ 查詢轉譯成表達查詢語言，例如 SQL。</span><span class="sxs-lookup"><span data-stu-id="b6a1f-136">A complex `IQueryable` provider, such as the [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] provider, might translate complete LINQ queries to an expressive query language, such as SQL.</span></span> <span data-ttu-id="b6a1f-137">複雜的提供者比複雜度較低的提供者更為廣泛，因為它可以在查詢中處理更多種類的問題。</span><span class="sxs-lookup"><span data-stu-id="b6a1f-137">A complex provider is more general than a less complex provider, because it can handle a wider variety of questions in the query.</span></span> <span data-ttu-id="b6a1f-138">它也具有開放類型系統，因此必須包含廣泛的基礎結構，以對應使用者定義的類型。</span><span class="sxs-lookup"><span data-stu-id="b6a1f-138">It also has an open type system and therefore must contain extensive infrastructure to map user-defined types.</span></span> <span data-ttu-id="b6a1f-139">開發複雜的提供者需要花費相當大量的心力。</span><span class="sxs-lookup"><span data-stu-id="b6a1f-139">Developing a complex provider requires a significant amount of effort.</span></span>

## <a name="see-also"></a><span data-ttu-id="b6a1f-140">另請參閱</span><span class="sxs-lookup"><span data-stu-id="b6a1f-140">See also</span></span>

- <xref:System.Linq.IQueryable%601>
- <xref:System.Collections.Generic.IEnumerable%601>
- <xref:System.Linq.Enumerable>
- [<span data-ttu-id="b6a1f-141">標準查詢運算子概觀 (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="b6a1f-141">Standard Query Operators Overview (Visual Basic)</span></span>](standard-query-operators-overview.md)
- [<span data-ttu-id="b6a1f-142">LINQ to Objects (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="b6a1f-142">LINQ to Objects (Visual Basic)</span></span>](linq-to-objects.md)
