---
title: EventWaitHandle
ms.date: 03/30/2017
helpviewer_keywords:
- threading [.NET], EventWaitHandle class
- EventWaitHandle class
- event wait handles [.NET]
- threading [.NET], cross-process synchronization
ms.assetid: 11ee0b38-d663-4617-b793-35eb6c64e9fc
ms.openlocfilehash: 078bda2354a6f0aec2215b0c5da2a021f53ff922
ms.sourcegitcommit: d8020797a6657d0fbbdff362b80300815f682f94
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 11/24/2020
ms.locfileid: "95723780"
---
# <a name="eventwaithandle"></a><span data-ttu-id="970fe-102">EventWaitHandle</span><span class="sxs-lookup"><span data-stu-id="970fe-102">EventWaitHandle</span></span>

<span data-ttu-id="970fe-103"><xref:System.Threading.EventWaitHandle> 類別可讓執行緒藉由發出訊號及等候訊號來互相進行通訊。</span><span class="sxs-lookup"><span data-stu-id="970fe-103">The <xref:System.Threading.EventWaitHandle> class allows threads to communicate with each other by signaling and by waiting for signals.</span></span> <span data-ttu-id="970fe-104">事件等候控制代碼 (也簡單稱為事件) 是可接收訊號來釋出一或多個等候執行緒的等候控制代碼。</span><span class="sxs-lookup"><span data-stu-id="970fe-104">Event wait handles (also referred to simply as events) are wait handles that can be signaled in order to release one or more waiting threads.</span></span> <span data-ttu-id="970fe-105">收到訊號之後，可以手動或自動重設事件等候控制代碼。</span><span class="sxs-lookup"><span data-stu-id="970fe-105">After it is signaled, an event wait handle is reset either manually or automatically.</span></span> <span data-ttu-id="970fe-106"><xref:System.Threading.EventWaitHandle> 類別可以代表本機事件等候控制代碼 (本機事件) 或具名的系統事件等候控制代碼 (所有處理序都可看見的具名事件或系統事件)。</span><span class="sxs-lookup"><span data-stu-id="970fe-106">The <xref:System.Threading.EventWaitHandle> class can represent either a local event wait handle (local event) or a named system event wait handle (named event or system event, visible to all processes).</span></span>  
  
> [!NOTE]
> <span data-ttu-id="970fe-107">事件等候控制代碼不是 .NET [事件](../events/index.md)。</span><span class="sxs-lookup"><span data-stu-id="970fe-107">Event wait handles are not .NET [events](../events/index.md).</span></span> <span data-ttu-id="970fe-108">其中並不涉及任何委派或事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="970fe-108">There are no delegates or event handlers involved.</span></span> <span data-ttu-id="970fe-109">「事件」一字是用來描述它們，因為傳統上將它們稱為作業系統事件，並且因為向等候控制代碼發出訊號的動作會向等候執行緒指出某個事件已發生。</span><span class="sxs-lookup"><span data-stu-id="970fe-109">The word "event" is used to describe them because they have traditionally been referred to as operating-system events, and because the act of signaling the wait handle indicates to waiting threads that an event has occurred.</span></span>  
  
 <span data-ttu-id="970fe-110">本機和具名事件等候控制代碼都會使用系統同步處理作業物件，<xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> 包裝函式會保護這些物件以確保資源被釋出。</span><span class="sxs-lookup"><span data-stu-id="970fe-110">Both local and named event wait handles use system synchronization objects, which are protected by <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> wrappers to ensure that the resources are released.</span></span> <span data-ttu-id="970fe-111">當您已使用完物件時，可以使用 <xref:System.Threading.WaitHandle.Dispose%2A> 方法來立即釋出資源。</span><span class="sxs-lookup"><span data-stu-id="970fe-111">You can use the <xref:System.Threading.WaitHandle.Dispose%2A> method to free the resources immediately when you have finished using the object.</span></span>  
  
## <a name="event-wait-handles-that-reset-automatically"></a><span data-ttu-id="970fe-112">自動重設的事件等候控制代碼</span><span class="sxs-lookup"><span data-stu-id="970fe-112">Event Wait Handles That Reset Automatically</span></span>  

 <span data-ttu-id="970fe-113">您可以在建立 <xref:System.Threading.EventWaitHandle> 物件時指定 <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType>，來建立自動重設事件。</span><span class="sxs-lookup"><span data-stu-id="970fe-113">You create an automatic reset event by specifying <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> when you create the <xref:System.Threading.EventWaitHandle> object.</span></span> <span data-ttu-id="970fe-114">正如其名，此同步處理事件在收到訊號並釋出一個等候執行緒之後，就會自動重設。</span><span class="sxs-lookup"><span data-stu-id="970fe-114">As its name implies, this synchronization event resets automatically when signaled, after releasing a single waiting thread.</span></span> <span data-ttu-id="970fe-115">請呼叫事件的 <xref:System.Threading.EventWaitHandle.Set%2A> 方法來對事件發出訊號。</span><span class="sxs-lookup"><span data-stu-id="970fe-115">Signal the event by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method.</span></span>  
  
 <span data-ttu-id="970fe-116">自動重設事件通常用來一次為一個執行緒提供資源的獨佔存取權。</span><span class="sxs-lookup"><span data-stu-id="970fe-116">Automatic reset events are usually used to provide exclusive access to a resource for a single thread at a time.</span></span> <span data-ttu-id="970fe-117">執行緒會透過呼叫 <xref:System.Threading.WaitHandle.WaitOne%2A> 方法來要求資源。</span><span class="sxs-lookup"><span data-stu-id="970fe-117">A thread requests the resource by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="970fe-118">如果沒有任何其他執行緒持有等候控制代碼，該方法就會傳回 `true`，而發出呼叫的執行緒就會擁有資源的控制權。</span><span class="sxs-lookup"><span data-stu-id="970fe-118">If no other thread is holding the wait handle, the method returns `true` and the calling thread has control of the resource.</span></span>  
  
> [!IMPORTANT]
> <span data-ttu-id="970fe-119">與使用所有同步處理機制時相同，您必須確保所有程式碼路徑在存取受保護的資源之前，先等候適當的等候控制代碼。</span><span class="sxs-lookup"><span data-stu-id="970fe-119">As with all synchronization mechanisms, you must ensure that all code paths wait on the appropriate wait handle before accessing a protected resource.</span></span> <span data-ttu-id="970fe-120">執行緒同步處理是採用合作方式。</span><span class="sxs-lookup"><span data-stu-id="970fe-120">Thread synchronization is cooperative.</span></span>  
  
 <span data-ttu-id="970fe-121">如果自動重設事件在沒有任何執行緒處於等候狀態時收到訊號，它會維持收到訊號的狀態，直到有執行緒嘗試等候它為止。</span><span class="sxs-lookup"><span data-stu-id="970fe-121">If an automatic reset event is signaled when no threads are waiting, it remains signaled until a thread attempts to wait on it.</span></span> <span data-ttu-id="970fe-122">此事件會釋出執行緒並立即重設，以阻斷後續的執行緒。</span><span class="sxs-lookup"><span data-stu-id="970fe-122">The event releases the thread and immediately resets, blocking subsequent threads.</span></span>  
  
## <a name="event-wait-handles-that-reset-manually"></a><span data-ttu-id="970fe-123">手動重設的事件等候控制代碼</span><span class="sxs-lookup"><span data-stu-id="970fe-123">Event Wait Handles That Reset Manually</span></span>  

 <span data-ttu-id="970fe-124">您可以在建立 <xref:System.Threading.EventWaitHandle> 物件時指定 <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType>，來建立手動重設事件。</span><span class="sxs-lookup"><span data-stu-id="970fe-124">You create a manual reset event by specifying <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> when you create the <xref:System.Threading.EventWaitHandle> object.</span></span> <span data-ttu-id="970fe-125">正如其名，您必須在此同步處理事件收到訊號之後，以手動方式重設它。</span><span class="sxs-lookup"><span data-stu-id="970fe-125">As its name implies, this synchronization event must be reset manually after it has been signaled.</span></span> <span data-ttu-id="970fe-126">在此事件被重設之前，等候事件控制代碼的執行緒可藉由呼叫其 <xref:System.Threading.EventWaitHandle.Reset%2A> 方法來立即繼續進行而不受阻斷。</span><span class="sxs-lookup"><span data-stu-id="970fe-126">Until it is reset, by calling its <xref:System.Threading.EventWaitHandle.Reset%2A> method, threads that wait on the event handle proceed immediately without blocking.</span></span>  
  
 <span data-ttu-id="970fe-127">手動重設事件就像圍欄的閘門一樣。</span><span class="sxs-lookup"><span data-stu-id="970fe-127">A manual reset event acts like the gate of a corral.</span></span> <span data-ttu-id="970fe-128">當事件沒有收到訊號時，等候它的執行緒會被阻斷，就像圍欄中的馬一樣。</span><span class="sxs-lookup"><span data-stu-id="970fe-128">When the event is not signaled, threads that wait on it block, like horses in a corral.</span></span> <span data-ttu-id="970fe-129">當事件收到訊號時，只要呼叫其 <xref:System.Threading.EventWaitHandle.Set%2A> 方法，所有等候中的執行緒便可自由繼續進行。</span><span class="sxs-lookup"><span data-stu-id="970fe-129">When the event is signaled, by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method, all waiting threads are free to proceed.</span></span> <span data-ttu-id="970fe-130">事件會維持收到訊號的狀態，直到其 <xref:System.Threading.EventWaitHandle.Reset%2A> 方法被呼叫為止。</span><span class="sxs-lookup"><span data-stu-id="970fe-130">The event remains signaled until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span> <span data-ttu-id="970fe-131">這使得手動重設事件成為一種理想的方式，來攔住必須等候某個執行緒完成工作的執行緒。</span><span class="sxs-lookup"><span data-stu-id="970fe-131">This makes the manual reset event an ideal way to hold up threads that need to wait until one thread finishes a task.</span></span>  
  
 <span data-ttu-id="970fe-132">與離開圍欄的馬一樣，作業系統需要時間來排定釋出的執行緒並讓它們繼續執行。</span><span class="sxs-lookup"><span data-stu-id="970fe-132">Like horses leaving a corral, it takes time for the released threads to be scheduled by the operating system and to resume execution.</span></span> <span data-ttu-id="970fe-133">如果在所有執行緒繼續執行之前呼叫 <xref:System.Threading.EventWaitHandle.Reset%2A> 方法，剩餘的執行緒就會再次遭到阻斷。</span><span class="sxs-lookup"><span data-stu-id="970fe-133">If the <xref:System.Threading.EventWaitHandle.Reset%2A> method is called before all the threads have resumed execution, the remaining threads once again block.</span></span> <span data-ttu-id="970fe-134">哪些執行緒會繼續執行及哪些執行緒會遭到阻斷，取決於系統上的負載、等候排程器的執行緒數量等隨機因素。</span><span class="sxs-lookup"><span data-stu-id="970fe-134">Which threads resume and which threads block depends on random factors like the load on the system, the number of threads waiting for the scheduler, and so on.</span></span> <span data-ttu-id="970fe-135">如果向事件發出訊號的執行緒在發出訊號後結束，這就不成問題，這也是最常見的使用模式。</span><span class="sxs-lookup"><span data-stu-id="970fe-135">This is not a problem if the thread that signals the event ends after signaling, which is the most common usage pattern.</span></span> <span data-ttu-id="970fe-136">如果您想要讓向事件發出訊號的執行緒在所有等候中執行緒都繼續執行之後開始新的工作，就必須阻斷它，直到所有等候中執行緒都已繼續執行為止。</span><span class="sxs-lookup"><span data-stu-id="970fe-136">If you want the thread that signaled the event to begin a new task after all the waiting threads have resumed, you must block it until all the waiting threads have resumed.</span></span> <span data-ttu-id="970fe-137">否則，會發生競爭情形，而無法預測您的程式碼行為。</span><span class="sxs-lookup"><span data-stu-id="970fe-137">Otherwise, you have a race condition, and the behavior of your code is unpredictable.</span></span>  
  
## <a name="features-common-to-automatic-and-manual-events"></a><span data-ttu-id="970fe-138">自動和手動事件的常見功能</span><span class="sxs-lookup"><span data-stu-id="970fe-138">Features Common to Automatic and Manual Events</span></span>  

 <span data-ttu-id="970fe-139">通常 <xref:System.Threading.EventWaitHandle> 上會有一或多個執行緒被阻斷，直到未遭阻斷的執行緒呼叫 <xref:System.Threading.EventWaitHandle.Set%2A> 方法為止，這會釋出其中一個等候中的執行緒 (在自動重設事件的案例中) 或所有等候中的執行緒 (在手動重設事件的案例中)。</span><span class="sxs-lookup"><span data-stu-id="970fe-139">Typically, one or more threads block on an <xref:System.Threading.EventWaitHandle> until an unblocked thread calls the <xref:System.Threading.EventWaitHandle.Set%2A> method, which releases one of the waiting threads (in the case of automatic reset events) or all of them (in the case of manual reset events).</span></span> <span data-ttu-id="970fe-140">執行緒可以藉由呼叫靜態 <xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType> 方法，向 <xref:System.Threading.EventWaitHandle> 發出訊號，然後被阻斷，整個作業一氣呵成。</span><span class="sxs-lookup"><span data-stu-id="970fe-140">A thread can signal an <xref:System.Threading.EventWaitHandle> and then block on it, as an atomic operation, by calling the static <xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="970fe-141"><xref:System.Threading.EventWaitHandle> 物件可以與靜態的 <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> 和 <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> 方法搭配使用。</span><span class="sxs-lookup"><span data-stu-id="970fe-141"><xref:System.Threading.EventWaitHandle> objects can be used with the static <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> and <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="970fe-142">由於 <xref:System.Threading.EventWaitHandle> 和 <xref:System.Threading.Mutex> 類別都衍生自 <xref:System.Threading.WaitHandle>，因此您可以將這兩個類別與這些方法搭配使用。</span><span class="sxs-lookup"><span data-stu-id="970fe-142">Because the <xref:System.Threading.EventWaitHandle> and <xref:System.Threading.Mutex> classes both derive from <xref:System.Threading.WaitHandle>, you can use both classes with these methods.</span></span>  
  
### <a name="named-events"></a><span data-ttu-id="970fe-143">具名事件</span><span class="sxs-lookup"><span data-stu-id="970fe-143">Named Events</span></span>  

 <span data-ttu-id="970fe-144">Windows 作業系統允許事件等候控制代碼擁有名稱。</span><span class="sxs-lookup"><span data-stu-id="970fe-144">The Windows operating system allows event wait handles to have names.</span></span> <span data-ttu-id="970fe-145">具名事件是全系統性的。</span><span class="sxs-lookup"><span data-stu-id="970fe-145">A named event is system wide.</span></span> <span data-ttu-id="970fe-146">也就是說，一旦建立具名事件，所有處理序中的所有執行緒都可看到它。</span><span class="sxs-lookup"><span data-stu-id="970fe-146">That is, once the named event is created, it is visible to all threads in all processes.</span></span> <span data-ttu-id="970fe-147">因此，具名事件既可用來同步處理執行緒，也可用來同步處理處理序的活動。</span><span class="sxs-lookup"><span data-stu-id="970fe-147">Thus, named events can be used to synchronize the activities of processes as well as threads.</span></span>  
  
 <span data-ttu-id="970fe-148">您可以使用其中一個指定名稱的建構函式，來建立代表具名系統事件的 <xref:System.Threading.EventWaitHandle> 物件。</span><span class="sxs-lookup"><span data-stu-id="970fe-148">You can create an <xref:System.Threading.EventWaitHandle> object that represents a named system event by using one of the constructors that specifies an event name.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="970fe-149">由於具名事件是全系統性的，因此可以有多個代表相同具名事件的 <xref:System.Threading.EventWaitHandle> 物件。</span><span class="sxs-lookup"><span data-stu-id="970fe-149">Because named events are system wide, it is possible to have multiple <xref:System.Threading.EventWaitHandle> objects that represent the same named event.</span></span> <span data-ttu-id="970fe-150">每次呼叫建構函式或 <xref:System.Threading.EventWaitHandle.OpenExisting%2A> 方法時，都會建立新的 <xref:System.Threading.EventWaitHandle> 物件。</span><span class="sxs-lookup"><span data-stu-id="970fe-150">Each time you call a constructor, or the <xref:System.Threading.EventWaitHandle.OpenExisting%2A> method, a new <xref:System.Threading.EventWaitHandle> object is created.</span></span> <span data-ttu-id="970fe-151">如果重複指定相同的名稱，就會建立多個代表相同具名事件的物件。</span><span class="sxs-lookup"><span data-stu-id="970fe-151">Specifying the same name repeatedly creates multiple objects that represent the same named event.</span></span>  
  
 <span data-ttu-id="970fe-152">使用具名事件時，請務必謹慎。</span><span class="sxs-lookup"><span data-stu-id="970fe-152">Caution is advised in using named events.</span></span> <span data-ttu-id="970fe-153">由於這些事件是全系統性的，因此如果有另一個處理序使用相同的名稱，就可能意外阻斷您的執行緒。</span><span class="sxs-lookup"><span data-stu-id="970fe-153">Because they are system wide, another process that uses the same name can block your threads unexpectedly.</span></span> <span data-ttu-id="970fe-154">在同一部電腦上執行的惡意程式碼便可使用此點作為拒絕服務攻擊的基礎。</span><span class="sxs-lookup"><span data-stu-id="970fe-154">Malicious code executing on the same computer could use this as the basis of a denial-of-service attack.</span></span>  
  
 <span data-ttu-id="970fe-155">請使用存取控制安全性來保護代表具名事件的 <xref:System.Threading.EventWaitHandle> 物件，最好是使用指定 <xref:System.Security.AccessControl.EventWaitHandleSecurity> 物件的建構函式。</span><span class="sxs-lookup"><span data-stu-id="970fe-155">Use access control security to protect an <xref:System.Threading.EventWaitHandle> object that represents a named event, preferably by using a constructor that specifies an <xref:System.Security.AccessControl.EventWaitHandleSecurity> object.</span></span> <span data-ttu-id="970fe-156">您也可以使用 <xref:System.Threading.EventWaitHandle.SetAccessControl%2A> 方法來套用存取控制安全性，但這會在事件等候控制代碼的建立時間與受保護時間之間，留下一段有弱點的空窗期。</span><span class="sxs-lookup"><span data-stu-id="970fe-156">You can also apply access control security using the <xref:System.Threading.EventWaitHandle.SetAccessControl%2A> method, but this leaves a window of vulnerability between the time the event wait handle is created and the time it is protected.</span></span> <span data-ttu-id="970fe-157">使用存取控制安全性來保護事件有助於防止惡意攻擊，但並無法解決意外名稱衝突問題。</span><span class="sxs-lookup"><span data-stu-id="970fe-157">Protecting events with access control security helps prevent malicious attacks, but it does not solve the problem of unintentional name collisions.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="970fe-158">不同於 <xref:System.Threading.EventWaitHandle> 類別，衍生的類別 <xref:System.Threading.AutoResetEvent> 和 <xref:System.Threading.ManualResetEvent> 只能代表本機等候控制代碼。</span><span class="sxs-lookup"><span data-stu-id="970fe-158">Unlike the <xref:System.Threading.EventWaitHandle> class, the derived classes <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent> can represent only local wait handles.</span></span> <span data-ttu-id="970fe-159">它們無法代表具名系統事件。</span><span class="sxs-lookup"><span data-stu-id="970fe-159">They cannot represent named system events.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="970fe-160">另請參閱</span><span class="sxs-lookup"><span data-stu-id="970fe-160">See also</span></span>

- <xref:System.Threading.EventWaitHandle>
- <xref:System.Threading.WaitHandle>
- <xref:System.Threading.AutoResetEvent>
- <xref:System.Threading.ManualResetEvent>
