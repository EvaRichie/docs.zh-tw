---
title: 受控執行緒集區
description: 了解提供背景工作執行緒的 .NET 執行緒集區
ms.date: 08/02/2018
ms.technology: dotnet-standard
helpviewer_keywords:
- thread pooling [.NET]
- thread pools [.NET]
- threading [.NET], thread pool
- threading [.NET], pooling
ms.assetid: 2be05b06-a42e-4c9d-a739-96c21d673927
ms.openlocfilehash: 2671ce7c9721b15de8a3805da27040e973a62804
ms.sourcegitcommit: 67ebdb695fd017d79d9f1f7f35d145042d5a37f7
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 10/20/2020
ms.locfileid: "92223794"
---
# <a name="the-managed-thread-pool"></a><span data-ttu-id="eab31-103">受控執行緒集區</span><span class="sxs-lookup"><span data-stu-id="eab31-103">The managed thread pool</span></span>

<span data-ttu-id="eab31-104"><xref:System.Threading.ThreadPool?displayProperty=nameWithType> 類別為您的應用程式提供了受到系統管理的背景工作執行緒集區，讓您專注於應用程式工作上，而不是執行緒的管理。</span><span class="sxs-lookup"><span data-stu-id="eab31-104">The <xref:System.Threading.ThreadPool?displayProperty=nameWithType> class provides your application with a pool of worker threads that are managed by the system, allowing you to concentrate on application tasks rather than thread management.</span></span> <span data-ttu-id="eab31-105">如果您有需要在背景處理的簡短工作，Managed 執行緒集區是利用多重執行緒的一個簡單方式。</span><span class="sxs-lookup"><span data-stu-id="eab31-105">If you have short tasks that require background processing, the managed thread pool is an easy way to take advantage of multiple threads.</span></span> <span data-ttu-id="eab31-106">相較於舊版，使用 Framework 4 及更新版本中的執行緒集區容易許多，因為您可以建立<xref:System.Threading.Tasks.Task> 及 <xref:System.Threading.Tasks.Task%601> 物件，對執行緒集區的執行緒執行非同步工作。</span><span class="sxs-lookup"><span data-stu-id="eab31-106">Use of the thread pool is significantly easier in Framework 4 and later, since you can create <xref:System.Threading.Tasks.Task> and <xref:System.Threading.Tasks.Task%601> objects that perform asynchronous tasks on thread pool threads.</span></span>  
  
<span data-ttu-id="eab31-107">.NET 執行緒集區的執行緒有多種用途，包括[工作平行程式庫 (TPL)作業](../parallel-programming/task-parallel-library-tpl.md)、非同步 I/O 完成、[計時器](timers.md)回呼、註冊的等候作業、使用委派的非同步方法，以及 <xref:System.Net?displayProperty=nameWithType> 通訊端連線。</span><span class="sxs-lookup"><span data-stu-id="eab31-107">.NET uses thread pool threads for many purposes, including [Task Parallel Library (TPL)](../parallel-programming/task-parallel-library-tpl.md) operations, asynchronous I/O completion, [timer](timers.md) callbacks, registered wait operations, asynchronous method calls using delegates, and <xref:System.Net?displayProperty=nameWithType> socket connections.</span></span>  

## <a name="thread-pool-characteristics"></a><span data-ttu-id="eab31-108">執行緒集區的特性</span><span class="sxs-lookup"><span data-stu-id="eab31-108">Thread pool characteristics</span></span>

<span data-ttu-id="eab31-109">執行緒集區的執行緒為[背景](foreground-and-background-threads.md)執行緒。</span><span class="sxs-lookup"><span data-stu-id="eab31-109">Thread pool threads are [background](foreground-and-background-threads.md) threads.</span></span> <span data-ttu-id="eab31-110">每個執行緒都會使用預設堆疊大小、以預先優先權執行，並且位於多執行緒 Apartment 中。</span><span class="sxs-lookup"><span data-stu-id="eab31-110">Each thread uses the default stack size, runs at the default priority, and is in the multithreaded apartment.</span></span> <span data-ttu-id="eab31-111">當執行緒集區的執行緒完成其工作時，會返回等候中的執行緒佇列。</span><span class="sxs-lookup"><span data-stu-id="eab31-111">Once a thread in the thread pool completes its task, it's returned to a queue of waiting threads.</span></span> <span data-ttu-id="eab31-112">當其返回佇列時，就能重複使用。</span><span class="sxs-lookup"><span data-stu-id="eab31-112">From this moment it can be reused.</span></span> <span data-ttu-id="eab31-113">這項重複使用可讓應用程式避免建立每個工作之新執行緒的成本。</span><span class="sxs-lookup"><span data-stu-id="eab31-113">This reuse enables applications to avoid the cost of creating a new thread for each task.</span></span>
  
<span data-ttu-id="eab31-114">每個處理序只有一個執行緒集區。</span><span class="sxs-lookup"><span data-stu-id="eab31-114">There is only one thread pool per process.</span></span>  
  
### <a name="exceptions-in-thread-pool-threads"></a><span data-ttu-id="eab31-115">執行緒集區執行緒的例外狀況</span><span class="sxs-lookup"><span data-stu-id="eab31-115">Exceptions in thread pool threads</span></span>

<span data-ttu-id="eab31-116">執行緒集區的執行緒中如有未處理的例外狀況，將會終止該處理序。</span><span class="sxs-lookup"><span data-stu-id="eab31-116">Unhandled exceptions in thread pool threads terminate the process.</span></span> <span data-ttu-id="eab31-117">這項規則有三個例外狀況：</span><span class="sxs-lookup"><span data-stu-id="eab31-117">There are three exceptions to this rule:</span></span>  
  
- <span data-ttu-id="eab31-118">因為呼叫了 <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>，所以會在執行緒集區的執行緒中擲回 <xref:System.Threading.ThreadAbortException?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="eab31-118">A <xref:System.Threading.ThreadAbortException?displayProperty=nameWithType> is thrown in a thread pool thread because <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType> was called.</span></span>  
- <span data-ttu-id="eab31-119">因為正在卸載應用程式定義域，所以在執行緒集區的執行緒中擲回 <xref:System.AppDomainUnloadedException?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="eab31-119">A <xref:System.AppDomainUnloadedException?displayProperty=nameWithType> is thrown in a thread pool thread because the application domain is being unloaded.</span></span>  
- <span data-ttu-id="eab31-120">Common Language Runtime 或主應用程式處理序會結束這個執行緒。</span><span class="sxs-lookup"><span data-stu-id="eab31-120">The common language runtime or a host process terminates the thread.</span></span>  
  
<span data-ttu-id="eab31-121">如需詳細資訊，請參閱 [Managed 執行緒中的例外](exceptions-in-managed-threads.md)狀況。</span><span class="sxs-lookup"><span data-stu-id="eab31-121">For more information, see [Exceptions in Managed Threads](exceptions-in-managed-threads.md).</span></span>  
  
### <a name="maximum-number-of-thread-pool-threads"></a><span data-ttu-id="eab31-122">執行緒集區執行緒數的上限</span><span class="sxs-lookup"><span data-stu-id="eab31-122">Maximum number of thread pool threads</span></span>

<span data-ttu-id="eab31-123">可以排入執行緒集區佇列的作業數，受限於可用記憶體的數量，</span><span class="sxs-lookup"><span data-stu-id="eab31-123">The number of operations that can be queued to the thread pool is limited only by available memory.</span></span> <span data-ttu-id="eab31-124">但執行緒集區會限制能在處理序中同時作用的執行緒數。</span><span class="sxs-lookup"><span data-stu-id="eab31-124">However, the thread pool limits the number of threads that can be active in the process simultaneously.</span></span> <span data-ttu-id="eab31-125">當所有執行緒集區執行緒都在忙碌時，其他工作項目會排入佇列中，直到有執行緒可以執行這些工作為止。</span><span class="sxs-lookup"><span data-stu-id="eab31-125">If all thread pool threads are busy, additional work items are queued until threads to execute them become available.</span></span> <span data-ttu-id="eab31-126">自 .NET Framework 4 起，處理序的執行緒集區預設大小取決於數個因素，例如虛擬位址空間的大小。</span><span class="sxs-lookup"><span data-stu-id="eab31-126">Beginning with the .NET Framework 4, the default size of the thread pool for a process depends on several factors, such as the size of the virtual address space.</span></span> <span data-ttu-id="eab31-127">處理序可以呼叫 <xref:System.Threading.ThreadPool.GetMaxThreads%2A?displayProperty=nameWithType> 方法來決定執行緒數目。</span><span class="sxs-lookup"><span data-stu-id="eab31-127">A process can call the <xref:System.Threading.ThreadPool.GetMaxThreads%2A?displayProperty=nameWithType> method to determine the number of threads.</span></span>  
  
<span data-ttu-id="eab31-128">您可以使用 <xref:System.Threading.ThreadPool.GetMaxThreads%2A?displayProperty=nameWithType> 和 <xref:System.Threading.ThreadPool.SetMaxThreads%2A?displayProperty=nameWithType> 方法來控制執行緒最大數目。</span><span class="sxs-lookup"><span data-stu-id="eab31-128">You can control the maximum number of threads by using the <xref:System.Threading.ThreadPool.GetMaxThreads%2A?displayProperty=nameWithType> and <xref:System.Threading.ThreadPool.SetMaxThreads%2A?displayProperty=nameWithType> methods.</span></span>  

> [!NOTE]
> <span data-ttu-id="eab31-129">裝載 common language runtime 的程式碼可以使用方法來設定大小 [`ICorThreadpool::CorSetMaxThreads`](../../framework/unmanaged-api/hosting/icorthreadpool-corsetmaxthreads-method.md) 。</span><span class="sxs-lookup"><span data-stu-id="eab31-129">Code that hosts the common language runtime can set the size using the [`ICorThreadpool::CorSetMaxThreads`](../../framework/unmanaged-api/hosting/icorthreadpool-corsetmaxthreads-method.md) method.</span></span>  
  
### <a name="thread-pool-minimums"></a><span data-ttu-id="eab31-130">執行緒集區下限</span><span class="sxs-lookup"><span data-stu-id="eab31-130">Thread pool minimums</span></span>

<span data-ttu-id="eab31-131">執行緒集區會視需要提供新的背景工作執行緒或 I/O 完成執行緒，直到達到每個分類的指定最小值為止。</span><span class="sxs-lookup"><span data-stu-id="eab31-131">The thread pool provides new worker threads or I/O completion threads on demand until it reaches a specified minimum for each category.</span></span> <span data-ttu-id="eab31-132">您可以使用 <xref:System.Threading.ThreadPool.GetMinThreads%2A?displayProperty=nameWithType> 方法取得這些最小值。</span><span class="sxs-lookup"><span data-stu-id="eab31-132">You can use the <xref:System.Threading.ThreadPool.GetMinThreads%2A?displayProperty=nameWithType> method to obtain these minimum values.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="eab31-133">當需求很低時，執行緒集區執行緒的實際數目可能低於最小值。</span><span class="sxs-lookup"><span data-stu-id="eab31-133">When demand is low, the actual number of thread pool threads can fall below the minimum values.</span></span>  
  
<span data-ttu-id="eab31-134">當達到最小值時，執行緒集區可以建立額外的執行緒，或是等候部分工作完成。</span><span class="sxs-lookup"><span data-stu-id="eab31-134">When a minimum is reached, the thread pool can create additional threads or wait until some tasks complete.</span></span> <span data-ttu-id="eab31-135">自 .NET Framework 4 起，執行緒集區會建立及終結背景工作執行緒，以最佳化輸送量。輸送量是指每個時間單位所能完成的工作數。</span><span class="sxs-lookup"><span data-stu-id="eab31-135">Beginning with the .NET Framework 4, the thread pool creates and destroys worker threads in order to optimize throughput, which is defined as the number of tasks that complete per unit of time.</span></span> <span data-ttu-id="eab31-136">執行緒太少可能無法最有效地利用可用資源，而執行緒太多則可能增加資源爭用的情況。</span><span class="sxs-lookup"><span data-stu-id="eab31-136">Too few threads might not make optimal use of available resources, whereas too many threads could increase resource contention.</span></span>  
  
> [!CAUTION]
> <span data-ttu-id="eab31-137">您可以使用 <xref:System.Threading.ThreadPool.SetMinThreads%2A?displayProperty=nameWithType> 方法來提高閒置執行緒的數目下限。</span><span class="sxs-lookup"><span data-stu-id="eab31-137">You can use the <xref:System.Threading.ThreadPool.SetMinThreads%2A?displayProperty=nameWithType> method to increase the minimum number of idle threads.</span></span> <span data-ttu-id="eab31-138">不過，不必要地增加這些值，可能會造成效能問題。</span><span class="sxs-lookup"><span data-stu-id="eab31-138">However, unnecessarily increasing these values can cause performance problems.</span></span> <span data-ttu-id="eab31-139">如果太多工作同時啟動，則所有工作可能都會變慢。</span><span class="sxs-lookup"><span data-stu-id="eab31-139">If too many tasks start at the same time, all of them might appear to be slow.</span></span> <span data-ttu-id="eab31-140">在大部分情況下，執行緒集區使用自己的演算法來配置執行緒的效能較佳。</span><span class="sxs-lookup"><span data-stu-id="eab31-140">In most cases the thread pool will perform better with its own algorithm for allocating threads.</span></span>  

## <a name="using-the-thread-pool"></a><span data-ttu-id="eab31-141">使用執行緒集區</span><span class="sxs-lookup"><span data-stu-id="eab31-141">Using the thread pool</span></span>

<span data-ttu-id="eab31-142">自 .NET Framework 4 起，使用執行緒集區最簡單的方式，就是使用[工作平行程式庫 (TPL)](../parallel-programming/task-parallel-library-tpl.md)。</span><span class="sxs-lookup"><span data-stu-id="eab31-142">Beginning with the .NET Framework 4, the easiest way to use the thread pool is to use the [Task Parallel Library (TPL)](../parallel-programming/task-parallel-library-tpl.md).</span></span> <span data-ttu-id="eab31-143">根據預設，諸如 <xref:System.Threading.Tasks.Task> 與 <xref:System.Threading.Tasks.Task%601> 等 TPL 類型，都會使用執行緒集區的執行緒執行工作。</span><span class="sxs-lookup"><span data-stu-id="eab31-143">By default, TPL types like <xref:System.Threading.Tasks.Task> and <xref:System.Threading.Tasks.Task%601> use thread pool threads to run tasks.</span></span>

<span data-ttu-id="eab31-144">您也可以使用執行緒集區，方法是 <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A?displayProperty=nameWithType> 從 managed 程式碼 (或 [`ICorThreadpool::CorQueueUserWorkItem`](../../framework/unmanaged-api/hosting/icorthreadpool-corqueueuserworkitem-method.md) 從非受控程式) 代碼進行呼叫，並傳遞 <xref:System.Threading.WaitCallback?displayProperty=nameWithType> 代表執行工作之方法的委派。</span><span class="sxs-lookup"><span data-stu-id="eab31-144">You can also use the thread pool by calling <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A?displayProperty=nameWithType> from managed code (or [`ICorThreadpool::CorQueueUserWorkItem`](../../framework/unmanaged-api/hosting/icorthreadpool-corqueueuserworkitem-method.md) from unmanaged code) and passing a <xref:System.Threading.WaitCallback?displayProperty=nameWithType> delegate representing the method that performs the task.</span></span>

<span data-ttu-id="eab31-145">使用執行緒集區的另一種方式，是使用 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A?displayProperty=nameWithType> 方法並傳遞 <xref:System.Threading.WaitHandle?displayProperty=nameWithType> (它在收到信號或逾時的時候會呼叫由 <xref:System.Threading.WaitOrTimerCallback?displayProperty=nameWithType> 委派表示的方法)，藉以將與等候作業有關的工作項目排入佇列。</span><span class="sxs-lookup"><span data-stu-id="eab31-145">Another way to use the thread pool is to queue work items that are related to a wait operation by using the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A?displayProperty=nameWithType> method and passing a <xref:System.Threading.WaitHandle?displayProperty=nameWithType> that, when signaled or when timed out, calls the method represented by the <xref:System.Threading.WaitOrTimerCallback?displayProperty=nameWithType> delegate.</span></span> <span data-ttu-id="eab31-146">執行緒集區執行緒可用來叫用回呼方法。</span><span class="sxs-lookup"><span data-stu-id="eab31-146">Thread pool threads are used to invoke callback methods.</span></span>  

<span data-ttu-id="eab31-147">如需範例，請參閱所參考的 API 頁面。</span><span class="sxs-lookup"><span data-stu-id="eab31-147">For the examples, check the referenced API pages.</span></span>
  
## <a name="skipping-security-checks"></a><span data-ttu-id="eab31-148">略過安全性檢查</span><span class="sxs-lookup"><span data-stu-id="eab31-148">Skipping security checks</span></span>

<span data-ttu-id="eab31-149">執行緒集區也提供 <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A?displayProperty=nameWithType> 和 <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="eab31-149">The thread pool also provides the <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A?displayProperty=nameWithType> and <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="eab31-150">只有在您確定呼叫端的堆疊與排入佇列之工作的執行期間所做的任何安全性檢查無關時，才能使用這些方法。</span><span class="sxs-lookup"><span data-stu-id="eab31-150">Use these methods only when you are certain that the caller's stack is irrelevant to any security checks performed during the execution of the queued task.</span></span> <span data-ttu-id="eab31-151"><xref:System.Threading.ThreadPool.QueueUserWorkItem%2A?displayProperty=nameWithType> 和 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A?displayProperty=nameWithType> 都可擷取呼叫端的堆疊，這個堆疊會在執行緒開始執行工作時，合併到執行緒集區執行緒的堆疊中。</span><span class="sxs-lookup"><span data-stu-id="eab31-151"><xref:System.Threading.ThreadPool.QueueUserWorkItem%2A?displayProperty=nameWithType> and <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A?displayProperty=nameWithType> both capture the caller's stack, which is merged into the stack of the thread pool thread when the thread begins to execute a task.</span></span> <span data-ttu-id="eab31-152">如果需要安全性檢查，則必須檢查整個堆疊。</span><span class="sxs-lookup"><span data-stu-id="eab31-152">If a security check is required, the entire stack must be checked.</span></span> <span data-ttu-id="eab31-153">雖然檢查能夠提供安全性，但是也帶來效能成本。</span><span class="sxs-lookup"><span data-stu-id="eab31-153">Although the check provides safety, it also has a performance cost.</span></span>  

## <a name="when-not-to-use-thread-pool-threads"></a><span data-ttu-id="eab31-154">不應使用執行緒集區執行緒的時機</span><span class="sxs-lookup"><span data-stu-id="eab31-154">When not to use thread pool threads</span></span>

<span data-ttu-id="eab31-155">有好幾種情況適合建立及管理您自己的執行緒，而不是使用執行緒集區的執行緒：</span><span class="sxs-lookup"><span data-stu-id="eab31-155">There are several scenarios in which it's appropriate to create and manage your own threads instead of using thread pool threads:</span></span>  
  
- <span data-ttu-id="eab31-156">您需要前景執行緒。</span><span class="sxs-lookup"><span data-stu-id="eab31-156">You require a foreground thread.</span></span>  
- <span data-ttu-id="eab31-157">您需要執行緒有特定的優先權。</span><span class="sxs-lookup"><span data-stu-id="eab31-157">You require a thread to have a particular priority.</span></span>  
- <span data-ttu-id="eab31-158">您有一些工作會造成執行緒封鎖一段很長的時間。</span><span class="sxs-lookup"><span data-stu-id="eab31-158">You have tasks that cause the thread to block for long periods of time.</span></span> <span data-ttu-id="eab31-159">執行緒集區有執行緒數目上限，因此大量已封鎖的執行緒集區執行緒可能會導致工作無法啟動。</span><span class="sxs-lookup"><span data-stu-id="eab31-159">The thread pool has a maximum number of threads, so a large number of blocked thread pool threads might prevent tasks from starting.</span></span>  
- <span data-ttu-id="eab31-160">您需要將執行緒放在單一執行緒 Apartment 中。</span><span class="sxs-lookup"><span data-stu-id="eab31-160">You need to place threads into a single-threaded apartment.</span></span> <span data-ttu-id="eab31-161">所有 <xref:System.Threading.ThreadPool> 執行緒都會在多執行緒 Apartment 中。</span><span class="sxs-lookup"><span data-stu-id="eab31-161">All <xref:System.Threading.ThreadPool> threads are in the multithreaded apartment.</span></span>  
- <span data-ttu-id="eab31-162">您需要有一個與執行緒關聯的固定識別，或是讓執行緒專屬於某項工作。</span><span class="sxs-lookup"><span data-stu-id="eab31-162">You need to have a stable identity associated with the thread, or to dedicate a thread to a task.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="eab31-163">另請參閱</span><span class="sxs-lookup"><span data-stu-id="eab31-163">See also</span></span>

- <xref:System.Threading.ThreadPool?displayProperty=nameWithType>
- <xref:System.Threading.Tasks.Task?displayProperty=nameWithType>
- <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType>
- [<span data-ttu-id="eab31-164">工作平行程式庫 (TPL)</span><span class="sxs-lookup"><span data-stu-id="eab31-164">Task Parallel Library (TPL)</span></span>](../parallel-programming/task-parallel-library-tpl.md)
- [<span data-ttu-id="eab31-165">作法：從工作傳回值</span><span class="sxs-lookup"><span data-stu-id="eab31-165">How to: Return a Value from a Task</span></span>](../parallel-programming/how-to-return-a-value-from-a-task.md)
- [<span data-ttu-id="eab31-166">執行緒物件和功能</span><span class="sxs-lookup"><span data-stu-id="eab31-166">Threading Objects and Features</span></span>](threading-objects-and-features.md)
- [<span data-ttu-id="eab31-167">執行緒和執行緒處理</span><span class="sxs-lookup"><span data-stu-id="eab31-167">Threads and Threading</span></span>](threads-and-threading.md)
- [<span data-ttu-id="eab31-168">非同步檔案 i/o</span><span class="sxs-lookup"><span data-stu-id="eab31-168">Asynchronous File I/O</span></span>](../io/asynchronous-file-i-o.md)
- [<span data-ttu-id="eab31-169">計時器</span><span class="sxs-lookup"><span data-stu-id="eab31-169">Timers</span></span>](timers.md)
