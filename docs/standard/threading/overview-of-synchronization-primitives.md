---
title: 同步處理原始物件概觀
description: 了解用來同步對共用資源的存取或控制執行緒互動的 .NET 執行緒同步處理原始物件
ms.date: 10/01/2018
helpviewer_keywords:
- synchronization, threads
- threading [.NET],synchronizing threads
- managed threading
ms.assetid: b782bcb8-da6a-4c6a-805f-2eb46d504309
ms.openlocfilehash: 9dfaaa6050cc6e9a6b86f991aa6d2ce2a815959a
ms.sourcegitcommit: 965a5af7918acb0a3fd3baf342e15d511ef75188
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 11/18/2020
ms.locfileid: "94819652"
---
# <a name="overview-of-synchronization-primitives"></a><span data-ttu-id="8cc28-103">同步處理原始物件概觀</span><span class="sxs-lookup"><span data-stu-id="8cc28-103">Overview of synchronization primitives</span></span>

<span data-ttu-id="8cc28-104">.NET 提供可用來同步對共用資源的存取或協調執行緒互動的一系列類型。</span><span class="sxs-lookup"><span data-stu-id="8cc28-104">.NET provides a range of types that you can use to synchronize access to a shared resource or coordinate thread interaction.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="8cc28-105">使用相同同步處理原始物件執行個體來保護共用資源的存取。</span><span class="sxs-lookup"><span data-stu-id="8cc28-105">Use the same synchronization primitive instance to protect access of a shared resource.</span></span> <span data-ttu-id="8cc28-106">如果您使用不同的同步處理原始物件執行個體來保護相同資源，則會規避同步處理原始物件所提供的保護。</span><span class="sxs-lookup"><span data-stu-id="8cc28-106">If you use different synchronization primitive instances to protect the same resource, you'll circumvent the protection provided by a synchronization primitive.</span></span>

## <a name="waithandle-class-and-lightweight-synchronization-types"></a><span data-ttu-id="8cc28-107">WaitHandle 類別和輕量型同步處理類別</span><span class="sxs-lookup"><span data-stu-id="8cc28-107">WaitHandle class and lightweight synchronization types</span></span>

<span data-ttu-id="8cc28-108">衍生自 <xref:System.Threading.WaitHandle?displayProperty=nameWithType> 類別的多個 .NET 同步處理原始物件，它能封裝原生作業系統同步處理控制代碼，並針對執行緒互動使用訊號機制。</span><span class="sxs-lookup"><span data-stu-id="8cc28-108">Multiple .NET synchronization primitives derive from the <xref:System.Threading.WaitHandle?displayProperty=nameWithType> class, which encapsulates a native operating system synchronization handle and uses a signaling mechanism for thread interaction.</span></span> <span data-ttu-id="8cc28-109">那些類別包括：</span><span class="sxs-lookup"><span data-stu-id="8cc28-109">Those classes include:</span></span>

- <span data-ttu-id="8cc28-110"><xref:System.Threading.Mutex?displayProperty=nameWithType>，它能授與對共用資源的獨佔存取權。</span><span class="sxs-lookup"><span data-stu-id="8cc28-110"><xref:System.Threading.Mutex?displayProperty=nameWithType>, which grants exclusive access to a shared resource.</span></span> <span data-ttu-id="8cc28-111">如果沒有任何執行緒擁有 Mutex，則 Mutex 的狀態為已發出訊號。</span><span class="sxs-lookup"><span data-stu-id="8cc28-111">The state of a mutex is signaled if no thread owns it.</span></span>
- <span data-ttu-id="8cc28-112"><xref:System.Threading.Semaphore?displayProperty=nameWithType>，它能限制可以同時存取共用資源或資源集區的執行緒數目。</span><span class="sxs-lookup"><span data-stu-id="8cc28-112"><xref:System.Threading.Semaphore?displayProperty=nameWithType>, which limits the number of threads that can access a shared resource or a pool of resources concurrently.</span></span> <span data-ttu-id="8cc28-113">旗號的狀態會在其計數大於零時設定為已收到訊號，並在計數為零時設定為未收到訊號。</span><span class="sxs-lookup"><span data-stu-id="8cc28-113">The state of a semaphore is set to signaled when its count is greater than zero, and nonsignaled when its count is zero.</span></span>
- <span data-ttu-id="8cc28-114"><xref:System.Threading.EventWaitHandle?displayProperty=nameWithType>，它代表執行緒同步處理事件，並可以處於已收到訊號或未收到訊號的狀態。</span><span class="sxs-lookup"><span data-stu-id="8cc28-114"><xref:System.Threading.EventWaitHandle?displayProperty=nameWithType>, which represents a thread synchronization event and can be either in a signaled or unsignaled state.</span></span>
- <span data-ttu-id="8cc28-115"><xref:System.Threading.AutoResetEvent?displayProperty=nameWithType>，它衍生自 <xref:System.Threading.EventWaitHandle>，且在收到訊號時，會在發佈單一等候執行緒之後自動重設至未收到訊號的狀態。</span><span class="sxs-lookup"><span data-stu-id="8cc28-115"><xref:System.Threading.AutoResetEvent?displayProperty=nameWithType>, which derives from <xref:System.Threading.EventWaitHandle> and, when signaled, resets automatically to an unsignaled state after releasing a single waiting thread.</span></span>
- <span data-ttu-id="8cc28-116"><xref:System.Threading.ManualResetEvent?displayProperty=nameWithType>，它衍生自 <xref:System.Threading.EventWaitHandle>，且在收到訊號時會持續處於已收到訊號的狀態，直到 <xref:System.Threading.EventWaitHandle.Reset%2A> 方法被呼叫為止。</span><span class="sxs-lookup"><span data-stu-id="8cc28-116"><xref:System.Threading.ManualResetEvent?displayProperty=nameWithType>, which derives from <xref:System.Threading.EventWaitHandle> and, when signaled, stays in a signaled state until the <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span>

<span data-ttu-id="8cc28-117">在 .NET Framework 中，因為 <xref:System.Threading.WaitHandle> 衍生自 <xref:System.MarshalByRefObject?displayProperty=nameWithType> ，所以這些類型可以用來跨應用程式域界限同步處理執行緒的活動。</span><span class="sxs-lookup"><span data-stu-id="8cc28-117">In .NET Framework, because <xref:System.Threading.WaitHandle> derives from <xref:System.MarshalByRefObject?displayProperty=nameWithType>, these types can be used to synchronize the activities of threads across application domain boundaries.</span></span>

<span data-ttu-id="8cc28-118">在 .NET Framework、.NET Core 和 .NET 5 + 中，其中一些類型可以代表名為系統同步處理控制碼，在整個作業系統中都是可見的，並且可以用於進程間同步處理：</span><span class="sxs-lookup"><span data-stu-id="8cc28-118">In .NET Framework, .NET Core, and .NET 5+, some of these types can represent named system synchronization handles, which are visible throughout the operating system and can be used for the inter-process synchronization:</span></span>

- <xref:System.Threading.Mutex>
- <span data-ttu-id="8cc28-119"><xref:System.Threading.Semaphore> Windows) 上的 (</span><span class="sxs-lookup"><span data-stu-id="8cc28-119"><xref:System.Threading.Semaphore> (on Windows)</span></span>
- <span data-ttu-id="8cc28-120"><xref:System.Threading.EventWaitHandle> Windows) 上的 (</span><span class="sxs-lookup"><span data-stu-id="8cc28-120"><xref:System.Threading.EventWaitHandle> (on Windows)</span></span>

<span data-ttu-id="8cc28-121">如需詳細資訊，請參閱 <xref:System.Threading.WaitHandle> API 參考。</span><span class="sxs-lookup"><span data-stu-id="8cc28-121">For more information, see the <xref:System.Threading.WaitHandle> API reference.</span></span>

<span data-ttu-id="8cc28-122">輕量型同步處理類型不會仰賴基礎作業系統控制代碼，且通常能提供較佳的效能。</span><span class="sxs-lookup"><span data-stu-id="8cc28-122">Lightweight synchronization types don't rely on underlying operating system handles and typically provide better performance.</span></span> <span data-ttu-id="8cc28-123">不過，它們並無法用於處理序間的同步處理。</span><span class="sxs-lookup"><span data-stu-id="8cc28-123">However, they cannot be used for the inter-process synchronization.</span></span> <span data-ttu-id="8cc28-124">請針對位於單一應用程式內的執行緒同步處理使用那些類型。</span><span class="sxs-lookup"><span data-stu-id="8cc28-124">Use those types for thread synchronization within one application.</span></span>

<span data-ttu-id="8cc28-125">那些類型有一部分是衍生自 <xref:System.Threading.WaitHandle> 之類型的替代方案。</span><span class="sxs-lookup"><span data-stu-id="8cc28-125">Some of those types are alternatives to the types derived from <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="8cc28-126">例如，<xref:System.Threading.SemaphoreSlim> 是 <xref:System.Threading.Semaphore> 的輕量型替代方案。</span><span class="sxs-lookup"><span data-stu-id="8cc28-126">For example, <xref:System.Threading.SemaphoreSlim> is a lightweight alternative to <xref:System.Threading.Semaphore>.</span></span>

## <a name="synchronization-of-access-to-a-shared-resource"></a><span data-ttu-id="8cc28-127">對共用資源之存取的同步處理</span><span class="sxs-lookup"><span data-stu-id="8cc28-127">Synchronization of access to a shared resource</span></span>

<span data-ttu-id="8cc28-128">.NET 提供一系列的同步處理原始物件，以控制多個執行緒對共用資源的存取。</span><span class="sxs-lookup"><span data-stu-id="8cc28-128">.NET provides a range of synchronization primitives to control access to a shared resource by multiple threads.</span></span>

### <a name="monitor-class"></a><span data-ttu-id="8cc28-129">Monitor 類別</span><span class="sxs-lookup"><span data-stu-id="8cc28-129">Monitor class</span></span>

<span data-ttu-id="8cc28-130"><xref:System.Threading.Monitor?displayProperty=nameWithType> 類別會透過取得或釋放能識別共用資源之物件上的鎖定，來授與對該資源的互斥存取。</span><span class="sxs-lookup"><span data-stu-id="8cc28-130">The <xref:System.Threading.Monitor?displayProperty=nameWithType> class grants mutually exclusive access to a shared resource by acquiring or releasing a lock on the object that identifies the resource.</span></span> <span data-ttu-id="8cc28-131">持有鎖定時，持有鎖定的執行緒可以再次取得並釋放鎖定。</span><span class="sxs-lookup"><span data-stu-id="8cc28-131">While a lock is held, the thread that holds the lock can again acquire and release the lock.</span></span> <span data-ttu-id="8cc28-132">其他執行緒將無法取得鎖定，且 <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> 方法會等待直到釋放鎖定為止。</span><span class="sxs-lookup"><span data-stu-id="8cc28-132">Any other thread is blocked from acquiring the lock and the <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> method waits until the lock is released.</span></span> <span data-ttu-id="8cc28-133"><xref:System.Threading.Monitor.Enter%2A> 方法會取得已釋放的鎖定。</span><span class="sxs-lookup"><span data-stu-id="8cc28-133">The <xref:System.Threading.Monitor.Enter%2A> method acquires a released lock.</span></span> <span data-ttu-id="8cc28-134">您也可以使用 <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType> 方法來指定執行緒嘗試取得鎖定的時間長度。</span><span class="sxs-lookup"><span data-stu-id="8cc28-134">You can also use the <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType> method to specify the amount of time during which a thread attempts to acquire a lock.</span></span> <span data-ttu-id="8cc28-135">由於 <xref:System.Threading.Monitor> 類別具有執行緒同質性，因此取得鎖定的執行緒必須呼叫 <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> 方法來釋放鎖定。</span><span class="sxs-lookup"><span data-stu-id="8cc28-135">Because the <xref:System.Threading.Monitor> class has thread affinity, the thread that acquired a lock must release the lock by calling the <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="8cc28-136">您可以使用 <xref:System.Threading.Monitor.Wait%2A?displayProperty=nameWithType>、<xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType> 與 <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType> 方法來協調在相同物件上取得鎖定之執行緒的互動。</span><span class="sxs-lookup"><span data-stu-id="8cc28-136">You can coordinate the interaction of threads that acquire a lock on the same object by using the <xref:System.Threading.Monitor.Wait%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType>, and <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType> methods.</span></span>

<span data-ttu-id="8cc28-137">如需詳細資訊，請參閱 <xref:System.Threading.Monitor> API 參考。</span><span class="sxs-lookup"><span data-stu-id="8cc28-137">For more information, see the <xref:System.Threading.Monitor> API reference.</span></span>

> [!NOTE]
> <span data-ttu-id="8cc28-138">請使用以 C# 撰寫的 [lock](../../csharp/language-reference/keywords/lock-statement.md) 陳述式，以及使用 Visual Basic 撰寫的 [SyncLock](../../visual-basic/language-reference/statements/synclock-statement.md) 陳述式來同步對共用資源的存取，而不要直接使用 <xref:System.Threading.Monitor>。</span><span class="sxs-lookup"><span data-stu-id="8cc28-138">Use the [lock](../../csharp/language-reference/keywords/lock-statement.md) statement in C# and the [SyncLock](../../visual-basic/language-reference/statements/synclock-statement.md) statement in Visual Basic to synchronize access to a shared resource instead of using the <xref:System.Threading.Monitor> class directly.</span></span> <span data-ttu-id="8cc28-139">那些陳述式是使用 <xref:System.Threading.Monitor.Enter%2A> 與 <xref:System.Threading.Monitor.Exit%2A> 方法來實作，並會使用 `try…finally` 區塊以確保所取得的鎖定一律會被釋放。</span><span class="sxs-lookup"><span data-stu-id="8cc28-139">Those statements are implemented by using the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> methods and a `try…finally` block to ensure that the acquired lock is always released.</span></span>

### <a name="mutex-class"></a><span data-ttu-id="8cc28-140">Mutex 類別</span><span class="sxs-lookup"><span data-stu-id="8cc28-140">Mutex class</span></span>

<span data-ttu-id="8cc28-141"><xref:System.Threading.Mutex?displayProperty=nameWithType> 類別，它和 <xref:System.Threading.Monitor> 相同，能授與對共用資源的獨佔存取權。</span><span class="sxs-lookup"><span data-stu-id="8cc28-141">The <xref:System.Threading.Mutex?displayProperty=nameWithType> class, like <xref:System.Threading.Monitor>, grants exclusive access to a shared resource.</span></span> <span data-ttu-id="8cc28-142">使用其中一個 [Mutex.WaitOne](<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>) 方法多載來要求 Mutex 的擁有權。</span><span class="sxs-lookup"><span data-stu-id="8cc28-142">Use one of the [Mutex.WaitOne](<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>) method overloads to request the ownership of a mutex.</span></span> <span data-ttu-id="8cc28-143">與 <xref:System.Threading.Monitor> 類似，<xref:System.Threading.Mutex> 具有執行緒同質性，且取得 Mutex 的執行緒必須呼叫 <xref:System.Threading.Mutex.ReleaseMutex%2A?displayProperty=nameWithType> 方法來釋放它。</span><span class="sxs-lookup"><span data-stu-id="8cc28-143">Like <xref:System.Threading.Monitor>, <xref:System.Threading.Mutex> has thread affinity and the thread that acquired a mutex must release it by calling the <xref:System.Threading.Mutex.ReleaseMutex%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="8cc28-144">與 <xref:System.Threading.Monitor> 不同，<xref:System.Threading.Mutex> 類別可以用於處理序間的同步處理。</span><span class="sxs-lookup"><span data-stu-id="8cc28-144">Unlike <xref:System.Threading.Monitor>, the <xref:System.Threading.Mutex> class can be used for inter-process synchronization.</span></span> <span data-ttu-id="8cc28-145">若要這麼做，請使用具名 Mutex，這能使其於整個作業系統中皆可見。</span><span class="sxs-lookup"><span data-stu-id="8cc28-145">To do that, use a named mutex, which is visible throughout the operating system.</span></span> <span data-ttu-id="8cc28-146">若要建立具名 Mutex 執行個體，請使用能指定名稱的 [Mutex 建構函式](<xref:System.Threading.Mutex.%23ctor%2A>)。</span><span class="sxs-lookup"><span data-stu-id="8cc28-146">To create a named mutex instance, use a [Mutex constructor](<xref:System.Threading.Mutex.%23ctor%2A>) that specifies a name.</span></span> <span data-ttu-id="8cc28-147">您也可以呼叫 <xref:System.Threading.Mutex.OpenExisting%2A?displayProperty=nameWithType> 方法來開啟現有的已命名系統 mutex。</span><span class="sxs-lookup"><span data-stu-id="8cc28-147">You can also call the <xref:System.Threading.Mutex.OpenExisting%2A?displayProperty=nameWithType> method to open an existing named system mutex.</span></span>
  
<span data-ttu-id="8cc28-148">如需詳細資訊，請參閱 [Mutex](mutexes.md) 文章與 <xref:System.Threading.Mutex> API 參考文件。</span><span class="sxs-lookup"><span data-stu-id="8cc28-148">For more information, see the [Mutexes](mutexes.md) article and the <xref:System.Threading.Mutex> API reference.</span></span>

### <a name="spinlock-structure"></a><span data-ttu-id="8cc28-149">SpinLock 結構</span><span class="sxs-lookup"><span data-stu-id="8cc28-149">SpinLock structure</span></span>

<span data-ttu-id="8cc28-150"><xref:System.Threading.SpinLock?displayProperty=nameWithType> 結構與 <xref:System.Threading.Monitor> 類似，能根據鎖定的可用性授與對共用資源的獨佔存取。</span><span class="sxs-lookup"><span data-stu-id="8cc28-150">The <xref:System.Threading.SpinLock?displayProperty=nameWithType> structure, like <xref:System.Threading.Monitor>, grants exclusive access to a shared resource based on the availability of a lock.</span></span> <span data-ttu-id="8cc28-151">當 <xref:System.Threading.SpinLock> 嘗試取得不可用的鎖定時，它會在迴圈中等候並重複檢查，直到該鎖定變得可用為止。</span><span class="sxs-lookup"><span data-stu-id="8cc28-151">When <xref:System.Threading.SpinLock> attempts to acquire a lock that is unavailable, it waits in a loop, repeatedly checking until the lock becomes available.</span></span>

<span data-ttu-id="8cc28-152">如需使用微調鎖定之優缺點的詳細資訊，請參閱 [SpinLock](spinlock.md) 文章與 <xref:System.Threading.SpinLock> API 參考。</span><span class="sxs-lookup"><span data-stu-id="8cc28-152">For more information about the benefits and drawbacks of using spin lock, see the [SpinLock](spinlock.md) article and the <xref:System.Threading.SpinLock> API reference.</span></span>

### <a name="readerwriterlockslim-class"></a><span data-ttu-id="8cc28-153">ReaderWriterLockSlim 類別</span><span class="sxs-lookup"><span data-stu-id="8cc28-153">ReaderWriterLockSlim class</span></span>

<span data-ttu-id="8cc28-154"><xref:System.Threading.ReaderWriterLockSlim?displayProperty=nameWithType> 類別會授與對共用資源進行寫入的獨佔存取權，並允許多個執行緒同時存取該資源以進行讀取。</span><span class="sxs-lookup"><span data-stu-id="8cc28-154">The <xref:System.Threading.ReaderWriterLockSlim?displayProperty=nameWithType> class grants exclusive access to a shared resource for writing and allows multiple threads to access the resource simultaneously for reading.</span></span> <span data-ttu-id="8cc28-155">您應該使用 <xref:System.Threading.ReaderWriterLockSlim> 來同步對支援安全執行緒讀取作業，但需要獨佔存取以執行寫入作業之共用資料結構的存取。</span><span class="sxs-lookup"><span data-stu-id="8cc28-155">You might want to use <xref:System.Threading.ReaderWriterLockSlim> to synchronize access to a shared data structure that supports thread-safe read operations, but requires exclusive access to perform write operation.</span></span> <span data-ttu-id="8cc28-156">當執行緒要求獨佔存取權 (例如，透過呼叫 <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A?displayProperty=nameWithType> 方法) 時，後續的讀取器和寫入器要求會封鎖直到所有現有讀取器都結束鎖定，且寫入器已進入並離開鎖定為止。</span><span class="sxs-lookup"><span data-stu-id="8cc28-156">When a thread requests exclusive access (for example, by calling the <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A?displayProperty=nameWithType> method), subsequent reader and writer requests block until all existing readers have exited the lock, and the writer has entered and exited the lock.</span></span>
  
<span data-ttu-id="8cc28-157">如需詳細資訊，請參閱 <xref:System.Threading.ReaderWriterLockSlim> API 參考。</span><span class="sxs-lookup"><span data-stu-id="8cc28-157">For more information, see the <xref:System.Threading.ReaderWriterLockSlim> API reference.</span></span>

### <a name="semaphore-and-semaphoreslim-classes"></a><span data-ttu-id="8cc28-158">旗號與 SemaphoreSlim 類別</span><span class="sxs-lookup"><span data-stu-id="8cc28-158">Semaphore and SemaphoreSlim classes</span></span>

<span data-ttu-id="8cc28-159"><xref:System.Threading.Semaphore?displayProperty=nameWithType> 與 <xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType> 類別能限制可以同時存取共用資源或資源集區的執行緒數目。</span><span class="sxs-lookup"><span data-stu-id="8cc28-159">The <xref:System.Threading.Semaphore?displayProperty=nameWithType> and <xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType> classes limit the number of threads that can access a shared resource or a pool of resources concurrently.</span></span> <span data-ttu-id="8cc28-160">要求資源的其他執行緒需等候，直到執行緒釋放旗號為止。</span><span class="sxs-lookup"><span data-stu-id="8cc28-160">Additional threads that request the resource wait until any thread releases the semaphore.</span></span> <span data-ttu-id="8cc28-161">由於旗號不具有執行緒同質性，因此某個執行緒可以取得旗號，並由另一個執行緒釋放它。</span><span class="sxs-lookup"><span data-stu-id="8cc28-161">Because the semaphore doesn't have thread affinity, a thread can acquire the semaphore and another one can release it.</span></span>

<span data-ttu-id="8cc28-162"><xref:System.Threading.SemaphoreSlim> 是 <xref:System.Threading.Semaphore> 的輕量型替代方案，並僅可用於在單一處理序界限內進行同步處理。</span><span class="sxs-lookup"><span data-stu-id="8cc28-162"><xref:System.Threading.SemaphoreSlim> is a lightweight alternative to <xref:System.Threading.Semaphore> and can be used only for synchronization within a single process boundary.</span></span>

<span data-ttu-id="8cc28-163">在 Windows 上，您可以使用 <xref:System.Threading.Semaphore> 以進行處理序間的同步處理。</span><span class="sxs-lookup"><span data-stu-id="8cc28-163">On Windows, you can use <xref:System.Threading.Semaphore> for the inter-process synchronization.</span></span> <span data-ttu-id="8cc28-164">若要這麼做，請使用其中一個能指定名稱的[旗號建構函式](<xref:System.Threading.Semaphore.%23ctor%2A>)或 <xref:System.Threading.Semaphore.OpenExisting%2A?displayProperty=nameWithType> 方法，建立代表具名系統旗號的 <xref:System.Threading.Semaphore> 執行個體。</span><span class="sxs-lookup"><span data-stu-id="8cc28-164">To do that, create a <xref:System.Threading.Semaphore> instance that represents a named system semaphore by using one of the [Semaphore constructors](<xref:System.Threading.Semaphore.%23ctor%2A>) that specifies a name or the <xref:System.Threading.Semaphore.OpenExisting%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="8cc28-165"><xref:System.Threading.SemaphoreSlim> 不支援具名系統旗號。</span><span class="sxs-lookup"><span data-stu-id="8cc28-165"><xref:System.Threading.SemaphoreSlim> doesn't support named system semaphores.</span></span>

<span data-ttu-id="8cc28-166">如需詳細資訊，請參閱[旗號與 SemaphoreSlim](semaphore-and-semaphoreslim.md) 文章，以及 <xref:System.Threading.Semaphore> 或 <xref:System.Threading.SemaphoreSlim> API 參考。</span><span class="sxs-lookup"><span data-stu-id="8cc28-166">For more information, see the [Semaphore and SemaphoreSlim](semaphore-and-semaphoreslim.md) article and the <xref:System.Threading.Semaphore> or <xref:System.Threading.SemaphoreSlim> API reference.</span></span>

## <a name="thread-interaction-or-signaling"></a><span data-ttu-id="8cc28-167">執行緒互動 (或訊號處理)</span><span class="sxs-lookup"><span data-stu-id="8cc28-167">Thread interaction, or signaling</span></span>

<span data-ttu-id="8cc28-168">執行緒互動 (或執行緒訊號處理) 表示執行緒必須等候來自一或多個執行緒的通知 (或訊號)，才能繼續執行。</span><span class="sxs-lookup"><span data-stu-id="8cc28-168">Thread interaction (or thread signaling) means that a thread must wait for notification, or a signal, from one or more threads in order to proceed.</span></span> <span data-ttu-id="8cc28-169">例如，如果執行緒 A 呼叫執行緒 B 的 <xref:System.Threading.Thread.Join%2A?displayProperty=nameWithType> 方法，在執行緒 B 完成之前，執行緒 A 將會被封鎖。</span><span class="sxs-lookup"><span data-stu-id="8cc28-169">For example, if thread A calls the <xref:System.Threading.Thread.Join%2A?displayProperty=nameWithType> method of thread B, thread A is blocked until thread B completes.</span></span> <span data-ttu-id="8cc28-170">上一節所描述的同步處理原始物件能提供不同的訊號處理機制：執行緒可以透過釋放鎖定，來通知另一個執行緒其可以取得鎖定來繼續執行。</span><span class="sxs-lookup"><span data-stu-id="8cc28-170">The synchronization primitives described in the preceding section provide a different mechanism for signaling: by releasing a lock, a thread notifies another thread that it can proceed by acquiring the lock.</span></span>

<span data-ttu-id="8cc28-171">此節描述由 .NET 提供的其他訊號處理建構。</span><span class="sxs-lookup"><span data-stu-id="8cc28-171">This section describes additional signaling constructs provided by .NET.</span></span>

### <a name="eventwaithandle-autoresetevent-manualresetevent-and-manualreseteventslim-classes"></a><span data-ttu-id="8cc28-172">EventWaitHandle、AutoResetEvent、ManualResetEvent 與 ManualResetEventSlim 類別</span><span class="sxs-lookup"><span data-stu-id="8cc28-172">EventWaitHandle, AutoResetEvent, ManualResetEvent, and ManualResetEventSlim classes</span></span>

<span data-ttu-id="8cc28-173"><xref:System.Threading.EventWaitHandle?displayProperty=nameWithType> 類別代表執行緒同步處理事件。</span><span class="sxs-lookup"><span data-stu-id="8cc28-173">The <xref:System.Threading.EventWaitHandle?displayProperty=nameWithType> class represents a thread synchronization event.</span></span>

<span data-ttu-id="8cc28-174">同步處理事件可以處於未收到訊號或已收到訊號的狀態。</span><span class="sxs-lookup"><span data-stu-id="8cc28-174">A synchronization event can be either in an unsignaled or signaled state.</span></span> <span data-ttu-id="8cc28-175">當事件的狀態為未收到訊號時，呼叫該事件之 <xref:System.Threading.WaitHandle.WaitOne%2A?> 多載的執行緒會被封鎖，直到事件收到訊號為止。</span><span class="sxs-lookup"><span data-stu-id="8cc28-175">When the state of an event is unsignaled, a thread that calls the event's <xref:System.Threading.WaitHandle.WaitOne%2A?> overload is blocked until an event is signaled.</span></span> <span data-ttu-id="8cc28-176"><xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType> 方法會將事件的狀態設定為已收到訊號。</span><span class="sxs-lookup"><span data-stu-id="8cc28-176">The <xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType> method sets the state of an event to signaled.</span></span>

<span data-ttu-id="8cc28-177">已收到訊號之 <xref:System.Threading.EventWaitHandle> 的行為會取決於其重設模式：</span><span class="sxs-lookup"><span data-stu-id="8cc28-177">The behavior of an <xref:System.Threading.EventWaitHandle> that has been signaled depends on its reset mode:</span></span>

- <span data-ttu-id="8cc28-178">搭配 <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> 旗標建立的 <xref:System.Threading.EventWaitHandle>，會在發佈單一等候執行緒後自動重設。</span><span class="sxs-lookup"><span data-stu-id="8cc28-178">An <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag resets automatically after releasing a single waiting thread.</span></span> <span data-ttu-id="8cc28-179">它就像是在每次收到訊號時僅允許單一執行緒通過的十字轉門一般。</span><span class="sxs-lookup"><span data-stu-id="8cc28-179">It's like a turnstile that allows only one thread through each time it's signaled.</span></span> <span data-ttu-id="8cc28-180"><xref:System.Threading.AutoResetEvent?displayProperty=nameWithType> 類別 (衍生自 <xref:System.Threading.EventWaitHandle>) 代表該行為。</span><span class="sxs-lookup"><span data-stu-id="8cc28-180">The <xref:System.Threading.AutoResetEvent?displayProperty=nameWithType> class, which derives from <xref:System.Threading.EventWaitHandle>, represents that behavior.</span></span>
- <span data-ttu-id="8cc28-181">搭配 <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> 旗標建立的 <xref:System.Threading.EventWaitHandle> 會維持已收到訊號的狀態，直到其 <xref:System.Threading.EventWaitHandle.Reset%2A> 方法被呼叫為止。</span><span class="sxs-lookup"><span data-stu-id="8cc28-181">An <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag remains signaled until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span> <span data-ttu-id="8cc28-182">它就像是在收到訊號前會保持關閉，並在有人重新關閉它前會持續開啟的閘門一般。</span><span class="sxs-lookup"><span data-stu-id="8cc28-182">It's like a gate that is closed until signaled and then stays open until someone closes it.</span></span> <span data-ttu-id="8cc28-183"><xref:System.Threading.ManualResetEvent?displayProperty=nameWithType> 類別 (衍生自 <xref:System.Threading.EventWaitHandle>) 代表該行為。</span><span class="sxs-lookup"><span data-stu-id="8cc28-183">The <xref:System.Threading.ManualResetEvent?displayProperty=nameWithType> class, which derives from <xref:System.Threading.EventWaitHandle>, represents that behavior.</span></span> <span data-ttu-id="8cc28-184"><xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType> 類別是 <xref:System.Threading.ManualResetEvent> 的輕量型替代方案。</span><span class="sxs-lookup"><span data-stu-id="8cc28-184">The <xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType> class is a lightweight alternative to <xref:System.Threading.ManualResetEvent>.</span></span>

<span data-ttu-id="8cc28-185">在 Windows 上，您可以使用 <xref:System.Threading.EventWaitHandle> 以進行處理序間的同步處理。</span><span class="sxs-lookup"><span data-stu-id="8cc28-185">On Windows, you can use <xref:System.Threading.EventWaitHandle> for the inter-process synchronization.</span></span> <span data-ttu-id="8cc28-186">若要這麼做，請使用其中一個能指定名稱的 [EventWaitHandle 建構函式](<xref:System.Threading.EventWaitHandle.%23ctor%2A>)或 <xref:System.Threading.EventWaitHandle.OpenExisting%2A?displayProperty=nameWithType> 方法，建立代表具名系統同步處理事件的 <xref:System.Threading.EventWaitHandle> 執行個體。</span><span class="sxs-lookup"><span data-stu-id="8cc28-186">To do that, create a <xref:System.Threading.EventWaitHandle> instance that represents a named system synchronization event by using one of the [EventWaitHandle constructors](<xref:System.Threading.EventWaitHandle.%23ctor%2A>) that specifies a name or the <xref:System.Threading.EventWaitHandle.OpenExisting%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="8cc28-187">如需詳細資訊，請參閱 [EventWaitHandle](eventwaithandle.md) 文章。</span><span class="sxs-lookup"><span data-stu-id="8cc28-187">For more information, see the [EventWaitHandle](eventwaithandle.md) article.</span></span> <span data-ttu-id="8cc28-188">如需 API 參考，請參閱 <xref:System.Threading.EventWaitHandle>、<xref:System.Threading.AutoResetEvent>、<xref:System.Threading.ManualResetEvent> 與 <xref:System.Threading.ManualResetEventSlim>。</span><span class="sxs-lookup"><span data-stu-id="8cc28-188">For the API reference, see <xref:System.Threading.EventWaitHandle>, <xref:System.Threading.AutoResetEvent>, <xref:System.Threading.ManualResetEvent>, and <xref:System.Threading.ManualResetEventSlim>.</span></span>

### <a name="countdownevent-class"></a><span data-ttu-id="8cc28-189">CountdownEvent 類別</span><span class="sxs-lookup"><span data-stu-id="8cc28-189">CountdownEvent class</span></span>

<span data-ttu-id="8cc28-190"><xref:System.Threading.CountdownEvent?displayProperty=nameWithType> 類別代表會在計數為零時被設定的事件。</span><span class="sxs-lookup"><span data-stu-id="8cc28-190">The <xref:System.Threading.CountdownEvent?displayProperty=nameWithType> class represents an event that becomes set when its count is zero.</span></span> <span data-ttu-id="8cc28-191">在 <xref:System.Threading.CountdownEvent.CurrentCount?displayProperty=nameWithType> 大於零時，呼叫 <xref:System.Threading.CountdownEvent.Wait%2A?displayProperty=nameWithType> 的執行緒將會被封鎖。</span><span class="sxs-lookup"><span data-stu-id="8cc28-191">While <xref:System.Threading.CountdownEvent.CurrentCount?displayProperty=nameWithType> is greater than zero, a thread that calls <xref:System.Threading.CountdownEvent.Wait%2A?displayProperty=nameWithType> is blocked.</span></span> <span data-ttu-id="8cc28-192">呼叫 <xref:System.Threading.CountdownEvent.Signal%2A?displayProperty=nameWithType> 來使事件的計數遞減。</span><span class="sxs-lookup"><span data-stu-id="8cc28-192">Call <xref:System.Threading.CountdownEvent.Signal%2A?displayProperty=nameWithType> to decrement an event's count.</span></span>

<span data-ttu-id="8cc28-193">與可透過來自單一執行緒的訊號將多個執行緒解除封鎖的 <xref:System.Threading.ManualResetEvent> 或 <xref:System.Threading.ManualResetEventSlim> 相反，您可以使用 <xref:System.Threading.CountdownEvent> 以透過來自多個執行緒的訊號，將一或多個執行緒解除封鎖。</span><span class="sxs-lookup"><span data-stu-id="8cc28-193">In contrast to <xref:System.Threading.ManualResetEvent> or <xref:System.Threading.ManualResetEventSlim>, which you can use to unblock multiple threads with a signal from one thread, you can use <xref:System.Threading.CountdownEvent> to unblock one or more threads with signals from multiple threads.</span></span>

<span data-ttu-id="8cc28-194">如需詳細資訊，請參閱 [CountdownEvent](countdownevent.md) 文章與 <xref:System.Threading.CountdownEvent> API 參考。</span><span class="sxs-lookup"><span data-stu-id="8cc28-194">For more information, see the [CountdownEvent](countdownevent.md) article and the <xref:System.Threading.CountdownEvent> API reference.</span></span>

### <a name="barrier-class"></a><span data-ttu-id="8cc28-195">Barrier 類別</span><span class="sxs-lookup"><span data-stu-id="8cc28-195">Barrier class</span></span>

<span data-ttu-id="8cc28-196"><xref:System.Threading.Barrier?displayProperty=nameWithType> 類別代表執行緒執行屏障。</span><span class="sxs-lookup"><span data-stu-id="8cc28-196">The <xref:System.Threading.Barrier?displayProperty=nameWithType> class represents a thread execution barrier.</span></span> <span data-ttu-id="8cc28-197">呼叫 <xref:System.Threading.Barrier.SignalAndWait%2A?displayProperty=nameWithType> 方法的執行緒會發出其已抵達屏障的訊號，並會持續等候，直到其他參與者執行緒也抵達屏障為止。</span><span class="sxs-lookup"><span data-stu-id="8cc28-197">A thread that calls the <xref:System.Threading.Barrier.SignalAndWait%2A?displayProperty=nameWithType> method signals that it reached the barrier and waits until other participant threads reach the barrier.</span></span> <span data-ttu-id="8cc28-198">當所有參與者執行緒皆抵達屏障時，它們便會繼續執行，而該屏障也會重設並可供再次使用。</span><span class="sxs-lookup"><span data-stu-id="8cc28-198">When all participant threads reach the barrier, they proceed and the barrier is reset and can be used again.</span></span>

<span data-ttu-id="8cc28-199">當有一或多個執行緒需要取得其他執行緒的結果以繼續至下個運算階段時，您可以使用 <xref:System.Threading.Barrier>。</span><span class="sxs-lookup"><span data-stu-id="8cc28-199">You might use <xref:System.Threading.Barrier> when one or more threads require the results of other threads before proceeding to the next computation phase.</span></span>

<span data-ttu-id="8cc28-200">如需詳細資訊，請參閱[屏障](barrier.md)文章與 <xref:System.Threading.Barrier> API 參考。</span><span class="sxs-lookup"><span data-stu-id="8cc28-200">For more information, see the [Barrier](barrier.md) article and the <xref:System.Threading.Barrier> API reference.</span></span>

## <a name="interlocked-class"></a><span data-ttu-id="8cc28-201">Interlocked 類別</span><span class="sxs-lookup"><span data-stu-id="8cc28-201">Interlocked class</span></span>

<span data-ttu-id="8cc28-202"><xref:System.Threading.Interlocked?displayProperty=nameWithType> 類別可提供能針對變數執行簡易不可部分完成之作業的靜態方法。</span><span class="sxs-lookup"><span data-stu-id="8cc28-202">The <xref:System.Threading.Interlocked?displayProperty=nameWithType> class provides static methods that perform simple atomic operations on a variable.</span></span> <span data-ttu-id="8cc28-203">那些不可部分完成的作業包括對 64 位元整數值的相加、遞增和遞減、根據比較的交換和條件式交換，以及讀取作業。</span><span class="sxs-lookup"><span data-stu-id="8cc28-203">Those atomic operations include addition, increment and decrement, exchange and conditional exchange that depends on a comparison, and read operation of a 64-bit integer value.</span></span>

<span data-ttu-id="8cc28-204">如需詳細資訊，請參閱 <xref:System.Threading.Interlocked> API 參考。</span><span class="sxs-lookup"><span data-stu-id="8cc28-204">For more information, see the <xref:System.Threading.Interlocked> API reference.</span></span>

## <a name="spinwait-structure"></a><span data-ttu-id="8cc28-205">SpinWait 結構</span><span class="sxs-lookup"><span data-stu-id="8cc28-205">SpinWait structure</span></span>

<span data-ttu-id="8cc28-206"><xref:System.Threading.SpinWait?displayProperty=nameWithType> 結構能提供微調式等候的支援。</span><span class="sxs-lookup"><span data-stu-id="8cc28-206">The <xref:System.Threading.SpinWait?displayProperty=nameWithType> structure provides support for spin-based waiting.</span></span> <span data-ttu-id="8cc28-207">當執行緒必須等待事件收到訊號或符合條件，但實際的等待時間預期會少於使用等候控制代碼或以其他方式封鎖執行緒的等候時間時，您便可以使用它。</span><span class="sxs-lookup"><span data-stu-id="8cc28-207">You might want to use it when a thread has to wait for an event to be signaled or a condition to be met, but when the actual wait time is expected to be less than the waiting time required by using a wait handle or by otherwise blocking the thread.</span></span> <span data-ttu-id="8cc28-208">使用 <xref:System.Threading.SpinWait>，您可以指定在等待時旋轉一小段時間，並且只有在指定的時間內未符合條件時放棄 (例如，藉由等待或睡眠)。</span><span class="sxs-lookup"><span data-stu-id="8cc28-208">By using <xref:System.Threading.SpinWait>, you can specify a short period of time to spin while waiting, and then yield (for example, by waiting or sleeping) only if the condition was not met in the specified time.</span></span>

<span data-ttu-id="8cc28-209">如需詳細資訊，請參閱 [SpinWait](spinwait.md) 文章與 <xref:System.Threading.SpinWait> API 參考。</span><span class="sxs-lookup"><span data-stu-id="8cc28-209">For more information, see the [SpinWait](spinwait.md) article and the <xref:System.Threading.SpinWait> API reference.</span></span>

## <a name="see-also"></a><span data-ttu-id="8cc28-210">請參閱</span><span class="sxs-lookup"><span data-stu-id="8cc28-210">See also</span></span>

- <xref:System.Collections.Concurrent?displayProperty=nameWithType>
- [<span data-ttu-id="8cc28-211">安全執行緒集合</span><span class="sxs-lookup"><span data-stu-id="8cc28-211">Thread-safe collections</span></span>](../collections/thread-safe/index.md)
- [<span data-ttu-id="8cc28-212">執行緒物件和功能</span><span class="sxs-lookup"><span data-stu-id="8cc28-212">Threading objects and features</span></span>](threading-objects-and-features.md)
