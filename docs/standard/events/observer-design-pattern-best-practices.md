---
title: 觀察器設計模式最佳作法
ms.date: 03/30/2017
ms.technology: dotnet-standard
helpviewer_keywords:
- observer design pattern [.NET Framework], best practices
- best practices [.NET Framework], observer design pattern
ms.assetid: c834760f-ddd4-417f-abb7-a059679d5b8c
ms.openlocfilehash: b4f8e568dcb6790dac1dc8fc5c969d6fa1367c4e
ms.sourcegitcommit: 33deec3e814238fb18a49b2a7e89278e27888291
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 06/02/2020
ms.locfileid: "84288455"
---
# <a name="observer-design-pattern-best-practices"></a><span data-ttu-id="2e0bb-102">觀察器設計模式最佳作法</span><span class="sxs-lookup"><span data-stu-id="2e0bb-102">Observer Design Pattern Best Practices</span></span>
<span data-ttu-id="2e0bb-103">在 .NET Framework 中，觀察者設計模式會實作為一組介面。</span><span class="sxs-lookup"><span data-stu-id="2e0bb-103">In the .NET Framework, the observer design pattern is implemented as a set of interfaces.</span></span> <span data-ttu-id="2e0bb-104"><xref:System.IObservable%601?displayProperty=nameWithType> 介面代表資料提供者，它也負責提供 <xref:System.IDisposable> 實作，讓觀察者可以取消訂閱通知。</span><span class="sxs-lookup"><span data-stu-id="2e0bb-104">The <xref:System.IObservable%601?displayProperty=nameWithType> interface represents the data provider, which is also responsible for providing an <xref:System.IDisposable> implementation that lets observers unsubscribe from notifications.</span></span> <span data-ttu-id="2e0bb-105"><xref:System.IObserver%601?displayProperty=nameWithType> 介面代表觀察者。</span><span class="sxs-lookup"><span data-stu-id="2e0bb-105">The <xref:System.IObserver%601?displayProperty=nameWithType> interface represents the observer.</span></span> <span data-ttu-id="2e0bb-106">本主題說明使用這些介面實作觀察者設計模式時，開發人員應該遵循的最佳作法。</span><span class="sxs-lookup"><span data-stu-id="2e0bb-106">This topic describes the best practices that developers should follow when implementing the observer design pattern using these interfaces.</span></span>  
  
## <a name="threading"></a><span data-ttu-id="2e0bb-107">執行緒</span><span class="sxs-lookup"><span data-stu-id="2e0bb-107">Threading</span></span>  
 <span data-ttu-id="2e0bb-108">一般來說，提供者會藉由將特定觀察者加入由某些集合物件所代表的訂閱者清單，而實作 <xref:System.IObservable%601.Subscribe%2A?displayProperty=nameWithType> 方法，且其會藉由從訂閱者清單中移除特定觀察者而實作 <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="2e0bb-108">Typically, a provider implements the <xref:System.IObservable%601.Subscribe%2A?displayProperty=nameWithType> method by adding a particular observer to a subscriber list that is represented by some collection object, and it implements the <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> method by removing a particular observer from the subscriber list.</span></span> <span data-ttu-id="2e0bb-109">觀察者可隨時呼叫這些方法。</span><span class="sxs-lookup"><span data-stu-id="2e0bb-109">An observer can call these methods at any time.</span></span> <span data-ttu-id="2e0bb-110">此外，因為提供者/觀察者合約未指定負責在 <xref:System.IObserver%601.OnCompleted%2A?displayProperty=nameWithType> 回呼方法之後取消訂閱的人員，所以提供者和觀察者可能會同時嘗試從清單中移除相同的成員。</span><span class="sxs-lookup"><span data-stu-id="2e0bb-110">In addition, because the provider/observer contract does not specify who is responsible for unsubscribing after the <xref:System.IObserver%601.OnCompleted%2A?displayProperty=nameWithType> callback method, the provider and observer may both try to remove the same member from the list.</span></span> <span data-ttu-id="2e0bb-111">因為這種可能性，<xref:System.IObservable%601.Subscribe%2A> 和 <xref:System.IDisposable.Dispose%2A> 方法都應該是安全執行緒。</span><span class="sxs-lookup"><span data-stu-id="2e0bb-111">Because of this possibility, both the <xref:System.IObservable%601.Subscribe%2A> and <xref:System.IDisposable.Dispose%2A> methods should be thread-safe.</span></span> <span data-ttu-id="2e0bb-112">通常，這需要使用[平行集合](../parallel-programming/data-structures-for-parallel-programming.md)或鎖定。</span><span class="sxs-lookup"><span data-stu-id="2e0bb-112">Typically, this involves using a [concurrent collection](../parallel-programming/data-structures-for-parallel-programming.md) or a lock.</span></span> <span data-ttu-id="2e0bb-113">不是安全執行緒的實作，應該要明確地記載它們不是安全執行緒。</span><span class="sxs-lookup"><span data-stu-id="2e0bb-113">Implementations that are not thread-safe should explicitly document that they are not.</span></span>  
  
 <span data-ttu-id="2e0bb-114">除了提供者/觀察者合約之外，還必須在某一層級指定所有其他保證。</span><span class="sxs-lookup"><span data-stu-id="2e0bb-114">Any additional guarantees have to be specified in a layer on top of the provider/observer contract.</span></span> <span data-ttu-id="2e0bb-115">當實作者強制要求其他需求時，應該清楚地宣布，以避免使用者對觀察者合約感到困惑。</span><span class="sxs-lookup"><span data-stu-id="2e0bb-115">Implementers should clearly call out when they impose additional requirements to avoid user confusion about the observer contract.</span></span>  
  
## <a name="handling-exceptions"></a><span data-ttu-id="2e0bb-116">例外狀況處理</span><span class="sxs-lookup"><span data-stu-id="2e0bb-116">Handling Exceptions</span></span>  
 <span data-ttu-id="2e0bb-117">由於資料提供者和觀察者之間的鬆散連接，觀察者設計模式中的例外狀況傾向僅供參考。</span><span class="sxs-lookup"><span data-stu-id="2e0bb-117">Because of the loose coupling between a data provider and an observer, exceptions in the observer design pattern are intended to be informational.</span></span> <span data-ttu-id="2e0bb-118">這會影響提供者和觀察者處理觀察者設計模式中例外狀況的方式。</span><span class="sxs-lookup"><span data-stu-id="2e0bb-118">This affects how providers and observers handle exceptions in the observer design pattern.</span></span>  
  
### <a name="the-provider----calling-the-onerror-method"></a><span data-ttu-id="2e0bb-119">提供者 -- 呼叫 OnError 方法</span><span class="sxs-lookup"><span data-stu-id="2e0bb-119">The Provider -- Calling the OnError Method</span></span>  
 <span data-ttu-id="2e0bb-120"><xref:System.IObserver%601.OnError%2A> 方法旨在為觀察者提供參考訊息，和 <xref:System.IObserver%601.OnNext%2A?displayProperty=nameWithType> 方法很像。</span><span class="sxs-lookup"><span data-stu-id="2e0bb-120">The <xref:System.IObserver%601.OnError%2A> method is intended as an informational message to observers, much like the <xref:System.IObserver%601.OnNext%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="2e0bb-121">不過，<xref:System.IObserver%601.OnNext%2A> 方法是設計來提供觀察者最近或更新過的資料，而 <xref:System.IObserver%601.OnError%2A> 方法則設計來指出提供者無法提供有效的資料。</span><span class="sxs-lookup"><span data-stu-id="2e0bb-121">However, the <xref:System.IObserver%601.OnNext%2A> method is designed to provide an observer with current or updated data, whereas the <xref:System.IObserver%601.OnError%2A> method is designed to indicate that the provider is unable to provide valid data.</span></span>  
  
 <span data-ttu-id="2e0bb-122">提供者在處理例外狀況及呼叫 <xref:System.IObserver%601.OnError%2A> 方法時，應遵循這些最佳作法：</span><span class="sxs-lookup"><span data-stu-id="2e0bb-122">The provider should follow these best practices when handling exceptions and calling the <xref:System.IObserver%601.OnError%2A> method:</span></span>  
  
- <span data-ttu-id="2e0bb-123">如果有任何特定的需求，提供者必須處理它本身的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="2e0bb-123">The provider must handle its own exceptions if it has any specific requirements.</span></span>  
  
- <span data-ttu-id="2e0bb-124">提供者不應預期或要求觀察者以任何特定方式處理例外狀況。</span><span class="sxs-lookup"><span data-stu-id="2e0bb-124">The provider should not expect or require that observers handle exceptions in any particular way.</span></span>  
  
- <span data-ttu-id="2e0bb-125">提供者應該在處理危害其提供更新能力的例外狀況時，呼叫 <xref:System.IObserver%601.OnError%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="2e0bb-125">The provider should call the <xref:System.IObserver%601.OnError%2A> method when it handles an exception that compromises its ability to provide updates.</span></span> <span data-ttu-id="2e0bb-126">這類例外狀況的詳細資訊，可以傳遞給觀察者。</span><span class="sxs-lookup"><span data-stu-id="2e0bb-126">Information on such exceptions can be passed to the observer.</span></span> <span data-ttu-id="2e0bb-127">在其他情況下，不需要通知觀察者有例外狀況。</span><span class="sxs-lookup"><span data-stu-id="2e0bb-127">In other cases, there is no need to notify observers of an exception.</span></span>  
  
 <span data-ttu-id="2e0bb-128">一旦提供者呼叫了 <xref:System.IObserver%601.OnError%2A> 或<xref:System.IObserver%601.OnCompleted%2A?displayProperty=nameWithType> 方法，便不應該再有進一步的通知，提供者可以取消訂閱其觀察者。</span><span class="sxs-lookup"><span data-stu-id="2e0bb-128">Once the provider calls the <xref:System.IObserver%601.OnError%2A> or <xref:System.IObserver%601.OnCompleted%2A?displayProperty=nameWithType> method, there should be no further notifications, and the provider can unsubscribe its observers.</span></span> <span data-ttu-id="2e0bb-129">但觀察者也可以隨時取消訂閱自己，包括收到 <xref:System.IObserver%601.OnError%2A> 或 <xref:System.IObserver%601.OnCompleted%2A?displayProperty=nameWithType> 通知之前和之後。</span><span class="sxs-lookup"><span data-stu-id="2e0bb-129">However, the observers can also unsubscribe themselves at any time, including both before and after they receive an <xref:System.IObserver%601.OnError%2A> or <xref:System.IObserver%601.OnCompleted%2A?displayProperty=nameWithType> notification.</span></span> <span data-ttu-id="2e0bb-130">觀察者設計模式不會指定提供者還是觀察者要否要負責取消訂閱；因此，有可能兩者都會嘗試取消訂閱。</span><span class="sxs-lookup"><span data-stu-id="2e0bb-130">The observer design pattern does not dictate whether the provider or the observer is responsible for unsubscribing; therefore, there is a possibility that both may attempt to unsubscribe.</span></span> <span data-ttu-id="2e0bb-131">一般而言，當觀察者取消訂閱時，它們會從訂閱者集合中移除。</span><span class="sxs-lookup"><span data-stu-id="2e0bb-131">Typically, when observers unsubscribe, they are removed from a subscribers collection.</span></span> <span data-ttu-id="2e0bb-132">在單一執行緒應用程式中，<xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> 實作應可確保物件參考有效，且物件是訂閱者集合的成員，然後再嘗試將它移除。</span><span class="sxs-lookup"><span data-stu-id="2e0bb-132">In a single-threaded application, the <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementation should ensure that an object reference is valid and that the object is a member of the subscribers collection before attempting to remove it.</span></span> <span data-ttu-id="2e0bb-133">在多執行緒應用程式中，應使用安全執行緒的集合物件，例如 <xref:System.Collections.Concurrent.BlockingCollection%601?displayProperty=nameWithType> 物件。</span><span class="sxs-lookup"><span data-stu-id="2e0bb-133">In a multithreaded application, a thread-safe collection object, such as a <xref:System.Collections.Concurrent.BlockingCollection%601?displayProperty=nameWithType> object, should be used.</span></span>  
  
### <a name="the-observer----implementing-the-onerror-method"></a><span data-ttu-id="2e0bb-134">觀察者 -- 實作 OnError 方法</span><span class="sxs-lookup"><span data-stu-id="2e0bb-134">The Observer -- Implementing the OnError Method</span></span>  
 <span data-ttu-id="2e0bb-135">當觀察者收到來自提供者的錯誤通知時，觀察者應該將例外狀況視為參考，且應該不需要採取任何特定的動作。</span><span class="sxs-lookup"><span data-stu-id="2e0bb-135">When an observer receives an error notification from a provider, the observer should treat the exception as informational and should not be required to take any particular action.</span></span>  
  
 <span data-ttu-id="2e0bb-136">在回應來自提供者的 <xref:System.IObserver%601.OnError%2A> 方法呼叫時，觀察者應該遵循這些最佳作法：</span><span class="sxs-lookup"><span data-stu-id="2e0bb-136">The observer should follow these best practices when responding to an <xref:System.IObserver%601.OnError%2A> method call from a provider:</span></span>  
  
- <span data-ttu-id="2e0bb-137">觀察者不應該從其介面實作擲回例外狀況，例如 <xref:System.IObserver%601.OnNext%2A> 或 <xref:System.IObserver%601.OnError%2A>。</span><span class="sxs-lookup"><span data-stu-id="2e0bb-137">The observer should not throw exceptions from its interface implementations, such as <xref:System.IObserver%601.OnNext%2A> or <xref:System.IObserver%601.OnError%2A>.</span></span> <span data-ttu-id="2e0bb-138">不過，如果觀察者沒有擲回例外狀況，它應該預期這些例外狀況不會受到處理。</span><span class="sxs-lookup"><span data-stu-id="2e0bb-138">However, if the observer does throw exceptions, it should expect these exceptions to go unhandled.</span></span>  
  
- <span data-ttu-id="2e0bb-139">若要保留呼叫堆疊，則想要擲回傳遞給其 <xref:System.Exception> 方法之 <xref:System.IObserver%601.OnError%2A> 物件的觀察者，在擲回之前應該包裝該例外狀況。</span><span class="sxs-lookup"><span data-stu-id="2e0bb-139">To preserve the call stack, an observer that wishes to throw an <xref:System.Exception> object that was passed to its <xref:System.IObserver%601.OnError%2A> method should wrap the exception before throwing it.</span></span> <span data-ttu-id="2e0bb-140">對此用途應使用標準的例外狀況物件。</span><span class="sxs-lookup"><span data-stu-id="2e0bb-140">A standard exception object should be used for this purpose.</span></span>  
  
## <a name="additional-best-practices"></a><span data-ttu-id="2e0bb-141">其他最佳作法</span><span class="sxs-lookup"><span data-stu-id="2e0bb-141">Additional Best Practices</span></span>  
 <span data-ttu-id="2e0bb-142">嘗試在 <xref:System.IObservable%601.Subscribe%2A?displayProperty=nameWithType> 方法中取消註冊，可能會導致 null 參考。</span><span class="sxs-lookup"><span data-stu-id="2e0bb-142">Attempting to unregister in the <xref:System.IObservable%601.Subscribe%2A?displayProperty=nameWithType> method may result in a null reference.</span></span> <span data-ttu-id="2e0bb-143">因此，我們建議您避免使用這種作法。</span><span class="sxs-lookup"><span data-stu-id="2e0bb-143">Therefore, we recommend that you avoid this practice.</span></span>  
  
 <span data-ttu-id="2e0bb-144">雖然您可以將觀察者附加到多個提供者，但建議的模式是將 <xref:System.IObserver%601> 執行個體只附加到一個 <xref:System.IObservable%601> 執行個體。</span><span class="sxs-lookup"><span data-stu-id="2e0bb-144">Although it is possible to attach an observer to multiple providers, the recommended pattern is to attach an <xref:System.IObserver%601> instance to only one <xref:System.IObservable%601> instance.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="2e0bb-145">另請參閱</span><span class="sxs-lookup"><span data-stu-id="2e0bb-145">See also</span></span>

- [<span data-ttu-id="2e0bb-146">觀察器設計模式</span><span class="sxs-lookup"><span data-stu-id="2e0bb-146">Observer Design Pattern</span></span>](observer-design-pattern.md)
- [<span data-ttu-id="2e0bb-147">如何：執行觀察者</span><span class="sxs-lookup"><span data-stu-id="2e0bb-147">How to: Implement an Observer</span></span>](how-to-implement-an-observer.md)
- [<span data-ttu-id="2e0bb-148">如何：執行提供者</span><span class="sxs-lookup"><span data-stu-id="2e0bb-148">How to: Implement a Provider</span></span>](how-to-implement-a-provider.md)
