---
title: 觀察器設計模式
description: 瞭解 .NET 中的觀察者設計模式。 這種模式可讓訂閱者向提供者註冊和接收通知。
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- IObserver(Of T) interface
- IObservable<T> interface
- IObserver<T> interface
- IObservable(Of T) interface
- observer design pattern [.NET Framework]
ms.assetid: 3680171f-f522-453c-aa4a-54f755a78f88
ms.openlocfilehash: 80dac36199dd13abeab295d4b53a52615e7ae625
ms.sourcegitcommit: 27a15a55019f6b5f2733961738babe94aec0def3
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 09/15/2020
ms.locfileid: "90559157"
---
# <a name="observer-design-pattern"></a><span data-ttu-id="f0bca-104">觀察器設計模式</span><span class="sxs-lookup"><span data-stu-id="f0bca-104">Observer Design Pattern</span></span>

<span data-ttu-id="f0bca-105">觀察者設計模式可讓訂閱者向提供者註冊，並且接收通知。</span><span class="sxs-lookup"><span data-stu-id="f0bca-105">The observer design pattern enables a subscriber to register with and receive notifications from a provider.</span></span> <span data-ttu-id="f0bca-106">它適合任何需要推入型通知的情節。</span><span class="sxs-lookup"><span data-stu-id="f0bca-106">It is suitable for any scenario that requires push-based notification.</span></span> <span data-ttu-id="f0bca-107">這個模式會定義「提供者」**(也稱為「主題」** 或「可預見值」**)，以及零個、一個或多個「觀察者」**。</span><span class="sxs-lookup"><span data-stu-id="f0bca-107">The pattern defines a *provider* (also known as a *subject* or an *observable*) and zero, one, or more *observers*.</span></span> <span data-ttu-id="f0bca-108">觀察者會向提供者註冊，而且只要預先定義的條件、事件或狀態有所變更，提供者就會自動呼叫觀察者的其中一種方法，來通知所有觀察者。</span><span class="sxs-lookup"><span data-stu-id="f0bca-108">Observers register with the provider, and whenever a predefined condition, event, or state change occurs, the provider automatically notifies all observers by calling one of their methods.</span></span> <span data-ttu-id="f0bca-109">在這個方法呼叫中，提供者也可以提供目前的狀態資訊給觀察者。</span><span class="sxs-lookup"><span data-stu-id="f0bca-109">In this method call, the provider can also provide current state information to observers.</span></span> <span data-ttu-id="f0bca-110">在 .NET Framework 中，觀察者設計模式是透過實作泛型 <xref:System.IObservable%601?displayProperty=nameWithType> 和 <xref:System.IObserver%601?displayProperty=nameWithType> 介面來套用。</span><span class="sxs-lookup"><span data-stu-id="f0bca-110">In the .NET Framework, the observer design pattern is applied by implementing the generic <xref:System.IObservable%601?displayProperty=nameWithType> and <xref:System.IObserver%601?displayProperty=nameWithType> interfaces.</span></span> <span data-ttu-id="f0bca-111">泛型型別參數代表提供通知資訊的類型。</span><span class="sxs-lookup"><span data-stu-id="f0bca-111">The generic type parameter represents the type that provides notification information.</span></span>

## <a name="applying-the-pattern"></a><span data-ttu-id="f0bca-112">套用模式</span><span class="sxs-lookup"><span data-stu-id="f0bca-112">Applying the Pattern</span></span>

<span data-ttu-id="f0bca-113">觀察者設計模式適合分散式推入型通知，因為它支援清楚分隔兩種不同的元件或應用程式層，例如資料來源 (商務邏輯) 層和使用者介面 (顯示) 層。</span><span class="sxs-lookup"><span data-stu-id="f0bca-113">The observer design pattern is suitable for distributed push-based notifications, because it supports a clean separation between two different components or application layers, such as a data source (business logic) layer and a user interface (display) layer.</span></span> <span data-ttu-id="f0bca-114">當提供者使用回呼將目前的資訊提供給其用戶端時，便會實作這個模式。</span><span class="sxs-lookup"><span data-stu-id="f0bca-114">The pattern can be implemented whenever a provider uses callbacks to supply its clients with current information.</span></span>

<span data-ttu-id="f0bca-115">實作模式需要您提供下列項目：</span><span class="sxs-lookup"><span data-stu-id="f0bca-115">Implementing the pattern requires that you provide the following:</span></span>

- <span data-ttu-id="f0bca-116">提供者或主題，也就是傳送通知給觀察者的物件。</span><span class="sxs-lookup"><span data-stu-id="f0bca-116">A provider or subject, which is the object that sends notifications to observers.</span></span> <span data-ttu-id="f0bca-117">提供者是實作 <xref:System.IObservable%601> 介面的類別或結構。</span><span class="sxs-lookup"><span data-stu-id="f0bca-117">A provider is a class or structure that implements the <xref:System.IObservable%601> interface.</span></span> <span data-ttu-id="f0bca-118">提供者必須實作單一方法 <xref:System.IObservable%601.Subscribe%2A?displayProperty=nameWithType>，觀察者會呼叫該方法，以接收來自提供者的通知。</span><span class="sxs-lookup"><span data-stu-id="f0bca-118">The provider must implement a single method, <xref:System.IObservable%601.Subscribe%2A?displayProperty=nameWithType>, which is called by observers that wish to receive notifications from the provider.</span></span>

- <span data-ttu-id="f0bca-119">觀察者，也就是接收來自提供者之通知的物件。</span><span class="sxs-lookup"><span data-stu-id="f0bca-119">An observer, which is an object that receives notifications from a provider.</span></span> <span data-ttu-id="f0bca-120">觀察者是實作 <xref:System.IObserver%601> 介面的類別或結構。</span><span class="sxs-lookup"><span data-stu-id="f0bca-120">An observer is a class or structure that implements the <xref:System.IObserver%601> interface.</span></span> <span data-ttu-id="f0bca-121">觀察者必須實作三種方法，這三種方法全都是由提供者呼叫：</span><span class="sxs-lookup"><span data-stu-id="f0bca-121">The observer must implement three methods, all of which are called by the provider:</span></span>

  - <span data-ttu-id="f0bca-122"><xref:System.IObserver%601.OnNext%2A?displayProperty=nameWithType>，提供新的或目前的資訊給觀察者。</span><span class="sxs-lookup"><span data-stu-id="f0bca-122"><xref:System.IObserver%601.OnNext%2A?displayProperty=nameWithType>, which supplies the observer with new or current information.</span></span>

  - <span data-ttu-id="f0bca-123"><xref:System.IObserver%601.OnError%2A?displayProperty=nameWithType>，通知觀察者發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="f0bca-123"><xref:System.IObserver%601.OnError%2A?displayProperty=nameWithType>, which informs the observer that an error has occurred.</span></span>

  - <span data-ttu-id="f0bca-124"><xref:System.IObserver%601.OnCompleted%2A?displayProperty=nameWithType>，指出提供者已完成傳送通知。</span><span class="sxs-lookup"><span data-stu-id="f0bca-124"><xref:System.IObserver%601.OnCompleted%2A?displayProperty=nameWithType>, which indicates that the provider has finished sending notifications.</span></span>

- <span data-ttu-id="f0bca-125">允許提供者追蹤觀察者的機制。</span><span class="sxs-lookup"><span data-stu-id="f0bca-125">A mechanism that allows the provider to keep track of observers.</span></span> <span data-ttu-id="f0bca-126">一般而言，提供者會使用容器物件 (例如 <xref:System.Collections.Generic.List%601?displayProperty=nameWithType> 物件) 保留已訂閱通知的 <xref:System.IObserver%601> 實作參考。</span><span class="sxs-lookup"><span data-stu-id="f0bca-126">Typically, the provider uses a container object, such as a <xref:System.Collections.Generic.List%601?displayProperty=nameWithType> object, to hold references to the <xref:System.IObserver%601> implementations that have subscribed to notifications.</span></span> <span data-ttu-id="f0bca-127">基於這個目的使用儲存容器，可讓提供者處理零個到無限多個觀察者。</span><span class="sxs-lookup"><span data-stu-id="f0bca-127">Using a storage container for this purpose enables the provider to handle zero to an unlimited number of observers.</span></span> <span data-ttu-id="f0bca-128">觀察者接收通知的順序並未定義；提供者可自由使用任何方法來決定順序。</span><span class="sxs-lookup"><span data-stu-id="f0bca-128">The order in which observers receive notifications is not defined; the provider is free to use any method to determine the order.</span></span>

- <span data-ttu-id="f0bca-129"><xref:System.IDisposable> 實作，可讓提供者在通知完成時移除觀察者。</span><span class="sxs-lookup"><span data-stu-id="f0bca-129">An <xref:System.IDisposable> implementation that enables the provider to remove observers when notification is complete.</span></span> <span data-ttu-id="f0bca-130">觀察者會從 <xref:System.IObservable%601.Subscribe%2A> 方法接收 <xref:System.IDisposable> 實作的參考，如此觀察者同樣可以在提供者完成傳送通知之前呼叫 <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> 方法來取消訂閱。</span><span class="sxs-lookup"><span data-stu-id="f0bca-130">Observers receive a reference to the <xref:System.IDisposable> implementation from the <xref:System.IObservable%601.Subscribe%2A> method, so they can also call the <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> method to unsubscribe before the provider has finished sending notifications.</span></span>

- <span data-ttu-id="f0bca-131">包含提供者傳送給觀察者之資料的物件。</span><span class="sxs-lookup"><span data-stu-id="f0bca-131">An object that contains the data that the provider sends to its observers.</span></span> <span data-ttu-id="f0bca-132">這個物件的類型對應至 <xref:System.IObservable%601> 和 <xref:System.IObserver%601> 介面的泛型類型參數。</span><span class="sxs-lookup"><span data-stu-id="f0bca-132">The type of this object corresponds to the generic type parameter of the <xref:System.IObservable%601> and <xref:System.IObserver%601> interfaces.</span></span> <span data-ttu-id="f0bca-133">雖然這個物件可以與 <xref:System.IObservable%601> 實作相同，但它常是不同的類型。</span><span class="sxs-lookup"><span data-stu-id="f0bca-133">Although this object can be the same as the <xref:System.IObservable%601> implementation, most commonly it is a separate type.</span></span>

> [!NOTE]
> <span data-ttu-id="f0bca-134">除了實作觀察者設計模式之外，您可能對探索使用 <xref:System.IObservable%601> 和 <xref:System.IObserver%601> 介面建置的程式庫有興趣。</span><span class="sxs-lookup"><span data-stu-id="f0bca-134">In addition to implementing the observer design pattern, you may be interested in exploring libraries that are built using the <xref:System.IObservable%601> and <xref:System.IObserver%601> interfaces.</span></span> <span data-ttu-id="f0bca-135">例如，[Reactive Extensions for .NET (Rx)](/previous-versions/dotnet/reactive-extensions/hh242985(v=vs.103)) 是由一組擴充方法和 LINQ 標準序列運算子所組成，可支援非同步程式設計。</span><span class="sxs-lookup"><span data-stu-id="f0bca-135">For example, [Reactive Extensions for .NET (Rx)](/previous-versions/dotnet/reactive-extensions/hh242985(v=vs.103)) consist of a set of extension methods and LINQ standard sequence operators to support asynchronous programming.</span></span>

## <a name="implementing-the-pattern"></a><span data-ttu-id="f0bca-136">實作模式</span><span class="sxs-lookup"><span data-stu-id="f0bca-136">Implementing the Pattern</span></span>

<span data-ttu-id="f0bca-137">下列範例會使用觀察者設計模式實作機場行李提領資訊系統。</span><span class="sxs-lookup"><span data-stu-id="f0bca-137">The following example uses the observer design pattern to implement an airport baggage claim information system.</span></span> <span data-ttu-id="f0bca-138">`BaggageInfo` 類別提供有關抵達班機及可提領各班機行李之轉盤的資訊。</span><span class="sxs-lookup"><span data-stu-id="f0bca-138">A `BaggageInfo` class provides information about arriving flights and the carousels where baggage from each flight is available for pickup.</span></span> <span data-ttu-id="f0bca-139">下列範例會提供示範。</span><span class="sxs-lookup"><span data-stu-id="f0bca-139">It is shown in the following example.</span></span>

[!code-csharp[Conceptual.ObserverDesignPattern#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.observerdesignpattern/cs/provider.cs#1)]
[!code-vb[Conceptual.ObserverDesignPattern#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.observerdesignpattern/vb/provider.vb#1)]

<span data-ttu-id="f0bca-140">`BaggageHandler` 負責接收有關抵達班機和行李提領轉盤的資訊。</span><span class="sxs-lookup"><span data-stu-id="f0bca-140">A `BaggageHandler` class is responsible for receiving information about arriving flights and baggage claim carousels.</span></span> <span data-ttu-id="f0bca-141">它在內部維護兩個集合：</span><span class="sxs-lookup"><span data-stu-id="f0bca-141">Internally, it maintains two collections:</span></span>

- <span data-ttu-id="f0bca-142">`observers` - 將接收更新資訊的用戶端集合。</span><span class="sxs-lookup"><span data-stu-id="f0bca-142">`observers` - A collection of clients that will receive updated information.</span></span>

- <span data-ttu-id="f0bca-143">`flights` - 班機及其指派轉盤的集合。</span><span class="sxs-lookup"><span data-stu-id="f0bca-143">`flights` - A collection of flights and their assigned carousels.</span></span>

<span data-ttu-id="f0bca-144">這兩個集合都是由在 `BaggageHandler` 類別建構函式中執行個體化的泛型 <xref:System.Collections.Generic.List%601> 物件表示。</span><span class="sxs-lookup"><span data-stu-id="f0bca-144">Both collections are represented by generic <xref:System.Collections.Generic.List%601> objects that are instantiated in the `BaggageHandler` class constructor.</span></span> <span data-ttu-id="f0bca-145">下列範例會顯示 `BaggageHandler` 類別的原始程式碼。</span><span class="sxs-lookup"><span data-stu-id="f0bca-145">The source code for the `BaggageHandler` class is shown in the following example.</span></span>

[!code-csharp[Conceptual.ObserverDesignPattern#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.observerdesignpattern/cs/provider.cs#2)]
[!code-vb[Conceptual.ObserverDesignPattern#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.observerdesignpattern/vb/provider.vb#2)]

<span data-ttu-id="f0bca-146">希望收到更新資訊的用戶端會呼叫 `BaggageHandler.Subscribe` 方法。</span><span class="sxs-lookup"><span data-stu-id="f0bca-146">Clients that wish to receive updated information call the `BaggageHandler.Subscribe` method.</span></span> <span data-ttu-id="f0bca-147">如果用戶端之前未訂閱通知，則會將用戶端的 <xref:System.IObserver%601> 實作參考加入 `observers` 集合。</span><span class="sxs-lookup"><span data-stu-id="f0bca-147">If the client has not previously subscribed to notifications, a reference to the client's <xref:System.IObserver%601> implementation is added to the `observers` collection.</span></span>

<span data-ttu-id="f0bca-148">您可以呼叫多載的 `BaggageHandler.BaggageStatus` 方法，以指出班機的行李正在卸載，或是已卸載完成。</span><span class="sxs-lookup"><span data-stu-id="f0bca-148">The overloaded `BaggageHandler.BaggageStatus` method can be called to indicate that baggage from a flight either is being unloaded or is no longer being unloaded.</span></span> <span data-ttu-id="f0bca-149">在第一個案例中，會對方法傳遞一個班機號碼、班機的起飛機場，以及卸載行李的轉盤。</span><span class="sxs-lookup"><span data-stu-id="f0bca-149">In the first case, the method is passed a flight number, the airport from which the flight originated, and the carousel where baggage is being unloaded.</span></span> <span data-ttu-id="f0bca-150">在第二個案例中，只會對方法傳遞一個班機號碼。</span><span class="sxs-lookup"><span data-stu-id="f0bca-150">In the second case, the method is passed only a flight number.</span></span> <span data-ttu-id="f0bca-151">針對正在卸載的行李，這個方法會檢查傳遞給方法的 `BaggageInfo` 資訊是否存在於 `flights` 集合中。</span><span class="sxs-lookup"><span data-stu-id="f0bca-151">For baggage that is being unloaded, the method checks whether the `BaggageInfo` information passed to the method exists in the `flights` collection.</span></span> <span data-ttu-id="f0bca-152">如果不存在，則這個方法會加入資訊並且呼叫每個觀察者的 `OnNext` 方法。</span><span class="sxs-lookup"><span data-stu-id="f0bca-152">If it does not, the method adds the information and calls each observer's `OnNext` method.</span></span> <span data-ttu-id="f0bca-153">針對行李已卸載完成的班機，這個方法會檢查該班機的資訊是否已儲存至 `flights` 集合中。</span><span class="sxs-lookup"><span data-stu-id="f0bca-153">For flights whose baggage is no longer being unloaded, the method checks whether information on that flight is stored in the `flights` collection.</span></span> <span data-ttu-id="f0bca-154">如果已儲存，則這個方法會呼叫每個觀察者的 `OnNext` 方法，並且從 `flights` 集合中移除 `BaggageInfo` 物件。</span><span class="sxs-lookup"><span data-stu-id="f0bca-154">If it is, the method calls each observer's `OnNext` method and removes the `BaggageInfo` object from the `flights` collection.</span></span>

<span data-ttu-id="f0bca-155">當天最後一個班機降落且其行李已處理完成時，就會呼叫 `BaggageHandler.LastBaggageClaimed` 方法。</span><span class="sxs-lookup"><span data-stu-id="f0bca-155">When the last flight of the day has landed and its baggage has been processed, the `BaggageHandler.LastBaggageClaimed` method is called.</span></span> <span data-ttu-id="f0bca-156">這個方法會呼叫每個觀察者的 `OnCompleted` 方法，指出所有通知已完成，然後清除 `observers` 集合。</span><span class="sxs-lookup"><span data-stu-id="f0bca-156">This method calls each observer's `OnCompleted` method to indicate that all notifications have completed, and then clears the `observers` collection.</span></span>

<span data-ttu-id="f0bca-157">提供者的 <xref:System.IObservable%601.Subscribe%2A> 方法會傳回 <xref:System.IDisposable> 實作，讓觀察者在呼叫 <xref:System.IObserver%601.OnCompleted%2A> 方法之前停止接收通知。</span><span class="sxs-lookup"><span data-stu-id="f0bca-157">The provider's <xref:System.IObservable%601.Subscribe%2A> method returns an <xref:System.IDisposable> implementation that enables observers to stop receiving notifications before the <xref:System.IObserver%601.OnCompleted%2A> method is called.</span></span> <span data-ttu-id="f0bca-158">下列範例會顯示這個 `Unsubscriber(Of BaggageInfo)` 類別的原始程式碼。</span><span class="sxs-lookup"><span data-stu-id="f0bca-158">The source code for this `Unsubscriber(Of BaggageInfo)` class is shown in the following example.</span></span> <span data-ttu-id="f0bca-159">當類別在 `BaggageHandler.Subscribe` 方法中執行個體化時，會對該類別傳遞 `observers` 集合的參考，以及對已加入集合之觀察者的參考。</span><span class="sxs-lookup"><span data-stu-id="f0bca-159">When the class is instantiated in the `BaggageHandler.Subscribe` method, it is passed a reference to the `observers` collection and a reference to the observer that is added to the collection.</span></span> <span data-ttu-id="f0bca-160">這些參考會指派給區域變數。</span><span class="sxs-lookup"><span data-stu-id="f0bca-160">These references are assigned to local variables.</span></span> <span data-ttu-id="f0bca-161">呼叫物件的 `Dispose` 方法時，它會檢查觀察者是否仍存在於 `observers` 集合中；如果存在的話，則會移除觀察者。</span><span class="sxs-lookup"><span data-stu-id="f0bca-161">When the object's `Dispose` method is called, it checks whether the observer still exists in the `observers` collection, and, if it does, removes the observer.</span></span>

[!code-csharp[Conceptual.ObserverDesignPattern#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.observerdesignpattern/cs/provider.cs#3)]
[!code-vb[Conceptual.ObserverDesignPattern#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.observerdesignpattern/vb/provider.vb#3)]

<span data-ttu-id="f0bca-162">下列範例提供名為 `ArrivalsMonitor` 的 <xref:System.IObserver%601> 實作，其為顯示行李提領資訊的基底類別。</span><span class="sxs-lookup"><span data-stu-id="f0bca-162">The following example provides an <xref:System.IObserver%601> implementation named `ArrivalsMonitor`, which is a base class that displays baggage claim information.</span></span> <span data-ttu-id="f0bca-163">資訊會依照起飛城市名稱的英文字母順序顯示。</span><span class="sxs-lookup"><span data-stu-id="f0bca-163">The information is displayed alphabetically, by the name of the originating city.</span></span> <span data-ttu-id="f0bca-164">`ArrivalsMonitor` 的方法會標記為 `overridable` (在 Visual Basic 中) 或 `virtual` (在 C# 中)，如此衍生類別就能一次覆寫所有方法。</span><span class="sxs-lookup"><span data-stu-id="f0bca-164">The methods of `ArrivalsMonitor` are marked as `overridable` (in Visual Basic) or `virtual` (in C#), so they can all be overridden by a derived class.</span></span>

[!code-csharp[Conceptual.ObserverDesignPattern#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.observerdesignpattern/cs/observer.cs#4)]
[!code-vb[Conceptual.ObserverDesignPattern#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.observerdesignpattern/vb/observer.vb#4)]

<span data-ttu-id="f0bca-165">`ArrivalsMonitor` 類別包含 `Subscribe` 和 `Unsubscribe` 方法。</span><span class="sxs-lookup"><span data-stu-id="f0bca-165">The `ArrivalsMonitor` class includes the `Subscribe` and `Unsubscribe` methods.</span></span> <span data-ttu-id="f0bca-166">`Subscribe` 方法可讓類別將呼叫 <xref:System.IObservable%601.Subscribe%2A> 所傳回的 <xref:System.IDisposable> 實作儲存至私用變數。</span><span class="sxs-lookup"><span data-stu-id="f0bca-166">The `Subscribe` method enables the class to save the <xref:System.IDisposable> implementation returned by the call to <xref:System.IObservable%601.Subscribe%2A> to a private variable.</span></span> <span data-ttu-id="f0bca-167">`Unsubscribe` 方法可讓類別藉由呼叫提供者的 <xref:System.IDisposable.Dispose%2A> 實作來取消訂閱通知。</span><span class="sxs-lookup"><span data-stu-id="f0bca-167">The `Unsubscribe` method enables the class to unsubscribe from notifications by calling the provider's <xref:System.IDisposable.Dispose%2A> implementation.</span></span> <span data-ttu-id="f0bca-168">`ArrivalsMonitor` 還提供 <xref:System.IObserver%601.OnNext%2A>、<xref:System.IObserver%601.OnError%2A> 和 <xref:System.IObserver%601.OnCompleted%2A> 方法的實作。</span><span class="sxs-lookup"><span data-stu-id="f0bca-168">`ArrivalsMonitor` also provides implementations of the <xref:System.IObserver%601.OnNext%2A>, <xref:System.IObserver%601.OnError%2A>, and <xref:System.IObserver%601.OnCompleted%2A> methods.</span></span> <span data-ttu-id="f0bca-169">只有 <xref:System.IObserver%601.OnNext%2A> 實作會包含大量程式碼。</span><span class="sxs-lookup"><span data-stu-id="f0bca-169">Only the <xref:System.IObserver%601.OnNext%2A> implementation contains a significant amount of code.</span></span> <span data-ttu-id="f0bca-170">這個方法可處理私用且已排序的泛型 <xref:System.Collections.Generic.List%601> 物件，該物件會維護有關抵達班機的起飛機場以及可提領其行李之轉盤的資訊。</span><span class="sxs-lookup"><span data-stu-id="f0bca-170">The method works with a private, sorted, generic <xref:System.Collections.Generic.List%601> object that maintains information about the airports of origin for arriving flights and the carousels on which their baggage is available.</span></span> <span data-ttu-id="f0bca-171">如果 `BaggageHandler` 類別報告有新班機抵達，則 <xref:System.IObserver%601.OnNext%2A> 方法實作會將該班機的相關資訊加入清單中。</span><span class="sxs-lookup"><span data-stu-id="f0bca-171">If the `BaggageHandler` class reports a new flight arrival, the <xref:System.IObserver%601.OnNext%2A> method implementation adds information about that flight to the list.</span></span> <span data-ttu-id="f0bca-172">如果 `BaggageHandler` 類別報告班機的行李已卸載完畢，則 <xref:System.IObserver%601.OnNext%2A> 方法會從清單中移除該班機。</span><span class="sxs-lookup"><span data-stu-id="f0bca-172">If the `BaggageHandler` class reports that the flight's baggage has been unloaded, the <xref:System.IObserver%601.OnNext%2A> method removes that flight from the list.</span></span> <span data-ttu-id="f0bca-173">只要發生變更，清單就會排序並顯示於主控台上。</span><span class="sxs-lookup"><span data-stu-id="f0bca-173">Whenever a change is made, the list is sorted and displayed to the console.</span></span>

<span data-ttu-id="f0bca-174">下列範例包含執行個體化 `BaggageHandler` 類別及 `ArrivalsMonitor` 類別之兩個執行個體的應用程式進入點，並且使用 `BaggageHandler.BaggageStatus` 方法加入和移除抵達班機的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="f0bca-174">The following example contains the application entry point that instantiates the `BaggageHandler` class as well as two instances of the `ArrivalsMonitor` class, and uses the `BaggageHandler.BaggageStatus` method to add and remove information about arriving flights.</span></span> <span data-ttu-id="f0bca-175">在每個案例中，觀察者都會接收更新並且正確顯示行李提領資訊。</span><span class="sxs-lookup"><span data-stu-id="f0bca-175">In each case, the observers receive updates and correctly display baggage claim information.</span></span>

[!code-csharp[Conceptual.ObserverDesignPattern#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.observerdesignpattern/cs/program.cs#5)]
[!code-vb[Conceptual.ObserverDesignPattern#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.observerdesignpattern/vb/module1.vb#5)]

## <a name="related-topics"></a><span data-ttu-id="f0bca-176">[相關主題]</span><span class="sxs-lookup"><span data-stu-id="f0bca-176">Related Topics</span></span>

|<span data-ttu-id="f0bca-177">標題</span><span class="sxs-lookup"><span data-stu-id="f0bca-177">Title</span></span>|<span data-ttu-id="f0bca-178">描述</span><span class="sxs-lookup"><span data-stu-id="f0bca-178">Description</span></span>|
|-----------|-----------------|
|[<span data-ttu-id="f0bca-179">觀察者設計模式最佳做法</span><span class="sxs-lookup"><span data-stu-id="f0bca-179">Observer Design Pattern Best Practices</span></span>](observer-design-pattern-best-practices.md)|<span data-ttu-id="f0bca-180">描述開發實作觀察者設計模式的應用程式時，所採用的最佳做法。</span><span class="sxs-lookup"><span data-stu-id="f0bca-180">Describes best practices to adopt when developing applications that implement the observer design pattern.</span></span>|
|[<span data-ttu-id="f0bca-181">如何：執行提供者</span><span class="sxs-lookup"><span data-stu-id="f0bca-181">How to: Implement a Provider</span></span>](how-to-implement-a-provider.md)|<span data-ttu-id="f0bca-182">提供溫度監控應用程式的提供者逐步實作。</span><span class="sxs-lookup"><span data-stu-id="f0bca-182">Provides a step-by-step implementation of a provider for a temperature monitoring application.</span></span>|
|[<span data-ttu-id="f0bca-183">如何：執行觀察者</span><span class="sxs-lookup"><span data-stu-id="f0bca-183">How to: Implement an Observer</span></span>](how-to-implement-an-observer.md)|<span data-ttu-id="f0bca-184">提供溫度監控應用程式的觀察者逐步實作。</span><span class="sxs-lookup"><span data-stu-id="f0bca-184">Provides a step-by-step implementation of an observer for a temperature monitoring application.</span></span>|
