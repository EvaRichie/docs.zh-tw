---
title: PLINQ 中的合併選項
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- PLINQ queries, merge options
ms.assetid: e8f7be3b-88de-4f33-ab14-dc008e76c1ba
ms.openlocfilehash: e6690a600b7b00272471362bc087633d52a98f25
ms.sourcegitcommit: 965a5af7918acb0a3fd3baf342e15d511ef75188
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 11/18/2020
ms.locfileid: "94824840"
---
# <a name="merge-options-in-plinq"></a><span data-ttu-id="246d1-102">PLINQ 中的合併選項</span><span class="sxs-lookup"><span data-stu-id="246d1-102">Merge Options in PLINQ</span></span>
<span data-ttu-id="246d1-103">當查詢平行執行時，PLINQ 會分割來源序列，讓多個執行緒可以在不同的組件上同時工作，通常是在個別的執行緒上。</span><span class="sxs-lookup"><span data-stu-id="246d1-103">When a query is executing as parallel, PLINQ partitions the source sequence so that multiple threads can work on different parts concurrently, typically on separate threads.</span></span> <span data-ttu-id="246d1-104">如果結果是在一個執行緒上使用，例如在 `foreach` (Visual Basic 中的 `For Each`) 迴圈中，則必須將每個執行緒中的結果合併回單一序列。</span><span class="sxs-lookup"><span data-stu-id="246d1-104">If the results are to be consumed on one thread, for example, in a `foreach` (`For Each` in Visual Basic) loop, then the results from every thread must be merged back into one sequence.</span></span> <span data-ttu-id="246d1-105">PLINQ 執行的合併類型，取決於存在查詢中的運算子。</span><span class="sxs-lookup"><span data-stu-id="246d1-105">The kind of merge that PLINQ performs depends on the operators that are present in the query.</span></span> <span data-ttu-id="246d1-106">比方說，對結果強制執行新順序的運算子，必須緩衝所有執行緒中的所有元素。</span><span class="sxs-lookup"><span data-stu-id="246d1-106">For example, operators that impose a new order on the results must buffer all elements from all threads.</span></span> <span data-ttu-id="246d1-107">就使用執行緒的角度而言 (也是應用程式使用者的觀點)，完整緩衝的查詢在產生其第一個結果前可能會執行不算短的一段時間。</span><span class="sxs-lookup"><span data-stu-id="246d1-107">From the perspective of the consuming thread (which is also that of the application user) a fully buffered query might run for a noticeable period of time before it produces its first result.</span></span> <span data-ttu-id="246d1-108">其他運算子預設會部分進行緩衝；會批次產生其結果。</span><span class="sxs-lookup"><span data-stu-id="246d1-108">Other operators, by default, are partially buffered; they yield their results in batches.</span></span> <span data-ttu-id="246d1-109">有一個運算子 (<xref:System.Linq.ParallelEnumerable.ForAll%2A>) 預設不會進行緩衝。</span><span class="sxs-lookup"><span data-stu-id="246d1-109">One operator, <xref:System.Linq.ParallelEnumerable.ForAll%2A> is not buffered by default.</span></span> <span data-ttu-id="246d1-110">它會立即產生所有執行緒中的所有元素。</span><span class="sxs-lookup"><span data-stu-id="246d1-110">It yields all elements from all threads immediately.</span></span>  
  
 <span data-ttu-id="246d1-111">使用 <xref:System.Linq.ParallelEnumerable.WithMergeOptions%2A> 方法，如下列範例所示，您可以提供提示給 PLINQ 以指示要執行何種合併。</span><span class="sxs-lookup"><span data-stu-id="246d1-111">By using the <xref:System.Linq.ParallelEnumerable.WithMergeOptions%2A> method, as shown in the following example, you can provide a hint to PLINQ that indicates what kind of merging to perform.</span></span>  
  
 [!code-csharp[PLINQ#26](../../../samples/snippets/csharp/VS_Snippets_Misc/plinq/cs/plinqsamples.cs#26)]
 [!code-vb[PLINQ#26](../../../samples/snippets/visualbasic/VS_Snippets_Misc/plinq/vb/plinq2_vb.vb#26)]  
  
 <span data-ttu-id="246d1-112">如需完整範例，請參閱[如何：在 PLINQ 中指定合併選項](how-to-specify-merge-options-in-plinq.md)。</span><span class="sxs-lookup"><span data-stu-id="246d1-112">For the complete example, see [How to: Specify Merge Options in PLINQ](how-to-specify-merge-options-in-plinq.md).</span></span>  
  
 <span data-ttu-id="246d1-113">如果特定查詢無法支援要求的選項，將會忽略此選項。</span><span class="sxs-lookup"><span data-stu-id="246d1-113">If the particular query cannot support the requested option, then the option will just be ignored.</span></span> <span data-ttu-id="246d1-114">在多數情況下，您不需為 PLINQ 查詢指定合併選項。</span><span class="sxs-lookup"><span data-stu-id="246d1-114">In most cases, you do not have to specify a merge option for a PLINQ query.</span></span> <span data-ttu-id="246d1-115">不過在某些情況下，藉由測試及量測，您會發現查詢在非預設模式的執行效能最佳。</span><span class="sxs-lookup"><span data-stu-id="246d1-115">However, in some cases you may find by testing and measurement that a query executes best in a non-default mode.</span></span> <span data-ttu-id="246d1-116">這個選項的常見用法是強制區塊合併運算子串流處理其結果，以提供更能有效回應的使用者介面。</span><span class="sxs-lookup"><span data-stu-id="246d1-116">A common use of this option is to force a chunk-merging operator to stream its results in order to provide a more responsive user interface.</span></span>  
  
## <a name="parallelmergeoptions"></a><span data-ttu-id="246d1-117">ParallelMergeOptions</span><span class="sxs-lookup"><span data-stu-id="246d1-117">ParallelMergeOptions</span></span>  
 <span data-ttu-id="246d1-118"><xref:System.Linq.ParallelMergeOptions> 列舉包含下列選項，其中針對支援的查詢圖形，會指定在一個執行緒上使用結果時如何產生最終輸出：</span><span class="sxs-lookup"><span data-stu-id="246d1-118">The <xref:System.Linq.ParallelMergeOptions> enumeration includes the following options that specify, for supported query shapes, how the final output of the query is yielded when the results are consumed on one thread:</span></span>  
  
- `Not Buffered`  
  
     <span data-ttu-id="246d1-119"><xref:System.Linq.ParallelMergeOptions.NotBuffered> 選項會讓每個處理過的元素一產生就從每個執行緒傳回。</span><span class="sxs-lookup"><span data-stu-id="246d1-119">The <xref:System.Linq.ParallelMergeOptions.NotBuffered> option causes each processed element to be returned from each thread as soon as it is produced.</span></span> <span data-ttu-id="246d1-120">此行為類似「串流處理」輸出。</span><span class="sxs-lookup"><span data-stu-id="246d1-120">This behavior is analogous to "streaming" the output.</span></span> <span data-ttu-id="246d1-121">如果 <xref:System.Linq.ParallelEnumerable.AsOrdered%2A> 運算子存在查詢中，`NotBuffered` 會保留來源元素的順序。</span><span class="sxs-lookup"><span data-stu-id="246d1-121">If the <xref:System.Linq.ParallelEnumerable.AsOrdered%2A> operator is present in the query, `NotBuffered` preserves the order of the source elements.</span></span> <span data-ttu-id="246d1-122">雖然 `NotBuffered` 會在有結果可用時立即產生結果，但產生所有結果的總時間可能仍會比使用其中一個其他合併選項還長。</span><span class="sxs-lookup"><span data-stu-id="246d1-122">Although `NotBuffered` starts yielding results as soon as they're available, the total time to produce all the results might still be longer than using one of the other merge options.</span></span>  
  
- `Auto Buffered`  
  
     <span data-ttu-id="246d1-123"><xref:System.Linq.ParallelMergeOptions.AutoBuffered> 選項會讓查詢將項目收集至緩衝區中，然後定期將緩衝區內容一次產生至耗用端執行緒中。</span><span class="sxs-lookup"><span data-stu-id="246d1-123">The <xref:System.Linq.ParallelMergeOptions.AutoBuffered> option causes the query to collect elements into a buffer and then periodically yield the buffer contents all at once to the consuming thread.</span></span> <span data-ttu-id="246d1-124">這類似以區塊方式產生來源資料，而非使用 `NotBuffered` 的「串流處理」行為。</span><span class="sxs-lookup"><span data-stu-id="246d1-124">This is analogous to yielding the source data in "chunks" instead of using the "streaming" behavior of `NotBuffered`.</span></span> <span data-ttu-id="246d1-125">相較於 `NotBuffered`，`AutoBuffered` 會需要更多時間才能讓第一個元素可用於使用的執行緒上。</span><span class="sxs-lookup"><span data-stu-id="246d1-125">`AutoBuffered` may take longer than `NotBuffered` to make the first element available on the consuming thread.</span></span> <span data-ttu-id="246d1-126">緩衝區的大小和確切的產生行為無法設定，而且可能有所不同，這取決於和查詢相關的各種因素。</span><span class="sxs-lookup"><span data-stu-id="246d1-126">The size of the buffer and the exact yielding behavior are not configurable and may vary, depending on various factors that relate to the query.</span></span>  
  
- `FullyBuffered`  
  
     <span data-ttu-id="246d1-127"><xref:System.Linq.ParallelMergeOptions.FullyBuffered> 選項會在任一元素產生前先緩衝整個查詢的輸出。</span><span class="sxs-lookup"><span data-stu-id="246d1-127">The <xref:System.Linq.ParallelMergeOptions.FullyBuffered> option causes the output of the whole query to be buffered before any of the elements are yielded.</span></span> <span data-ttu-id="246d1-128">使用此選項時，會需要更多時間才能讓第一個元素可用於使用的執行緒上，但產生整體結果的速度可能仍比使用其他選項快。</span><span class="sxs-lookup"><span data-stu-id="246d1-128">When you use this option, it can take longer before the first element is available on the consuming thread, but the complete results might still be produced faster than by using the other options.</span></span>  
  
## <a name="query-operators-that-support-merge-options"></a><span data-ttu-id="246d1-129">支援合併選項的查詢運算子</span><span class="sxs-lookup"><span data-stu-id="246d1-129">Query Operators that Support Merge Options</span></span>  
 <span data-ttu-id="246d1-130">下表列出支援所有合併選項模式的運算子及其具體限制。</span><span class="sxs-lookup"><span data-stu-id="246d1-130">The following table lists the operators that support all merge option modes, subject to the specified restrictions.</span></span>  
  
|<span data-ttu-id="246d1-131">運算子</span><span class="sxs-lookup"><span data-stu-id="246d1-131">Operator</span></span>|<span data-ttu-id="246d1-132">限制</span><span class="sxs-lookup"><span data-stu-id="246d1-132">Restrictions</span></span>|  
|--------------|------------------|  
|<xref:System.Linq.ParallelEnumerable.AsEnumerable%2A>|<span data-ttu-id="246d1-133">無</span><span class="sxs-lookup"><span data-stu-id="246d1-133">None</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Cast%2A>|<span data-ttu-id="246d1-134">無</span><span class="sxs-lookup"><span data-stu-id="246d1-134">None</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Concat%2A>|<span data-ttu-id="246d1-135">只含有陣列或清單來源的非排序查詢。</span><span class="sxs-lookup"><span data-stu-id="246d1-135">Non-ordered queries that have an Array or List source only.</span></span>|  
|<xref:System.Linq.ParallelEnumerable.DefaultIfEmpty%2A>|<span data-ttu-id="246d1-136">無</span><span class="sxs-lookup"><span data-stu-id="246d1-136">None</span></span>|  
|<xref:System.Linq.ParallelEnumerable.OfType%2A>|<span data-ttu-id="246d1-137">無</span><span class="sxs-lookup"><span data-stu-id="246d1-137">None</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Reverse%2A>|<span data-ttu-id="246d1-138">只含有陣列或清單來源的非排序查詢。</span><span class="sxs-lookup"><span data-stu-id="246d1-138">Non-ordered queries that have an Array or List source only.</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Select%2A>|<span data-ttu-id="246d1-139">無</span><span class="sxs-lookup"><span data-stu-id="246d1-139">None</span></span>|  
|<xref:System.Linq.ParallelEnumerable.SelectMany%2A>|<span data-ttu-id="246d1-140">無</span><span class="sxs-lookup"><span data-stu-id="246d1-140">None</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Skip%2A>|<span data-ttu-id="246d1-141">無</span><span class="sxs-lookup"><span data-stu-id="246d1-141">None</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Take%2A>|<span data-ttu-id="246d1-142">無</span><span class="sxs-lookup"><span data-stu-id="246d1-142">None</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Where%2A>|<span data-ttu-id="246d1-143">無</span><span class="sxs-lookup"><span data-stu-id="246d1-143">None</span></span>|  
  
 <span data-ttu-id="246d1-144">所有其他的 PLINQ 查詢運算子可能會忽略使用者提供的合併選項。</span><span class="sxs-lookup"><span data-stu-id="246d1-144">All other PLINQ query operators might ignore user-provided merge options.</span></span> <span data-ttu-id="246d1-145">某些查詢運算子 (例如 <xref:System.Linq.ParallelEnumerable.Reverse%2A> 和 <xref:System.Linq.ParallelEnumerable.OrderBy%2A>) 在所有元素都已產生並重新排序之前無法產生任何元素。</span><span class="sxs-lookup"><span data-stu-id="246d1-145">Some query operators, for example, <xref:System.Linq.ParallelEnumerable.Reverse%2A> and <xref:System.Linq.ParallelEnumerable.OrderBy%2A>, cannot yield any elements until all have been produced and reordered.</span></span> <span data-ttu-id="246d1-146">因此，當 <xref:System.Linq.ParallelMergeOptions> 使用於也包含運算子 (例如 <xref:System.Linq.ParallelEnumerable.Reverse%2A>) 的查詢中時，一直到該運算子已產生其結果後，才會在查詢中套用合併行為。</span><span class="sxs-lookup"><span data-stu-id="246d1-146">Therefore, when <xref:System.Linq.ParallelMergeOptions> is used in a query that also contains an operator such as <xref:System.Linq.ParallelEnumerable.Reverse%2A>, the merge behavior will not be applied in the query until after that operator has produced its results.</span></span>  
  
 <span data-ttu-id="246d1-147">某些運算子是否可以處理合併選項，取決於來源序列的類型，以及先前是否在查詢中使用了 <xref:System.Linq.ParallelEnumerable.AsOrdered%2A> 運算子。</span><span class="sxs-lookup"><span data-stu-id="246d1-147">The ability of some operators to handle merge options depends on the type of the source sequence, and whether the <xref:System.Linq.ParallelEnumerable.AsOrdered%2A> operator was used earlier in the query.</span></span> <span data-ttu-id="246d1-148"><xref:System.Linq.ParallelEnumerable.ForAll%2A> 一律為 <xref:System.Linq.ParallelMergeOptions.NotBuffered>；它會立即產生其元素。</span><span class="sxs-lookup"><span data-stu-id="246d1-148"><xref:System.Linq.ParallelEnumerable.ForAll%2A> is always <xref:System.Linq.ParallelMergeOptions.NotBuffered> ; it yields its elements immediately.</span></span> <span data-ttu-id="246d1-149"><xref:System.Linq.ParallelEnumerable.OrderBy%2A> 一律為 <xref:System.Linq.ParallelMergeOptions.FullyBuffered>；它必須先排序整個清單後才會產生。</span><span class="sxs-lookup"><span data-stu-id="246d1-149"><xref:System.Linq.ParallelEnumerable.OrderBy%2A> is always <xref:System.Linq.ParallelMergeOptions.FullyBuffered>; it must sort the whole list before it yields.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="246d1-150">請參閱</span><span class="sxs-lookup"><span data-stu-id="246d1-150">See also</span></span>

- [<span data-ttu-id="246d1-151">平行 LINQ (PLINQ)</span><span class="sxs-lookup"><span data-stu-id="246d1-151">Parallel LINQ (PLINQ)</span></span>](introduction-to-plinq.md)
- [<span data-ttu-id="246d1-152">作法：在 PLINQ 中指定合併選項</span><span class="sxs-lookup"><span data-stu-id="246d1-152">How to: Specify Merge Options in PLINQ</span></span>](how-to-specify-merge-options-in-plinq.md)
