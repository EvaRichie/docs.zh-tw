---
title: 例外狀況處理 (工作平行程式庫)
ms.date: 04/20/2020
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- tasks, exceptions
ms.assetid: beb51e50-9061-4d3d-908c-56a4f7c2e8c1
ms.openlocfilehash: 674abcfe4477e14295f131e766a48422779391de
ms.sourcegitcommit: 33deec3e814238fb18a49b2a7e89278e27888291
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 06/02/2020
ms.locfileid: "84290041"
---
# <a name="exception-handling-task-parallel-library"></a><span data-ttu-id="65651-102">例外狀況處理 (工作平行程式庫)</span><span class="sxs-lookup"><span data-stu-id="65651-102">Exception handling (Task Parallel Library)</span></span>

<span data-ttu-id="65651-103">由在工作中執行的使用者程式碼所擲回的未處理例外狀況，會傳播回到呼叫執行緒，本主題稍後所述的特定情況除外。</span><span class="sxs-lookup"><span data-stu-id="65651-103">Unhandled exceptions that are thrown by user code that is running inside a task are propagated back to the calling thread, except in certain scenarios that are described later in this topic.</span></span> <span data-ttu-id="65651-104">當您使用其中一個靜態或執行個體 <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> 方法時會傳播例外狀況，您可以用 `try`/`catch` 陳述式括住呼叫來處理它們。</span><span class="sxs-lookup"><span data-stu-id="65651-104">Exceptions are propagated when you use one of the static or instance <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> methods, and you handle them by enclosing the call in a `try`/`catch` statement.</span></span> <span data-ttu-id="65651-105">如果工作是已連結子工作的父代，或如果您在等候多個工作，就可能會擲回多個例外狀況。</span><span class="sxs-lookup"><span data-stu-id="65651-105">If a task is the parent of attached child tasks, or if you are waiting on multiple tasks, multiple exceptions could be thrown.</span></span>

<span data-ttu-id="65651-106">若要將所有例外狀況傳播回呼叫執行緒，工作基礎結構會將它們包裝在 <xref:System.AggregateException> 執行個體中。</span><span class="sxs-lookup"><span data-stu-id="65651-106">To propagate all the exceptions back to the calling thread, the Task infrastructure wraps them in an <xref:System.AggregateException> instance.</span></span> <span data-ttu-id="65651-107"><xref:System.AggregateException> 例外狀況有 <xref:System.AggregateException.InnerExceptions%2A> 屬性，您可以列舉這個屬性來檢查所有擲回的原始例外狀況，並且個別處理 (或不處理) 每個例外狀況。</span><span class="sxs-lookup"><span data-stu-id="65651-107">The <xref:System.AggregateException> exception has an <xref:System.AggregateException.InnerExceptions%2A> property that can be enumerated to examine all the original exceptions that were thrown, and handle (or not handle) each one individually.</span></span> <span data-ttu-id="65651-108">您也可以使用 <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> 方法處理原始的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="65651-108">You can also handle the original exceptions by using the <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="65651-109">即使只擲回一個例外狀況，它仍然會包裝在 <xref:System.AggregateException> 例外狀況裡，如下例所示。</span><span class="sxs-lookup"><span data-stu-id="65651-109">Even if only one exception is thrown, it is still wrapped in an <xref:System.AggregateException> exception, as the following example shows.</span></span>

[!code-csharp[TPL_Exceptions#21](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/handling21.cs#21)]
[!code-vb[TPL_Exceptions#21](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/handling21.vb#21)]

<span data-ttu-id="65651-110">只要攔截 <xref:System.AggregateException> 而且沒有觀察到任何內部的例外狀況，就可以避免未處理的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="65651-110">You could avoid an unhandled exception by just catching the <xref:System.AggregateException> and not observing any of the inner exceptions.</span></span> <span data-ttu-id="65651-111">不過，建議您不要這麼做，因為它在非平行案例中類似於攔截基底 <xref:System.Exception> 類型。</span><span class="sxs-lookup"><span data-stu-id="65651-111">However, we recommend that you do not do this because it is analogous to catching the base <xref:System.Exception> type in non-parallel scenarios.</span></span> <span data-ttu-id="65651-112">攔截例外狀況卻不採取特定動作從它復原，可能會讓您的程式處於不確定狀態。</span><span class="sxs-lookup"><span data-stu-id="65651-112">To catch an exception without taking specific actions to recover from it can leave your program in an indeterminate state.</span></span>

<span data-ttu-id="65651-113">如果您不想要呼叫 <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> 方法來等候工作完成，則也可以擷取來自工作 <xref:System.Threading.Tasks.Task.Exception%2A> 屬性的 <xref:System.AggregateException> 例外狀況，如下例所示。</span><span class="sxs-lookup"><span data-stu-id="65651-113">If you do not want to call the <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> method to wait for a task's completion, you can also retrieve the <xref:System.AggregateException> exception from the task's <xref:System.Threading.Tasks.Task.Exception%2A> property, as the following example shows.</span></span> <span data-ttu-id="65651-114">如需詳細資訊，請參閱本主題中的[使用 Exception 屬性來觀察例外](#observing-exceptions-by-using-the-taskexception-property)狀況一節。</span><span class="sxs-lookup"><span data-stu-id="65651-114">For more information, see the [Observing exceptions by using the Task.Exception property](#observing-exceptions-by-using-the-taskexception-property) section in this topic.</span></span>

[!code-csharp[TPL_Exceptions#29](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/handling22.cs#29)]
[!code-vb[TPL_Exceptions#29](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/handling22.vb#29)]

<span data-ttu-id="65651-115">如果您不需要等候工作傳播例外狀況，或存取其 <xref:System.Threading.Tasks.Task.Exception%2A> 屬性，當工作回收時就會根據 .NET 例外狀況原則提昇例外狀況。</span><span class="sxs-lookup"><span data-stu-id="65651-115">If you do not wait on a task that propagates an exception, or access its <xref:System.Threading.Tasks.Task.Exception%2A> property, the exception is escalated according to the .NET exception policy when the task is garbage-collected.</span></span>

<span data-ttu-id="65651-116">當允許例外狀況反昇至聯結的執行緒時，工作可能就可以在引發例外狀況之後，繼續處理某些項目。</span><span class="sxs-lookup"><span data-stu-id="65651-116">When exceptions are allowed to bubble up back to the joining thread, it is possible that a task may continue to process some items after the exception is raised.</span></span>

> [!NOTE]
> <span data-ttu-id="65651-117">啟用 [Just My Code] 時，Visual Studio 在某些情況下會在擲回例外狀況的字行上中斷，並顯示錯誤訊息，指出「使用者程式碼未處理例外狀況」。</span><span class="sxs-lookup"><span data-stu-id="65651-117">When "Just My Code" is enabled, Visual Studio in some cases will break on the line that throws the exception and display an error message that says "exception not handled by user code."</span></span> <span data-ttu-id="65651-118">這個錯誤是良性的。</span><span class="sxs-lookup"><span data-stu-id="65651-118">This error is benign.</span></span> <span data-ttu-id="65651-119">您可以按 F5 繼續，並查看下面範例中示範的例外狀況處理行為。</span><span class="sxs-lookup"><span data-stu-id="65651-119">You can press F5 to continue and see the exception-handling behavior that is demonstrated in these examples.</span></span> <span data-ttu-id="65651-120">若要防止 Visual Studio 在遇到第一個錯誤時就中斷，只要取消核取 [工具]、[選項]、[偵錯]、[一般] \*\*\*\* 下的 [ **啟用 Just My Code**] 核取方塊即可。</span><span class="sxs-lookup"><span data-stu-id="65651-120">To prevent Visual Studio from breaking on the first error, just uncheck the **Enable Just My Code** checkbox under **Tools, Options, Debugging, General**.</span></span>

## <a name="attached-child-tasks-and-nested-aggregateexceptions"></a><span data-ttu-id="65651-121">已附加子工作和巢狀的 AggregateExceptions</span><span class="sxs-lookup"><span data-stu-id="65651-121">Attached child tasks and nested AggregateExceptions</span></span>

<span data-ttu-id="65651-122">如果工作有會擲回例外狀況的已連結子工作，該例外狀況就會先包裝在 <xref:System.AggregateException> 再傳播到父工作，這會先把此例外狀況包裝在它自己的 <xref:System.AggregateException> 再傳播回呼叫執行緒。</span><span class="sxs-lookup"><span data-stu-id="65651-122">If a task has an attached child task that throws an exception, that exception is wrapped in an <xref:System.AggregateException> before it is propagated to the parent task, which wraps that exception in its own <xref:System.AggregateException> before it propagates it back to the calling thread.</span></span> <span data-ttu-id="65651-123">在這種情況下，在 <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType>、<xref:System.Threading.Tasks.Task.WaitAny%2A> 或 <xref:System.Threading.Tasks.Task.WaitAll%2A> 方法攔截的 <xref:System.AggregateException> 例外狀況，其 <xref:System.AggregateException.InnerExceptions%2A> 屬性會包含一個或多個 <xref:System.AggregateException> 執行個體，而不是包含造成錯誤的原始例外狀況。</span><span class="sxs-lookup"><span data-stu-id="65651-123">In such cases, the <xref:System.AggregateException.InnerExceptions%2A> property of the <xref:System.AggregateException> exception that is caught at the <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType>, <xref:System.Threading.Tasks.Task.WaitAny%2A>, or <xref:System.Threading.Tasks.Task.WaitAll%2A> method contains one or more <xref:System.AggregateException> instances, not the original exceptions that caused the fault.</span></span> <span data-ttu-id="65651-124">為免逐一查看巢狀 <xref:System.AggregateException> 例外狀況，您可以使用 <xref:System.AggregateException.Flatten%2A> 方法移除所有的巢狀 <xref:System.AggregateException> 例外狀況，讓 <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> 屬性包含原始例外狀況。</span><span class="sxs-lookup"><span data-stu-id="65651-124">To avoid having to iterate over nested <xref:System.AggregateException> exceptions, you can use the <xref:System.AggregateException.Flatten%2A> method to remove all the nested <xref:System.AggregateException> exceptions, so that the <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> property contains the original exceptions.</span></span> <span data-ttu-id="65651-125">下例中，巢狀 <xref:System.AggregateException> 執行個體被扁平化，並只在一個迴圈中處理。</span><span class="sxs-lookup"><span data-stu-id="65651-125">In the following example, nested <xref:System.AggregateException> instances are flattened and handled in just one loop.</span></span>

[!code-csharp[TPL_Exceptions#22](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/flatten2.cs#22)]
[!code-vb[TPL_Exceptions#22](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/flatten2.vb#22)]

<span data-ttu-id="65651-126">您也可以使用 <xref:System.AggregateException.Flatten%2A?displayProperty=nameWithType> 方法，從被單一 <xref:System.AggregateException> 執行個體之多個工作擲回的多個 <xref:System.AggregateException> 執行個體中，重新擲回內部的例外狀況，如下例所示。</span><span class="sxs-lookup"><span data-stu-id="65651-126">You can also use the <xref:System.AggregateException.Flatten%2A?displayProperty=nameWithType> method to rethrow the inner exceptions from multiple <xref:System.AggregateException> instances thrown by multiple tasks in a single <xref:System.AggregateException> instance, as the following example shows.</span></span>

[!code-csharp[TPL_Exceptions#13](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/taskexceptions2.cs#13)]
[!code-vb[TPL_Exceptions#13](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/taskexceptions2.vb#13)]

## <a name="exceptions-from-detached-child-tasks"></a><span data-ttu-id="65651-127">來自中斷連結子工作的例外狀況</span><span class="sxs-lookup"><span data-stu-id="65651-127">Exceptions from detached child tasks</span></span>

<span data-ttu-id="65651-128">子工作預設的建立狀態為中斷連結。</span><span class="sxs-lookup"><span data-stu-id="65651-128">By default, child tasks are created as detached.</span></span> <span data-ttu-id="65651-129">從已中斷連結工作擲回的例外狀況，必須在緊鄰的父工作中處理或重新擲回；它們傳播回呼叫執行緒的方式，和已連結子工作傳播回的方式不一樣。</span><span class="sxs-lookup"><span data-stu-id="65651-129">Exceptions thrown from detached tasks must be handled or rethrown in the immediate parent task; they are not propagated back to the calling thread in the same way as attached child tasks propagated back.</span></span> <span data-ttu-id="65651-130">最上層的父代可以從中斷連結的子代手動重新擲回例外狀況，讓它包裝在 <xref:System.AggregateException> 中並傳播回呼叫執行緒。</span><span class="sxs-lookup"><span data-stu-id="65651-130">The topmost parent can manually rethrow an exception from a detached child to cause it to be wrapped in an <xref:System.AggregateException> and propagated back to the calling thread.</span></span>

[!code-csharp[TPL_Exceptions#23](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/detached21.cs#23)]
[!code-vb[TPL_Exceptions#23](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/detached21.vb#23)]

<span data-ttu-id="65651-131">即使您持續觀察子工作中的例外狀況，父工作也仍然必須觀察此例外狀況。</span><span class="sxs-lookup"><span data-stu-id="65651-131">Even if you use a continuation to observe an exception in a child task, the exception still must be observed by the parent task.</span></span>

## <a name="exceptions-that-indicate-cooperative-cancellation"></a><span data-ttu-id="65651-132">指出合作式取消的例外狀況</span><span class="sxs-lookup"><span data-stu-id="65651-132">Exceptions that indicate cooperative cancellation</span></span>

<span data-ttu-id="65651-133">當工作中的使用者程式碼回應取消要求時，正確的程序會擲回 <xref:System.OperationCanceledException> 傳入已在其中通訊過要求的取消語彙基元。</span><span class="sxs-lookup"><span data-stu-id="65651-133">When user code in a task responds to a cancellation request, the correct procedure is to throw an <xref:System.OperationCanceledException> passing in the cancellation token on which the request was communicated.</span></span> <span data-ttu-id="65651-134">在它嘗試傳播例外狀況之前，工作執行個體會比較例外狀況中的語彙基元和個體建立時傳來的語彙基元。</span><span class="sxs-lookup"><span data-stu-id="65651-134">Before it attempts to propagate the exception, the task instance compares the token in the exception to the one that was passed to it when it was created.</span></span> <span data-ttu-id="65651-135">如果它們是相同的，工作會傳播包裝在 <xref:System.Threading.Tasks.TaskCanceledException> 中的 <xref:System.AggregateException>，而且在檢查內部例外狀況時可以看到它。</span><span class="sxs-lookup"><span data-stu-id="65651-135">If they are the same, the task propagates a <xref:System.Threading.Tasks.TaskCanceledException> wrapped in the <xref:System.AggregateException>, and it can be seen when the inner exceptions are examined.</span></span> <span data-ttu-id="65651-136">不過，如果呼叫執行緒並未等待工作，就不會傳播這個特定的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="65651-136">However, if the calling thread is not waiting on the task, this specific exception will not be propagated.</span></span> <span data-ttu-id="65651-137">如需詳細資訊，請參閱 [Task Cancellation](task-cancellation.md)。</span><span class="sxs-lookup"><span data-stu-id="65651-137">For more information, see [Task Cancellation](task-cancellation.md).</span></span>

[!code-csharp[TPL_Exceptions#4](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/exceptions.cs#4)]
[!code-vb[TPL_Exceptions#4](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/tpl_exceptions.vb#4)]

## <a name="using-the-handle-method-to-filter-inner-exceptions"></a><span data-ttu-id="65651-138">使用控制方法篩選內部例外狀況</span><span class="sxs-lookup"><span data-stu-id="65651-138">Using the handle method to filter inner exceptions</span></span>

<span data-ttu-id="65651-139">您可以使用 <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> 方法，不用任何進一步的邏輯，篩選出您可以視為「已處理」的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="65651-139">You can use the <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> method to filter out exceptions that you can treat as "handled" without using any further logic.</span></span> <span data-ttu-id="65651-140">在提供給 <xref:System.AggregateException.Handle%28System.Func%7BSystem.Exception%2CSystem.Boolean%7D%29?displayProperty=nameWithType> 方法的使用者委派中，您可以檢查例外狀況類型、其 <xref:System.Exception.Message%2A> 屬性或任何其他相關資訊，讓您判斷其是否為良性。</span><span class="sxs-lookup"><span data-stu-id="65651-140">In the user delegate that is supplied to the <xref:System.AggregateException.Handle%28System.Func%7BSystem.Exception%2CSystem.Boolean%7D%29?displayProperty=nameWithType> method, you can examine the exception type, its <xref:System.Exception.Message%2A> property, or any other information about it that will let you determine whether it is benign.</span></span> <span data-ttu-id="65651-141">在 <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> 方法傳回之後，任何讓委派傳回 `false` 的例外狀況都會立即在新的 <xref:System.AggregateException> 執行個體中重新擲回。</span><span class="sxs-lookup"><span data-stu-id="65651-141">Any exceptions for which the delegate returns `false` are rethrown in a new <xref:System.AggregateException> instance immediately after the <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> method returns.</span></span>

<span data-ttu-id="65651-142">下例在功能上等同於本主題的第一個範例，這會檢查 <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> 集合中的每個例外狀況。</span><span class="sxs-lookup"><span data-stu-id="65651-142">The following example is functionally equivalent to the first example in this topic, which examines each exception in the <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> collection.</span></span>  <span data-ttu-id="65651-143">只不過，這個例外狀況處理常式會呼叫每個例外狀況的 <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> 方法物件，而且只重新擲回不是 `CustomException` 執行個體的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="65651-143">Instead, this exception handler calls the <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> method object for each exception, and only rethrows exceptions that are not `CustomException` instances.</span></span>

[!code-csharp[TPL_Exceptions#26](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/handlemethod21.cs#26)]
[!code-vb[TPL_Exceptions#26](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/handlemethod21.vb#26)]

<span data-ttu-id="65651-144">以下是更完整的範例，其使用 <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> 方法在列舉檔案時為 <xref:System.UnauthorizedAccessException> 例外狀況提供特殊處理。</span><span class="sxs-lookup"><span data-stu-id="65651-144">The following is a more complete example that uses the <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> method to provide special handling for an <xref:System.UnauthorizedAccessException> exception when enumerating files.</span></span>

[!code-csharp[TPL_Exceptions#12](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/taskexceptions.cs#12)]
[!code-vb[TPL_Exceptions#12](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/taskexceptions.vb#12)]

## <a name="observing-exceptions-by-using-the-taskexception-property"></a><span data-ttu-id="65651-145">使用 Task.Exception 屬性觀察例外狀況</span><span class="sxs-lookup"><span data-stu-id="65651-145">Observing exceptions by using the Task.Exception property</span></span>

<span data-ttu-id="65651-146">如果工作在 <xref:System.Threading.Tasks.TaskStatus.Faulted?displayProperty=nameWithType> 狀態中完成，可檢查其 <xref:System.Threading.Tasks.Task.Exception%2A> 屬性以探查哪些特定的例外狀況導致這個錯誤。</span><span class="sxs-lookup"><span data-stu-id="65651-146">If a task completes in the <xref:System.Threading.Tasks.TaskStatus.Faulted?displayProperty=nameWithType> state, its <xref:System.Threading.Tasks.Task.Exception%2A> property can be examined to discover which specific exception caused the fault.</span></span> <span data-ttu-id="65651-147">使用唯有在前項工作發生錯誤時才執行的接續，是觀察 <xref:System.Threading.Tasks.Task.Exception%2A> 屬性的好方法，如下例所示。</span><span class="sxs-lookup"><span data-stu-id="65651-147">A good way to observe the <xref:System.Threading.Tasks.Task.Exception%2A> property is to use a continuation that runs only if the antecedent task faults, as shown in the following example.</span></span>

[!code-csharp[TPL_Exceptions#27](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/exceptionprop21.cs#27)]
[!code-vb[TPL_Exceptions#27](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/exceptionprop21.vb#27)]

<span data-ttu-id="65651-148">在有意義的應用程式中，接續委派可以記錄例外狀況的詳細資訊，而且可能會產生新的工作以從例外狀況中復原。</span><span class="sxs-lookup"><span data-stu-id="65651-148">In a meaningful application, the continuation delegate could log detailed information about the exception and possibly spawn new tasks to recover from the exception.</span></span> <span data-ttu-id="65651-149">如果工作錯誤，下列運算式會擲回例外狀況：</span><span class="sxs-lookup"><span data-stu-id="65651-149">If a task faults, the following expressions throw the exception:</span></span>

- `await task`
- `task.Wait()`
- `task.Result`
- `task.GetAwaiter().GetResult()`

<span data-ttu-id="65651-150">使用 [`try-catch`](../../csharp/language-reference/keywords/try-catch.md) 語句來處理和觀察擲回的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="65651-150">Use a [`try-catch`](../../csharp/language-reference/keywords/try-catch.md) statement to handle and observe thrown exceptions.</span></span> <span data-ttu-id="65651-151">或者，藉由存取屬性來觀察例外狀況 <xref:System.Threading.Tasks.Task.Exception%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="65651-151">Alternatively, observe the exception by accessing the <xref:System.Threading.Tasks.Task.Exception%2A?displayProperty=nameWithType> property.</span></span>

## <a name="unobservedtaskexception-event"></a><span data-ttu-id="65651-152">UnobservedTaskException 事件</span><span class="sxs-lookup"><span data-stu-id="65651-152">UnobservedTaskException event</span></span>

<span data-ttu-id="65651-153">在某些情況下，例如裝載時不受信任的外掛程式，良性的例外狀況可能很常見，而要手動觀察全部太困難。</span><span class="sxs-lookup"><span data-stu-id="65651-153">In some scenarios, such as when hosting untrusted plug-ins, benign exceptions might be common, and it might be too difficult to manually observe them all.</span></span> <span data-ttu-id="65651-154">在這些情況下，您可以處理 <xref:System.Threading.Tasks.TaskScheduler.UnobservedTaskException?displayProperty=nameWithType> 事件。</span><span class="sxs-lookup"><span data-stu-id="65651-154">In these cases, you can handle the <xref:System.Threading.Tasks.TaskScheduler.UnobservedTaskException?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="65651-155">傳遞至處理常式的 <xref:System.Threading.Tasks.UnobservedTaskExceptionEventArgs?displayProperty=nameWithType> 執行個體，可用來防止未觀察到的例外狀況傳播回聯結執行緒。</span><span class="sxs-lookup"><span data-stu-id="65651-155">The <xref:System.Threading.Tasks.UnobservedTaskExceptionEventArgs?displayProperty=nameWithType> instance that is passed to your handler can be used to prevent the unobserved exception from being propagated back to the joining thread.</span></span>

## <a name="see-also"></a><span data-ttu-id="65651-156">另請參閱</span><span class="sxs-lookup"><span data-stu-id="65651-156">See also</span></span>

- [<span data-ttu-id="65651-157">工作平行程式庫 (TPL)</span><span class="sxs-lookup"><span data-stu-id="65651-157">Task Parallel Library (TPL)</span></span>](task-parallel-library-tpl.md)
