---
title: 作法：撰寫簡單的 Parallel.For 迴圈
description: 瞭解如何在 .NET 中撰寫 Parallel. For 迴圈，您不需要取消迴圈、中斷迴圈反覆運算，或維護任何執行緒區域狀態。
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- Parallel.For, How to Write
- for loop, parallel construction in .NET
- parallel for loops, how to use
ms.assetid: 9029ba7f-a9d1-4526-8c84-c88716dba5d4
ms.openlocfilehash: 506d6dd725f5d42c6c445a14c5f450c815bfdde1
ms.sourcegitcommit: 965a5af7918acb0a3fd3baf342e15d511ef75188
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 11/18/2020
ms.locfileid: "94826629"
---
# <a name="how-to-write-a-simple-parallelfor-loop"></a><span data-ttu-id="32209-103">作法：撰寫簡單的 Parallel.For 迴圈</span><span class="sxs-lookup"><span data-stu-id="32209-103">How to: Write a Simple Parallel.For Loop</span></span>

<span data-ttu-id="32209-104">本主題包含兩個範例，示範 <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="32209-104">This topic contains two examples that illustrate the <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="32209-105">第一個範例使用 <xref:System.Threading.Tasks.Parallel.For%28System.Int64%2CSystem.Int64%2CSystem.Action%7BSystem.Int64%7D%29?displayProperty=nameWithType> 方法多載，而第二個會使用 <xref:System.Threading.Tasks.Parallel.For%28System.Int32%2CSystem.Int32%2CSystem.Action%7BSystem.Int32%7D%29?displayProperty=nameWithType> 多載，這是 <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> 方法的兩個最簡單的多載。</span><span class="sxs-lookup"><span data-stu-id="32209-105">The first uses the <xref:System.Threading.Tasks.Parallel.For%28System.Int64%2CSystem.Int64%2CSystem.Action%7BSystem.Int64%7D%29?displayProperty=nameWithType> method overload, and the second uses the <xref:System.Threading.Tasks.Parallel.For%28System.Int32%2CSystem.Int32%2CSystem.Action%7BSystem.Int32%7D%29?displayProperty=nameWithType> overload, the two simplest overloads of the <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="32209-106">當您不需要取消迴圈、中斷迴圈的反覆項目，或維護任何執行緒區域狀態時，可以使用這兩個 <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> 方法的多載。</span><span class="sxs-lookup"><span data-stu-id="32209-106">You can use these two overloads of the <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> method when you do not need to cancel the loop, break out of the loop iterations, or maintain any thread-local state.</span></span>

> [!NOTE]
> <span data-ttu-id="32209-107">本文件使用 Lambda 運算式來定義 TPL 中的委派。</span><span class="sxs-lookup"><span data-stu-id="32209-107">This documentation uses lambda expressions to define delegates in TPL.</span></span> <span data-ttu-id="32209-108">如果您不熟悉 C# 或 Visual Basic 中的 Lambda 運算式，請參閱 [PLINQ 和 TPL 中的 Lambda 運算式](lambda-expressions-in-plinq-and-tpl.md)。</span><span class="sxs-lookup"><span data-stu-id="32209-108">If you are not familiar with lambda expressions in C# or Visual Basic, see [Lambda Expressions in PLINQ and TPL](lambda-expressions-in-plinq-and-tpl.md).</span></span>

<span data-ttu-id="32209-109">第一個範例會計算單一目錄中的檔案大小。</span><span class="sxs-lookup"><span data-stu-id="32209-109">The first example calculates the size of files in a single directory.</span></span> <span data-ttu-id="32209-110">第二個會計算兩個矩陣的乘積。</span><span class="sxs-lookup"><span data-stu-id="32209-110">The second computes the product of two matrices.</span></span>

## <a name="directory-size-example"></a><span data-ttu-id="32209-111">目錄大小範例</span><span class="sxs-lookup"><span data-stu-id="32209-111">Directory size example</span></span>

<span data-ttu-id="32209-112">這個範例是簡單的命令列公用程式，它會計算目錄中的檔案大小總計。</span><span class="sxs-lookup"><span data-stu-id="32209-112">This example is a simple command-line utility that calculates the total size of files in a directory.</span></span> <span data-ttu-id="32209-113">它預期會有單一目錄路徑做為引數，並報告該目錄中的檔案大小總計與數量。</span><span class="sxs-lookup"><span data-stu-id="32209-113">It expects a single directory path as an argument, and reports the number and total size of the files in that directory.</span></span> <span data-ttu-id="32209-114">在確認目錄存在之後，它會使用 <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> 方法來列舉目錄中的檔案，並判斷其檔案大小。</span><span class="sxs-lookup"><span data-stu-id="32209-114">After verifying that the directory exists, it uses the <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> method to enumerate the files in the directory and determine their file sizes.</span></span> <span data-ttu-id="32209-115">每個檔案大小會加到 `totalSize` 變數。</span><span class="sxs-lookup"><span data-stu-id="32209-115">Each file size is then added to the `totalSize` variable.</span></span> <span data-ttu-id="32209-116">請注意，加法是透過呼叫 <xref:System.Threading.Interlocked.Add%2A?displayProperty=nameWithType> 來執行，因此加法在執行時是不可部分完成的作業。</span><span class="sxs-lookup"><span data-stu-id="32209-116">Note that the addition is performed by calling the <xref:System.Threading.Interlocked.Add%2A?displayProperty=nameWithType> so that the addition is performed as an atomic operation.</span></span> <span data-ttu-id="32209-117">否則，多個工作可能會嘗試同時更新 `totalSize` 變數。</span><span class="sxs-lookup"><span data-stu-id="32209-117">Otherwise, multiple tasks could try to update the `totalSize` variable simultaneously.</span></span>

[!code-csharp[Conceptual.Parallel.For#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.parallel.for/cs/for1.cs#1)]
[!code-vb[Conceptual.Parallel.For#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.parallel.for/vb/for1.vb#1)]

## <a name="matrix-and-stopwatch-example"></a><span data-ttu-id="32209-118">矩陣和碼錶範例</span><span class="sxs-lookup"><span data-stu-id="32209-118">Matrix and stopwatch example</span></span>

<span data-ttu-id="32209-119">這個範例會使用 <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> 方法來計算兩個矩陣的乘積。</span><span class="sxs-lookup"><span data-stu-id="32209-119">This example uses the <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> method to compute the product of two matrices.</span></span> <span data-ttu-id="32209-120">它也顯示如何使用 <xref:System.Diagnostics.Stopwatch?displayProperty=nameWithType> 類別比較平行迴圈與非平行迴圈的效能。</span><span class="sxs-lookup"><span data-stu-id="32209-120">It also shows how to use the <xref:System.Diagnostics.Stopwatch?displayProperty=nameWithType> class to compare the performance of a parallel loop with a non-parallel loop.</span></span> <span data-ttu-id="32209-121">請注意，由於它可能會產生大量的輸出，因此範例允許輸出重新導向至檔案。</span><span class="sxs-lookup"><span data-stu-id="32209-121">Note that, because it can generate a large volume of output, the example allows output to be redirected to a file.</span></span>

[!code-csharp[TPL_Parallel#01](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_parallel/cs/simpleparallelfor.cs#01)]
[!code-vb[TPL_Parallel#01](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_parallel/vb/simpleparallelfor.vb#01)]

<span data-ttu-id="32209-122">平行處理任何程式碼，包括迴圈時，一個重要的目標是要盡可能利用處理器，而不過度平行處理，導致平行處理的負荷否定任何效能優勢。</span><span class="sxs-lookup"><span data-stu-id="32209-122">When parallelizing any code, including loops, one important goal is to utilize the processors as much as possible without over parallelizing to the point where the overhead for parallel processing negates any performance benefits.</span></span> <span data-ttu-id="32209-123">在這個特定範例中，只有外部迴圈會進行平行處理，因為內部迴圈中沒有執行太多工作。</span><span class="sxs-lookup"><span data-stu-id="32209-123">In this particular example, only the outer loop is parallelized because there is not very much work performed in the inner loop.</span></span> <span data-ttu-id="32209-124">少量的工作和非預期的快取效果的組合可能導致巢狀平行迴圈中的效能降低。</span><span class="sxs-lookup"><span data-stu-id="32209-124">The combination of a small amount of work and undesirable cache effects can result in performance degradation in nested parallel loops.</span></span> <span data-ttu-id="32209-125">因此，只平行處理外部迴圈是讓大多數系統上的並行處理好處最大化的最佳方式。</span><span class="sxs-lookup"><span data-stu-id="32209-125">Therefore, parallelizing the outer loop only is the best way to maximize the benefits of concurrency on most systems.</span></span>

## <a name="the-delegate"></a><span data-ttu-id="32209-126">委派</span><span class="sxs-lookup"><span data-stu-id="32209-126">The Delegate</span></span>

<span data-ttu-id="32209-127">這個 <xref:System.Threading.Tasks.Parallel.For%2A> 多載的第三個參數是 C# 中類型`Action<int>` 或 Visual Basic 中類型 `Action(Of Integer)` 委派。</span><span class="sxs-lookup"><span data-stu-id="32209-127">The third parameter of this overload of <xref:System.Threading.Tasks.Parallel.For%2A> is a delegate of type `Action<int>` in C# or `Action(Of Integer)` in Visual Basic.</span></span> <span data-ttu-id="32209-128">`Action` 委派不論有零個、一個或 16 個類型參數，都一律會傳回 void。</span><span class="sxs-lookup"><span data-stu-id="32209-128">An `Action` delegate, whether it has zero, one or sixteen type parameters, always returns void.</span></span> <span data-ttu-id="32209-129">在 Visual Basic 中，`Action` 的行為使用 `Sub` 來定義。</span><span class="sxs-lookup"><span data-stu-id="32209-129">In Visual Basic, the behavior of an `Action` is defined with a `Sub`.</span></span> <span data-ttu-id="32209-130">這個範例會使用 Lambda 運算式來建立委派，但您也可以用其他方式建立委派。</span><span class="sxs-lookup"><span data-stu-id="32209-130">The example uses a lambda expression to create the delegate, but you can create the delegate in other ways as well.</span></span> <span data-ttu-id="32209-131">如需詳細資訊，請參閱 [PLINQ 和 TPL 中的 Lambda 運算式](lambda-expressions-in-plinq-and-tpl.md)。</span><span class="sxs-lookup"><span data-stu-id="32209-131">For more information, see [Lambda Expressions in PLINQ and TPL](lambda-expressions-in-plinq-and-tpl.md).</span></span>

## <a name="the-iteration-value"></a><span data-ttu-id="32209-132">反覆項目值</span><span class="sxs-lookup"><span data-stu-id="32209-132">The Iteration Value</span></span>

<span data-ttu-id="32209-133">委派會採用單一輸入參數，其值是目前反覆項目。</span><span class="sxs-lookup"><span data-stu-id="32209-133">The delegate takes a single input parameter whose value is the current iteration.</span></span> <span data-ttu-id="32209-134">此反覆項目值由執行階段所提供，且其起始值為目前執行緒上正在處理之來源區段 (分割區) 上的第一個項目的索引。</span><span class="sxs-lookup"><span data-stu-id="32209-134">This iteration value is supplied by the runtime and its starting value is the index of the first element on the segment (partition) of the source that is being processed on the current thread.</span></span>

<span data-ttu-id="32209-135">如果您需要對並行處理等級有更多控制，請使用採用 <xref:System.Threading.Tasks.ParallelOptions?displayProperty=nameWithType> 輸入參數的其中一個多載，例如：<xref:System.Threading.Tasks.Parallel.For%28System.Int32%2CSystem.Int32%2CSystem.Threading.Tasks.ParallelOptions%2CSystem.Action%7BSystem.Int32%2CSystem.Threading.Tasks.ParallelLoopState%7D%29?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="32209-135">If you require more control over the concurrency level, use one of the overloads that takes a <xref:System.Threading.Tasks.ParallelOptions?displayProperty=nameWithType> input parameter, such as: <xref:System.Threading.Tasks.Parallel.For%28System.Int32%2CSystem.Int32%2CSystem.Threading.Tasks.ParallelOptions%2CSystem.Action%7BSystem.Int32%2CSystem.Threading.Tasks.ParallelLoopState%7D%29?displayProperty=nameWithType>.</span></span>

## <a name="return-value-and-exception-handling"></a><span data-ttu-id="32209-136">傳回值和例外狀況處理</span><span class="sxs-lookup"><span data-stu-id="32209-136">Return Value and Exception Handling</span></span>

<span data-ttu-id="32209-137">當所有執行緒都完成時，<xref:System.Threading.Tasks.Parallel.For%2A> 會傳回 <xref:System.Threading.Tasks.ParallelLoopResult?displayProperty=nameWithType> 物件。</span><span class="sxs-lookup"><span data-stu-id="32209-137"><xref:System.Threading.Tasks.Parallel.For%2A> returns a <xref:System.Threading.Tasks.ParallelLoopResult?displayProperty=nameWithType> object when all threads have completed.</span></span> <span data-ttu-id="32209-138">這個傳回值適用於您以手動方式停止或中斷迴圈的反覆項目時，因為 <xref:System.Threading.Tasks.ParallelLoopResult>會儲存資訊，以便最後一個反覆項目執行至完成。</span><span class="sxs-lookup"><span data-stu-id="32209-138">This return value is useful when you are stopping or breaking loop iteration manually, because the <xref:System.Threading.Tasks.ParallelLoopResult> stores information such as the last iteration that ran to completion.</span></span> <span data-ttu-id="32209-139">如果其中一個執行緒上發生一個或多個例外狀況，將會擲回 <xref:System.AggregateException?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="32209-139">If one or more exceptions occur on one of the threads, a <xref:System.AggregateException?displayProperty=nameWithType> will be thrown.</span></span>

<span data-ttu-id="32209-140">在這個範例的程式碼中，不會使用 <xref:System.Threading.Tasks.Parallel.For%2A> 的傳回值。</span><span class="sxs-lookup"><span data-stu-id="32209-140">In the code in this example, the return value of <xref:System.Threading.Tasks.Parallel.For%2A> is not used.</span></span>

## <a name="analysis-and-performance"></a><span data-ttu-id="32209-141">分析和效能</span><span class="sxs-lookup"><span data-stu-id="32209-141">Analysis and Performance</span></span>

<span data-ttu-id="32209-142">您可以使用 [效能精靈] 來檢視電腦上的 CPU 使用量。</span><span class="sxs-lookup"><span data-stu-id="32209-142">You can use the Performance Wizard to view CPU usage on your computer.</span></span> <span data-ttu-id="32209-143">做一個試驗，請增加矩陣中的資料行和資料列數目。</span><span class="sxs-lookup"><span data-stu-id="32209-143">As an experiment, increase the number of columns and rows in the matrices.</span></span> <span data-ttu-id="32209-144">矩陣愈大，計算的平行和循序版本之間的效能差異也愈大。</span><span class="sxs-lookup"><span data-stu-id="32209-144">The larger the matrices, the greater the performance difference between the parallel and sequential versions of the computation.</span></span> <span data-ttu-id="32209-145">當矩陣是小型矩陣時，循序版本會因為設定平行迴圈的負荷而執行較快。</span><span class="sxs-lookup"><span data-stu-id="32209-145">When the matrix is small, the sequential version will run faster because of the overhead in setting up the parallel loop.</span></span>

<span data-ttu-id="32209-146">對於共用資源的同步呼叫，像是主控台或檔案系統，將會大幅降低平行迴圈的效能。</span><span class="sxs-lookup"><span data-stu-id="32209-146">Synchronous calls to shared resources, like the Console or the File System, will significantly degrade the performance of a parallel loop.</span></span> <span data-ttu-id="32209-147">測量效能時，請試著避免在迴圈內使用例如 <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 的呼叫。</span><span class="sxs-lookup"><span data-stu-id="32209-147">When measuring performance, try to avoid calls such as <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> within the loop.</span></span>

## <a name="compile-the-code"></a><span data-ttu-id="32209-148">編譯程式碼</span><span class="sxs-lookup"><span data-stu-id="32209-148">Compile the Code</span></span>

<span data-ttu-id="32209-149">將這段程式碼複製並貼到 Visual Studio 專案。</span><span class="sxs-lookup"><span data-stu-id="32209-149">Copy and paste this code into a Visual Studio project.</span></span>

## <a name="see-also"></a><span data-ttu-id="32209-150">請參閱</span><span class="sxs-lookup"><span data-stu-id="32209-150">See also</span></span>

- <xref:System.Threading.Tasks.Parallel.For%2A>
- <xref:System.Threading.Tasks.Parallel.ForEach%2A>
- [<span data-ttu-id="32209-151">資料平行處理</span><span class="sxs-lookup"><span data-stu-id="32209-151">Data Parallelism</span></span>](data-parallelism-task-parallel-library.md)
- [<span data-ttu-id="32209-152">平行程式設計</span><span class="sxs-lookup"><span data-stu-id="32209-152">Parallel Programming</span></span>](index.md)
