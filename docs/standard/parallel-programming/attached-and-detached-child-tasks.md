---
title: 附加與中斷連結的子工作
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- tasks, child tasks
ms.assetid: c95788bf-90a6-4e96-b7bc-58e36a228cc5
ms.openlocfilehash: c8a5d2c1ccb8bb2d272c2582cd416cdfd75506d8
ms.sourcegitcommit: 33deec3e814238fb18a49b2a7e89278e27888291
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 06/02/2020
ms.locfileid: "84285686"
---
# <a name="attached-and-detached-child-tasks"></a><span data-ttu-id="b6de8-102">附加與中斷連結的子工作</span><span class="sxs-lookup"><span data-stu-id="b6de8-102">Attached and Detached Child Tasks</span></span>
<span data-ttu-id="b6de8-103">「子工作」**(或「巢狀工作」**) 是 <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> 執行個體，它是在另一項工作 (稱為「父工作」\*\*) 的使用者委派中建立。</span><span class="sxs-lookup"><span data-stu-id="b6de8-103">A *child task* (or *nested task*) is a <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> instance that is created in the user delegate of another task, which is known as the *parent task*.</span></span> <span data-ttu-id="b6de8-104">子工作可以中斷連結或附加。</span><span class="sxs-lookup"><span data-stu-id="b6de8-104">A child task can be either detached or attached.</span></span> <span data-ttu-id="b6de8-105">「中斷連結的子工作」\*\*(detached child task) 是獨立於其父代而執行的工作。</span><span class="sxs-lookup"><span data-stu-id="b6de8-105">A *detached child task* is a task that executes independently of its parent.</span></span> <span data-ttu-id="b6de8-106">「附加的子工作」\*\*(attached child task) 是巢狀工作，而且是使用 <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent?displayProperty=nameWithType> 選項所建立，其父代並不明確或預設禁止它附加。</span><span class="sxs-lookup"><span data-stu-id="b6de8-106">An *attached child task* is a nested task that is created with the <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent?displayProperty=nameWithType> option whose parent does not explicitly or by default prohibit it from being attached.</span></span> <span data-ttu-id="b6de8-107">工作可能會建立任意數目的附加和中斷連結的子工作，只受限於系統資源。</span><span class="sxs-lookup"><span data-stu-id="b6de8-107">A task may create any number of attached and detached child tasks, limited only by system resources.</span></span>  
  
 <span data-ttu-id="b6de8-108">下表列出這兩種子工作之間的基本差異。</span><span class="sxs-lookup"><span data-stu-id="b6de8-108">The following table lists the basic differences between the two kinds of child tasks.</span></span>  
  
|<span data-ttu-id="b6de8-109">類別</span><span class="sxs-lookup"><span data-stu-id="b6de8-109">Category</span></span>|<span data-ttu-id="b6de8-110">中斷連結的子工作</span><span class="sxs-lookup"><span data-stu-id="b6de8-110">Detached child tasks</span></span>|<span data-ttu-id="b6de8-111">附加的子工作</span><span class="sxs-lookup"><span data-stu-id="b6de8-111">Attached child tasks</span></span>|  
|--------------|--------------------------|--------------------------|  
|<span data-ttu-id="b6de8-112">等候子工作完成的父系。</span><span class="sxs-lookup"><span data-stu-id="b6de8-112">Parent waits for child tasks to complete.</span></span>|<span data-ttu-id="b6de8-113">否</span><span class="sxs-lookup"><span data-stu-id="b6de8-113">No</span></span>|<span data-ttu-id="b6de8-114">是</span><span class="sxs-lookup"><span data-stu-id="b6de8-114">Yes</span></span>|  
|<span data-ttu-id="b6de8-115">父系會傳播子工作擲回的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="b6de8-115">Parent propagates exceptions thrown by child tasks.</span></span>|<span data-ttu-id="b6de8-116">否</span><span class="sxs-lookup"><span data-stu-id="b6de8-116">No</span></span>|<span data-ttu-id="b6de8-117">是</span><span class="sxs-lookup"><span data-stu-id="b6de8-117">Yes</span></span>|  
|<span data-ttu-id="b6de8-118">父系的狀態取決於子系的狀態。</span><span class="sxs-lookup"><span data-stu-id="b6de8-118">Status of parent depends on status of child.</span></span>|<span data-ttu-id="b6de8-119">否</span><span class="sxs-lookup"><span data-stu-id="b6de8-119">No</span></span>|<span data-ttu-id="b6de8-120">是</span><span class="sxs-lookup"><span data-stu-id="b6de8-120">Yes</span></span>|  
  
 <span data-ttu-id="b6de8-121">在大部分情況下，我們建議您使用中斷連結的子工作，因為它們與其他工作的關聯性較不複雜。</span><span class="sxs-lookup"><span data-stu-id="b6de8-121">In most scenarios, we recommend that you use detached child tasks, because their relationships with other tasks are less complex.</span></span> <span data-ttu-id="b6de8-122">這也就是為什麼在父工作中建立的工作會依預設中斷連結，且您必須明確指定 <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent?displayProperty=nameWithType> 選項才能建立附加的子工作。</span><span class="sxs-lookup"><span data-stu-id="b6de8-122">That is why tasks created inside parent tasks are detached by default, and you must explicitly specify the <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent?displayProperty=nameWithType> option to create an attached child task.</span></span>  
  
## <a name="detached-child-tasks"></a><span data-ttu-id="b6de8-123">中斷連結的子工作</span><span class="sxs-lookup"><span data-stu-id="b6de8-123">Detached child tasks</span></span>  
 <span data-ttu-id="b6de8-124">雖然子工作由父工作建立，依預設它與父工作無關。</span><span class="sxs-lookup"><span data-stu-id="b6de8-124">Although a child task is created by a parent task, by default it is independent of the parent task.</span></span> <span data-ttu-id="b6de8-125">在下列範例中，父工作會建立一個簡單的子工作。</span><span class="sxs-lookup"><span data-stu-id="b6de8-125">In the following example, a parent task creates one simple child task.</span></span> <span data-ttu-id="b6de8-126">如果多次執行範例程式碼，您可能會注意到範例的輸出會不同於所顯示內容，且每次執行程式碼時輸出也可能變更。</span><span class="sxs-lookup"><span data-stu-id="b6de8-126">If you run the example code multiple times, you may notice that the output from the example differs from that shown, and also that the output may change each time you run the code.</span></span> <span data-ttu-id="b6de8-127">這是因為父工作和子工作執行時彼此無關。子系是中斷連結的工作。</span><span class="sxs-lookup"><span data-stu-id="b6de8-127">This occurs because the parent task and child tasks execute independently of each other; the child is a detached task.</span></span> <span data-ttu-id="b6de8-128">此範例只會等候父工作完成，子工作可能無法在主控台應用程式終止之前執行或完成。</span><span class="sxs-lookup"><span data-stu-id="b6de8-128">The example waits only for the parent task to complete, and the child task may not execute or complete before the console app terminates.</span></span>  
  
 [!code-csharp[TPL_ChildTasks#1](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_childtasks/cs/nested1.cs#1)]
 [!code-vb[TPL_ChildTasks#1](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_childtasks/vb/nested1.vb#1)]  
  
 <span data-ttu-id="b6de8-129">如果子工作由 <xref:System.Threading.Tasks.Task%601> 物件代表，而非 <xref:System.Threading.Tasks.Task> 物件，則您可以藉由存取子系的 <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> 屬性確保父工作會等待子系完成，即使它是中斷連結的子工作。</span><span class="sxs-lookup"><span data-stu-id="b6de8-129">If the child task is represented by a <xref:System.Threading.Tasks.Task%601> object rather than a <xref:System.Threading.Tasks.Task> object, you can ensure that the parent task will wait for the child to complete by accessing the <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property of the child even if it is a detached child task.</span></span> <span data-ttu-id="b6de8-130"><xref:System.Threading.Tasks.Task%601.Result%2A> 屬性會封鎖，直到完成其工作，如下列範例所示。</span><span class="sxs-lookup"><span data-stu-id="b6de8-130">The <xref:System.Threading.Tasks.Task%601.Result%2A> property blocks until its task completes, as the following example shows.</span></span>  
  
 [!code-csharp[TPL_ChildTasks#4](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_childtasks/cs/childtasks.cs#4)]
 [!code-vb[TPL_ChildTasks#4](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_childtasks/vb/tpl_childtasks.vb#4)]  
  
## <a name="attached-child-tasks"></a><span data-ttu-id="b6de8-131">附加的子工作</span><span class="sxs-lookup"><span data-stu-id="b6de8-131">Attached child tasks</span></span>  
 <span data-ttu-id="b6de8-132">不同於中斷連結的子工作，附加的子工作與父代密切同步。</span><span class="sxs-lookup"><span data-stu-id="b6de8-132">Unlike detached child tasks, attached child tasks are closely synchronized with the parent.</span></span> <span data-ttu-id="b6de8-133">您可以將前一個範例中的中斷連結子工作，變更為附加的子工作，只要在工作建立陳述式中使用 <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent?displayProperty=nameWithType> 選項，如下列範例所示。</span><span class="sxs-lookup"><span data-stu-id="b6de8-133">You can change the detached child task in the previous example to an attached child task by using the <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent?displayProperty=nameWithType> option in the task creation statement, as shown in the following example.</span></span> <span data-ttu-id="b6de8-134">在此程式碼中，附加的子工作會在其父系之前完成。</span><span class="sxs-lookup"><span data-stu-id="b6de8-134">In this code, the attached child task completes before its parent.</span></span> <span data-ttu-id="b6de8-135">如此一來，此範例的輸出在您每次執行程式碼時都會相同。</span><span class="sxs-lookup"><span data-stu-id="b6de8-135">As a result, the output from the example is the same each time you run the code.</span></span>  
  
 [!code-csharp[TPL_ChildTasks#2](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_childtasks/cs/child1.cs#2)]
 [!code-vb[TPL_ChildTasks#2](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_childtasks/vb/child1.vb#2)]  
  
 <span data-ttu-id="b6de8-136">您可以使用附加的子工作，建立非同步作業的緊密同步處理圖形。</span><span class="sxs-lookup"><span data-stu-id="b6de8-136">You can use attached child tasks to create tightly synchronized graphs of asynchronous operations.</span></span>  
  
 <span data-ttu-id="b6de8-137">不過，子工作只能在其父代未禁止附加子工作時附加至其父代。</span><span class="sxs-lookup"><span data-stu-id="b6de8-137">However, a child task can attach to its parent only if its parent does not prohibit attached child tasks.</span></span> <span data-ttu-id="b6de8-138">父工作可以明確地防止子工作附加至其上，方法是在父工作的類別建構函式中指定 <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType> 選項或 <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="b6de8-138">Parent tasks can explicitly prevent child tasks from attaching to them by specifying the <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType> option in the parent task's class constructor or the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="b6de8-139">如果父工作是藉由呼叫 <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> 方法而建立，則父工作會隱含地防止子工作附加至它們。</span><span class="sxs-lookup"><span data-stu-id="b6de8-139">Parent tasks implicitly prevent child tasks from attaching to them if they are created by calling the <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="b6de8-140">下列範例將說明這點。</span><span class="sxs-lookup"><span data-stu-id="b6de8-140">The following example illustrates this.</span></span> <span data-ttu-id="b6de8-141">它與先前的範例相同，只除了父工作是藉由呼叫 <xref:System.Threading.Tasks.Task.Run%28System.Action%29?displayProperty=nameWithType> 方法建立，而非 <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="b6de8-141">It is identical to the previous example, except that the parent task is created by calling the <xref:System.Threading.Tasks.Task.Run%28System.Action%29?displayProperty=nameWithType> method rather than the <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="b6de8-142">因為子工作不能附加至其父代，所以無法預期此範例的輸出。</span><span class="sxs-lookup"><span data-stu-id="b6de8-142">Because the child task is not able to attach to its parent, the output from the example is unpredictable.</span></span> <span data-ttu-id="b6de8-143">因為 <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> 多載的預設工作建立選項包含 <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>，此範例在功能上等於＜中斷連結的子工作＞一節中的第一個範例。</span><span class="sxs-lookup"><span data-stu-id="b6de8-143">Because the default task creation options for the <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> overloads include <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>, this example is functionally equivalent to the first example in the "Detached child tasks" section.</span></span>  
  
 [!code-csharp[TPL_ChildTasks#3](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_childtasks/cs/child1a.cs#3)]
 [!code-vb[TPL_ChildTasks#3](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_childtasks/vb/child1a.vb#3)]  
  
## <a name="exceptions-in-child-tasks"></a><span data-ttu-id="b6de8-144">子工作中的例外狀況</span><span class="sxs-lookup"><span data-stu-id="b6de8-144">Exceptions in child tasks</span></span>  
 <span data-ttu-id="b6de8-145">如果中斷連結的子工作擲回例外狀況，則必須直接在父工作中觀察或處理該例外狀況，就像對任何非巢狀工作一樣。</span><span class="sxs-lookup"><span data-stu-id="b6de8-145">If a detached child task throws an exception, that exception must be observed or handled directly in the parent task just as with any non-nested task.</span></span> <span data-ttu-id="b6de8-146">如果附加的子工作擲回例外狀況，例外狀況會自動傳播至父工作，以及回到等待或嘗試存取工作之 <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> 屬性的緒行緒。</span><span class="sxs-lookup"><span data-stu-id="b6de8-146">If an attached child task throws an exception, the exception is automatically propagated to the parent task and back to the thread that waits or tries to access the task's <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="b6de8-147">因此，藉由使用附加的子工作，您可以在呼叫執行緒上，對 <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> 的呼叫中，一次處理所有例外狀況。</span><span class="sxs-lookup"><span data-stu-id="b6de8-147">Therefore, by using attached child tasks, you can handle all exceptions at just one point in the call to <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> on the calling thread.</span></span> <span data-ttu-id="b6de8-148">如需詳細資訊，請參閱[例外狀況處理](exception-handling-task-parallel-library.md)。</span><span class="sxs-lookup"><span data-stu-id="b6de8-148">For more information, see [Exception Handling](exception-handling-task-parallel-library.md).</span></span>  
  
## <a name="cancellation-and-child-tasks"></a><span data-ttu-id="b6de8-149">取消和子工作</span><span class="sxs-lookup"><span data-stu-id="b6de8-149">Cancellation and child tasks</span></span>  
 <span data-ttu-id="b6de8-150">工作取消需要合作。</span><span class="sxs-lookup"><span data-stu-id="b6de8-150">Task cancellation is cooperative.</span></span> <span data-ttu-id="b6de8-151">也就是說，若要能取消，每個附加或中斷連結的子工作必須監視取消語彙基元的狀態。</span><span class="sxs-lookup"><span data-stu-id="b6de8-151">That is, to be cancelable, every attached or detached child task must monitor the status of the cancellation token.</span></span> <span data-ttu-id="b6de8-152">如果您想要使用一個取消要求來取消父系及其所有子系，您會將相同的語彙基元當做引數傳遞至所有工作，並在每個工作中提供邏輯以回應每個工作中的要求。</span><span class="sxs-lookup"><span data-stu-id="b6de8-152">If you want to cancel a parent and all its children by using one cancellation request, you pass the same token as an argument to all tasks and provide in each task the logic to respond to the request in each task.</span></span> <span data-ttu-id="b6de8-153">如需詳細資訊，請參閱[工作取消](task-cancellation.md)和[如何：取消工作及其子系](how-to-cancel-a-task-and-its-children.md)。</span><span class="sxs-lookup"><span data-stu-id="b6de8-153">For more information, see [Task Cancellation](task-cancellation.md) and [How to: Cancel a Task and Its Children](how-to-cancel-a-task-and-its-children.md).</span></span>  
  
### <a name="when-the-parent-cancels"></a><span data-ttu-id="b6de8-154">當父系取消時</span><span class="sxs-lookup"><span data-stu-id="b6de8-154">When the parent cancels</span></span>  
 <span data-ttu-id="b6de8-155">如果父系在其子工作啟動之前自行取消，則永遠不會啟動子系。</span><span class="sxs-lookup"><span data-stu-id="b6de8-155">If a parent cancels itself before its child task is started, the child never starts.</span></span> <span data-ttu-id="b6de8-156">如果父系在子工作已經開始之後自行取消，則子系會執行到完成為止，除非它有自己的取消邏輯。</span><span class="sxs-lookup"><span data-stu-id="b6de8-156">If a parent cancels itself after its child task has already started, the child runs to completion unless it has its own cancellation logic.</span></span> <span data-ttu-id="b6de8-157">如需詳細資訊，請參閱 [Task Cancellation](task-cancellation.md)。</span><span class="sxs-lookup"><span data-stu-id="b6de8-157">For more information, see [Task Cancellation](task-cancellation.md).</span></span>  
  
### <a name="when-a-detached-child-task-cancels"></a><span data-ttu-id="b6de8-158">當取消中斷連結的子工作時</span><span class="sxs-lookup"><span data-stu-id="b6de8-158">When a detached child task cancels</span></span>  
 <span data-ttu-id="b6de8-159">如果中斷連結的子工作使用傳遞給父系的相同語彙基元來自行取消，且父系不等候子工作，則不會傳播任何例外狀況，因為例外狀況被視為良性合作取消。</span><span class="sxs-lookup"><span data-stu-id="b6de8-159">If a detached child task cancels itself by using the same token that was passed to the parent, and the parent does not wait for the child task, no exception is propagated, because the exception is treated as benign cooperation cancellation.</span></span> <span data-ttu-id="b6de8-160">此行為與任何最上層工作相同。</span><span class="sxs-lookup"><span data-stu-id="b6de8-160">This behavior is the same as that of any top-level task.</span></span>  
  
### <a name="when-an-attached-child-task-cancels"></a><span data-ttu-id="b6de8-161">當取消附加的子工作時</span><span class="sxs-lookup"><span data-stu-id="b6de8-161">When an attached child task cancels</span></span>  
 <span data-ttu-id="b6de8-162">當附加的子工作使用傳遞給父工作的相同語彙基元來自行取消時，<xref:System.Threading.Tasks.TaskCanceledException> 會傳播到 <xref:System.AggregateException> 內部的聯結執行緒。</span><span class="sxs-lookup"><span data-stu-id="b6de8-162">When an attached child task cancels itself by using the same token that was passed to its parent task, a <xref:System.Threading.Tasks.TaskCanceledException> is propagated to the joining thread inside an <xref:System.AggregateException>.</span></span> <span data-ttu-id="b6de8-163">您必須等候父工作，以便處理所有良性的例外狀況，以及所有在附加的子工作的圖形間向上傳播的錯誤例外狀況。</span><span class="sxs-lookup"><span data-stu-id="b6de8-163">You must wait for the parent task so that you can handle all benign exceptions in addition to all faulting exceptions that are propagated up through a graph of attached child tasks.</span></span>  
  
 <span data-ttu-id="b6de8-164">如需詳細資訊，請參閱[例外狀況處理](exception-handling-task-parallel-library.md)。</span><span class="sxs-lookup"><span data-stu-id="b6de8-164">For more information, see [Exception Handling](exception-handling-task-parallel-library.md).</span></span>  
  
## <a name="preventing-a-child-task-from-attaching-to-its-parent"></a><span data-ttu-id="b6de8-165">防止子工作附加到其父系</span><span class="sxs-lookup"><span data-stu-id="b6de8-165">Preventing a child task from attaching to its parent</span></span>  
 <span data-ttu-id="b6de8-166">子工作所擲回的未處理例外狀況會傳播到父工作。</span><span class="sxs-lookup"><span data-stu-id="b6de8-166">An unhandled exception that is thrown by a child task is propagated to the parent task.</span></span> <span data-ttu-id="b6de8-167">您可以使用此行為來從一個根工作觀察所有子工作例外狀況，而不必周遊工作樹狀。</span><span class="sxs-lookup"><span data-stu-id="b6de8-167">You can use this behavior to observe all child task exceptions from one root task instead of traversing a tree of tasks.</span></span> <span data-ttu-id="b6de8-168">不過，當父工作不預期會有來自其他程式碼的附加時，例外狀況傳播可能會造成問題。</span><span class="sxs-lookup"><span data-stu-id="b6de8-168">However, exception propagation can be problematic when a parent task does not expect attachment from other code.</span></span> <span data-ttu-id="b6de8-169">例如，假設應用程式從 <xref:System.Threading.Tasks.Task> 物件呼叫協力廠商程式庫元件。</span><span class="sxs-lookup"><span data-stu-id="b6de8-169">For example, consider an app that calls a third-party library component from a <xref:System.Threading.Tasks.Task> object.</span></span> <span data-ttu-id="b6de8-170">如果協力廠商程式庫元件也會建立 <xref:System.Threading.Tasks.Task> 物件，並指定 <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent?displayProperty=nameWithType> 將它附加至父工作，則在子工作中發生任何未處理例外狀況都會傳播到父系。</span><span class="sxs-lookup"><span data-stu-id="b6de8-170">If the third-party library component also creates a <xref:System.Threading.Tasks.Task> object and specifies <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent?displayProperty=nameWithType> to attach it to the parent task, any unhandled exceptions that occur in the child task propagate to the parent.</span></span> <span data-ttu-id="b6de8-171">這可能會導致在主應用程式中非預期的行為。</span><span class="sxs-lookup"><span data-stu-id="b6de8-171">This could lead to unexpected behavior in the main app.</span></span>  
  
 <span data-ttu-id="b6de8-172">若要防止子工作附加至其父工作，，當您建立父 <xref:System.Threading.Tasks.Task> 或 <xref:System.Threading.Tasks.Task%601> 物件時，請指定 <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType> 選項。</span><span class="sxs-lookup"><span data-stu-id="b6de8-172">To prevent a child task from attaching to its parent task, specify the <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType> option when you create the parent <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601> object.</span></span> <span data-ttu-id="b6de8-173">當工作嘗試附加至其父系，而父系指定 <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType> 選項，則子工作將無法附加至父系，並且執行時就如同未指定 <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent?displayProperty=nameWithType> 選項。</span><span class="sxs-lookup"><span data-stu-id="b6de8-173">When a task tries to attach to its parent and the parent specifies the <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType> option, the child task will not be able to attach to a parent and will execute just as if the <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent?displayProperty=nameWithType> option was not specified.</span></span>  
  
 <span data-ttu-id="b6de8-174">當子工作未及時完成時，您也可能想要防止子工作附加到其父系。</span><span class="sxs-lookup"><span data-stu-id="b6de8-174">You might also want to prevent a child task from attaching to its parent when the child task does not finish in a timely manner.</span></span> <span data-ttu-id="b6de8-175">由於父工作會在所有子工作完成後才完成，因此長時間執行的子工作可能造成整個應用程式效能不佳。</span><span class="sxs-lookup"><span data-stu-id="b6de8-175">Because a parent task does not finish until all child tasks finish, a long-running child task can cause the overall app to perform poorly.</span></span> <span data-ttu-id="b6de8-176">如需示範如何藉由防止工作附加至其父工作以改善應用程式效能的範例，請參閱[如何：防止子工作附加到其父系](how-to-prevent-a-child-task-from-attaching-to-its-parent.md)。</span><span class="sxs-lookup"><span data-stu-id="b6de8-176">For an example that shows how to improve app performance by preventing a task from attaching to its parent task, see [How to: Prevent a Child Task from Attaching to its Parent](how-to-prevent-a-child-task-from-attaching-to-its-parent.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="b6de8-177">另請參閱</span><span class="sxs-lookup"><span data-stu-id="b6de8-177">See also</span></span>

- [<span data-ttu-id="b6de8-178">平行程式設計</span><span class="sxs-lookup"><span data-stu-id="b6de8-178">Parallel Programming</span></span>](index.md)
- [<span data-ttu-id="b6de8-179">資料平行處理</span><span class="sxs-lookup"><span data-stu-id="b6de8-179">Data Parallelism</span></span>](data-parallelism-task-parallel-library.md)
