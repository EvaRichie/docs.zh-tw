---
title: PLINQ 和 TPL 的自訂 Partitioner
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- tasks, partitioners
ms.assetid: 96153688-9a01-47c4-8430-909cee9a2887
ms.openlocfilehash: 2268df2eb5cae4dcd7adde491b42c86c546aa1fc
ms.sourcegitcommit: 965a5af7918acb0a3fd3baf342e15d511ef75188
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 11/18/2020
ms.locfileid: "94829228"
---
# <a name="custom-partitioners-for-plinq-and-tpl"></a><span data-ttu-id="d9ee0-102">PLINQ 和 TPL 的自訂 Partitioner</span><span class="sxs-lookup"><span data-stu-id="d9ee0-102">Custom Partitioners for PLINQ and TPL</span></span>

<span data-ttu-id="d9ee0-103">若要將資料來源上的作業平行化，其中一個必要步驟就是將來源「分割」成多個可供多個執行緒同時存取的區段。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-103">To parallelize an operation on a data source, one of the essential steps is to *partition* the source into multiple sections that can be accessed concurrently by multiple threads.</span></span> <span data-ttu-id="d9ee0-104">PLINQ 和「工作平行程式庫」(TPL) 提供預設的 Partitioner，可在您撰寫平行查詢或 <xref:System.Threading.Tasks.Parallel.ForEach%2A> 迴圈時在背景中運作。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-104">PLINQ and the Task Parallel Library (TPL) provide default partitioners that work transparently when you write a parallel query or <xref:System.Threading.Tasks.Parallel.ForEach%2A> loop.</span></span> <span data-ttu-id="d9ee0-105">針對較進階的案例，您可以插入自己的 Partitioner。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-105">For more advanced scenarios, you can plug in your own partitioner.</span></span>

## <a name="kinds-of-partitioning"></a><span data-ttu-id="d9ee0-106">資料分割的種類</span><span class="sxs-lookup"><span data-stu-id="d9ee0-106">Kinds of Partitioning</span></span>

<span data-ttu-id="d9ee0-107">有許多可分割資料來源的方法。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-107">There are many ways to partition a data source.</span></span> <span data-ttu-id="d9ee0-108">在最有效率的方法中，多個執行緒會合作處理原始來源序列，而不會實際將來源分割成多個子序列。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-108">In the most efficient approaches, multiple threads cooperate to process the original source sequence, rather than physically separating the source into multiple subsequences.</span></span> <span data-ttu-id="d9ee0-109">針對陣列及其他已編製索引的來源 (例如已事先知道長度的 <xref:System.Collections.IList> 集合)，「定界分割」是最簡單的資料分割種類。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-109">For arrays and other indexed sources such as <xref:System.Collections.IList> collections where the length is known in advance, *range partitioning* is the simplest kind of partitioning.</span></span> <span data-ttu-id="d9ee0-110">每個執行緒都會收到唯一的開始和結束索引，因此可處理自己的來源範圍，而不會覆寫任何其他執行緒或被任何其他執行緒覆寫。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-110">Every thread receives unique beginning and ending indexes, so that it can process its range of the source without overwriting or being overwritten by any other thread.</span></span> <span data-ttu-id="d9ee0-111">定界分割唯一涉及的額外負荷就是一開始的範圍建立工作；之後則不需要任何額外的同步處理。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-111">The only overhead involved in range partitioning is the initial work of creating the ranges; no additional synchronization is required after that.</span></span> <span data-ttu-id="d9ee0-112">因此，只要平均分配工作負載，便能夠提供良好的效能。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-112">Therefore, it can provide good performance as long as the workload is divided evenly.</span></span> <span data-ttu-id="d9ee0-113">定界分割有個缺點，就是如果一個執行緒提早完成，它並無法協助其他執行緒完成它們的工作。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-113">A disadvantage of range partitioning is that if one thread finishes early, it cannot help the other threads finish their work.</span></span>

<span data-ttu-id="d9ee0-114">針對連結清單或其他長度不明的集合，您可以使用「區塊分割」。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-114">For linked lists or other collections whose length is not known, you can use *chunk partitioning*.</span></span> <span data-ttu-id="d9ee0-115">在區塊分割中，平行迴圈或查詢中的每個執行緒或工作都會取用一個區塊中的一些來源元素、處理它們，然後再返回來擷取額外的元素。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-115">In chunk partitioning, every thread or task in a parallel loop or query consumes some number of source elements in one chunk, processes them, and then comes back to retrieve additional elements.</span></span> <span data-ttu-id="d9ee0-116">Partitioner 可確保散發所有元素且沒有任何重複項目。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-116">The partitioner ensures that all elements are distributed and that there are no duplicates.</span></span> <span data-ttu-id="d9ee0-117">區塊可以是任何大小。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-117">A chunk may be any size.</span></span> <span data-ttu-id="d9ee0-118">例如，[如何：實作動態磁碟分割](how-to-implement-dynamic-partitions.md)所示範的 Partitioner 會建立只包含一個元素的區塊。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-118">For example, the partitioner that is demonstrated in [How to: Implement Dynamic Partitions](how-to-implement-dynamic-partitions.md) creates chunks that contain just one element.</span></span> <span data-ttu-id="d9ee0-119">只要區塊不是太大，這類資料分割本質上可提供負載平衡，因為不是以預先決定的方式將元素指派給執行緒。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-119">As long as the chunks are not too large, this kind of partitioning is inherently load-balancing because the assignment of elements to threads is not pre-determined.</span></span> <span data-ttu-id="d9ee0-120">不過，每次執行緒需要取得另一個區塊時，Partitioner 的確會造成同步處理額外負荷。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-120">However, the partitioner does incur the synchronization overhead each time the thread needs to get another chunk.</span></span> <span data-ttu-id="d9ee0-121">在這些情況下所導致的同步處理量多寡與區塊的大小成反比。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-121">The amount of synchronization incurred in these cases is inversely proportional to the size of the chunks.</span></span>

<span data-ttu-id="d9ee0-122">一般而言，只有在委派的執行時間為少到適中，且來源有大量元素，以及每個資料分割的總工作量大致相等時，定界分割才會比較快。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-122">In general, range partitioning is only faster when the execution time of the delegate is small to moderate, and the source has a large number of elements, and the total work of each partition is roughly equivalent.</span></span> <span data-ttu-id="d9ee0-123">因此，通常區塊分割在大多數情況下會比較快。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-123">Chunk partitioning is therefore generally faster in most cases.</span></span> <span data-ttu-id="d9ee0-124">當來源只有少量元素或委派的執行時間較長時，則區塊分割和定界分割的效能大致相等。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-124">On sources with a small number of elements or longer execution times for the delegate, then the performance of chunk and range partitioning is about equal.</span></span>

<span data-ttu-id="d9ee0-125">TPL Partitioner 也支援動態數量的資料分割。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-125">The TPL partitioners also support a dynamic number of partitions.</span></span> <span data-ttu-id="d9ee0-126">這意謂著它們可以機動地建立資料分割，例如當 <xref:System.Threading.Tasks.Parallel.ForEach%2A> 迴圈產生新工作時。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-126">This means they can create partitions on-the-fly, for example, when the <xref:System.Threading.Tasks.Parallel.ForEach%2A> loop spawns a new task.</span></span> <span data-ttu-id="d9ee0-127">此功能可讓 Partitioner 搭配迴圈本身一起進行調整。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-127">This feature enables the partitioner to scale together with the loop itself.</span></span> <span data-ttu-id="d9ee0-128">動態 Partitioner 也具有負載平衡的本質。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-128">Dynamic partitioners are also inherently load-balancing.</span></span> <span data-ttu-id="d9ee0-129">當您建立自訂 Partitioner 時，必須支援從 <xref:System.Threading.Tasks.Parallel.ForEach%2A> 迴圈取用動態分割。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-129">When you create a custom partitioner, you must support dynamic partitioning to be consumable from a <xref:System.Threading.Tasks.Parallel.ForEach%2A> loop.</span></span>

### <a name="configuring-load-balancing-partitioners-for-plinq"></a><span data-ttu-id="d9ee0-130">為 PLINQ 設定負載平衡 Partitioner</span><span class="sxs-lookup"><span data-stu-id="d9ee0-130">Configuring Load Balancing Partitioners for PLINQ</span></span>

<span data-ttu-id="d9ee0-131"><xref:System.Collections.Concurrent.Partitioner.Create%2A?displayProperty=nameWithType> 方法的某些多載可讓您針對陣列或 <xref:System.Collections.IList> 來源建立 Partitioner，並指定它是否應該嘗試平衡執行緒之間的工作負載。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-131">Some overloads of the <xref:System.Collections.Concurrent.Partitioner.Create%2A?displayProperty=nameWithType> method let you create a partitioner for an array or <xref:System.Collections.IList> source and specify whether it should attempt to balance the workload among the threads.</span></span> <span data-ttu-id="d9ee0-132">設定讓 Partitioner 進行負載平衡時，會使用區塊分割，在收到元素要求時，會將元素以小區塊交給每個資料分割。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-132">When the partitioner is configured to load-balance, chunk partitioning is used, and the elements are handed off to each partition in small chunks as they are requested.</span></span> <span data-ttu-id="d9ee0-133">此方法有助於確保所有資料分割都有元素可處理，直到整個迴圈或查詢完成為止。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-133">This approach helps ensure that all partitions have elements to process until the entire loop or query is completed.</span></span> <span data-ttu-id="d9ee0-134">您可以使用額外的多載來提供任何 <xref:System.Collections.IEnumerable> 來源的負載平衡分割。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-134">An additional overload can be used to provide load-balancing partitioning of any <xref:System.Collections.IEnumerable> source.</span></span>

<span data-ttu-id="d9ee0-135">一般而言，負載平衡需要資料分割較頻繁地向 Partitioner 要求元素。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-135">In general, load balancing requires the partitions to request elements relatively frequently from the partitioner.</span></span> <span data-ttu-id="d9ee0-136">相較之下，執行靜態分割的 Partitioner 則可藉由使用定界分割或區塊分割，將元素一次全部指派給每個 Partitioner。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-136">By contrast, a partitioner that does static partitioning can assign the elements to each partitioner all at once by using either range or chunk partitioning.</span></span> <span data-ttu-id="d9ee0-137">此做法所需的額外負荷比負載平衡少，但如果一個執行緒最後的工作量明顯多於其他執行緒，執行時間就可能較長。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-137">This requires less overhead than load balancing, but it might take longer to execute if one thread ends up with significantly more work than the others.</span></span> <span data-ttu-id="d9ee0-138">根據預設，當所傳遞的是 IList 或陣列時，PLINQ 一律會使用沒有負載平衡的定界分割。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-138">By default when it is passed an IList or an array, PLINQ always uses range partitioning without load balancing.</span></span> <span data-ttu-id="d9ee0-139">若要為 PLINQ 啟用負載平衡，請使用 `Partitioner.Create` 方法，如以下範例所示。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-139">To enable load balancing for PLINQ, use the `Partitioner.Create` method, as shown in the following example.</span></span>

[!code-csharp[TPL_Partitioners#02](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_partitioners/cs/partitioners.cs#02)]
[!code-vb[TPL_Partitioners#02](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_partitioners/vb/partitionsnippets_vb.vb#02)]

<span data-ttu-id="d9ee0-140">在任何指定的情況下，判斷是否該使用負載平衡的最佳方式，就是在代表性的負載和電腦設定下，進行實驗並測量作業需要多長的時間才能完成。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-140">The best way to determine whether to use load balancing in any given scenario is to experiment and measure how long it takes operations to complete under representative loads and computer configurations.</span></span> <span data-ttu-id="d9ee0-141">例如，在只有幾個核心的多核心電腦上，靜態分割可能會帶來顯著的加速效果，但在有較多核心的電腦上，則可能拖慢速度。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-141">For example, static partitioning might provide significant speedup on a multi-core computer that has only a few cores, but it might result in slowdowns on computers that have relatively many cores.</span></span>

<span data-ttu-id="d9ee0-142">下表列出 <xref:System.Collections.Concurrent.Partitioner.Create%2A> 方法的可用多載。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-142">The following table lists the available overloads of the <xref:System.Collections.Concurrent.Partitioner.Create%2A> method.</span></span> <span data-ttu-id="d9ee0-143">這些 Partitioner 不僅限於與 PLINQ 或 <xref:System.Threading.Tasks.Task> 搭配使用。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-143">These partitioners are not limited to use only with PLINQ or <xref:System.Threading.Tasks.Task>.</span></span> <span data-ttu-id="d9ee0-144">它們也可以與任何自訂的平行建構搭配使用。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-144">They can also be used with any custom parallel construct.</span></span>

|<span data-ttu-id="d9ee0-145">多載</span><span class="sxs-lookup"><span data-stu-id="d9ee0-145">Overload</span></span>|<span data-ttu-id="d9ee0-146">使用負載平衡</span><span class="sxs-lookup"><span data-stu-id="d9ee0-146">Uses load balancing</span></span>|
|--------------|-------------------------|
|<xref:System.Collections.Concurrent.Partitioner.Create%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>|<span data-ttu-id="d9ee0-147">永遠</span><span class="sxs-lookup"><span data-stu-id="d9ee0-147">Always</span></span>|
|<xref:System.Collections.Concurrent.Partitioner.Create%60%601%28%60%600%5B%5D%2CSystem.Boolean%29>|<span data-ttu-id="d9ee0-148">將布林值引數指定為 true 時</span><span class="sxs-lookup"><span data-stu-id="d9ee0-148">When the Boolean argument is specified as true</span></span>|
|<xref:System.Collections.Concurrent.Partitioner.Create%60%601%28System.Collections.Generic.IList%7B%60%600%7D%2CSystem.Boolean%29>|<span data-ttu-id="d9ee0-149">將布林值引數指定為 true 時</span><span class="sxs-lookup"><span data-stu-id="d9ee0-149">When the Boolean argument is specified as true</span></span>|
|<xref:System.Collections.Concurrent.Partitioner.Create%28System.Int32%2CSystem.Int32%29>|<span data-ttu-id="d9ee0-150">永不</span><span class="sxs-lookup"><span data-stu-id="d9ee0-150">Never</span></span>|
|<xref:System.Collections.Concurrent.Partitioner.Create%28System.Int32%2CSystem.Int32%2CSystem.Int32%29>|<span data-ttu-id="d9ee0-151">永不</span><span class="sxs-lookup"><span data-stu-id="d9ee0-151">Never</span></span>|
|<xref:System.Collections.Concurrent.Partitioner.Create%28System.Int64%2CSystem.Int64%29>|<span data-ttu-id="d9ee0-152">永不</span><span class="sxs-lookup"><span data-stu-id="d9ee0-152">Never</span></span>|
|<xref:System.Collections.Concurrent.Partitioner.Create%28System.Int64%2CSystem.Int64%2CSystem.Int64%29>|<span data-ttu-id="d9ee0-153">永不</span><span class="sxs-lookup"><span data-stu-id="d9ee0-153">Never</span></span>|

### <a name="configuring-static-range-partitioners-for-parallelforeach"></a><span data-ttu-id="d9ee0-154">為 Parallel.ForEach 設定靜態定界分割</span><span class="sxs-lookup"><span data-stu-id="d9ee0-154">Configuring Static Range Partitioners for Parallel.ForEach</span></span>

<span data-ttu-id="d9ee0-155">在 <xref:System.Threading.Tasks.Parallel.For%2A> 迴圈中，會將迴圈主體提供給方法作為委派。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-155">In a <xref:System.Threading.Tasks.Parallel.For%2A> loop, the body of the loop is provided to the method as a delegate.</span></span> <span data-ttu-id="d9ee0-156">叫用該委派的成本與虛擬方法呼叫大致相同。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-156">The cost of invoking that delegate is about the same as a virtual method call.</span></span> <span data-ttu-id="d9ee0-157">在某些案例中，平行迴圈的主體可能相當小，而足以讓每個迴圈反覆運算上的委派引動過程成本變得很高。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-157">In some scenarios, the body of a parallel loop might be small enough that the cost of the delegate invocation on each loop iteration becomes significant.</span></span> <span data-ttu-id="d9ee0-158">在這類情況下，您可以使用其中一個 <xref:System.Collections.Concurrent.Partitioner.Create%2A> 多載，在來源元素上建立定界分割的 <xref:System.Collections.Generic.IEnumerable%601>。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-158">In such situations, you can use one of the <xref:System.Collections.Concurrent.Partitioner.Create%2A> overloads to create an <xref:System.Collections.Generic.IEnumerable%601> of range partitions over the source elements.</span></span> <span data-ttu-id="d9ee0-159">接著，您可以將這個範圍集合傳遞給主體由一般 `for` 迴圈組成的 <xref:System.Threading.Tasks.Parallel.ForEach%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-159">Then, you can pass this collection of ranges to a <xref:System.Threading.Tasks.Parallel.ForEach%2A> method whose body consists of a regular `for` loop.</span></span> <span data-ttu-id="d9ee0-160">此方法的優點是，每個範圍只會產生一次委派引動過程成本，而不是每個元素產生一次。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-160">The benefit of this approach is that the delegate invocation cost is incurred only once per range, rather than once per element.</span></span> <span data-ttu-id="d9ee0-161">下列範例示範基本模式。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-161">The following example demonstrates the basic pattern.</span></span>

[!code-csharp[TPL_Partitioners#01](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_partitioners/cs/partitioner01.cs#01)]
[!code-vb[TPL_Partitioners#01](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_partitioners/vb/partitionercreate01.vb#01)]

<span data-ttu-id="d9ee0-162">迴圈中的每個執行緒都會收到自己的 <xref:System.Tuple%602>，其中包含所指定子範圍中的起始和結束索引值。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-162">Every thread in the loop receives its own <xref:System.Tuple%602> that contains the starting and ending index values in the specified sub-range.</span></span> <span data-ttu-id="d9ee0-163">內部 `for` 迴圈會使用 `fromInclusive` 和 `toExclusive` 值來循環處理整個陣列，或直接處理 <xref:System.Collections.IList>。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-163">The inner `for` loop uses the `fromInclusive` and `toExclusive` values to loop over the array or the <xref:System.Collections.IList> directly.</span></span>

<span data-ttu-id="d9ee0-164">其中一個 <xref:System.Collections.Concurrent.Partitioner.Create%2A> 多載可讓您指定資料分割的大小，以及資料分割的數量。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-164">One of the <xref:System.Collections.Concurrent.Partitioner.Create%2A> overloads lets you specify the size of the partitions, and the number of partitions.</span></span> <span data-ttu-id="d9ee0-165">如果每個元素的工作量都很低，以致於甚至每個元素一個虛擬方法呼叫都會明顯影響效能，在這類案例中，便可以使用此多載。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-165">This overload can be used in scenarios where the work per element is so low that even one virtual method call per element has a noticeable impact on performance.</span></span>

## <a name="custom-partitioners"></a><span data-ttu-id="d9ee0-166">自訂 Partitioner</span><span class="sxs-lookup"><span data-stu-id="d9ee0-166">Custom Partitioners</span></span>

<span data-ttu-id="d9ee0-167">在某些案例中，可能值得或甚至必須實作您自己的 Partitioner。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-167">In some scenarios, it might be worthwhile or even required to implement your own partitioner.</span></span> <span data-ttu-id="d9ee0-168">例如，您可能有一個自訂集合類別，而根據您對該類別內部結構的了解，可以用比預設 Partitioner 更有效率的方式來分割該類別。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-168">For example, you might have a custom collection class that you can partition more efficiently than the default partitioners can, based on your knowledge of the internal structure of the class.</span></span> <span data-ttu-id="d9ee0-169">或者，您可能想要根據處理來源集合中不同位置之元素所需的時間，建立不同大小的定界分割。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-169">Or, you may want to create range partitions of varying sizes based on your knowledge of how long it will take to process elements at different locations in the source collection.</span></span>

<span data-ttu-id="d9ee0-170">若要建立基本自訂 Partitioner，請從 <xref:System.Collections.Concurrent.Partitioner%601?displayProperty=nameWithType> 衍生類別並覆寫虛擬方法，如下表所述。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-170">To create a basic custom partitioner, derive a class from <xref:System.Collections.Concurrent.Partitioner%601?displayProperty=nameWithType> and override the virtual methods, as described in the following table.</span></span>

|||
|-|-|
|<xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>|<span data-ttu-id="d9ee0-171">此方法只會被主執行緒呼叫一次，並且會傳回 IList(IEnumerator(TSource))。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-171">This method is called once by the main thread and returns an IList(IEnumerator(TSource)).</span></span> <span data-ttu-id="d9ee0-172">迴圈或查詢中的每個背景工作執行緒都可以呼叫清單上的 `GetEnumerator`，以擷取不同資料分割上的 <xref:System.Collections.Generic.IEnumerator%601>。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-172">Each worker thread in the loop or query can call `GetEnumerator` on the list to retrieve a <xref:System.Collections.Generic.IEnumerator%601> over a distinct partition.</span></span>|
|<xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A>|<span data-ttu-id="d9ee0-173">如果您實作 <xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A>，就會傳回 `true`，否則會傳回 `false`。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-173">Return `true` if you implement <xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A>, otherwise, `false`.</span></span>|
|<xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A>|<span data-ttu-id="d9ee0-174">如果 <xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A> 為 `true`，則可視需要呼叫此方法，而不呼叫 <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-174">If <xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A> is `true`, this method can optionally be called instead of <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>.</span></span>|

<span data-ttu-id="d9ee0-175">如果結果必須是可排序的，或您需要以索引方式存取元素，則請從 <xref:System.Collections.Concurrent.OrderablePartitioner%601?displayProperty=nameWithType> 衍生並覆寫其虛擬方法，如下表所述。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-175">If the results must be sortable or you require indexed access into the elements, then derive from <xref:System.Collections.Concurrent.OrderablePartitioner%601?displayProperty=nameWithType> and override its virtual methods as described in the following table.</span></span>

|||
|-|-|
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetPartitions%2A>|<span data-ttu-id="d9ee0-176">此方法只會被主執行緒呼叫一次，並且會傳回 `IList(IEnumerator(TSource))`。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-176">This method is called once by the main thread and returns an `IList(IEnumerator(TSource))`.</span></span> <span data-ttu-id="d9ee0-177">迴圈或查詢中的每個背景工作執行緒都可以呼叫清單上的 `GetEnumerator`，以擷取不同資料分割上的 <xref:System.Collections.Generic.IEnumerator%601>。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-177">Each worker thread in the loop or query can call `GetEnumerator` on the list to retrieve a <xref:System.Collections.Generic.IEnumerator%601> over a distinct partition.</span></span>|
|<xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A>|<span data-ttu-id="d9ee0-178">如果您實作 <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetDynamicPartitions%2A>，就會傳回 `true`，否則會傳回 false。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-178">Return `true` if you implement <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetDynamicPartitions%2A>; otherwise, false.</span></span>|
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetDynamicPartitions%2A>|<span data-ttu-id="d9ee0-179">通常，這只會呼叫 <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A>。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-179">Typically, this just calls <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A>.</span></span>|
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A>|<span data-ttu-id="d9ee0-180">如果 <xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A> 為 `true`，則可視需要呼叫此方法，而不呼叫 <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-180">If <xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A> is `true`, this method can optionally be called instead of <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>.</span></span>|

<span data-ttu-id="d9ee0-181">下表提供額外的詳細資料，說明三種負載平衡 Partitioner 如何實作 <xref:System.Collections.Concurrent.OrderablePartitioner%601> 類別。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-181">The following table provides additional details about how the three kinds of load-balancing partitioners implement the <xref:System.Collections.Concurrent.OrderablePartitioner%601> class.</span></span>

|<span data-ttu-id="d9ee0-182">方法/屬性</span><span class="sxs-lookup"><span data-stu-id="d9ee0-182">Method/Property</span></span>|<span data-ttu-id="d9ee0-183">沒有負載平衡的 IList/陣列</span><span class="sxs-lookup"><span data-stu-id="d9ee0-183">IList / Array without Load Balancing</span></span>|<span data-ttu-id="d9ee0-184">有負載平衡的 IList/陣列</span><span class="sxs-lookup"><span data-stu-id="d9ee0-184">IList / Array with Load Balancing</span></span>|<span data-ttu-id="d9ee0-185">IEnumerable</span><span class="sxs-lookup"><span data-stu-id="d9ee0-185">IEnumerable</span></span>|
|----------------------|-------------------------------------------|----------------------------------------|-----------------|
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A>|<span data-ttu-id="d9ee0-186">使用定界分割</span><span class="sxs-lookup"><span data-stu-id="d9ee0-186">Uses range partitioning</span></span>|<span data-ttu-id="d9ee0-187">使用已針對所指定 partitionCount 之清單進行最佳化的區塊分割</span><span class="sxs-lookup"><span data-stu-id="d9ee0-187">Uses chunk partitioning optimized for Lists for the partitionCount specified</span></span>|<span data-ttu-id="d9ee0-188">藉由建立靜態數量的資料分割來使用區塊分割。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-188">Uses chunk partitioning by creating a static number of partitions.</span></span>|
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A?displayProperty=nameWithType>|<span data-ttu-id="d9ee0-189">擲回不支援例外狀況</span><span class="sxs-lookup"><span data-stu-id="d9ee0-189">Throws not-supported exception</span></span>|<span data-ttu-id="d9ee0-190">使用已針對清單和動態分割進行最佳化的區塊分割</span><span class="sxs-lookup"><span data-stu-id="d9ee0-190">Uses chunk partitioning optimized for Lists and dynamic partitions</span></span>|<span data-ttu-id="d9ee0-191">藉由建立動態數量的資料分割來使用區塊分割。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-191">Uses chunk partitioning by creating a dynamic number of partitions.</span></span>|
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.KeysOrderedInEachPartition%2A>|<span data-ttu-id="d9ee0-192">傳回 `true`。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-192">Returns `true`</span></span>|<span data-ttu-id="d9ee0-193">傳回 `true`。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-193">Returns `true`</span></span>|<span data-ttu-id="d9ee0-194">傳回 `true`。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-194">Returns `true`</span></span>|
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.KeysOrderedAcrossPartitions%2A>|<span data-ttu-id="d9ee0-195">傳回 `true`。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-195">Returns `true`</span></span>|<span data-ttu-id="d9ee0-196">傳回 `false`。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-196">Returns `false`</span></span>|<span data-ttu-id="d9ee0-197">傳回 `false`。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-197">Returns `false`</span></span>|
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.KeysNormalized%2A>|<span data-ttu-id="d9ee0-198">傳回 `true`。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-198">Returns `true`</span></span>|<span data-ttu-id="d9ee0-199">傳回 `true`。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-199">Returns `true`</span></span>|<span data-ttu-id="d9ee0-200">傳回 `true`。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-200">Returns `true`</span></span>|
|<xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A>|<span data-ttu-id="d9ee0-201">傳回 `false`。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-201">Returns `false`</span></span>|<span data-ttu-id="d9ee0-202">傳回 `true`。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-202">Returns `true`</span></span>|<span data-ttu-id="d9ee0-203">傳回 `true`。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-203">Returns `true`</span></span>|

### <a name="dynamic-partitions"></a><span data-ttu-id="d9ee0-204">動態分割</span><span class="sxs-lookup"><span data-stu-id="d9ee0-204">Dynamic Partitions</span></span>

<span data-ttu-id="d9ee0-205">如果您想要在 <xref:System.Threading.Tasks.Parallel.ForEach%2A> 方法中使用 Partitioner，您必須能夠傳回動態數量的資料分割。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-205">If you intend the partitioner to be used in a <xref:System.Threading.Tasks.Parallel.ForEach%2A> method, you must be able to return a dynamic number of partitions.</span></span> <span data-ttu-id="d9ee0-206">這意謂著 Partitioner 可以在迴圈執行期間，隨時視需要為新資料分割提供列舉值。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-206">This means that the partitioner can supply an enumerator for a new partition on-demand at any time during loop execution.</span></span> <span data-ttu-id="d9ee0-207">基本上，每次迴圈新增平行工作時，都會為該工作要求新的資料分割。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-207">Basically, whenever the loop adds a new parallel task, it requests a new partition for that task.</span></span> <span data-ttu-id="d9ee0-208">如果您要求資料必須可排序，則請從 <xref:System.Collections.Concurrent.OrderablePartitioner%601?displayProperty=nameWithType> 衍生，如此才能為每個資料分割中的每個項目指派唯一索引。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-208">If you require the data to be orderable, then derive from <xref:System.Collections.Concurrent.OrderablePartitioner%601?displayProperty=nameWithType> so that each item in each partition is assigned a unique index.</span></span>

<span data-ttu-id="d9ee0-209">如需詳細資訊和範例，請參閱[如何：實作動態磁碟分割](how-to-implement-dynamic-partitions.md)。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-209">For more information, and an example, see [How to: Implement Dynamic Partitions](how-to-implement-dynamic-partitions.md).</span></span>

### <a name="contract-for-partitioners"></a><span data-ttu-id="d9ee0-210">Partitioner 的合約</span><span class="sxs-lookup"><span data-stu-id="d9ee0-210">Contract for Partitioners</span></span>

<span data-ttu-id="d9ee0-211">實作自訂 Partitioner 時，請依循下列指導方針來協助確保能夠與 PLINQ 和 TPL 中的 <xref:System.Threading.Tasks.Parallel.ForEach%2A> 正確互動：</span><span class="sxs-lookup"><span data-stu-id="d9ee0-211">When you implement a custom partitioner, follow these guidelines to help ensure correct interaction with PLINQ and <xref:System.Threading.Tasks.Parallel.ForEach%2A> in the TPL:</span></span>

- <span data-ttu-id="d9ee0-212">如果使用等於或小於零的 `partitionsCount` 引數來呼叫 <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>，將會擲回 <xref:System.ArgumentOutOfRangeException>。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-212">If <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A> is called with an argument of zero or less for `partitionsCount`, throw <xref:System.ArgumentOutOfRangeException>.</span></span> <span data-ttu-id="d9ee0-213">雖然 PLINQ 和 TPL 永遠不會傳入等於 0 的 `partitionCount`，但建議您杜絕這個可能性。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-213">Although PLINQ and TPL will never pass in a `partitionCount` equal to 0, we nevertheless recommend that you guard against the possibility.</span></span>

- <span data-ttu-id="d9ee0-214"><xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A> 和 <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A> 應該一律傳回 `partitionsCount` 數量的資料分割。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-214"><xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A> and <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A> should always return `partitionsCount` number of partitions.</span></span> <span data-ttu-id="d9ee0-215">如果 Partitioner 用盡資料而無法建立符合所要求數量的資料分割，則方法應該針對剩餘的每個資料分割傳回空的列舉值。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-215">If the partitioner runs out of data and cannot create as many partitions as requested, then the method should return an empty enumerator for each of the remaining partitions.</span></span> <span data-ttu-id="d9ee0-216">否則，PLINQ 和 TPL 都會擲回 <xref:System.InvalidOperationException>。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-216">Otherwise, both PLINQ and TPL will throw an <xref:System.InvalidOperationException>.</span></span>

- <span data-ttu-id="d9ee0-217"><xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>、<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A>、<xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A> 及 <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A> 應該一律不傳回 `null` (在 Visual Basic 中為 `Nothing`)。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-217"><xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>, <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A>, <xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A>, and <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A> should never return `null` (`Nothing` in Visual Basic).</span></span> <span data-ttu-id="d9ee0-218">如果會傳回該值，PLINQ/TPL 將會擲回 <xref:System.InvalidOperationException>。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-218">If they do, PLINQ / TPL will throw an <xref:System.InvalidOperationException>.</span></span>

- <span data-ttu-id="d9ee0-219">方法如果會傳回資料分割，應該一律傳回能夠以完整且唯一方式列舉資料來源的資料分割。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-219">Methods that return partitions should always return partitions that can fully and uniquely enumerate the data source.</span></span> <span data-ttu-id="d9ee0-220">除非 Partitioner 的設計上所需，否則資料來源中不應該有任何重複項目或是略過的項目。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-220">There should be no duplication in the data source or skipped items unless specifically required by the design of the partitioner.</span></span> <span data-ttu-id="d9ee0-221">如果不允許使用此規則，則輸出順序可能會相當凌亂。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-221">If this rule is not followed, then the output order may be scrambled.</span></span>

- <span data-ttu-id="d9ee0-222">下列布林值 getter 必須一律精確地傳回下列值，如此輸出順序才不會凌亂：</span><span class="sxs-lookup"><span data-stu-id="d9ee0-222">The following Boolean getters must always accurately return the following values so that the output order is not scrambled:</span></span>

  - <span data-ttu-id="d9ee0-223">`KeysOrderedInEachPartition`：每個資料分割都會傳回具有遞增索引鍵索引的元素。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-223">`KeysOrderedInEachPartition`: Each partition returns elements with increasing key indices.</span></span>

  - <span data-ttu-id="d9ee0-224">`KeysOrderedAcrossPartitions`：在所有傳回的資料分割中，資料分割 *i* 中的索引鍵索引鍵會高於資料分割 *i*-1 中的索引鍵索引。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-224">`KeysOrderedAcrossPartitions`: For all partitions that are returned, the key indices in partition *i* are higher than the key indices in partition *i*-1.</span></span>

  - <span data-ttu-id="d9ee0-225">`KeysNormalized`：所有索引鍵索引都會從零開始，以單純方式遞增而沒有間隔。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-225">`KeysNormalized`: All key indices are monotonically increasing without gaps, starting from zero.</span></span>

- <span data-ttu-id="d9ee0-226">所有索引都必須是唯一的。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-226">All indices must be unique.</span></span> <span data-ttu-id="d9ee0-227">不可以有重複的索引。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-227">There may not be duplicate indices.</span></span> <span data-ttu-id="d9ee0-228">如果不允許使用此規則，則輸出順序可能會相當凌亂。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-228">If this rule is not followed, then the output order may be scrambled.</span></span>

- <span data-ttu-id="d9ee0-229">所有索引都不可為負值。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-229">All indices must be nonnegative.</span></span> <span data-ttu-id="d9ee0-230">如果未遵守此規則，則 PLINQ/TPL 可能會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="d9ee0-230">If this rule is not followed, then PLINQ/TPL may throw exceptions.</span></span>

## <a name="see-also"></a><span data-ttu-id="d9ee0-231">請參閱</span><span class="sxs-lookup"><span data-stu-id="d9ee0-231">See also</span></span>

- [<span data-ttu-id="d9ee0-232">平行程式設計</span><span class="sxs-lookup"><span data-stu-id="d9ee0-232">Parallel Programming</span></span>](index.md)
- [<span data-ttu-id="d9ee0-233">作法：實作動態分割</span><span class="sxs-lookup"><span data-stu-id="d9ee0-233">How to: Implement Dynamic Partitions</span></span>](how-to-implement-dynamic-partitions.md)
- [<span data-ttu-id="d9ee0-234">作法：為靜態分割實作 Partitioner</span><span class="sxs-lookup"><span data-stu-id="d9ee0-234">How to: Implement a Partitioner for Static Partitioning</span></span>](how-to-implement-a-partitioner-for-static-partitioning.md)
