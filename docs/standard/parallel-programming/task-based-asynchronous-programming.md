---
title: 工作型非同步程式設計 - .NET
description: 在本文中，透過工作平行程式庫 (TPL) 在 .NET 中瞭解以工作為基礎的非同步程式設計。
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- parallelism, task
ms.assetid: 458b5e69-5210-45e5-bc44-3888f86abd6f
ms.openlocfilehash: d735cb56c5914dd33ba694c95a8e92446ca47088
ms.sourcegitcommit: 6d09ae36acba0b0e2ba47999f8f1a725795462a2
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 10/29/2020
ms.locfileid: "92925242"
---
# <a name="task-based-asynchronous-programming"></a><span data-ttu-id="7f295-103">工作型非同步程式設計</span><span class="sxs-lookup"><span data-stu-id="7f295-103">Task-based asynchronous programming</span></span>

<span data-ttu-id="7f295-104">工作平行程式庫 (TPL) 是以「工作」  (Task) 的概念為基礎，工作表示非同步作業。</span><span class="sxs-lookup"><span data-stu-id="7f295-104">The Task Parallel Library (TPL) is based on the concept of a *task* , which represents an asynchronous operation.</span></span> <span data-ttu-id="7f295-105">在某些方面，工作類似執行緒或 <xref:System.Threading.ThreadPool> 工作項目，但是抽象等級較高。</span><span class="sxs-lookup"><span data-stu-id="7f295-105">In some ways, a task resembles a thread or <xref:System.Threading.ThreadPool> work item, but at a higher level of abstraction.</span></span> <span data-ttu-id="7f295-106">「工作平行處理原則」  (Task Parallelism) 是指同時執行一個或多個獨立工作。</span><span class="sxs-lookup"><span data-stu-id="7f295-106">The term *task parallelism* refers to one or more independent tasks running concurrently.</span></span> <span data-ttu-id="7f295-107">工作主要提供兩項優點：</span><span class="sxs-lookup"><span data-stu-id="7f295-107">Tasks provide two primary benefits:</span></span>

- <span data-ttu-id="7f295-108">更有效率且更靈活地使用系統資源。</span><span class="sxs-lookup"><span data-stu-id="7f295-108">More efficient and more scalable use of system resources.</span></span>

     <span data-ttu-id="7f295-109">在幕後，工作會排入已用演算法加強之 <xref:System.Threading.ThreadPool> 的佇列中，這些演算法會判斷和調整執行緒數目，並提供負載平衡以發揮最大輸送量。</span><span class="sxs-lookup"><span data-stu-id="7f295-109">Behind the scenes, tasks are queued to the <xref:System.Threading.ThreadPool>, which has been enhanced with algorithms  that determine and adjust to the number of threads and that provide load balancing to maximize throughput.</span></span> <span data-ttu-id="7f295-110">這樣會使得工作變得相當輕便，而且您可以建立許多工作來啟用細部的平行處理原則。</span><span class="sxs-lookup"><span data-stu-id="7f295-110">This makes tasks relatively lightweight, and you can create many of them to enable fine-grained parallelism.</span></span>

- <span data-ttu-id="7f295-111">比使用執行緒或工作項目提供更多的程式設計控制能力。</span><span class="sxs-lookup"><span data-stu-id="7f295-111">More programmatic control than is possible with a thread or work item.</span></span>

     <span data-ttu-id="7f295-112">工作和以工作為中心建置的架構提供了一組豐富的 API，可支援等候、取消、接續、穩固的例外狀況處理、詳細狀態和自訂排程等各式各樣的作業。</span><span class="sxs-lookup"><span data-stu-id="7f295-112">Tasks and the framework built around them provide a rich set of APIs that support waiting, cancellation, continuations, robust exception handling, detailed status, custom scheduling, and more.</span></span>

<span data-ttu-id="7f295-113">基於上述原因，TPL 是在 .NET 中撰寫多執行緒、非同步和平行程式碼的慣用 API。</span><span class="sxs-lookup"><span data-stu-id="7f295-113">For both of these reasons, TPL is the preferred API for writing multi-threaded, asynchronous, and parallel code in .NET.</span></span>

## <a name="creating-and-running-tasks-implicitly"></a><span data-ttu-id="7f295-114">隱含建立和執行工作</span><span class="sxs-lookup"><span data-stu-id="7f295-114">Creating and running tasks implicitly</span></span>

<span data-ttu-id="7f295-115"><xref:System.Threading.Tasks.Parallel.Invoke%2A?displayProperty=nameWithType> 方法有便利的方式可讓您同時執行任何數目的任意陳述式。</span><span class="sxs-lookup"><span data-stu-id="7f295-115">The <xref:System.Threading.Tasks.Parallel.Invoke%2A?displayProperty=nameWithType> method provides a convenient way to run any number of arbitrary statements concurrently.</span></span> <span data-ttu-id="7f295-116">只要為每個工作項目傳入 <xref:System.Action> 委派即可。</span><span class="sxs-lookup"><span data-stu-id="7f295-116">Just pass in an <xref:System.Action> delegate for each item of work.</span></span> <span data-ttu-id="7f295-117">若要建立這些委派，使用 Lambda 運算式是最簡單的方式。</span><span class="sxs-lookup"><span data-stu-id="7f295-117">The easiest way to create these delegates is to use lambda expressions.</span></span> <span data-ttu-id="7f295-118">Lambda 運算式可以呼叫具名方法，或提供程式碼內嵌。</span><span class="sxs-lookup"><span data-stu-id="7f295-118">The lambda expression can either call a named method or provide the code inline.</span></span> <span data-ttu-id="7f295-119">下列範例說明如何使用基本 <xref:System.Threading.Tasks.Parallel.Invoke%2A> 呼叫，建立並啟動兩項同時執行的工作。</span><span class="sxs-lookup"><span data-stu-id="7f295-119">The following example shows a basic <xref:System.Threading.Tasks.Parallel.Invoke%2A> call that creates and starts two tasks that run concurrently.</span></span> <span data-ttu-id="7f295-120">第一個工作是由呼叫名為 `DoSomeWork` 之方法的 Lambda 運算式表示，而第二個工作是由呼叫名為 `DoSomeOtherWork` 之方法的 Lambda 運算式表示。</span><span class="sxs-lookup"><span data-stu-id="7f295-120">The first task is represented by a lambda expression that calls a method named `DoSomeWork`, and the second task is represented by a lambda expression that calls a method named `DoSomeOtherWork`.</span></span>

> [!NOTE]
> <span data-ttu-id="7f295-121">本文件使用 Lambda 運算式來定義 TPL 中的委派。</span><span class="sxs-lookup"><span data-stu-id="7f295-121">This documentation uses lambda expressions to define delegates in TPL.</span></span> <span data-ttu-id="7f295-122">如果您不熟悉 C# 或 Visual Basic 中的 Lambda 運算式，請參閱 [PLINQ 和 TPL 中的 Lambda 運算式](lambda-expressions-in-plinq-and-tpl.md)。</span><span class="sxs-lookup"><span data-stu-id="7f295-122">If you are not familiar with lambda expressions in C# or Visual Basic, see [Lambda Expressions in PLINQ and TPL](lambda-expressions-in-plinq-and-tpl.md).</span></span>

[!code-csharp[TPL#21](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl/cs/tpl.cs#21)]
[!code-vb[TPL#21](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl/vb/tpl_vb.vb#21)]

> [!NOTE]
> <span data-ttu-id="7f295-123"><xref:System.Threading.Tasks.Task> 在幕後建立的 <xref:System.Threading.Tasks.Parallel.Invoke%2A> 執行個體數目，不一定會等於所提供的委派數目。</span><span class="sxs-lookup"><span data-stu-id="7f295-123">The number of <xref:System.Threading.Tasks.Task> instances that are created behind the scenes by <xref:System.Threading.Tasks.Parallel.Invoke%2A> is not necessarily equal to the number of delegates that are provided.</span></span> <span data-ttu-id="7f295-124">TPL 可採用各種不同的最佳化方式，尤其是有大量委派時。</span><span class="sxs-lookup"><span data-stu-id="7f295-124">The TPL may employ various optimizations, especially with large numbers of delegates.</span></span>

<span data-ttu-id="7f295-125">如需詳細資訊，請參閱[如何：使用 Parallel.Invoke 來執行平行作業](how-to-use-parallel-invoke-to-execute-parallel-operations.md)。</span><span class="sxs-lookup"><span data-stu-id="7f295-125">For more information, see [How to: Use Parallel.Invoke to Execute Parallel Operations](how-to-use-parallel-invoke-to-execute-parallel-operations.md).</span></span>

<span data-ttu-id="7f295-126">若要進一步控制工作執行，或是從工作傳回值，您必須更明確地使用 <xref:System.Threading.Tasks.Task> 物件。</span><span class="sxs-lookup"><span data-stu-id="7f295-126">For greater control over task execution or to return a value from the task, you have to work with <xref:System.Threading.Tasks.Task> objects more explicitly.</span></span>

## <a name="creating-and-running-tasks-explicitly"></a><span data-ttu-id="7f295-127">明確建立和執行工作</span><span class="sxs-lookup"><span data-stu-id="7f295-127">Creating and running tasks explicitly</span></span>

<span data-ttu-id="7f295-128">不會傳回值的工作是以 <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> 類別表示。</span><span class="sxs-lookup"><span data-stu-id="7f295-128">A task that does not return a value is represented by the <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> class.</span></span> <span data-ttu-id="7f295-129">會傳回值的工作則是以繼承自 <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> 的 <xref:System.Threading.Tasks.Task> 類別表示。</span><span class="sxs-lookup"><span data-stu-id="7f295-129">A task that returns a value is represented by the <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> class, which inherits from <xref:System.Threading.Tasks.Task>.</span></span> <span data-ttu-id="7f295-130">工作物件會處理基礎結構細節，並提供可供呼叫端執行緒在整個工作存留期存取的方法和屬性。</span><span class="sxs-lookup"><span data-stu-id="7f295-130">The task object handles the infrastructure details and provides methods and properties that are accessible from the calling thread throughout the lifetime of the task.</span></span> <span data-ttu-id="7f295-131">例如，您可以隨時存取工作的 <xref:System.Threading.Tasks.Task.Status%2A> 屬性，看看工作是否已開始執行、已執行完畢、已取消或已擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="7f295-131">For example, you can access the <xref:System.Threading.Tasks.Task.Status%2A> property of a task at any time to determine whether it has started running, ran to completion, was canceled, or has thrown an exception.</span></span> <span data-ttu-id="7f295-132">狀態是以 <xref:System.Threading.Tasks.TaskStatus> 列舉表示。</span><span class="sxs-lookup"><span data-stu-id="7f295-132">The status is represented by a <xref:System.Threading.Tasks.TaskStatus> enumeration.</span></span>

<span data-ttu-id="7f295-133">當您建立工作時，您會指定使用者委派給工作，這個使用者委派會封裝此工作會執行的程式碼。</span><span class="sxs-lookup"><span data-stu-id="7f295-133">When you create a task, you give it a user delegate that encapsulates the code that the task will execute.</span></span> <span data-ttu-id="7f295-134">委派可以以具名委派、匿名方法或 Lambda 運算式的形式呈現。</span><span class="sxs-lookup"><span data-stu-id="7f295-134">The delegate can be expressed as a named delegate, an anonymous method, or a lambda expression.</span></span> <span data-ttu-id="7f295-135">Lambda 運算式可以包含具名方法的呼叫，如下列範例所示。</span><span class="sxs-lookup"><span data-stu-id="7f295-135">Lambda expressions can contain a call to a named method, as shown in the following example.</span></span> <span data-ttu-id="7f295-136">請注意，此範例會包含對 <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> 方法的呼叫，以確保工作會在主控台模式應用程式結束前完成執行。</span><span class="sxs-lookup"><span data-stu-id="7f295-136">Note that the example includes a call to the <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> method to ensure that the task completes execution before the console mode application ends.</span></span>

[!code-csharp[TPL_TaskIntro#1](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/lambda1.cs#1)]
[!code-vb[TPL_TaskIntro#1](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/lambda1.vb#1)]

<span data-ttu-id="7f295-137">您也可以使用 <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> 方法直接以一道作業建立並啟動工作。</span><span class="sxs-lookup"><span data-stu-id="7f295-137">You can also use the <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> methods to create and start a task in one operation.</span></span> <span data-ttu-id="7f295-138">不論與目前執行緒相關聯的是哪個工作排程器，<xref:System.Threading.Tasks.Task.Run%2A> 方法都會使用預設的工作排程器來管理工作。</span><span class="sxs-lookup"><span data-stu-id="7f295-138">To manage the task, the <xref:System.Threading.Tasks.Task.Run%2A> methods use the default  task scheduler, regardless of which task scheduler is associated with the current thread.</span></span> <span data-ttu-id="7f295-139">若不需要對工作的建立和排程多加控制，則 <xref:System.Threading.Tasks.Task.Run%2A> 方法是建立和啟動工作的較好方式。</span><span class="sxs-lookup"><span data-stu-id="7f295-139">The <xref:System.Threading.Tasks.Task.Run%2A> methods are the preferred way to create and start tasks when more control over the creation and scheduling of the task is not needed.</span></span>

[!code-csharp[TPL_TaskIntro#2](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/run1.cs#2)]
[!code-vb[TPL_TaskIntro#2](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/run1.vb#2)]

<span data-ttu-id="7f295-140">您也可以使用 <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> 方法直接以一道作業建立並啟動工作。</span><span class="sxs-lookup"><span data-stu-id="7f295-140">You can also use the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> method to create and start a task in one operation.</span></span> <span data-ttu-id="7f295-141">如果建立和排程不需要分開，且您需要其他工作建立選項或使用特定排程器，或是如果需要透過其 <xref:System.Threading.Tasks.Task.AsyncState%2A?displayProperty=nameWithType> 屬性將其他狀態傳遞至您可以擷取的工作 (如下面範例所示)，請使用這個方法。</span><span class="sxs-lookup"><span data-stu-id="7f295-141">Use this method when creation and scheduling do not have to be separated and you require additional task creation options or the use of a specific scheduler, or when you need to pass additional state into the task that you can retrieve through its <xref:System.Threading.Tasks.Task.AsyncState%2A?displayProperty=nameWithType> property, as shown in the following example.</span></span>

[!code-csharp[TPL_TaskIntro#3](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/asyncstate.cs#23)]
[!code-vb[TPL_TaskIntro#3](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/asyncstate.vb#23)]

<span data-ttu-id="7f295-142"><xref:System.Threading.Tasks.Task> 和 <xref:System.Threading.Tasks.Task%601> 都會公開靜態 <xref:System.Threading.Tasks.Task.Factory%2A> 屬性，這個屬性會傳回 <xref:System.Threading.Tasks.TaskFactory> 的預設執行個體，讓您以 `Task.Factory.StartNew()` 的形式呼叫這個方法。</span><span class="sxs-lookup"><span data-stu-id="7f295-142"><xref:System.Threading.Tasks.Task> and <xref:System.Threading.Tasks.Task%601> each expose a static <xref:System.Threading.Tasks.Task.Factory%2A> property that returns a default instance of <xref:System.Threading.Tasks.TaskFactory>, so that you can call the method as `Task.Factory.StartNew()`.</span></span> <span data-ttu-id="7f295-143">另外，在下面範例中，每個工作都屬於 <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> 類型，因此它們都各自具有包含計算結果的公用 <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> 屬性。</span><span class="sxs-lookup"><span data-stu-id="7f295-143">Also, in the following example, because the tasks are of type <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType>, they each have a public <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property that contains the result of the computation.</span></span> <span data-ttu-id="7f295-144">這些工作會以非同步方式執行，且可能以任何順序完成。</span><span class="sxs-lookup"><span data-stu-id="7f295-144">The tasks run asynchronously and may complete in any order.</span></span> <span data-ttu-id="7f295-145">如果在計算完成之前就存取 <xref:System.Threading.Tasks.Task%601.Result%2A> 屬性，則這個屬性會封鎖呼叫端執行緒，直到有值為止。</span><span class="sxs-lookup"><span data-stu-id="7f295-145">If the <xref:System.Threading.Tasks.Task%601.Result%2A> property is accessed before the computation finishes, the property blocks the calling thread until the value is available.</span></span>

[!code-csharp[TPL_TaskIntro#4](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/result1.cs#4)]
[!code-vb[TPL_TaskIntro#4](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/result1.vb#4)]

<span data-ttu-id="7f295-146">如需詳細資訊，請參閱[如何：從工作傳回值](how-to-return-a-value-from-a-task.md)。</span><span class="sxs-lookup"><span data-stu-id="7f295-146">For more information, see [How to: Return a Value from a Task](how-to-return-a-value-from-a-task.md).</span></span>

<span data-ttu-id="7f295-147">當您使用 Lambda 運算式建立委派時，可以存取原始程式碼中該時間點可見的所有變數。</span><span class="sxs-lookup"><span data-stu-id="7f295-147">When you use a lambda expression to create a delegate, you have access to all the variables that are visible at that point in your source code.</span></span> <span data-ttu-id="7f295-148">不過，在某些情況下 (特別是在迴圈內)，Lambda 擷取的變數不是預期的變數。</span><span class="sxs-lookup"><span data-stu-id="7f295-148">However, in some cases, most notably within loops, a lambda doesn't capture the variable as expected.</span></span> <span data-ttu-id="7f295-149">它只會擷取最後的值，而不是在每次反覆運算後變動的值。</span><span class="sxs-lookup"><span data-stu-id="7f295-149">It only captures the final value, not the value as it mutates after each iteration.</span></span> <span data-ttu-id="7f295-150">下面範例會說明此問題。</span><span class="sxs-lookup"><span data-stu-id="7f295-150">The following example illustrates the problem.</span></span> <span data-ttu-id="7f295-151">它會將迴圈計數器傳遞給 Lambda 運算式，這個運算式會具現化 `CustomData` 物件並使用迴圈計數器做為物件的識別項。</span><span class="sxs-lookup"><span data-stu-id="7f295-151">It passes a loop counter to a lambda expression that instantiates a `CustomData` object and uses the loop counter as the object's identifier.</span></span> <span data-ttu-id="7f295-152">如範例輸出所示，每個 `CustomData` 物件都具有相同的識別項。</span><span class="sxs-lookup"><span data-stu-id="7f295-152">As the output from the example shows, each `CustomData` object has an identical identifier.</span></span>

[!code-csharp[TPL_TaskIntro#22](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/iteration1b.cs#22)]
[!code-vb[TPL_TaskIntro#22](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/iteration1b.vb#22)]

<span data-ttu-id="7f295-153">您可以透過工作的建構函式提供狀態物件給工作，以存取每個反覆項目的值。</span><span class="sxs-lookup"><span data-stu-id="7f295-153">You can access the value on each iteration by providing a state object to a task through its constructor.</span></span> <span data-ttu-id="7f295-154">下面範例是修改自先前的範例，是在建立 `CustomData` 物件 (此物件接著傳遞至 Lambda 運算式) 時使用迴圈計數器。</span><span class="sxs-lookup"><span data-stu-id="7f295-154">The following example modifies the previous example by using the loop counter when creating the `CustomData` object, which, in turn, is passed to the lambda expression.</span></span>  <span data-ttu-id="7f295-155">如範例輸出所示，每個 `CustomData` 物件現在會在物件具現化時根據迴圈計數器的值而擁有唯一識別項。</span><span class="sxs-lookup"><span data-stu-id="7f295-155">As the output from the example shows, each `CustomData` object now has a unique identifier based on the value of the loop counter at the time the object was instantiated.</span></span>

[!code-csharp[TPL_TaskIntro#21](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/iteration1a.cs#21)]
[!code-vb[TPL_TaskIntro#21](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/iteration1a.vb#21)]

<span data-ttu-id="7f295-156">這個狀態會做為引數傳遞給工作委派，且可使用 <xref:System.Threading.Tasks.Task.AsyncState%2A?displayProperty=nameWithType> 屬性從工作物件存取。</span><span class="sxs-lookup"><span data-stu-id="7f295-156">This state is passed as an argument to the task delegate, and it can be accessed from the task object by using the <xref:System.Threading.Tasks.Task.AsyncState%2A?displayProperty=nameWithType> property.</span></span>  <span data-ttu-id="7f295-157">下面範例是改變自先前的範例。</span><span class="sxs-lookup"><span data-stu-id="7f295-157">The following example is a variation on the previous example.</span></span> <span data-ttu-id="7f295-158">此範例會使用 <xref:System.Threading.Tasks.Task.AsyncState%2A> 屬性來顯示有關傳遞至 Lambda 運算式之 `CustomData` 物件的資訊。</span><span class="sxs-lookup"><span data-stu-id="7f295-158">It uses the <xref:System.Threading.Tasks.Task.AsyncState%2A> property to display information about the `CustomData` objects passed to the lambda expression.</span></span>

[!code-csharp[TPL_TaskIntro#23](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/asyncstate.cs#23)]
[!code-vb[TPL_TaskIntro#23](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/asyncstate.vb#23)]

## <a name="task-id"></a><span data-ttu-id="7f295-159">工作識別碼</span><span class="sxs-lookup"><span data-stu-id="7f295-159">Task ID</span></span>

<span data-ttu-id="7f295-160">每個工作都會得到一個整數 ID，這個 ID 負責在應用程式定義域中唯一識別該工作，且可以經由 <xref:System.Threading.Tasks.Task.Id%2A?displayProperty=nameWithType> 屬性來存取。</span><span class="sxs-lookup"><span data-stu-id="7f295-160">Every task receives an integer ID that uniquely identifies it in an application domain and can be accessed by using the <xref:System.Threading.Tasks.Task.Id%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="7f295-161">當要在 Visual Studio Debugger 的 [平行堆疊]  和 [工作]  視窗中檢閱工作資訊時，這個 ID 很有用。</span><span class="sxs-lookup"><span data-stu-id="7f295-161">The ID is useful for viewing task information in the Visual Studio debugger **Parallel Stacks** and **Tasks** windows.</span></span> <span data-ttu-id="7f295-162">ID 是採延遲建立的方式，也就是說，要等到收到要求後才會建立 ID。因此，每次執行程式時，工作都可能會有不同的 ID。</span><span class="sxs-lookup"><span data-stu-id="7f295-162">The ID is lazily created, which means that it isn't created until it is requested; therefore, a task may have a different ID every time the program is run.</span></span> <span data-ttu-id="7f295-163">如需如何在偵錯工具中檢閱工作識別碼的詳細資訊，請參閱[使用工作視窗](/visualstudio/debugger/using-the-tasks-window)和[使用平行堆疊視窗](/visualstudio/debugger/using-the-parallel-stacks-window)。</span><span class="sxs-lookup"><span data-stu-id="7f295-163">For more information about how to view task IDs in the debugger, see [Using the Tasks Window](/visualstudio/debugger/using-the-tasks-window) and [Using the Parallel Stacks Window](/visualstudio/debugger/using-the-parallel-stacks-window).</span></span>

## <a name="task-creation-options"></a><span data-ttu-id="7f295-164">工作建立選項</span><span class="sxs-lookup"><span data-stu-id="7f295-164">Task creation options</span></span>

<span data-ttu-id="7f295-165">大多數建立工作的 API 都會提供用來接受 <xref:System.Threading.Tasks.TaskCreationOptions> 參數的多載。</span><span class="sxs-lookup"><span data-stu-id="7f295-165">Most APIs that create tasks provide overloads that accept a <xref:System.Threading.Tasks.TaskCreationOptions> parameter.</span></span> <span data-ttu-id="7f295-166">藉由指定其中一或多個選項，您可以告訴工作排程器如何排程執行緒集區上的工作。</span><span class="sxs-lookup"><span data-stu-id="7f295-166">By specifying one or more of these options, you tell the task scheduler how to schedule the task on the thread pool.</span></span> <span data-ttu-id="7f295-167">選項可以使用位 **or** 運算來合併。</span><span class="sxs-lookup"><span data-stu-id="7f295-167">Options may be combined by using a bitwise **OR** operation.</span></span>

<span data-ttu-id="7f295-168">下列範例顯示具有 <xref:System.Threading.Tasks.TaskCreationOptions.LongRunning> 和選項的工作 <xref:System.Threading.Tasks.TaskContinuationOptions.PreferFairness> 。</span><span class="sxs-lookup"><span data-stu-id="7f295-168">The following example shows a task that has the <xref:System.Threading.Tasks.TaskCreationOptions.LongRunning> and <xref:System.Threading.Tasks.TaskContinuationOptions.PreferFairness> options.</span></span>

[!code-csharp[TPL_TaskIntro#03](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/taskintro.cs#03)]
[!code-vb[TPL_TaskIntro#03](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/tpl_intro.vb#03)]

## <a name="tasks-threads-and-culture"></a><span data-ttu-id="7f295-169">工作、執行緒和文化特性</span><span class="sxs-lookup"><span data-stu-id="7f295-169">Tasks, threads, and culture</span></span>

<span data-ttu-id="7f295-170">每個執行緒都有相關聯的文化特性和 UI 文化特性， <xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType> 分別由和 <xref:System.Threading.Thread.CurrentUICulture%2A?displayProperty=nameWithType> 屬性定義。</span><span class="sxs-lookup"><span data-stu-id="7f295-170">Each thread has an associated culture and UI culture, which are defined by the <xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType> and <xref:System.Threading.Thread.CurrentUICulture%2A?displayProperty=nameWithType> properties, respectively.</span></span> <span data-ttu-id="7f295-171">執行緒的文化特性會用在格式化、剖析、排序及字串比較之類的作業。</span><span class="sxs-lookup"><span data-stu-id="7f295-171">A thread's culture is used in such operations as formatting, parsing, sorting, and string comparison.</span></span> <span data-ttu-id="7f295-172">執行緒的 UI 文化特性會用於資源查閱。</span><span class="sxs-lookup"><span data-stu-id="7f295-172">A thread's UI culture is used in resource lookup.</span></span>

<span data-ttu-id="7f295-173">除非您使用和屬性為應用程式域中的所有線程指定預設文化 <xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=nameWithType> <xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=nameWithType> 特性，否則執行緒的預設文化特性和 UI 文化特性是由系統文化特性所定義。</span><span class="sxs-lookup"><span data-stu-id="7f295-173">Unless you specify a default culture for all the threads in an application domain by using the <xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=nameWithType> and <xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=nameWithType> properties, the default culture and UI culture of a thread is defined by the system culture.</span></span> <span data-ttu-id="7f295-174">如果您明確設定執行緒的文化特性，並啟動新的執行緒，新的執行緒並不會繼承呼叫執行緒的文化特性；相反地，其文化特性為預設系統文化特性。</span><span class="sxs-lookup"><span data-stu-id="7f295-174">If you explicitly set a thread's culture and launch a new thread, the new thread does not inherit the culture of the calling thread; instead, its culture is the default system culture.</span></span> <span data-ttu-id="7f295-175">不過，在以工作為基礎的程式設計中，工作會使用呼叫執行緒的文化特性，即使工作是在不同的執行緒上以非同步方式執行也一樣。</span><span class="sxs-lookup"><span data-stu-id="7f295-175">However, in task-based programming, tasks use the calling thread's culture, even if the task runs asynchronously on a different thread.</span></span>

<span data-ttu-id="7f295-176">下列範例提供一個簡單的範例。</span><span class="sxs-lookup"><span data-stu-id="7f295-176">The following example provides a simple illustration.</span></span> <span data-ttu-id="7f295-177">它會將應用程式目前的文化特性變更為法文 (法國)  (或者，如果法文 (法國) 已經是目前的文化特性，則為英文 (美國) # A7。</span><span class="sxs-lookup"><span data-stu-id="7f295-177">It changes the app's current culture to French (France) (or, if French (France) is already the current culture, to English (United States)).</span></span> <span data-ttu-id="7f295-178">然後它叫用名為 `formatDelegate` 的委派，並傳回在新的文化特性中格式化為貨幣值的一些數字。</span><span class="sxs-lookup"><span data-stu-id="7f295-178">It then invokes a delegate named `formatDelegate` that returns some numbers formatted as currency values in the new culture.</span></span> <span data-ttu-id="7f295-179">無論是以同步或非同步方式叫用委派，工作都會使用呼叫執行緒的文化特性。</span><span class="sxs-lookup"><span data-stu-id="7f295-179">Whether the delegate is invoked by a task either synchronously or asynchronously, the task uses the culture of the calling thread.</span></span>

:::code language="csharp" source="snippets/cs/asyncculture1.cs" id="1":::

:::code language="vbnet" source="snippets/vb/asyncculture1.vb" id="1":::

> [!NOTE]
> <span data-ttu-id="7f295-180">在 .NET Framework 4.6 之前的 .NET Framework 版本中，工作的文化特性是由其 *執行* 所在之執行緒的文化特性所決定，而不是 *呼叫執行緒* 的文化特性。</span><span class="sxs-lookup"><span data-stu-id="7f295-180">In versions of .NET Framework prior to .NET Framework 4.6, a task's culture is determined by the culture of the thread on which it *runs* , not the culture of the *calling thread* .</span></span> <span data-ttu-id="7f295-181">針對非同步工作，這表示工作使用的文化特性可能與呼叫執行緒的文化特性不同。</span><span class="sxs-lookup"><span data-stu-id="7f295-181">For asynchronous tasks, this means the culture used by the task could be different to the calling thread's culture.</span></span>

<span data-ttu-id="7f295-182">如需有關非同步工作和文化特性的詳細資訊，請參閱 <xref:System.Globalization.CultureInfo> 主題中的＜文化特性和以工作為基礎的非同步作業＞一節。</span><span class="sxs-lookup"><span data-stu-id="7f295-182">For more information on asynchronous tasks and culture, see the "Culture and asynchronous task-based operations" section in the <xref:System.Globalization.CultureInfo> topic.</span></span>

## <a name="creating-task-continuations"></a><span data-ttu-id="7f295-183">建立工作接續</span><span class="sxs-lookup"><span data-stu-id="7f295-183">Creating task continuations</span></span>

<span data-ttu-id="7f295-184"><xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> 和 <xref:System.Threading.Tasks.Task%601.ContinueWith%2A?displayProperty=nameWithType> 方法可讓您指定在「前項工作」(Antecedent Task)  完成時要啟動的工作。</span><span class="sxs-lookup"><span data-stu-id="7f295-184">The <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> and <xref:System.Threading.Tasks.Task%601.ContinueWith%2A?displayProperty=nameWithType> methods let you specify a task to start when the *antecedent task* finishes.</span></span> <span data-ttu-id="7f295-185">前項工作的參考會傳遞給接續工作的委派，以便檢查前項工作的狀態，並可藉由擷取 <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> 屬性的值，使用前項的輸出做為接續的輸入。</span><span class="sxs-lookup"><span data-stu-id="7f295-185">The delegate of the continuation task is passed a reference to the antecedent task so that it can examine the antecedent task's status and, by retrieving the value of the <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property, can use the output of the antecedent as input for the continuation.</span></span>

<span data-ttu-id="7f295-186">在下面範例中，`getData` 工作是透過呼叫 <xref:System.Threading.Tasks.TaskFactory.StartNew%60%601%28System.Func%7B%60%600%7D%29?displayProperty=nameWithType> 方法來啟動。</span><span class="sxs-lookup"><span data-stu-id="7f295-186">In the following example, the `getData` task is started by a call to the <xref:System.Threading.Tasks.TaskFactory.StartNew%60%601%28System.Func%7B%60%600%7D%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="7f295-187">當 `processData` 完成時，會自動啟動 `getData` 工作，而 `displayData` 完成時會啟動 `processData`。</span><span class="sxs-lookup"><span data-stu-id="7f295-187">The `processData` task is started automatically when `getData` finishes, and `displayData` is started when `processData` finishes.</span></span> <span data-ttu-id="7f295-188">`getData` 會產生整數陣列，`processData` 工作可透過 `getData` 工作的 <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> 屬性存取該陣列。</span><span class="sxs-lookup"><span data-stu-id="7f295-188">`getData` produces an integer array, which is accessible to the `processData` task through the `getData` task's <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="7f295-189">`processData` 工作會處理該陣列並傳回結果，這個結果的類型是從傳遞給 <xref:System.Threading.Tasks.Task%601.ContinueWith%60%601%28System.Func%7BSystem.Threading.Tasks.Task%7B%600%7D%2C%60%600%7D%29?displayProperty=nameWithType> 方法之 Lambda 運算式的傳回類型推斷而來。</span><span class="sxs-lookup"><span data-stu-id="7f295-189">The `processData` task processes that array and returns a result whose type is inferred from the return type of the lambda expression passed to the <xref:System.Threading.Tasks.Task%601.ContinueWith%60%601%28System.Func%7BSystem.Threading.Tasks.Task%7B%600%7D%2C%60%600%7D%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="7f295-190">當 `displayData` 完成時，`processData` 工作會自動執行，而 <xref:System.Tuple%603> Lambda 運算式傳回的 `processData` 物件可供 `displayData` 工作透過 `processData` 工作的 <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> 屬性來存取。</span><span class="sxs-lookup"><span data-stu-id="7f295-190">The `displayData` task executes automatically when `processData` finishes, and the <xref:System.Tuple%603> object returned by the `processData` lambda expression is accessible to the `displayData` task through the `processData` task's <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="7f295-191">`displayData` 工作會接受 `processData` 工作的結果並且產生結果，這個結果的類型也是以類似方式推斷而來，且這個結果會放在 <xref:System.Threading.Tasks.Task%601.Result%2A> 屬性中讓程式取得。</span><span class="sxs-lookup"><span data-stu-id="7f295-191">The `displayData` task takes the result of the `processData` task and produces a result whose type is inferred in a similar manner and which is made available to the program in the <xref:System.Threading.Tasks.Task%601.Result%2A> property.</span></span>

[!code-csharp[TPL_TaskIntro#5](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/continuations1.cs#5)]
[!code-vb[TPL_TaskIntro#5](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/continuations1.vb#5)]

<span data-ttu-id="7f295-192">由於 <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> 是執行個體方法，所以您可以將方法呼叫鏈結在一起 (而不是具現化每個前項工作的 <xref:System.Threading.Tasks.Task%601> 物件)。</span><span class="sxs-lookup"><span data-stu-id="7f295-192">Because <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> is an instance method, you can chain method calls together instead of instantiating a <xref:System.Threading.Tasks.Task%601> object for each antecedent task.</span></span> <span data-ttu-id="7f295-193">下面範例在功能上與前一個範例相同，不同之處在於會將對 <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> 方法的呼叫鏈結在一起。</span><span class="sxs-lookup"><span data-stu-id="7f295-193">The following example is functionally identical to the previous example, except that it chains together calls to the <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="7f295-194">請注意，由方法呼叫鏈結所傳回的 <xref:System.Threading.Tasks.Task%601> 物件是最後的接續工作。</span><span class="sxs-lookup"><span data-stu-id="7f295-194">Note that the <xref:System.Threading.Tasks.Task%601> object returned by the chain of method calls is the final continuation task.</span></span>

[!code-csharp[TPL_TaskIntro#24](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/continuations2.cs#24)]
[!code-vb[TPL_TaskIntro#24](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/continuations2.vb#24)]

<span data-ttu-id="7f295-195"><xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A> 和 <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A> 方法可讓您從多個工作繼續執行。</span><span class="sxs-lookup"><span data-stu-id="7f295-195">The <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A> and <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A> methods enable you to continue from multiple tasks.</span></span>

<span data-ttu-id="7f295-196">如需詳細資訊，請參閱[使用接續工作鏈結工作](chaining-tasks-by-using-continuation-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="7f295-196">For more information, see [Chaining Tasks by Using Continuation Tasks](chaining-tasks-by-using-continuation-tasks.md).</span></span>

## <a name="creating-detached-child-tasks"></a><span data-ttu-id="7f295-197">建立中斷連結的子工作</span><span class="sxs-lookup"><span data-stu-id="7f295-197">Creating detached child tasks</span></span>

<span data-ttu-id="7f295-198">當在工作內執行的使用者程式碼建立新工作，卻未指定 <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent> 選項時，新的工作不會以任何特殊方式與父工作保持同步。</span><span class="sxs-lookup"><span data-stu-id="7f295-198">When user code that is running in a task creates a new task and does not specify the <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent> option, the new task is not synchronized with the parent task in any special way.</span></span> <span data-ttu-id="7f295-199">這種非同步處理的工作稱為「中斷連結的巢狀工作」  (Detached Nested Task) 或「中斷連結的子工作」  (Detached Child Task)。</span><span class="sxs-lookup"><span data-stu-id="7f295-199">This type of non-synchronized task is called a *detached nested task* or *detached child task* .</span></span> <span data-ttu-id="7f295-200">下面範例會示範一個工作如何建立一個中斷連結的子工作。</span><span class="sxs-lookup"><span data-stu-id="7f295-200">The following example shows a task that creates one detached child task.</span></span>

[!code-csharp[TPL_TaskIntro#07](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/taskintro.cs#07)]
[!code-vb[TPL_TaskIntro#07](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/tpl_intro.vb#07)]

<span data-ttu-id="7f295-201">請注意，父工作不會等候中斷連結的子工作完成。</span><span class="sxs-lookup"><span data-stu-id="7f295-201">Note that the parent task does not wait for the detached child task to finish.</span></span>

## <a name="creating-child-tasks"></a><span data-ttu-id="7f295-202">建立子工作</span><span class="sxs-lookup"><span data-stu-id="7f295-202">Creating child tasks</span></span>

<span data-ttu-id="7f295-203">當工作中執行的使用者程式碼以選項建立工作時 <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent> ，新的工作即稱為父工作的「 *附加子* 工作」（task）。</span><span class="sxs-lookup"><span data-stu-id="7f295-203">When user code that is running in a task creates a task with the <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent> option, the new task is known as an *attached child task* of the parent task.</span></span> <span data-ttu-id="7f295-204">您可以使用 <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent> 選項來呈現結構化工作平行處理原則，因為父工作會隱含等候所有附加的子工作都完成。</span><span class="sxs-lookup"><span data-stu-id="7f295-204">You can use the <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent> option to express structured task parallelism, because the parent task implicitly waits for all attached child tasks to finish.</span></span> <span data-ttu-id="7f295-205">下面範例會示範一個父工作如何建立十個附加的子工作。</span><span class="sxs-lookup"><span data-stu-id="7f295-205">The following example shows a parent task that creates ten attached child tasks.</span></span> <span data-ttu-id="7f295-206">請注意，雖然此範例會呼叫 <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> 方法等候父工作完成，但不一定會明確等候附加的子工作完成。</span><span class="sxs-lookup"><span data-stu-id="7f295-206">Note that although the example calls the <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> method to wait for the parent task to finish, it does not have to explicitly wait for the attached child tasks to complete.</span></span>

[!code-csharp[TPL_TaskIntro#8](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/child1.cs#8)]
[!code-vb[TPL_TaskIntro#8](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/child1.vb#8)]

<span data-ttu-id="7f295-207">父工作可以使用 <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType> 選項防止其他工作附加至父工作。</span><span class="sxs-lookup"><span data-stu-id="7f295-207">A parent task can use the <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType> option to prevent other tasks from attaching to the parent task.</span></span> <span data-ttu-id="7f295-208">如需詳細資訊，請參閱[附加與中斷連結的子工作](attached-and-detached-child-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="7f295-208">For more information, see [Attached and Detached Child Tasks](attached-and-detached-child-tasks.md).</span></span>

## <a name="waiting-for-tasks-to-finish"></a><span data-ttu-id="7f295-209">等候工作完成</span><span class="sxs-lookup"><span data-stu-id="7f295-209">Waiting for tasks to finish</span></span>

<span data-ttu-id="7f295-210"><xref:System.Threading.Tasks.Task?displayProperty=nameWithType> 和 <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> 類型會提供 <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> 方法的數個多載，這些多載可讓您等候工作完成。</span><span class="sxs-lookup"><span data-stu-id="7f295-210">The <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> and <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> types provide several overloads of the <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> methods that enable you to wait for a task to finish.</span></span> <span data-ttu-id="7f295-211">此外，靜態 <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> 和 <xref:System.Threading.Tasks.Task.WaitAny%2A?displayProperty=nameWithType> 方法的多載可讓您等候工作陣列中的任一工作或所有工作完成。</span><span class="sxs-lookup"><span data-stu-id="7f295-211">In addition, overloads of the static <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> and <xref:System.Threading.Tasks.Task.WaitAny%2A?displayProperty=nameWithType> methods let you wait for any or all of an array of tasks to finish.</span></span>

<span data-ttu-id="7f295-212">您通常會因為下列其中一個原因而等候工作完成：</span><span class="sxs-lookup"><span data-stu-id="7f295-212">Typically, you would wait for a task for one of these reasons:</span></span>

- <span data-ttu-id="7f295-213">主執行緒需要有工作的最終計算結果才能完成。</span><span class="sxs-lookup"><span data-stu-id="7f295-213">The main thread depends on the final result computed by a task.</span></span>

- <span data-ttu-id="7f295-214">您必須處理可能會從工作擲回的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="7f295-214">You have to handle exceptions that might be thrown from the task.</span></span>

- <span data-ttu-id="7f295-215">應用程式可能會在所有工作都已經完成執行之前結束。</span><span class="sxs-lookup"><span data-stu-id="7f295-215">The application may terminate before all tasks have completed execution.</span></span> <span data-ttu-id="7f295-216">例如，只要 `Main` (應用程式進入點) 中的所有同步程式碼都已執行，主控台應用程式就會終止。</span><span class="sxs-lookup"><span data-stu-id="7f295-216">For example, console applications will terminate as soon as all synchronous code in `Main` (the application entry point) has executed.</span></span>

<span data-ttu-id="7f295-217">下列範例顯示不含例外狀況處理的基本模式。</span><span class="sxs-lookup"><span data-stu-id="7f295-217">The following example shows the basic pattern that does not involve exception handling.</span></span>

[!code-csharp[TPL_TaskIntro#06](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/taskintro.cs#06)]
[!code-vb[TPL_TaskIntro#06](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/tpl_intro.vb#06)]

<span data-ttu-id="7f295-218">如需示範例外狀況處理的範例，請參閱[例外狀況處理](exception-handling-task-parallel-library.md)。</span><span class="sxs-lookup"><span data-stu-id="7f295-218">For an example that shows exception handling, see [Exception Handling](exception-handling-task-parallel-library.md).</span></span>

<span data-ttu-id="7f295-219">有些多載可讓您指定逾時，有些多載則額外接受一個 <xref:System.Threading.CancellationToken> 做為輸入參數，讓等候作業本身也可以取消 (不管是透過程式設計還是做為對使用者輸入的回應)。</span><span class="sxs-lookup"><span data-stu-id="7f295-219">Some overloads let you specify a time-out, and others take an additional <xref:System.Threading.CancellationToken> as an input parameter, so that the wait itself can be canceled either programmatically or in response to user input.</span></span>

<span data-ttu-id="7f295-220">等候工作時，也會隱含等候該工作之所有使用 <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent?displayProperty=nameWithType> 選項建立的子系。</span><span class="sxs-lookup"><span data-stu-id="7f295-220">When you wait for a task, you implicitly wait for all children of that task that were created by using the <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent?displayProperty=nameWithType> option.</span></span> <span data-ttu-id="7f295-221">如果工作已完成，則 <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> 會立即傳回。</span><span class="sxs-lookup"><span data-stu-id="7f295-221"><xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> returns immediately if the task has already completed.</span></span> <span data-ttu-id="7f295-222"><xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> 方法會擲回工作所引發的任何例外狀況，即使 <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> 方法是在工作完成之後才呼叫也一樣。</span><span class="sxs-lookup"><span data-stu-id="7f295-222">Any exceptions raised by a task will be thrown by a <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> method, even if the <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> method was called after the task completed.</span></span>

## <a name="composing-tasks"></a><span data-ttu-id="7f295-223">組成工作</span><span class="sxs-lookup"><span data-stu-id="7f295-223">Composing tasks</span></span>

<span data-ttu-id="7f295-224"><xref:System.Threading.Tasks.Task> 和 <xref:System.Threading.Tasks.Task%601> 類別提供數種方法，可協助您撰寫多個工作來實作一般模式，以及更有效地使用 C#、Visual Basic 和 F# 提供的非同步語言功能。</span><span class="sxs-lookup"><span data-stu-id="7f295-224">The <xref:System.Threading.Tasks.Task> and <xref:System.Threading.Tasks.Task%601> classes provide several methods that can help you compose multiple tasks to implement common patterns and to better use the asynchronous language features that are provided by C#, Visual Basic, and F#.</span></span> <span data-ttu-id="7f295-225">本節說明 <xref:System.Threading.Tasks.Task.WhenAll%2A>、<xref:System.Threading.Tasks.Task.WhenAny%2A>、<xref:System.Threading.Tasks.Task.Delay%2A> 和 <xref:System.Threading.Tasks.Task.FromResult%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="7f295-225">This section describes the <xref:System.Threading.Tasks.Task.WhenAll%2A>, <xref:System.Threading.Tasks.Task.WhenAny%2A>, <xref:System.Threading.Tasks.Task.Delay%2A>, and <xref:System.Threading.Tasks.Task.FromResult%2A> methods.</span></span>

### <a name="taskwhenall"></a><span data-ttu-id="7f295-226">Task.WhenAll</span><span class="sxs-lookup"><span data-stu-id="7f295-226">Task.WhenAll</span></span>

<span data-ttu-id="7f295-227"><xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType> 方法會以非同步方式來等候多個 <xref:System.Threading.Tasks.Task> 或 <xref:System.Threading.Tasks.Task%601> 物件完成。</span><span class="sxs-lookup"><span data-stu-id="7f295-227">The <xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType> method asynchronously waits for multiple <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601> objects to finish.</span></span> <span data-ttu-id="7f295-228">這會提供可讓您等候多組不一致工作的多載版本。</span><span class="sxs-lookup"><span data-stu-id="7f295-228">It provides overloaded versions that enable you to wait for non-uniform sets of tasks.</span></span> <span data-ttu-id="7f295-229">例如，您可以在單一方法呼叫中等候多個 <xref:System.Threading.Tasks.Task> 和 <xref:System.Threading.Tasks.Task%601> 物件完成。</span><span class="sxs-lookup"><span data-stu-id="7f295-229">For example, you can wait for multiple <xref:System.Threading.Tasks.Task> and <xref:System.Threading.Tasks.Task%601> objects to complete from one method call.</span></span>

### <a name="taskwhenany"></a><span data-ttu-id="7f295-230">Task.WhenAny</span><span class="sxs-lookup"><span data-stu-id="7f295-230">Task.WhenAny</span></span>

<span data-ttu-id="7f295-231"><xref:System.Threading.Tasks.Task.WhenAny%2A?displayProperty=nameWithType> 方法會以非同步方式來等候多個 <xref:System.Threading.Tasks.Task> 或 <xref:System.Threading.Tasks.Task%601> 物件的其中一個完成。</span><span class="sxs-lookup"><span data-stu-id="7f295-231">The <xref:System.Threading.Tasks.Task.WhenAny%2A?displayProperty=nameWithType> method asynchronously waits for one of multiple <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601> objects to finish.</span></span> <span data-ttu-id="7f295-232">和 <xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType> 方法一樣，此方法也會提供可讓您等候多組不一致工作的多載版本。</span><span class="sxs-lookup"><span data-stu-id="7f295-232">As in the <xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType> method, this method provides overloaded versions that enable you to wait for non-uniform sets of tasks.</span></span> <span data-ttu-id="7f295-233"><xref:System.Threading.Tasks.Task.WhenAny%2A> 方法在下列情況下特別有用。</span><span class="sxs-lookup"><span data-stu-id="7f295-233">The <xref:System.Threading.Tasks.Task.WhenAny%2A> method is especially useful in the following scenarios.</span></span>

- <span data-ttu-id="7f295-234">重複的作業。</span><span class="sxs-lookup"><span data-stu-id="7f295-234">Redundant operations.</span></span> <span data-ttu-id="7f295-235">請考慮能夠以多種方式執行的演算法或作業。</span><span class="sxs-lookup"><span data-stu-id="7f295-235">Consider an algorithm or operation that can be performed in many ways.</span></span> <span data-ttu-id="7f295-236">您可以使用 <xref:System.Threading.Tasks.Task.WhenAny%2A> 方法，選擇先完成的作業，然後取消其餘作業。</span><span class="sxs-lookup"><span data-stu-id="7f295-236">You can use the <xref:System.Threading.Tasks.Task.WhenAny%2A> method to select the operation that finishes first and then cancel the remaining operations.</span></span>

- <span data-ttu-id="7f295-237">交錯作業。</span><span class="sxs-lookup"><span data-stu-id="7f295-237">Interleaved operations.</span></span> <span data-ttu-id="7f295-238">您可以啟動所有必須完成的多個作業，和使用 <xref:System.Threading.Tasks.Task.WhenAny%2A> 方法以在每個作業完成時處理結果。</span><span class="sxs-lookup"><span data-stu-id="7f295-238">You can start multiple operations that must all finish and use the <xref:System.Threading.Tasks.Task.WhenAny%2A> method to process results as each operation finishes.</span></span> <span data-ttu-id="7f295-239">完成作業後，您可以開始一個或多個其他工作。</span><span class="sxs-lookup"><span data-stu-id="7f295-239">After one operation finishes, you can start one or more additional tasks.</span></span>

- <span data-ttu-id="7f295-240">已節流的作業。</span><span class="sxs-lookup"><span data-stu-id="7f295-240">Throttled operations.</span></span> <span data-ttu-id="7f295-241">您可以使用 <xref:System.Threading.Tasks.Task.WhenAny%2A> 方法來限制並行作業的數目，以擴充前一個案例。</span><span class="sxs-lookup"><span data-stu-id="7f295-241">You can use the <xref:System.Threading.Tasks.Task.WhenAny%2A> method to extend the previous scenario by limiting the number of concurrent operations.</span></span>

- <span data-ttu-id="7f295-242">過期的作業。</span><span class="sxs-lookup"><span data-stu-id="7f295-242">Expired operations.</span></span> <span data-ttu-id="7f295-243">您可以使用 <xref:System.Threading.Tasks.Task.WhenAny%2A> 方法選取一個或多個工作，以及在指定時間之後完成的工作，例如由 <xref:System.Threading.Tasks.Task.Delay%2A> 方法傳回的工作。</span><span class="sxs-lookup"><span data-stu-id="7f295-243">You can use the <xref:System.Threading.Tasks.Task.WhenAny%2A> method to select between one or more tasks and a task that finishes after a specific time, such as a task that is returned by the <xref:System.Threading.Tasks.Task.Delay%2A> method.</span></span> <span data-ttu-id="7f295-244">下一節將說明 <xref:System.Threading.Tasks.Task.Delay%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="7f295-244">The <xref:System.Threading.Tasks.Task.Delay%2A> method is described in the following section.</span></span>

### <a name="taskdelay"></a><span data-ttu-id="7f295-245">Task.Delay</span><span class="sxs-lookup"><span data-stu-id="7f295-245">Task.Delay</span></span>

<span data-ttu-id="7f295-246"><xref:System.Threading.Tasks.Task.Delay%2A?displayProperty=nameWithType> 方法會產生 <xref:System.Threading.Tasks.Task> 物件，這個物件會在指定的時間之後完成。</span><span class="sxs-lookup"><span data-stu-id="7f295-246">The <xref:System.Threading.Tasks.Task.Delay%2A?displayProperty=nameWithType> method produces a <xref:System.Threading.Tasks.Task> object that finishes after the specified time.</span></span> <span data-ttu-id="7f295-247">您可以使用這個方法建立執行下列動作的迴圈：偶爾輪詢資料，引入逾時，延遲使用者輸入處理長達一段預先定義的時間等等。</span><span class="sxs-lookup"><span data-stu-id="7f295-247">You can use this method to build loops that occasionally poll for data, introduce time-outs, delay the handling of user input for a predetermined time, and so on.</span></span>

### <a name="tasktfromresult"></a><span data-ttu-id="7f295-248">Task(T).FromResult</span><span class="sxs-lookup"><span data-stu-id="7f295-248">Task(T).FromResult</span></span>

<span data-ttu-id="7f295-249">使用 <xref:System.Threading.Tasks.Task.FromResult%2A?displayProperty=nameWithType> 方法，您可以建立裝載預先計算結果的 <xref:System.Threading.Tasks.Task%601> 物件。</span><span class="sxs-lookup"><span data-stu-id="7f295-249">By using the <xref:System.Threading.Tasks.Task.FromResult%2A?displayProperty=nameWithType> method, you can create a <xref:System.Threading.Tasks.Task%601> object that holds a pre-computed result.</span></span> <span data-ttu-id="7f295-250">當您執行會傳回 <xref:System.Threading.Tasks.Task%601> 物件的非同步作業，而且該 <xref:System.Threading.Tasks.Task%601> 物件的結果已計算時，這個方法很有用。</span><span class="sxs-lookup"><span data-stu-id="7f295-250">This method is useful when you perform an asynchronous operation that returns a <xref:System.Threading.Tasks.Task%601> object, and the result of that <xref:System.Threading.Tasks.Task%601> object is already computed.</span></span> <span data-ttu-id="7f295-251">如需範例示範如何使用 <xref:System.Threading.Tasks.Task.FromResult%2A> 來擷取快取保留之非同步下載作業的結果，請參閱[如何：建立經過預先計算的工作](how-to-create-pre-computed-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="7f295-251">For an example that uses <xref:System.Threading.Tasks.Task.FromResult%2A> to retrieve the results of asynchronous download operations that are held in a cache, see [How to: Create Pre-Computed Tasks](how-to-create-pre-computed-tasks.md).</span></span>

## <a name="handling-exceptions-in-tasks"></a><span data-ttu-id="7f295-252">處理工作中的例外狀況</span><span class="sxs-lookup"><span data-stu-id="7f295-252">Handling exceptions in tasks</span></span>

<span data-ttu-id="7f295-253">當工作擲回一個或多個例外狀況時，這些例外狀況會包裝在 <xref:System.AggregateException> 例外狀況中。</span><span class="sxs-lookup"><span data-stu-id="7f295-253">When a task throws one or more exceptions, the exceptions are wrapped in an <xref:System.AggregateException> exception.</span></span> <span data-ttu-id="7f295-254">接著該例外狀況就會回傳給與工作聯結的執行緒，這通常會是正在等候該工作完成的執行緒，或是存取 <xref:System.Threading.Tasks.Task%601.Result%2A> 屬性的執行緒。</span><span class="sxs-lookup"><span data-stu-id="7f295-254">That exception is propagated back to the thread that joins with the task, which is typically the thread that is waiting for the task to finish or the thread that accesses the <xref:System.Threading.Tasks.Task%601.Result%2A> property.</span></span> <span data-ttu-id="7f295-255">這個行為有助於落實這樣的 .NET Framework 原則：即所有未處理的例外狀況預設都應該要終止處理序。</span><span class="sxs-lookup"><span data-stu-id="7f295-255">This behavior serves to enforce the .NET Framework policy that all unhandled exceptions by default should terminate the process.</span></span> <span data-ttu-id="7f295-256">呼叫的程式碼可以在 `try`/`catch` 區塊中使用下列任何一個來處理例外狀況：</span><span class="sxs-lookup"><span data-stu-id="7f295-256">The calling code can handle the exceptions by using any of the following in a `try`/`catch` block:</span></span>

- <span data-ttu-id="7f295-257"><xref:System.Threading.Tasks.Task.Wait%2A> 方法</span><span class="sxs-lookup"><span data-stu-id="7f295-257">The <xref:System.Threading.Tasks.Task.Wait%2A> method</span></span>

- <span data-ttu-id="7f295-258"><xref:System.Threading.Tasks.Task.WaitAll%2A> 方法</span><span class="sxs-lookup"><span data-stu-id="7f295-258">The <xref:System.Threading.Tasks.Task.WaitAll%2A> method</span></span>

- <span data-ttu-id="7f295-259"><xref:System.Threading.Tasks.Task.WaitAny%2A> 方法</span><span class="sxs-lookup"><span data-stu-id="7f295-259">The <xref:System.Threading.Tasks.Task.WaitAny%2A> method</span></span>

- <span data-ttu-id="7f295-260"><xref:System.Threading.Tasks.Task%601.Result%2A> 屬性</span><span class="sxs-lookup"><span data-stu-id="7f295-260">The <xref:System.Threading.Tasks.Task%601.Result%2A> property</span></span>

<span data-ttu-id="7f295-261">聯結的執行緒也可以藉由在工作被進行記憶體回收之前就存取 <xref:System.Threading.Tasks.Task.Exception%2A> 屬性，以處理例外狀況。</span><span class="sxs-lookup"><span data-stu-id="7f295-261">The joining thread can also handle exceptions by accessing the <xref:System.Threading.Tasks.Task.Exception%2A> property before the task is garbage-collected.</span></span> <span data-ttu-id="7f295-262">存取這個屬性，可防止未處理的例外狀況觸發當物件完成時，會終止處理序的例外狀況傳播行為。</span><span class="sxs-lookup"><span data-stu-id="7f295-262">By accessing this property, you prevent the unhandled exception from triggering the exception propagation behavior that terminates the process when the object is finalized.</span></span>

<span data-ttu-id="7f295-263">如需例外狀況和工作的詳細資訊，請參閱[例外狀況處理](exception-handling-task-parallel-library.md)。</span><span class="sxs-lookup"><span data-stu-id="7f295-263">For more information about exceptions and tasks, see [Exception Handling](exception-handling-task-parallel-library.md).</span></span>

## <a name="canceling-tasks"></a><span data-ttu-id="7f295-264">取消工作</span><span class="sxs-lookup"><span data-stu-id="7f295-264">Canceling tasks</span></span>

<span data-ttu-id="7f295-265"><xref:System.Threading.Tasks.Task> 類別支援合作式取消，且與 .NET Framework 4 中引進的 <xref:System.Threading.CancellationTokenSource?displayProperty=nameWithType> 和 <xref:System.Threading.CancellationToken?displayProperty=nameWithType> 類別完全整合。</span><span class="sxs-lookup"><span data-stu-id="7f295-265">The <xref:System.Threading.Tasks.Task> class supports cooperative cancellation and is fully integrated with the <xref:System.Threading.CancellationTokenSource?displayProperty=nameWithType> and <xref:System.Threading.CancellationToken?displayProperty=nameWithType> classes, which were introduced in the .NET Framework 4.</span></span> <span data-ttu-id="7f295-266"><xref:System.Threading.Tasks.Task?displayProperty=nameWithType> 類別中的許多建構函式都接受 <xref:System.Threading.CancellationToken> 物件做為輸入參數。</span><span class="sxs-lookup"><span data-stu-id="7f295-266">Many of the constructors in the <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> class take a <xref:System.Threading.CancellationToken> object as an input parameter.</span></span> <span data-ttu-id="7f295-267">許多 <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> 和 <xref:System.Threading.Tasks.Task.Run%2A> 多載也包含 <xref:System.Threading.CancellationToken> 參數。</span><span class="sxs-lookup"><span data-stu-id="7f295-267">Many of the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> and <xref:System.Threading.Tasks.Task.Run%2A> overloads also include a <xref:System.Threading.CancellationToken> parameter.</span></span>

<span data-ttu-id="7f295-268">您可以先建立語彙基元，之後再使用 <xref:System.Threading.CancellationTokenSource> 類別來發出取消要求。</span><span class="sxs-lookup"><span data-stu-id="7f295-268">You can create the token, and issue the cancellation request at some later time, by using the <xref:System.Threading.CancellationTokenSource> class.</span></span> <span data-ttu-id="7f295-269">請將語彙基元當做引數傳遞給 <xref:System.Threading.Tasks.Task>，並同時在您的使用者委派 (負責完成回應取消要求的動作) 中參考同一個語彙基元。</span><span class="sxs-lookup"><span data-stu-id="7f295-269">Pass the token to the <xref:System.Threading.Tasks.Task> as an argument, and also reference the same token in your user delegate, which does the work of responding to a cancellation request.</span></span>

<span data-ttu-id="7f295-270">如需詳細資訊，請參閱[工作取消](task-cancellation.md)和[如何：取消工作及其子系](how-to-cancel-a-task-and-its-children.md)。</span><span class="sxs-lookup"><span data-stu-id="7f295-270">For more information, see [Task Cancellation](task-cancellation.md) and [How to: Cancel a Task and Its Children](how-to-cancel-a-task-and-its-children.md).</span></span>

## <a name="the-taskfactory-class"></a><span data-ttu-id="7f295-271">TaskFactory 類別</span><span class="sxs-lookup"><span data-stu-id="7f295-271">The TaskFactory class</span></span>

<span data-ttu-id="7f295-272"><xref:System.Threading.Tasks.TaskFactory> 類別提供靜態方法，這些方法會封裝在建立和啟動工作及接續工作時常用的一些模式。</span><span class="sxs-lookup"><span data-stu-id="7f295-272">The <xref:System.Threading.Tasks.TaskFactory> class provides static methods that encapsulate some common patterns for creating and starting tasks and continuation tasks.</span></span>

- <span data-ttu-id="7f295-273">最常用的模式是 <xref:System.Threading.Tasks.TaskFactory.StartNew%2A>，這個模式會以一個陳述式建立並啟動工作。</span><span class="sxs-lookup"><span data-stu-id="7f295-273">The most common pattern is <xref:System.Threading.Tasks.TaskFactory.StartNew%2A>, which creates and starts a task in one statement.</span></span>

- <span data-ttu-id="7f295-274">當您從多個前項工作建立接續工作時，請使用 <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A> 方法或 <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A> 方法或 <xref:System.Threading.Tasks.Task%601> 類別中的對應項。</span><span class="sxs-lookup"><span data-stu-id="7f295-274">When you create continuation tasks from multiple antecedents, use the <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A> method or <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A> method or their equivalents in the <xref:System.Threading.Tasks.Task%601> class.</span></span> <span data-ttu-id="7f295-275">如需詳細資訊，請參閱[使用接續工作鏈結工作](chaining-tasks-by-using-continuation-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="7f295-275">For more information, see [Chaining Tasks by Using Continuation Tasks](chaining-tasks-by-using-continuation-tasks.md).</span></span>

- <span data-ttu-id="7f295-276">若要在 `BeginX` 或 `EndX` 執行個體中封裝非同步程式設計模型 <xref:System.Threading.Tasks.Task> 和 <xref:System.Threading.Tasks.Task%601> 方法，請使用 <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="7f295-276">To encapsulate Asynchronous Programming Model `BeginX` and `EndX` methods in a <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601> instance, use the <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> methods.</span></span> <span data-ttu-id="7f295-277">如需詳細資訊，請參閱 [TPL 和傳統 .NET Framework 非同步程式設計](tpl-and-traditional-async-programming.md)。</span><span class="sxs-lookup"><span data-stu-id="7f295-277">For more information, see [TPL and Traditional .NET Framework Asynchronous Programming](tpl-and-traditional-async-programming.md).</span></span>

<span data-ttu-id="7f295-278"><xref:System.Threading.Tasks.TaskFactory> 類別或 <xref:System.Threading.Tasks.Task> 類別上會以靜態屬性的形式提供預設的 <xref:System.Threading.Tasks.Task%601> 供人存取。</span><span class="sxs-lookup"><span data-stu-id="7f295-278">The default <xref:System.Threading.Tasks.TaskFactory> can be accessed as a static property on the <xref:System.Threading.Tasks.Task> class or <xref:System.Threading.Tasks.Task%601> class.</span></span> <span data-ttu-id="7f295-279">您也可以直接具現化 <xref:System.Threading.Tasks.TaskFactory> 並指定各種選項，包括 <xref:System.Threading.CancellationToken>、<xref:System.Threading.Tasks.TaskCreationOptions> 選項、<xref:System.Threading.Tasks.TaskContinuationOptions> 選項或 <xref:System.Threading.Tasks.TaskScheduler>。</span><span class="sxs-lookup"><span data-stu-id="7f295-279">You can also instantiate a <xref:System.Threading.Tasks.TaskFactory> directly and specify various options that include a <xref:System.Threading.CancellationToken>, a <xref:System.Threading.Tasks.TaskCreationOptions> option, a <xref:System.Threading.Tasks.TaskContinuationOptions> option, or a <xref:System.Threading.Tasks.TaskScheduler>.</span></span> <span data-ttu-id="7f295-280">您在建立工作 Factory 時指定的任何選項都會套用至此 Factory 建立的所有工作，除非 <xref:System.Threading.Tasks.Task> 是以 <xref:System.Threading.Tasks.TaskCreationOptions> 列舉建立，在此情況下，工作的選項會覆寫工作 Factory 的選項。</span><span class="sxs-lookup"><span data-stu-id="7f295-280">Whatever options are specified when you create the task factory will be applied to all tasks that it creates, unless the <xref:System.Threading.Tasks.Task> is created by using the <xref:System.Threading.Tasks.TaskCreationOptions> enumeration, in which case the task's options override those of the task factory.</span></span>

## <a name="tasks-without-delegates"></a><span data-ttu-id="7f295-281">不含委派的工作</span><span class="sxs-lookup"><span data-stu-id="7f295-281">Tasks without delegates</span></span>

<span data-ttu-id="7f295-282">在某些情況下，您可能需要使用 <xref:System.Threading.Tasks.Task> 來封裝由外部元件 (而非您自己的使用者委派) 所執行的一些非同步作業。</span><span class="sxs-lookup"><span data-stu-id="7f295-282">In some cases, you may want to use a <xref:System.Threading.Tasks.Task> to encapsulate some asynchronous operation that is performed by an external component instead of your own user delegate.</span></span> <span data-ttu-id="7f295-283">如果作業是根據非同步程式設計模型 Begin/End 模式，您可以使用 <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="7f295-283">If the operation is based on the Asynchronous Programming Model Begin/End pattern, you can use the <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> methods.</span></span> <span data-ttu-id="7f295-284">如果不是根據這個模式，您可以使用 <xref:System.Threading.Tasks.TaskCompletionSource%601> 物件將作業包裝在工作中，進而享有利用 <xref:System.Threading.Tasks.Task> 撰寫程式的一些優點，例如支援例外狀況傳播和接續。</span><span class="sxs-lookup"><span data-stu-id="7f295-284">If that is not the case, you can use the <xref:System.Threading.Tasks.TaskCompletionSource%601> object to wrap the operation in a task and thereby gain some of the benefits of <xref:System.Threading.Tasks.Task> programmability, for example, support for exception propagation and continuations.</span></span> <span data-ttu-id="7f295-285">如需詳細資訊，請參閱<xref:System.Threading.Tasks.TaskCompletionSource%601>。</span><span class="sxs-lookup"><span data-stu-id="7f295-285">For more information, see <xref:System.Threading.Tasks.TaskCompletionSource%601>.</span></span>

## <a name="custom-schedulers"></a><span data-ttu-id="7f295-286">自訂排程器</span><span class="sxs-lookup"><span data-stu-id="7f295-286">Custom schedulers</span></span>

<span data-ttu-id="7f295-287">大部分的應用程式或程式庫開發人員並不在意工作會在哪一個處理器上執行、工作會如何將自己的成品與其他工作同步，或是工作會如何排定在 <xref:System.Threading.ThreadPool?displayProperty=nameWithType> 上。</span><span class="sxs-lookup"><span data-stu-id="7f295-287">Most application or library developers do not care which processor the task runs on, how it synchronizes its work with other tasks, or how it is scheduled on the <xref:System.Threading.ThreadPool?displayProperty=nameWithType>.</span></span> <span data-ttu-id="7f295-288">他們只要求工作能夠在主機電腦上盡可能有效率地執行。</span><span class="sxs-lookup"><span data-stu-id="7f295-288">They only require that it execute as efficiently as possible on the host computer.</span></span> <span data-ttu-id="7f295-289">如果您需要進一步控制排程細節，工作平行程式庫可讓您設定預設工作排程器上的某些設定，甚至可讓您提供自訂的排程器。</span><span class="sxs-lookup"><span data-stu-id="7f295-289">If you require more fine-grained control over the scheduling details, the Task Parallel Library lets you configure some settings on the default task scheduler, and even lets you supply a custom scheduler.</span></span> <span data-ttu-id="7f295-290">如需詳細資訊，請參閱<xref:System.Threading.Tasks.TaskScheduler>。</span><span class="sxs-lookup"><span data-stu-id="7f295-290">For more information, see <xref:System.Threading.Tasks.TaskScheduler>.</span></span>

## <a name="related-data-structures"></a><span data-ttu-id="7f295-291">相關資料結構</span><span class="sxs-lookup"><span data-stu-id="7f295-291">Related data structures</span></span>

<span data-ttu-id="7f295-292">TPL 提供數個新的公用類型，這些類型在平行處理和序列處理情節中會很有用。</span><span class="sxs-lookup"><span data-stu-id="7f295-292">The TPL has several new public types that are useful in both parallel and sequential scenarios.</span></span> <span data-ttu-id="7f295-293">這些類型包括 <xref:System.Collections.Concurrent?displayProperty=nameWithType> 命名空間中數個具備執行緒安全、快速和可擴充的集合類別，以及數個新的同步處理類型 (例如 <xref:System.Threading.Semaphore?displayProperty=nameWithType> 和 <xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType>)，這些類型在特定類型的工作負載上表現的比它們的前身更有效率。</span><span class="sxs-lookup"><span data-stu-id="7f295-293">These include several thread-safe, fast and scalable collection classes in the <xref:System.Collections.Concurrent?displayProperty=nameWithType> namespace, and several new synchronization types, for example, <xref:System.Threading.Semaphore?displayProperty=nameWithType> and <xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType>, which are more efficient than their predecessors for specific kinds of workloads.</span></span> <span data-ttu-id="7f295-294">.NET Framework 4 中還有其他新的類型 (例如 <xref:System.Threading.Barrier?displayProperty=nameWithType> 和 <xref:System.Threading.SpinLock?displayProperty=nameWithType>) 可提供舊版所沒有的功能。</span><span class="sxs-lookup"><span data-stu-id="7f295-294">Other new types in the .NET Framework 4, for example, <xref:System.Threading.Barrier?displayProperty=nameWithType> and <xref:System.Threading.SpinLock?displayProperty=nameWithType>, provide functionality that was not available in earlier releases.</span></span> <span data-ttu-id="7f295-295">如需詳細資訊，請參閱[適用於平行程式設計的資料結構](data-structures-for-parallel-programming.md)。</span><span class="sxs-lookup"><span data-stu-id="7f295-295">For more information, see [Data Structures for Parallel Programming](data-structures-for-parallel-programming.md).</span></span>

## <a name="custom-task-types"></a><span data-ttu-id="7f295-296">自訂工作類型</span><span class="sxs-lookup"><span data-stu-id="7f295-296">Custom task types</span></span>

<span data-ttu-id="7f295-297">建議您不要繼承自 <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> 或 <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType>，</span><span class="sxs-lookup"><span data-stu-id="7f295-297">We recommend that you do not inherit from <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> or <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType>.</span></span> <span data-ttu-id="7f295-298">建議您改用 <xref:System.Threading.Tasks.Task.AsyncState%2A> 屬性，建立其他資料或狀態與 <xref:System.Threading.Tasks.Task> 或 <xref:System.Threading.Tasks.Task%601> 物件的關聯。</span><span class="sxs-lookup"><span data-stu-id="7f295-298">Instead, we recommend that you use the <xref:System.Threading.Tasks.Task.AsyncState%2A> property to associate additional data or state with a <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601> object.</span></span> <span data-ttu-id="7f295-299">您也可以使用擴充方法，擴充 <xref:System.Threading.Tasks.Task> 和 <xref:System.Threading.Tasks.Task%601> 類別的功能。</span><span class="sxs-lookup"><span data-stu-id="7f295-299">You can also use extension methods to extend the functionality of the <xref:System.Threading.Tasks.Task> and <xref:System.Threading.Tasks.Task%601> classes.</span></span> <span data-ttu-id="7f295-300">如需擴充方法的詳細資訊，請參閱[擴充方法](../../csharp/programming-guide/classes-and-structs/extension-methods.md)和[擴充方法](../../visual-basic/programming-guide/language-features/procedures/extension-methods.md)。</span><span class="sxs-lookup"><span data-stu-id="7f295-300">For more information about extension methods, see [Extension Methods](../../csharp/programming-guide/classes-and-structs/extension-methods.md) and [Extension Methods](../../visual-basic/programming-guide/language-features/procedures/extension-methods.md).</span></span>

<span data-ttu-id="7f295-301">如果您必須繼承 <xref:System.Threading.Tasks.Task> 自或 <xref:System.Threading.Tasks.Task%601> ，就不能使用 <xref:System.Threading.Tasks.Task.Run%2A> 、、 <xref:System.Threading.Tasks.TaskFactory?displayProperty=nameWithType> 或 <xref:System.Threading.Tasks.TaskFactory%601?displayProperty=nameWithType> <xref:System.Threading.Tasks.TaskCompletionSource%601?displayProperty=nameWithType> 類別來建立自訂工作類型的實例，因為這些機制只會建立 <xref:System.Threading.Tasks.Task> 和 <xref:System.Threading.Tasks.Task%601> 物件。</span><span class="sxs-lookup"><span data-stu-id="7f295-301">If you must inherit from <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601>, you cannot use <xref:System.Threading.Tasks.Task.Run%2A>, or the <xref:System.Threading.Tasks.TaskFactory?displayProperty=nameWithType>, <xref:System.Threading.Tasks.TaskFactory%601?displayProperty=nameWithType>, or <xref:System.Threading.Tasks.TaskCompletionSource%601?displayProperty=nameWithType> classes to create instances of your custom task type because these mechanisms create only <xref:System.Threading.Tasks.Task> and <xref:System.Threading.Tasks.Task%601> objects.</span></span> <span data-ttu-id="7f295-302">此外，也不可以使用 <xref:System.Threading.Tasks.Task>、<xref:System.Threading.Tasks.Task%601>、<xref:System.Threading.Tasks.TaskFactory> 和 <xref:System.Threading.Tasks.TaskFactory%601> 所提供的工作接續機制來建立自訂工作類型執行個體，因為這些機制也是只建立 <xref:System.Threading.Tasks.Task> 和 <xref:System.Threading.Tasks.Task%601> 物件。</span><span class="sxs-lookup"><span data-stu-id="7f295-302">In addition, you cannot use the task continuation mechanisms that are provided by <xref:System.Threading.Tasks.Task>, <xref:System.Threading.Tasks.Task%601>, <xref:System.Threading.Tasks.TaskFactory>, and  <xref:System.Threading.Tasks.TaskFactory%601> to create instances of your custom task type because these mechanisms also create only <xref:System.Threading.Tasks.Task> and  <xref:System.Threading.Tasks.Task%601> objects.</span></span>

## <a name="related-topics"></a><span data-ttu-id="7f295-303">相關主題</span><span class="sxs-lookup"><span data-stu-id="7f295-303">Related topics</span></span>

|<span data-ttu-id="7f295-304">標題</span><span class="sxs-lookup"><span data-stu-id="7f295-304">Title</span></span>|<span data-ttu-id="7f295-305">描述</span><span class="sxs-lookup"><span data-stu-id="7f295-305">Description</span></span>|
|-|-|
|[<span data-ttu-id="7f295-306">使用接續工作鏈結工作</span><span class="sxs-lookup"><span data-stu-id="7f295-306">Chaining Tasks by Using Continuation Tasks</span></span>](chaining-tasks-by-using-continuation-tasks.md)|<span data-ttu-id="7f295-307">說明接續的運作方式。</span><span class="sxs-lookup"><span data-stu-id="7f295-307">Describes how continuations work.</span></span>|
|[<span data-ttu-id="7f295-308">附加與中斷連結的子工作</span><span class="sxs-lookup"><span data-stu-id="7f295-308">Attached and Detached Child Tasks</span></span>](attached-and-detached-child-tasks.md)|<span data-ttu-id="7f295-309">說明附加的與中斷連結的子工作之間的差異。</span><span class="sxs-lookup"><span data-stu-id="7f295-309">Describes the difference between attached and detached child tasks.</span></span>|
|[<span data-ttu-id="7f295-310">工作取消</span><span class="sxs-lookup"><span data-stu-id="7f295-310">Task Cancellation</span></span>](task-cancellation.md)|<span data-ttu-id="7f295-311">說明 <xref:System.Threading.Tasks.Task> 物件內建的取消支援。</span><span class="sxs-lookup"><span data-stu-id="7f295-311">Describes the cancellation support that is built into the <xref:System.Threading.Tasks.Task> object.</span></span>|
|[<span data-ttu-id="7f295-312">例外狀況處理</span><span class="sxs-lookup"><span data-stu-id="7f295-312">Exception Handling</span></span>](exception-handling-task-parallel-library.md)|<span data-ttu-id="7f295-313">說明並行執行緒上發生例外狀況時的處理方式。</span><span class="sxs-lookup"><span data-stu-id="7f295-313">Describes how exceptions on concurrent threads are handled.</span></span>|
|[<span data-ttu-id="7f295-314">作法：使用 Parallel.Invoke 執行平行作業</span><span class="sxs-lookup"><span data-stu-id="7f295-314">How to: Use Parallel.Invoke to Execute Parallel Operations</span></span>](how-to-use-parallel-invoke-to-execute-parallel-operations.md)|<span data-ttu-id="7f295-315">說明如何使用 <xref:System.Threading.Tasks.Parallel.Invoke%2A>。</span><span class="sxs-lookup"><span data-stu-id="7f295-315">Describes how to use <xref:System.Threading.Tasks.Parallel.Invoke%2A>.</span></span>|
|[<span data-ttu-id="7f295-316">作法：從工作傳回值</span><span class="sxs-lookup"><span data-stu-id="7f295-316">How to: Return a Value from a Task</span></span>](how-to-return-a-value-from-a-task.md)|<span data-ttu-id="7f295-317">說明如何從工作傳回值。</span><span class="sxs-lookup"><span data-stu-id="7f295-317">Describes how to return values from tasks.</span></span>|
|[<span data-ttu-id="7f295-318">作法：取消工作及其子系</span><span class="sxs-lookup"><span data-stu-id="7f295-318">How to: Cancel a Task and Its Children</span></span>](how-to-cancel-a-task-and-its-children.md)|<span data-ttu-id="7f295-319">說明如何取消工作。</span><span class="sxs-lookup"><span data-stu-id="7f295-319">Describes how to cancel tasks.</span></span>|
|[<span data-ttu-id="7f295-320">作法：建立經過預先計算的工作</span><span class="sxs-lookup"><span data-stu-id="7f295-320">How to: Create Pre-Computed Tasks</span></span>](how-to-create-pre-computed-tasks.md)|<span data-ttu-id="7f295-321">描述如何使用 <xref:System.Threading.Tasks.Task.FromResult%2A?displayProperty=nameWithType> 方法擷取保留在快取中之非同步下載作業的結果。</span><span class="sxs-lookup"><span data-stu-id="7f295-321">Describes how to use the <xref:System.Threading.Tasks.Task.FromResult%2A?displayProperty=nameWithType> method to retrieve the results of asynchronous download operations that are held in a cache.</span></span>|
|[<span data-ttu-id="7f295-322">作法：使用平行工作周遊二進位樹狀目錄</span><span class="sxs-lookup"><span data-stu-id="7f295-322">How to: Traverse a Binary Tree with Parallel Tasks</span></span>](how-to-traverse-a-binary-tree-with-parallel-tasks.md)|<span data-ttu-id="7f295-323">說明如何使用工作，在二進位樹狀目錄中周遊。</span><span class="sxs-lookup"><span data-stu-id="7f295-323">Describes how to use tasks to traverse a binary tree.</span></span>|
|[<span data-ttu-id="7f295-324">作法：解除包裝巢狀工作</span><span class="sxs-lookup"><span data-stu-id="7f295-324">How to: Unwrap a Nested Task</span></span>](how-to-unwrap-a-nested-task.md)|<span data-ttu-id="7f295-325">示範如何使用 <xref:System.Threading.Tasks.TaskExtensions.Unwrap%2A> 擴充方法。</span><span class="sxs-lookup"><span data-stu-id="7f295-325">Demonstrates how to use the <xref:System.Threading.Tasks.TaskExtensions.Unwrap%2A> extension method.</span></span>|
|[<span data-ttu-id="7f295-326">資料平行處理</span><span class="sxs-lookup"><span data-stu-id="7f295-326">Data Parallelism</span></span>](data-parallelism-task-parallel-library.md)|<span data-ttu-id="7f295-327">說明如何使用 <xref:System.Threading.Tasks.Parallel.For%2A> 和 <xref:System.Threading.Tasks.Parallel.ForEach%2A> 建立資料的平行迴圈。</span><span class="sxs-lookup"><span data-stu-id="7f295-327">Describes how to use <xref:System.Threading.Tasks.Parallel.For%2A> and <xref:System.Threading.Tasks.Parallel.ForEach%2A> to create parallel loops over data.</span></span>|
|[<span data-ttu-id="7f295-328">平行程式設計</span><span class="sxs-lookup"><span data-stu-id="7f295-328">Parallel Programming</span></span>](index.md)|<span data-ttu-id="7f295-329">.NET Framework 平行程式設計的最上層節點。</span><span class="sxs-lookup"><span data-stu-id="7f295-329">Top level node for .NET Framework parallel programming.</span></span>|

## <a name="see-also"></a><span data-ttu-id="7f295-330">另請參閱</span><span class="sxs-lookup"><span data-stu-id="7f295-330">See also</span></span>

- [<span data-ttu-id="7f295-331">平行程式設計</span><span class="sxs-lookup"><span data-stu-id="7f295-331">Parallel Programming</span></span>](index.md)
- [<span data-ttu-id="7f295-332">使用 .NET Core & 進行平行程式設計的範例 .NET Standard</span><span class="sxs-lookup"><span data-stu-id="7f295-332">Samples for Parallel Programming with the .NET Core & .NET Standard</span></span>](/samples/browse/?products=dotnet-core%2Cdotnet-standard&term=parallel)
