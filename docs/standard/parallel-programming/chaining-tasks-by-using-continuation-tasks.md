---
title: 使用接續工作來連結工作
description: 瞭解如何在 .NET 中使用接續工作來連鎖工作。 接續工作是由另一項工作所叫用的非同步工作。
ms.date: 07/20/2020
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- tasks, continuations
ms.assetid: 0b45e9a2-de28-46ce-8212-1817280ed42d
ms.openlocfilehash: d42d244e644bf3ee1f45b25a71d60bbb2ef8e590
ms.sourcegitcommit: 7476c20d2f911a834a00b8a7f5e8926bae6804d9
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/11/2020
ms.locfileid: "88063831"
---
# <a name="chaining-tasks-using-continuation-tasks"></a><span data-ttu-id="403a9-104">使用接續工作來連結工作</span><span class="sxs-lookup"><span data-stu-id="403a9-104">Chaining tasks using continuation tasks</span></span>

<span data-ttu-id="403a9-105">在非同步程式設計中，一個非同步作業在完成時通常會叫用第二個作業。</span><span class="sxs-lookup"><span data-stu-id="403a9-105">In asynchronous programming, it's common for one asynchronous operation, on completion, to invoke a second operation.</span></span> <span data-ttu-id="403a9-106">接續可讓 decedent 作業耗用第一項操作的結果。</span><span class="sxs-lookup"><span data-stu-id="403a9-106">Continuations allow decedent operations to consume the results of the first operation.</span></span> <span data-ttu-id="403a9-107">傳統上，會使用回呼方法完成接續。</span><span class="sxs-lookup"><span data-stu-id="403a9-107">Traditionally, continuations have been done by using callback methods.</span></span> <span data-ttu-id="403a9-108">在工作平行程式庫中，由 _「接續工作」_(continuation task) 提供相同的功能。</span><span class="sxs-lookup"><span data-stu-id="403a9-108">In the Task Parallel Library, the same functionality is provided by _continuation tasks_.</span></span> <span data-ttu-id="403a9-109">接續工作 (也稱為接續) 是由另一個工作所叫用的非同步工作，也就是在上一項工作完成時，稱為「 _antecedent_」。</span><span class="sxs-lookup"><span data-stu-id="403a9-109">A continuation task (also known just as a continuation) is an asynchronous task that's invoked by another task, known as the _antecedent_, when the antecedent finishes.</span></span>

<span data-ttu-id="403a9-110">接續相對容易使用，但卻非常強大且有彈性。</span><span class="sxs-lookup"><span data-stu-id="403a9-110">Continuations are relatively easy to use, but are nevertheless powerful and flexible.</span></span> <span data-ttu-id="403a9-111">例如，您可以：</span><span class="sxs-lookup"><span data-stu-id="403a9-111">For example, you can:</span></span>

- <span data-ttu-id="403a9-112">將資料從前項傳遞至接續。</span><span class="sxs-lookup"><span data-stu-id="403a9-112">Pass data from the antecedent to the continuation.</span></span>
- <span data-ttu-id="403a9-113">指定叫用或不叫用接續的精確條件。</span><span class="sxs-lookup"><span data-stu-id="403a9-113">Specify the precise conditions under which the continuation will be invoked or not invoked.</span></span>
- <span data-ttu-id="403a9-114">在接續開始之前或是在以合作方式執行時取消接續。</span><span class="sxs-lookup"><span data-stu-id="403a9-114">Cancel a continuation either before it starts or cooperatively as it is running.</span></span>
- <span data-ttu-id="403a9-115">提供有關該如何排定接續的提示。</span><span class="sxs-lookup"><span data-stu-id="403a9-115">Provide hints about how the continuation should be scheduled.</span></span>
- <span data-ttu-id="403a9-116">從相同前項叫用多個接續。</span><span class="sxs-lookup"><span data-stu-id="403a9-116">Invoke multiple continuations from the same antecedent.</span></span>
- <span data-ttu-id="403a9-117">當所有或多個前項之任何一項完成時，請叫用一個接續。</span><span class="sxs-lookup"><span data-stu-id="403a9-117">Invoke one continuation when all or any one of multiple antecedents complete.</span></span>
- <span data-ttu-id="403a9-118">鏈結接續可一個接著一個直到任意長度。</span><span class="sxs-lookup"><span data-stu-id="403a9-118">Chain continuations one after another to any arbitrary length.</span></span>
- <span data-ttu-id="403a9-119">使用接續處理前項所擲回的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="403a9-119">Use a continuation to handle exceptions thrown by the antecedent.</span></span>

## <a name="about-continuations"></a><span data-ttu-id="403a9-120">關於接續</span><span class="sxs-lookup"><span data-stu-id="403a9-120">About continuations</span></span>

<span data-ttu-id="403a9-121">接續是在 <xref:System.Threading.Tasks.TaskStatus.WaitingForActivation> 狀態建立的工作。</span><span class="sxs-lookup"><span data-stu-id="403a9-121">A continuation is a task that is created in the <xref:System.Threading.Tasks.TaskStatus.WaitingForActivation> state.</span></span> <span data-ttu-id="403a9-122">當其前項工作完成時，它便會自動啟動。</span><span class="sxs-lookup"><span data-stu-id="403a9-122">It is activated automatically when its antecedent task or tasks complete.</span></span> <span data-ttu-id="403a9-123">在使用者程式碼中的接續呼叫 <xref:System.Threading.Tasks.Task.Start%2A?displayProperty=nameWithType> 會擲回 <xref:System.InvalidOperationException?displayProperty=nameWithType> 例外狀況。</span><span class="sxs-lookup"><span data-stu-id="403a9-123">Calling <xref:System.Threading.Tasks.Task.Start%2A?displayProperty=nameWithType> on a continuation in user code throws an <xref:System.InvalidOperationException?displayProperty=nameWithType> exception.</span></span>

<span data-ttu-id="403a9-124">接續本身是 <xref:System.Threading.Tasks.Task> ，啟動時並不會封鎖執行緒。</span><span class="sxs-lookup"><span data-stu-id="403a9-124">A continuation is itself a <xref:System.Threading.Tasks.Task> and does not block the thread on which it is started.</span></span> <span data-ttu-id="403a9-125">呼叫 <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> 方法來封鎖，直到完成接續工作。</span><span class="sxs-lookup"><span data-stu-id="403a9-125">Call the <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> method to block until the continuation task finishes.</span></span>

## <a name="create-a-continuation-for-a-single-antecedent"></a><span data-ttu-id="403a9-126">建立單一 antecedent 的接續</span><span class="sxs-lookup"><span data-stu-id="403a9-126">Create a continuation for a single antecedent</span></span>

<span data-ttu-id="403a9-127">您可建立當前項藉由呼叫 <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> 方法完成時執行的接續。</span><span class="sxs-lookup"><span data-stu-id="403a9-127">You create a continuation that executes when its antecedent has completed by calling the <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="403a9-128">下列範例顯示其基本模式 (為求清楚明瞭，省略例外狀況處理)。</span><span class="sxs-lookup"><span data-stu-id="403a9-128">The following example shows the basic pattern (for clarity, exception handling is omitted).</span></span> <span data-ttu-id="403a9-129">它會執行前項工作 `taskA`，這會傳回表示今天是星期幾之名稱的 <xref:System.DayOfWeek> 物件。</span><span class="sxs-lookup"><span data-stu-id="403a9-129">It executes an antecedent task, `taskA`, that returns a <xref:System.DayOfWeek> object that indicates the name of the current day of the week.</span></span> <span data-ttu-id="403a9-130">當前項完成時，接續工作 `continuation` 由其前項傳遞，並顯示包含結果的字串。</span><span class="sxs-lookup"><span data-stu-id="403a9-130">When the antecedent completes, the continuation task, `continuation`, is passed the antecedent and displays a string that includes its result.</span></span>

> [!NOTE]
> <span data-ttu-id="403a9-131">此發行項中的 C# 範例使用 `Main` 方法上的 `async` 修飾詞。</span><span class="sxs-lookup"><span data-stu-id="403a9-131">The C# samples in this article make use of the `async` modifier on the `Main` method.</span></span> <span data-ttu-id="403a9-132">C# 7.1 及更新版本有提供該功能。</span><span class="sxs-lookup"><span data-stu-id="403a9-132">That feature is available in C# 7.1 and later.</span></span> <span data-ttu-id="403a9-133">[`CS5001`](../../csharp/misc/cs5001.md)編譯此範例程式碼時，會產生先前的版本。</span><span class="sxs-lookup"><span data-stu-id="403a9-133">Previous versions generate [`CS5001`](../../csharp/misc/cs5001.md) when compiling this sample code.</span></span> <span data-ttu-id="403a9-134">您必須將語言版本設定為 C# 7.1 或更新版本。</span><span class="sxs-lookup"><span data-stu-id="403a9-134">You'll need to set the language version to C# 7.1 or newer.</span></span> <span data-ttu-id="403a9-135">如需了解如何設定發行項中的語言版本，請參閱[設定語言版本](../../csharp/language-reference/configure-language-version.md)。</span><span class="sxs-lookup"><span data-stu-id="403a9-135">You can learn how to configure the language version in the article on [configure language version](../../csharp/language-reference/configure-language-version.md).</span></span>

:::code language="csharp" source="snippets/cs/simple1.cs":::

[!code-vb[TPL_Continuations#1](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/simple1.vb#1)]

## <a name="create-a-continuation-for-multiple-antecedents"></a><span data-ttu-id="403a9-136">為多個前項建立接續</span><span class="sxs-lookup"><span data-stu-id="403a9-136">Create a continuation for multiple antecedents</span></span>

<span data-ttu-id="403a9-137">您也可以建立會在任何或所有群組工作完成時執行的接續。</span><span class="sxs-lookup"><span data-stu-id="403a9-137">You can also create a continuation that will run when any or all of a group of tasks has completed.</span></span> <span data-ttu-id="403a9-138">當所有前項工作都完成後，若要執行接續，您可以呼叫靜態`Shared` 方法 (在 Visual Basic 中為 <xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType> ) 或執行個體 <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="403a9-138">To execute a continuation when all antecedent tasks have completed, you call the static (`Shared` in Visual Basic) <xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType> method or the instance <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="403a9-139">當任何前項工作完成後，若要執行接續，您可以呼叫靜態`Shared` 方法 (在 Visual Basic 中為 <xref:System.Threading.Tasks.Task.WhenAny%2A?displayProperty=nameWithType> ) 或執行個體 <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="403a9-139">To execute a continuation when any of the antecedent tasks has completed, you call the static (`Shared` in Visual Basic) <xref:System.Threading.Tasks.Task.WhenAny%2A?displayProperty=nameWithType> method or the instance <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="403a9-140">和多載的呼叫 <xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType> <xref:System.Threading.Tasks.Task.WhenAny%2A?displayProperty=nameWithType> 不會封鎖呼叫執行緒。</span><span class="sxs-lookup"><span data-stu-id="403a9-140">Calls to the <xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType> and <xref:System.Threading.Tasks.Task.WhenAny%2A?displayProperty=nameWithType> overloads do not block the calling thread.</span></span> <span data-ttu-id="403a9-141">不過，您通常會呼叫除了和方法以外的所有， <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29?displayProperty=nameWithType> <xref:System.Threading.Tasks.Task.WhenAll%28System.Threading.Tasks.Task%5B%5D%29?displayProperty=nameWithType> 以取出傳回的 <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> 屬性，而這會封鎖呼叫執行緒。</span><span class="sxs-lookup"><span data-stu-id="403a9-141">However, you typically call all but the <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29?displayProperty=nameWithType> and <xref:System.Threading.Tasks.Task.WhenAll%28System.Threading.Tasks.Task%5B%5D%29?displayProperty=nameWithType> methods to retrieve the returned <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property, which does block the calling thread.</span></span>

<span data-ttu-id="403a9-142">下列範例會呼叫 <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29?displayProperty=nameWithType> 方法來建立接續工作，這會反映其 10 個前項工作的結果。</span><span class="sxs-lookup"><span data-stu-id="403a9-142">The following example calls the <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29?displayProperty=nameWithType> method to create a continuation task that reflects the results of its 10 antecedent tasks.</span></span> <span data-ttu-id="403a9-143">每個前項工作計算介於 1 到 10 之間的索引值平方。</span><span class="sxs-lookup"><span data-stu-id="403a9-143">Each antecedent task squares an index value that ranges from one to 10.</span></span> <span data-ttu-id="403a9-144">如果順利完成前項 (其 <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> 屬性是 <xref:System.Threading.Tasks.TaskStatus.RanToCompletion?displayProperty=nameWithType>)，則接續的 <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> 屬性是每個前項所傳回的 <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> 值之陣列。</span><span class="sxs-lookup"><span data-stu-id="403a9-144">If the antecedents complete successfully (their <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> property is <xref:System.Threading.Tasks.TaskStatus.RanToCompletion?displayProperty=nameWithType>), the <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property of the continuation is an array of the <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> values returned by each antecedent.</span></span> <span data-ttu-id="403a9-145">此範例會加入它們，以計算介於 1 到 10 之間所有數字的平方和。</span><span class="sxs-lookup"><span data-stu-id="403a9-145">The example adds them to compute the sum of squares for all numbers between one and 10.</span></span>

:::code language="csharp" source="snippets/cs/whenall1.cs":::

[!code-vb[TPL_Continuations#5](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/whenall1.vb#5)]

## <a name="continuation-options"></a><span data-ttu-id="403a9-146">接續選項</span><span class="sxs-lookup"><span data-stu-id="403a9-146">Continuation options</span></span>

<span data-ttu-id="403a9-147">當您建立單一工作接續時，您可以使用 <xref:System.Threading.Tasks.Task.ContinueWith%2A> 多載，這會採用 <xref:System.Threading.Tasks.TaskContinuationOptions?displayProperty=nameWithType> 列舉值，以指定啟動接續的條件。</span><span class="sxs-lookup"><span data-stu-id="403a9-147">When you create a single-task continuation, you can use a <xref:System.Threading.Tasks.Task.ContinueWith%2A> overload that takes a <xref:System.Threading.Tasks.TaskContinuationOptions?displayProperty=nameWithType> enumeration value to specify the conditions under which the continuation starts.</span></span> <span data-ttu-id="403a9-148">例如，您可以指定只有當前項已順利完成，或只有當它在發生錯誤的狀態下完成時，才執行接續。</span><span class="sxs-lookup"><span data-stu-id="403a9-148">For example, you can specify that the continuation is to run only if the antecedent completes successfully, or only if it completes in a faulted state.</span></span> <span data-ttu-id="403a9-149">當前項已準備好叫用接續時，若此條件不成立，則此接續會直接轉換成 <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> 狀態，而且無法啟動。</span><span class="sxs-lookup"><span data-stu-id="403a9-149">If the condition is not true when the antecedent is ready to invoke the continuation, the continuation transitions directly to the <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> state and subsequently cannot be started.</span></span>

<span data-ttu-id="403a9-150">一些多工接續方法，例如 <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A?displayProperty=nameWithType> 方法的多載，也包含 <xref:System.Threading.Tasks.TaskContinuationOptions?displayProperty=nameWithType> 參數。</span><span class="sxs-lookup"><span data-stu-id="403a9-150">A number of multi-task continuation methods, such as overloads of the <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A?displayProperty=nameWithType> method, also include a <xref:System.Threading.Tasks.TaskContinuationOptions?displayProperty=nameWithType> parameter.</span></span> <span data-ttu-id="403a9-151">不過，只有所有 <xref:System.Threading.Tasks.TaskContinuationOptions?displayProperty=nameWithType> 列舉類型成員的子集有效。</span><span class="sxs-lookup"><span data-stu-id="403a9-151">Only a subset of all <xref:System.Threading.Tasks.TaskContinuationOptions?displayProperty=nameWithType> enumeration members are valid, however.</span></span> <span data-ttu-id="403a9-152">您可以指定 <xref:System.Threading.Tasks.TaskContinuationOptions?displayProperty=nameWithType> 值，該值具有 <xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=nameWithType> 列舉程式中的對應項目，例如 <xref:System.Threading.Tasks.TaskContinuationOptions.AttachedToParent?displayProperty=nameWithType>、 <xref:System.Threading.Tasks.TaskContinuationOptions.LongRunning?displayProperty=nameWithType>和 <xref:System.Threading.Tasks.TaskContinuationOptions.PreferFairness?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="403a9-152">You can specify <xref:System.Threading.Tasks.TaskContinuationOptions?displayProperty=nameWithType> values that have counterparts in the <xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=nameWithType> enumeration, such as <xref:System.Threading.Tasks.TaskContinuationOptions.AttachedToParent?displayProperty=nameWithType>, <xref:System.Threading.Tasks.TaskContinuationOptions.LongRunning?displayProperty=nameWithType>, and <xref:System.Threading.Tasks.TaskContinuationOptions.PreferFairness?displayProperty=nameWithType>.</span></span> <span data-ttu-id="403a9-153">如果您指定具有多工接續的任何 `NotOn` 或 `OnlyOn` 選項，則會在執行階段擲回 <xref:System.ArgumentOutOfRangeException> 例外狀況。</span><span class="sxs-lookup"><span data-stu-id="403a9-153">If you specify any of the `NotOn` or `OnlyOn` options with a multi-task continuation, an <xref:System.ArgumentOutOfRangeException> exception will be thrown at run time.</span></span>

<span data-ttu-id="403a9-154">如需有關工作接續選項的詳細資訊，請參閱 <xref:System.Threading.Tasks.TaskContinuationOptions> 主題。</span><span class="sxs-lookup"><span data-stu-id="403a9-154">For more information on task continuation options, see the <xref:System.Threading.Tasks.TaskContinuationOptions> topic.</span></span>

## <a name="pass-data-to-a-continuation"></a><span data-ttu-id="403a9-155">將資料傳遞至接續</span><span class="sxs-lookup"><span data-stu-id="403a9-155">Pass data to a continuation</span></span>

<span data-ttu-id="403a9-156"><xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> 方法將做為引數傳遞前項的參考至接續的使用者委派。</span><span class="sxs-lookup"><span data-stu-id="403a9-156">The <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> method passes a reference to the antecedent to the user delegate of the continuation as an argument.</span></span> <span data-ttu-id="403a9-157">如果前項是 <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> 物件，且工作執行直到它已完成，則接續可以存取 <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> 工作的屬性。</span><span class="sxs-lookup"><span data-stu-id="403a9-157">If the antecedent is a <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> object, and the task ran until it was completed, then the continuation can access the <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property of the task.</span></span>

<span data-ttu-id="403a9-158"><xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> 屬性會封鎖，直到完成工作。</span><span class="sxs-lookup"><span data-stu-id="403a9-158">The <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property blocks until the task has completed.</span></span> <span data-ttu-id="403a9-159">不過，如果工作已取消，或發生錯誤，則嘗試存取 <xref:System.Threading.Tasks.Task%601.Result%2A> 屬性則會擲回 <xref:System.AggregateException> 例外狀況。</span><span class="sxs-lookup"><span data-stu-id="403a9-159">However, if the task was canceled or faulted, attempting to access the <xref:System.Threading.Tasks.Task%601.Result%2A> property throws an <xref:System.AggregateException> exception.</span></span> <span data-ttu-id="403a9-160">請使用 <xref:System.Threading.Tasks.TaskContinuationOptions.OnlyOnRanToCompletion> 選項來避免這個問題，如下列範例所示。</span><span class="sxs-lookup"><span data-stu-id="403a9-160">You can avoid this problem by using the <xref:System.Threading.Tasks.TaskContinuationOptions.OnlyOnRanToCompletion> option, as shown in the following example.</span></span>

:::code language="csharp" source="snippets/cs/result1.cs":::

[!code-vb[TPL_Continuations#2](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/result1.vb#2)]

<span data-ttu-id="403a9-161">如果您想執行接續，即使前項並未執行到順利完成，您也必須防範例外狀況。</span><span class="sxs-lookup"><span data-stu-id="403a9-161">If you want the continuation to run even if the antecedent did not run to successful completion, you must guard against the exception.</span></span> <span data-ttu-id="403a9-162">其中一個方法是測試前項的 <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> 屬性，而且只嘗試存取 <xref:System.Threading.Tasks.Task%601.Result%2A> 屬性 (若狀態不是 <xref:System.Threading.Tasks.TaskStatus.Faulted> 或 <xref:System.Threading.Tasks.TaskStatus.Canceled>)。</span><span class="sxs-lookup"><span data-stu-id="403a9-162">One approach is to test the <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> property of the antecedent, and only attempt to access the <xref:System.Threading.Tasks.Task%601.Result%2A> property if the status is not <xref:System.Threading.Tasks.TaskStatus.Faulted> or <xref:System.Threading.Tasks.TaskStatus.Canceled>.</span></span> <span data-ttu-id="403a9-163">您也可以檢查前項的 <xref:System.Threading.Tasks.Task.Exception%2A> 屬性。</span><span class="sxs-lookup"><span data-stu-id="403a9-163">You can also examine the <xref:System.Threading.Tasks.Task.Exception%2A> property of the antecedent.</span></span> <span data-ttu-id="403a9-164">如需詳細資訊，請參閱[例外狀況處理](exception-handling-task-parallel-library.md)。</span><span class="sxs-lookup"><span data-stu-id="403a9-164">For more information, see [Exception Handling](exception-handling-task-parallel-library.md).</span></span> <span data-ttu-id="403a9-165">下列範例會修改上一個範例來存取前項的 <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> 屬性 (僅在當其狀態為 <xref:System.Threading.Tasks.TaskStatus.RanToCompletion?displayProperty=nameWithType>之時)。</span><span class="sxs-lookup"><span data-stu-id="403a9-165">The following example modifies the previous example to access antecedent's <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property only if its status is <xref:System.Threading.Tasks.TaskStatus.RanToCompletion?displayProperty=nameWithType>.</span></span>

:::code language="csharp" source="snippets/cs/result2.cs":::

[!code-vb[TPL_Continuations#7](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/result2.vb#7)]

## <a name="cancel-a-continuation"></a><span data-ttu-id="403a9-166">取消接續</span><span class="sxs-lookup"><span data-stu-id="403a9-166">Cancel a continuation</span></span>

<span data-ttu-id="403a9-167">在下列情況中，接續的 <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> 屬性會被設定為 <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> ：</span><span class="sxs-lookup"><span data-stu-id="403a9-167">The <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> property of a continuation is set to <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> in the following situations:</span></span>

- <span data-ttu-id="403a9-168">它會擲回 <xref:System.OperationCanceledException> 例外狀況以回應取消要求。</span><span class="sxs-lookup"><span data-stu-id="403a9-168">It throws an <xref:System.OperationCanceledException> exception in response to a cancellation request.</span></span> <span data-ttu-id="403a9-169">如同任何工作，如果例外狀況包含傳遞給接續的相同標記，則會將它視為合作式取消的認可。</span><span class="sxs-lookup"><span data-stu-id="403a9-169">As with any task, if the exception contains the same token that was passed to the continuation, it is treated as an acknowledgment of cooperative cancellation.</span></span>
- <span data-ttu-id="403a9-170">接續傳遞 <xref:System.Threading.CancellationToken?displayProperty=nameWithType> ，其 <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> 屬性是 `true`。</span><span class="sxs-lookup"><span data-stu-id="403a9-170">The continuation is passed a <xref:System.Threading.CancellationToken?displayProperty=nameWithType> whose <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> property is `true`.</span></span> <span data-ttu-id="403a9-171">在此案例中，接續未啟動，而且會轉換為 <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> 狀態。</span><span class="sxs-lookup"><span data-stu-id="403a9-171">In this case, the continuation does not start, and it transitions to the <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> state.</span></span>
- <span data-ttu-id="403a9-172">此接續絕不會執行，因為不符合 <xref:System.Threading.Tasks.TaskContinuationOptions> 引數設定的條件。</span><span class="sxs-lookup"><span data-stu-id="403a9-172">The continuation never runs because the condition set by its <xref:System.Threading.Tasks.TaskContinuationOptions> argument was not met.</span></span> <span data-ttu-id="403a9-173">例如，如果前項進入 <xref:System.Threading.Tasks.TaskStatus.Faulted?displayProperty=nameWithType> 狀態，則不會執行其已傳遞 <xref:System.Threading.Tasks.TaskContinuationOptions.NotOnFaulted?displayProperty=nameWithType> 選項的接續，但會轉換成 <xref:System.Threading.Tasks.TaskStatus.Canceled> 狀態。</span><span class="sxs-lookup"><span data-stu-id="403a9-173">For example, if an antecedent goes into a <xref:System.Threading.Tasks.TaskStatus.Faulted?displayProperty=nameWithType> state, its continuation that was passed the <xref:System.Threading.Tasks.TaskContinuationOptions.NotOnFaulted?displayProperty=nameWithType> option will not run but will transition to the <xref:System.Threading.Tasks.TaskStatus.Canceled> state.</span></span>

<span data-ttu-id="403a9-174">如果工作及其接續代表相同的邏輯作業的兩個部分，則您可傳遞相同的取消語彙基元給這兩項工作，如下列範例所示。</span><span class="sxs-lookup"><span data-stu-id="403a9-174">If a task and its continuation represent two parts of the same logical operation, you can pass the same cancellation token to both tasks, as shown in the following example.</span></span> <span data-ttu-id="403a9-175">這包含會產生可由 33 整除的整數清單之前項，這會傳遞給接續。</span><span class="sxs-lookup"><span data-stu-id="403a9-175">It consists of an antecedent that generates a list of integers that are divisible by 33, which it passes to the continuation.</span></span> <span data-ttu-id="403a9-176">接續會輪流顯示此清單。</span><span class="sxs-lookup"><span data-stu-id="403a9-176">The continuation in turn displays the list.</span></span> <span data-ttu-id="403a9-177">前項和接續會定期暫停隨機一段時間。</span><span class="sxs-lookup"><span data-stu-id="403a9-177">Both the antecedent and the continuation pause regularly for random intervals.</span></span> <span data-ttu-id="403a9-178">此外，在 5 秒的逾時時間間隔後， <xref:System.Threading.Timer?displayProperty=nameWithType> 物件會用來執行 `Elapsed` 方法。</span><span class="sxs-lookup"><span data-stu-id="403a9-178">In addition, a <xref:System.Threading.Timer?displayProperty=nameWithType> object is used to execute the `Elapsed` method after a five-second timeout interval.</span></span> <span data-ttu-id="403a9-179">此範例會呼叫 <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> 方法，導致目前正在執行的工作去呼叫 <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="403a9-179">This example calls the <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> method, which causes the currently executing task to call the <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="403a9-180">當前項或其接續執行時，是否呼叫 <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> 方法取決於隨機產生的暫停持續期間。</span><span class="sxs-lookup"><span data-stu-id="403a9-180">Whether the <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> method is called when the antecedent or its continuation is executing depends on the duration of the randomly generated pauses.</span></span> <span data-ttu-id="403a9-181">如果取消前項，將不會啟動接續。</span><span class="sxs-lookup"><span data-stu-id="403a9-181">If the antecedent is canceled, the continuation will not start.</span></span> <span data-ttu-id="403a9-182">如果未取消前項，則語彙基元仍可用於取消接續。</span><span class="sxs-lookup"><span data-stu-id="403a9-182">If the antecedent is not canceled, the token can still be used to cancel the continuation.</span></span>

:::code language="csharp" source="snippets/cs/cancellation1.cs":::

[!code-vb[TPL_Continuations#3](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/cancellation1.vb#3)]

<span data-ttu-id="403a9-183">若在不需要提供接續的取消語彙基元之情況下取消前項，則當您建立接續時，也可藉由指定 <xref:System.Threading.Tasks.TaskContinuationOptions.NotOnCanceled?displayProperty=nameWithType> 選項來防止接續執行。</span><span class="sxs-lookup"><span data-stu-id="403a9-183">You can also prevent a continuation from executing if its antecedent is canceled without supplying the continuation a cancellation token by specifying the <xref:System.Threading.Tasks.TaskContinuationOptions.NotOnCanceled?displayProperty=nameWithType> option when you create the continuation.</span></span> <span data-ttu-id="403a9-184">以下是簡單的範例。</span><span class="sxs-lookup"><span data-stu-id="403a9-184">The following is a simple example.</span></span>

:::code language="csharp" source="snippets/cs/cancellation2.cs":::

[!code-vb[TPL_Continuations#8](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/cancellation2.vb#8)]

<span data-ttu-id="403a9-185">在接續進入 <xref:System.Threading.Tasks.TaskStatus.Canceled> 狀態之後，它可能會影響後續的接續，這取決於為了接續而指定的 <xref:System.Threading.Tasks.TaskContinuationOptions> 。</span><span class="sxs-lookup"><span data-stu-id="403a9-185">After a continuation goes into the <xref:System.Threading.Tasks.TaskStatus.Canceled> state, it may affect continuations that follow, depending on the <xref:System.Threading.Tasks.TaskContinuationOptions> that were specified for those continuations.</span></span>

<span data-ttu-id="403a9-186">已處置的接續將不會啟動。</span><span class="sxs-lookup"><span data-stu-id="403a9-186">Continuations that are disposed will not start.</span></span>

## <a name="continuations-and-child-tasks"></a><span data-ttu-id="403a9-187">接續和子工作</span><span class="sxs-lookup"><span data-stu-id="403a9-187">Continuations and child tasks</span></span>

<span data-ttu-id="403a9-188">直到接續和所有附加的子工作完成後，前項才會執行。</span><span class="sxs-lookup"><span data-stu-id="403a9-188">A continuation does not run until the antecedent and all of its attached child tasks have completed.</span></span> <span data-ttu-id="403a9-189">接續不會等候中斷連結的子工作完成。</span><span class="sxs-lookup"><span data-stu-id="403a9-189">The continuation does not wait for detached child tasks to finish.</span></span> <span data-ttu-id="403a9-190">下列兩個範例說明會附加和卸離建立接續之前項的子工作。</span><span class="sxs-lookup"><span data-stu-id="403a9-190">The following two examples illustrate child tasks that are attached to and detached from an antecedent that creates a continuation.</span></span> <span data-ttu-id="403a9-191">在下列範例中，僅在所有子工作都已完成後，才會執行接續。且每次執行此範例多次都會產生相同的輸出。</span><span class="sxs-lookup"><span data-stu-id="403a9-191">In the following example, the continuation runs only after all child tasks have completed, and running the example multiple times produces identical output each time.</span></span> <span data-ttu-id="403a9-192">因為根據預設，<xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> 方法會建立父工作，其預設工作建立選項是 <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>，所以此範例會藉由呼叫 <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> 方法來啟動前項。</span><span class="sxs-lookup"><span data-stu-id="403a9-192">The example launches the antecedent by calling the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> method, since by default the <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> method creates a parent task whose default task creation option is <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>.</span></span>

:::code language="csharp" source="snippets/cs/attached1.cs":::

[!code-vb[TPL_Continuations#9](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/attached1.vb#9)]

<span data-ttu-id="403a9-193">如果子工作從前項中斷，但只要前項已經終止，接續就會執行，不論子工作的狀態為何。</span><span class="sxs-lookup"><span data-stu-id="403a9-193">If child tasks are detached from the antecedent, however, the continuation runs as soon as the antecedent has terminated, regardless of the state of the child tasks.</span></span> <span data-ttu-id="403a9-194">因此，下列範例中的多個回合會產生變數輸出，這些會取決於工作排程器如何處理每項子工作。</span><span class="sxs-lookup"><span data-stu-id="403a9-194">As a result, multiple runs of the following example can produce variable output that depends on how the task scheduler handled each child task.</span></span>

:::code language="csharp" source="snippets/cs/detached1.cs":::

[!code-vb[TPL_Continuations#10](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/detached1.vb#10)]

<span data-ttu-id="403a9-195">前項工作的最終狀態取決於任何附加子工作的最終狀態。</span><span class="sxs-lookup"><span data-stu-id="403a9-195">The final status of the antecedent task depends on the final status of any attached child tasks.</span></span> <span data-ttu-id="403a9-196">中斷連結的子工作狀態不會影響父代。</span><span class="sxs-lookup"><span data-stu-id="403a9-196">The status of detached child tasks does not affect the parent.</span></span> <span data-ttu-id="403a9-197">如需詳細資訊，請參閱[附加與中斷連結的子工作](attached-and-detached-child-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="403a9-197">For more information, see [Attached and Detached Child Tasks](attached-and-detached-child-tasks.md).</span></span>

## <a name="associate-state-with-continuations"></a><span data-ttu-id="403a9-198">將狀態與接續關聯</span><span class="sxs-lookup"><span data-stu-id="403a9-198">Associate state with continuations</span></span>

<span data-ttu-id="403a9-199">您可以將任意的狀態與工作接續相關聯。</span><span class="sxs-lookup"><span data-stu-id="403a9-199">You can associate arbitrary state with a task continuation.</span></span> <span data-ttu-id="403a9-200"><xref:System.Threading.Tasks.Task.ContinueWith%2A> 方法提供多載的版本，每個都會擷取代表接續狀態的 <xref:System.Object> 值。</span><span class="sxs-lookup"><span data-stu-id="403a9-200">The <xref:System.Threading.Tasks.Task.ContinueWith%2A> method provides overloaded versions that each take an <xref:System.Object> value that represents the state of the continuation.</span></span> <span data-ttu-id="403a9-201">稍後您可以使用 <xref:System.Threading.Tasks.Task.AsyncState%2A?displayProperty=nameWithType> 屬性來存取這個狀態物件。</span><span class="sxs-lookup"><span data-stu-id="403a9-201">You can later access this state object by using the <xref:System.Threading.Tasks.Task.AsyncState%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="403a9-202">如果您未提供值，則此狀態物件為 `null` 。</span><span class="sxs-lookup"><span data-stu-id="403a9-202">This state object is `null` if you do not provide a value.</span></span>

<span data-ttu-id="403a9-203">當您為使用 TPL 而轉換現有之使用 [非同步程式設計模型 (APM)](../asynchronous-programming-patterns/asynchronous-programming-model-apm.md) 的程式碼時，接續狀態會很有用。</span><span class="sxs-lookup"><span data-stu-id="403a9-203">Continuation state is useful when you convert existing code that uses the [Asynchronous Programming Model (APM)](../asynchronous-programming-patterns/asynchronous-programming-model-apm.md) to use the TPL.</span></span> <span data-ttu-id="403a9-204">在 APM 中，您通常會在 **Begin**_Method_ 方法中提供物件狀態，並在稍後使用 <xref:System.IAsyncResult.AsyncState%2A?displayProperty=nameWithType> 屬性存取該狀態。</span><span class="sxs-lookup"><span data-stu-id="403a9-204">In the APM, you typically provide object state in the **Begin**_Method_ method and later access that state by using the <xref:System.IAsyncResult.AsyncState%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="403a9-205">藉由使用 <xref:System.Threading.Tasks.Task.ContinueWith%2A> 方法，當您轉換使用 APM 的程式碼為使用 TPL 時，您可以保留此狀態。</span><span class="sxs-lookup"><span data-stu-id="403a9-205">By using the <xref:System.Threading.Tasks.Task.ContinueWith%2A> method, you can preserve this state when you convert code that uses the APM to use the TPL.</span></span>

<span data-ttu-id="403a9-206">當您使用 Visual Studio 偵錯工具中的 <xref:System.Threading.Tasks.Task> 物件時，接續狀態也相當有用。</span><span class="sxs-lookup"><span data-stu-id="403a9-206">Continuation state can also be useful when you work with <xref:System.Threading.Tasks.Task> objects in the Visual Studio debugger.</span></span> <span data-ttu-id="403a9-207">例如，在 [平行工作] \*\*\*\* 視窗中，[工作] \*\*\*\* 資料行會顯示每項工作的狀態物件之字串表示。</span><span class="sxs-lookup"><span data-stu-id="403a9-207">For example, in the **Parallel Tasks** window, the **Task** column displays the string representation of the state object for each task.</span></span> <span data-ttu-id="403a9-208">如需 [平行工作]\*\*\*\* 視窗的詳細資訊，請參閱[使用工作視窗](/visualstudio/debugger/using-the-tasks-window)。</span><span class="sxs-lookup"><span data-stu-id="403a9-208">For more information about the **Parallel Tasks** window, see [Using the Tasks Window](/visualstudio/debugger/using-the-tasks-window).</span></span>

<span data-ttu-id="403a9-209">下列範例示範如何使用接續狀態。</span><span class="sxs-lookup"><span data-stu-id="403a9-209">The following example shows how to use continuation state.</span></span> <span data-ttu-id="403a9-210">它會建立接續工作的鏈結。</span><span class="sxs-lookup"><span data-stu-id="403a9-210">It creates a chain of continuation tasks.</span></span> <span data-ttu-id="403a9-211">每個工作會為 <xref:System.DateTime> 方法的 `state` 參數提供目前的時間，此為 <xref:System.Threading.Tasks.Task.ContinueWith%2A> 物件。</span><span class="sxs-lookup"><span data-stu-id="403a9-211">Each task provides the current time, a <xref:System.DateTime> object, for the `state` parameter of the <xref:System.Threading.Tasks.Task.ContinueWith%2A> method.</span></span> <span data-ttu-id="403a9-212">每個 <xref:System.DateTime> 物件代表建立接續工作時的時間。</span><span class="sxs-lookup"><span data-stu-id="403a9-212">Each <xref:System.DateTime> object represents the time at which the continuation task is created.</span></span> <span data-ttu-id="403a9-213">做為其結果，每一項工作會產生第二個 <xref:System.DateTime> 物件，表示工作完成時的時間。</span><span class="sxs-lookup"><span data-stu-id="403a9-213">Each task produces as its result a second <xref:System.DateTime> object that represents the time at which the task finishes.</span></span> <span data-ttu-id="403a9-214">所有工作都完成之後，此範例會顯示建立時間，以及顯示每個接續工作完成的時間。</span><span class="sxs-lookup"><span data-stu-id="403a9-214">After all tasks finish, this example displays the creation time and the time at which each continuation task finishes.</span></span>

:::code language="csharp" source="snippets/cs/continuationstate.cs":::

[!code-vb[TPL_ContinuationState#1](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuationstate/vb/continuationstate.vb#1)]

## <a name="continuations-that-return-task-types"></a><span data-ttu-id="403a9-215">傳回工作類型的接續</span><span class="sxs-lookup"><span data-stu-id="403a9-215">Continuations that return Task types</span></span>

<span data-ttu-id="403a9-216">有時候，您可能需要連結傳回類型的接續 <xref:System.Threading.Tasks.Task> 。</span><span class="sxs-lookup"><span data-stu-id="403a9-216">Sometimes you may need to chain a continuation that returns a <xref:System.Threading.Tasks.Task> type.</span></span> <span data-ttu-id="403a9-217">這些稱為「嵌套工作」，它們是常見的。</span><span class="sxs-lookup"><span data-stu-id="403a9-217">These are referred to as nested tasks, and they are common.</span></span> <span data-ttu-id="403a9-218">當父工作呼叫 <xref:System.Threading.Tasks.Task%601.ContinueWith%2A?displayProperty=nameWithType> ，並提供工作 `continuationFunction` 時，您會呼叫 <xref:System.Threading.Tasks.TaskExtensions.Unwrap%2A> 來建立 proxy 工作，以代表 `<Task<Task<T>>>` 或 `Task(Of Task(Of T))` (Visual Basic) 的非同步作業。</span><span class="sxs-lookup"><span data-stu-id="403a9-218">When a parent task calls <xref:System.Threading.Tasks.Task%601.ContinueWith%2A?displayProperty=nameWithType>, and provides a `continuationFunction` that is task returning you call <xref:System.Threading.Tasks.TaskExtensions.Unwrap%2A> to create a proxy task that represents the asynchronous operation of the `<Task<Task<T>>>` or `Task(Of Task(Of T))` (Visual Basic).</span></span>

<span data-ttu-id="403a9-219">下列範例示範如何使用接續，以包裝額外的工作傳回函式。</span><span class="sxs-lookup"><span data-stu-id="403a9-219">The following example shows how to use continuations that wrap additional task returning functions.</span></span> <span data-ttu-id="403a9-220">每個接續都可以解除包裝，並公開已包裝的內部工作。</span><span class="sxs-lookup"><span data-stu-id="403a9-220">Each continuation can be unwrapped, exposing the inner task that was wrapped.</span></span>

:::code language="csharp" source="snippets/cs/unwrap.cs":::
:::code language="vb" source="snippets/vb/unwrap.vb":::

<span data-ttu-id="403a9-221">如需使用的詳細資訊 <xref:System.Threading.Tasks.TaskExtensions.Unwrap%2A> ，請參閱[如何：解除包裝嵌套的工作](how-to-unwrap-a-nested-task.md)。</span><span class="sxs-lookup"><span data-stu-id="403a9-221">For more information on using <xref:System.Threading.Tasks.TaskExtensions.Unwrap%2A>, see [How to: Unwrap a nested Task](how-to-unwrap-a-nested-task.md).</span></span>

## <a name="handle-exceptions-thrown-from-continuations"></a><span data-ttu-id="403a9-222">處理從接續擲回的例外狀況</span><span class="sxs-lookup"><span data-stu-id="403a9-222">Handle exceptions thrown from continuations</span></span>

<span data-ttu-id="403a9-223">前項與接續的關聯性並非父子式關聯性。</span><span class="sxs-lookup"><span data-stu-id="403a9-223">An antecedent-continuation relationship is not a parent-child relationship.</span></span> <span data-ttu-id="403a9-224">接續擲回的例外狀況並不會傳播至前項。</span><span class="sxs-lookup"><span data-stu-id="403a9-224">Exceptions thrown by continuations are not propagated to the antecedent.</span></span> <span data-ttu-id="403a9-225">因此，就如同您在其他工作中一樣地處理接續所擲回的例外狀況，如下所示：</span><span class="sxs-lookup"><span data-stu-id="403a9-225">Therefore, handle exceptions thrown by continuations as you would handle them in any other task, as follows:</span></span>

- <span data-ttu-id="403a9-226">您可以使用 <xref:System.Threading.Tasks.Task.Wait%2A>、 <xref:System.Threading.Tasks.Task.WaitAll%2A>或 <xref:System.Threading.Tasks.Task.WaitAny%2A> 方法或是其泛型對應項目，用來等待接續。</span><span class="sxs-lookup"><span data-stu-id="403a9-226">You can use the <xref:System.Threading.Tasks.Task.Wait%2A>, <xref:System.Threading.Tasks.Task.WaitAll%2A>, or <xref:System.Threading.Tasks.Task.WaitAny%2A> method, or its generic counterpart, to wait on the continuation.</span></span> <span data-ttu-id="403a9-227">您可以在相同的 `try` 陳述式中等待前項和其接續，如下列範例所示。</span><span class="sxs-lookup"><span data-stu-id="403a9-227">You can wait for an antecedent and its continuations in the same `try` statement, as shown in the following example.</span></span>

:::code language="csharp" source="snippets/cs/exception1.cs":::

[!code-vb[TPL_Continuations#6](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/exception1.vb#6)]

- <span data-ttu-id="403a9-228">您可以使用第二個接續來觀察第一個接續的 <xref:System.Threading.Tasks.Task.Exception%2A> 屬性。</span><span class="sxs-lookup"><span data-stu-id="403a9-228">You can use a second continuation to observe the <xref:System.Threading.Tasks.Task.Exception%2A> property of the first continuation.</span></span> <span data-ttu-id="403a9-229">在下列範例中，工作會嘗試讀取不存在的檔案。</span><span class="sxs-lookup"><span data-stu-id="403a9-229">In the following example, a task attempts to read from a non-existent file.</span></span> <span data-ttu-id="403a9-230">然後接續會顯示有關前項工作中例外狀況的資訊。</span><span class="sxs-lookup"><span data-stu-id="403a9-230">The continuation then displays information about the exception in the antecedent task.</span></span>

:::code language="csharp" source="snippets/cs/exception2.cs" id="example":::

[!code-vb[TPL_Continuations#4](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/exception2.vb#4)]

<span data-ttu-id="403a9-231">因為它以 <xref:System.Threading.Tasks.TaskContinuationOptions.OnlyOnFaulted?displayProperty=nameWithType> 選項執行，所以僅當前項中發生例外狀況時，接續才會執行，也因此它可能會假設前項的 <xref:System.Threading.Tasks.Task.Exception%2A> 屬性不是 `null`。</span><span class="sxs-lookup"><span data-stu-id="403a9-231">Because it was run with the <xref:System.Threading.Tasks.TaskContinuationOptions.OnlyOnFaulted?displayProperty=nameWithType> option, the continuation executes only if an exception occurs in the antecedent, and therefore it can assume that the antecedent's <xref:System.Threading.Tasks.Task.Exception%2A> property is not `null`.</span></span> <span data-ttu-id="403a9-232">如果不論前項中是否擲回例外狀況都執行接續，則可能會檢查是否前項的 <xref:System.Threading.Tasks.Task.Exception%2A> 屬性不是 `null` ，之後才嘗試處理例外狀況，如下列程式碼片段所示。</span><span class="sxs-lookup"><span data-stu-id="403a9-232">If the continuation executes whether or not an exception is thrown in the antecedent, it would have to check whether the antecedent's <xref:System.Threading.Tasks.Task.Exception%2A> property is not `null` before attempting to handle the exception, as the following code fragment shows.</span></span>

:::code language="csharp" source="snippets/cs/exception2.cs" id="exception":::

[!code-vb[TPL_Continuations#11](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/exception2.vb#11)]

<span data-ttu-id="403a9-233">如需詳細資訊，請參閱[例外狀況處理](exception-handling-task-parallel-library.md)。</span><span class="sxs-lookup"><span data-stu-id="403a9-233">For more information, see [Exception Handling](exception-handling-task-parallel-library.md).</span></span>

- <span data-ttu-id="403a9-234">如果接續是使用 <xref:System.Threading.Tasks.TaskContinuationOptions.AttachedToParent?displayProperty=nameWithType> 選項建立的附加子工作，則其父代會將例外狀況傳播回到呼叫的執行緒，如同任何附加之子系的情況。</span><span class="sxs-lookup"><span data-stu-id="403a9-234">If the continuation is an attached child task that was created by using the <xref:System.Threading.Tasks.TaskContinuationOptions.AttachedToParent?displayProperty=nameWithType> option, its exceptions will be propagated by the parent back to the calling thread, as is the case in any other attached child.</span></span> <span data-ttu-id="403a9-235">如需詳細資訊，請參閱[附加與中斷連結的子工作](attached-and-detached-child-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="403a9-235">For more information, see [Attached and Detached Child Tasks](attached-and-detached-child-tasks.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="403a9-236">另請參閱</span><span class="sxs-lookup"><span data-stu-id="403a9-236">See also</span></span>

- [<span data-ttu-id="403a9-237">工作平行程式庫 (TPL)</span><span class="sxs-lookup"><span data-stu-id="403a9-237">Task Parallel Library (TPL)</span></span>](task-parallel-library-tpl.md)
