---
title: PLINQ 簡介
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- PLINQ queries, introduction to
ms.assetid: eaa720d8-8999-4eb7-8df5-3c19ca61cad0
ms.openlocfilehash: e50b2bf15d9a627f70ff01616bf2c72c70d7ff33
ms.sourcegitcommit: 33deec3e814238fb18a49b2a7e89278e27888291
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 06/02/2020
ms.locfileid: "84290677"
---
# <a name="introduction-to-plinq"></a><span data-ttu-id="b426b-102">PLINQ 簡介</span><span class="sxs-lookup"><span data-stu-id="b426b-102">Introduction to PLINQ</span></span>

<span data-ttu-id="b426b-103">Parallel LINQ （PLINQ）是[語言整合式查詢（LINQ）](../../csharp/programming-guide/concepts/linq/index.md)模式的平行執行。</span><span class="sxs-lookup"><span data-stu-id="b426b-103">Parallel LINQ (PLINQ) is a parallel implementation of the [Language-Integrated Query (LINQ)](../../csharp/programming-guide/concepts/linq/index.md) pattern.</span></span> <span data-ttu-id="b426b-104">PLINQ 實作了一組完整的 LINQ 標準查詢運算子來作為 <xref:System.Linq> 命名空間的擴充方法，並具有其他運算子可供平行作業使用。</span><span class="sxs-lookup"><span data-stu-id="b426b-104">PLINQ implements the full set of LINQ standard query operators as extension methods for the <xref:System.Linq> namespace and has additional operators for parallel operations.</span></span> <span data-ttu-id="b426b-105">PLINQ 結合了 LINQ 語法簡單易懂的特性以及平行程式設計的威力。</span><span class="sxs-lookup"><span data-stu-id="b426b-105">PLINQ combines the simplicity and readability of LINQ syntax with the power of parallel programming.</span></span>

> [!TIP]
> <span data-ttu-id="b426b-106">如果您不熟悉 LINQ，它會提供統一的模型，以型別安全的方式查詢任何可列舉的資料來源。</span><span class="sxs-lookup"><span data-stu-id="b426b-106">If you're not familiar with LINQ, it features a unified model for querying any enumerable data source in a type-safe manner.</span></span> <span data-ttu-id="b426b-107">LINQ to Objects 是 LINQ 查詢的名稱，它是針對記憶體中的集合 (例如 <xref:System.Collections.Generic.List%601> 和陣列) 執行。</span><span class="sxs-lookup"><span data-stu-id="b426b-107">LINQ to Objects is the name for LINQ queries that are run against in-memory collections such as <xref:System.Collections.Generic.List%601> and arrays.</span></span> <span data-ttu-id="b426b-108">本文假設您已對 LINQ 有基本了解。</span><span class="sxs-lookup"><span data-stu-id="b426b-108">This article assumes that you have a basic understanding of LINQ.</span></span> <span data-ttu-id="b426b-109">如需詳細資訊，請參閱[語言整合式查詢（LINQ）](../../csharp/programming-guide/concepts/linq/index.md)。</span><span class="sxs-lookup"><span data-stu-id="b426b-109">For more information, see [Language-Integrated Query (LINQ)](../../csharp/programming-guide/concepts/linq/index.md).</span></span>

## <a name="what-is-a-parallel-query"></a><span data-ttu-id="b426b-110">什麼是平行查詢？</span><span class="sxs-lookup"><span data-stu-id="b426b-110">What is a Parallel query?</span></span>

<span data-ttu-id="b426b-111">PLINQ 查詢在很多方面類似於非平行 LINQ to Objects 查詢。</span><span class="sxs-lookup"><span data-stu-id="b426b-111">A PLINQ query in many ways resembles a non-parallel LINQ to Objects query.</span></span> <span data-ttu-id="b426b-112">PLINQ 查詢就如同連續的 LINQ 查詢，會在任何記憶體內部 <xref:System.Collections.IEnumerable> 或資料來源上運作， <xref:System.Collections.Generic.IEnumerable%601> 並具有延後執行，這表示在列舉查詢之前，它們不會開始執行。</span><span class="sxs-lookup"><span data-stu-id="b426b-112">PLINQ queries, just like sequential LINQ queries, operate on any in-memory <xref:System.Collections.IEnumerable> or <xref:System.Collections.Generic.IEnumerable%601> data source, and have deferred execution, which means they do not begin executing until the query is enumerated.</span></span> <span data-ttu-id="b426b-113">這兩種查詢的主要差別在於，PLINQ 會嘗試充分利用系統上的所有處理器。</span><span class="sxs-lookup"><span data-stu-id="b426b-113">The primary difference is that PLINQ attempts to make full use of all the processors on the system.</span></span> <span data-ttu-id="b426b-114">它所採取的方式是將資料來源分割成多個區段，然後在多個處理器上，以平行方式在不同的背景工作執行緒上對每個區段執行查詢。</span><span class="sxs-lookup"><span data-stu-id="b426b-114">It does this by partitioning the data source into segments, and then executing the query on each segment on separate worker threads in parallel on multiple processors.</span></span> <span data-ttu-id="b426b-115">在許多情況下，平行執行意謂著查詢的執行速度會明顯加快。</span><span class="sxs-lookup"><span data-stu-id="b426b-115">In many cases, parallel execution means that the query runs significantly faster.</span></span>

<span data-ttu-id="b426b-116">透過平行執行，PLINQ 就能對適用於某些查詢種類的舊版程式碼，達成顯著的效能改善，而這通常只需要對資料來源新增 <xref:System.Linq.ParallelEnumerable.AsParallel%2A> 作業即可做到。</span><span class="sxs-lookup"><span data-stu-id="b426b-116">Through parallel execution, PLINQ can achieve significant performance improvements over legacy code for certain kinds of queries, often just by adding the <xref:System.Linq.ParallelEnumerable.AsParallel%2A> query operation to the data source.</span></span> <span data-ttu-id="b426b-117">不過，平行處理原則也會帶來自己的複雜性，所以並非所有查詢作業都可透過 PLINQ 加快執行速度。</span><span class="sxs-lookup"><span data-stu-id="b426b-117">However, parallelism can introduce its own complexities, and not all query operations run faster in PLINQ.</span></span> <span data-ttu-id="b426b-118">事實上，平行處理的確會降低某些查詢的速度。</span><span class="sxs-lookup"><span data-stu-id="b426b-118">In fact, parallelization actually slows down certain queries.</span></span> <span data-ttu-id="b426b-119">因此，您應該了解各種問題 (例如排序) 會如何影響平行查詢。</span><span class="sxs-lookup"><span data-stu-id="b426b-119">Therefore, you should understand how issues such as ordering affect parallel queries.</span></span> <span data-ttu-id="b426b-120">如需詳細資訊，請參閱[認識 PLINQ 中的加速](understanding-speedup-in-plinq.md)。</span><span class="sxs-lookup"><span data-stu-id="b426b-120">For more information, see [Understanding Speedup in PLINQ](understanding-speedup-in-plinq.md).</span></span>

> [!NOTE]
> <span data-ttu-id="b426b-121">本文件使用 Lambda 運算式來定義 PLINQ 中的委派。</span><span class="sxs-lookup"><span data-stu-id="b426b-121">This documentation uses lambda expressions to define delegates in PLINQ.</span></span> <span data-ttu-id="b426b-122">如果您不熟悉 C# 或 Visual Basic 中的 Lambda 運算式，請參閱 [PLINQ 和 TPL 中的 Lambda 運算式](lambda-expressions-in-plinq-and-tpl.md)。</span><span class="sxs-lookup"><span data-stu-id="b426b-122">If you are not familiar with lambda expressions in C# or Visual Basic, see [Lambda Expressions in PLINQ and TPL](lambda-expressions-in-plinq-and-tpl.md).</span></span>

<span data-ttu-id="b426b-123">本文的其餘部分提供主要 PLINQ 類別的總覽，並討論如何建立 PLINQ 查詢。</span><span class="sxs-lookup"><span data-stu-id="b426b-123">The remainder of this article gives an overview of the main PLINQ classes and discusses how to create PLINQ queries.</span></span> <span data-ttu-id="b426b-124">每一節都附有連結，可供您獲得詳細資訊和程式碼範例。</span><span class="sxs-lookup"><span data-stu-id="b426b-124">Each section contains links to more detailed information and code examples.</span></span>

## <a name="the-parallelenumerable-class"></a><span data-ttu-id="b426b-125">ParallelEnumerable 類別</span><span class="sxs-lookup"><span data-stu-id="b426b-125">The ParallelEnumerable Class</span></span>

<span data-ttu-id="b426b-126"><xref:System.Linq.ParallelEnumerable?displayProperty=nameWithType> 類別會公開幾乎所有的 PLINQ 功能。</span><span class="sxs-lookup"><span data-stu-id="b426b-126">The <xref:System.Linq.ParallelEnumerable?displayProperty=nameWithType> class exposes almost all of PLINQ's functionality.</span></span> <span data-ttu-id="b426b-127">此類別和其餘的 <xref:System.Linq?displayProperty=nameWithType> 命名空間型別會編譯成 System.Core.dll 組件。</span><span class="sxs-lookup"><span data-stu-id="b426b-127">It and the rest of the <xref:System.Linq?displayProperty=nameWithType> namespace types are compiled into the System.Core.dll assembly.</span></span> <span data-ttu-id="b426b-128">Visual Studio 中預設的 C# 和 Visual Basic 專案都會參考此組件並匯入該命名空間。</span><span class="sxs-lookup"><span data-stu-id="b426b-128">The default C# and Visual Basic projects in Visual Studio both reference the assembly and import the namespace.</span></span>

<span data-ttu-id="b426b-129"><xref:System.Linq.ParallelEnumerable> 會實作 LINQ to Objects 所支援的所有標準查詢運算子，但不會嘗試平行處理每個運算子。</span><span class="sxs-lookup"><span data-stu-id="b426b-129"><xref:System.Linq.ParallelEnumerable> includes implementations of all the standard query operators that LINQ to Objects supports, although it does not attempt to parallelize each one.</span></span> <span data-ttu-id="b426b-130">如果您不熟悉 LINQ，請參閱[Linq 簡介（c #）](../../csharp/programming-guide/concepts/linq/index.md)和[linq 簡介（Visual Basic）](../../visual-basic/programming-guide/concepts/linq/introduction-to-linq.md)。</span><span class="sxs-lookup"><span data-stu-id="b426b-130">If you are not familiar with LINQ, see [Introduction to LINQ (C#)](../../csharp/programming-guide/concepts/linq/index.md) and [Introduction to LINQ (Visual Basic)](../../visual-basic/programming-guide/concepts/linq/introduction-to-linq.md).</span></span>

<span data-ttu-id="b426b-131">除了標準查詢運算子外，<xref:System.Linq.ParallelEnumerable> 類別還會包含一組方法，以供啟用平行執行特有的行為。</span><span class="sxs-lookup"><span data-stu-id="b426b-131">In addition to the standard query operators, the <xref:System.Linq.ParallelEnumerable> class contains a set of methods that enable behaviors specific to parallel execution.</span></span> <span data-ttu-id="b426b-132">下表列出這些 PLINQ 特有的方法。</span><span class="sxs-lookup"><span data-stu-id="b426b-132">These PLINQ-specific methods are listed in the following table.</span></span>

|<span data-ttu-id="b426b-133">ParallelEnumerable 運算子</span><span class="sxs-lookup"><span data-stu-id="b426b-133">ParallelEnumerable Operator</span></span>|<span data-ttu-id="b426b-134">描述</span><span class="sxs-lookup"><span data-stu-id="b426b-134">Description</span></span>|
|---------------------------------|-----------------|
|<xref:System.Linq.ParallelEnumerable.AsParallel%2A>|<span data-ttu-id="b426b-135">PLINQ 的進入點。</span><span class="sxs-lookup"><span data-stu-id="b426b-135">The entry point for PLINQ.</span></span> <span data-ttu-id="b426b-136">指定系統應該在情況允許時平行處理其餘查詢。</span><span class="sxs-lookup"><span data-stu-id="b426b-136">Specifies that the rest of the query should be parallelized, if it is possible.</span></span>|
|<xref:System.Linq.ParallelEnumerable.AsSequential%2A>|<span data-ttu-id="b426b-137">指定系統應該將其餘查詢當作非平行 LINQ 查詢來循序執行。</span><span class="sxs-lookup"><span data-stu-id="b426b-137">Specifies that the rest of the query should be run sequentially, as a non-parallel LINQ query.</span></span>|
|<xref:System.Linq.ParallelEnumerable.AsOrdered%2A>|<span data-ttu-id="b426b-138">指定 PLINQ 應該為其餘查詢保留來源序列的排序，或保留到排序變更時，例如透過使用 orderby (在 Visual Basic 中是 Order By) 子句來變更。</span><span class="sxs-lookup"><span data-stu-id="b426b-138">Specifies that PLINQ should preserve the ordering of the source sequence for the rest of the query, or until the ordering is changed, for example by the use of an orderby (Order By in Visual Basic) clause.</span></span>|
|<xref:System.Linq.ParallelEnumerable.AsUnordered%2A>|<span data-ttu-id="b426b-139">指定用於其餘查詢的 PLINQ 不需要保留來源序列的排序。</span><span class="sxs-lookup"><span data-stu-id="b426b-139">Specifies that PLINQ for the rest of the query is not required to preserve the ordering of the source sequence.</span></span>|
|<xref:System.Linq.ParallelEnumerable.WithCancellation%2A>|<span data-ttu-id="b426b-140">指定 PLINQ 應定期監視所提供之取消權杖的狀態，並在經過要求後取消執行。</span><span class="sxs-lookup"><span data-stu-id="b426b-140">Specifies that PLINQ should periodically monitor the state of the provided cancellation token and cancel execution if it is requested.</span></span>|
|<xref:System.Linq.ParallelEnumerable.WithDegreeOfParallelism%2A>|<span data-ttu-id="b426b-141">指定 PLINQ 應該用來平行處理查詢的處理器數目上限。</span><span class="sxs-lookup"><span data-stu-id="b426b-141">Specifies the maximum number of processors that PLINQ should use to parallelize the query.</span></span>|
|<xref:System.Linq.ParallelEnumerable.WithMergeOptions%2A>|<span data-ttu-id="b426b-142">在情況允許時提供提示，說明 PLINQ 應該如何將平行結果合併回取用者執行緒上的單一序列中。</span><span class="sxs-lookup"><span data-stu-id="b426b-142">Provides a hint about how PLINQ should, if it is possible, merge parallel results back into just one sequence on the consuming thread.</span></span>|
|<xref:System.Linq.ParallelEnumerable.WithExecutionMode%2A>|<span data-ttu-id="b426b-143">指定 PLINQ 是否應在預設行為是循序執行查詢時，仍平行處理查詢。</span><span class="sxs-lookup"><span data-stu-id="b426b-143">Specifies whether PLINQ should parallelize the query even when the default behavior would be to run it sequentially.</span></span>|
|<xref:System.Linq.ParallelEnumerable.ForAll%2A>|<span data-ttu-id="b426b-144">多執行緒列舉方法不同於逐一查看查詢結果的方法，前者可平行處理所有結果，而不必先合併回取用者執行緒。</span><span class="sxs-lookup"><span data-stu-id="b426b-144">A multithreaded enumeration method that, unlike iterating over the results of the query, enables results to be processed in parallel without first merging back to the consumer thread.</span></span>|
|<span data-ttu-id="b426b-145"><xref:System.Linq.ParallelEnumerable.Aggregate%2A> 多載</span><span class="sxs-lookup"><span data-stu-id="b426b-145"><xref:System.Linq.ParallelEnumerable.Aggregate%2A> overload</span></span>|<span data-ttu-id="b426b-146">這是 PLINQ 特有的多載，可對執行緒區域分割啟用中繼彙總，並附有最後彙總函式可結合所有分割的結果。</span><span class="sxs-lookup"><span data-stu-id="b426b-146">An overload that is unique to PLINQ and enables intermediate aggregation over thread-local partitions, plus a final aggregation function to combine the results of all partitions.</span></span>|

## <a name="the-opt-in-model"></a><span data-ttu-id="b426b-147">加入模型</span><span class="sxs-lookup"><span data-stu-id="b426b-147">The Opt-in Model</span></span>

<span data-ttu-id="b426b-148">當您撰寫完查詢時，請藉由對資料來源叫用 <xref:System.Linq.ParallelEnumerable.AsParallel%2A?displayProperty=nameWithType> 擴充方法來將查詢加入 PLINQ，如下列範例所示。</span><span class="sxs-lookup"><span data-stu-id="b426b-148">When you write a query, opt in to PLINQ by invoking the <xref:System.Linq.ParallelEnumerable.AsParallel%2A?displayProperty=nameWithType> extension method on the data source, as shown in the following example.</span></span>

[!code-csharp[PLINQ#1](../../../samples/snippets/csharp/VS_Snippets_Misc/plinq/cs/plinq2_cs.cs#1)]
[!code-vb[PLINQ#1](../../../samples/snippets/visualbasic/VS_Snippets_Misc/plinq/vb/plinq2_vb.vb#1)]

<span data-ttu-id="b426b-149"><xref:System.Linq.ParallelEnumerable.AsParallel%2A> 擴充方法會將後續的查詢運算子 (此案例中為 `where` 和 `select`) 繫結至 <xref:System.Linq.ParallelEnumerable?displayProperty=nameWithType> 實作。</span><span class="sxs-lookup"><span data-stu-id="b426b-149">The <xref:System.Linq.ParallelEnumerable.AsParallel%2A> extension method binds the subsequent query operators, in this case, `where` and `select`, to the <xref:System.Linq.ParallelEnumerable?displayProperty=nameWithType> implementations.</span></span>

## <a name="execution-modes"></a><span data-ttu-id="b426b-150">執行模式</span><span class="sxs-lookup"><span data-stu-id="b426b-150">Execution Modes</span></span>

<span data-ttu-id="b426b-151">根據預設，PLINQ 會保守行事。</span><span class="sxs-lookup"><span data-stu-id="b426b-151">By default, PLINQ is conservative.</span></span> <span data-ttu-id="b426b-152">在執行階段，PLINQ 基礎結構會分析查詢的整體結構。</span><span class="sxs-lookup"><span data-stu-id="b426b-152">At run time, the PLINQ infrastructure analyzes the overall structure of the query.</span></span> <span data-ttu-id="b426b-153">如果查詢可透過平行化作業來加快執行速度，PLINQ 會將來源序列分割成可同時執行的工作。</span><span class="sxs-lookup"><span data-stu-id="b426b-153">If the query is likely to yield speedups by parallelization, PLINQ partitions the source sequence into tasks that can be run concurrently.</span></span> <span data-ttu-id="b426b-154">如果平行處理查詢的方式並不安全，PLINQ 就會循序執行查詢。</span><span class="sxs-lookup"><span data-stu-id="b426b-154">If it is not safe to parallelize a query, PLINQ just runs the query sequentially.</span></span> <span data-ttu-id="b426b-155">如果 PLINQ 可選擇是要使用成本可能較高的平行演算法，還是使用成本不高的循序演算法，則依預設它會選擇循序演算法。</span><span class="sxs-lookup"><span data-stu-id="b426b-155">If PLINQ has a choice between a potentially expensive parallel algorithm or an inexpensive sequential algorithm, it chooses the sequential algorithm by default.</span></span> <span data-ttu-id="b426b-156">您可以使用 <xref:System.Linq.ParallelEnumerable.WithExecutionMode%2A> 方法和 <xref:System.Linq.ParallelExecutionMode?displayProperty=nameWithType> 列舉來指示 PLINQ 選取平行演算法。</span><span class="sxs-lookup"><span data-stu-id="b426b-156">You can use the <xref:System.Linq.ParallelEnumerable.WithExecutionMode%2A> method and the <xref:System.Linq.ParallelExecutionMode?displayProperty=nameWithType> enumeration to instruct PLINQ to select the parallel algorithm.</span></span> <span data-ttu-id="b426b-157">當您在測試和測量後得知，某特定查詢在平行執行時速度會更快，便適合這麼做。</span><span class="sxs-lookup"><span data-stu-id="b426b-157">This is useful when you know by testing and measurement that a particular query executes faster in parallel.</span></span> <span data-ttu-id="b426b-158">如需詳細資訊，請參閱[如何：在 PLINQ 中指定執行模式](how-to-specify-the-execution-mode-in-plinq.md)。</span><span class="sxs-lookup"><span data-stu-id="b426b-158">For more information, see [How to: Specify the Execution Mode in PLINQ](how-to-specify-the-execution-mode-in-plinq.md).</span></span>

## <a name="degree-of-parallelism"></a><span data-ttu-id="b426b-159">平行處理原則的程度</span><span class="sxs-lookup"><span data-stu-id="b426b-159">Degree of Parallelism</span></span>

<span data-ttu-id="b426b-160">根據預設，PLINQ 會使用主機電腦上的所有處理器。</span><span class="sxs-lookup"><span data-stu-id="b426b-160">By default, PLINQ uses all of the processors on the host computer.</span></span> <span data-ttu-id="b426b-161">您可以使用 <xref:System.Linq.ParallelEnumerable.WithDegreeOfParallelism%2A> 方法來指示 PLINQ 使用不超過指定數目的處理器。</span><span class="sxs-lookup"><span data-stu-id="b426b-161">You can instruct PLINQ to use no more than a specified number of processors by using the <xref:System.Linq.ParallelEnumerable.WithDegreeOfParallelism%2A> method.</span></span> <span data-ttu-id="b426b-162">若您想要確保電腦上執行的其他處理序可獲得一定的 CPU 使用時間，您便可以這麼做。</span><span class="sxs-lookup"><span data-stu-id="b426b-162">This is useful when you want to make sure that other processes running on the computer receive a certain amount of CPU time.</span></span> <span data-ttu-id="b426b-163">下列程式碼片段會限制查詢最多只能使用兩個處理器。</span><span class="sxs-lookup"><span data-stu-id="b426b-163">The following snippet limits the query to utilizing a maximum of two processors.</span></span>

[!code-csharp[PLINQ#5](../../../samples/snippets/csharp/VS_Snippets_Misc/plinq/cs/plinqsamples.cs#5)]
[!code-vb[PLINQ#5](../../../samples/snippets/visualbasic/VS_Snippets_Misc/plinq/vb/plinq2_vb.vb#5)]

<span data-ttu-id="b426b-164">當查詢在執行大量非計算繫結工作 (例如檔案 I/O) 的情況下，將平行處理程度指定為大於電腦上的核心數目可能會有幫助。</span><span class="sxs-lookup"><span data-stu-id="b426b-164">In cases where a query is performing a significant amount of non-compute-bound work such as File I/O, it might be beneficial to specify a degree of parallelism greater than the number of cores on the machine.</span></span>

## <a name="ordered-versus-unordered-parallel-queries"></a><span data-ttu-id="b426b-165">比較排序與未排序的平行查詢</span><span class="sxs-lookup"><span data-stu-id="b426b-165">Ordered Versus Unordered Parallel Queries</span></span>

<span data-ttu-id="b426b-166">在某些查詢中，查詢運算子所產生的結果必須保留來源序列的排序。</span><span class="sxs-lookup"><span data-stu-id="b426b-166">In some queries, a query operator must produce results that preserve the ordering of the source sequence.</span></span> <span data-ttu-id="b426b-167">基於此目的，PLINQ 提供 <xref:System.Linq.ParallelEnumerable.AsOrdered%2A> 運算子。</span><span class="sxs-lookup"><span data-stu-id="b426b-167">PLINQ provides the <xref:System.Linq.ParallelEnumerable.AsOrdered%2A> operator for this purpose.</span></span> <span data-ttu-id="b426b-168"><xref:System.Linq.ParallelEnumerable.AsOrdered%2A> 不同於 <xref:System.Linq.ParallelEnumerable.AsSequential%2A>。</span><span class="sxs-lookup"><span data-stu-id="b426b-168"><xref:System.Linq.ParallelEnumerable.AsOrdered%2A> is distinct from <xref:System.Linq.ParallelEnumerable.AsSequential%2A>.</span></span> <span data-ttu-id="b426b-169"><xref:System.Linq.ParallelEnumerable.AsOrdered%2A> 序列仍會以平行方式處理，但其結果會新增到緩衝區並加以排序。</span><span class="sxs-lookup"><span data-stu-id="b426b-169">An <xref:System.Linq.ParallelEnumerable.AsOrdered%2A> sequence is still processed in parallel, but its results are buffered and sorted.</span></span> <span data-ttu-id="b426b-170">順序保留通常涉及額外工作，因此，<xref:System.Linq.ParallelEnumerable.AsOrdered%2A> 序列的處理速度可能會比 <xref:System.Linq.ParallelEnumerable.AsUnordered%2A> 序列慢。</span><span class="sxs-lookup"><span data-stu-id="b426b-170">Because order preservation typically involves extra work, an <xref:System.Linq.ParallelEnumerable.AsOrdered%2A> sequence might be processed more slowly than the default <xref:System.Linq.ParallelEnumerable.AsUnordered%2A> sequence.</span></span> <span data-ttu-id="b426b-171">有許多因素會決定特定的排序平行作業是否會比循序作業更快。</span><span class="sxs-lookup"><span data-stu-id="b426b-171">Whether a particular ordered parallel operation is faster than a sequential version of the operation depends on many factors.</span></span>

<span data-ttu-id="b426b-172">下列程式碼範例示範如何選擇加入順序保留功能。</span><span class="sxs-lookup"><span data-stu-id="b426b-172">The following code example shows how to opt in to order preservation.</span></span>

[!code-csharp[PLINQ#3](../../../samples/snippets/csharp/VS_Snippets_Misc/plinq/cs/plinq2_cs.cs#3)]
[!code-vb[PLINQ#3](../../../samples/snippets/visualbasic/VS_Snippets_Misc/plinq/vb/plinq2_vb.vb#3)]

<span data-ttu-id="b426b-173">如需詳細資訊，請參閱 [PLINQ 中的順序保留](order-preservation-in-plinq.md)。</span><span class="sxs-lookup"><span data-stu-id="b426b-173">For more information, see [Order Preservation in PLINQ](order-preservation-in-plinq.md).</span></span>

## <a name="parallel-vs-sequential-queries"></a><span data-ttu-id="b426b-174">比較平行與循序查詢</span><span class="sxs-lookup"><span data-stu-id="b426b-174">Parallel vs. Sequential Queries</span></span>

<span data-ttu-id="b426b-175">某些作業會要求系統以循序方式傳遞來源資料。</span><span class="sxs-lookup"><span data-stu-id="b426b-175">Some operations require that the source data be delivered in a sequential manner.</span></span> <span data-ttu-id="b426b-176"><xref:System.Linq.ParallelEnumerable> 查詢運算子會在必要時自動還原為循序模式。</span><span class="sxs-lookup"><span data-stu-id="b426b-176">The <xref:System.Linq.ParallelEnumerable> query operators revert to sequential mode automatically when it is required.</span></span> <span data-ttu-id="b426b-177">對於使用者定義的查詢運算子和需要循序執行的使用者委派，PLINQ 提供了 <xref:System.Linq.ParallelEnumerable.AsSequential%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="b426b-177">For user-defined query operators and user delegates that require sequential execution, PLINQ provides the <xref:System.Linq.ParallelEnumerable.AsSequential%2A> method.</span></span> <span data-ttu-id="b426b-178">當您使用 <xref:System.Linq.ParallelEnumerable.AsSequential%2A> 時，查詢中的所有後續運算子會循序執行，直到再次呼叫 <xref:System.Linq.ParallelEnumerable.AsParallel%2A> 為止。</span><span class="sxs-lookup"><span data-stu-id="b426b-178">When you use <xref:System.Linq.ParallelEnumerable.AsSequential%2A>, all subsequent operators in the query are executed sequentially until <xref:System.Linq.ParallelEnumerable.AsParallel%2A> is called again.</span></span> <span data-ttu-id="b426b-179">如需詳細資訊，請參閱[如何：結合平行和循序 LINQ 查詢](how-to-combine-parallel-and-sequential-linq-queries.md)。</span><span class="sxs-lookup"><span data-stu-id="b426b-179">For more information, see [How to: Combine Parallel and Sequential LINQ Queries](how-to-combine-parallel-and-sequential-linq-queries.md).</span></span>

## <a name="options-for-merging-query-results"></a><span data-ttu-id="b426b-180">可供合併查詢結果的選項</span><span class="sxs-lookup"><span data-stu-id="b426b-180">Options for Merging Query Results</span></span>

<span data-ttu-id="b426b-181">當 PLINQ 查詢以平行方式執行時，其來自每個背景工作執行緒的結果，必須合併回主要執行緒以供 `foreach` 迴圈 (在 Visual Basic 中是 `For Each`) 取用，或以供插入至清單或陣列。</span><span class="sxs-lookup"><span data-stu-id="b426b-181">When a PLINQ query executes in parallel, its results from each worker thread must be merged back onto the main thread for consumption by a `foreach` loop (`For Each` in Visual Basic), or insertion into a list or array.</span></span> <span data-ttu-id="b426b-182">在某些情況下，指定特定種類的合併作業可能會有幫助，例如，若您要更快速地開始產生結果的話。</span><span class="sxs-lookup"><span data-stu-id="b426b-182">In some cases, it might be beneficial to specify a particular kind of merge operation, for example, to begin producing results more quickly.</span></span> <span data-ttu-id="b426b-183">基於此目的，PLINQ 支援 <xref:System.Linq.ParallelEnumerable.WithMergeOptions%2A> 方法與 <xref:System.Linq.ParallelMergeOptions> 列舉。</span><span class="sxs-lookup"><span data-stu-id="b426b-183">For this purpose, PLINQ supports the <xref:System.Linq.ParallelEnumerable.WithMergeOptions%2A> method, and the <xref:System.Linq.ParallelMergeOptions> enumeration.</span></span> <span data-ttu-id="b426b-184">如需詳細資訊，請參閱 [PLINQ 中的合併選項](merge-options-in-plinq.md)。</span><span class="sxs-lookup"><span data-stu-id="b426b-184">For more information, see [Merge Options in PLINQ](merge-options-in-plinq.md).</span></span>

## <a name="the-forall-operator"></a><span data-ttu-id="b426b-185">ForAll 運算子</span><span class="sxs-lookup"><span data-stu-id="b426b-185">The ForAll Operator</span></span>

<span data-ttu-id="b426b-186">在連續的 LINQ 查詢中，執行會延後，直到在 `foreach` （ `For Each` Visual Basic）迴圈中列舉查詢或叫用方法（例如 <xref:System.Linq.ParallelEnumerable.ToList%2A> 、或）為止 <xref:System.Linq.ParallelEnumerable.ToArray%2A> <xref:System.Linq.ParallelEnumerable.ToDictionary%2A> 。</span><span class="sxs-lookup"><span data-stu-id="b426b-186">In sequential LINQ queries, execution is deferred until the query is enumerated either in a `foreach` (`For Each` in Visual Basic) loop or by invoking a method such as <xref:System.Linq.ParallelEnumerable.ToList%2A> , <xref:System.Linq.ParallelEnumerable.ToArray%2A> , or <xref:System.Linq.ParallelEnumerable.ToDictionary%2A>.</span></span> <span data-ttu-id="b426b-187">在 PLINQ 中，您也可以使用 `foreach` 來執行查詢，並逐一查看各項結果。</span><span class="sxs-lookup"><span data-stu-id="b426b-187">In PLINQ, you can also use `foreach` to execute the query and iterate through the results.</span></span> <span data-ttu-id="b426b-188">不過，`foreach` 本身並不會以平行方式執行，因此，所有平行工作的輸出必須合併回用來執行迴圈的執行緒。</span><span class="sxs-lookup"><span data-stu-id="b426b-188">However, `foreach` itself does not run in parallel, and therefore, it requires that the output from all parallel tasks be merged back into the thread on which the loop is running.</span></span> <span data-ttu-id="b426b-189">在 PLINQ 中，當您必須保留查詢結果的最終排序時，以及每當您以序列方式處理結果時 (例如，當您為每個元素呼叫 `Console.WriteLine` 時)，您都可以使用 `foreach`。</span><span class="sxs-lookup"><span data-stu-id="b426b-189">In PLINQ, you can use `foreach` when you must preserve the final ordering of the query results, and also whenever you are processing the results in a serial manner, for example when you are calling `Console.WriteLine` for each element.</span></span> <span data-ttu-id="b426b-190">在不必保留順序時，以及在結果本身可以平行處理時，若您需要更快速地執行查詢，請使用 <xref:System.Linq.ParallelEnumerable.ForAll%2A> 方法來執行 PLINQ 查詢。</span><span class="sxs-lookup"><span data-stu-id="b426b-190">For faster query execution when order preservation is not required and when the processing of the results can itself be parallelized, use the <xref:System.Linq.ParallelEnumerable.ForAll%2A> method to execute a PLINQ query.</span></span> <span data-ttu-id="b426b-191"><xref:System.Linq.ParallelEnumerable.ForAll%2A> 不會執此最終合併步驟。</span><span class="sxs-lookup"><span data-stu-id="b426b-191"><xref:System.Linq.ParallelEnumerable.ForAll%2A> does not perform this final merge step.</span></span> <span data-ttu-id="b426b-192">下列程式碼範例示範如何使用 <xref:System.Linq.ParallelEnumerable.ForAll%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="b426b-192">The following code example shows how to use the <xref:System.Linq.ParallelEnumerable.ForAll%2A> method.</span></span> <span data-ttu-id="b426b-193">這裡會使用 <xref:System.Collections.Concurrent.ConcurrentBag%601?displayProperty=nameWithType>，因為它已經過最佳化，能夠用於同時新增的多個執行緒，而不會嘗試移除任何項目。</span><span class="sxs-lookup"><span data-stu-id="b426b-193"><xref:System.Collections.Concurrent.ConcurrentBag%601?displayProperty=nameWithType> is used here because it is optimized for multiple threads adding concurrently without attempting to remove any items.</span></span>

[!code-csharp[PLINQ#4](../../../samples/snippets/csharp/VS_Snippets_Misc/plinq/cs/plinq2_cs.cs#4)]
[!code-vb[PLINQ#4](../../../samples/snippets/visualbasic/VS_Snippets_Misc/plinq/vb/plinq2_vb.vb#4)]

<span data-ttu-id="b426b-194">下圖顯示 `foreach` 和 <xref:System.Linq.ParallelEnumerable.ForAll%2A> 兩者在執行查詢方面的差異。</span><span class="sxs-lookup"><span data-stu-id="b426b-194">The following illustration shows the difference between `foreach` and <xref:System.Linq.ParallelEnumerable.ForAll%2A> with regard to query execution.</span></span>

<span data-ttu-id="b426b-195">![ForAll 與 ForEach 的比較](media/vs-isvnt-allvseach.png "VS_ISVNT_ALLvsEACH")</span><span class="sxs-lookup"><span data-stu-id="b426b-195">![ForAll vs. ForEach](media/vs-isvnt-allvseach.png "VS_ISVNT_ALLvsEACH")</span></span>

## <a name="cancellation"></a><span data-ttu-id="b426b-196">取消</span><span class="sxs-lookup"><span data-stu-id="b426b-196">Cancellation</span></span>

<span data-ttu-id="b426b-197">PLINQ 已與 .NET Framework 4 中的取消作業型別整合。</span><span class="sxs-lookup"><span data-stu-id="b426b-197">PLINQ is integrated with the cancellation types in .NET Framework 4.</span></span> <span data-ttu-id="b426b-198">（如需詳細資訊，請參閱[Managed 執行緒中的取消](../threading/cancellation-in-managed-threads.md)）。因此，與順序 LINQ to Objects 查詢不同的是，PLINQ 查詢可以取消。</span><span class="sxs-lookup"><span data-stu-id="b426b-198">(For more information, see [Cancellation in Managed Threads](../threading/cancellation-in-managed-threads.md).) Therefore, unlike sequential LINQ to Objects queries, PLINQ queries can be canceled.</span></span> <span data-ttu-id="b426b-199">若要建立可取消的 PLINQ 查詢，請在查詢中使用 <xref:System.Linq.ParallelEnumerable.WithCancellation%2A> 運算子，並提供 <xref:System.Threading.CancellationToken> 執行個體做為引數。</span><span class="sxs-lookup"><span data-stu-id="b426b-199">To create a cancelable PLINQ query, use the <xref:System.Linq.ParallelEnumerable.WithCancellation%2A> operator on the query and provide a <xref:System.Threading.CancellationToken> instance as the argument.</span></span> <span data-ttu-id="b426b-200">當權杖上的 <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> 屬性設為 true 時，PLINQ 將注意到，並會停止所有執行緒上的處理作業，然後擲回 <xref:System.OperationCanceledException>。</span><span class="sxs-lookup"><span data-stu-id="b426b-200">When the <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> property on the token is set to true, PLINQ will notice it, stop processing on all threads, and throw an <xref:System.OperationCanceledException>.</span></span>

<span data-ttu-id="b426b-201">在設定了取消權杖之後，PLINQ 查詢還是可能會繼續處理某些元素。</span><span class="sxs-lookup"><span data-stu-id="b426b-201">It is possible that a PLINQ query might continue to process some elements after the cancellation token is set.</span></span>

<span data-ttu-id="b426b-202">若要提高回應速度，您也可以在長時間執行的使用者委派中回應取消要求。</span><span class="sxs-lookup"><span data-stu-id="b426b-202">For greater responsiveness, you can also respond to cancellation requests in long-running user delegates.</span></span> <span data-ttu-id="b426b-203">如需詳細資訊，請參閱[如何：取消 PLINQ 查詢](how-to-cancel-a-plinq-query.md)。</span><span class="sxs-lookup"><span data-stu-id="b426b-203">For more information, see [How to: Cancel a PLINQ Query](how-to-cancel-a-plinq-query.md).</span></span>

## <a name="exceptions"></a><span data-ttu-id="b426b-204">例外狀況</span><span class="sxs-lookup"><span data-stu-id="b426b-204">Exceptions</span></span>

<span data-ttu-id="b426b-205">PLINQ 查詢在執行時，不同的執行緒可能會同時擲回多個例外狀況。</span><span class="sxs-lookup"><span data-stu-id="b426b-205">When a PLINQ query executes, multiple exceptions might be thrown from different threads simultaneously.</span></span> <span data-ttu-id="b426b-206">此外，負責處理例外狀況之程式碼所在的執行緒，可能會不同於擲回例外狀況之程式碼所在的執行緒。</span><span class="sxs-lookup"><span data-stu-id="b426b-206">Also, the code to handle the exception might be on a different thread than the code that threw the exception.</span></span> <span data-ttu-id="b426b-207">PLINQ 會使用 <xref:System.AggregateException> 型別將查詢擲回的所有例外狀況封裝起來，然後將這些例外狀況封送處理回呼叫端執行緒。</span><span class="sxs-lookup"><span data-stu-id="b426b-207">PLINQ uses the <xref:System.AggregateException> type to encapsulate all the exceptions that were thrown by a query, and marshal those exceptions back to the calling thread.</span></span> <span data-ttu-id="b426b-208">呼叫端執行緒只需要一個 try-catch 區塊。</span><span class="sxs-lookup"><span data-stu-id="b426b-208">On the calling thread, only one try-catch block is required.</span></span> <span data-ttu-id="b426b-209">不過，您可以逐一查看 <xref:System.AggregateException> 中封裝的所有例外狀況，並攔截您可以從中安全復原的任何例外狀況。</span><span class="sxs-lookup"><span data-stu-id="b426b-209">However, you can iterate through all of the exceptions that are encapsulated in the <xref:System.AggregateException> and catch any that you can safely recover from.</span></span> <span data-ttu-id="b426b-210">在少數情況下，某些例外狀況擲回時可能未包裝於 <xref:System.AggregateException> 中，<xref:System.Threading.ThreadAbortException> 也未包裝。</span><span class="sxs-lookup"><span data-stu-id="b426b-210">In rare cases, some exceptions may be thrown that are not wrapped in an <xref:System.AggregateException>, and <xref:System.Threading.ThreadAbortException>s  are also not wrapped.</span></span>

<span data-ttu-id="b426b-211">當系統允許例外狀況反昇至聯結的執行緒時，查詢可能就可以在引發例外狀況之後，繼續處理某些項目。</span><span class="sxs-lookup"><span data-stu-id="b426b-211">When exceptions are allowed to bubble up back to the joining thread, then it is possible that a query may continue to process some items after the exception is raised.</span></span>

<span data-ttu-id="b426b-212">如需詳細資訊，請參閱[如何：處理 PLINQ 查詢中的例外狀況](how-to-handle-exceptions-in-a-plinq-query.md)。</span><span class="sxs-lookup"><span data-stu-id="b426b-212">For more information, see [How to: Handle Exceptions in a PLINQ Query](how-to-handle-exceptions-in-a-plinq-query.md).</span></span>

## <a name="custom-partitioners"></a><span data-ttu-id="b426b-213">自訂 Partitioner</span><span class="sxs-lookup"><span data-stu-id="b426b-213">Custom Partitioners</span></span>

<span data-ttu-id="b426b-214">在某些情況下，您可以藉由撰寫自訂 Partitioner 來利用來源資料的某些特性，以改善查詢效能。</span><span class="sxs-lookup"><span data-stu-id="b426b-214">In some cases, you can improve query performance by writing a custom partitioner that takes advantage of some characteristic of the source data.</span></span> <span data-ttu-id="b426b-215">在查詢中，自訂 Partitioner 本身就是所查詢的可列舉物件。</span><span class="sxs-lookup"><span data-stu-id="b426b-215">In the query, the custom partitioner itself is the enumerable object that is queried.</span></span>

[!code-csharp[PLINQ#2](../../../samples/snippets/csharp/VS_Snippets_Misc/plinq/cs/plinq2_cs.cs#2)]
[!code-vb[PLINQ#2](../../../samples/snippets/visualbasic/VS_Snippets_Misc/plinq/vb/plinq3.vb#2)]

<span data-ttu-id="b426b-216">PLINQ 支援固定數目的分割 (但在執行階段為了保持負載平衡，系統可能會以動態方式將資料重新指派給這些分割)。</span><span class="sxs-lookup"><span data-stu-id="b426b-216">PLINQ supports a fixed number of partitions (although data may be dynamically reassigned to those partitions during run time for load balancing.).</span></span> <span data-ttu-id="b426b-217"><xref:System.Threading.Tasks.Parallel.For%2A> 和 <xref:System.Threading.Tasks.Parallel.ForEach%2A> 僅支援動態分割，這表示分割區數目是在執行階段變更的。</span><span class="sxs-lookup"><span data-stu-id="b426b-217"><xref:System.Threading.Tasks.Parallel.For%2A> and <xref:System.Threading.Tasks.Parallel.ForEach%2A> support only dynamic partitioning, which means that the number of partitions changes at run time.</span></span> <span data-ttu-id="b426b-218">如需詳細資訊，請參閱 [PLINQ 和 TPL 的自訂 Partitioner](custom-partitioners-for-plinq-and-tpl.md)。</span><span class="sxs-lookup"><span data-stu-id="b426b-218">For more information, see [Custom Partitioners for PLINQ and TPL](custom-partitioners-for-plinq-and-tpl.md).</span></span>

## <a name="measuring-plinq-performance"></a><span data-ttu-id="b426b-219">測量 PLINQ 效能</span><span class="sxs-lookup"><span data-stu-id="b426b-219">Measuring PLINQ Performance</span></span>

<span data-ttu-id="b426b-220">在許多情況下，查詢可平行處理，但設定平行查詢時所帶來的額外負荷，遠超過所獲得的效能好處。</span><span class="sxs-lookup"><span data-stu-id="b426b-220">In many cases, a query can be parallelized, but the overhead of setting up the parallel query outweighs the performance benefit gained.</span></span> <span data-ttu-id="b426b-221">如果查詢不會執行許多計算，或如果資料來源很小，PLINQ 查詢的速度可能會比 LINQ to Objects 循序查詢還慢。</span><span class="sxs-lookup"><span data-stu-id="b426b-221">If a query does not perform much computation or if the data source is small, a PLINQ query may be slower than a sequential LINQ to Objects query.</span></span> <span data-ttu-id="b426b-222">您可以使用 Visual Studio Team Server 中的 Parallel Performance Analyzer 來比較各種查詢的效能，以找出處理瓶頸，以及判斷您的查詢該平行執行還是循序執行。</span><span class="sxs-lookup"><span data-stu-id="b426b-222">You can use the Parallel Performance Analyzer in Visual Studio Team Server to compare the performance of various queries, to locate processing bottlenecks, and to determine whether your query is running in parallel or sequentially.</span></span> <span data-ttu-id="b426b-223">如需詳細資訊，請參閱[並行視覺化檢視](/visualstudio/profiling/concurrency-visualizer)和[如何：測量 PLINQ 查詢效能](how-to-measure-plinq-query-performance.md)。</span><span class="sxs-lookup"><span data-stu-id="b426b-223">For more information, see [Concurrency Visualizer](/visualstudio/profiling/concurrency-visualizer) and [How to: Measure PLINQ Query Performance](how-to-measure-plinq-query-performance.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="b426b-224">另請參閱</span><span class="sxs-lookup"><span data-stu-id="b426b-224">See also</span></span>

- [<span data-ttu-id="b426b-225">平行 LINQ (PLINQ)</span><span class="sxs-lookup"><span data-stu-id="b426b-225">Parallel LINQ (PLINQ)</span></span>](introduction-to-plinq.md)
- [<span data-ttu-id="b426b-226">認識 PLINQ 中的加速</span><span class="sxs-lookup"><span data-stu-id="b426b-226">Understanding Speedup in PLINQ</span></span>](understanding-speedup-in-plinq.md)
