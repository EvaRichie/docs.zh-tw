---
title: 資料流程 (工作平行程式庫)
description: 瞭解如何使用工作平行程式庫中的資料流程元件 (TPL) 來改善啟用平行存取之應用程式的穩定性。
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- Task Parallel Library, dataflows
- TPL dataflow library
ms.assetid: 643575d0-d26d-4c35-8de7-a9c403e97dd6
ms.openlocfilehash: 8c6eeab852f30535d721aa44b3c60e4b6febe0fc
ms.sourcegitcommit: 965a5af7918acb0a3fd3baf342e15d511ef75188
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 11/18/2020
ms.locfileid: "94817636"
---
# <a name="dataflow-task-parallel-library"></a><span data-ttu-id="0364b-103">資料流程 (工作平行程式庫)</span><span class="sxs-lookup"><span data-stu-id="0364b-103">Dataflow (Task Parallel Library)</span></span>
<span data-ttu-id="0364b-104">工作平行程式庫 (TPL) 提供資料流程元件來協助增加啟用並行的應用程式之穩定性。</span><span class="sxs-lookup"><span data-stu-id="0364b-104">The Task Parallel Library (TPL) provides dataflow components to help increase the robustness of concurrency-enabled applications.</span></span> <span data-ttu-id="0364b-105">這些資料流程元件合稱為「TPL 資料流程程式庫」。</span><span class="sxs-lookup"><span data-stu-id="0364b-105">These dataflow components are collectively referred to as the *TPL Dataflow Library*.</span></span> <span data-ttu-id="0364b-106">此資料流程模型以提供針對廣泛資料流程以及管線工作的同處理序訊息傳遞，將以行動為基礎的程式撰寫升級。</span><span class="sxs-lookup"><span data-stu-id="0364b-106">This dataflow model promotes actor-based programming by providing in-process message passing for coarse-grained dataflow and pipelining tasks.</span></span> <span data-ttu-id="0364b-107">資料流程元件會在 TPL 的類型與排程基礎結構上建置，並整合 C#、Visual Basic 以及 F# 語言對非同步程式設計的支援。</span><span class="sxs-lookup"><span data-stu-id="0364b-107">The dataflow components build on the types and scheduling infrastructure of the TPL and integrate with the C#, Visual Basic, and F# language support for asynchronous programming.</span></span> <span data-ttu-id="0364b-108">當您有多個必須非同步式互相溝通的作業時，或當您因為資料變為可用而要處理資料時，這些資料流程元件就會相當實用。</span><span class="sxs-lookup"><span data-stu-id="0364b-108">These dataflow components are useful when you have multiple operations that must communicate with one another asynchronously or when you want to process data as it becomes available.</span></span> <span data-ttu-id="0364b-109">例如，請考慮一個應用程式，它會處理來自網路攝影機的影像資料。</span><span class="sxs-lookup"><span data-stu-id="0364b-109">For example, consider an application that processes image data from a web camera.</span></span> <span data-ttu-id="0364b-110">使用資料流模型，應用程式就可以在影像畫面可用時處理它們。</span><span class="sxs-lookup"><span data-stu-id="0364b-110">By using the dataflow model, the application can process image frames as they become available.</span></span> <span data-ttu-id="0364b-111">例如，如果應用程式因執行光源修正或消除紅眼而增強影像畫面，則您可以建立資料流程元件的「管線」。</span><span class="sxs-lookup"><span data-stu-id="0364b-111">If the application enhances image frames, for example, by performing light correction or red-eye reduction, you can create a *pipeline* of dataflow components.</span></span> <span data-ttu-id="0364b-112">此管線的每個階段都可能使用更廣泛的平行處理原則功能 (例如 TPL 提供的功能) 來轉換該影像。</span><span class="sxs-lookup"><span data-stu-id="0364b-112">Each stage of the pipeline might use more coarse-grained parallelism functionality, such as the functionality that is provided by the TPL, to transform the image.</span></span>  
  
 <span data-ttu-id="0364b-113">本文件提供 TPL 資料流程程式庫的概觀。</span><span class="sxs-lookup"><span data-stu-id="0364b-113">This document provides an overview of the TPL Dataflow Library.</span></span> <span data-ttu-id="0364b-114">此文件描述程式設計模型、預先定義的資料流程區塊類型，以及描述如何設定資料流程區塊以符合應用程式的特定需求。</span><span class="sxs-lookup"><span data-stu-id="0364b-114">It describes the programming model, the predefined dataflow block types, and how to configure dataflow blocks to meet the specific requirements of your applications.</span></span>  

[!INCLUDE [tpl-install-instructions](../../../includes/tpl-install-instructions.md)]

## <a name="programming-model"></a><span data-ttu-id="0364b-115">程式設計模型</span><span class="sxs-lookup"><span data-stu-id="0364b-115">Programming Model</span></span>
 <span data-ttu-id="0364b-116">TPL 資料流程程式庫提供了訊息傳遞之基礎，也是平行處理具有高輸送量與低延遲、需要大量 CPU 與 I/O 的應用程式之基礎。</span><span class="sxs-lookup"><span data-stu-id="0364b-116">The TPL Dataflow Library provides a foundation for message passing and parallelizing CPU-intensive and I/O-intensive applications that have high throughput and low latency.</span></span> <span data-ttu-id="0364b-117">這也可以讓您明確地控制資料如何緩衝以及如何在系統中移動。</span><span class="sxs-lookup"><span data-stu-id="0364b-117">It also gives you explicit control over how data is buffered and moves around the system.</span></span> <span data-ttu-id="0364b-118">若要進一步了解資料流程程式撰寫模型，請考慮以非同步方式從磁碟載入影像並建立這些影像組合的應用程式。</span><span class="sxs-lookup"><span data-stu-id="0364b-118">To better understand the dataflow programming model, consider an application that asynchronously loads images from disk and creates a composite of those images.</span></span> <span data-ttu-id="0364b-119">傳統的程式設計模型通常需要您使用回呼和同步處理物件 (例如鎖定)，來協調工作與存取共用資料。</span><span class="sxs-lookup"><span data-stu-id="0364b-119">Traditional programming models typically require that you use callbacks and synchronization objects, such as locks, to coordinate tasks and access to shared data.</span></span> <span data-ttu-id="0364b-120">您可以使用資料流程程式撰寫模型來建立資料流程物件，從磁碟讀取影像時，該資料流程物件可以處理影像。</span><span class="sxs-lookup"><span data-stu-id="0364b-120">By using the dataflow programming model, you can create dataflow objects that process images as they are read from disk.</span></span> <span data-ttu-id="0364b-121">在資料流程模型下，您宣告資料的處理方式、宣告其可使用的時機，以及資料之間的相依性。</span><span class="sxs-lookup"><span data-stu-id="0364b-121">Under the dataflow model, you declare how data is handled when it becomes available, and also any dependencies between data.</span></span> <span data-ttu-id="0364b-122">由於執行階段會處理資料之間的相依性，您通常可以避免存取共用資料之同步處理的需求。</span><span class="sxs-lookup"><span data-stu-id="0364b-122">Because the runtime manages dependencies between data, you can often avoid the requirement to synchronize access to shared data.</span></span> <span data-ttu-id="0364b-123">此外，因為執行階段排程是依據資料的非同步抵達來運作，所以資料流程可以藉由有效管理基礎執行緒以改善回應性和輸送量。</span><span class="sxs-lookup"><span data-stu-id="0364b-123">In addition, because the runtime schedules work based on the asynchronous arrival of data, dataflow can improve responsiveness and throughput by efficiently managing the underlying threads.</span></span> <span data-ttu-id="0364b-124">如需在 Windows Forms 應用程式中使用資料流程程式撰寫模型來實作影像處理的範例，請參閱[逐步解說：在 Windows Forms 應用程式中使用資料流程](walkthrough-using-dataflow-in-a-windows-forms-application.md)。</span><span class="sxs-lookup"><span data-stu-id="0364b-124">For an example that uses the dataflow programming model to implement image processing in a Windows Forms application, see [Walkthrough: Using Dataflow in a Windows Forms Application](walkthrough-using-dataflow-in-a-windows-forms-application.md).</span></span>  
  
### <a name="sources-and-targets"></a><span data-ttu-id="0364b-125">來源和目標</span><span class="sxs-lookup"><span data-stu-id="0364b-125">Sources and Targets</span></span>  
 <span data-ttu-id="0364b-126">TPL 資料流程程式庫由「資料流程區塊」所組成，其為緩衝及處理資料的資料結構。</span><span class="sxs-lookup"><span data-stu-id="0364b-126">The TPL Dataflow Library consists of *dataflow blocks*, which are data structures that buffer and process data.</span></span> <span data-ttu-id="0364b-127">TPL 定義三種資料流程區塊：「來源區塊」、「目標區塊」和「傳播程式區塊」。</span><span class="sxs-lookup"><span data-stu-id="0364b-127">The TPL defines three kinds of dataflow blocks: *source blocks*, *target blocks*, and *propagator blocks*.</span></span> <span data-ttu-id="0364b-128">來源區塊可當做資料來源，可以從中讀取。</span><span class="sxs-lookup"><span data-stu-id="0364b-128">A source block acts as a source of data and can be read from.</span></span> <span data-ttu-id="0364b-129">目標區塊可當做資料接收器，可以寫入。</span><span class="sxs-lookup"><span data-stu-id="0364b-129">A target block acts as a receiver of data and can be written to.</span></span> <span data-ttu-id="0364b-130">傳播程式區塊可當做來源區塊和目標區塊，而且可以從中讀取和寫入。</span><span class="sxs-lookup"><span data-stu-id="0364b-130">A propagator block acts as both a source block and a target block, and can be read from and written to.</span></span> <span data-ttu-id="0364b-131">TPL 定義 <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601?displayProperty=nameWithType> 介面代表來源、<xref:System.Threading.Tasks.Dataflow.ITargetBlock%601?displayProperty=nameWithType> 代表目標，以及 <xref:System.Threading.Tasks.Dataflow.IPropagatorBlock%602?displayProperty=nameWithType> 代表傳播程式。</span><span class="sxs-lookup"><span data-stu-id="0364b-131">The TPL defines the <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601?displayProperty=nameWithType> interface to represent sources, <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601?displayProperty=nameWithType> to represent targets, and <xref:System.Threading.Tasks.Dataflow.IPropagatorBlock%602?displayProperty=nameWithType> to represent propagators.</span></span> <span data-ttu-id="0364b-132"><xref:System.Threading.Tasks.Dataflow.IPropagatorBlock%602> 繼承自 <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601> 和 <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>。</span><span class="sxs-lookup"><span data-stu-id="0364b-132"><xref:System.Threading.Tasks.Dataflow.IPropagatorBlock%602> inherits from both <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601>, and <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>.</span></span>  
  
 <span data-ttu-id="0364b-133">TPL 資料流程程式庫提供幾種預先定義的資料流程區塊類型，這些類型會實作 <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601>、<xref:System.Threading.Tasks.Dataflow.ITargetBlock%601> 和 <xref:System.Threading.Tasks.Dataflow.IPropagatorBlock%602> 介面。</span><span class="sxs-lookup"><span data-stu-id="0364b-133">The TPL Dataflow Library provides several predefined dataflow block types that implement the <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601>, <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>, and <xref:System.Threading.Tasks.Dataflow.IPropagatorBlock%602> interfaces.</span></span> <span data-ttu-id="0364b-134">本文件的[預先定義的資料流程區塊類型](#predefined-dataflow-block-types)一節描述這些資料流程區塊類型。</span><span class="sxs-lookup"><span data-stu-id="0364b-134">These dataflow block types are described in this document in the section [Predefined Dataflow Block Types](#predefined-dataflow-block-types).</span></span>  
  
### <a name="connecting-blocks"></a><span data-ttu-id="0364b-135">連接區塊</span><span class="sxs-lookup"><span data-stu-id="0364b-135">Connecting Blocks</span></span>  
 <span data-ttu-id="0364b-136">您也可以連接資料流程區塊來形成「管線」(資料流程區塊的線性序列) 或「網路」(資料流程區塊的圖形)。</span><span class="sxs-lookup"><span data-stu-id="0364b-136">You can connect dataflow blocks to form *pipelines*, which are linear sequences of dataflow blocks, or *networks*, which are graphs of dataflow blocks.</span></span> <span data-ttu-id="0364b-137">管線是網路的一種格式。</span><span class="sxs-lookup"><span data-stu-id="0364b-137">A pipeline is one form of network.</span></span> <span data-ttu-id="0364b-138">在管線或網路中，當資料可供使用時，來源會非同步散佈資料至目標。</span><span class="sxs-lookup"><span data-stu-id="0364b-138">In a pipeline or network, sources asynchronously propagate data to targets as that data becomes available.</span></span> <span data-ttu-id="0364b-139"><xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.LinkTo%2A?displayProperty=nameWithType> 方法將來源資料流程區塊連結至目標區塊。</span><span class="sxs-lookup"><span data-stu-id="0364b-139">The <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.LinkTo%2A?displayProperty=nameWithType> method links a source dataflow block to a target block.</span></span> <span data-ttu-id="0364b-140">來源可以連接至零或多個目標；目標可以從零或更多個來源連接。</span><span class="sxs-lookup"><span data-stu-id="0364b-140">A source can be linked to zero or more targets; targets can be linked from zero or more sources.</span></span> <span data-ttu-id="0364b-141">您可以同時在管線或網路中加入或移除資料流程區塊。</span><span class="sxs-lookup"><span data-stu-id="0364b-141">You can add or remove dataflow blocks to or from a pipeline or network concurrently.</span></span> <span data-ttu-id="0364b-142">預先定義的資料流程區塊類型會處理連結和取消連結的所有執行緒安全性層面。</span><span class="sxs-lookup"><span data-stu-id="0364b-142">The predefined dataflow block types handle all thread-safety aspects of linking and unlinking.</span></span>  
  
 <span data-ttu-id="0364b-143">如需連接資料流程區塊以形成基本管線的範例，請參閱[逐步解說：建立資料流程管線](walkthrough-creating-a-dataflow-pipeline.md)。</span><span class="sxs-lookup"><span data-stu-id="0364b-143">For an example that connects dataflow blocks to form a basic pipeline, see [Walkthrough: Creating a Dataflow Pipeline](walkthrough-creating-a-dataflow-pipeline.md).</span></span> <span data-ttu-id="0364b-144">如需連接資料流程區塊以形成更複雜網路的範例，請參閱[逐步解說：在 Windows Forms 應用程式中使用資料流程](walkthrough-using-dataflow-in-a-windows-forms-application.md)。</span><span class="sxs-lookup"><span data-stu-id="0364b-144">For an example that connects dataflow blocks to form a more complex network, see [Walkthrough: Using Dataflow in a Windows Forms Application](walkthrough-using-dataflow-in-a-windows-forms-application.md).</span></span> <span data-ttu-id="0364b-145">如需在來源提供目標訊息後將目標從來源取消連結的範例，請參閱[如何：取消連結資料流程區塊](how-to-unlink-dataflow-blocks.md)。</span><span class="sxs-lookup"><span data-stu-id="0364b-145">For an example that unlinks a target from a source after the source offers the target a message, see [How to: Unlink Dataflow Blocks](how-to-unlink-dataflow-blocks.md).</span></span>  
  
#### <a name="filtering"></a><span data-ttu-id="0364b-146">篩選</span><span class="sxs-lookup"><span data-stu-id="0364b-146">Filtering</span></span>  
 <span data-ttu-id="0364b-147">當您呼叫 <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.LinkTo%2A?displayProperty=nameWithType> 方法來連結來源與目標時，您可以提供委派，根據訊息值來判斷目標區塊接受或拒絕訊息。</span><span class="sxs-lookup"><span data-stu-id="0364b-147">When you call the <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.LinkTo%2A?displayProperty=nameWithType> method to link a source to a target, you can supply a delegate that determines whether the target block accepts or rejects a message based on the value of that message.</span></span> <span data-ttu-id="0364b-148">篩選機制是確保資訊流程區塊只接收特定值的實用方式。</span><span class="sxs-lookup"><span data-stu-id="0364b-148">This filtering mechanism is a useful way to guarantee that a dataflow block receives only certain values.</span></span> <span data-ttu-id="0364b-149">對於大部分預先定義的資料流程區塊類型而言，如果來源區塊連接到多個目標區塊，則當目標區塊拒絕訊息時，來源就會提供該訊息給下一個目標。</span><span class="sxs-lookup"><span data-stu-id="0364b-149">For most of the predefined dataflow block types, if a source block is connected to multiple target blocks, when a target block rejects a message, the source offers that message to the next target.</span></span> <span data-ttu-id="0364b-150">來源提供訊息給目標的順序是由該來源所定義，而且可能會根據該來源類型而有所不同。</span><span class="sxs-lookup"><span data-stu-id="0364b-150">The order in which a source offers messages to targets is defined by the source and can vary according to the type of the source.</span></span> <span data-ttu-id="0364b-151">大部分的來源區塊類型在目標接受訊息之後，就會停止提供訊息。</span><span class="sxs-lookup"><span data-stu-id="0364b-151">Most source block types stop offering a message after one target accepts that message.</span></span> <span data-ttu-id="0364b-152">此規則的唯一例外是 <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> 類別，即使有一些目標拒絕了訊息，其仍為所有目標提供每一個訊息。</span><span class="sxs-lookup"><span data-stu-id="0364b-152">One exception to this rule is the <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> class, which offers each message to all targets, even if some targets reject the message.</span></span> <span data-ttu-id="0364b-153">如需使用篩選來只處理特定訊息的範例，請參閱[逐步解說：在 Windows Forms 應用程式中使用資料流程](walkthrough-using-dataflow-in-a-windows-forms-application.md)。</span><span class="sxs-lookup"><span data-stu-id="0364b-153">For an example that uses filtering to process only certain messages, see [Walkthrough: Using Dataflow in a Windows Forms Application](walkthrough-using-dataflow-in-a-windows-forms-application.md).</span></span>  
  
> [!IMPORTANT]
> <span data-ttu-id="0364b-154">由於每個預先定義來源資料流程區塊類型確保訊息都會按照收到訊息的順序來散佈，所以每個訊息都必須由來源區塊所讀取，之後來源區塊才可處理下一個訊息。</span><span class="sxs-lookup"><span data-stu-id="0364b-154">Because each predefined source dataflow block type guarantees that messages are propagated out in the order in which they are received, every message must be read from the source block before the source block can process the next message.</span></span> <span data-ttu-id="0364b-155">因此，當您使用篩選以連接多個目標至來源時，請確定至少有一個目標區塊會接收每一個訊息。</span><span class="sxs-lookup"><span data-stu-id="0364b-155">Therefore, when you use filtering to connect multiple targets to a source, make sure that at least one target block receives each message.</span></span> <span data-ttu-id="0364b-156">否則，您的應用程式可能會發生死結。</span><span class="sxs-lookup"><span data-stu-id="0364b-156">Otherwise, your application might deadlock.</span></span>  
  
### <a name="message-passing"></a><span data-ttu-id="0364b-157">訊息傳遞</span><span class="sxs-lookup"><span data-stu-id="0364b-157">Message Passing</span></span>  
 <span data-ttu-id="0364b-158">資料流程程式設計模型與「訊息傳遞」的概念有關，其中程式的獨立元件可藉由傳送訊息相互通訊。</span><span class="sxs-lookup"><span data-stu-id="0364b-158">The dataflow programming model is related to the concept of *message passing*, where independent components of a program communicate with one another by sending messages.</span></span> <span data-ttu-id="0364b-159">在應用程式元件之間散佈訊息的其中一種方式，為呼叫 <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Post%2A> 和 <xref:System.Threading.Tasks.Dataflow.DataflowBlock.SendAsync%2A?displayProperty=nameWithType> 方法，來將訊息傳送至目標資料流程區塊通知 (<xref:System.Threading.Tasks.Dataflow.DataflowBlock.Post%2A> 會同步動作；<xref:System.Threading.Tasks.Dataflow.DataflowBlock.SendAsync%2A> 會非同步動作)，以及呼叫 <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Receive%2A>、<xref:System.Threading.Tasks.Dataflow.DataflowBlock.ReceiveAsync%2A> 和 <xref:System.Threading.Tasks.Dataflow.DataflowBlock.TryReceive%2A> 方法，以接收來自來源區塊的訊息。</span><span class="sxs-lookup"><span data-stu-id="0364b-159">One way to propagate messages among application components is to call the <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Post%2A> and <xref:System.Threading.Tasks.Dataflow.DataflowBlock.SendAsync%2A?displayProperty=nameWithType> methods to send messages to target dataflow blocks post (<xref:System.Threading.Tasks.Dataflow.DataflowBlock.Post%2A> acts synchronously; <xref:System.Threading.Tasks.Dataflow.DataflowBlock.SendAsync%2A> acts asynchronously) and the <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Receive%2A>, <xref:System.Threading.Tasks.Dataflow.DataflowBlock.ReceiveAsync%2A>, and <xref:System.Threading.Tasks.Dataflow.DataflowBlock.TryReceive%2A> methods to receive messages from source blocks.</span></span> <span data-ttu-id="0364b-160">您可以傳送輸入資料至管線的前端節點 (目標區塊)，並接收來自管線的終端節點或網路 (一個或多個來源區塊) 的終端節點之輸出資料，將這些方法結合資料流程管線或網路。</span><span class="sxs-lookup"><span data-stu-id="0364b-160">You can combine these methods with dataflow pipelines or networks by sending input data to the head node (a target block), and receiving output data from the terminal node of the pipeline or the terminal nodes of the network (one or more source blocks).</span></span> <span data-ttu-id="0364b-161">您也可以使用 <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Choose%2A> 方法，從第一個具有可用資料並在此資料中執行動作之提供的來源讀取。</span><span class="sxs-lookup"><span data-stu-id="0364b-161">You can also use the <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Choose%2A> method to read from the first of the provided sources that has data available and perform action on that data.</span></span>  
  
 <span data-ttu-id="0364b-162">來源區塊會呼叫 <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A?displayProperty=nameWithType> 方法，以提供資料給目標區塊。</span><span class="sxs-lookup"><span data-stu-id="0364b-162">Source blocks offer data to target blocks by calling the <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="0364b-163">目標區塊對於所提供的訊息會採取三種回應之一：它可以接受該訊息、拒絕該訊息或延後該訊息。</span><span class="sxs-lookup"><span data-stu-id="0364b-163">The target block responds to an offered message in one of three ways: it can accept the message, decline the message, or postpone the message.</span></span> <span data-ttu-id="0364b-164">當目標接受該訊息時，<xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> 方法會傳回 <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Accepted>。</span><span class="sxs-lookup"><span data-stu-id="0364b-164">When the target accepts the message, the <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> method returns <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Accepted>.</span></span> <span data-ttu-id="0364b-165">當目標拒絕該訊息時，<xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> 方法會傳回 <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Declined>。</span><span class="sxs-lookup"><span data-stu-id="0364b-165">When the target declines the message, the <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> method returns <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Declined>.</span></span> <span data-ttu-id="0364b-166">當目標要求不再接收來自來源的任何訊息時，<xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> 會傳回 <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus.DecliningPermanently>。</span><span class="sxs-lookup"><span data-stu-id="0364b-166">When the target requires that it no longer receives any messages from the source, <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> returns <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus.DecliningPermanently>.</span></span> <span data-ttu-id="0364b-167">在接收這類傳回值之後，以及從這類目標自動取消連結之後，預先定義的來源區塊類型就不會傳遞訊息給連結的目標。</span><span class="sxs-lookup"><span data-stu-id="0364b-167">The predefined source block types do not offer messages to linked targets after such a return value is received, and they automatically unlink from such targets.</span></span>  
  
 <span data-ttu-id="0364b-168">當目標區塊延後該訊息以供稍後使用時，<xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> 方法會傳回 <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Postponed>。</span><span class="sxs-lookup"><span data-stu-id="0364b-168">When a target block postpones the message for later use, the <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> method returns <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Postponed>.</span></span> <span data-ttu-id="0364b-169">延後訊息的目標區塊可以於稍後呼叫 <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ReserveMessage%2A?displayProperty=nameWithType> 方法，以嘗試保留所提供的訊息。</span><span class="sxs-lookup"><span data-stu-id="0364b-169">A target block that postpones a message can later call the <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ReserveMessage%2A?displayProperty=nameWithType> method to try to reserve the offered message.</span></span> <span data-ttu-id="0364b-170">此時訊息仍為可用，而且可由目標區塊所使用，或者訊息已由另一個目標所採用。</span><span class="sxs-lookup"><span data-stu-id="0364b-170">At this point, the message is either still available and can be used by the target block, or the message has been taken by another target.</span></span> <span data-ttu-id="0364b-171">當目標區塊於稍後要求此訊息，或者不再需要此訊息時，便會分別呼叫 <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ConsumeMessage%2A?displayProperty=nameWithType> 或 <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ReleaseReservation%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="0364b-171">When the target block later requires the message or no longer needs the message, it calls the <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ConsumeMessage%2A?displayProperty=nameWithType> or <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ReleaseReservation%2A> method, respectively.</span></span> <span data-ttu-id="0364b-172">訊息保留通常由在非窮盡模式下操作的資料流程區塊型別所使用。</span><span class="sxs-lookup"><span data-stu-id="0364b-172">Message reservation is typically used by the dataflow block types that operate in non-greedy mode.</span></span> <span data-ttu-id="0364b-173">本文稍後將說明非窮盡模式。</span><span class="sxs-lookup"><span data-stu-id="0364b-173">Non-greedy mode is explained later in this document.</span></span> <span data-ttu-id="0364b-174">除了保留已延後的訊息之外，目標區塊也可以使用 <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ConsumeMessage%2A?displayProperty=nameWithType> 方法，來嘗試直接使用其他延後的訊息。</span><span class="sxs-lookup"><span data-stu-id="0364b-174">Instead of reserving a postponed message, a target block can also use the <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ConsumeMessage%2A?displayProperty=nameWithType> method to attempt to directly consume the postponed message.</span></span>  
  
### <a name="dataflow-block-completion"></a><span data-ttu-id="0364b-175">資料流程區塊的完成</span><span class="sxs-lookup"><span data-stu-id="0364b-175">Dataflow Block Completion</span></span>  
 <span data-ttu-id="0364b-176">資料流程區塊也支援「完成」的概念。</span><span class="sxs-lookup"><span data-stu-id="0364b-176">Dataflow blocks also support the concept of *completion*.</span></span> <span data-ttu-id="0364b-177">在已完成狀態中的資料流程區塊並不會執行任何進一步的工作。</span><span class="sxs-lookup"><span data-stu-id="0364b-177">A dataflow block that is in the completed state does not perform any further work.</span></span> <span data-ttu-id="0364b-178">每個資料流程區塊都具有相關聯的 <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> 物件，稱為 *完成工作*，代表該區塊的完成狀態。</span><span class="sxs-lookup"><span data-stu-id="0364b-178">Each dataflow block has an associated <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> object, known as a *completion task*, that represents the completion status of the block.</span></span> <span data-ttu-id="0364b-179">由於您可以使用完成工作來等候 <xref:System.Threading.Tasks.Task> 物件結束，所以可以等候資料流程網路的一或多個終端節點完成。</span><span class="sxs-lookup"><span data-stu-id="0364b-179">Because you can wait for a <xref:System.Threading.Tasks.Task> object to finish, by using completion tasks, you can wait for one or more terminal nodes of a dataflow network to finish.</span></span> <span data-ttu-id="0364b-180"><xref:System.Threading.Tasks.Dataflow.IDataflowBlock> 介面定義了 <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete%2A> 方法，該方法會通知為其所要求的資料流程區塊完成，以及定義了 <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion%2A> 屬性，該屬性會傳回資料流程區塊的完成工作。</span><span class="sxs-lookup"><span data-stu-id="0364b-180">The <xref:System.Threading.Tasks.Dataflow.IDataflowBlock> interface defines the <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete%2A> method, which informs the dataflow block of a request for it to complete, and the <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion%2A> property, which returns the completion task for the dataflow block.</span></span> <span data-ttu-id="0364b-181"><xref:System.Threading.Tasks.Dataflow.ISourceBlock%601> 和 <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601> 這兩者都是繼承自 <xref:System.Threading.Tasks.Dataflow.IDataflowBlock> 介面。</span><span class="sxs-lookup"><span data-stu-id="0364b-181">Both <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601> and <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601> inherit the <xref:System.Threading.Tasks.Dataflow.IDataflowBlock> interface.</span></span>  
  
 <span data-ttu-id="0364b-182">有兩種方式用來判斷資料流程區塊是否完成而沒有錯誤，還是遇到一或多個錯誤或已取消。</span><span class="sxs-lookup"><span data-stu-id="0364b-182">There are two ways to determine whether a dataflow block completed without error, encountered one or more errors, or was canceled.</span></span> <span data-ttu-id="0364b-183">第一種方式為在 `try`-`catch` 區塊 (在 Visual Basic 中為 `Try`-`Catch`) 中的完成工作上呼叫 <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="0364b-183">The first way is to call the <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> method on the completion task in a `try`-`catch` block (`Try`-`Catch` in Visual Basic).</span></span> <span data-ttu-id="0364b-184">下列範例會建立一個會在其輸入值小於零時擲回 <xref:System.ArgumentOutOfRangeException> 的 <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> 物件。</span><span class="sxs-lookup"><span data-stu-id="0364b-184">The following example creates an <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> object that throws <xref:System.ArgumentOutOfRangeException> if its input value is less than zero.</span></span> <span data-ttu-id="0364b-185">當這個範例呼叫完成工作上的 <xref:System.Threading.Tasks.Task.Wait%2A> 時，會擲回 <xref:System.AggregateException>。</span><span class="sxs-lookup"><span data-stu-id="0364b-185"><xref:System.AggregateException> is thrown when this example calls <xref:System.Threading.Tasks.Task.Wait%2A> on the completion task.</span></span> <span data-ttu-id="0364b-186">可透過 <xref:System.AggregateException> 物件的 <xref:System.AggregateException.InnerExceptions%2A> 屬性存取 <xref:System.ArgumentOutOfRangeException>。</span><span class="sxs-lookup"><span data-stu-id="0364b-186">The <xref:System.ArgumentOutOfRangeException> is accessed through the <xref:System.AggregateException.InnerExceptions%2A> property of the <xref:System.AggregateException> object.</span></span>  
  
 [!code-csharp[TPLDataflow_Overview#10](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#10)]
 [!code-vb[TPLDataflow_Overview#10](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#10)]  
  
 <span data-ttu-id="0364b-187">這個範例示範在執行資料流程區塊的委派中有例外狀況未受處理的案例。</span><span class="sxs-lookup"><span data-stu-id="0364b-187">This example demonstrates the case in which an exception goes unhandled in the delegate of an execution dataflow block.</span></span> <span data-ttu-id="0364b-188">建議您在這類區塊的主體中處理例外狀況。</span><span class="sxs-lookup"><span data-stu-id="0364b-188">We recommend that you handle exceptions in the bodies of such blocks.</span></span> <span data-ttu-id="0364b-189">然而，假如您無法這樣做，區塊會表現得就像已經取消，而不會處理傳入的訊息。</span><span class="sxs-lookup"><span data-stu-id="0364b-189">However, if you are unable to do so, the block behaves as though it was canceled and does not process incoming messages.</span></span>  
  
 <span data-ttu-id="0364b-190">當資料流程區塊已明確地取消時，<xref:System.AggregateException> 物件包含 <xref:System.AggregateException.InnerExceptions%2A> 屬性中的 <xref:System.OperationCanceledException>。</span><span class="sxs-lookup"><span data-stu-id="0364b-190">When a dataflow block is canceled explicitly, the <xref:System.AggregateException> object contains <xref:System.OperationCanceledException> in the <xref:System.AggregateException.InnerExceptions%2A> property.</span></span> <span data-ttu-id="0364b-191">如需取消資料流程的詳細資訊，請參閱[啟用取消](#enabling-cancellation)一節。</span><span class="sxs-lookup"><span data-stu-id="0364b-191">For more information about dataflow cancellation, see [Enabling Cancellation](#enabling-cancellation) section.</span></span>  
  
 <span data-ttu-id="0364b-192">第二種判斷資料流程區塊完成狀態的方式為使用此完成工作的接續，或使用 C# 和 Visual Basic 的非同步語言功能來非同步等候此完成工作。</span><span class="sxs-lookup"><span data-stu-id="0364b-192">The second way to determine the completion status of a dataflow block is to use a continuation of the completion task, or to use the asynchronous language features of C# and Visual Basic to asynchronously wait for the completion task.</span></span> <span data-ttu-id="0364b-193">您提供給 <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> 方法的委派會採用代表前項工作的 <xref:System.Threading.Tasks.Task> 物件。</span><span class="sxs-lookup"><span data-stu-id="0364b-193">The delegate that you provide to the <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> method takes a <xref:System.Threading.Tasks.Task> object that represents the antecedent task.</span></span> <span data-ttu-id="0364b-194">在 <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion%2A> 屬性的案例中，接續的委派本身會採用完成工作。</span><span class="sxs-lookup"><span data-stu-id="0364b-194">In the case of the <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion%2A> property, the delegate for the continuation takes the completion task itself.</span></span> <span data-ttu-id="0364b-195">下列範例與上一則範例很相似，不同之處在於它也會使用 <xref:System.Threading.Tasks.Task.ContinueWith%2A> 方法建立會列印整個資料流程作業狀態的接續工作。</span><span class="sxs-lookup"><span data-stu-id="0364b-195">The following example resembles the previous one, except that it also uses the <xref:System.Threading.Tasks.Task.ContinueWith%2A> method to create a continuation task that prints the status of the overall dataflow operation.</span></span>  
  
 [!code-csharp[TPLDataflow_Overview#11](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#11)]
 [!code-vb[TPLDataflow_Overview#11](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#11)]  
  
 <span data-ttu-id="0364b-196">您也可以使用在接續工作主體中的屬性 (例如 <xref:System.Threading.Tasks.Task.IsCanceled%2A>)，判斷資料流程區塊完成狀態中的其他資訊。</span><span class="sxs-lookup"><span data-stu-id="0364b-196">You can also use properties such as <xref:System.Threading.Tasks.Task.IsCanceled%2A> in the body of the continuation task to determine additional information about the completion status of a dataflow block.</span></span> <span data-ttu-id="0364b-197">如需接續工作及其與取消跟錯誤處理之關聯的詳細資訊，請參閱[使用接續工作鏈結工作](chaining-tasks-by-using-continuation-tasks.md)、[工作取消](task-cancellation.md)和[例外狀況處理](exception-handling-task-parallel-library.md)。</span><span class="sxs-lookup"><span data-stu-id="0364b-197">For more information about continuation tasks and how they relate to cancellation and error handling, see [Chaining Tasks by Using Continuation Tasks](chaining-tasks-by-using-continuation-tasks.md), [Task Cancellation](task-cancellation.md), and [Exception Handling](exception-handling-task-parallel-library.md).</span></span>  

## <a name="predefined-dataflow-block-types"></a><span data-ttu-id="0364b-198">預先定義的資料流程區塊類型</span><span class="sxs-lookup"><span data-stu-id="0364b-198">Predefined Dataflow Block Types</span></span>  
 <span data-ttu-id="0364b-199">TPL 資料流程程式庫提供幾種預先定義的資料流程區塊類型。</span><span class="sxs-lookup"><span data-stu-id="0364b-199">The TPL Dataflow Library provides several predefined dataflow block types.</span></span> <span data-ttu-id="0364b-200">這些類型分為三類：「緩衝區塊」、「執行區塊」和「群組區塊」。</span><span class="sxs-lookup"><span data-stu-id="0364b-200">These types are divided into three categories: *buffering blocks*, *execution blocks*, and *grouping blocks*.</span></span> <span data-ttu-id="0364b-201">下列章節描述組成這些類別的區塊類型。</span><span class="sxs-lookup"><span data-stu-id="0364b-201">The following sections describe the block types that make up these categories.</span></span>  
  
### <a name="buffering-blocks"></a><span data-ttu-id="0364b-202">緩衝區塊</span><span class="sxs-lookup"><span data-stu-id="0364b-202">Buffering Blocks</span></span>  
 <span data-ttu-id="0364b-203">緩衝區塊保存供資料消費者使用的資料。</span><span class="sxs-lookup"><span data-stu-id="0364b-203">Buffering blocks hold data for use by data consumers.</span></span> <span data-ttu-id="0364b-204">TPL 資料流程程式庫提供三個緩衝區塊類型：<xref:System.Threading.Tasks.Dataflow.BufferBlock%601?displayProperty=nameWithType>、<xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601?displayProperty=nameWithType> 和 <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="0364b-204">The TPL Dataflow Library provides three buffering block types: <xref:System.Threading.Tasks.Dataflow.BufferBlock%601?displayProperty=nameWithType>, <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601?displayProperty=nameWithType>, and <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601?displayProperty=nameWithType>.</span></span>  
  
#### <a name="bufferblockt"></a><span data-ttu-id="0364b-205">BufferBlock(T)</span><span class="sxs-lookup"><span data-stu-id="0364b-205">BufferBlock(T)</span></span>  
 <span data-ttu-id="0364b-206"><xref:System.Threading.Tasks.Dataflow.BufferBlock%601> 類別代表一般用途的非同步傳訊結構。</span><span class="sxs-lookup"><span data-stu-id="0364b-206">The <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> class represents a general-purpose asynchronous messaging structure.</span></span> <span data-ttu-id="0364b-207">這個類別會儲存可由多個來源寫入或由多個目標讀取之訊息的先進先出 (FIFO) 佇列。</span><span class="sxs-lookup"><span data-stu-id="0364b-207">This class stores a first in, first out (FIFO) queue of messages that can be written to by multiple sources or read from by multiple targets.</span></span> <span data-ttu-id="0364b-208">當目標從 <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> 物件接收到訊息時，就會從訊息佇列中移除該訊息。</span><span class="sxs-lookup"><span data-stu-id="0364b-208">When a target receives a message from a <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> object, that message is removed from the message queue.</span></span> <span data-ttu-id="0364b-209">因此，雖然 <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> 物件可以具有多個目標，只有一個目標會接收到每則訊息。</span><span class="sxs-lookup"><span data-stu-id="0364b-209">Therefore, although a <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> object can have multiple targets, only one target will receive each message.</span></span> <span data-ttu-id="0364b-210">當您想要將多則訊息傳遞給其他元件，而且該元件必須接收每則訊息時，<xref:System.Threading.Tasks.Dataflow.BufferBlock%601> 類別就很有用。</span><span class="sxs-lookup"><span data-stu-id="0364b-210">The <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> class is useful when you want to pass multiple messages to another component, and that component must receive each message.</span></span>  
  
 <span data-ttu-id="0364b-211">下列基本範例會張貼數個 <xref:System.Int32> 值至 <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> 物件，接著從該物件讀取這些值。</span><span class="sxs-lookup"><span data-stu-id="0364b-211">The following basic example posts several <xref:System.Int32> values to a <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> object and then reads those values back from that object.</span></span>  
  
 [!code-csharp[TPLDataflow_Overview#1](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#1)]
 [!code-vb[TPLDataflow_Overview#1](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#1)]  
  
 <span data-ttu-id="0364b-212">如需示範如何撰寫訊息到 <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> 物件，並從其中讀取訊息的完整範例，請參閱[如何：寫入訊息至資料流程區塊及讀取資料流程區塊中的訊息](how-to-write-messages-to-and-read-messages-from-a-dataflow-block.md)。</span><span class="sxs-lookup"><span data-stu-id="0364b-212">For a complete example that demonstrates how to write messages to and read messages from a <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> object, see [How to: Write Messages to and Read Messages from a Dataflow Block](how-to-write-messages-to-and-read-messages-from-a-dataflow-block.md).</span></span>  
  
#### <a name="broadcastblockt"></a><span data-ttu-id="0364b-213">BroadcastBlock(T)</span><span class="sxs-lookup"><span data-stu-id="0364b-213">BroadcastBlock(T)</span></span>  
 <span data-ttu-id="0364b-214">當您需要將多則訊息傳遞給其他元件，但是該元件只需要最新的值時，<xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> 類別就很有用。</span><span class="sxs-lookup"><span data-stu-id="0364b-214">The <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> class is useful when you must pass multiple messages to another component, but that component needs only the most recent value.</span></span> <span data-ttu-id="0364b-215">當您想要將訊息廣播至多個元件時，這個類別也很有用。</span><span class="sxs-lookup"><span data-stu-id="0364b-215">This class is also useful when you want to broadcast a message to multiple components.</span></span>  
  
 <span data-ttu-id="0364b-216">下列基本範例會將 <xref:System.Double> 值傳遞至 <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> 物件，然後從該物件讀取該值數次。</span><span class="sxs-lookup"><span data-stu-id="0364b-216">The following basic example posts a <xref:System.Double> value to a <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> object and then reads that value back from that object several times.</span></span> <span data-ttu-id="0364b-217">因為在已讀取值之後並不會從 <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> 物件中移除這些值，所以每次可用此相同的值。</span><span class="sxs-lookup"><span data-stu-id="0364b-217">Because values are not removed from <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> objects after they are read, the same value is available every time.</span></span>  
  
 [!code-csharp[TPLDataflow_Overview#2](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#2)]
 [!code-vb[TPLDataflow_Overview#2](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#2)]  
  
 <span data-ttu-id="0364b-218">如需示範如何使用 <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> 來將訊息廣播到多個目標區塊的完整範例，請參閱[如何：在資料流程區塊中指定工作排程器](how-to-specify-a-task-scheduler-in-a-dataflow-block.md)。</span><span class="sxs-lookup"><span data-stu-id="0364b-218">For a complete example that demonstrates how to use <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> to broadcast a message to multiple target blocks, see [How to: Specify a Task Scheduler in a Dataflow Block](how-to-specify-a-task-scheduler-in-a-dataflow-block.md).</span></span>  
  
#### <a name="writeonceblockt"></a><span data-ttu-id="0364b-219">WriteOnceBlock(T)</span><span class="sxs-lookup"><span data-stu-id="0364b-219">WriteOnceBlock(T)</span></span>  
 <span data-ttu-id="0364b-220"><xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> 類別類似於 <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> 類別，但是 <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> 物件只能被寫入一次。</span><span class="sxs-lookup"><span data-stu-id="0364b-220">The <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> class resembles the <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> class, except that a <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> object can be written to one time only.</span></span> <span data-ttu-id="0364b-221">您可以將 <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> 視為類似 C# [readonly](../../csharp/language-reference/keywords/readonly.md) (在 Visual Basic 中為 [ReadOnly](../../visual-basic/language-reference/modifiers/readonly.md)) 關鍵字，不過當 <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> 物件接收到值 (而非建構) 時，它就會變成不可變。</span><span class="sxs-lookup"><span data-stu-id="0364b-221">You can think of <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> as being similar to the C# [readonly](../../csharp/language-reference/keywords/readonly.md) ([ReadOnly](../../visual-basic/language-reference/modifiers/readonly.md) in Visual Basic) keyword, except that a <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> object becomes immutable after it receives a value instead of at construction.</span></span> <span data-ttu-id="0364b-222">與 <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> 類別相同的是，當目標從 <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> 物件收到訊息時，並不會從此物件中移除該訊息。</span><span class="sxs-lookup"><span data-stu-id="0364b-222">Like the <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> class, when a target receives a message from a <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> object, that message is not removed from that object.</span></span> <span data-ttu-id="0364b-223">因此，多個目標會接收此訊息的複本。</span><span class="sxs-lookup"><span data-stu-id="0364b-223">Therefore, multiple targets receive a copy of the message.</span></span> <span data-ttu-id="0364b-224">當您只想要散佈眾多訊息中的第一個時，<xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> 類別會很有用。</span><span class="sxs-lookup"><span data-stu-id="0364b-224">The <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> class is useful when you want to propagate only the first of multiple messages.</span></span>  
  
 <span data-ttu-id="0364b-225">下列基本範例傳遞多個 <xref:System.String> 值至 <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> 物件，然後從該物件讀取值。</span><span class="sxs-lookup"><span data-stu-id="0364b-225">The following basic example posts multiple <xref:System.String> values to a <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> object and then reads the value back from that object.</span></span> <span data-ttu-id="0364b-226">由於 <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> 物件只能被寫入一次，所以 <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> 物件接收到訊息之後，就會捨棄後續訊息。</span><span class="sxs-lookup"><span data-stu-id="0364b-226">Because a <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> object can be written to one time only, after a <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> object receives a message, it discards subsequent messages.</span></span>  
  
 [!code-csharp[TPLDataflow_Overview#3](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#3)]
 [!code-vb[TPLDataflow_Overview#3](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#3)]  
  
 <span data-ttu-id="0364b-227">如需示範如何使用 <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> 接收第一個結束作業之值的完整範例，請參閱[如何：取消連結資料流程區塊](how-to-unlink-dataflow-blocks.md)。</span><span class="sxs-lookup"><span data-stu-id="0364b-227">For a complete example that demonstrates how to use <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> to receive the value of the first operation that finishes, see [How to: Unlink Dataflow Blocks](how-to-unlink-dataflow-blocks.md).</span></span>  
  
### <a name="execution-blocks"></a><span data-ttu-id="0364b-228">執行區塊</span><span class="sxs-lookup"><span data-stu-id="0364b-228">Execution Blocks</span></span>  
 <span data-ttu-id="0364b-229">執行區塊會為已接受資料的每個部分呼叫使用者提供的委派。</span><span class="sxs-lookup"><span data-stu-id="0364b-229">Execution blocks call a user-provided delegate for each piece of received data.</span></span> <span data-ttu-id="0364b-230">TPL 資料流程程式庫提供三個執行區塊類型：<xref:System.Threading.Tasks.Dataflow.ActionBlock%601>、<xref:System.Threading.Tasks.Dataflow.TransformBlock%602?displayProperty=nameWithType> 和 <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="0364b-230">The TPL Dataflow Library provides three execution block types: <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602?displayProperty=nameWithType>, and <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602?displayProperty=nameWithType>.</span></span>  
  
#### <a name="actionblockt"></a><span data-ttu-id="0364b-231">ActionBlock(T)</span><span class="sxs-lookup"><span data-stu-id="0364b-231">ActionBlock(T)</span></span>  
 <span data-ttu-id="0364b-232"><xref:System.Threading.Tasks.Dataflow.ActionBlock%601> 類別是在接收到資料時呼叫委派的目標區塊。</span><span class="sxs-lookup"><span data-stu-id="0364b-232">The <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> class is a target block that calls a delegate when it receives data.</span></span> <span data-ttu-id="0364b-233">可將 <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> 物件視為在資料可用時會非同步執行的委派。</span><span class="sxs-lookup"><span data-stu-id="0364b-233">Think of a <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> object as a delegate that runs asynchronously when data becomes available.</span></span> <span data-ttu-id="0364b-234">您提供給 <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> 物件的委派可以是 <xref:System.Action%601> 類型或 `System.Func<TInput, Task>` 類型。</span><span class="sxs-lookup"><span data-stu-id="0364b-234">The delegate that you provide to an <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> object can be of type <xref:System.Action%601> or type `System.Func<TInput, Task>`.</span></span> <span data-ttu-id="0364b-235">當您搭配 <xref:System.Action%601> 使用 <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> 物件時，會將每個輸入項目的處理在委派傳回時視為完成。</span><span class="sxs-lookup"><span data-stu-id="0364b-235">When you use an <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> object with <xref:System.Action%601>, processing of each input element is considered completed when the delegate returns.</span></span> <span data-ttu-id="0364b-236">當您搭配 `System.Func<TInput, Task>` 使用 <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> 物件時，只有在傳回的 <xref:System.Threading.Tasks.Task> 物件已完成時，才會將每個輸入項目的處理視為已完成。</span><span class="sxs-lookup"><span data-stu-id="0364b-236">When you use an <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> object with `System.Func<TInput, Task>`, processing of each input element is considered completed only when the returned <xref:System.Threading.Tasks.Task> object is completed.</span></span> <span data-ttu-id="0364b-237">使用這兩種機制，您可以使用 <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> 為每個輸入項目作同步與非同步處理。</span><span class="sxs-lookup"><span data-stu-id="0364b-237">By using these two mechanisms, you can use <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> for both synchronous and asynchronous processing of each input element.</span></span>  
  
 <span data-ttu-id="0364b-238">下列基本範例會張貼多個 <xref:System.Int32> 值到 <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> 物件。</span><span class="sxs-lookup"><span data-stu-id="0364b-238">The following basic example posts multiple <xref:System.Int32> values to an <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> object.</span></span> <span data-ttu-id="0364b-239"><xref:System.Threading.Tasks.Dataflow.ActionBlock%601> 物件會列印這些值到主控台。</span><span class="sxs-lookup"><span data-stu-id="0364b-239">The <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> object prints those values to the console.</span></span> <span data-ttu-id="0364b-240">這個範例接著會設定此區塊為完成狀態，並等候所有資料流程工作完成。</span><span class="sxs-lookup"><span data-stu-id="0364b-240">This example then sets the block to the completed state and waits for all dataflow tasks to finish.</span></span>  
  
 [!code-csharp[TPLDataflow_Overview#4](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#4)]
 [!code-vb[TPLDataflow_Overview#4](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#4)]  
  
 <span data-ttu-id="0364b-241">如需示範如何使用具有 <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> 類別之委派的完整範例，請參閱[如何：在資料流程區塊收到資料時執行動作](how-to-perform-action-when-a-dataflow-block-receives-data.md)。</span><span class="sxs-lookup"><span data-stu-id="0364b-241">For complete examples that demonstrate how to use delegates with the <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> class, see [How to: Perform Action When a Dataflow Block Receives Data](how-to-perform-action-when-a-dataflow-block-receives-data.md).</span></span>  
  
#### <a name="transformblocktinput-toutput"></a><span data-ttu-id="0364b-242">TransformBlock(TInput, TOutput)</span><span class="sxs-lookup"><span data-stu-id="0364b-242">TransformBlock(TInput, TOutput)</span></span>  
 <span data-ttu-id="0364b-243"><xref:System.Threading.Tasks.Dataflow.TransformBlock%602> 類別類似於 <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> 類別，不同處在於它可同時作為來源和目標。</span><span class="sxs-lookup"><span data-stu-id="0364b-243">The <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> class resembles the <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> class, except that it acts as both a source and as a target.</span></span> <span data-ttu-id="0364b-244">您傳遞給 <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> 物件的委派會傳回類型 `TOutput` 的值。</span><span class="sxs-lookup"><span data-stu-id="0364b-244">The delegate that you pass to a <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> object returns a value of type `TOutput`.</span></span> <span data-ttu-id="0364b-245">您提供給 <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> 物件的委派可以是類型 `System.Func<TInput, TOutput>` 或類型 `System.Func<TInput, Task<TOutput>>`。</span><span class="sxs-lookup"><span data-stu-id="0364b-245">The delegate that you provide to a <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> object can be of type `System.Func<TInput, TOutput>` or type `System.Func<TInput, Task<TOutput>>`.</span></span> <span data-ttu-id="0364b-246">當您搭配 `System.Func<TInput, TOutput>` 使用 <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> 物件時，會將每個輸入項目的處理在委派傳回時視為完成。</span><span class="sxs-lookup"><span data-stu-id="0364b-246">When you use a <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> object with `System.Func<TInput, TOutput>`, processing of each input element is considered completed when the delegate returns.</span></span> <span data-ttu-id="0364b-247">當您搭配 `System.Func<TInput, Task<TOutput>>` 使用 <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> 物件時，只有在傳回的 <xref:System.Threading.Tasks.Task%601> 物件已完成時，才會將每個輸入項目的處理視為已完成。</span><span class="sxs-lookup"><span data-stu-id="0364b-247">When you use a <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> object used with `System.Func<TInput, Task<TOutput>>`, processing of each input element is considered completed only when the returned <xref:System.Threading.Tasks.Task%601> object is completed.</span></span> <span data-ttu-id="0364b-248">如同 <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>，使用這兩種機制，您就可以使用 <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> 為每個輸入項目作同步與非同步處理。</span><span class="sxs-lookup"><span data-stu-id="0364b-248">As with <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, by using these two mechanisms, you can use <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> for both synchronous and asynchronous processing of each input element.</span></span>  
  
 <span data-ttu-id="0364b-249">下列基本範例會建立 <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> 物件，該物件會計算其輸入的平方根。</span><span class="sxs-lookup"><span data-stu-id="0364b-249">The following basic example creates a <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> object that computes the square root of its input.</span></span> <span data-ttu-id="0364b-250"><xref:System.Threading.Tasks.Dataflow.TransformBlock%602> 物件會使用 <xref:System.Int32> 值做為輸入，並產生 <xref:System.Double> 值做為輸出。</span><span class="sxs-lookup"><span data-stu-id="0364b-250">The <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> object takes <xref:System.Int32> values as input and produces <xref:System.Double> values as output.</span></span>  
  
 [!code-csharp[TPLDataflow_Overview#5](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#5)]
 [!code-vb[TPLDataflow_Overview#5](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#5)]  
  
 <span data-ttu-id="0364b-251">如需在於 Windows Forms 應用程式中執行影像處理的資料流程區塊網路中使用 <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> 的完整範例，請參閱[逐步解說：在 Windows Forms 應用程式中使用資料流程](walkthrough-using-dataflow-in-a-windows-forms-application.md)。</span><span class="sxs-lookup"><span data-stu-id="0364b-251">For complete examples that uses <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> in a network of dataflow blocks that performs image processing in a Windows Forms application, see [Walkthrough: Using Dataflow in a Windows Forms Application](walkthrough-using-dataflow-in-a-windows-forms-application.md).</span></span>  
  
#### <a name="transformmanyblocktinput-toutput"></a><span data-ttu-id="0364b-252">TransformManyBlock(TInput, TOutput)</span><span class="sxs-lookup"><span data-stu-id="0364b-252">TransformManyBlock(TInput, TOutput)</span></span>  
 <span data-ttu-id="0364b-253"><xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> 類別相似於 <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> 類別，不同處在於 <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> 對每個輸入值會產生零或多個輸出值，而不是只有一個。</span><span class="sxs-lookup"><span data-stu-id="0364b-253">The <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> class resembles the <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> class, except that <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> produces zero or more output values for each input value, instead of only one output value for each input value.</span></span> <span data-ttu-id="0364b-254">您提供給 <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> 物件的委派可以是類型 `System.Func<TInput, IEnumerable<TOutput>>` 或類型 `System.Func<TInput, Task<IEnumerable<TOutput>>>`。</span><span class="sxs-lookup"><span data-stu-id="0364b-254">The delegate that you provide to a <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> object can be of type `System.Func<TInput, IEnumerable<TOutput>>` or type `System.Func<TInput, Task<IEnumerable<TOutput>>>`.</span></span> <span data-ttu-id="0364b-255">當您搭配 `System.Func<TInput, IEnumerable<TOutput>>` 使用 <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> 物件時，會將每個輸入項目的處理在委派傳回時視為完成。</span><span class="sxs-lookup"><span data-stu-id="0364b-255">When you use a <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> object with `System.Func<TInput, IEnumerable<TOutput>>`, processing of each input element is considered completed when the delegate returns.</span></span> <span data-ttu-id="0364b-256">當您搭配 `System.Func<TInput, Task<IEnumerable<TOutput>>>` 使用 <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> 物件時，只有在傳回的 `System.Threading.Tasks.Task<IEnumerable<TOutput>>` 物件已完成時，才會將每個輸入項目的處理視為已完成。</span><span class="sxs-lookup"><span data-stu-id="0364b-256">When you use a <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> object with `System.Func<TInput, Task<IEnumerable<TOutput>>>`, processing of each input element is considered complete only when the returned `System.Threading.Tasks.Task<IEnumerable<TOutput>>` object is completed.</span></span>  
  
 <span data-ttu-id="0364b-257">下列基本範例會建立 <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> 物件，該物件會將字串分割成獨立字元的序列。</span><span class="sxs-lookup"><span data-stu-id="0364b-257">The following basic example creates a <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> object that splits strings into their individual character sequences.</span></span> <span data-ttu-id="0364b-258"><xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> 物件會使用 <xref:System.String> 值做為輸入，並產生 <xref:System.Char> 值做為輸出。</span><span class="sxs-lookup"><span data-stu-id="0364b-258">The <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> object takes <xref:System.String> values as input and produces <xref:System.Char> values as output.</span></span>  
  
 [!code-csharp[TPLDataflow_Overview#6](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#6)]
 [!code-vb[TPLDataflow_Overview#6](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#6)]  
  
 <span data-ttu-id="0364b-259">如需使用 <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> 為資料流程管線中的每個輸入產生多組獨立輸出的完整範例，請參閱[逐步解說：建立資料流程管線](walkthrough-creating-a-dataflow-pipeline.md)。</span><span class="sxs-lookup"><span data-stu-id="0364b-259">For complete examples that use <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> to produce multiple independent outputs for each input in a dataflow pipeline, see [Walkthrough: Creating a Dataflow Pipeline](walkthrough-creating-a-dataflow-pipeline.md).</span></span>  
  
#### <a name="degree-of-parallelism"></a><span data-ttu-id="0364b-260">平行處理原則的程度</span><span class="sxs-lookup"><span data-stu-id="0364b-260">Degree of Parallelism</span></span>  
 <span data-ttu-id="0364b-261">每個 <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>、<xref:System.Threading.Tasks.Dataflow.TransformBlock%602>和 <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> 物件會緩衝輸入訊息，直到此區塊已準備好處理它們。</span><span class="sxs-lookup"><span data-stu-id="0364b-261">Every <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>, and <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> object buffers input messages until the block is ready to process them.</span></span> <span data-ttu-id="0364b-262">這些類別預設會按照接收到訊息的順序，一次處理一個訊息。</span><span class="sxs-lookup"><span data-stu-id="0364b-262">By default, these classes process messages in the order in which they are received, one message at a time.</span></span> <span data-ttu-id="0364b-263">您也可以指定平行處理原則的刻度以啟動 <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>、<xref:System.Threading.Tasks.Dataflow.TransformBlock%602> 和 <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> 物件同時處理多個訊息。</span><span class="sxs-lookup"><span data-stu-id="0364b-263">You can also specify the degree of parallelism to enable <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> and <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> objects to process multiple messages concurrently.</span></span> <span data-ttu-id="0364b-264">如需同時執行的詳細資訊，請參閱本文稍後的＜指定平行處理原則的刻度＞一節。</span><span class="sxs-lookup"><span data-stu-id="0364b-264">For more information about concurrent execution, see the section Specifying the Degree of Parallelism later in this document.</span></span> <span data-ttu-id="0364b-265">如需設定平行處理原則的刻度，讓執行資料流程區塊一次可處理一個以上訊息的範例，請參閱[如何：在資料流程區塊中指定平行處理原則的刻度](how-to-specify-the-degree-of-parallelism-in-a-dataflow-block.md)。</span><span class="sxs-lookup"><span data-stu-id="0364b-265">For an example that sets the degree of parallelism to enable an execution dataflow block to process more than one message at a time, see [How to: Specify the Degree of Parallelism in a Dataflow Block](how-to-specify-the-degree-of-parallelism-in-a-dataflow-block.md).</span></span>  
  
#### <a name="summary-of-delegate-types"></a><span data-ttu-id="0364b-266">委派類型摘要</span><span class="sxs-lookup"><span data-stu-id="0364b-266">Summary of Delegate Types</span></span>  
 <span data-ttu-id="0364b-267">下表摘要說明您可以提供給 <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>、<xref:System.Threading.Tasks.Dataflow.TransformBlock%602> 和 <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> 物件的委派類型。</span><span class="sxs-lookup"><span data-stu-id="0364b-267">The following table summarizes the delegate types that you can provide to <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>, and <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> objects.</span></span> <span data-ttu-id="0364b-268">表中也會指出委派類型是以同步或非同步方式運作。</span><span class="sxs-lookup"><span data-stu-id="0364b-268">This table also specifies whether the delegate type operates synchronously or asynchronously.</span></span>  
  
|<span data-ttu-id="0364b-269">類型</span><span class="sxs-lookup"><span data-stu-id="0364b-269">Type</span></span>|<span data-ttu-id="0364b-270">同步委派類型</span><span class="sxs-lookup"><span data-stu-id="0364b-270">Synchronous Delegate Type</span></span>|<span data-ttu-id="0364b-271">非同步委派類型</span><span class="sxs-lookup"><span data-stu-id="0364b-271">Asynchronous Delegate Type</span></span>|  
|----------|-------------------------------|--------------------------------|  
|<xref:System.Threading.Tasks.Dataflow.ActionBlock%601>|`System.Action`|`System.Func<TInput, Task>`|  
|<xref:System.Threading.Tasks.Dataflow.TransformBlock%602>|`System.Func<TInput, TOutput>`|`System.Func<TInput, Task<TOutput>>`|  
|<xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>|`System.Func<TInput, IEnumerable<TOutput>>`|`System.Func<TInput, Task<IEnumerable<TOutput>>>`|  
  
 <span data-ttu-id="0364b-272">當您使用執行區塊類型時，也可以使用 Lambda 運算式。</span><span class="sxs-lookup"><span data-stu-id="0364b-272">You can also use lambda expressions when you work with execution block types.</span></span> <span data-ttu-id="0364b-273">如需示範如何使用 Lambda 運算式搭配執行區塊的範例，請參閱[如何：在資料流程區塊收到資料時執行動作](how-to-perform-action-when-a-dataflow-block-receives-data.md)。</span><span class="sxs-lookup"><span data-stu-id="0364b-273">For an example that shows how to use a lambda expression with an execution block, see [How to: Perform Action When a Dataflow Block Receives Data](how-to-perform-action-when-a-dataflow-block-receives-data.md).</span></span>  
  
### <a name="grouping-blocks"></a><span data-ttu-id="0364b-274">群組區塊</span><span class="sxs-lookup"><span data-stu-id="0364b-274">Grouping Blocks</span></span>  
 <span data-ttu-id="0364b-275">群組區塊合併來自一個或多個來源、以及在各種條件約束下的資料。</span><span class="sxs-lookup"><span data-stu-id="0364b-275">Grouping blocks combine data from one or more sources and under various constraints.</span></span> <span data-ttu-id="0364b-276">TPL 資料流程式庫提供三個聯結區塊類型：<xref:System.Threading.Tasks.Dataflow.BatchBlock%601>、<xref:System.Threading.Tasks.Dataflow.JoinBlock%602> 和 <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602>。</span><span class="sxs-lookup"><span data-stu-id="0364b-276">The TPL Dataflow Library provides three join block types: <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>, <xref:System.Threading.Tasks.Dataflow.JoinBlock%602>, and <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602>.</span></span>  
  
#### <a name="batchblockt"></a><span data-ttu-id="0364b-277">BatchBlock(T)</span><span class="sxs-lookup"><span data-stu-id="0364b-277">BatchBlock(T)</span></span>  
 <span data-ttu-id="0364b-278"><xref:System.Threading.Tasks.Dataflow.BatchBlock%601> 類別將稱為批次的輸入資料集合併為輸出資料陣列。</span><span class="sxs-lookup"><span data-stu-id="0364b-278">The <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> class combines sets of input data, which are known as batches, into arrays of output data.</span></span> <span data-ttu-id="0364b-279">在建立 <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> 物件時，請指定每一批次的大小。</span><span class="sxs-lookup"><span data-stu-id="0364b-279">You specify the size of each batch when you create a <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> object.</span></span> <span data-ttu-id="0364b-280">當 <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> 物件接收指定的輸入項目計數時，會非同步散佈包含這些項目的陣列。</span><span class="sxs-lookup"><span data-stu-id="0364b-280">When the <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> object receives the specified count of input elements, it asynchronously propagates out an array that contains those elements.</span></span> <span data-ttu-id="0364b-281">如果 <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> 物件設定為完成狀態，但未包含足夠構成批次的項目，則會散佈包含剩餘輸入項目的最後一個陣列。</span><span class="sxs-lookup"><span data-stu-id="0364b-281">If a <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> object is set to the completed state but does not contain enough elements to form a batch, it propagates out a final array that contains the remaining input elements.</span></span>  
  
 <span data-ttu-id="0364b-282"><xref:System.Threading.Tasks.Dataflow.BatchBlock%601> 類別會在 *窮盡* 或 *非窮盡* 模式下運作。</span><span class="sxs-lookup"><span data-stu-id="0364b-282">The <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> class operates in either *greedy* or *non-greedy* mode.</span></span> <span data-ttu-id="0364b-283">在窮盡模式 (這是預設值)，<xref:System.Threading.Tasks.Dataflow.BatchBlock%601> 物件接受每則提供的訊息，並在接收指定的項目計數後散佈陣列。</span><span class="sxs-lookup"><span data-stu-id="0364b-283">In greedy mode, which is the default, a <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> object accepts every message that it is offered and propagates out an array after it receives the specified count of elements.</span></span> <span data-ttu-id="0364b-284">在非窮盡模式，<xref:System.Threading.Tasks.Dataflow.BatchBlock%601> 物件延後所有傳入訊息，直到來源提供給區塊的訊息足以形成批次。</span><span class="sxs-lookup"><span data-stu-id="0364b-284">In non-greedy mode, a <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> object postpones all incoming messages until enough sources have offered messages to the block to form a batch.</span></span> <span data-ttu-id="0364b-285">因為窮盡模式需要較少的處理額外負荷，通常其效能優於非窮盡模式。</span><span class="sxs-lookup"><span data-stu-id="0364b-285">Greedy mode typically performs better than non-greedy mode because it requires less processing overhead.</span></span> <span data-ttu-id="0364b-286">不過，在您必須以不可部分完成的方式協調來自多個來源之消耗時，可以使用非窮盡模式。</span><span class="sxs-lookup"><span data-stu-id="0364b-286">However, you can use non-greedy mode when you must coordinate consumption from multiple sources in an atomic fashion.</span></span> <span data-ttu-id="0364b-287">在 <xref:System.Threading.Tasks.Dataflow.BatchBlock%601.%23ctor%2A> 建構函式的 `dataflowBlockOptions` 參數中，設定 <xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions.Greedy%2A> 為 `False`，來指定非窮盡模式。</span><span class="sxs-lookup"><span data-stu-id="0364b-287">Specify non-greedy mode by setting <xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions.Greedy%2A> to `False` in the `dataflowBlockOptions` parameter in the <xref:System.Threading.Tasks.Dataflow.BatchBlock%601.%23ctor%2A> constructor.</span></span>  
  
 <span data-ttu-id="0364b-288">下列基本範例傳遞數個 <xref:System.Int32> 值至 <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> 物件，該物件會在一個批次中保存十個項目。</span><span class="sxs-lookup"><span data-stu-id="0364b-288">The following basic example posts several <xref:System.Int32> values to a <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> object that holds ten elements in a batch.</span></span> <span data-ttu-id="0364b-289">為了保證所有的值都會從 <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> 散佈，此範例會呼叫 <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="0364b-289">To guarantee that all values propagate out of the <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>, this example calls the <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete%2A> method.</span></span> <span data-ttu-id="0364b-290"><xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete%2A> 方法會將 <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> 物件設定為完成狀態，因此，<xref:System.Threading.Tasks.Dataflow.BatchBlock%601> 物件會散佈任何的剩餘項目做為最後的批次。</span><span class="sxs-lookup"><span data-stu-id="0364b-290">The <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete%2A> method sets the <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> object to the completed state, and therefore, the <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> object propagates out any remaining elements as a final batch.</span></span>  
  
 [!code-csharp[TPLDataflow_Overview#7](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#7)]
 [!code-vb[TPLDataflow_Overview#7](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#7)]  
  
 <span data-ttu-id="0364b-291">如需使用 <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> 改善資料庫插入作業效率的完整範例，請參閱[逐步解說：使用 BatchBlock 和 BatchedJoinBlock 以改善效率](walkthrough-using-batchblock-and-batchedjoinblock-to-improve-efficiency.md)。</span><span class="sxs-lookup"><span data-stu-id="0364b-291">For a complete example that uses <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> to improve the efficiency of database insert operations, see [Walkthrough: Using BatchBlock and BatchedJoinBlock to Improve Efficiency](walkthrough-using-batchblock-and-batchedjoinblock-to-improve-efficiency.md).</span></span>  
  
#### <a name="joinblockt1-t2-"></a><span data-ttu-id="0364b-292">JoinBlock(T1, T2, ...)</span><span class="sxs-lookup"><span data-stu-id="0364b-292">JoinBlock(T1, T2, ...)</span></span>  
 <span data-ttu-id="0364b-293"><xref:System.Threading.Tasks.Dataflow.JoinBlock%602> 和 <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> 類別會收集輸入項目，並散佈包含這些項目的 <xref:System.Tuple%602?displayProperty=nameWithType> 或 <xref:System.Tuple%603?displayProperty=nameWithType> 物件。</span><span class="sxs-lookup"><span data-stu-id="0364b-293">The <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> and <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> classes collect input elements and propagate out <xref:System.Tuple%602?displayProperty=nameWithType> or <xref:System.Tuple%603?displayProperty=nameWithType> objects that contain those elements.</span></span> <span data-ttu-id="0364b-294"><xref:System.Threading.Tasks.Dataflow.JoinBlock%602> 和 <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> 類別不會繼承自 <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>。</span><span class="sxs-lookup"><span data-stu-id="0364b-294">The <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> and <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> classes do not inherit from <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>.</span></span> <span data-ttu-id="0364b-295">相反地，它們提供了實作 <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601> 的屬性：<xref:System.Threading.Tasks.Dataflow.JoinBlock%602.Target1%2A>、<xref:System.Threading.Tasks.Dataflow.JoinBlock%602.Target2%2A> 和 <xref:System.Threading.Tasks.Dataflow.JoinBlock%603.Target3%2A>。</span><span class="sxs-lookup"><span data-stu-id="0364b-295">Instead, they provide properties, <xref:System.Threading.Tasks.Dataflow.JoinBlock%602.Target1%2A>, <xref:System.Threading.Tasks.Dataflow.JoinBlock%602.Target2%2A>, and <xref:System.Threading.Tasks.Dataflow.JoinBlock%603.Target3%2A>, that implement <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>.</span></span>  
  
 <span data-ttu-id="0364b-296">就像是 <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>、<xref:System.Threading.Tasks.Dataflow.JoinBlock%602> 和 <xref:System.Threading.Tasks.Dataflow.JoinBlock%603>，在窮盡或非窮盡模式下操作。</span><span class="sxs-lookup"><span data-stu-id="0364b-296">Like <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>, <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> and <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> operate in either greedy or non-greedy mode.</span></span> <span data-ttu-id="0364b-297">在窮盡模式 (這是預設值)，<xref:System.Threading.Tasks.Dataflow.JoinBlock%602> 或 <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> 物件會接受每則提供給它的訊息，並在其目標接收到至少一個訊息之後散佈 Tuple。</span><span class="sxs-lookup"><span data-stu-id="0364b-297">In greedy mode, which is the default, a <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> or <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> object accepts every message that it is offered and propagates out a tuple after each of its targets receives at least one message.</span></span> <span data-ttu-id="0364b-298">在非窮盡模式，<xref:System.Threading.Tasks.Dataflow.JoinBlock%602> 或 <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> 物件延後所有傳入訊息，直到建立 Tuple 所需的資料已提供至所有目標。</span><span class="sxs-lookup"><span data-stu-id="0364b-298">In non-greedy mode, a <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> or <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> object postpones all incoming messages until all targets have been offered the data that is required to create a tuple.</span></span> <span data-ttu-id="0364b-299">此時，該區塊會使用兩階段認可通訊協定，從來源以不可分割方式擷取所有必要的項目。</span><span class="sxs-lookup"><span data-stu-id="0364b-299">At this point, the block engages in a two-phase commit protocol to atomically retrieve all required items from the sources.</span></span> <span data-ttu-id="0364b-300">這項延遲使得其他實體可以同時使用資料，讓整個系統繼續進行。</span><span class="sxs-lookup"><span data-stu-id="0364b-300">This postponement makes it possible for another entity to consume the data in the meantime, to allow the overall system to make forward progress.</span></span>  
  
 <span data-ttu-id="0364b-301">下列基本範例示範 <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> 物件要求多個資料來計算一個值的案例。</span><span class="sxs-lookup"><span data-stu-id="0364b-301">The following basic example demonstrates a case in which a <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> object requires multiple data to compute a value.</span></span> <span data-ttu-id="0364b-302">這個範例會建立需要兩個 <xref:System.Int32> 值和一個 <xref:System.Char> 值來執行算術運算的 <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> 物件。</span><span class="sxs-lookup"><span data-stu-id="0364b-302">This example creates a <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> object that requires two <xref:System.Int32> values and a <xref:System.Char> value to perform an arithmetic operation.</span></span>  
  
 [!code-csharp[TPLDataflow_Overview#8](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#8)]
 [!code-vb[TPLDataflow_Overview#8](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#8)]  
  
 <span data-ttu-id="0364b-303">如需在非窮盡模式中使用 <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> 物件以合作方式共用資源的完整範例，請參閱[如何：使用 JoinBlock 從多個來源讀取資料](how-to-use-joinblock-to-read-data-from-multiple-sources.md)。</span><span class="sxs-lookup"><span data-stu-id="0364b-303">For a complete example that uses <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> objects in non-greedy mode to cooperatively share a resource, see [How to: Use JoinBlock to Read Data From Multiple Sources](how-to-use-joinblock-to-read-data-from-multiple-sources.md).</span></span>  
  
#### <a name="batchedjoinblockt1-t2-"></a><span data-ttu-id="0364b-304">BatchedJoinBlock(T1, T2, ...)</span><span class="sxs-lookup"><span data-stu-id="0364b-304">BatchedJoinBlock(T1, T2, ...)</span></span>  
 <span data-ttu-id="0364b-305"><xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> 和 <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%603> 類別會收集輸入項目的批次，並散佈包含這些項目的 `System.Tuple(IList(T1), IList(T2))` 或 `System.Tuple(IList(T1), IList(T2), IList(T3))` 物件。</span><span class="sxs-lookup"><span data-stu-id="0364b-305">The <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> and <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%603> classes collect batches of input elements and propagate out `System.Tuple(IList(T1), IList(T2))` or `System.Tuple(IList(T1), IList(T2), IList(T3))` objects that contain those elements.</span></span> <span data-ttu-id="0364b-306">請將 <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> 視為 <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> 和 <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> 的組合。</span><span class="sxs-lookup"><span data-stu-id="0364b-306">Think of <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> as a combination of <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> and <xref:System.Threading.Tasks.Dataflow.JoinBlock%602>.</span></span> <span data-ttu-id="0364b-307">當您建立 <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> 物件時，請指定每一批次的大小。</span><span class="sxs-lookup"><span data-stu-id="0364b-307">Specify the size of each batch when you create a <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> object.</span></span> <span data-ttu-id="0364b-308"><xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> 也提供會實作 <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601> 的屬性：<xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target1%2A> 和 <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target2%2A>。</span><span class="sxs-lookup"><span data-stu-id="0364b-308"><xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> also provides properties, <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target1%2A> and <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target2%2A>, that implement <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>.</span></span> <span data-ttu-id="0364b-309">當收到來自所有目標的指定輸入項目計數時，<xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> 物件會非同步散佈包含這些項目的 `System.Tuple(IList(T1), IList(T2))` 物件。</span><span class="sxs-lookup"><span data-stu-id="0364b-309">When the specified count of input elements are received from across all targets, the <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> object asynchronously propagates out a `System.Tuple(IList(T1), IList(T2))` object that contains those elements.</span></span>  
  
 <span data-ttu-id="0364b-310">下列基本範例建立會保存結果的 <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> 物件、<xref:System.Int32> 值，以及為 <xref:System.Exception> 物件的錯誤。</span><span class="sxs-lookup"><span data-stu-id="0364b-310">The following basic example creates a <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> object that holds results, <xref:System.Int32> values, and errors that are <xref:System.Exception> objects.</span></span> <span data-ttu-id="0364b-311">這個範例執行多個作業，並將結果寫入 <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> 物件的 <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target1%2A> 屬性，將錯誤寫入 <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target2%2A> 屬性。</span><span class="sxs-lookup"><span data-stu-id="0364b-311">This example performs multiple operations and writes results to the <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target1%2A> property, and errors to the <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target2%2A> property, of the <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> object.</span></span> <span data-ttu-id="0364b-312">由於事先不知道成功和失敗的作業計數，<xref:System.Collections.Generic.IList%601> 物件可讓每個目標接收零或多個值。</span><span class="sxs-lookup"><span data-stu-id="0364b-312">Because the count of successful and failed operations is unknown in advance, the <xref:System.Collections.Generic.IList%601> objects enable each target to receive zero or more values.</span></span>  
  
 [!code-csharp[TPLDataflow_Overview#9](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#9)]
 [!code-vb[TPLDataflow_Overview#9](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#9)]  
  
 <span data-ttu-id="0364b-313">如需使用 <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> 來擷取程式從資料庫讀取時所發生的結果和任何例外狀況的完整範例，請參閱[逐步解說：使用 BatchBlock 和 BatchedJoinBlock 以改善效率](walkthrough-using-batchblock-and-batchedjoinblock-to-improve-efficiency.md)。</span><span class="sxs-lookup"><span data-stu-id="0364b-313">For a complete example that uses <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> to capture both the results and any exceptions that occur while the program reads from a database, see [Walkthrough: Using BatchBlock and BatchedJoinBlock to Improve Efficiency](walkthrough-using-batchblock-and-batchedjoinblock-to-improve-efficiency.md).</span></span>  

## <a name="configuring-dataflow--block-behavior"></a><span data-ttu-id="0364b-314">設定資料流程區塊行為</span><span class="sxs-lookup"><span data-stu-id="0364b-314">Configuring Dataflow  Block Behavior</span></span>  
 <span data-ttu-id="0364b-315">您可以對資料流程區塊類型建構函式提供 <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions?displayProperty=nameWithType> 物件來啟用其他選項。</span><span class="sxs-lookup"><span data-stu-id="0364b-315">You can enable additional options by providing a <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions?displayProperty=nameWithType> object to the constructor of dataflow block types.</span></span> <span data-ttu-id="0364b-316">這些選項可控制行為，例如會管理基礎工作和平行處理原則刻度的排程器。</span><span class="sxs-lookup"><span data-stu-id="0364b-316">These options control behavior such the scheduler that manages the underlying task and the degree of parallelism.</span></span> <span data-ttu-id="0364b-317"><xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions> 也衍生出會指定某些資料流程區塊類型特定行為的類型。</span><span class="sxs-lookup"><span data-stu-id="0364b-317">The <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions> also has derived types that specify behavior that is specific to certain dataflow block types.</span></span> <span data-ttu-id="0364b-318">下表摘要說明與各資料流程區塊類型相關聯的選項類型。</span><span class="sxs-lookup"><span data-stu-id="0364b-318">The following table summarizes which options type is associated with each dataflow block type.</span></span>  
  
|<span data-ttu-id="0364b-319">資料流程區塊類型</span><span class="sxs-lookup"><span data-stu-id="0364b-319">Dataflow Block Type</span></span>|<span data-ttu-id="0364b-320"><xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions> 類型</span><span class="sxs-lookup"><span data-stu-id="0364b-320"><xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions> type</span></span>|  
|-------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------|  
|<xref:System.Threading.Tasks.Dataflow.BufferBlock%601>|<xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601>|<xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601>|<xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.ActionBlock%601>|<xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.TransformBlock%602>|<xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>|<xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.BatchBlock%601>|<xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.JoinBlock%602>|<xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602>|<xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions>|  
  
 <span data-ttu-id="0364b-321">下列章節提供可用於 <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions?displayProperty=nameWithType>、<xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions?displayProperty=nameWithType> 和 <xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions?displayProperty=nameWithType> 類別中重要的資料流程選項種類之其他資訊。</span><span class="sxs-lookup"><span data-stu-id="0364b-321">The following sections provide additional information about the important kinds of dataflow block options that are available through the <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions?displayProperty=nameWithType>, <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions?displayProperty=nameWithType>, and <xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions?displayProperty=nameWithType> classes.</span></span>  
  
### <a name="specifying-the-task-scheduler"></a><span data-ttu-id="0364b-322">指定工作排程器</span><span class="sxs-lookup"><span data-stu-id="0364b-322">Specifying the Task Scheduler</span></span>  
 <span data-ttu-id="0364b-323">每個預先定義的資料流程區塊使用 TPL 工作排程機制來執行活動，例如當資料可用時散佈資料至目標、接收來自來源的資料和執行使用者定義的委派。</span><span class="sxs-lookup"><span data-stu-id="0364b-323">Every predefined dataflow block uses the TPL task scheduling mechanism to perform activities such as propagating data to a target, receiving data from a source, and running user-defined delegates when data becomes available.</span></span> <span data-ttu-id="0364b-324"><xref:System.Threading.Tasks.TaskScheduler> 是一種抽象類別，代表在執行緒上將工作排入佇列的工作排程器。</span><span class="sxs-lookup"><span data-stu-id="0364b-324"><xref:System.Threading.Tasks.TaskScheduler> is an abstract class that represents a task scheduler that queues tasks onto threads.</span></span> <span data-ttu-id="0364b-325">預設工作排程器 <xref:System.Threading.Tasks.TaskScheduler.Default%2A> 使用 <xref:System.Threading.ThreadPool> 類別將工作排入佇列並執行。</span><span class="sxs-lookup"><span data-stu-id="0364b-325">The default task scheduler, <xref:System.Threading.Tasks.TaskScheduler.Default%2A>, uses the <xref:System.Threading.ThreadPool> class to queue and execute work.</span></span> <span data-ttu-id="0364b-326">您可以在建構資料流程區塊物件時設定 <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.TaskScheduler%2A> 屬性，來覆寫預設工作排程器。</span><span class="sxs-lookup"><span data-stu-id="0364b-326">You can override the default task scheduler by setting the <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.TaskScheduler%2A> property when you construct a dataflow block object.</span></span>  
  
 <span data-ttu-id="0364b-327">在同一個工作排程器管理多個資料流程區塊時，它可以跨區塊強制執行原則。</span><span class="sxs-lookup"><span data-stu-id="0364b-327">When the same task scheduler manages multiple dataflow blocks, it can enforce policies across them.</span></span> <span data-ttu-id="0364b-328">例如，如果多個資料流程區塊分別設定為以相同 <xref:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair> 物件的獨佔排程器為目標，則會將所有跨區塊執行的的工作序列化。</span><span class="sxs-lookup"><span data-stu-id="0364b-328">For example, if multiple dataflow blocks are each configured to target the exclusive scheduler of the same <xref:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair> object, all work that runs across these blocks is serialized.</span></span> <span data-ttu-id="0364b-329">同樣地，如果這些區塊設定為以相同 <xref:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair> 物件的並行排程器為目標，且該排程器已設定為具有最大並行層級，則所有來自這些區塊的工作都受限於並行作業的數目。</span><span class="sxs-lookup"><span data-stu-id="0364b-329">Similarly, if these blocks are configured to target the concurrent scheduler of the same <xref:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair> object, and that scheduler is configured to have a maximum concurrency level, all work from these blocks is limited to that number of concurrent operations.</span></span> <span data-ttu-id="0364b-330">如需使用 <xref:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair> 類別來使讀取作業以平行方式發生，但使寫入作業僅會針對所有其他作業發生的範例，請參閱[如何：在資料流程區塊中指定工作排程器](how-to-specify-a-task-scheduler-in-a-dataflow-block.md)。</span><span class="sxs-lookup"><span data-stu-id="0364b-330">For an example that uses the <xref:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair> class to enable read operations to occur in parallel, but write operations to occur exclusively of all other operations, see [How to: Specify a Task Scheduler in a Dataflow Block](how-to-specify-a-task-scheduler-in-a-dataflow-block.md).</span></span> <span data-ttu-id="0364b-331">如需 TPL 中工作排程器的詳細資訊，請參閱 <xref:System.Threading.Tasks.TaskScheduler> 類別主題。</span><span class="sxs-lookup"><span data-stu-id="0364b-331">For more information about task schedulers in the TPL, see the <xref:System.Threading.Tasks.TaskScheduler> class topic.</span></span>  
  
### <a name="specifying-the-degree-of-parallelism"></a><span data-ttu-id="0364b-332">指定平行處理原則的刻度</span><span class="sxs-lookup"><span data-stu-id="0364b-332">Specifying the Degree of Parallelism</span></span>  
 <span data-ttu-id="0364b-333">根據預設，TPL 資料流程程式庫所提供的三個執行區塊類型 <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>、<xref:System.Threading.Tasks.Dataflow.TransformBlock%602> 和 <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>，一次處理一個訊息。</span><span class="sxs-lookup"><span data-stu-id="0364b-333">By default, the three execution block types that the TPL Dataflow Library provides, <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>, and <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>, process one message at a time.</span></span> <span data-ttu-id="0364b-334">這些資料流程區塊類型也都會按照接收到訊息的順序處理訊息。</span><span class="sxs-lookup"><span data-stu-id="0364b-334">These dataflow block types also process messages in the order in which they are received.</span></span> <span data-ttu-id="0364b-335">在建構資料流程區塊物件時，要讓這些資料流程區塊同時處理訊息，請設定 <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A?displayProperty=nameWithType> 屬性。</span><span class="sxs-lookup"><span data-stu-id="0364b-335">To enable these dataflow blocks to process messages concurrently, set the <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A?displayProperty=nameWithType> property when you construct the dataflow block object.</span></span>  
  
 <span data-ttu-id="0364b-336"><xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> 的預設值為 1，以保證該資料流程區塊一次處理一個訊息。</span><span class="sxs-lookup"><span data-stu-id="0364b-336">The default value of <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> is 1, which guarantees that the dataflow block processes one message at a time.</span></span> <span data-ttu-id="0364b-337">設定此屬性為大於 1 的值可讓資料流程區塊同時處理多個訊息。</span><span class="sxs-lookup"><span data-stu-id="0364b-337">Setting this property to a value that is larger than 1 enables the dataflow block to process multiple messages concurrently.</span></span> <span data-ttu-id="0364b-338">設定此屬性為 <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.Unbounded?displayProperty=nameWithType> 可啟用基本的工作排程器來管理最大並行刻度。</span><span class="sxs-lookup"><span data-stu-id="0364b-338">Setting this property to <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.Unbounded?displayProperty=nameWithType> enables the underlying task scheduler to manage the maximum degree of concurrency.</span></span>  
  
> [!IMPORTANT]
> <span data-ttu-id="0364b-339">當您指定大於 1 的最大平行處理原則刻度時，將會同時處理多個訊息，因此訊息可能不會依照接收到的順序處理。</span><span class="sxs-lookup"><span data-stu-id="0364b-339">When you specify a maximum degree of parallelism that is larger than 1, multiple messages are processed simultaneously, and therefore messages might not be processed in the order in which they are received.</span></span> <span data-ttu-id="0364b-340">不過，訊息從區塊輸出的順序和收到的順序一樣。</span><span class="sxs-lookup"><span data-stu-id="0364b-340">The order in which the messages are output from the block is, however, the same one in which they are received.</span></span>  
  
 <span data-ttu-id="0364b-341">因為 <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> 屬性表示平行處理原則的最大刻度，所以資料流程區塊可能會以比您所指定刻度更小的平行處理原則來執行。</span><span class="sxs-lookup"><span data-stu-id="0364b-341">Because the <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> property represents the maximum degree of parallelism, the dataflow block might execute with a lesser degree of parallelism than you specify.</span></span> <span data-ttu-id="0364b-342">資料流程區塊可能使用較低刻度的平行處理以符合其功能需求，或者是因為缺乏可用的系統資源。</span><span class="sxs-lookup"><span data-stu-id="0364b-342">The dataflow block might use a lesser degree of parallelism to meet its functional requirements or because there is a lack of available system resources.</span></span> <span data-ttu-id="0364b-343">資料流程區塊絕不選擇高於您所指定的平行處理。</span><span class="sxs-lookup"><span data-stu-id="0364b-343">A dataflow block never chooses more parallelism than you specify.</span></span>  
  
 <span data-ttu-id="0364b-344"><xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> 屬性的值對每個資料流程區塊物件是獨佔的。</span><span class="sxs-lookup"><span data-stu-id="0364b-344">The value of the <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> property is exclusive to each dataflow block object.</span></span> <span data-ttu-id="0364b-345">例如，如果四個資料流程區塊物件每一個都為平行處理原則的最大刻度指定為 1，則全部四個資料流程區塊物件都可以平行執行。</span><span class="sxs-lookup"><span data-stu-id="0364b-345">For example, if four dataflow block objects each specify 1 for the maximum degree of parallelism, all four dataflow block objects can potentially run in parallel.</span></span>  
  
 <span data-ttu-id="0364b-346">如需設定平行處理原則的最大刻度，讓長時間作業平行處理的範例，請參閱[如何：在資料流程區塊中指定平行處理原則刻度](how-to-specify-the-degree-of-parallelism-in-a-dataflow-block.md)。</span><span class="sxs-lookup"><span data-stu-id="0364b-346">For an example that sets the maximum degree of parallelism to enable lengthy operations to occur in parallel, see [How to: Specify the Degree of Parallelism in a Dataflow Block](how-to-specify-the-degree-of-parallelism-in-a-dataflow-block.md).</span></span>  
  
### <a name="specifying-the-number-of-messages-per-task"></a><span data-ttu-id="0364b-347">指定每項工作的訊息數量</span><span class="sxs-lookup"><span data-stu-id="0364b-347">Specifying the Number of Messages per Task</span></span>  
 <span data-ttu-id="0364b-348">預先定義的資料流程區塊類型使用工作以處理多個輸入項目。</span><span class="sxs-lookup"><span data-stu-id="0364b-348">The predefined dataflow block types use tasks to process multiple input elements.</span></span> <span data-ttu-id="0364b-349">這有助於減少被要求處理資料的工作物件數目，使得應用程式更有效率地執行。</span><span class="sxs-lookup"><span data-stu-id="0364b-349">This helps minimize the number of task objects that are required to process data, which enables applications to run more efficiently.</span></span> <span data-ttu-id="0364b-350">不過，當來自一組工作資料流程區塊的工作正在處理資料時，來自其他資料流程區塊的工作可能需要將訊息加入佇列來等候處理時間。</span><span class="sxs-lookup"><span data-stu-id="0364b-350">However, when the tasks from one set of dataflow blocks are processing data, the tasks from other dataflow blocks might need to wait for processing time by queuing messages.</span></span> <span data-ttu-id="0364b-351">若要提升資料流程中工作的公平性，請設定 <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> 屬性。</span><span class="sxs-lookup"><span data-stu-id="0364b-351">To enable better fairness among dataflow tasks, set the <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> property.</span></span> <span data-ttu-id="0364b-352">當 <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> 設定為 <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.Unbounded?displayProperty=nameWithType> (預設) 時，由資料流程區塊所使用的工作會盡可能多地處理訊息。</span><span class="sxs-lookup"><span data-stu-id="0364b-352">When <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> is set to <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.Unbounded?displayProperty=nameWithType>, which is the default, the task used by a dataflow block processes as many messages as are available.</span></span> <span data-ttu-id="0364b-353">在 <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> 設定為除了 <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.Unbounded> 以外的值時，即為資料流程區塊對每個 <xref:System.Threading.Tasks.Task> 物件至多處理的訊息數量。</span><span class="sxs-lookup"><span data-stu-id="0364b-353">When <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> is set to a value other than <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.Unbounded>, the dataflow block processes at most this number of messages per <xref:System.Threading.Tasks.Task> object.</span></span> <span data-ttu-id="0364b-354">雖然設定 <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> 屬性可能會在工作之間提升公平性，但它可能造成系統建立更多超出所需的工作，反而可能會降低效能。</span><span class="sxs-lookup"><span data-stu-id="0364b-354">Although setting the <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> property can increase fairness among tasks, it can cause the system to create more tasks than are necessary, which can decrease performance.</span></span>  
  
### <a name="enabling-cancellation"></a><span data-ttu-id="0364b-355">啟用取消</span><span class="sxs-lookup"><span data-stu-id="0364b-355">Enabling Cancellation</span></span>  
 <span data-ttu-id="0364b-356">TPL 提供一種讓工作以合作方式協調取消的機制。</span><span class="sxs-lookup"><span data-stu-id="0364b-356">The TPL provides a mechanism that enables tasks to coordinate cancellation in a cooperative manner.</span></span> <span data-ttu-id="0364b-357">若要讓資料流程區塊參與此取消機制，請設定 <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.CancellationToken%2A> 屬性。</span><span class="sxs-lookup"><span data-stu-id="0364b-357">To enable dataflow blocks to participate in this cancellation mechanism, set the <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.CancellationToken%2A> property.</span></span> <span data-ttu-id="0364b-358">當此 <xref:System.Threading.CancellationToken> 物件設定為已取消狀態時，所有監視此語彙基元的資料流程區塊會結束執行其目前項目，但不開始處理後續項目。</span><span class="sxs-lookup"><span data-stu-id="0364b-358">When this <xref:System.Threading.CancellationToken> object is set to the canceled state, all dataflow blocks that monitor this token finish execution of their current item but do not start processing subsequent items.</span></span> <span data-ttu-id="0364b-359">這些資料流程區塊也會清除任何緩衝訊息，釋放連結給任何來源區塊和目標區塊，並轉換為取消狀態。</span><span class="sxs-lookup"><span data-stu-id="0364b-359">These dataflow blocks also clear any buffered messages, release connections to any source and target blocks, and transition to the canceled state.</span></span> <span data-ttu-id="0364b-360">除非在處理期間發生例外狀況，不然 <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion%2A> 屬性將透過轉換到已取消的狀態，將 <xref:System.Threading.Tasks.Task.Status%2A> 屬性設定為 <xref:System.Threading.Tasks.TaskStatus.Canceled>。</span><span class="sxs-lookup"><span data-stu-id="0364b-360">By transitioning to the canceled state, the <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion%2A> property has the <xref:System.Threading.Tasks.Task.Status%2A> property set to <xref:System.Threading.Tasks.TaskStatus.Canceled>, unless an exception occurred during processing.</span></span> <span data-ttu-id="0364b-361">在此情況下，<xref:System.Threading.Tasks.Task.Status%2A> 會設定為 <xref:System.Threading.Tasks.TaskStatus.Faulted>。</span><span class="sxs-lookup"><span data-stu-id="0364b-361">In that case, <xref:System.Threading.Tasks.Task.Status%2A> is set to <xref:System.Threading.Tasks.TaskStatus.Faulted>.</span></span>  
  
 <span data-ttu-id="0364b-362">如需示範如何在 Windows Forms 應用程式中使用取消的範例，請參閱[如何：取消資料流程區塊](how-to-cancel-a-dataflow-block.md)。</span><span class="sxs-lookup"><span data-stu-id="0364b-362">For an example that demonstrates how to use cancellation in a Windows Forms application, see [How to: Cancel a Dataflow Block](how-to-cancel-a-dataflow-block.md).</span></span> <span data-ttu-id="0364b-363">如需 TPL 中取消的詳細資訊，請參閱[工作取消](task-cancellation.md)。</span><span class="sxs-lookup"><span data-stu-id="0364b-363">For more information about cancellation in the TPL, see [Task Cancellation](task-cancellation.md).</span></span>  
  
### <a name="specifying-greedy-versus-non-greedy-behavior"></a><span data-ttu-id="0364b-364">指定窮盡與非窮盡的行為</span><span class="sxs-lookup"><span data-stu-id="0364b-364">Specifying Greedy Versus Non-Greedy Behavior</span></span>  
 <span data-ttu-id="0364b-365">許多群組資料流程區塊類型可以在「窮盡」或「非窮盡」模式中運作。</span><span class="sxs-lookup"><span data-stu-id="0364b-365">Several grouping dataflow block types can operate in either *greedy* or *non-greedy* mode.</span></span> <span data-ttu-id="0364b-366">預先定義的資料流程區塊類型預設會在窮盡模式下運作。</span><span class="sxs-lookup"><span data-stu-id="0364b-366">By default, the predefined dataflow block types operate in greedy mode.</span></span>  
  
 <span data-ttu-id="0364b-367">對於聯結區塊類型 (例如 <xref:System.Threading.Tasks.Dataflow.JoinBlock%602>)，窮盡模式表示即使與其相聯結的對應資料尚未可用，區塊會立即接受資料。</span><span class="sxs-lookup"><span data-stu-id="0364b-367">For join block types such as <xref:System.Threading.Tasks.Dataflow.JoinBlock%602>, greedy mode means that the block immediately accepts data even if the corresponding data with which to join is not yet available.</span></span> <span data-ttu-id="0364b-368">非窮盡模式則表示區塊會延後處理所有傳入訊息，直到其中之一在其每個目標上可用於完成聯結。</span><span class="sxs-lookup"><span data-stu-id="0364b-368">Non-greedy mode means that the block postpones all incoming messages until one is available on each of its targets to complete the join.</span></span> <span data-ttu-id="0364b-369">如果任何延後的訊息皆不再可用，則聯結區塊會釋出所有延後的訊息，並重新啟動此程序。</span><span class="sxs-lookup"><span data-stu-id="0364b-369">If any of the postponed messages are no longer available, the join block releases all postponed messages and restarts the process.</span></span> <span data-ttu-id="0364b-370">對於 <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> 類別，窮盡和非窮盡的行為類似，但是在非窮盡模式下，<xref:System.Threading.Tasks.Dataflow.BatchBlock%601> 物件將所有傳入訊息延後，直到來自不同來源的訊息足夠可用，以完成批次。</span><span class="sxs-lookup"><span data-stu-id="0364b-370">For the <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> class, greedy and non-greedy behavior is similar, except that under non-greedy mode, a <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> object postpones all incoming messages until enough are available from distinct sources to complete a batch.</span></span>  
  
 <span data-ttu-id="0364b-371">若要為資料流程區塊指定非窮盡模式，請將 <xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions.Greedy%2A> 設為 `False`。</span><span class="sxs-lookup"><span data-stu-id="0364b-371">To specify non-greedy mode for a dataflow block, set <xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions.Greedy%2A> to `False`.</span></span> <span data-ttu-id="0364b-372">如需示範如何使用非窮盡模式，讓多個聯結區塊更有效率共用資料來源的範例，請參閱[如何：使用 JoinBlock 從多個來源讀取資料](how-to-use-joinblock-to-read-data-from-multiple-sources.md)。</span><span class="sxs-lookup"><span data-stu-id="0364b-372">For an example that demonstrates how to use non-greedy mode to enable multiple join blocks to share a data source more efficiently, see [How to: Use JoinBlock to Read Data From Multiple Sources](how-to-use-joinblock-to-read-data-from-multiple-sources.md).</span></span>

## <a name="custom-dataflow-blocks"></a><span data-ttu-id="0364b-373">自訂資料流程區塊</span><span class="sxs-lookup"><span data-stu-id="0364b-373">Custom Dataflow Blocks</span></span>  
 <span data-ttu-id="0364b-374">雖然 TPL 資料流程程式庫提供許多預先定義的區塊類型，但您可以建立會執行自訂行為的其他區塊類型。</span><span class="sxs-lookup"><span data-stu-id="0364b-374">Although the TPL Dataflow Library provides many predefined block types, you can create additional block types that perform custom behavior.</span></span> <span data-ttu-id="0364b-375">直接實作 <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601> 或 <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601> 介面，或是使用 <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Encapsulate%2A> 方法來建立封裝現有區塊類型行為的複雜區塊。</span><span class="sxs-lookup"><span data-stu-id="0364b-375">Implement the <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601> or <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601> interfaces directly or use the  <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Encapsulate%2A> method to build a complex block that encapsulates the behavior of existing block types.</span></span> <span data-ttu-id="0364b-376">如需示範如何實作自訂資料流程區塊功能的範例，請參閱[逐步解說：建立自訂資料流程區塊類型](walkthrough-creating-a-custom-dataflow-block-type.md)。</span><span class="sxs-lookup"><span data-stu-id="0364b-376">For examples that show how to implement custom dataflow block functionality, see [Walkthrough: Creating a Custom Dataflow Block Type](walkthrough-creating-a-custom-dataflow-block-type.md).</span></span>

## <a name="related-topics"></a><span data-ttu-id="0364b-377">相關主題</span><span class="sxs-lookup"><span data-stu-id="0364b-377">Related Topics</span></span>  
  
|<span data-ttu-id="0364b-378">標題</span><span class="sxs-lookup"><span data-stu-id="0364b-378">Title</span></span>|<span data-ttu-id="0364b-379">說明</span><span class="sxs-lookup"><span data-stu-id="0364b-379">Description</span></span>|  
|-----------|-----------------|  
|[<span data-ttu-id="0364b-380">作法：對資料流程區塊寫入訊息和讀取訊息</span><span class="sxs-lookup"><span data-stu-id="0364b-380">How to: Write Messages to and Read Messages from a Dataflow Block</span></span>](how-to-write-messages-to-and-read-messages-from-a-dataflow-block.md)|<span data-ttu-id="0364b-381">示範如何寫入訊息至 <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> 物件及讀取該物件中的訊息。</span><span class="sxs-lookup"><span data-stu-id="0364b-381">Demonstrates how to write messages to and read messages from a <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> object.</span></span>|  
|[<span data-ttu-id="0364b-382">作法：實作產生者/取用者資料流程模式</span><span class="sxs-lookup"><span data-stu-id="0364b-382">How to: Implement a Producer-Consumer Dataflow Pattern</span></span>](how-to-implement-a-producer-consumer-dataflow-pattern.md)|<span data-ttu-id="0364b-383">描述如何使用此資料流程模型以實作生產者-消費者模式，其中生產者傳送訊息至資料流程區塊，而消費者從該區塊讀取訊息。</span><span class="sxs-lookup"><span data-stu-id="0364b-383">Describes how to use the dataflow model to implement a producer-consumer pattern, where the producer sends messages to a dataflow block, and the consumer reads messages from that block.</span></span>|  
|[<span data-ttu-id="0364b-384">作法：在資料流程區塊收到資料時執行動作</span><span class="sxs-lookup"><span data-stu-id="0364b-384">How to: Perform Action When a Dataflow Block Receives Data</span></span>](how-to-perform-action-when-a-dataflow-block-receives-data.md)|<span data-ttu-id="0364b-385">說明如何提供委派給執行資料流程區塊類型 <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>、<xref:System.Threading.Tasks.Dataflow.TransformBlock%602> 和 <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>。</span><span class="sxs-lookup"><span data-stu-id="0364b-385">Describes how to provide delegates to the execution dataflow block types, <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>, and <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>.</span></span>|  
|[<span data-ttu-id="0364b-386">逐步解說：建立資料流程管線</span><span class="sxs-lookup"><span data-stu-id="0364b-386">Walkthrough: Creating a Dataflow Pipeline</span></span>](walkthrough-creating-a-dataflow-pipeline.md)|<span data-ttu-id="0364b-387">描述如何建立可以從網路下載文字並對該文字執行作業的資料流程管線。</span><span class="sxs-lookup"><span data-stu-id="0364b-387">Describes how to create a dataflow pipeline that downloads text from the web and performs operations on that text.</span></span>|  
|[<span data-ttu-id="0364b-388">作法：取消連結資料流程區塊</span><span class="sxs-lookup"><span data-stu-id="0364b-388">How to: Unlink Dataflow Blocks</span></span>](how-to-unlink-dataflow-blocks.md)|<span data-ttu-id="0364b-389">示範如何使用 <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.LinkTo%2A> 方法，來在來源為目標提供訊息之後，將目標區塊與其來源取消連結。</span><span class="sxs-lookup"><span data-stu-id="0364b-389">Demonstrates how to use the <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.LinkTo%2A> method to unlink a target block from its source after the source offers a message to the target.</span></span>|  
|[<span data-ttu-id="0364b-390">逐步解說：在 Windows Forms 應用程式中使用資料流程</span><span class="sxs-lookup"><span data-stu-id="0364b-390">Walkthrough: Using Dataflow in a Windows Forms Application</span></span>](walkthrough-using-dataflow-in-a-windows-forms-application.md)|<span data-ttu-id="0364b-391">示範如何建立資料流程區塊網路，其可以在 Windows Form 應用程式中執行影像處理。</span><span class="sxs-lookup"><span data-stu-id="0364b-391">Demonstrates how to create a network of dataflow blocks that perform image processing in a Windows Forms application.</span></span>|  
|[<span data-ttu-id="0364b-392">作法：取消資料流程區塊</span><span class="sxs-lookup"><span data-stu-id="0364b-392">How to: Cancel a Dataflow Block</span></span>](how-to-cancel-a-dataflow-block.md)|<span data-ttu-id="0364b-393">示範如何在 Windows Form 應用程式中使用取消。</span><span class="sxs-lookup"><span data-stu-id="0364b-393">Demonstrates how to use cancellation in a Windows Forms application.</span></span>|  
|[<span data-ttu-id="0364b-394">作法：使用 JoinBlock 從多個來源讀取資料</span><span class="sxs-lookup"><span data-stu-id="0364b-394">How to: Use JoinBlock to Read Data From Multiple Sources</span></span>](how-to-use-joinblock-to-read-data-from-multiple-sources.md)|<span data-ttu-id="0364b-395">說明如何在資料可取自多重來源時使用 <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> 類別執行作業，以及如何使用非窮盡模式使得多重聯結區塊可以更有效率地共用資料來源。</span><span class="sxs-lookup"><span data-stu-id="0364b-395">Explains how to use the <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> class to perform an operation when data is available from multiple sources, and how to use non-greedy mode to enable multiple join blocks to share a data source more efficiently.</span></span>|  
|[<span data-ttu-id="0364b-396">作法：在資料流程區塊中指定平行處理原則程度</span><span class="sxs-lookup"><span data-stu-id="0364b-396">How to: Specify the Degree of Parallelism in a Dataflow Block</span></span>](how-to-specify-the-degree-of-parallelism-in-a-dataflow-block.md)|<span data-ttu-id="0364b-397">描述如何設定 <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> 屬性使執行資料流程區塊可以同時處理一個以上的訊息。</span><span class="sxs-lookup"><span data-stu-id="0364b-397">Describes how to set the <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> property to enable an execution dataflow block to process more than one message at a time.</span></span>|  
|[<span data-ttu-id="0364b-398">作法：在資料流程區塊中指定工作排程器</span><span class="sxs-lookup"><span data-stu-id="0364b-398">How to: Specify a Task Scheduler in a Dataflow Block</span></span>](how-to-specify-a-task-scheduler-in-a-dataflow-block.md)|<span data-ttu-id="0364b-399">示範當您在應用程式中使用資料流程時，要如何與特定工作排程器建立關聯。</span><span class="sxs-lookup"><span data-stu-id="0364b-399">Demonstrates how to associate a specific task scheduler when you use dataflow in your application.</span></span>|  
|[<span data-ttu-id="0364b-400">逐步解說：使用 BatchBlock 和 BatchedJoinBlock 以改善效率</span><span class="sxs-lookup"><span data-stu-id="0364b-400">Walkthrough: Using BatchBlock and BatchedJoinBlock to Improve Efficiency</span></span>](walkthrough-using-batchblock-and-batchedjoinblock-to-improve-efficiency.md)|<span data-ttu-id="0364b-401">說明如何使用 <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> 類別來改善資料庫插入作業的效率，以及說明如何使用 <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> 類別在程式讀取資料庫時擷取結果和發生的任何例外狀況。</span><span class="sxs-lookup"><span data-stu-id="0364b-401">Describes how to use the <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> class to improve the efficiency of database insert operations, and how to use the <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> class to capture both the results and any exceptions that occur while the program reads from a database.</span></span>|  
|[<span data-ttu-id="0364b-402">逐步解說：建立自訂資料流程區塊類型</span><span class="sxs-lookup"><span data-stu-id="0364b-402">Walkthrough: Creating a Custom Dataflow Block Type</span></span>](walkthrough-creating-a-custom-dataflow-block-type.md)|<span data-ttu-id="0364b-403">示範建立會實作自訂行為的資料流程區塊類型之兩種方式。</span><span class="sxs-lookup"><span data-stu-id="0364b-403">Demonstrates two ways to create a dataflow block type that implements custom behavior.</span></span>|  
|[<span data-ttu-id="0364b-404">工作平行程式庫 (TPL)</span><span class="sxs-lookup"><span data-stu-id="0364b-404">Task Parallel Library (TPL)</span></span>](task-parallel-library-tpl.md)|<span data-ttu-id="0364b-405">介紹 TPL，這是一種在 .NET Framework 應用程式中簡化平行和並行程式設計的程式庫。</span><span class="sxs-lookup"><span data-stu-id="0364b-405">Introduces the TPL, a library that simplifies parallel and concurrent programming in .NET Framework applications.</span></span>|
