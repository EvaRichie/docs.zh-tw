---
title: BinaryFormatter 安全性指南
description: 本文說明 BinaryFormatter 類型中固有的安全性風險，以及要使用的不同序列化程式的建議。
ms.date: 07/11/2020
ms.author: levib
author: GrabYourPitchforks
ms.openlocfilehash: f6a54b34bbf1e19212fe37aadb448a1722fe9ff0
ms.sourcegitcommit: 2543a78be6e246aa010a01decf58889de53d1636
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 07/17/2020
ms.locfileid: "86444761"
---
# <a name="binaryformatter-security-guide"></a><span data-ttu-id="381cc-103">BinaryFormatter 安全性指南</span><span class="sxs-lookup"><span data-stu-id="381cc-103">BinaryFormatter security guide</span></span>

<span data-ttu-id="381cc-104">本文適用于下列 .NET 部署：</span><span class="sxs-lookup"><span data-stu-id="381cc-104">This article applies to the following .NET implementations:</span></span>

* <span data-ttu-id="381cc-105">.NET Framework 所有版本</span><span class="sxs-lookup"><span data-stu-id="381cc-105">.NET Framework all versions</span></span>
* <span data-ttu-id="381cc-106">.NET Core 2.1-3。1</span><span class="sxs-lookup"><span data-stu-id="381cc-106">.NET Core 2.1 - 3.1</span></span>
* <span data-ttu-id="381cc-107">.NET 5.0 和更新版本</span><span class="sxs-lookup"><span data-stu-id="381cc-107">.NET 5.0 and later</span></span>

## <a name="background"></a><span data-ttu-id="381cc-108">背景</span><span class="sxs-lookup"><span data-stu-id="381cc-108">Background</span></span>

> [!WARNING]
> <span data-ttu-id="381cc-109"><xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter>類型是危險的，***不***建議用於資料處理。</span><span class="sxs-lookup"><span data-stu-id="381cc-109">The <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> type is dangerous and is ***not*** recommended for data processing.</span></span> <span data-ttu-id="381cc-110">應用程式應該儘快停止使用 `BinaryFormatter` ，即使他們認為所處理的資料值得信任。</span><span class="sxs-lookup"><span data-stu-id="381cc-110">Applications should stop using `BinaryFormatter` as soon as possible, even if they believe the data they're processing to be trustworthy.</span></span> <span data-ttu-id="381cc-111">`BinaryFormatter`不安全，無法安全地進行保護。</span><span class="sxs-lookup"><span data-stu-id="381cc-111">`BinaryFormatter` is insecure can't be made secure.</span></span>

<span data-ttu-id="381cc-112">本文也適用于下列類型：</span><span class="sxs-lookup"><span data-stu-id="381cc-112">This article also applies to the following types:</span></span>

* <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter>
* <xref:System.Runtime.Serialization.NetDataContractSerializer>
* <xref:System.Web.UI.LosFormatter>
* <xref:System.Web.UI.ObjectStateFormatter>

<span data-ttu-id="381cc-113">還原序列化弱點是, 處理要求承載的威脅類別。</span><span class="sxs-lookup"><span data-stu-id="381cc-113">Deserialization vulnerabilities are a threat category where request payloads are processed insecurely.</span></span> <span data-ttu-id="381cc-114">針對應用程式成功運用這些弱點的攻擊者可能會導致拒絕服務（DoS）、資訊洩漏，或在目標應用程式內執行遠端程式碼。</span><span class="sxs-lookup"><span data-stu-id="381cc-114">An attacker who successfully leverages these vulnerabilities against an app can cause denial of service (DoS), information disclosure, or remote code execution inside the target app.</span></span> <span data-ttu-id="381cc-115">此風險分類會一致地使[OWASP 的前10個](https://owasp.org/www-project-top-ten/)。</span><span class="sxs-lookup"><span data-stu-id="381cc-115">This risk category consistently makes the [OWASP Top 10](https://owasp.org/www-project-top-ten/).</span></span> <span data-ttu-id="381cc-116">目標包括以[各種語言](https://owasp.org/www-community/vulnerabilities/Deserialization_of_untrusted_data)撰寫的應用程式，包括 c/c + +、JAVA 和 c #。</span><span class="sxs-lookup"><span data-stu-id="381cc-116">Targets include apps written in [a variety of languages](https://owasp.org/www-community/vulnerabilities/Deserialization_of_untrusted_data), including C/C++, Java, and C#.</span></span>

<span data-ttu-id="381cc-117">在 .NET 中，最大的風險目標是使用類型來還原序列化資料的應用程式 <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> 。</span><span class="sxs-lookup"><span data-stu-id="381cc-117">In .NET, the biggest risk target is apps that use the <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> type to deserialize data.</span></span> <span data-ttu-id="381cc-118">`BinaryFormatter`在 .NET 生態系統中廣泛使用，因為它的威力和易用性。</span><span class="sxs-lookup"><span data-stu-id="381cc-118">`BinaryFormatter` is widely used throughout the .NET ecosystem because of its power and its ease of use.</span></span> <span data-ttu-id="381cc-119">不過，同樣的威力讓攻擊者能夠影響目標應用程式內的控制流程。</span><span class="sxs-lookup"><span data-stu-id="381cc-119">However, this same power gives attackers the ability to influence control flow within the target app.</span></span> <span data-ttu-id="381cc-120">成功的攻擊可能會導致攻擊者能夠在目標進程的內容中執行程式碼。</span><span class="sxs-lookup"><span data-stu-id="381cc-120">Successful attacks can result in the attacker being able to run code within the context of the target process.</span></span>

<span data-ttu-id="381cc-121">比較簡單的方式是，假設對承載進行呼叫相當於將 `BinaryFormatter.Deserialize` 該承載解讀為獨立可執行檔並啟動它。</span><span class="sxs-lookup"><span data-stu-id="381cc-121">As a simpler analogy, assume that calling `BinaryFormatter.Deserialize` over a payload is the equivalent of interpreting that payload as a standalone executable and launching it.</span></span>

## <a name="binaryformatter-security-vulnerabilities"></a><span data-ttu-id="381cc-122">BinaryFormatter 安全性弱點</span><span class="sxs-lookup"><span data-stu-id="381cc-122">BinaryFormatter security vulnerabilities</span></span>

> [!WARNING]
> <span data-ttu-id="381cc-123">搭配 `BinaryFormatter.Deserialize` 不受信任的輸入使用時，方法__絕對__不安全。</span><span class="sxs-lookup"><span data-stu-id="381cc-123">The `BinaryFormatter.Deserialize` method is __never__ safe when used with untrusted input.</span></span> <span data-ttu-id="381cc-124">我們強烈建議取用者改為考慮使用本文稍後所述的其中一種替代方案。</span><span class="sxs-lookup"><span data-stu-id="381cc-124">We strongly recommend that consumers instead consider using one of the alternatives outlined later in this article.</span></span>

<span data-ttu-id="381cc-125">`BinaryFormatter`在還原序列化弱點之前已實作為充分瞭解的威脅類別。</span><span class="sxs-lookup"><span data-stu-id="381cc-125">`BinaryFormatter` was implemented before deserialization vulnerabilities were a well-understood threat category.</span></span> <span data-ttu-id="381cc-126">因此，程式碼不會遵循現代化的最佳作法。</span><span class="sxs-lookup"><span data-stu-id="381cc-126">As a result, the code does not follow modern best practices.</span></span> <span data-ttu-id="381cc-127">`Deserialize`方法可以用來作為向量，讓攻擊者對取用應用程式執行 DoS 攻擊。</span><span class="sxs-lookup"><span data-stu-id="381cc-127">The `Deserialize` method can be used as a vector for attackers to perform DoS attacks against consuming apps.</span></span> <span data-ttu-id="381cc-128">這些攻擊可能會導致應用程式沒有回應，或造成非預期的進程終止。</span><span class="sxs-lookup"><span data-stu-id="381cc-128">These attacks might render the app unresponsive or result in unexpected process termination.</span></span> <span data-ttu-id="381cc-129">使用或任何其他設定參數，就無法減輕這類的攻擊 `SerializationBinder` `BinaryFormatter` 。</span><span class="sxs-lookup"><span data-stu-id="381cc-129">This category of attack cannot be mitigated with a `SerializationBinder` or any other `BinaryFormatter` configuration switch.</span></span> <span data-ttu-id="381cc-130">.NET 會將此行為視為***設計***，而且不會發出程式碼更新來修改行為。</span><span class="sxs-lookup"><span data-stu-id="381cc-130">.NET considers this behavior to be ***by design*** and won't issue a code update to modify the behavior.</span></span>

<span data-ttu-id="381cc-131">`BinaryFormatter.Deserialize`可能容易遭受其他攻擊類別，例如資訊洩漏或遠端程式碼執行。</span><span class="sxs-lookup"><span data-stu-id="381cc-131">`BinaryFormatter.Deserialize` may be vulnerable to other attack categories, such as information disclosure or remote code execution.</span></span> <span data-ttu-id="381cc-132">使用自訂之類的功能 <xref:System.Runtime.Serialization.SerializationBinder> 可能不足以適當地緩和這些風險。</span><span class="sxs-lookup"><span data-stu-id="381cc-132">Utilizing features such as a custom <xref:System.Runtime.Serialization.SerializationBinder> may be insufficient to properly mitigate these risks.</span></span> <span data-ttu-id="381cc-133">有一個可能的原因是探索到 novel 弱點，而 .NET 無法以實際的發佈安全性更新。</span><span class="sxs-lookup"><span data-stu-id="381cc-133">The possibility exists that a novel vulnerability will be discovered for which .NET cannot practically publish a security update.</span></span> <span data-ttu-id="381cc-134">取用者應該評估其個別案例，並考慮其對這些風險的潛在風險。</span><span class="sxs-lookup"><span data-stu-id="381cc-134">Consumers should assess their individual scenarios and consider their potential exposure to these risks.</span></span>

<span data-ttu-id="381cc-135">我們建議取用 `BinaryFormatter` 者在其應用程式上執行個別的風險評量。</span><span class="sxs-lookup"><span data-stu-id="381cc-135">We recommend that `BinaryFormatter` consumers perform individual risk assessments on their apps.</span></span> <span data-ttu-id="381cc-136">取用者會自行負責判斷是否要使用 `BinaryFormatter` 。</span><span class="sxs-lookup"><span data-stu-id="381cc-136">It is the consumer's sole responsibility to determine whether to utilize `BinaryFormatter`.</span></span> <span data-ttu-id="381cc-137">取用者應該會有風險，以評估使用的安全性、技術、信譽、法律和法規需求 `BinaryFormatter` 。</span><span class="sxs-lookup"><span data-stu-id="381cc-137">Consumers should risk assess the security, technical, reputation, legal, and regulatory requirements of using `BinaryFormatter`.</span></span>

## <a name="preferred-alternatives"></a><span data-ttu-id="381cc-138">慣用的替代方案</span><span class="sxs-lookup"><span data-stu-id="381cc-138">Preferred alternatives</span></span>

<span data-ttu-id="381cc-139">.NET 提供數個內建的序列化程式，可安全地處理不受信任的資料：</span><span class="sxs-lookup"><span data-stu-id="381cc-139">.NET offers several in-box serializers that can handle untrusted data safely:</span></span>

* <span data-ttu-id="381cc-140"><xref:System.Xml.Serialization.XmlSerializer>和， <xref:System.Runtime.Serialization.DataContractSerializer> 將物件圖形序列化為 XML。</span><span class="sxs-lookup"><span data-stu-id="381cc-140"><xref:System.Xml.Serialization.XmlSerializer> and <xref:System.Runtime.Serialization.DataContractSerializer> to serialize object graphs into and from XML.</span></span> <span data-ttu-id="381cc-141">請勿混淆 `DataContractSerializer` <xref:System.Runtime.Serialization.NetDataContractSerializer> 。</span><span class="sxs-lookup"><span data-stu-id="381cc-141">Do not confuse `DataContractSerializer` with  <xref:System.Runtime.Serialization.NetDataContractSerializer>.</span></span>
* <span data-ttu-id="381cc-142"><xref:System.IO.BinaryReader>和 <xref:System.IO.BinaryWriter> 適用于 XML 和 JSON。</span><span class="sxs-lookup"><span data-stu-id="381cc-142"><xref:System.IO.BinaryReader> and <xref:System.IO.BinaryWriter> for XML and JSON.</span></span>
* <span data-ttu-id="381cc-143">用 <xref:System.Text.Json> 來將物件圖形序列化為 JSON 的 api。</span><span class="sxs-lookup"><span data-stu-id="381cc-143">The <xref:System.Text.Json> APIs to serialize object graphs into JSON.</span></span>

## <a name="dangerous-alternatives"></a><span data-ttu-id="381cc-144">危險替代方案</span><span class="sxs-lookup"><span data-stu-id="381cc-144">Dangerous alternatives</span></span>

<span data-ttu-id="381cc-145">避免下列序列化程式：</span><span class="sxs-lookup"><span data-stu-id="381cc-145">Avoid the following serializers:</span></span>

* <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter>
* <xref:System.Web.UI.LosFormatter>
* <xref:System.Runtime.Serialization.NetDataContractSerializer>
* <xref:System.Web.UI.ObjectStateFormatter>

<span data-ttu-id="381cc-146">上述的序列化程式全都執行不受限制的多型多型還原序列化，而且很危險， `BinaryFormatter` 就像</span><span class="sxs-lookup"><span data-stu-id="381cc-146">The preceding serializers all perform unrestricted polymorphic deserialization and are dangerous, just like `BinaryFormatter`.</span></span>

## <a name="the-risks-of-assuming-data-to-be-trustworthy"></a><span data-ttu-id="381cc-147">假設資料值得信任的風險</span><span class="sxs-lookup"><span data-stu-id="381cc-147">The risks of assuming data to be trustworthy</span></span>

<span data-ttu-id="381cc-148">應用程式開發人員通常會認為他們只會處理受信任的輸入。</span><span class="sxs-lookup"><span data-stu-id="381cc-148">Frequently, an app developer might believe that they are processing only trusted input.</span></span> <span data-ttu-id="381cc-149">在某些罕見的情況下，安全輸入案例是正確的。</span><span class="sxs-lookup"><span data-stu-id="381cc-149">The safe input case is true in some rare circumstances.</span></span> <span data-ttu-id="381cc-150">但更常見的是，裝載不會跨越信任界限，而開發人員也不會實現它。</span><span class="sxs-lookup"><span data-stu-id="381cc-150">But it's much more common that a payload crosses a trust boundary without the developer realizing it.</span></span>

<span data-ttu-id="381cc-151">__假設有一個內部部署伺服器__，員工使用其工作站的桌面用戶端與服務互動。</span><span class="sxs-lookup"><span data-stu-id="381cc-151">__Consider an on-prem server__ where employees use a desktop client from their workstations to interact with the service.</span></span> <span data-ttu-id="381cc-152">這種情況可能會 naïvely 為「安全」的設定，讓您 `BinaryFormatter` 可以接受使用。</span><span class="sxs-lookup"><span data-stu-id="381cc-152">This scenario might be seen naïvely as a "safe" setup where utilizing `BinaryFormatter` is acceptable.</span></span> <span data-ttu-id="381cc-153">不過，此案例會針對惡意程式碼提供一個向量，讓您能夠存取單一員工的電腦，以便在整個企業中散佈。</span><span class="sxs-lookup"><span data-stu-id="381cc-153">However, this scenario presents a vector for malware that gains access to a single employee's machine to be able to spread throughout the enterprise.</span></span> <span data-ttu-id="381cc-154">該惡意程式碼可以利用的企業使用， `BinaryFormatter` 從員工的工作站橫向移到後端伺服器。</span><span class="sxs-lookup"><span data-stu-id="381cc-154">That malware can leverage the enterprise's use of `BinaryFormatter` to move laterally from the employee's workstation to the backend server.</span></span> <span data-ttu-id="381cc-155">然後，它可以竊取公司的敏感性資料。</span><span class="sxs-lookup"><span data-stu-id="381cc-155">It can then exfiltrate the company's sensitive data.</span></span> <span data-ttu-id="381cc-156">這類資料可能包含營業秘密或客戶資料。</span><span class="sxs-lookup"><span data-stu-id="381cc-156">Such data could include trade secrets or customer data.</span></span>

<span data-ttu-id="381cc-157">__另請考慮使用 `BinaryFormatter` 來保存儲存狀態的應用程式。__</span><span class="sxs-lookup"><span data-stu-id="381cc-157">__Consider also an app that uses `BinaryFormatter` to persist save state.__</span></span> <span data-ttu-id="381cc-158">這可能一開始似乎是安全的案例，因為在您自己的硬碟上讀取和寫入資料，代表一個小威脅。</span><span class="sxs-lookup"><span data-stu-id="381cc-158">This might at first seem to be a safe scenario, as reading and writing data on your own hard drive represents a minor threat.</span></span> <span data-ttu-id="381cc-159">不過，跨電子郵件或網際網路共用檔很常見，大部分的使用者都不會覺得將這些下載的檔案開啟為有風險的行為。</span><span class="sxs-lookup"><span data-stu-id="381cc-159">However, sharing documents across email or the internet is common, and most end users wouldn't perceive opening these downloaded files as risky behavior.</span></span>

<span data-ttu-id="381cc-160">此案例可用於惡意的效果。</span><span class="sxs-lookup"><span data-stu-id="381cc-160">This scenario can be leveraged to nefarious effect.</span></span> <span data-ttu-id="381cc-161">如果應用程式是遊戲，共用儲存檔案的使用者會在不知情的情況下自行承擔風險。</span><span class="sxs-lookup"><span data-stu-id="381cc-161">If the app is a game, users who share save files unknowingly place themselves at risk.</span></span> <span data-ttu-id="381cc-162">開發人員也可以做為目標。</span><span class="sxs-lookup"><span data-stu-id="381cc-162">The developers themselves can also be targeted.</span></span> <span data-ttu-id="381cc-163">攻擊者可能會透過電子郵件傳送開發人員技術支援、附加惡意資料檔，並要求支援人員開啟它。</span><span class="sxs-lookup"><span data-stu-id="381cc-163">The attacker might email the developers' tech support, attaching a malicious data file and asking the support staff to open it.</span></span> <span data-ttu-id="381cc-164">這類攻擊可能會讓攻擊者成為企業中的據點。</span><span class="sxs-lookup"><span data-stu-id="381cc-164">This kind of attack could give the attacker a foothold in the enterprise.</span></span>

<span data-ttu-id="381cc-165">另一種情況是將資料檔案儲存在雲端儲存體中，並在使用者的電腦之間自動同步處理。</span><span class="sxs-lookup"><span data-stu-id="381cc-165">Another scenario is where the data file is stored in cloud storage and automatically synced between the user's machines.</span></span> <span data-ttu-id="381cc-166">能夠取得雲端儲存體帳戶存取權的攻擊者可能會有害資料檔案。</span><span class="sxs-lookup"><span data-stu-id="381cc-166">An attacker who is able to gain access to the cloud storage account can poison the data file.</span></span> <span data-ttu-id="381cc-167">此資料檔案會自動同步處理到使用者的電腦。</span><span class="sxs-lookup"><span data-stu-id="381cc-167">This data file will be automatically synced to the user's machines.</span></span> <span data-ttu-id="381cc-168">下次使用者開啟資料檔案時，就會執行攻擊者的承載。</span><span class="sxs-lookup"><span data-stu-id="381cc-168">The next time the user opens the data file, the attacker's payload runs.</span></span> <span data-ttu-id="381cc-169">因此，攻擊者可以利用雲端儲存體帳戶危害來取得完整的程式碼執行許可權。</span><span class="sxs-lookup"><span data-stu-id="381cc-169">Thus the attacker can leverage a cloud storage account compromise to gain full code execution permissions.</span></span>

<span data-ttu-id="381cc-170">__請考慮從桌面安裝模型移至雲端優先模型的應用程式。__</span><span class="sxs-lookup"><span data-stu-id="381cc-170">__Consider an app that moves from a desktop-install model to a cloud-first model.__</span></span> <span data-ttu-id="381cc-171">此案例包括從桌面應用程式或豐富型用戶端模型移至 web 架構模型的應用程式。</span><span class="sxs-lookup"><span data-stu-id="381cc-171">This scenario includes apps that move from a desktop app or rich client model into a web-based model.</span></span> <span data-ttu-id="381cc-172">針對桌面應用程式所繪製的任何威脅模型，都不一定適用于雲端式服務。</span><span class="sxs-lookup"><span data-stu-id="381cc-172">Any threat models drawn for the desktop app aren't necessarily applicable to the cloud-based service.</span></span> <span data-ttu-id="381cc-173">桌面應用程式的威脅模型可能會將指定的威脅關閉為「用戶端不感興趣」。</span><span class="sxs-lookup"><span data-stu-id="381cc-173">The threat model for the desktop app might dismiss a given threat as "not interesting for the client to attack itself."</span></span> <span data-ttu-id="381cc-174">但是，在認為遠端使用者（用戶端）攻擊雲端服務本身時，相同的威脅可能會變得很有趣。</span><span class="sxs-lookup"><span data-stu-id="381cc-174">But that same threat might become interesting when it considers a remote user (the client) attacking the cloud service itself.</span></span>

> [!NOTE]
> <span data-ttu-id="381cc-175">一般來說，序列化的目的是要將物件傳入或傳出應用程式。</span><span class="sxs-lookup"><span data-stu-id="381cc-175">In general terms, the intent of serialization is to transmit an object into or out of an app.</span></span> <span data-ttu-id="381cc-176">威脅模型化練習幾乎一律會將這類資料傳輸標示為跨越信任界限。</span><span class="sxs-lookup"><span data-stu-id="381cc-176">A threat modeling exercise almost always marks this kind of data transfer as crossing a trust boundary.</span></span>

## <a name="further-resources"></a><span data-ttu-id="381cc-177">進一步資源</span><span class="sxs-lookup"><span data-stu-id="381cc-177">Further resources</span></span>

* <span data-ttu-id="381cc-178">[YSoSerial.Net](https://github.com/pwntester/ysoserial.net)以研究敵人如何攻擊使用的應用程式 `BinaryFormatter` 。</span><span class="sxs-lookup"><span data-stu-id="381cc-178">[YSoSerial.Net](https://github.com/pwntester/ysoserial.net) for research into how adversaries attack apps that utilize `BinaryFormatter`.</span></span>
* <span data-ttu-id="381cc-179">[威脅模型](/securityengineering/sdl/threatmodeling)化，以取得威脅模型化應用程式和服務的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="381cc-179">[Threat Modeling](/securityengineering/sdl/threatmodeling) for information on threat modeling apps and services.</span></span>
* <span data-ttu-id="381cc-180">還原序列化弱點的一般背景：</span><span class="sxs-lookup"><span data-stu-id="381cc-180">General background on deserialization vulnerabilities:</span></span>
  * [<span data-ttu-id="381cc-181">OWASP Top 10-A8： 2017-不安全的還原序列化</span><span class="sxs-lookup"><span data-stu-id="381cc-181">OWASP Top 10 - A8:2017-Insecure Deserialization</span></span>](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A8-Insecure_Deserialization)
  * [<span data-ttu-id="381cc-182">CWE-502：未受信任資料的還原序列化</span><span class="sxs-lookup"><span data-stu-id="381cc-182">CWE-502: Deserialization of Untrusted Data</span></span>](https://cwe.mitre.org/data/definitions/502.html)
