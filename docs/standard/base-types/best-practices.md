---
title: .NET 中規則運算式的最佳做法
description: 了解如何在 .NET 中建立有效率且有效的規則運算式。
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- .NET Framework regular expressions, best practices
- regular expressions, best practices
ms.assetid: 618e5afb-3a97-440d-831a-70e4c526a51c
ms.openlocfilehash: ecfe0cca59b50da9231709dbd9a2de9b56391d4f
ms.sourcegitcommit: 33deec3e814238fb18a49b2a7e89278e27888291
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 06/02/2020
ms.locfileid: "84291054"
---
# <a name="best-practices-for-regular-expressions-in-net"></a><span data-ttu-id="a24fc-103">.NET 中的正則運算式最佳做法</span><span class="sxs-lookup"><span data-stu-id="a24fc-103">Best practices for regular expressions in .NET</span></span>

<span data-ttu-id="a24fc-104">.NET 中的規則運算式引擎是一項強大而功能完整的工具，會依據模式比對而非比較與比對常值文字的方式處理文字。</span><span class="sxs-lookup"><span data-stu-id="a24fc-104">The regular expression engine in .NET is a powerful, full-featured tool that processes text based on pattern matches rather than on comparing and matching literal text.</span></span> <span data-ttu-id="a24fc-105">在大部分情況下，它會快速且有效率地執行模式比對。</span><span class="sxs-lookup"><span data-stu-id="a24fc-105">In most cases, it performs pattern matching rapidly and efficiently.</span></span> <span data-ttu-id="a24fc-106">不過，在某些情況下，規則運算式引擎速度可能變得相當慢。</span><span class="sxs-lookup"><span data-stu-id="a24fc-106">However, in some cases, the regular expression engine can appear to be very slow.</span></span> <span data-ttu-id="a24fc-107">而只有鮮少情況下，它甚至可能在處理相對小的輸入卻耗費數小時甚至數天時停止回應。</span><span class="sxs-lookup"><span data-stu-id="a24fc-107">In extreme cases, it can even appear to stop responding as it processes a relatively small input over the course of hours or even days.</span></span>

<span data-ttu-id="a24fc-108">本主題說明一些開發人員可以採用的最佳做法，確保其規則運算式達到最佳效能。</span><span class="sxs-lookup"><span data-stu-id="a24fc-108">This topic outlines some of the best practices that developers can adopt to ensure that their regular expressions achieve optimal performance.</span></span>

## <a name="consider-the-input-source"></a><span data-ttu-id="a24fc-109">考慮輸入來源</span><span class="sxs-lookup"><span data-stu-id="a24fc-109">Consider the input source</span></span>

<span data-ttu-id="a24fc-110">一般而言，規則運算式可以接受兩種類型的輸入：受限制或未受限制。</span><span class="sxs-lookup"><span data-stu-id="a24fc-110">In general, regular expressions can accept two types of input: constrained or unconstrained.</span></span> <span data-ttu-id="a24fc-111">受限制的輸入是來自已知或可靠來源，並且遵循預先定義格式的文字。</span><span class="sxs-lookup"><span data-stu-id="a24fc-111">Constrained input is text that originates from a known or reliable source and follows a predefined format.</span></span> <span data-ttu-id="a24fc-112">未受限制的輸入是來自不可靠來源 (例如 Web 使用者) 的文字，且可能未依循預先定義或預期的格式。</span><span class="sxs-lookup"><span data-stu-id="a24fc-112">Unconstrained input is text that originates from an unreliable source, such as a web user, and may not follow a predefined or expected format.</span></span>

<span data-ttu-id="a24fc-113">通常撰寫規則運算式模式的目的在於比對有效輸入。</span><span class="sxs-lookup"><span data-stu-id="a24fc-113">Regular expression patterns are typically written to match valid input.</span></span> <span data-ttu-id="a24fc-114">也就是說，開發人員會檢查要比對的文字，然後撰寫比對該文字的規則運算式模式。</span><span class="sxs-lookup"><span data-stu-id="a24fc-114">That is, developers examine the text that they want to match and then write a regular expression pattern that matches it.</span></span> <span data-ttu-id="a24fc-115">接著開發人員會利用多個有效的輸入項目進行測試，藉此判斷此模式是否需要更正或進一步詳述。</span><span class="sxs-lookup"><span data-stu-id="a24fc-115">Developers then determine whether this pattern requires correction or further elaboration by testing it with multiple valid input items.</span></span> <span data-ttu-id="a24fc-116">當模式符合所有假設的有效輸入時，即宣告準備好實際執行，並且可以納入已發行的應用程式中。</span><span class="sxs-lookup"><span data-stu-id="a24fc-116">When the pattern matches all presumed valid inputs, it is declared to be production-ready and can be included in a released application.</span></span> <span data-ttu-id="a24fc-117">這種方式使得規則運算式模式相當適合比對限制的輸入，</span><span class="sxs-lookup"><span data-stu-id="a24fc-117">This makes a regular expression pattern suitable for matching constrained input.</span></span> <span data-ttu-id="a24fc-118">不過卻不適合比對未受限制的輸入。</span><span class="sxs-lookup"><span data-stu-id="a24fc-118">However, it does not make it suitable for matching unconstrained input.</span></span>

<span data-ttu-id="a24fc-119">若要比對未受限制的輸入，規則運算式必須能夠有效率地處理三種文字：</span><span class="sxs-lookup"><span data-stu-id="a24fc-119">To match unconstrained input, a regular expression must be able to efficiently handle three kinds of text:</span></span>

- <span data-ttu-id="a24fc-120">符合規則運算式模式的文字。</span><span class="sxs-lookup"><span data-stu-id="a24fc-120">Text that matches the regular expression pattern.</span></span>

- <span data-ttu-id="a24fc-121">不符合規則運算式模式的文字。</span><span class="sxs-lookup"><span data-stu-id="a24fc-121">Text that does not match the regular expression pattern.</span></span>

- <span data-ttu-id="a24fc-122">幾乎符合規則運算式模式的文字。</span><span class="sxs-lookup"><span data-stu-id="a24fc-122">Text that nearly matches the regular expression pattern.</span></span>

<span data-ttu-id="a24fc-123">最後一種文字對於專為處理受限制輸入的規則運算式而言尤其繁瑣。</span><span class="sxs-lookup"><span data-stu-id="a24fc-123">The last text type is especially problematic for a regular expression that has been written to handle constrained input.</span></span> <span data-ttu-id="a24fc-124">如果該規則運算式也依賴大量[回溯](backtracking-in-regular-expressions.md)，則規則運算式引擎可能耗費相當長的時間 (有些情況需要許多小時或許多天) 處理看似無關緊要的文字。</span><span class="sxs-lookup"><span data-stu-id="a24fc-124">If that regular expression also relies on extensive [backtracking](backtracking-in-regular-expressions.md), the regular expression engine can spend an inordinate amount of time (in some cases, many hours or days) processing seemingly innocuous text.</span></span>

> [!WARNING]
> <span data-ttu-id="a24fc-125">下列範例將使用容易造成大量回溯，而且可能拒絕有效電子郵件地址的規則運算式。</span><span class="sxs-lookup"><span data-stu-id="a24fc-125">The following example uses a regular expression that is prone to excessive backtracking and that is likely to reject valid email addresses.</span></span> <span data-ttu-id="a24fc-126">這個規則運算式不應該在電子郵件驗證常式中使用。</span><span class="sxs-lookup"><span data-stu-id="a24fc-126">You should not use it in an email validation routine.</span></span> <span data-ttu-id="a24fc-127">如果您想要會驗證電子郵件地址的規則運算式，請參閱[如何：確認字串是否為有效的電子郵件格式](how-to-verify-that-strings-are-in-valid-email-format.md)。</span><span class="sxs-lookup"><span data-stu-id="a24fc-127">If you would like a regular expression that validates email addresses, see [How to: Verify that Strings Are in Valid Email Format](how-to-verify-that-strings-are-in-valid-email-format.md).</span></span>

<span data-ttu-id="a24fc-128">例如，像是驗證電子郵件地址別名的規則運算式，這種規則運算式相當常用卻也極為繁瑣。</span><span class="sxs-lookup"><span data-stu-id="a24fc-128">For example, consider a very commonly used but extremely problematic regular expression for validating the alias of an email address.</span></span> <span data-ttu-id="a24fc-129">規則運算式 `^[0-9A-Z]([-.\w]*[0-9A-Z])*$` 主要用來處理一般視為有效的電子郵件地址，其中包含英數字元，後面接著零個或多個字元，而這些字元可以是英數字、句號或連字號。</span><span class="sxs-lookup"><span data-stu-id="a24fc-129">The regular expression `^[0-9A-Z]([-.\w]*[0-9A-Z])*$` is written to process what is considered to be a valid email address, which consists of an alphanumeric character, followed by zero or more characters that can be alphanumeric, periods, or hyphens.</span></span> <span data-ttu-id="a24fc-130">規則運算式的結尾必須是英數字元。</span><span class="sxs-lookup"><span data-stu-id="a24fc-130">The regular expression must end with an alphanumeric character.</span></span> <span data-ttu-id="a24fc-131">不過，如下面的範例所示，雖然這個規則運算式可輕鬆處理有效的輸入，但是當它處理幾乎有效的輸入時就非常沒有效率。</span><span class="sxs-lookup"><span data-stu-id="a24fc-131">However, as the following example shows, although this regular expression handles valid input easily, its performance is very inefficient when it is processing nearly valid input.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/design2.cs#1)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/design2.vb#1)]

<span data-ttu-id="a24fc-132">如範例的輸出所示，規則運算式引擎會以大致相同的時間間隔處理有效的電子郵件別名 (無論其長度為何)。</span><span class="sxs-lookup"><span data-stu-id="a24fc-132">As the output from the example shows, the regular expression engine processes the valid email alias in about the same time interval regardless of its length.</span></span> <span data-ttu-id="a24fc-133">但另一方面，當幾乎有效的電子郵件地址包含超過五個字元時，字串中超出的每個字元其處理時間約為兩倍。</span><span class="sxs-lookup"><span data-stu-id="a24fc-133">On the other hand, when the nearly valid email address has more than five characters, processing time approximately doubles for each additional character in the string.</span></span> <span data-ttu-id="a24fc-134">這表示，幾乎有效的 28 個字元字串需要超過一小時的處理時間，而幾乎有效的 33 個字元字串則需要將近一天來處理。</span><span class="sxs-lookup"><span data-stu-id="a24fc-134">This means that a nearly valid 28-character string would take over an hour to process, and a nearly valid 33-character string would take nearly a day to process.</span></span>

<span data-ttu-id="a24fc-135">由於這個規則運算式單純是考量所要比對輸入的格式而開發，因此並未考慮不符合模式的輸入。</span><span class="sxs-lookup"><span data-stu-id="a24fc-135">Because this regular expression was developed solely by considering the format of input to be matched, it fails to take account of input that does not match the pattern.</span></span> <span data-ttu-id="a24fc-136">而這種情況就會讓幾乎符合規則運算式模式的未受限制輸入大幅降低效能。</span><span class="sxs-lookup"><span data-stu-id="a24fc-136">This, in turn, can allow unconstrained input that nearly matches the regular expression pattern to significantly degrade performance.</span></span>

<span data-ttu-id="a24fc-137">若要解決這個問題，您可以執行下列操作：</span><span class="sxs-lookup"><span data-stu-id="a24fc-137">To solve this problem, you can do the following:</span></span>

- <span data-ttu-id="a24fc-138">開發模式時，您應考慮回溯可能對規則運算式引擎的效能造成的影響，尤其是規則運算式的設計為處理未受限制的輸入。</span><span class="sxs-lookup"><span data-stu-id="a24fc-138">When developing a pattern, you should consider how backtracking might affect the performance of the regular expression engine, particularly if your regular expression is designed to process unconstrained input.</span></span> <span data-ttu-id="a24fc-139">如需詳細資訊，請參閱[收取回溯](#take-charge-of-backtracking)一節。</span><span class="sxs-lookup"><span data-stu-id="a24fc-139">For more information, see the [Take Charge of Backtracking](#take-charge-of-backtracking) section.</span></span>

- <span data-ttu-id="a24fc-140">使用無效或幾乎有效的輸入以及有效輸入徹底測試您的規則運算式。</span><span class="sxs-lookup"><span data-stu-id="a24fc-140">Thoroughly test your regular expression using invalid and near-valid input as well as valid input.</span></span> <span data-ttu-id="a24fc-141">若要針對特殊規則運算式隨機產生輸入，您可以使用 [Rex](https://www.microsoft.com/research/project/rex-regular-expression-exploration/)，這是 Microsoft Research 提供的規則運算式探索工具。</span><span class="sxs-lookup"><span data-stu-id="a24fc-141">To generate input for a particular regular expression randomly, you can use [Rex](https://www.microsoft.com/research/project/rex-regular-expression-exploration/), which is a regular expression exploration tool from Microsoft Research.</span></span>

## <a name="handle-object-instantiation-appropriately"></a><span data-ttu-id="a24fc-142">適當處理物件具現化</span><span class="sxs-lookup"><span data-stu-id="a24fc-142">Handle object instantiation appropriately</span></span>

<span data-ttu-id="a24fc-143"><xref:System.Text.RegularExpressions.Regex?displayProperty=nameWithType> 類別是 .NET 規則運算式物件模型的核心，它代表規則運算式引擎。</span><span class="sxs-lookup"><span data-stu-id="a24fc-143">At the heart of .NET’s regular expression object model is the <xref:System.Text.RegularExpressions.Regex?displayProperty=nameWithType> class, which represents the regular expression engine.</span></span> <span data-ttu-id="a24fc-144">使用 <xref:System.Text.RegularExpressions.Regex> 引擎的方式經常是影響規則運算式效能最重要的一項因素。</span><span class="sxs-lookup"><span data-stu-id="a24fc-144">Often, the single greatest factor that affects regular expression performance is the way in which the <xref:System.Text.RegularExpressions.Regex> engine is used.</span></span> <span data-ttu-id="a24fc-145">定義規則運算式的工作與結合規則運算式引擎和規則運算式模式息息相關。</span><span class="sxs-lookup"><span data-stu-id="a24fc-145">Defining a regular expression involves tightly coupling the regular expression engine with a regular expression pattern.</span></span> <span data-ttu-id="a24fc-146">無論是傳遞規則運算式模式給 <xref:System.Text.RegularExpressions.Regex> 物件的建構函式，藉此將該物件具現化，或是將規則運算式模式連同要分析的字串一併傳遞給靜態方法，藉此呼叫該方法，這個結合的過程都必然相當昂貴。</span><span class="sxs-lookup"><span data-stu-id="a24fc-146">That coupling process, whether it involves instantiating a <xref:System.Text.RegularExpressions.Regex> object by passing its constructor a regular expression pattern or calling a static method by passing it the regular expression pattern along with the string to be analyzed, is by necessity an expensive one.</span></span>

> [!NOTE]
> <span data-ttu-id="a24fc-147">如需使用已解譯和已編譯規則運算式所造成不良效能影響的詳細討論，請參閱 BCL Team 部落格中的[將規則運算式的效能最佳化，第 II 部分：控制回溯](https://docs.microsoft.com/archive/blogs/bclteam/optimizing-regular-expression-performance-part-ii-taking-charge-of-backtracking-ron-petrusha) \(英文\)。</span><span class="sxs-lookup"><span data-stu-id="a24fc-147">For a more detailed discussion of the performance implications of using interpreted and compiled regular expressions, see [Optimizing Regular Expression Performance, Part II: Taking Charge of Backtracking](https://docs.microsoft.com/archive/blogs/bclteam/optimizing-regular-expression-performance-part-ii-taking-charge-of-backtracking-ron-petrusha) in the BCL Team blog.</span></span>

<span data-ttu-id="a24fc-148">您可以結合規則運算式引擎與特定規則運算式模式，然後使用引擎透過數種方式比對文字：</span><span class="sxs-lookup"><span data-stu-id="a24fc-148">You can couple the regular expression engine with a particular regular expression pattern and then use the engine to match text in several ways:</span></span>

- <span data-ttu-id="a24fc-149">您可以呼叫靜態模式比對方法，例如 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="a24fc-149">You can call a static pattern-matching method, such as <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29?displayProperty=nameWithType>.</span></span> <span data-ttu-id="a24fc-150">這樣就不需要具現化規則運算式物件。</span><span class="sxs-lookup"><span data-stu-id="a24fc-150">This does not require instantiation of a regular expression object.</span></span>

- <span data-ttu-id="a24fc-151">您可以具現化 <xref:System.Text.RegularExpressions.Regex> 物件，並且呼叫解譯之規則運算式的執行個體模式比對方法。</span><span class="sxs-lookup"><span data-stu-id="a24fc-151">You can instantiate a <xref:System.Text.RegularExpressions.Regex> object and call an instance pattern-matching method of an interpreted regular expression.</span></span> <span data-ttu-id="a24fc-152">這是將規則運算式引擎繫結至規則運算式模式的預設方法。</span><span class="sxs-lookup"><span data-stu-id="a24fc-152">This is the default method for binding the regular expression engine to a regular expression pattern.</span></span> <span data-ttu-id="a24fc-153">這個方法會在 <xref:System.Text.RegularExpressions.Regex> 物件具現化，但是沒有包含 `options` 旗標的 <xref:System.Text.RegularExpressions.RegexOptions.Compiled> 引數時得出結果。</span><span class="sxs-lookup"><span data-stu-id="a24fc-153">It results when a <xref:System.Text.RegularExpressions.Regex> object is instantiated without an `options` argument that includes the <xref:System.Text.RegularExpressions.RegexOptions.Compiled> flag.</span></span>

- <span data-ttu-id="a24fc-154">您可以具現化 <xref:System.Text.RegularExpressions.Regex> 物件，並且呼叫編譯之規則運算式的執行個體模式比對方法。</span><span class="sxs-lookup"><span data-stu-id="a24fc-154">You can instantiate a <xref:System.Text.RegularExpressions.Regex> object and call an instance pattern-matching method of a compiled regular expression.</span></span> <span data-ttu-id="a24fc-155">當 <xref:System.Text.RegularExpressions.Regex> 物件具現化且包含 `options` 旗標的 <xref:System.Text.RegularExpressions.RegexOptions.Compiled> 引數時，規則運算式物件就會表示編譯的模式。</span><span class="sxs-lookup"><span data-stu-id="a24fc-155">Regular expression objects represent compiled patterns when a <xref:System.Text.RegularExpressions.Regex> object is instantiated with an `options` argument that includes the <xref:System.Text.RegularExpressions.RegexOptions.Compiled> flag.</span></span>

- <span data-ttu-id="a24fc-156">您可以建立與特殊規則運算式模式緊密結合的特殊目的 <xref:System.Text.RegularExpressions.Regex> 物件、進行編譯，並且將它儲存到獨立的組件中。</span><span class="sxs-lookup"><span data-stu-id="a24fc-156">You can create a special-purpose <xref:System.Text.RegularExpressions.Regex> object that is tightly coupled with a particular regular expression pattern, compile it, and save it to a standalone assembly.</span></span> <span data-ttu-id="a24fc-157">您可以藉由呼叫 <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A?displayProperty=nameWithType> 方法執行這項作業。</span><span class="sxs-lookup"><span data-stu-id="a24fc-157">You do this by calling the <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="a24fc-158">您呼叫規則運算式比對方法的特殊方式可能對應用程式造成大幅影響。</span><span class="sxs-lookup"><span data-stu-id="a24fc-158">The particular way in which you call regular expression matching methods can have a significant impact on your application.</span></span> <span data-ttu-id="a24fc-159">下列各節將討論何時使用靜態方法呼叫、解譯的規則運算式以及編譯的規則運算式改善應用程式的效能。</span><span class="sxs-lookup"><span data-stu-id="a24fc-159">The following sections discuss when to use static method calls, interpreted regular expressions, and compiled regular expressions to improve your application's performance.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="a24fc-160">如果在方法呼叫中重複使用相同的規則運算式，或是應用程式大量使用規則運算式物件，則方法呼叫的形式 (靜態、解譯、編譯) 就會影響效能。</span><span class="sxs-lookup"><span data-stu-id="a24fc-160">The form of the method call (static, interpreted, compiled) affects performance if the same regular expression is used repeatedly in method calls, or if an application makes extensive use of regular expression objects.</span></span>

### <a name="static-regular-expressions"></a><span data-ttu-id="a24fc-161">靜態規則運算式</span><span class="sxs-lookup"><span data-stu-id="a24fc-161">Static regular expressions</span></span>

<span data-ttu-id="a24fc-162">建議您使用靜態規則運算式方法來替代使用相同的規則運算式重複具現化規則運算式物件。</span><span class="sxs-lookup"><span data-stu-id="a24fc-162">Static regular expression methods are recommended as an alternative to repeatedly instantiating a regular expression object with the same regular expression.</span></span> <span data-ttu-id="a24fc-163">不同于正則運算式物件所使用的正則運算式模式，正則運算式引擎會在內部快取從靜態方法呼叫中使用之模式的作業程式碼或已編譯的 Microsoft 中繼語言（MSIL）。</span><span class="sxs-lookup"><span data-stu-id="a24fc-163">Unlike regular expression patterns used by regular expression objects, either the operation codes or the compiled Microsoft intermediate language (MSIL) from patterns used in static method calls is cached internally by the regular expression engine.</span></span>

<span data-ttu-id="a24fc-164">例如，事件處理常式經常會呼叫另一個方法來驗證使用者輸入。</span><span class="sxs-lookup"><span data-stu-id="a24fc-164">For example, an event handler frequently calls another method to validate user input.</span></span> <span data-ttu-id="a24fc-165">下列程式碼中會反映這種情況，其中 <xref:System.Windows.Forms.Button> 控制項的 <xref:System.Windows.Forms.Control.Click> 事件會用來呼叫名為 `IsValidCurrency` 的方法，該方法會檢查使用者是否已輸入貨幣符號且後面至少有一個十進位數字。</span><span class="sxs-lookup"><span data-stu-id="a24fc-165">This is reflected in the following code, in which a <xref:System.Windows.Forms.Button> control's <xref:System.Windows.Forms.Control.Click> event is used to call a method named `IsValidCurrency`, which checks whether the user has entered a currency symbol followed by at least one decimal digit.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/static1.cs#2)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/static1.vb#2)]

<span data-ttu-id="a24fc-166">下列範例示範非常沒有效率的 `IsValidCurrency` 方法實作。</span><span class="sxs-lookup"><span data-stu-id="a24fc-166">A very inefficient implementation of the `IsValidCurrency` method is shown in the following example.</span></span> <span data-ttu-id="a24fc-167">請注意，每一個方法呼叫都會使用相同的模式重複具現化 <xref:System.Text.RegularExpressions.Regex> 物件。</span><span class="sxs-lookup"><span data-stu-id="a24fc-167">Note that each method call reinstantiates a <xref:System.Text.RegularExpressions.Regex> object with the same pattern.</span></span> <span data-ttu-id="a24fc-168">而這表示，每次呼叫方法時都必須重新編譯規則運算式。</span><span class="sxs-lookup"><span data-stu-id="a24fc-168">This, in turn, means that the regular expression pattern must be recompiled each time the method is called.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/static1.cs#3)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/static1.vb#3)]

<span data-ttu-id="a24fc-169">您應該用呼叫靜態 <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29?displayProperty=nameWithType> 方法取代這個沒有效率的程式碼。</span><span class="sxs-lookup"><span data-stu-id="a24fc-169">You should replace this inefficient code with a call to the static <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="a24fc-170">這樣就不必在每次您想要呼叫模式比對方法時具現化 <xref:System.Text.RegularExpressions.Regex> 物件，並且可讓規則運算式引擎從其快取擷取編譯版的規則運算式。</span><span class="sxs-lookup"><span data-stu-id="a24fc-170">This eliminates the need to instantiate a <xref:System.Text.RegularExpressions.Regex> object each time you want to call a pattern-matching method, and enables the regular expression engine to retrieve a compiled version of the regular expression from its cache.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/static2.cs#4)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/static2.vb#4)]

<span data-ttu-id="a24fc-171">根據預設，會快取 15 個最近使用的靜態規則運算式模式。</span><span class="sxs-lookup"><span data-stu-id="a24fc-171">By default, the last 15 most recently used static regular expression patterns are cached.</span></span> <span data-ttu-id="a24fc-172">針對需要大量快取之靜態規則運算式的應用程式，快取的大小可以透過設定 <xref:System.Text.RegularExpressions.Regex.CacheSize%2A?displayProperty=nameWithType> 屬性加以調整。</span><span class="sxs-lookup"><span data-stu-id="a24fc-172">For applications that require a larger number of cached static regular expressions, the size of the cache can be adjusted by setting the <xref:System.Text.RegularExpressions.Regex.CacheSize%2A?displayProperty=nameWithType> property.</span></span>

<span data-ttu-id="a24fc-173">這個範例中使用的規則運算式 `\p{Sc}+\s*\d+` 會驗證輸入字串是否包含貨幣符號和至少一個十進位數字。</span><span class="sxs-lookup"><span data-stu-id="a24fc-173">The regular expression `\p{Sc}+\s*\d+` that is used in this example verifies that the input string consists of a currency symbol and at least one decimal digit.</span></span> <span data-ttu-id="a24fc-174">模式的定義方式如下表所示。</span><span class="sxs-lookup"><span data-stu-id="a24fc-174">The pattern is defined as shown in the following table.</span></span>

|<span data-ttu-id="a24fc-175">模式</span><span class="sxs-lookup"><span data-stu-id="a24fc-175">Pattern</span></span>|<span data-ttu-id="a24fc-176">描述</span><span class="sxs-lookup"><span data-stu-id="a24fc-176">Description</span></span>|
|-------------|-----------------|
|`\p{Sc}+`|<span data-ttu-id="a24fc-177">比對 [Unicode Symbol, Currency] 分類中的一個或多個字元。</span><span class="sxs-lookup"><span data-stu-id="a24fc-177">Match one or more characters in the Unicode Symbol, Currency category.</span></span>|
|`\s*`|<span data-ttu-id="a24fc-178">比對零個以上的空白字元。</span><span class="sxs-lookup"><span data-stu-id="a24fc-178">Match zero or more white-space characters.</span></span>|
|`\d+`|<span data-ttu-id="a24fc-179">比對一個或多個十進位數字。</span><span class="sxs-lookup"><span data-stu-id="a24fc-179">Match one or more decimal digits.</span></span>|

### <a name="interpreted-vs-compiled-regular-expressions"></a><span data-ttu-id="a24fc-180">比較經過解譯與經過編譯的規則運算式</span><span class="sxs-lookup"><span data-stu-id="a24fc-180">Interpreted vs. compiled regular expressions</span></span>

<span data-ttu-id="a24fc-181">未透過指定 <xref:System.Text.RegularExpressions.RegexOptions.Compiled> 選項繫結程序至規則運算式引擎的規則運算式模式會加以解譯。</span><span class="sxs-lookup"><span data-stu-id="a24fc-181">Regular expression patterns that are not bound to the regular expression engine through the specification of the <xref:System.Text.RegularExpressions.RegexOptions.Compiled> option are interpreted.</span></span> <span data-ttu-id="a24fc-182">具現化規則運算式物件時，規則運算式引擎會將規則運算式轉換成一組作業程式碼。</span><span class="sxs-lookup"><span data-stu-id="a24fc-182">When a regular expression object is instantiated, the regular expression engine converts the regular expression to a set of operation codes.</span></span> <span data-ttu-id="a24fc-183">呼叫執行個體方法時，作業程式碼會轉換成 MSIL 並且由 JIT 編譯器執行。</span><span class="sxs-lookup"><span data-stu-id="a24fc-183">When an instance method is called, the operation codes are converted to MSIL and executed by the JIT compiler.</span></span> <span data-ttu-id="a24fc-184">同樣地，當呼叫靜態規則運算式方法而快取中找不到規則運算式時，規則運算式引擎會將規則運算式轉換成一組作業程式碼，並且將它們儲存到快取中。</span><span class="sxs-lookup"><span data-stu-id="a24fc-184">Similarly, when a static regular expression method is called and the regular expression cannot be found in the cache, the regular expression engine converts the regular expression to a set of operation codes and stores them in the cache.</span></span> <span data-ttu-id="a24fc-185">然後引擎會將這些作業程式碼轉換成 MSIL，JIT 編譯器就可以執行這些作業程式碼。</span><span class="sxs-lookup"><span data-stu-id="a24fc-185">It then converts these operation codes to MSIL so that the JIT compiler can execute them.</span></span> <span data-ttu-id="a24fc-186">解譯的規則運算式會藉由放慢執行時間來縮短啟動時間。</span><span class="sxs-lookup"><span data-stu-id="a24fc-186">Interpreted regular expressions reduce startup time at the cost of slower execution time.</span></span> <span data-ttu-id="a24fc-187">因此，在少數方法呼叫中使用規則運算式時，或是雖然不知道規則運算式方法呼叫的確實數目，但是期望數目很少時，最適合使用解譯的規則運算式。</span><span class="sxs-lookup"><span data-stu-id="a24fc-187">Because of this, they are best used when the regular expression is used in a small number of method calls, or if the exact number of calls to regular expression methods is unknown but is expected to be small.</span></span> <span data-ttu-id="a24fc-188">隨著方法呼叫的數目增加，放慢執行速度就會壓縮掉縮短啟動時間所獲得的效能。</span><span class="sxs-lookup"><span data-stu-id="a24fc-188">As the number of method calls increases, the performance gain from reduced startup time is outstripped by the slower execution speed.</span></span>

<span data-ttu-id="a24fc-189">透過指定 <xref:System.Text.RegularExpressions.RegexOptions.Compiled> 選項繫結程序至規則運算式引擎的規則運算式模式會加以編譯。</span><span class="sxs-lookup"><span data-stu-id="a24fc-189">Regular expression patterns that are bound to the regular expression engine through the specification of the <xref:System.Text.RegularExpressions.RegexOptions.Compiled> option are compiled.</span></span> <span data-ttu-id="a24fc-190">這表示，當具現化規則運算式物件，或是當呼叫靜態規則運算式方法而快取中找不到規則運算式時，規則運算式引擎會將規則運算式轉換成一組中繼的作業程式碼，然後將這些程式碼轉換成 MSIL。</span><span class="sxs-lookup"><span data-stu-id="a24fc-190">This means that, when a regular expression object is instantiated, or when a static regular expression method is called and the regular expression cannot be found in the cache, the regular expression engine converts the regular expression to an intermediary set of operation codes, which it then converts to MSIL.</span></span> <span data-ttu-id="a24fc-191">呼叫方法時，JIT 編譯器會執行 MSIL。</span><span class="sxs-lookup"><span data-stu-id="a24fc-191">When a method is called, the JIT compiler executes the MSIL.</span></span> <span data-ttu-id="a24fc-192">與解譯的規則運算式相反的是，編譯的規則運算式會延長啟動時間，但加快執行個別模式比對方法的速度。</span><span class="sxs-lookup"><span data-stu-id="a24fc-192">In contrast to interpreted regular expressions, compiled regular expressions increase startup time but execute individual pattern-matching methods faster.</span></span> <span data-ttu-id="a24fc-193">因此，編譯規則運算式所獲得的效能優勢會與呼叫的規則運算式方法數目成比例。</span><span class="sxs-lookup"><span data-stu-id="a24fc-193">As a result, the performance benefit that results from compiling the regular expression increases in proportion to the number of regular expression methods called.</span></span>

<span data-ttu-id="a24fc-194">簡言之，我們建議您在呼叫含有相對較不常用之特定規則運算式的規則運算式方法時，使用解譯的規則運算式。</span><span class="sxs-lookup"><span data-stu-id="a24fc-194">To summarize, we recommend that you use interpreted regular expressions when you call regular expression methods with a specific regular expression relatively infrequently.</span></span> <span data-ttu-id="a24fc-195">而當您呼叫含有相對較常用之特定規則運算式的規則運算式方法時，則應該使用編譯的規則運算式。</span><span class="sxs-lookup"><span data-stu-id="a24fc-195">You should use compiled regular expressions when you call regular expression methods with a specific regular expression relatively frequently.</span></span> <span data-ttu-id="a24fc-196">無論是放慢解譯的規則運算式執行速度所提升的效能超過縮短的啟動時間，或是放慢編譯的規則運算式啟動時間所提升的效能超過加快執行速度，都不容易判斷出其確實的臨界值。</span><span class="sxs-lookup"><span data-stu-id="a24fc-196">The exact threshold at which the slower execution speeds of interpreted regular expressions outweigh gains from their reduced startup time, or the threshold at which the slower startup times of compiled regular expressions outweigh gains from their faster execution speeds, is difficult to determine.</span></span> <span data-ttu-id="a24fc-197">因為臨界值取決於各種不同的因素，包括規則運算式及其處理之特定資料的複雜度。</span><span class="sxs-lookup"><span data-stu-id="a24fc-197">It depends on a variety of factors, including the complexity of the regular expression and the specific data that it processes.</span></span> <span data-ttu-id="a24fc-198">若要判斷究竟是解譯或編譯的規則運算式能為您的特殊應用程式案例提供最佳效能，您可以使用 <xref:System.Diagnostics.Stopwatch> 類別比較兩者的執行時間。</span><span class="sxs-lookup"><span data-stu-id="a24fc-198">To determine whether interpreted or compiled regular expressions offer the best performance for your particular application scenario, you can use the <xref:System.Diagnostics.Stopwatch> class to compare their execution times.</span></span>

<span data-ttu-id="a24fc-199">下列範例會比較已編譯和已解譯的規則運算式讀取 Theodore Dreiser 所著 *The Financier* 一文的前十個句子及讀取所有句子時的效能。</span><span class="sxs-lookup"><span data-stu-id="a24fc-199">The following example compares the performance of compiled and interpreted regular expressions when reading the first ten sentences and when reading all the sentences in the text of Theodore Dreiser's *The Financier*.</span></span> <span data-ttu-id="a24fc-200">如範例的輸出所示，僅對規則運算式比對方法進行十次呼叫時，解譯的規則運算式能提供比編譯的規則運算式更佳的效能。</span><span class="sxs-lookup"><span data-stu-id="a24fc-200">As the output from the example shows, when only ten calls are made to regular expression matching methods, an interpreted regular expression offers better performance than a compiled regular expression.</span></span> <span data-ttu-id="a24fc-201">但是進行大量呼叫 (此案例中為超過 13,000 次) 時，編譯的規則運算式會提供較佳的效能。</span><span class="sxs-lookup"><span data-stu-id="a24fc-201">However, a compiled regular expression offers better performance when a large number of calls (in this case, over 13,000) are made.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/compare1.cs#5)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/compare1.vb#5)]

<span data-ttu-id="a24fc-202">範例中所使用規則運算式模式 `\b(\w+((\r?\n)|,?\s))*\w+[.?:;!]` 的定義方式如下表所示。</span><span class="sxs-lookup"><span data-stu-id="a24fc-202">The regular expression pattern used in the example, `\b(\w+((\r?\n)|,?\s))*\w+[.?:;!]`, is defined as shown in the following table.</span></span>

|<span data-ttu-id="a24fc-203">模式</span><span class="sxs-lookup"><span data-stu-id="a24fc-203">Pattern</span></span>|<span data-ttu-id="a24fc-204">描述</span><span class="sxs-lookup"><span data-stu-id="a24fc-204">Description</span></span>|
|-------------|-----------------|
|`\b`|<span data-ttu-id="a24fc-205">開始字緣比對。</span><span class="sxs-lookup"><span data-stu-id="a24fc-205">Begin the match at a word boundary.</span></span>|
|`\w+`|<span data-ttu-id="a24fc-206">比對一個或多個文字字元。</span><span class="sxs-lookup"><span data-stu-id="a24fc-206">Match one or more word characters.</span></span>|
|<code>(\r?\n)&#124;,?\s)</code>|<span data-ttu-id="a24fc-207">比對後面接著新行字元的零個或一個歸位字元，或是後面接著空白字元的零個或一個逗號。</span><span class="sxs-lookup"><span data-stu-id="a24fc-207">Match either zero or one carriage return followed by a newline character, or zero or one comma followed by a white-space character.</span></span>|
|<code>(\w+((\r?\n)&#124;,?\s))*</code>|<span data-ttu-id="a24fc-208">比對出現零次或多次的一個或多個文字字元，其後面會接著零個或一個歸位字元和新行字元，或是後面接著空白字元的零個或一個逗號。</span><span class="sxs-lookup"><span data-stu-id="a24fc-208">Match zero or more occurrences of one or more word characters that are followed either by zero or one carriage return and a newline character, or by zero or one comma followed by a white-space character.</span></span>|
|`\w+`|<span data-ttu-id="a24fc-209">比對一個或多個文字字元。</span><span class="sxs-lookup"><span data-stu-id="a24fc-209">Match one or more word characters.</span></span>|
|`[.?:;!]`|<span data-ttu-id="a24fc-210">比對句號、問號、冒號、分號或驚嘆號。</span><span class="sxs-lookup"><span data-stu-id="a24fc-210">Match a period, question mark, colon, semicolon, or exclamation point.</span></span>|

### <a name="regular-expressions-compiled-to-an-assembly"></a><span data-ttu-id="a24fc-211">正則運算式：編譯成元件</span><span class="sxs-lookup"><span data-stu-id="a24fc-211">Regular expressions: Compiled to an assembly</span></span>

<span data-ttu-id="a24fc-212">.NET 也可讓您建立包含已編譯規則運算式的組件。</span><span class="sxs-lookup"><span data-stu-id="a24fc-212">.NET also enables you to create an assembly that contains compiled regular expressions.</span></span> <span data-ttu-id="a24fc-213">這樣會將規則運算式編譯的效能影響從執行階段移至設計階段。</span><span class="sxs-lookup"><span data-stu-id="a24fc-213">This moves the performance hit of regular expression compilation from run time to design time.</span></span> <span data-ttu-id="a24fc-214">不過，它還包含了一些額外的工作：您必須事先定義規則運算式，並且將其編譯為組件。</span><span class="sxs-lookup"><span data-stu-id="a24fc-214">However, it also involves some additional work: You must define the regular expressions in advance and compile them to an assembly.</span></span> <span data-ttu-id="a24fc-215">接著編譯器就可在編譯使用組件之規則運算式的原始程式碼時參考這個組件。</span><span class="sxs-lookup"><span data-stu-id="a24fc-215">The compiler can then reference this assembly when compiling source code that uses the assembly’s regular expressions.</span></span> <span data-ttu-id="a24fc-216">組件中的每個編譯的規則運算式都會以衍生自 <xref:System.Text.RegularExpressions.Regex> 的類別表示。</span><span class="sxs-lookup"><span data-stu-id="a24fc-216">Each compiled regular expression in the assembly is represented by a class that derives from <xref:System.Text.RegularExpressions.Regex>.</span></span>

<span data-ttu-id="a24fc-217">若要將規則運算式編譯為組件，請呼叫 <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%29?displayProperty=nameWithType> 方法，並且將代表要編譯之規則運算式的 <xref:System.Text.RegularExpressions.RegexCompilationInfo> 物件陣列，以及包含所要建立組件之相關資訊的 <xref:System.Reflection.AssemblyName> 物件傳遞給該方法。</span><span class="sxs-lookup"><span data-stu-id="a24fc-217">To compile regular expressions to an assembly, you call the <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%29?displayProperty=nameWithType> method and pass it an array of <xref:System.Text.RegularExpressions.RegexCompilationInfo> objects that represent the regular expressions to be compiled, and an <xref:System.Reflection.AssemblyName> object that contains information about the assembly to be created.</span></span>

<span data-ttu-id="a24fc-218">建議您在下列情況下將規則運算式編譯為組件：</span><span class="sxs-lookup"><span data-stu-id="a24fc-218">We recommend that you compile regular expressions to an assembly in the following situations:</span></span>

- <span data-ttu-id="a24fc-219">如果您是元件開發人員，而且想要建立可重複使用的規則運算式程式庫。</span><span class="sxs-lookup"><span data-stu-id="a24fc-219">If you are a component developer who wants to create a library of reusable regular expressions.</span></span>

- <span data-ttu-id="a24fc-220">如果您希望不定次數 (從一、兩次到數千、數萬次) 地呼叫規則運算式的模式比對方法。</span><span class="sxs-lookup"><span data-stu-id="a24fc-220">If you expect your regular expression's pattern-matching methods to be called an indeterminate number of times -- anywhere from once or twice to thousands or tens of thousands of times.</span></span> <span data-ttu-id="a24fc-221">與編譯或解譯的規則運算式不同的是，無論方法呼叫的次數為何，編譯為個別組件的規則運算式都會提供一致的效能。</span><span class="sxs-lookup"><span data-stu-id="a24fc-221">Unlike compiled or interpreted regular expressions, regular expressions that are compiled to separate assemblies offer performance that is consistent regardless of the number of method calls.</span></span>

<span data-ttu-id="a24fc-222">如果您要使用編譯的規則運算式來最佳化效能，則不應使用反映來建立組件、載入規則運算式引擎，以及執行其模式比對方法。</span><span class="sxs-lookup"><span data-stu-id="a24fc-222">If you are using compiled regular expressions to optimize performance, you should not use reflection to create the assembly, load the regular expression engine, and execute its pattern-matching methods.</span></span> <span data-ttu-id="a24fc-223">因此您就必須避免動態建置規則運算式模式，並且在建立組件時指定任何模式比對選項 (例如不區分大小寫的模式比對)。</span><span class="sxs-lookup"><span data-stu-id="a24fc-223">This requires that you avoid building regular expression patterns dynamically, and that you specify any pattern-matching options (such as case-insensitive pattern matching) at the time the assembly is created.</span></span> <span data-ttu-id="a24fc-224">另外，您也必須將建立組件的程式碼與使用規則運算式的程式碼分開。</span><span class="sxs-lookup"><span data-stu-id="a24fc-224">It also requires that you separate the code that creates the assembly from the code that uses the regular expression.</span></span>

<span data-ttu-id="a24fc-225">下列範例示範如何建立內含編譯的規則運算式的組件。</span><span class="sxs-lookup"><span data-stu-id="a24fc-225">The following example shows how to create an assembly that contains a compiled regular expression.</span></span> <span data-ttu-id="a24fc-226">它會建立一個名為 `RegexLib.dll` 且具有單一正則運算式類別的元件， `SentencePattern` 其中包含在 [[解讀與編譯的正則運算式](#interpreted-vs-compiled-regular-expressions)] 區段中使用的句子比對正則運算式模式。</span><span class="sxs-lookup"><span data-stu-id="a24fc-226">It creates an assembly named `RegexLib.dll` with a single regular expression class, `SentencePattern`, that contains the sentence-matching regular expression pattern used in the [Interpreted vs. Compiled Regular Expressions](#interpreted-vs-compiled-regular-expressions) section.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#6](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/compile1.cs#6)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/compile1.vb#6)]

<span data-ttu-id="a24fc-227">當範例編譯為可執行檔並且執行時，會建立名為 `RegexLib.dll` 的組件。</span><span class="sxs-lookup"><span data-stu-id="a24fc-227">When the example is compiled to an executable and run, it creates an assembly named `RegexLib.dll`.</span></span> <span data-ttu-id="a24fc-228">規則運算式會以衍生自 `Utilities.RegularExpressions.SentencePattern` 且名為 <xref:System.Text.RegularExpressions.Regex> 的類別表示。</span><span class="sxs-lookup"><span data-stu-id="a24fc-228">The regular expression is represented by a class named `Utilities.RegularExpressions.SentencePattern` that is derived from <xref:System.Text.RegularExpressions.Regex>.</span></span> <span data-ttu-id="a24fc-229">下列範例接著會使用已編譯的規則運算式來擷取 Theodore Dreiser 所著 *The Financier* 一文中的句子。</span><span class="sxs-lookup"><span data-stu-id="a24fc-229">The following example then uses the compiled regular expression to extract the sentences from the text of Theodore Dreiser's *The Financier*.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#7](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/compile2.cs#7)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/compile2.vb#7)]

## <a name="take-charge-of-backtracking"></a><span data-ttu-id="a24fc-230">控制回溯</span><span class="sxs-lookup"><span data-stu-id="a24fc-230">Take charge of backtracking</span></span>

<span data-ttu-id="a24fc-231">通常規則運算式引擎會使用線性迴歸逐一處理輸入字串，並且與規則運算式模式比較。</span><span class="sxs-lookup"><span data-stu-id="a24fc-231">Ordinarily, the regular expression engine uses linear progression to move through an input string and compare it to a regular expression pattern.</span></span> <span data-ttu-id="a24fc-232">不過，當規則運算式模式中使用不定數的數量詞 (例如 `*`、`+` 和 `?`) 時，規則運算式引擎可能會放棄一部分成功的部分符合結果，並且返回之前儲存的狀態，以便搜尋與整個模式完全相符的結果。</span><span class="sxs-lookup"><span data-stu-id="a24fc-232">However, when indeterminate quantifiers such as `*`, `+`, and `?` are used in a regular expression pattern, the regular expression engine may give up a portion of successful partial matches and return to a previously saved state in order to search for a successful match for the entire pattern.</span></span> <span data-ttu-id="a24fc-233">這個程序稱為「回溯」(Backtracking)。</span><span class="sxs-lookup"><span data-stu-id="a24fc-233">This process is known as backtracking.</span></span>

> [!NOTE]
> <span data-ttu-id="a24fc-234">如需有關回溯的詳細資訊，請參閱[規則運算式行為的詳細資料](details-of-regular-expression-behavior.md)和[回溯](backtracking-in-regular-expressions.md)。</span><span class="sxs-lookup"><span data-stu-id="a24fc-234">For more information on backtracking, see [Details of Regular Expression Behavior](details-of-regular-expression-behavior.md) and [Backtracking](backtracking-in-regular-expressions.md).</span></span> <span data-ttu-id="a24fc-235">如需有關回溯的詳細討論，請參閱 BCL Team 部落格中的[將規則運算式的效能最佳化，第 II 部分：控制回溯](https://docs.microsoft.com/archive/blogs/bclteam/optimizing-regular-expression-performance-part-ii-taking-charge-of-backtracking-ron-petrusha) \(英文\)。</span><span class="sxs-lookup"><span data-stu-id="a24fc-235">For a detailed discussion of backtracking, see [Optimizing Regular Expression Performance, Part II: Taking Charge of Backtracking](https://docs.microsoft.com/archive/blogs/bclteam/optimizing-regular-expression-performance-part-ii-taking-charge-of-backtracking-ron-petrusha) in the BCL Team blog.</span></span>

<span data-ttu-id="a24fc-236">支援回溯能讓規則運算式更強大且更靈活，</span><span class="sxs-lookup"><span data-stu-id="a24fc-236">Support for backtracking gives regular expressions power and flexibility.</span></span> <span data-ttu-id="a24fc-237">同時還能讓規則運算式開發人員負責掌控規則運算式引擎的作業。</span><span class="sxs-lookup"><span data-stu-id="a24fc-237">It also places the responsibility for controlling the operation of the regular expression engine in the hands of regular expression developers.</span></span> <span data-ttu-id="a24fc-238">由於開發人員經常忽略這個責任而誤用回溯或大量使用回溯，因而時常是造成規則運算式效能低落的最重要原因。</span><span class="sxs-lookup"><span data-stu-id="a24fc-238">Because developers are often not aware of this responsibility, their misuse of backtracking or reliance on excessive backtracking often plays the most significant role in degrading regular expression performance.</span></span> <span data-ttu-id="a24fc-239">在最糟的情況下，輸入字串中每個超出字元的執行時間可能會倍增。</span><span class="sxs-lookup"><span data-stu-id="a24fc-239">In a worst-case scenario, execution time can double for each additional character in the input string.</span></span> <span data-ttu-id="a24fc-240">事實上，如果輸入幾乎符合規則運算式模式的話，大量使用回溯很容易製造相當於程式設計上的無窮迴圈，而規則運算式引擎可能需要數小時，甚至數天來處理相對來說很短的輸入字串。</span><span class="sxs-lookup"><span data-stu-id="a24fc-240">In fact, by using backtracking excessively, it is easy to create the programmatic equivalent of an endless loop if input nearly matches the regular expression pattern; the regular expression engine may take hours or even days to process a relatively short input string.</span></span>

<span data-ttu-id="a24fc-241">儘管回溯並不是比對的要件，應用程式常常會因為使用回溯而影響效能。</span><span class="sxs-lookup"><span data-stu-id="a24fc-241">Often, applications pay a performance penalty for using backtracking despite the fact that backtracking is not essential for a match.</span></span> <span data-ttu-id="a24fc-242">例如，規則運算式 `\b\p{Lu}\w*\b` 會比對所有開頭為大寫字元的文字，如下表所示。</span><span class="sxs-lookup"><span data-stu-id="a24fc-242">For example, the regular expression `\b\p{Lu}\w*\b` matches all words that begin with an uppercase character, as the following table shows.</span></span>

|<span data-ttu-id="a24fc-243">模式</span><span class="sxs-lookup"><span data-stu-id="a24fc-243">Pattern</span></span>|<span data-ttu-id="a24fc-244">描述</span><span class="sxs-lookup"><span data-stu-id="a24fc-244">Description</span></span>|
|-|-|
|`\b`|<span data-ttu-id="a24fc-245">開始字緣比對。</span><span class="sxs-lookup"><span data-stu-id="a24fc-245">Begin the match at a word boundary.</span></span>|
|`\p{Lu}`|<span data-ttu-id="a24fc-246">比對大寫字元。</span><span class="sxs-lookup"><span data-stu-id="a24fc-246">Match an uppercase character.</span></span>|
|`\w*`|<span data-ttu-id="a24fc-247">比對零個或多個文字字元。</span><span class="sxs-lookup"><span data-stu-id="a24fc-247">Match zero or more word characters.</span></span>|
|`\b`|<span data-ttu-id="a24fc-248">結束字緣比對。</span><span class="sxs-lookup"><span data-stu-id="a24fc-248">End the match at a word boundary.</span></span>|

<span data-ttu-id="a24fc-249">由於字緣與文字字元不同，也不是文字字元的子集，因此規則運算式引擎不可能在比對文字字元時跨越字緣。</span><span class="sxs-lookup"><span data-stu-id="a24fc-249">Because a word boundary is not the same as, or a subset of, a word character, there is no possibility that the regular expression engine will cross a word boundary when matching word characters.</span></span> <span data-ttu-id="a24fc-250">這表示對於這個規則運算式來說，回溯不會使任何比對完全成功，只會造成效能降低，因為規則運算式引擎會被迫儲存每一個成功的初始文字字元比對的狀態。</span><span class="sxs-lookup"><span data-stu-id="a24fc-250">This means that for this regular expression, backtracking can never contribute to the overall success of any match -- it can only degrade performance, because the regular expression engine is forced to save its state for each successful preliminary match of a word character.</span></span>

<span data-ttu-id="a24fc-251">如果您判斷不需要回溯，可以使用 `(?>subexpression)` language 元素（稱為不可部分完成的群組）來停用它。</span><span class="sxs-lookup"><span data-stu-id="a24fc-251">If you determine that backtracking is not necessary, you can disable it by using the `(?>subexpression)` language element, known as an atomic group.</span></span> <span data-ttu-id="a24fc-252">下列範例會使用兩個規則運算式剖析輸入字串。</span><span class="sxs-lookup"><span data-stu-id="a24fc-252">The following example parses an input string by using two regular expressions.</span></span> <span data-ttu-id="a24fc-253">首先，`\b\p{Lu}\w*\b` 會仰賴回溯。</span><span class="sxs-lookup"><span data-stu-id="a24fc-253">The first, `\b\p{Lu}\w*\b`, relies on backtracking.</span></span> <span data-ttu-id="a24fc-254">第二，`\b\p{Lu}(?>\w*)\b` 會停用回溯。</span><span class="sxs-lookup"><span data-stu-id="a24fc-254">The second, `\b\p{Lu}(?>\w*)\b`, disables backtracking.</span></span> <span data-ttu-id="a24fc-255">如範例的輸出所示，兩者會產生相同的結果。</span><span class="sxs-lookup"><span data-stu-id="a24fc-255">As the output from the example shows, they both produce the same result.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#10](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/backtrack2.cs#10)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#10](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/backtrack2.vb#10)]

<span data-ttu-id="a24fc-256">在許多情況下，回溯是比對規則運算式模式與輸入文字時所必要。</span><span class="sxs-lookup"><span data-stu-id="a24fc-256">In many cases, backtracking is essential for matching a regular expression pattern to input text.</span></span> <span data-ttu-id="a24fc-257">不過，大量回溯可能嚴重降低效能，並且製造應用程式停止回應的印象。</span><span class="sxs-lookup"><span data-stu-id="a24fc-257">However, excessive backtracking can severely degrade performance and create the impression that an application has stopped responding.</span></span> <span data-ttu-id="a24fc-258">尤其是當數量詞為巢狀，而且符合外部子運算式的文字是符合內部子運算式之文字的子集時，就會發生這種情況。</span><span class="sxs-lookup"><span data-stu-id="a24fc-258">In particular, this happens when quantifiers are nested and the text that matches the outer subexpression is a subset of the text that matches the inner subexpression.</span></span>

> [!WARNING]
> <span data-ttu-id="a24fc-259">除了避免大量回溯以外，您應該使用逾時功能確保大量回溯不會嚴重降低規則運算式的效能。</span><span class="sxs-lookup"><span data-stu-id="a24fc-259">In addition to avoiding excessive backtracking, you should use the timeout feature to ensure that excessive backtracking does not severely degrade regular expression performance.</span></span> <span data-ttu-id="a24fc-260">如需詳細資訊，請參閱[使用逾時值](#use-time-out-values)一節。</span><span class="sxs-lookup"><span data-stu-id="a24fc-260">For more information, see the [Use Time-out Values](#use-time-out-values) section.</span></span>

<span data-ttu-id="a24fc-261">例如，規則運算式模式 `^[0-9A-Z]([-.\w]*[0-9A-Z])*\$$` 的目的在於比對至少包含一個英數字元的零件編號。</span><span class="sxs-lookup"><span data-stu-id="a24fc-261">For example, the regular expression pattern `^[0-9A-Z]([-.\w]*[0-9A-Z])*\$$` is intended to match a part number that consists of at least one alphanumeric character.</span></span> <span data-ttu-id="a24fc-262">任何額外的字元都可能包含英數字元、連字號、底線或句號，不過最後一個字元必須是英數字。</span><span class="sxs-lookup"><span data-stu-id="a24fc-262">Any additional characters can consist of an alphanumeric character, a hyphen, an underscore, or a period, though the last character must be alphanumeric.</span></span> <span data-ttu-id="a24fc-263">$ 符號則結束零件編號。</span><span class="sxs-lookup"><span data-stu-id="a24fc-263">A dollar sign terminates the part number.</span></span> <span data-ttu-id="a24fc-264">在某些情況下，這個規則運算式模式可能顯現出極差的效能，因為數量詞為巢狀，而且子運算式 `[0-9A-Z]` 是 `[-.\w]*` 子運算式的子集。</span><span class="sxs-lookup"><span data-stu-id="a24fc-264">In some cases, this regular expression pattern can exhibit extremely poor performance because quantifiers are nested, and because the subexpression `[0-9A-Z]` is a subset of the subexpression `[-.\w]*`.</span></span>

<span data-ttu-id="a24fc-265">在這類情況下，您可以移除巢狀數量詞，並且將外部子運算式取代為零寬度的右合樣或左合樣判斷提示，藉此最佳化規則運算式的效能。</span><span class="sxs-lookup"><span data-stu-id="a24fc-265">In these cases, you can optimize regular expression performance by removing the nested quantifiers and replacing the outer subexpression with a zero-width lookahead or lookbehind assertion.</span></span> <span data-ttu-id="a24fc-266">右合樣和左合樣判斷提示是錨點，它們不會移動輸入字串中的指標，而是向右或向左合樣，以檢查是否符合指定的條件。</span><span class="sxs-lookup"><span data-stu-id="a24fc-266">Lookahead and lookbehind assertions are anchors; they do not move the pointer in the input string, but instead look ahead or behind to check whether a specified condition is met.</span></span> <span data-ttu-id="a24fc-267">例如，零件編號規則運算式可以重寫為 `^[0-9A-Z][-.\w]*(?<=[0-9A-Z])\$$`。</span><span class="sxs-lookup"><span data-stu-id="a24fc-267">For example, the part number regular expression can be rewritten as `^[0-9A-Z][-.\w]*(?<=[0-9A-Z])\$$`.</span></span> <span data-ttu-id="a24fc-268">這個規則運算式模式的定義方式如下表所示。</span><span class="sxs-lookup"><span data-stu-id="a24fc-268">This regular expression pattern is defined as shown in the following table.</span></span>

|<span data-ttu-id="a24fc-269">模式</span><span class="sxs-lookup"><span data-stu-id="a24fc-269">Pattern</span></span>|<span data-ttu-id="a24fc-270">描述</span><span class="sxs-lookup"><span data-stu-id="a24fc-270">Description</span></span>|
|-------------|-----------------|
|`^`|<span data-ttu-id="a24fc-271">在輸入字串的開頭開始比對。</span><span class="sxs-lookup"><span data-stu-id="a24fc-271">Begin the match at the beginning of the input string.</span></span>|
|`[0-9A-Z]`|<span data-ttu-id="a24fc-272">比對英數字元。</span><span class="sxs-lookup"><span data-stu-id="a24fc-272">Match an alphanumeric character.</span></span> <span data-ttu-id="a24fc-273">零件編號必須至少包含這個字元。</span><span class="sxs-lookup"><span data-stu-id="a24fc-273">The part number must consist of at least this character.</span></span>|
|`[-.\w]*`|<span data-ttu-id="a24fc-274">比對出現零次或多次的任何文字字元、連字號或句號。</span><span class="sxs-lookup"><span data-stu-id="a24fc-274">Match zero or more occurrences of any word character, hyphen, or period.</span></span>|
|`\$`|<span data-ttu-id="a24fc-275">比對 $ 符號。</span><span class="sxs-lookup"><span data-stu-id="a24fc-275">Match a dollar sign.</span></span>|
|`(?<=[0-9A-Z])`|<span data-ttu-id="a24fc-276">向右合樣結尾的 $ 符號，確定前一個字元是英數字。</span><span class="sxs-lookup"><span data-stu-id="a24fc-276">Look ahead of the ending dollar sign to ensure that the previous character is alphanumeric.</span></span>|
|`$`|<span data-ttu-id="a24fc-277">在輸入字串結尾結束比對。</span><span class="sxs-lookup"><span data-stu-id="a24fc-277">End the match at the end of the input string.</span></span>|

<span data-ttu-id="a24fc-278">下列範例說明如何使用這個規則運算式比對包含可能零件編號的陣列。</span><span class="sxs-lookup"><span data-stu-id="a24fc-278">The following example illustrates the use of this regular expression to match an array containing possible part numbers.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#11](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/backtrack4.cs#11)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#11](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/backtrack4.vb#11)]

<span data-ttu-id="a24fc-279">.NET 中的規則運算式語言包括下列語言項目，可讓您用來消除巢狀數量詞。</span><span class="sxs-lookup"><span data-stu-id="a24fc-279">The regular expression language in .NET includes the following language elements that you can use to eliminate nested quantifiers.</span></span> <span data-ttu-id="a24fc-280">如需詳細資訊，請參閱[群組建構](grouping-constructs-in-regular-expressions.md)。</span><span class="sxs-lookup"><span data-stu-id="a24fc-280">For more information, see [Grouping Constructs](grouping-constructs-in-regular-expressions.md).</span></span>

|<span data-ttu-id="a24fc-281">語言項目</span><span class="sxs-lookup"><span data-stu-id="a24fc-281">Language element</span></span>|<span data-ttu-id="a24fc-282">描述</span><span class="sxs-lookup"><span data-stu-id="a24fc-282">Description</span></span>|
|----------------------|-----------------|
|<span data-ttu-id="a24fc-283">`(?=` `subexpression` `)`</span><span class="sxs-lookup"><span data-stu-id="a24fc-283">`(?=` `subexpression` `)`</span></span>|<span data-ttu-id="a24fc-284">零寬度右合樣。</span><span class="sxs-lookup"><span data-stu-id="a24fc-284">Zero-width positive lookahead.</span></span> <span data-ttu-id="a24fc-285">從目前的位置向右合樣，判斷 `subexpression` 是否符合輸入字串。</span><span class="sxs-lookup"><span data-stu-id="a24fc-285">Look ahead of the current position to determine whether `subexpression` matches the input string.</span></span>|
|<span data-ttu-id="a24fc-286">`(?!` `subexpression` `)`</span><span class="sxs-lookup"><span data-stu-id="a24fc-286">`(?!` `subexpression` `)`</span></span>|<span data-ttu-id="a24fc-287">零寬度右不合樣。</span><span class="sxs-lookup"><span data-stu-id="a24fc-287">Zero-width negative lookahead.</span></span> <span data-ttu-id="a24fc-288">從目前的位置向右合樣，判斷 `subexpression` 是否不符合輸入字串。</span><span class="sxs-lookup"><span data-stu-id="a24fc-288">Look ahead of the current position to determine whether `subexpression` does not match the input string.</span></span>|
|<span data-ttu-id="a24fc-289">`(?<=` `subexpression` `)`</span><span class="sxs-lookup"><span data-stu-id="a24fc-289">`(?<=` `subexpression` `)`</span></span>|<span data-ttu-id="a24fc-290">零寬度左合樣。</span><span class="sxs-lookup"><span data-stu-id="a24fc-290">Zero-width positive lookbehind.</span></span> <span data-ttu-id="a24fc-291">從目前的位置向左合樣，判斷 `subexpression` 是否符合輸入字串。</span><span class="sxs-lookup"><span data-stu-id="a24fc-291">Look behind the current position to determine whether `subexpression` matches the input string.</span></span>|
|<span data-ttu-id="a24fc-292">`(?<!` `subexpression` `)`</span><span class="sxs-lookup"><span data-stu-id="a24fc-292">`(?<!` `subexpression` `)`</span></span>|<span data-ttu-id="a24fc-293">零寬度左不合樣。</span><span class="sxs-lookup"><span data-stu-id="a24fc-293">Zero-width negative lookbehind.</span></span> <span data-ttu-id="a24fc-294">從目前的位置向左合樣，判斷 `subexpression` 是否不符合輸入字串。</span><span class="sxs-lookup"><span data-stu-id="a24fc-294">Look behind the current position to determine whether `subexpression` does not match the input string.</span></span>|

## <a name="use-time-out-values"></a><span data-ttu-id="a24fc-295">使用逾時值</span><span class="sxs-lookup"><span data-stu-id="a24fc-295">Use time-out values</span></span>

<span data-ttu-id="a24fc-296">如果您的規則運算式會處理幾乎符合規則運算式模式的輸入，它經常會依賴大量回溯，如此就會大幅影響其效能。</span><span class="sxs-lookup"><span data-stu-id="a24fc-296">If your regular expressions processes input that nearly matches the regular expression pattern, it can often rely on excessive backtracking, which impacts its performance significantly.</span></span> <span data-ttu-id="a24fc-297">除了仔細考量使用回溯以及對幾乎符合的輸入進行規則運算式測試之外，務必要設定逾時值，以確保將大量回溯 (如發生的話) 的影響降至最低。</span><span class="sxs-lookup"><span data-stu-id="a24fc-297">In addition to carefully considering your use of backtracking and testing the regular expression against near-matching input, you should always set a time-out value to ensure that the impact of excessive backtracking, if it occurs, is minimized.</span></span>

<span data-ttu-id="a24fc-298">正則運算式逾時間隔會定義正則運算式引擎在超時前尋找單一比對的時間長度。預設的逾時間隔是 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> ，這表示正則運算式不會超時。您可以覆寫此值並定義逾時間隔，如下所示：</span><span class="sxs-lookup"><span data-stu-id="a24fc-298">The regular expression time-out interval defines the period of time that the regular expression engine will look for a single match before it times out. The default time-out interval is <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, which means that the regular expression will not time out. You can override this value and define a time-out interval as follows:</span></span>

- <span data-ttu-id="a24fc-299">在您呼叫 <xref:System.Text.RegularExpressions.Regex> 建構函式具現化 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> 物件時提供逾時值。</span><span class="sxs-lookup"><span data-stu-id="a24fc-299">By providing a time-out value when you instantiate a <xref:System.Text.RegularExpressions.Regex> object by calling the <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> constructor.</span></span>

- <span data-ttu-id="a24fc-300">呼叫靜態模式比對方法，例如，包含 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> 參數的 <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> 或 `matchTimeout`。</span><span class="sxs-lookup"><span data-stu-id="a24fc-300">By calling a static pattern matching method, such as <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> or <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType>, that includes a `matchTimeout` parameter.</span></span>

- <span data-ttu-id="a24fc-301">若是藉由呼叫 <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A?displayProperty=nameWithType> 方法所建立之編譯的規則運算式，則可呼叫具有 <xref:System.TimeSpan> 類型參數的建構函式。</span><span class="sxs-lookup"><span data-stu-id="a24fc-301">For compiled regular expressions that are created by calling the <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A?displayProperty=nameWithType> method, by calling the constructor that has a parameter of type <xref:System.TimeSpan>.</span></span>

<span data-ttu-id="a24fc-302">如果您已定義逾時間隔，但是在該間隔結束時未找到相符項目，則規則運算式方法會擲回 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 例外狀況。</span><span class="sxs-lookup"><span data-stu-id="a24fc-302">If you have defined a time-out interval and a match is not found at the end of that interval, the regular expression method throws a <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception.</span></span> <span data-ttu-id="a24fc-303">在例外處理常式中，您可以選擇以較長的逾時間隔重試比對、放棄比對嘗試並假設沒有相符項目，或是放棄比對嘗試並記錄例外狀況資訊供未來進行分析。</span><span class="sxs-lookup"><span data-stu-id="a24fc-303">In your exception handler, you can choose to retry the match with a longer time-out interval, abandon the match attempt and assume that there is no match, or abandon the match attempt and log the exception information for future analysis.</span></span>

<span data-ttu-id="a24fc-304">下列範例將定義 `GetWordData` 方法，該方法會具現化逾時間隔為 350 毫秒的規則運算式，以計算文字文件中的字數和一個字的平均字元數。</span><span class="sxs-lookup"><span data-stu-id="a24fc-304">The following example defines a `GetWordData` method that instantiates a regular expression with a time-out interval of 350 milliseconds to calculate the number of words and average number of characters in a word in a text document.</span></span> <span data-ttu-id="a24fc-305">如果比對作業逾時，則逾時間隔將增加 350 毫秒，並且重新具現化 <xref:System.Text.RegularExpressions.Regex> 物件。</span><span class="sxs-lookup"><span data-stu-id="a24fc-305">If the matching operation times out, the time-out interval is increased by 350 milliseconds and the <xref:System.Text.RegularExpressions.Regex> object is re-instantiated.</span></span> <span data-ttu-id="a24fc-306">如果新的逾時間隔超過 1 秒，則方法會重新擲回例外狀況至呼叫端。</span><span class="sxs-lookup"><span data-stu-id="a24fc-306">If the new time-out interval exceeds 1 second, the method re-throws the exception to the caller.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#12](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/timeout1.cs#12)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#12](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/timeout1.vb#12)]

## <a name="capture-only-when-necessary"></a><span data-ttu-id="a24fc-307">必要時擷取</span><span class="sxs-lookup"><span data-stu-id="a24fc-307">Capture only when necessary</span></span>

<span data-ttu-id="a24fc-308">.NET 中的規則運算式支援許多群組建構，可讓您將規則運算式模式與一或多個子運算式設為群組。</span><span class="sxs-lookup"><span data-stu-id="a24fc-308">Regular expressions in .NET support a number of grouping constructs, which let you group a regular expression pattern into one or more subexpressions.</span></span> <span data-ttu-id="a24fc-309">.Net 正則運算式語言中最常用的群組結構是 `(` *子運算式* `)` ，它會定義編號的捕捉群組和 `(?<` *名稱* `>` *子運算式* `)` ，以定義名為的「捕捉群組」。</span><span class="sxs-lookup"><span data-stu-id="a24fc-309">The most commonly used grouping constructs in .NET regular expression language are `(`*subexpression*`)`, which defines a numbered capturing group, and `(?<`*name*`>`*subexpression*`)`, which defines a named capturing group.</span></span> <span data-ttu-id="a24fc-310">群組建構是建立反向參考和定義套用數量詞之子運算式的要件。</span><span class="sxs-lookup"><span data-stu-id="a24fc-310">Grouping constructs are essential for creating backreferences and for defining a subexpression to which a quantifier is applied.</span></span>

<span data-ttu-id="a24fc-311">不過，使用這些語言項目也有其代價。</span><span class="sxs-lookup"><span data-stu-id="a24fc-311">However, the use of these language elements has a cost.</span></span> <span data-ttu-id="a24fc-312">這些語言項目會造成在 <xref:System.Text.RegularExpressions.GroupCollection> 屬性傳回的 <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> 物件中填入最近使用的未命名或具名擷取，而如果單一群組建構擷取了輸入字串中的多個子字串，則這些語言項目也會在特定擷取群組的 <xref:System.Text.RegularExpressions.CaptureCollection> 屬性傳回的 <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> 物件中填入多個 <xref:System.Text.RegularExpressions.Capture> 物件。</span><span class="sxs-lookup"><span data-stu-id="a24fc-312">They cause the <xref:System.Text.RegularExpressions.GroupCollection> object returned by the <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> property to be populated with the most recent unnamed or named captures, and if a single grouping construct has captured multiple substrings in the input string, they also populate the <xref:System.Text.RegularExpressions.CaptureCollection> object returned by the <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> property of a particular capturing group with multiple <xref:System.Text.RegularExpressions.Capture> objects.</span></span>

<span data-ttu-id="a24fc-313">通常在規則運算式中使用群組建構的目的在於能夠套用數量詞，而且後續不會使用這些子運算式擷取的群組。</span><span class="sxs-lookup"><span data-stu-id="a24fc-313">Often, grouping constructs are used in a regular expression only so that quantifiers can be applied to them, and the groups captured by these subexpressions are not subsequently used.</span></span> <span data-ttu-id="a24fc-314">例如，規則運算式 `\b(\w+[;,]?\s?)+[.?!]` 是設計用來擷取整個句子。</span><span class="sxs-lookup"><span data-stu-id="a24fc-314">For example, the regular expression `\b(\w+[;,]?\s?)+[.?!]` is designed to capture an entire sentence.</span></span> <span data-ttu-id="a24fc-315">下表描述這個規則運算式模式中的語言項目，及其對於 <xref:System.Text.RegularExpressions.Match> 物件的 <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> 和 <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> 集合造成的影響。</span><span class="sxs-lookup"><span data-stu-id="a24fc-315">The following table describes the language elements in this regular expression pattern and their effect on the <xref:System.Text.RegularExpressions.Match> object's <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> and <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> collections.</span></span>

|<span data-ttu-id="a24fc-316">模式</span><span class="sxs-lookup"><span data-stu-id="a24fc-316">Pattern</span></span>|<span data-ttu-id="a24fc-317">描述</span><span class="sxs-lookup"><span data-stu-id="a24fc-317">Description</span></span>|
|-------------|-----------------|
|`\b`|<span data-ttu-id="a24fc-318">開始字緣比對。</span><span class="sxs-lookup"><span data-stu-id="a24fc-318">Begin the match at a word boundary.</span></span>|
|`\w+`|<span data-ttu-id="a24fc-319">比對一個或多個文字字元。</span><span class="sxs-lookup"><span data-stu-id="a24fc-319">Match one or more word characters.</span></span>|
|`[;,]?`|<span data-ttu-id="a24fc-320">比對零個或一個逗號或分號。</span><span class="sxs-lookup"><span data-stu-id="a24fc-320">Match zero or one comma or semicolon.</span></span>|
|`\s?`|<span data-ttu-id="a24fc-321">比對零個或一個空白字元。</span><span class="sxs-lookup"><span data-stu-id="a24fc-321">Match zero or one white-space character.</span></span>|
|`(\w+[;,]?\s?)+`|<span data-ttu-id="a24fc-322">比對出現一次或多次的一個或多個文字字元，後面接著選擇性的逗號或分號，再後面接著選擇性的空白字元。</span><span class="sxs-lookup"><span data-stu-id="a24fc-322">Match one or more occurrences of one or more word characters followed by an optional comma or semicolon followed by an optional white-space character.</span></span> <span data-ttu-id="a24fc-323">這會定義必要的第一個擷取群組，如此多個文字字元 (也就是文字) 後面接著選擇性標點符號的組合才會重複，直到規則運算式引擎到達句尾為止。</span><span class="sxs-lookup"><span data-stu-id="a24fc-323">This defines the first capturing group, which is necessary so that the combination of multiple word characters (that is, a word) followed by an optional punctuation symbol will be repeated until the regular expression engine reaches the end of a sentence.</span></span>|
|`[.?!]`|<span data-ttu-id="a24fc-324">比對句號、問號或驚嘆號。</span><span class="sxs-lookup"><span data-stu-id="a24fc-324">Match a period, question mark, or exclamation point.</span></span>|

<span data-ttu-id="a24fc-325">如下列範例所示，找到符合的結果時，<xref:System.Text.RegularExpressions.GroupCollection> 和 <xref:System.Text.RegularExpressions.CaptureCollection> 物件中都會填入比對所擷取的項目。</span><span class="sxs-lookup"><span data-stu-id="a24fc-325">As the following example shows, when a match is found, both the <xref:System.Text.RegularExpressions.GroupCollection> and <xref:System.Text.RegularExpressions.CaptureCollection> objects are populated with captures from the match.</span></span> <span data-ttu-id="a24fc-326">在此案例中，擷取群組 `(\w+[;,]?\s?)` 會存在，如此 `+` 數量詞就能套用至其中，這樣就能讓規則運算式模式比對句子中的每個字。</span><span class="sxs-lookup"><span data-stu-id="a24fc-326">In this case, the capturing group `(\w+[;,]?\s?)` exists so that the `+` quantifier can be applied to it, which enables the regular expression pattern to match each word in a sentence.</span></span> <span data-ttu-id="a24fc-327">否則就會比對句子中的最後一個字。</span><span class="sxs-lookup"><span data-stu-id="a24fc-327">Otherwise, it would match the last word in a sentence.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#8](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/group1.cs#8)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/group1.vb#8)]

<span data-ttu-id="a24fc-328">如果您使用子運算式的目的只是要在其中套用數量詞，對於擷取的文字並不感興趣，則應該停用群組擷取。</span><span class="sxs-lookup"><span data-stu-id="a24fc-328">When you use subexpressions only to apply quantifiers to them, and you are not interested in the captured text, you should disable group captures.</span></span> <span data-ttu-id="a24fc-329">例如，`(?:subexpression)` 語言元素會阻止套用該語言元素的群組擷取相符的子字串。</span><span class="sxs-lookup"><span data-stu-id="a24fc-329">For example, the `(?:subexpression)` language element prevents the group to which it applies from capturing matched substrings.</span></span> <span data-ttu-id="a24fc-330">在下列範例中，前一個範例的規則運算式模式會變成 `\b(?:\w+[;,]?\s?)+[.?!]`。</span><span class="sxs-lookup"><span data-stu-id="a24fc-330">In the following example, the regular expression pattern from the previous example is changed to `\b(?:\w+[;,]?\s?)+[.?!]`.</span></span> <span data-ttu-id="a24fc-331">如輸出所示，它會阻止規則運算式引擎填入 <xref:System.Text.RegularExpressions.GroupCollection> 和 <xref:System.Text.RegularExpressions.CaptureCollection> 集合。</span><span class="sxs-lookup"><span data-stu-id="a24fc-331">As the output shows, it prevents the regular expression engine from populating the <xref:System.Text.RegularExpressions.GroupCollection> and <xref:System.Text.RegularExpressions.CaptureCollection> collections.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#9](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/group2.cs#9)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#9](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/group2.vb#9)]

<span data-ttu-id="a24fc-332">您可以透過下列其中一種方式停用擷取：</span><span class="sxs-lookup"><span data-stu-id="a24fc-332">You can disable captures in one of the following ways:</span></span>

- <span data-ttu-id="a24fc-333">使用 `(?:subexpression)` 語言元素。</span><span class="sxs-lookup"><span data-stu-id="a24fc-333">Use the `(?:subexpression)` language element.</span></span> <span data-ttu-id="a24fc-334">這個項目會阻止在套用該項目的群組中擷取相符的子字串。</span><span class="sxs-lookup"><span data-stu-id="a24fc-334">This element prevents the capture of matched substrings in the group to which it applies.</span></span> <span data-ttu-id="a24fc-335">不過，它不會停用任何巢狀群組中的子字串擷取。</span><span class="sxs-lookup"><span data-stu-id="a24fc-335">It does not disable substring captures in any nested groups.</span></span>

- <span data-ttu-id="a24fc-336">使用 <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture> 選項。</span><span class="sxs-lookup"><span data-stu-id="a24fc-336">Use the <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture> option.</span></span> <span data-ttu-id="a24fc-337">這個選項會停用規則運算式模式中的所有未命名或隱含擷取。</span><span class="sxs-lookup"><span data-stu-id="a24fc-337">It disables all unnamed or implicit captures in the regular expression pattern.</span></span> <span data-ttu-id="a24fc-338">當您使用這個選項時，只會擷取符合 `(?<name>subexpression)` 語言元素所定義之具名群組的子字串。</span><span class="sxs-lookup"><span data-stu-id="a24fc-338">When you use this option, only substrings that match named groups defined with the `(?<name>subexpression)` language element can be captured.</span></span> <span data-ttu-id="a24fc-339"><xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture> 旗標可以傳遞至 `options` 類別建構函式的 <xref:System.Text.RegularExpressions.Regex> 參數，或是 `options` 靜態比對方法的 <xref:System.Text.RegularExpressions.Regex> 參數。</span><span class="sxs-lookup"><span data-stu-id="a24fc-339">The <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture> flag can be passed to the `options` parameter of a <xref:System.Text.RegularExpressions.Regex> class constructor or to the `options` parameter of a <xref:System.Text.RegularExpressions.Regex> static matching method.</span></span>

- <span data-ttu-id="a24fc-340">在 `n` 語言項目中使用 `(?imnsx)` 選項。</span><span class="sxs-lookup"><span data-stu-id="a24fc-340">Use the `n` option in the `(?imnsx)` language element.</span></span> <span data-ttu-id="a24fc-341">這個選項會從規則運算式模式中出現該項目的位置開始，停用所有未命名或隱含擷取。</span><span class="sxs-lookup"><span data-stu-id="a24fc-341">This option disables all unnamed or implicit captures from the point in the regular expression pattern at which the element appears.</span></span> <span data-ttu-id="a24fc-342">在到達模式結尾或 `(-n)` 選項啟用未命名或隱含擷取之前，擷取都會是停用狀態。</span><span class="sxs-lookup"><span data-stu-id="a24fc-342">Captures are disabled either until the end of the pattern or until the `(-n)` option enables unnamed or implicit captures.</span></span> <span data-ttu-id="a24fc-343">如需詳細資訊，請參閱[其他建構](miscellaneous-constructs-in-regular-expressions.md)。</span><span class="sxs-lookup"><span data-stu-id="a24fc-343">For more information, see [Miscellaneous Constructs](miscellaneous-constructs-in-regular-expressions.md).</span></span>

- <span data-ttu-id="a24fc-344">在 `n` 語言項目中使用 `(?imnsx:subexpression)` 選項。</span><span class="sxs-lookup"><span data-stu-id="a24fc-344">Use the `n` option in the `(?imnsx:subexpression)` language element.</span></span> <span data-ttu-id="a24fc-345">這個選項會停用 `subexpression` 中的所有未命名或隱含擷取。</span><span class="sxs-lookup"><span data-stu-id="a24fc-345">This option disables all unnamed or implicit captures in `subexpression`.</span></span> <span data-ttu-id="a24fc-346">任何未命名或隱含巢狀擷取群組所進行的擷取也都會停用。</span><span class="sxs-lookup"><span data-stu-id="a24fc-346">Captures by any unnamed or implicit nested capturing groups are disabled as well.</span></span>

## <a name="related-topics"></a><span data-ttu-id="a24fc-347">相關主題</span><span class="sxs-lookup"><span data-stu-id="a24fc-347">Related topics</span></span>

|<span data-ttu-id="a24fc-348">Title</span><span class="sxs-lookup"><span data-stu-id="a24fc-348">Title</span></span>|<span data-ttu-id="a24fc-349">描述</span><span class="sxs-lookup"><span data-stu-id="a24fc-349">Description</span></span>|
|-----------|-----------------|
|[<span data-ttu-id="a24fc-350">規則運算式行為的詳細資訊</span><span class="sxs-lookup"><span data-stu-id="a24fc-350">Details of Regular Expression Behavior</span></span>](details-of-regular-expression-behavior.md)|<span data-ttu-id="a24fc-351">檢查 .NET 中規則運算式引擎的實作。</span><span class="sxs-lookup"><span data-stu-id="a24fc-351">Examines the implementation of the regular expression engine in .NET.</span></span> <span data-ttu-id="a24fc-352">本主題將強調規則運算式的靈活度，並且說明開發人員應負責確保規則運算式引擎有效率且穩定地運作。</span><span class="sxs-lookup"><span data-stu-id="a24fc-352">The topic focuses on the flexibility of regular expressions and explains the developer's responsibility for ensuring the efficient and robust operation of the regular expression engine.</span></span>|
|[<span data-ttu-id="a24fc-353">回溯</span><span class="sxs-lookup"><span data-stu-id="a24fc-353">Backtracking</span></span>](backtracking-in-regular-expressions.md)|<span data-ttu-id="a24fc-354">說明何謂回溯以及回溯如何影響規則運算式的效能，並且檢查提供回溯之替代方式的語言項目。</span><span class="sxs-lookup"><span data-stu-id="a24fc-354">Explains what backtracking is and how it affects regular expression performance, and examines language elements that provide alternatives to backtracking.</span></span>|
|[<span data-ttu-id="a24fc-355">規則運算式語言 - 快速參考</span><span class="sxs-lookup"><span data-stu-id="a24fc-355">Regular Expression Language - Quick Reference</span></span>](regular-expression-language-quick-reference.md)|<span data-ttu-id="a24fc-356">描述 .NET 中規則運算式語言的項目，並且提供每個語言項目之詳細文件的連結。</span><span class="sxs-lookup"><span data-stu-id="a24fc-356">Describes the elements of the regular expression language in .NET and provides links to detailed documentation for each language element.</span></span>|
