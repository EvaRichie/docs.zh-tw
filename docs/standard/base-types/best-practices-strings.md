---
title: 在 .NET 中比較字串的最佳作法
description: 瞭解如何在 .NET 應用程式中有效地比較字串。
ms.date: 05/01/2019
dev_langs:
- csharp
- vb
helpviewer_keywords:
- strings [.NET],searching
- best practices,string comparison and sorting
- strings [.NET],best practices
- strings [.NET],basic string operations
- sorting strings
- strings [.NET],sorting
- string comparison [.NET],best practices
- string sorting
- comparing strings
- strings [.NET],comparing
ms.assetid: b9f0bf53-e2de-4116-8ce9-d4f91a1df4f7
ms.openlocfilehash: 840e5b0e6a523ac8e3f24586d4980958cd58f613
ms.sourcegitcommit: 7ef96827b161ef3fcde75f79d839885632e26ef1
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/07/2021
ms.locfileid: "97970885"
---
# <a name="best-practices-for-comparing-strings-in-net"></a><span data-ttu-id="63d79-103">在 .NET 中比較字串的最佳作法</span><span class="sxs-lookup"><span data-stu-id="63d79-103">Best practices for comparing strings in .NET</span></span>

<span data-ttu-id="63d79-104">.NET 可廣泛支援當地語系化和全球化應用程式的開發作業，使您在執行一般作業 (例如排序和顯示字串) 時，可輕鬆套用目前的文化特性或特定文化特性的慣例。</span><span class="sxs-lookup"><span data-stu-id="63d79-104">.NET provides extensive support for developing localized and globalized applications, and makes it easy to apply the conventions of either the current culture or a specific culture when performing common operations such as sorting and displaying strings.</span></span> <span data-ttu-id="63d79-105">但是，排序或比較字串並不一定是區分文化特性的作業。</span><span class="sxs-lookup"><span data-stu-id="63d79-105">But sorting or comparing strings is not always a culture-sensitive operation.</span></span> <span data-ttu-id="63d79-106">例如，應用程式內部使用的字串，通常應該跨所有文化特性皆進行相同處理。</span><span class="sxs-lookup"><span data-stu-id="63d79-106">For example, strings that are used internally by an application typically should be handled identically across all cultures.</span></span> <span data-ttu-id="63d79-107">若將與文化特性無關的字串資料 (例如 XML 標記、HTML 標記、使用者名稱、檔案路徑和系統物件的名稱) 進行區分文化特性的解譯時，應用程式程式碼可能會出現細微的 Bug、效能不佳，甚至在某些情況下，會產生安全性問題。</span><span class="sxs-lookup"><span data-stu-id="63d79-107">When culturally independent string data, such as XML tags, HTML tags, user names, file paths, and the names of system objects, are interpreted as if they were culture-sensitive, application code can be subject to subtle bugs, poor performance, and, in some cases, security issues.</span></span>

<span data-ttu-id="63d79-108">本文會詳述 .NET 中的字串排序、比較和大小寫方法，並提供適當字串處理方法的選擇建議，以及字串處理方法的其他資訊。</span><span class="sxs-lookup"><span data-stu-id="63d79-108">This article examines the string sorting, comparison, and casing methods in .NET, presents recommendations for selecting an appropriate string-handling method, and provides additional information about string-handling methods.</span></span>

## <a name="recommendations-for-string-usage"></a><span data-ttu-id="63d79-109">字串的使用建議</span><span class="sxs-lookup"><span data-stu-id="63d79-109">Recommendations for string usage</span></span>

<span data-ttu-id="63d79-110">當您使用 .NET 進行開發時，當您比較字串時，請遵循下列簡單的建議：</span><span class="sxs-lookup"><span data-stu-id="63d79-110">When you develop with .NET, follow these simple recommendations when you compare strings:</span></span>

- <span data-ttu-id="63d79-111">使用明確指定字串比較規則的多載來進行字串作業。</span><span class="sxs-lookup"><span data-stu-id="63d79-111">Use overloads that explicitly specify the string comparison rules for string operations.</span></span> <span data-ttu-id="63d79-112">一般而言，這需要呼叫具有 <xref:System.StringComparison>類別參數的方法多載。</span><span class="sxs-lookup"><span data-stu-id="63d79-112">Typically, this involves calling a method overload that has a parameter of type <xref:System.StringComparison>.</span></span>
- <span data-ttu-id="63d79-113">將 <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> 或 <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> 做為安全的無從驗證文化特性字串預設比對，來進行比較。</span><span class="sxs-lookup"><span data-stu-id="63d79-113">Use <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> or <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> for comparisons as your safe default for culture-agnostic string matching.</span></span>
- <span data-ttu-id="63d79-114">使用 <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> 或 <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> 來比較以提升效能。</span><span class="sxs-lookup"><span data-stu-id="63d79-114">Use comparisons with <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> or <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> for better performance.</span></span>
- <span data-ttu-id="63d79-115">向使用者顯示輸出時，您可以使用依據 <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType> 的字串作業。</span><span class="sxs-lookup"><span data-stu-id="63d79-115">Use string operations that are based on <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType> when you display output to the user.</span></span>
- <span data-ttu-id="63d79-116">在進行語言無關的比較 (如符號) 時，使用非語言式 <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> 或 <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> 值，而不是依據 <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> 的字串作業。</span><span class="sxs-lookup"><span data-stu-id="63d79-116">Use the non-linguistic <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> or <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> values instead of string operations based on <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> when the comparison is linguistically irrelevant (symbolic, for example).</span></span>
- <span data-ttu-id="63d79-117">正規化字串以進行比較，使用 <xref:System.String.ToUpperInvariant%2A?displayProperty=nameWithType> 方法，而非 <xref:System.String.ToLowerInvariant%2A?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="63d79-117">Use the <xref:System.String.ToUpperInvariant%2A?displayProperty=nameWithType> method instead of the <xref:System.String.ToLowerInvariant%2A?displayProperty=nameWithType> method when you normalize strings for comparison.</span></span>
- <span data-ttu-id="63d79-118">使用 <xref:System.String.Equals%2A?displayProperty=nameWithType> 方法的多載，來測試兩個字串是否相等。</span><span class="sxs-lookup"><span data-stu-id="63d79-118">Use an overload of the <xref:System.String.Equals%2A?displayProperty=nameWithType> method to test whether two strings are equal.</span></span>
- <span data-ttu-id="63d79-119">使用 <xref:System.String.Compare%2A?displayProperty=nameWithType> 和 <xref:System.String.CompareTo%2A?displayProperty=nameWithType> 方法來排序字串，而不檢查是否相等。</span><span class="sxs-lookup"><span data-stu-id="63d79-119">Use the <xref:System.String.Compare%2A?displayProperty=nameWithType> and <xref:System.String.CompareTo%2A?displayProperty=nameWithType> methods to sort strings, not to check for equality.</span></span>
- <span data-ttu-id="63d79-120">使用區分文化特性的格式來顯示使用者介面中的非字串資料，例如數字和日期。</span><span class="sxs-lookup"><span data-stu-id="63d79-120">Use culture-sensitive formatting to display non-string data, such as numbers and dates, in a user interface.</span></span> <span data-ttu-id="63d79-121">使用不因 [文化](xref:System.Globalization.CultureInfo.InvariantCulture) 特性而異的格式，以字串形式保存非字串資料。</span><span class="sxs-lookup"><span data-stu-id="63d79-121">Use formatting with the [invariant culture](xref:System.Globalization.CultureInfo.InvariantCulture) to persist non-string data in string form.</span></span>

<span data-ttu-id="63d79-122">當您比較字串時，請避免下列作法：</span><span class="sxs-lookup"><span data-stu-id="63d79-122">Avoid the following practices when you compare strings:</span></span>

- <span data-ttu-id="63d79-123">不要使用未明確或未隱含指定字串比較規則的多載來進行字串作業。</span><span class="sxs-lookup"><span data-stu-id="63d79-123">Do not use overloads that do not explicitly or implicitly specify the string comparison rules for string operations.</span></span>
- <span data-ttu-id="63d79-124">在大部分情況下，請不要使用依據 <xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType> 的字串作業。</span><span class="sxs-lookup"><span data-stu-id="63d79-124">Do not use string operations based on <xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType> in most cases.</span></span> <span data-ttu-id="63d79-125">若您要保存具語言意義但無從驗證文化特性的資料，就是少數的例外狀況之一。</span><span class="sxs-lookup"><span data-stu-id="63d79-125">One of the few exceptions is when you are persisting linguistically meaningful but culturally agnostic data.</span></span>
- <span data-ttu-id="63d79-126">不要使用 <xref:System.String.Compare%2A?displayProperty=nameWithType> 或 <xref:System.String.CompareTo%2A> 方法的多載以及傳回零值的測試，來判斷兩個字串是否相等。</span><span class="sxs-lookup"><span data-stu-id="63d79-126">Do not use an overload of the <xref:System.String.Compare%2A?displayProperty=nameWithType> or <xref:System.String.CompareTo%2A> method and test for a return value of zero to determine whether two strings are equal.</span></span>

## <a name="specifying-string-comparisons-explicitly"></a><span data-ttu-id="63d79-127">明確指定字串比較</span><span class="sxs-lookup"><span data-stu-id="63d79-127">Specifying string comparisons explicitly</span></span>

<span data-ttu-id="63d79-128">在 .NET 中的字串操作方法大多都是多載。</span><span class="sxs-lookup"><span data-stu-id="63d79-128">Most of the string manipulation methods in .NET are overloaded.</span></span> <span data-ttu-id="63d79-129">一般而言，您可讓一或多個多載接受預設值，而其他不接受預設值的多載，則定義用來比較或操作字串的精確方式。</span><span class="sxs-lookup"><span data-stu-id="63d79-129">Typically, one or more overloads accept default settings, whereas others accept no defaults and instead define the precise way in which strings are to be compared or manipulated.</span></span> <span data-ttu-id="63d79-130">大部分不依賴預設值的方法都會包含 <xref:System.StringComparison>類型的參數，其為一種列舉類型，可明確指定依據文化特性和大小寫進行字串比較的規則。</span><span class="sxs-lookup"><span data-stu-id="63d79-130">Most of the methods that do not rely on defaults include a parameter of type <xref:System.StringComparison>, which is an enumeration that explicitly specifies rules for string comparison by culture and case.</span></span> <span data-ttu-id="63d79-131">下表說明 <xref:System.StringComparison> 列舉類型成員。</span><span class="sxs-lookup"><span data-stu-id="63d79-131">The following table describes the <xref:System.StringComparison> enumeration members.</span></span>

|<span data-ttu-id="63d79-132">StringComparison 成員</span><span class="sxs-lookup"><span data-stu-id="63d79-132">StringComparison member</span></span>|<span data-ttu-id="63d79-133">描述</span><span class="sxs-lookup"><span data-stu-id="63d79-133">Description</span></span>|
|-----------------------------|-----------------|
|<xref:System.StringComparison.CurrentCulture>|<span data-ttu-id="63d79-134">使用目前文化特性執行區分大小寫的比較。</span><span class="sxs-lookup"><span data-stu-id="63d79-134">Performs a case-sensitive comparison using the current culture.</span></span>|
|<xref:System.StringComparison.CurrentCultureIgnoreCase>|<span data-ttu-id="63d79-135">使用目前文化特性執行不區分大小寫的比較。</span><span class="sxs-lookup"><span data-stu-id="63d79-135">Performs a case-insensitive comparison using the current culture.</span></span>|
|<xref:System.StringComparison.InvariantCulture>|<span data-ttu-id="63d79-136">使用不因國別而異的文化特性執行區分大小寫的比較。</span><span class="sxs-lookup"><span data-stu-id="63d79-136">Performs a case-sensitive comparison using the invariant culture.</span></span>|
|<xref:System.StringComparison.InvariantCultureIgnoreCase>|<span data-ttu-id="63d79-137">使用不因國別而異的文化特性執行不區分大小寫的比較。</span><span class="sxs-lookup"><span data-stu-id="63d79-137">Performs a case-insensitive comparison using the invariant culture.</span></span>|
|<xref:System.StringComparison.Ordinal>|<span data-ttu-id="63d79-138">執行序數比較。</span><span class="sxs-lookup"><span data-stu-id="63d79-138">Performs an ordinal comparison.</span></span>|
|<xref:System.StringComparison.OrdinalIgnoreCase>|<span data-ttu-id="63d79-139">執行不區分大小寫的序數比較。</span><span class="sxs-lookup"><span data-stu-id="63d79-139">Performs a case-insensitive ordinal comparison.</span></span>|

<span data-ttu-id="63d79-140">例如， <xref:System.String.IndexOf%2A> 方法有下列九個多載，可傳回 <xref:System.String> 物件中符合某字元或某字串之子字串的索引：</span><span class="sxs-lookup"><span data-stu-id="63d79-140">For example, the <xref:System.String.IndexOf%2A> method, which returns the index of a substring in a <xref:System.String> object that matches either a character or a string, has nine overloads:</span></span>

- <span data-ttu-id="63d79-141"><xref:System.String.IndexOf%28System.Char%29>、 <xref:System.String.IndexOf%28System.Char%2CSystem.Int32%29>和 <xref:System.String.IndexOf%28System.Char%2CSystem.Int32%2CSystem.Int32%29>會預設執行字串字元的序數 (區分大小寫且區分文化特性) 搜尋。</span><span class="sxs-lookup"><span data-stu-id="63d79-141"><xref:System.String.IndexOf%28System.Char%29>, <xref:System.String.IndexOf%28System.Char%2CSystem.Int32%29>, and <xref:System.String.IndexOf%28System.Char%2CSystem.Int32%2CSystem.Int32%29>, which by default perform an ordinal (case-sensitive and culture-insensitive) search for a character in the string.</span></span>
- <span data-ttu-id="63d79-142"><xref:System.String.IndexOf%28System.String%29>、 <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29>和 <xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29>會預設執行字串的子字元搜尋 (區分大小寫且區分文化特性)。</span><span class="sxs-lookup"><span data-stu-id="63d79-142"><xref:System.String.IndexOf%28System.String%29>, <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29>, and <xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29>, which by default perform a case-sensitive and culture-sensitive search for a substring in the string.</span></span>
- <span data-ttu-id="63d79-143"><xref:System.String.IndexOf%28System.String%2CSystem.StringComparison%29>、 <xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.StringComparison%29>和 <xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29>包括 <xref:System.StringComparison> 類型的參數，可指定比較形式。</span><span class="sxs-lookup"><span data-stu-id="63d79-143"><xref:System.String.IndexOf%28System.String%2CSystem.StringComparison%29>, <xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.StringComparison%29>, and <xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29>, which include a parameter of type <xref:System.StringComparison> that allows the form of the comparison to be specified.</span></span>

<span data-ttu-id="63d79-144">基於下列原因，建議您選取不使用預設值的多載：</span><span class="sxs-lookup"><span data-stu-id="63d79-144">We recommend that you select an overload that does not use default values, for the following reasons:</span></span>

- <span data-ttu-id="63d79-145">有些使用預設參數的多載 (其會在字串執行個體中搜尋 <xref:System.Char> ) 會執行序數比較，而其他多載 (其會搜尋字串執行個體中的字串) 有區分文化特性。</span><span class="sxs-lookup"><span data-stu-id="63d79-145">Some overloads with default parameters (those that search for a <xref:System.Char> in the string instance) perform an ordinal comparison, whereas others (those that search for a string in the string instance) are culture-sensitive.</span></span> <span data-ttu-id="63d79-146">使用者很難記住哪一種方法使用預設值，也很容易混淆多載。</span><span class="sxs-lookup"><span data-stu-id="63d79-146">It is difficult to remember which method uses which default value, and easy to confuse the overloads.</span></span>
- <span data-ttu-id="63d79-147">依賴預設值來執行方法呼叫的程式碼意圖並不清楚。</span><span class="sxs-lookup"><span data-stu-id="63d79-147">The intent of the code that relies on default values for method calls is not clear.</span></span> <span data-ttu-id="63d79-148">在下列使用預設值的範例中，我們難以知道開發人員要進行兩個字串的序數或語言比較，也很難判斷 `protocol` 和 "http" 之間的大小寫差異是否會造成相等測試傳回 `false`類別參數的方法多載。</span><span class="sxs-lookup"><span data-stu-id="63d79-148">In the following example, which relies on defaults, it is difficult to know whether the developer actually intended an ordinal or a linguistic comparison of two strings, or whether a case difference between `protocol` and "http" might cause the test for equality to return `false`.</span></span>

     [!code-csharp[Conceptual.Strings.BestPractices#1](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.bestpractices/cs/explicitargs1.cs#1)]
     [!code-vb[Conceptual.Strings.BestPractices#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.bestpractices/vb/explicitargs1.vb#1)]

<span data-ttu-id="63d79-149">一般而言，我們建議您呼叫不依賴預設值的方法，因為它會讓程式碼的意圖模稜兩可。</span><span class="sxs-lookup"><span data-stu-id="63d79-149">In general, we recommend that you call a method that does not rely on defaults, because it makes the intent of the code unambiguous.</span></span> <span data-ttu-id="63d79-150">不過，這可讓程式碼更容易閱讀也更容易偵錯與維護。</span><span class="sxs-lookup"><span data-stu-id="63d79-150">This, in turn, makes the code more readable and easier to debug and maintain.</span></span> <span data-ttu-id="63d79-151">下列範例將解決先前範例所引發的問題。</span><span class="sxs-lookup"><span data-stu-id="63d79-151">The following example addresses the questions raised about the previous example.</span></span> <span data-ttu-id="63d79-152">它會清楚指出使用序數比較，並且忽略大小寫差異。</span><span class="sxs-lookup"><span data-stu-id="63d79-152">It makes it clear that ordinal comparison is used and that differences in case are ignored.</span></span>

[!code-csharp[Conceptual.Strings.BestPractices#2](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.bestpractices/cs/explicitargs1.cs#2)]
[!code-vb[Conceptual.Strings.BestPractices#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.bestpractices/vb/explicitargs1.vb#2)]

## <a name="the-details-of-string-comparison"></a><span data-ttu-id="63d79-153">字串比較的詳細資料</span><span class="sxs-lookup"><span data-stu-id="63d79-153">The details of string comparison</span></span>

<span data-ttu-id="63d79-154">字串比較是許多字串相關作業的核心，尤其是排序和測試是否相等這類作業。</span><span class="sxs-lookup"><span data-stu-id="63d79-154">String comparison is the heart of many string-related operations, particularly sorting and testing for equality.</span></span> <span data-ttu-id="63d79-155">字串依固定順序排序：在已排序的字串清單中，如果 "my" 在 "string" 之前出現，則 "my" 比較起來一定小於或等於 "string"。</span><span class="sxs-lookup"><span data-stu-id="63d79-155">Strings sort in a determined order: If "my" appears before "string" in a sorted list of strings, "my" must compare less than or equal to "string".</span></span> <span data-ttu-id="63d79-156">此外，比較也隱含定義相等性。</span><span class="sxs-lookup"><span data-stu-id="63d79-156">Additionally, comparison implicitly defines equality.</span></span> <span data-ttu-id="63d79-157">比較作業會針對它認為相等的字串傳回零。</span><span class="sxs-lookup"><span data-stu-id="63d79-157">The comparison operation returns zero for strings it deems equal.</span></span> <span data-ttu-id="63d79-158">明言之，就是沒有任一字串比另一個字串更小。</span><span class="sxs-lookup"><span data-stu-id="63d79-158">A good interpretation is that neither string is less than the other.</span></span> <span data-ttu-id="63d79-159">最有意義的字串作業包含下列一或兩個程序：和其他字串進行比較，並執行定義完善的排序作業。</span><span class="sxs-lookup"><span data-stu-id="63d79-159">Most meaningful operations involving strings include one or both of these procedures: comparing with another string, and executing a well-defined sort operation.</span></span>

> [!NOTE]
> <span data-ttu-id="63d79-160">您可以下載[排序權數資料表](https://www.microsoft.com/download/details.aspx?id=10921)，該文字檔集合包含在 Windows 作業系統排序及比較作業中使用的字元權數資訊，以及下載[預設 Unicode 定序元素資料表](https://www.unicode.org/Public/UCA/latest/allkeys.txt) (適用於 Linux 和 macOS 的最新版本排序權數資料表)。</span><span class="sxs-lookup"><span data-stu-id="63d79-160">You can download the [Sorting Weight Tables](https://www.microsoft.com/download/details.aspx?id=10921), a set of text files that contain information on the character weights used in sorting and comparison operations for Windows operating systems, and the [Default Unicode Collation Element Table](https://www.unicode.org/Public/UCA/latest/allkeys.txt), the latest version of the sort weight table for Linux and macOS.</span></span> <span data-ttu-id="63d79-161">Linux 和 macOS 上的特定版本排序權數資料表，取決於在系統上安裝的 [International Components for Unicode](http://site.icu-project.org/) 程式庫。</span><span class="sxs-lookup"><span data-stu-id="63d79-161">The specific version of the sort weight table on Linux and macOS depends on the version of the [International Components for Unicode](http://site.icu-project.org/) libraries installed on the system.</span></span> <span data-ttu-id="63d79-162">如需其實作的 ICU 版本及 Unicode 版本詳細資訊，請參閱[下載 ICU](http://site.icu-project.org/download)。</span><span class="sxs-lookup"><span data-stu-id="63d79-162">For information on ICU versions and the Unicode versions that they implement, see [Downloading ICU](http://site.icu-project.org/download).</span></span>

<span data-ttu-id="63d79-163">不過，評估兩個字串是否相等或決定排序順序不會產生單一的正確結果，而要取決於用來比較字串的準則而定。</span><span class="sxs-lookup"><span data-stu-id="63d79-163">However, evaluating two strings for equality or sort order does not yield a single, correct result; the outcome depends on the criteria used to compare the strings.</span></span> <span data-ttu-id="63d79-164">尤其是，如果字串比較是序數或根據目前文化特性的大小寫與排序慣例或不因 [文化](xref:System.Globalization.CultureInfo.InvariantCulture) 特性而異，則 (以英文語言為基礎的地區設定文化特性，) 可能會產生不同的結果。</span><span class="sxs-lookup"><span data-stu-id="63d79-164">In particular, string comparisons that are ordinal or that are based on the casing and sorting conventions of the current culture or the [invariant culture](xref:System.Globalization.CultureInfo.InvariantCulture) (a locale-agnostic culture based on the English language) may produce different results.</span></span>

<span data-ttu-id="63d79-165">此外，使用不同版本 .NET 或使用不同作業系統或作業系統版本上 .NET 所做的字串比較，可能會傳回不同的結果。</span><span class="sxs-lookup"><span data-stu-id="63d79-165">In addition, string comparisons using different versions of .NET or using .NET on different operating systems or operating system versions may return different results.</span></span> <span data-ttu-id="63d79-166">如需詳細資訊，請參閱[字串及 Unicode 標準](xref:System.String#Unicode)。</span><span class="sxs-lookup"><span data-stu-id="63d79-166">For more information, see [Strings and the Unicode Standard](xref:System.String#Unicode).</span></span>

### <a name="string-comparisons-that-use-the-current-culture"></a><span data-ttu-id="63d79-167">使用目前之文化特性的字串比較</span><span class="sxs-lookup"><span data-stu-id="63d79-167">String comparisons that use the current culture</span></span>

<span data-ttu-id="63d79-168">比較字串時，其中一個準則需使用目前文化特性的慣例。</span><span class="sxs-lookup"><span data-stu-id="63d79-168">One criterion involves using the conventions of the current culture when comparing strings.</span></span> <span data-ttu-id="63d79-169">如果比較是以目前文化特性為依據，就會使用執行緒的目前文化特性或地區設定。</span><span class="sxs-lookup"><span data-stu-id="63d79-169">Comparisons that are based on the current culture use the thread's current culture or locale.</span></span> <span data-ttu-id="63d79-170">如果使用者未設定文化特性，則會預設為控制台 [地區選項]  視窗中的設定。</span><span class="sxs-lookup"><span data-stu-id="63d79-170">If the culture is not set by the user, it defaults to the setting in the **Regional Options** window in Control Panel.</span></span> <span data-ttu-id="63d79-171">當資料是語言相關資料，以及資料會反映區分文化特性的使用者互動時，請一律使用以目前文化特性為根據的比較。</span><span class="sxs-lookup"><span data-stu-id="63d79-171">You should always use comparisons that are based on the current culture when data is linguistically relevant, and when it reflects culture-sensitive user interaction.</span></span>

<span data-ttu-id="63d79-172">不過，當文化特性變更時，.NET 中的比較和大小寫行為也會有所變更。</span><span class="sxs-lookup"><span data-stu-id="63d79-172">However, comparison and casing behavior in .NET changes when the culture changes.</span></span> <span data-ttu-id="63d79-173">當執行應用程式的電腦其文化特性不同於開發應用程式的電腦時，或執行中的執行緒變更其文化特性時，會發生這種情況。</span><span class="sxs-lookup"><span data-stu-id="63d79-173">This happens when an application executes on a computer that has a different culture than the computer on which the application was developed, or when the executing thread changes its culture.</span></span> <span data-ttu-id="63d79-174">此種行為有其用意，但對許多開發人員來說並不容易注意到。</span><span class="sxs-lookup"><span data-stu-id="63d79-174">This behavior is intentional, but it remains non-obvious to many developers.</span></span> <span data-ttu-id="63d79-175">下列範例說明美國英文 ("en-US") 和瑞典文 ("sv-SE") 文化特性之間排序次序的差異。</span><span class="sxs-lookup"><span data-stu-id="63d79-175">The following example illustrates differences in sort order between the U.S. English ("en-US") and Swedish ("sv-SE") cultures.</span></span> <span data-ttu-id="63d79-176">請注意單字 "ångström"、"Windows" 和 "Visual Studio" 出現在已排序的字串陣列中的不同位置。</span><span class="sxs-lookup"><span data-stu-id="63d79-176">Note that the words "ångström", "Windows", and "Visual Studio" appear in different positions in the sorted string arrays.</span></span>

[!code-csharp[Conceptual.Strings.BestPractices#3](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.bestpractices/cs/comparison1.cs#3)]
[!code-vb[Conceptual.Strings.BestPractices#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.bestpractices/vb/comparison1.vb#3)]

<span data-ttu-id="63d79-177">如果比較是使用目前文化特性且不區分大小寫，這類比較和區分文化特性的比較相同 (除了這些比較會忽略執行緒目前文化特性的大小寫要求以外)。</span><span class="sxs-lookup"><span data-stu-id="63d79-177">Case-insensitive comparisons that use the current culture are the same as culture-sensitive comparisons, except that they ignore case as dictated by the thread's current culture.</span></span> <span data-ttu-id="63d79-178">這種行為可能會以排序順序來呈現。</span><span class="sxs-lookup"><span data-stu-id="63d79-178">This behavior may manifest itself in sort orders as well.</span></span>

<span data-ttu-id="63d79-179">下列方法預設為執行使用目前文化特性之語意的比較：</span><span class="sxs-lookup"><span data-stu-id="63d79-179">Comparisons that use current culture semantics are the default for the following methods:</span></span>

- <span data-ttu-id="63d79-180">不含<xref:System.String.Compare%2A?displayProperty=nameWithType> 參數的 <xref:System.StringComparison> 多載。</span><span class="sxs-lookup"><span data-stu-id="63d79-180"><xref:System.String.Compare%2A?displayProperty=nameWithType> overloads that do not include a <xref:System.StringComparison> parameter.</span></span>
- <span data-ttu-id="63d79-181"><xref:System.String.CompareTo%2A?displayProperty=nameWithType> 多載。</span><span class="sxs-lookup"><span data-stu-id="63d79-181"><xref:System.String.CompareTo%2A?displayProperty=nameWithType> overloads.</span></span>
- <span data-ttu-id="63d79-182">預設的 <xref:System.String.StartsWith%28System.String%29?displayProperty=nameWithType> 方法和含有 `null`<xref:System.Globalization.CultureInfo> 參數的 <xref:System.String.StartsWith%28System.String%2CSystem.Boolean%2CSystem.Globalization.CultureInfo%29?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="63d79-182">The default <xref:System.String.StartsWith%28System.String%29?displayProperty=nameWithType> method, and the <xref:System.String.StartsWith%28System.String%2CSystem.Boolean%2CSystem.Globalization.CultureInfo%29?displayProperty=nameWithType> method with a `null`<xref:System.Globalization.CultureInfo> parameter.</span></span>
- <span data-ttu-id="63d79-183">預設的 <xref:System.String.EndsWith%28System.String%29?displayProperty=nameWithType> 方法和含有 `null`<xref:System.Globalization.CultureInfo> 參數的 <xref:System.String.EndsWith%28System.String%2CSystem.Boolean%2CSystem.Globalization.CultureInfo%29?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="63d79-183">The default <xref:System.String.EndsWith%28System.String%29?displayProperty=nameWithType> method, and the <xref:System.String.EndsWith%28System.String%2CSystem.Boolean%2CSystem.Globalization.CultureInfo%29?displayProperty=nameWithType> method with a `null`<xref:System.Globalization.CultureInfo> parameter.</span></span>
- <span data-ttu-id="63d79-184">可接受<xref:System.String.IndexOf%2A?displayProperty=nameWithType> 做為搜尋參數且不含 <xref:System.String> 參數的 <xref:System.StringComparison> 多載。</span><span class="sxs-lookup"><span data-stu-id="63d79-184"><xref:System.String.IndexOf%2A?displayProperty=nameWithType> overloads that accept a <xref:System.String> as a search parameter and that do not have a <xref:System.StringComparison> parameter.</span></span>
- <span data-ttu-id="63d79-185">可接受<xref:System.String.LastIndexOf%2A?displayProperty=nameWithType> 做為搜尋參數且不含 <xref:System.String> 參數的 <xref:System.StringComparison> 多載。</span><span class="sxs-lookup"><span data-stu-id="63d79-185"><xref:System.String.LastIndexOf%2A?displayProperty=nameWithType> overloads that accept a <xref:System.String> as a search parameter and that do not have a <xref:System.StringComparison> parameter.</span></span>

<span data-ttu-id="63d79-186">在任何情況下，都建議您呼叫具有 <xref:System.StringComparison> 參數的多載，以讓呼叫方法的目的更清晰。</span><span class="sxs-lookup"><span data-stu-id="63d79-186">In any case, we recommend that you call an overload that has a <xref:System.StringComparison> parameter to make the intent of the method call clear.</span></span>

<span data-ttu-id="63d79-187">若以語言方式解譯非語言式的字串資料，或使用其他文化特性的慣例解譯來自特定文化特性的字串資料時，可能會出現微妙或不太微妙的 Bug。</span><span class="sxs-lookup"><span data-stu-id="63d79-187">Subtle and not so subtle bugs can emerge when non-linguistic string data is interpreted linguistically, or when string data from a particular culture is interpreted using the conventions of another culture.</span></span> <span data-ttu-id="63d79-188">標準範例是土耳其文 I 的問題。</span><span class="sxs-lookup"><span data-stu-id="63d79-188">The canonical example is the Turkish-I problem.</span></span>

<span data-ttu-id="63d79-189">對於幾乎所有拉丁字母 (包括美國英文)，字元 "i" (\u0069) 是字元 "I" (\u0049) 的小寫。</span><span class="sxs-lookup"><span data-stu-id="63d79-189">For nearly all Latin alphabets, including U.S. English, the character "i" (\u0069) is the lowercase version of the character "I" (\u0049).</span></span> <span data-ttu-id="63d79-190">這種大小寫規則很快成為以這種文化特性進行程式設計的人所採用的預設規則。</span><span class="sxs-lookup"><span data-stu-id="63d79-190">This casing rule quickly becomes the default for someone programming in such a culture.</span></span> <span data-ttu-id="63d79-191">不過，土耳其文 ("tr-TR") 字母包括「加上一點的 I」字元 "İ" (\u0130)，也就是 "i" 的大寫。</span><span class="sxs-lookup"><span data-stu-id="63d79-191">However, the Turkish ("tr-TR") alphabet includes an "I with a dot" character "İ" (\u0130), which is the capital version of "i".</span></span> <span data-ttu-id="63d79-192">土耳其文中也包含「不含點的 i 」字元，"ı" (\u0131)，其大寫為 "I"。</span><span class="sxs-lookup"><span data-stu-id="63d79-192">Turkish also includes a lowercase "i without a dot" character, "ı" (\u0131), which capitalizes to "I".</span></span> <span data-ttu-id="63d79-193">亞塞拜然 ("az") 文化特性中也會發生這種行為。</span><span class="sxs-lookup"><span data-stu-id="63d79-193">This behavior occurs in the Azerbaijani ("az") culture as well.</span></span>

<span data-ttu-id="63d79-194">因此，關於將 "i" 轉換成大寫或將 "I" 轉換成小寫的假設並不適用。</span><span class="sxs-lookup"><span data-stu-id="63d79-194">Therefore, assumptions made about capitalizing "i" or lowercasing "I" are not valid among all cultures.</span></span> <span data-ttu-id="63d79-195">如果您針對字串比較常式使用預設多載，就會受限於文化特性之間的差異。</span><span class="sxs-lookup"><span data-stu-id="63d79-195">If you use the default overloads for string comparison routines, they will be subject to variance between cultures.</span></span> <span data-ttu-id="63d79-196">如果要比較的資料為非語言式，使用預設多載可能產生非預期的結果，如下列嘗試執行字串 "file" 和 "FILE" 之不區分大小寫的比較範例所示。</span><span class="sxs-lookup"><span data-stu-id="63d79-196">If the data to be compared is non-linguistic, using the default overloads can produce undesirable results, as the following attempt to perform a case-insensitive comparison of the strings "file" and "FILE" illustrates.</span></span>

[!code-csharp[Conceptual.Strings.BestPractices#11](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.bestpractices/cs/turkish1.cs#11)]
[!code-vb[Conceptual.Strings.BestPractices#11](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.bestpractices/vb/turkish1.vb#11)]

<span data-ttu-id="63d79-197">如果不小心將文化特性用於安全性相關設定 (如下列範例所示)，這項比較可能會造成重大的問題。</span><span class="sxs-lookup"><span data-stu-id="63d79-197">This comparison could cause significant problems if the culture is inadvertently used in security-sensitive settings, as in the following example.</span></span> <span data-ttu-id="63d79-198">如果目前的文化特性是美國英文，方法呼叫 (如 `IsFileURI("file:")` ) 會傳回 `true` ；但若目前的文化特性為土耳其文，則傳回 `false` 。</span><span class="sxs-lookup"><span data-stu-id="63d79-198">A method call such as `IsFileURI("file:")` returns `true` if the current culture is U.S. English, but `false` if the current culture is Turkish.</span></span> <span data-ttu-id="63d79-199">因此，在土耳其文的系統中，有心人士可以使用開頭為 "FILE:" 的 URI，來規避封鎖存取不區分大小寫之 URI 的安全性措施。</span><span class="sxs-lookup"><span data-stu-id="63d79-199">Thus, on Turkish systems, someone could circumvent security measures that block access to case-insensitive URIs that begin with "FILE:".</span></span>

[!code-csharp[Conceptual.Strings.BestPractices#12](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.bestpractices/cs/turkish1.cs#12)]
[!code-vb[Conceptual.Strings.BestPractices#12](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.bestpractices/vb/turkish1.vb#12)]

<span data-ttu-id="63d79-200">在此情況下，因為 "file：" 旨在解釋為非語言、不區分文化特性的識別碼，所以應改為撰寫程式碼，如下列範例所示：</span><span class="sxs-lookup"><span data-stu-id="63d79-200">In this case, because "file:" is meant to be interpreted as a non-linguistic, culture-insensitive identifier, the code should instead be written as shown in the following example:</span></span>

[!code-csharp[Conceptual.Strings.BestPractices#13](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.bestpractices/cs/turkish1.cs#13)]
[!code-vb[Conceptual.Strings.BestPractices#13](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.bestpractices/vb/turkish1.vb#13)]

### <a name="ordinal-string-operations"></a><span data-ttu-id="63d79-201">序數位符串作業</span><span class="sxs-lookup"><span data-stu-id="63d79-201">Ordinal string operations</span></span>

<span data-ttu-id="63d79-202">在方法呼叫中指定 <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> 或 <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> 值意謂著非語言比較，其中忽略自然語言的特性。</span><span class="sxs-lookup"><span data-stu-id="63d79-202">Specifying the <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> or <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> value in a method call signifies a non-linguistic comparison in which the features of natural languages are ignored.</span></span> <span data-ttu-id="63d79-203">若使用這類 <xref:System.StringComparison> 值來呼叫方法，方法就會以簡單的位元組比較來進行字串作業決策，而不以文化特性參數化的大小寫或對等項目資料表為根據。</span><span class="sxs-lookup"><span data-stu-id="63d79-203">Methods that are invoked with these <xref:System.StringComparison> values base string operation decisions on simple byte comparisons instead of casing or equivalence tables that are parameterized by culture.</span></span> <span data-ttu-id="63d79-204">在大部分情況下，這種方法非常適合預期的字串解譯，同時可讓程式碼更快速、可靠。</span><span class="sxs-lookup"><span data-stu-id="63d79-204">In most cases, this approach best fits the intended interpretation of strings while making code faster and more reliable.</span></span>

<span data-ttu-id="63d79-205">序數比較是一種字串比較，其會比較每個字串的每個位元組，而不進行語言解譯；例如，"windows" 不符合 "Windows"。</span><span class="sxs-lookup"><span data-stu-id="63d79-205">Ordinal comparisons are string comparisons in which each byte of each string is compared without linguistic interpretation; for example, "windows" does not match "Windows".</span></span> <span data-ttu-id="63d79-206">這基本上是對 C 執行階段 `strcmp` 函式的呼叫。</span><span class="sxs-lookup"><span data-stu-id="63d79-206">This is essentially a call to the C runtime `strcmp` function.</span></span> <span data-ttu-id="63d79-207">如果內容指出字串應該完全相符，或要求保守的比對原則時，請使用這項比較。</span><span class="sxs-lookup"><span data-stu-id="63d79-207">Use this comparison when the context dictates that strings should be matched exactly or demands conservative matching policy.</span></span> <span data-ttu-id="63d79-208">此外，序數比較在決定結果時不會套用任何語言規則，因此是最快速的比較作業。</span><span class="sxs-lookup"><span data-stu-id="63d79-208">Additionally, ordinal comparison is the fastest comparison operation because it applies no linguistic rules when determining a result.</span></span>

<span data-ttu-id="63d79-209">.NET 中的字串可以包含內嵌的 Null 字元。</span><span class="sxs-lookup"><span data-stu-id="63d79-209">Strings in .NET can contain embedded null characters.</span></span> <span data-ttu-id="63d79-210">序數和區分文化特性的比較 (包括使用不因文化特性而異的比較) 其中一個最明顯差異在於，內嵌 Null 字元在字串中的處理方式。</span><span class="sxs-lookup"><span data-stu-id="63d79-210">One of the clearest differences between ordinal and culture-sensitive comparison (including comparisons that use the invariant culture) concerns the handling of embedded null characters in a string.</span></span> <span data-ttu-id="63d79-211">當您使用 <xref:System.String.Compare%2A?displayProperty=nameWithType> 和 <xref:System.String.Equals%2A?displayProperty=nameWithType> 方法來執行區分文化特性的比較 (包括使用不因文化特性而異的比較) 時，會忽略這些字元。</span><span class="sxs-lookup"><span data-stu-id="63d79-211">These characters are ignored when you use the <xref:System.String.Compare%2A?displayProperty=nameWithType> and <xref:System.String.Equals%2A?displayProperty=nameWithType> methods to perform culture-sensitive comparisons (including comparisons that use the invariant culture).</span></span> <span data-ttu-id="63d79-212">如此一來，在區分文化特性的比較中，即可將包含內嵌 Null 字元的字串視為等於不含這類字元的字串。</span><span class="sxs-lookup"><span data-stu-id="63d79-212">As a result, in culture-sensitive comparisons, strings that contain embedded null characters can be considered equal to strings that do not.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="63d79-213">雖然字串比較方法可以忽略內嵌的 Null 字元，但 <xref:System.String.Contains%2A?displayProperty=nameWithType>、 <xref:System.String.EndsWith%2A?displayProperty=nameWithType>、 <xref:System.String.IndexOf%2A?displayProperty=nameWithType>、 <xref:System.String.LastIndexOf%2A?displayProperty=nameWithType>和 <xref:System.String.StartsWith%2A?displayProperty=nameWithType> 之類的字串搜尋方法就不能這麼做了。</span><span class="sxs-lookup"><span data-stu-id="63d79-213">Although string comparison methods disregard embedded null characters, string search methods such as <xref:System.String.Contains%2A?displayProperty=nameWithType>, <xref:System.String.EndsWith%2A?displayProperty=nameWithType>, <xref:System.String.IndexOf%2A?displayProperty=nameWithType>, <xref:System.String.LastIndexOf%2A?displayProperty=nameWithType>, and <xref:System.String.StartsWith%2A?displayProperty=nameWithType> do not.</span></span>

<span data-ttu-id="63d79-214">下列範例會對字串 "Aa" 執行區分文化特性的比較，該字串包含數個在 "A" 和 "a" 之間的內嵌 null 字元，並顯示兩個字串如何視為相等：</span><span class="sxs-lookup"><span data-stu-id="63d79-214">The following example performs a culture-sensitive comparison of the string "Aa" with a similar string that contains several embedded null characters between "A" and "a", and shows how the two strings are considered equal:</span></span>

[!code-csharp[Conceptual.Strings.BestPractices#19](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.bestpractices/cs/embeddednulls1.cs#19)]
 [!code-vb[Conceptual.Strings.BestPractices#19](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.bestpractices/vb/embeddednulls1.vb#19)]

<span data-ttu-id="63d79-215">但是，當您使用序數比較時，不會將字串視為相等，如下列範例所示：</span><span class="sxs-lookup"><span data-stu-id="63d79-215">However, the strings are not considered equal when you use ordinal comparison, as the following example shows:</span></span>

[!code-csharp[Conceptual.Strings.BestPractices#20](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.bestpractices/cs/embeddednulls2.cs#20)]
[!code-vb[Conceptual.Strings.BestPractices#20](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.bestpractices/vb/embeddednulls2.vb#20)]

<span data-ttu-id="63d79-216">第二種最保守的方式是不區分大小寫的序數比較。</span><span class="sxs-lookup"><span data-stu-id="63d79-216">Case-insensitive ordinal comparisons are the next most conservative approach.</span></span> <span data-ttu-id="63d79-217">這些比較會忽略大部分的大小寫；例如，"windows" 符合 "Windows"。</span><span class="sxs-lookup"><span data-stu-id="63d79-217">These comparisons ignore most casing; for example, "windows" matches "Windows".</span></span> <span data-ttu-id="63d79-218">當處理 ASCII 字元時，這項原則相當於 <xref:System.StringComparison.Ordinal?displayProperty=nameWithType>，不過它會忽略一般 ASCII 大小寫。</span><span class="sxs-lookup"><span data-stu-id="63d79-218">When dealing with ASCII characters, this policy is equivalent to <xref:System.StringComparison.Ordinal?displayProperty=nameWithType>, except that it ignores the usual ASCII casing.</span></span> <span data-ttu-id="63d79-219">因此，[A, Z] (\u0041-\u005A) 中的任何字元會符合 [a,z] (\u0061-\007A) 中的對應字元。</span><span class="sxs-lookup"><span data-stu-id="63d79-219">Therefore, any character in [A, Z] (\u0041-\u005A) matches the corresponding character in [a,z] (\u0061-\007A).</span></span> <span data-ttu-id="63d79-220">ASCII 範圍之外的大小寫會使用不因文化特性而異的資料表。</span><span class="sxs-lookup"><span data-stu-id="63d79-220">Casing outside the ASCII range uses the invariant culture's tables.</span></span> <span data-ttu-id="63d79-221">因此，下列比較：</span><span class="sxs-lookup"><span data-stu-id="63d79-221">Therefore, the following comparison:</span></span>

[!code-csharp[Conceptual.Strings.BestPractices#4](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.bestpractices/cs/comparison2.cs#4)]
[!code-vb[Conceptual.Strings.BestPractices#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.bestpractices/vb/comparison2.vb#4)]

<span data-ttu-id="63d79-222">相當於下列比較 (而且更快)：</span><span class="sxs-lookup"><span data-stu-id="63d79-222">is equivalent to (but faster than) this comparison:</span></span>

[!code-csharp[Conceptual.Strings.BestPractices#5](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.bestpractices/cs/comparison2.cs#5)]
[!code-vb[Conceptual.Strings.BestPractices#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.bestpractices/vb/comparison2.vb#5)]

<span data-ttu-id="63d79-223">這些比較仍非常快速。</span><span class="sxs-lookup"><span data-stu-id="63d79-223">These comparisons are still very fast.</span></span>

<span data-ttu-id="63d79-224"><xref:System.StringComparison.Ordinal?displayProperty=nameWithType> 和 <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> 兩者都直接使用二進位值，最適合用來比對。</span><span class="sxs-lookup"><span data-stu-id="63d79-224">Both <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> and <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> use the binary values directly, and are best suited for matching.</span></span> <span data-ttu-id="63d79-225">當您不確定比較設定時，請使用這兩個值的其中一個。</span><span class="sxs-lookup"><span data-stu-id="63d79-225">When you are not sure about your comparison settings, use one of these two values.</span></span> <span data-ttu-id="63d79-226">不過，因為它們是以位元組為單位逐一比較，所以不會依照語言排序次序來排序 (就像英文字典一樣)，而是採用二進位排序次序。</span><span class="sxs-lookup"><span data-stu-id="63d79-226">However, because they perform a byte-by-byte comparison, they do not sort by a linguistic sort order (like an English dictionary) but by a binary sort order.</span></span> <span data-ttu-id="63d79-227">因此，在大多數內容當中，使用者看到的結果可能很奇怪。</span><span class="sxs-lookup"><span data-stu-id="63d79-227">The results may look odd in most contexts if displayed to users.</span></span>

<span data-ttu-id="63d79-228">不包含 <xref:System.String.Equals%2A?displayProperty=nameWithType> 引數 (包括等號比較運算子) 的 <xref:System.StringComparison> 多載是以序數語意為預設。</span><span class="sxs-lookup"><span data-stu-id="63d79-228">Ordinal semantics are the default for <xref:System.String.Equals%2A?displayProperty=nameWithType> overloads that do not include a <xref:System.StringComparison> argument (including the equality operator).</span></span> <span data-ttu-id="63d79-229">在任何情況下，我們建議您呼叫具有 <xref:System.StringComparison> 參數的多載。</span><span class="sxs-lookup"><span data-stu-id="63d79-229">In any case, we recommend that you call an overload that has a <xref:System.StringComparison> parameter.</span></span>

### <a name="string-operations-that-use-the-invariant-culture"></a><span data-ttu-id="63d79-230">使用文化特性不變的字串作業</span><span class="sxs-lookup"><span data-stu-id="63d79-230">String operations that use the invariant culture</span></span>

<span data-ttu-id="63d79-231">採用不因文化特性而異的比較會使用靜態 <xref:System.Globalization.CultureInfo.CompareInfo%2A> 屬性傳回的 <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> 屬性。</span><span class="sxs-lookup"><span data-stu-id="63d79-231">Comparisons with the invariant culture use the <xref:System.Globalization.CultureInfo.CompareInfo%2A> property returned by the static <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="63d79-232">這種行為在所有系統上都相同，它會將其範圍之外的任何字元轉譯成它認為是相等非變異字元的字元。</span><span class="sxs-lookup"><span data-stu-id="63d79-232">This behavior is the same on all systems; it translates any characters outside its range into what it believes are equivalent invariant characters.</span></span> <span data-ttu-id="63d79-233">這項原則很適合跨文化特性來維護一套字串行為，但通常會產生非預期的結果。</span><span class="sxs-lookup"><span data-stu-id="63d79-233">This policy can be useful for maintaining one set of string behavior across cultures, but it often provides unexpected results.</span></span>

<span data-ttu-id="63d79-234">採用不因文化特性而異的不分區大小寫比較，也會使用靜態 <xref:System.Globalization.CultureInfo.CompareInfo%2A> 屬性所傳回的靜態 <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> 屬性來取得比較資訊。</span><span class="sxs-lookup"><span data-stu-id="63d79-234">Case-insensitive comparisons with the invariant culture use the static <xref:System.Globalization.CultureInfo.CompareInfo%2A> property returned by the static <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> property for comparison information as well.</span></span> <span data-ttu-id="63d79-235">這些轉譯的字元之間的任何大小寫差異都會被忽略。</span><span class="sxs-lookup"><span data-stu-id="63d79-235">Any case differences among these translated characters are ignored.</span></span>

<span data-ttu-id="63d79-236">使用 <xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType> 和 <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> 的比較在 ASCII 字串上的運作方式完全相同。</span><span class="sxs-lookup"><span data-stu-id="63d79-236">Comparisons that use <xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType> and <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> work identically on ASCII strings.</span></span> <span data-ttu-id="63d79-237">不過，對於必須解譯成一組位元組的字串， <xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType> 所做的語言決策就可能不適合。</span><span class="sxs-lookup"><span data-stu-id="63d79-237">However, <xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType> makes linguistic decisions that might not be appropriate for strings that have to be interpreted as a set of bytes.</span></span> <span data-ttu-id="63d79-238">由 `CultureInfo.InvariantCulture.CompareInfo` 物件使 <xref:System.String.Compare%2A> 方法將多組字元解譯成相等。</span><span class="sxs-lookup"><span data-stu-id="63d79-238">The `CultureInfo.InvariantCulture.CompareInfo` object makes the <xref:System.String.Compare%2A> method interpret certain sets of characters as equivalent.</span></span> <span data-ttu-id="63d79-239">例如，下列等式在不因國別而異的文化特性之下有效：</span><span class="sxs-lookup"><span data-stu-id="63d79-239">For example, the following equivalence is valid under the invariant culture:</span></span>

<span data-ttu-id="63d79-240">InvariantCulture: a + ̊ = å</span><span class="sxs-lookup"><span data-stu-id="63d79-240">InvariantCulture: a + ̊ = å</span></span>

<span data-ttu-id="63d79-241">拉丁小寫字母 A 字元 "a" (\u0061) 在緊鄰著結合上圓圈字元 "+ " ̊" (\u030a) 時，解譯成拉丁小寫字母 A 帶上圓圈字元 "å" (\u00e5)。</span><span class="sxs-lookup"><span data-stu-id="63d79-241">The LATIN SMALL LETTER A character "a"  (\u0061), when it is next to the COMBINING RING ABOVE character "+ " ̊" (\u030a), is interpreted as the LATIN SMALL LETTER A WITH RING ABOVE character "å" (\u00e5).</span></span> <span data-ttu-id="63d79-242">如下列範例如示，這種行為不同於序數比較。</span><span class="sxs-lookup"><span data-stu-id="63d79-242">As the following example shows, this behavior differs from ordinal comparison.</span></span>

[!code-csharp[Conceptual.Strings.BestPractices#15](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.bestpractices/cs/comparison3.cs#15)]
[!code-vb[Conceptual.Strings.BestPractices#15](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.bestpractices/vb/comparison3.vb#15)]

<span data-ttu-id="63d79-243">在解譯檔名、Cookie 或可能出現像 "å" 一樣的組合的其他任何字串時，序數比較仍然會展現最明確和最適當的行為。</span><span class="sxs-lookup"><span data-stu-id="63d79-243">When interpreting file names, cookies, or anything else where a combination such as "å" can appear, ordinal comparisons still offer the most transparent and fitting behavior.</span></span>

<span data-ttu-id="63d79-244">權衡來看，不因國別而異的文化特性只有非常少的屬性，因此適合用於比較。</span><span class="sxs-lookup"><span data-stu-id="63d79-244">On balance, the invariant culture has very few properties that make it useful for comparison.</span></span> <span data-ttu-id="63d79-245">不過，它會以語言相關的方式進行比較，這樣無法保證符號完全相等，因而不適合在任何文化特性中顯示。</span><span class="sxs-lookup"><span data-stu-id="63d79-245">It does comparison in a linguistically relevant manner, which prevents it from guaranteeing full symbolic equivalence, but it is not the choice for display in any culture.</span></span> <span data-ttu-id="63d79-246">使用 <xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType> 來比較有幾個理由，其中之一是保持已排序的資料在不同文化特性下顯示時完全相同。</span><span class="sxs-lookup"><span data-stu-id="63d79-246">One of the few reasons to use <xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType> for comparison is to persist ordered data for a cross-culturally identical display.</span></span> <span data-ttu-id="63d79-247">例如，如果包含已排序之顯示識別項清單的大型資料檔案伴隨一個應用程式，則加入這份清單需要插入非變異樣式排序。</span><span class="sxs-lookup"><span data-stu-id="63d79-247">For example, if a large data file that contains a list of sorted identifiers for display accompanies an application, adding to this list would require an insertion with invariant-style sorting.</span></span>

## <a name="choosing-a-stringcomparison-member-for-your-method-call"></a><span data-ttu-id="63d79-248">為您的方法呼叫選擇 StringComparison 成員</span><span class="sxs-lookup"><span data-stu-id="63d79-248">Choosing a StringComparison member for your method call</span></span>

<span data-ttu-id="63d79-249">下表概述從語義字串內容到列舉成員的對應 <xref:System.StringComparison> ：</span><span class="sxs-lookup"><span data-stu-id="63d79-249">The following table outlines the mapping from semantic string context to a <xref:System.StringComparison> enumeration member:</span></span>

|<span data-ttu-id="63d79-250">資料</span><span class="sxs-lookup"><span data-stu-id="63d79-250">Data</span></span>|<span data-ttu-id="63d79-251">行為</span><span class="sxs-lookup"><span data-stu-id="63d79-251">Behavior</span></span>|<span data-ttu-id="63d79-252">對應的 System.StringComparison</span><span class="sxs-lookup"><span data-stu-id="63d79-252">Corresponding System.StringComparison</span></span><br /><br /> <span data-ttu-id="63d79-253">value</span><span class="sxs-lookup"><span data-stu-id="63d79-253">value</span></span>|
|----------|--------------|-----------------------------------------------------|
|<span data-ttu-id="63d79-254">區分大小寫的內部識別項。</span><span class="sxs-lookup"><span data-stu-id="63d79-254">Case-sensitive internal identifiers.</span></span><br /><br /> <span data-ttu-id="63d79-255">在標準中區分大小寫的識別項，例如 XML 和 HTTP。</span><span class="sxs-lookup"><span data-stu-id="63d79-255">Case-sensitive identifiers in standards such as XML and HTTP.</span></span><br /><br /> <span data-ttu-id="63d79-256">區分大小寫的安全性相關設定。</span><span class="sxs-lookup"><span data-stu-id="63d79-256">Case-sensitive security-related settings.</span></span>|<span data-ttu-id="63d79-257">位元組完全相符的非語言識別項。</span><span class="sxs-lookup"><span data-stu-id="63d79-257">A non-linguistic identifier, where bytes match exactly.</span></span>|<xref:System.StringComparison.Ordinal>|
|<span data-ttu-id="63d79-258">不區分大小寫的內部識別項。</span><span class="sxs-lookup"><span data-stu-id="63d79-258">Case-insensitive internal identifiers.</span></span><br /><br /> <span data-ttu-id="63d79-259">在標準中區分大小寫的識別項，例如 XML 和 HTTP。</span><span class="sxs-lookup"><span data-stu-id="63d79-259">Case-insensitive identifiers in standards such as XML and HTTP.</span></span><br /><br /> <span data-ttu-id="63d79-260">檔案路徑。</span><span class="sxs-lookup"><span data-stu-id="63d79-260">File paths.</span></span><br /><br /> <span data-ttu-id="63d79-261">登錄機碼和值。</span><span class="sxs-lookup"><span data-stu-id="63d79-261">Registry keys and values.</span></span><br /><br /> <span data-ttu-id="63d79-262">環境變數。</span><span class="sxs-lookup"><span data-stu-id="63d79-262">Environment variables.</span></span><br /><br /> <span data-ttu-id="63d79-263">資源識別項 (例如控制代碼名稱)。</span><span class="sxs-lookup"><span data-stu-id="63d79-263">Resource identifiers (for example, handle names).</span></span><br /><br /> <span data-ttu-id="63d79-264">不區分大小寫的安全性相關設定。</span><span class="sxs-lookup"><span data-stu-id="63d79-264">Case-insensitive security-related settings.</span></span>|<span data-ttu-id="63d79-265">大小寫不重要的非語言識別項，特別是大部分 Windows 系統服務中儲存的資料。</span><span class="sxs-lookup"><span data-stu-id="63d79-265">A non-linguistic identifier, where case is irrelevant; especially data stored in most Windows system services.</span></span>|<xref:System.StringComparison.OrdinalIgnoreCase>|
|<span data-ttu-id="63d79-266">某些永續性、語言相關的資料。</span><span class="sxs-lookup"><span data-stu-id="63d79-266">Some persisted, linguistically relevant data.</span></span><br /><br /> <span data-ttu-id="63d79-267">需要固定排序次序之語言資料的顯示。</span><span class="sxs-lookup"><span data-stu-id="63d79-267">Display of linguistic data that requires a fixed sort order.</span></span>|<span data-ttu-id="63d79-268">仍與語言相關之不區分文化特性的資料。</span><span class="sxs-lookup"><span data-stu-id="63d79-268">Culturally agnostic data that still is linguistically relevant.</span></span>|<xref:System.StringComparison.InvariantCulture><br /><br /> <span data-ttu-id="63d79-269">-或-</span><span class="sxs-lookup"><span data-stu-id="63d79-269">-or-</span></span><br /><br /> <xref:System.StringComparison.InvariantCultureIgnoreCase>|
|<span data-ttu-id="63d79-270">向使用者顯示的資料。</span><span class="sxs-lookup"><span data-stu-id="63d79-270">Data displayed to the user.</span></span><br /><br /> <span data-ttu-id="63d79-271">大部分的使用者輸入。</span><span class="sxs-lookup"><span data-stu-id="63d79-271">Most user input.</span></span>|<span data-ttu-id="63d79-272">需要當地語言自訂的資料。</span><span class="sxs-lookup"><span data-stu-id="63d79-272">Data that requires local linguistic customs.</span></span>|<xref:System.StringComparison.CurrentCulture><br /><br /> <span data-ttu-id="63d79-273">-或-</span><span class="sxs-lookup"><span data-stu-id="63d79-273">-or-</span></span><br /><br /> <xref:System.StringComparison.CurrentCultureIgnoreCase>|

## <a name="common-string-comparison-methods-in-net"></a><span data-ttu-id="63d79-274">.NET 中常用的字串比較方法</span><span class="sxs-lookup"><span data-stu-id="63d79-274">Common string comparison methods in .NET</span></span>

<span data-ttu-id="63d79-275">下列各節描述字串比較最常用的方法。</span><span class="sxs-lookup"><span data-stu-id="63d79-275">The following sections describe the methods that are most commonly used for string comparison.</span></span>

### <a name="stringcompare"></a><span data-ttu-id="63d79-276">String.Compare</span><span class="sxs-lookup"><span data-stu-id="63d79-276">String.Compare</span></span>

<span data-ttu-id="63d79-277">預設解譯： <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="63d79-277">Default interpretation: <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="63d79-278">由於是字串解譯最主要的作業，這些方法呼叫的所有執行個體都應該經過檢查，以決定字串應該根據目前文化特性來解譯，還是與文化特性分開 (符號形式)。</span><span class="sxs-lookup"><span data-stu-id="63d79-278">As the operation most central to string interpretation, all instances of these method calls should be examined to determine whether strings should be interpreted according to the current culture, or dissociated from the culture (symbolically).</span></span> <span data-ttu-id="63d79-279">通常是後者，所以應該改用 <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> 比較。</span><span class="sxs-lookup"><span data-stu-id="63d79-279">Typically, it is the latter, and a <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> comparison should be used instead.</span></span>

<span data-ttu-id="63d79-280">由 <xref:System.Globalization.CompareInfo?displayProperty=nameWithType> 屬性傳回的 <xref:System.Globalization.CultureInfo.CompareInfo%2A?displayProperty=nameWithType> 類別也包含 <xref:System.Globalization.CompareInfo.Compare%2A> 方法，這個方法透過 <xref:System.Globalization.CompareOptions> 旗標列舉，提供大量比對選項 (序數、忽略空白字元、忽略假名類型等)。</span><span class="sxs-lookup"><span data-stu-id="63d79-280">The <xref:System.Globalization.CompareInfo?displayProperty=nameWithType> class, which is returned by the <xref:System.Globalization.CultureInfo.CompareInfo%2A?displayProperty=nameWithType> property, also includes a <xref:System.Globalization.CompareInfo.Compare%2A> method that provides a large number of matching options (ordinal, ignoring white space, ignoring kana type, and so on) by means of the <xref:System.Globalization.CompareOptions> flag enumeration.</span></span>

### <a name="stringcompareto"></a><span data-ttu-id="63d79-281">String.CompareTo</span><span class="sxs-lookup"><span data-stu-id="63d79-281">String.CompareTo</span></span>

<span data-ttu-id="63d79-282">預設解譯： <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="63d79-282">Default interpretation: <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="63d79-283">這個方法目前未提供任何指定 <xref:System.StringComparison> 類型的多載。</span><span class="sxs-lookup"><span data-stu-id="63d79-283">This method does not currently offer an overload that specifies a <xref:System.StringComparison> type.</span></span> <span data-ttu-id="63d79-284">通常可以將這個方法轉換成建議的 <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType> 形式。</span><span class="sxs-lookup"><span data-stu-id="63d79-284">It is usually possible to convert this method to the recommended <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType> form.</span></span>

<span data-ttu-id="63d79-285">實作 <xref:System.IComparable> 和 <xref:System.IComparable%601> 介面的類型會實作這個方法。</span><span class="sxs-lookup"><span data-stu-id="63d79-285">Types that implement the <xref:System.IComparable> and <xref:System.IComparable%601> interfaces implement this method.</span></span> <span data-ttu-id="63d79-286">由於它不提供 <xref:System.StringComparison> 參數的選項，所以實作這些型別通常可讓使用者在建構函式中指定 <xref:System.StringComparer> 。</span><span class="sxs-lookup"><span data-stu-id="63d79-286">Because it does not offer the option of a <xref:System.StringComparison> parameter, implementing types often let the user specify a <xref:System.StringComparer> in their constructor.</span></span> <span data-ttu-id="63d79-287">下列範例定義 `FileName` 類別，該類別的類別建構函式包含 <xref:System.StringComparer> 參數。</span><span class="sxs-lookup"><span data-stu-id="63d79-287">The following example defines a `FileName` class whose class constructor includes a <xref:System.StringComparer> parameter.</span></span> <span data-ttu-id="63d79-288">然後在 <xref:System.StringComparer> 方法中使用這個 `FileName.CompareTo` 物件。</span><span class="sxs-lookup"><span data-stu-id="63d79-288">This <xref:System.StringComparer> object is then used in the `FileName.CompareTo` method.</span></span>

[!code-csharp[Conceptual.Strings.BestPractices#6](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.bestpractices/cs/api1.cs#6)]
[!code-vb[Conceptual.Strings.BestPractices#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.bestpractices/vb/api1.vb#6)]

### <a name="stringequals"></a><span data-ttu-id="63d79-289">String.Equals</span><span class="sxs-lookup"><span data-stu-id="63d79-289">String.Equals</span></span>

<span data-ttu-id="63d79-290">預設解譯： <xref:System.StringComparison.Ordinal?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="63d79-290">Default interpretation: <xref:System.StringComparison.Ordinal?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="63d79-291"><xref:System.String> 類別可讓您呼叫靜態或執行個體 <xref:System.String.Equals%2A> 方法多載，或使用靜態等號比較運算子，以測試是否相等。</span><span class="sxs-lookup"><span data-stu-id="63d79-291">The <xref:System.String> class lets you test for equality by calling either the static or instance <xref:System.String.Equals%2A> method overloads, or by using the static equality operator.</span></span> <span data-ttu-id="63d79-292">多載和運算子預設會使用序數比較。</span><span class="sxs-lookup"><span data-stu-id="63d79-292">The overloads and operator use ordinal comparison by default.</span></span> <span data-ttu-id="63d79-293">然而，即使您想要執行序數比較，我們還是建議您呼叫明確指定 <xref:System.StringComparison> 型別的多載，這樣可以很輕鬆在程式碼中搜尋特定的字串解譯。</span><span class="sxs-lookup"><span data-stu-id="63d79-293">However, we still recommend that you call an overload that explicitly specifies the <xref:System.StringComparison> type even if you want to perform an ordinal comparison; this makes it easier to search code for a certain string interpretation.</span></span>

### <a name="stringtoupper-and-stringtolower"></a><span data-ttu-id="63d79-294">String.ToUpper 和 String.ToLower</span><span class="sxs-lookup"><span data-stu-id="63d79-294">String.ToUpper and String.ToLower</span></span>

<span data-ttu-id="63d79-295">預設解譯： <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="63d79-295">Default interpretation: <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="63d79-296">當您使用 <xref:System.String.ToUpper?displayProperty=nameWithType> 和 <xref:System.String.ToLower?displayProperty=nameWithType> 方法時請小心，因為強制字串為大寫或小寫通常用來做為比較字串的小型正規化，而不考慮大小寫。</span><span class="sxs-lookup"><span data-stu-id="63d79-296">Be careful when you use the <xref:System.String.ToUpper?displayProperty=nameWithType> and <xref:System.String.ToLower?displayProperty=nameWithType> methods, because forcing a string to a uppercase or lowercase is often used as a small normalization for comparing strings regardless of case.</span></span> <span data-ttu-id="63d79-297">如果是這樣，請考慮使用不區分大小寫的比較。</span><span class="sxs-lookup"><span data-stu-id="63d79-297">If so, consider using a case-insensitive comparison.</span></span>

<span data-ttu-id="63d79-298">您也可以使用 <xref:System.String.ToUpperInvariant%2A?displayProperty=nameWithType> 和 <xref:System.String.ToLowerInvariant%2A?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="63d79-298">The <xref:System.String.ToUpperInvariant%2A?displayProperty=nameWithType> and <xref:System.String.ToLowerInvariant%2A?displayProperty=nameWithType> methods are also available.</span></span> <span data-ttu-id="63d79-299"><xref:System.String.ToUpperInvariant%2A> 是將大小寫正規化的標準方式。</span><span class="sxs-lookup"><span data-stu-id="63d79-299"><xref:System.String.ToUpperInvariant%2A> is the standard way to normalize case.</span></span> <span data-ttu-id="63d79-300">使用 <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> 進行的比較在行為上由兩次呼叫所構成：在兩個字串引數上都呼叫 <xref:System.String.ToUpperInvariant%2A> ，然後使用 <xref:System.StringComparison.Ordinal?displayProperty=nameWithType>進行比較。</span><span class="sxs-lookup"><span data-stu-id="63d79-300">Comparisons made using <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> are behaviorally the composition of two calls: calling <xref:System.String.ToUpperInvariant%2A> on both string arguments, and doing a comparison using <xref:System.StringComparison.Ordinal?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="63d79-301">特定文化特性中，也可以使用多載將表示該文化特性的 <xref:System.Globalization.CultureInfo> 物件傳遞至這個方法，以轉換為大寫和小寫。</span><span class="sxs-lookup"><span data-stu-id="63d79-301">Overloads are also available for converting to uppercase and lowercase in a specific culture, by passing a <xref:System.Globalization.CultureInfo> object that represents that culture to the method.</span></span>

### <a name="chartoupper-and-chartolower"></a><span data-ttu-id="63d79-302">Char.ToUpper 和 Char.ToLower</span><span class="sxs-lookup"><span data-stu-id="63d79-302">Char.ToUpper and Char.ToLower</span></span>

<span data-ttu-id="63d79-303">預設解譯： <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="63d79-303">Default interpretation: <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="63d79-304"><xref:System.Char.ToUpper(System.Char)?displayProperty=nameWithType>和 <xref:System.Char.ToLower(System.Char)?displayProperty=nameWithType> 方法的運作方式類似于 <xref:System.String.ToUpper?displayProperty=nameWithType> <xref:System.String.ToLower?displayProperty=nameWithType> 上一節中所述的和方法。</span><span class="sxs-lookup"><span data-stu-id="63d79-304">The <xref:System.Char.ToUpper(System.Char)?displayProperty=nameWithType> and <xref:System.Char.ToLower(System.Char)?displayProperty=nameWithType> methods work similarly to the <xref:System.String.ToUpper?displayProperty=nameWithType> and <xref:System.String.ToLower?displayProperty=nameWithType> methods described in the previous section.</span></span>

### <a name="stringstartswith-and-stringendswith"></a><span data-ttu-id="63d79-305">String.StartsWith 和 String.EndsWith</span><span class="sxs-lookup"><span data-stu-id="63d79-305">String.StartsWith and String.EndsWith</span></span>

<span data-ttu-id="63d79-306">預設解譯： <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="63d79-306">Default interpretation: <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="63d79-307">根據預設，這兩個方法都會執行區分文化特性的比較。</span><span class="sxs-lookup"><span data-stu-id="63d79-307">By default, both of these methods perform a culture-sensitive comparison.</span></span>

### <a name="stringindexof-and-stringlastindexof"></a><span data-ttu-id="63d79-308">String.IndexOf 和 String.LastIndexOf</span><span class="sxs-lookup"><span data-stu-id="63d79-308">String.IndexOf and String.LastIndexOf</span></span>

<span data-ttu-id="63d79-309">預設解譯： <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="63d79-309">Default interpretation: <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="63d79-310">這些方法的預設多載在執行比較時，作法並不一致。</span><span class="sxs-lookup"><span data-stu-id="63d79-310">There is a lack of consistency in how the default overloads of these methods perform comparisons.</span></span> <span data-ttu-id="63d79-311">所有包含 <xref:System.String.IndexOf%2A?displayProperty=nameWithType> 參數的 <xref:System.String.LastIndexOf%2A?displayProperty=nameWithType> 和 <xref:System.Char> 方法都執行序數比較，但包含 <xref:System.String.IndexOf%2A?displayProperty=nameWithType> 參數的預設 <xref:System.String.LastIndexOf%2A?displayProperty=nameWithType> 和 <xref:System.String> 方法會執行區分文化特性的比較。</span><span class="sxs-lookup"><span data-stu-id="63d79-311">All <xref:System.String.IndexOf%2A?displayProperty=nameWithType> and <xref:System.String.LastIndexOf%2A?displayProperty=nameWithType> methods that include a <xref:System.Char> parameter perform an ordinal comparison, but the default <xref:System.String.IndexOf%2A?displayProperty=nameWithType> and <xref:System.String.LastIndexOf%2A?displayProperty=nameWithType> methods that include a <xref:System.String> parameter perform a culture-sensitive comparison.</span></span>

<span data-ttu-id="63d79-312">如果您呼叫 <xref:System.String.IndexOf%28System.String%29?displayProperty=nameWithType> 或 <xref:System.String.LastIndexOf%28System.String%29?displayProperty=nameWithType> 方法，並將要在目前執行個體中尋找的字串傳遞至這個方法，我們建議您呼叫明確指定 <xref:System.StringComparison> 類型的多載。</span><span class="sxs-lookup"><span data-stu-id="63d79-312">If you call the <xref:System.String.IndexOf%28System.String%29?displayProperty=nameWithType> or <xref:System.String.LastIndexOf%28System.String%29?displayProperty=nameWithType> method and pass it a string to locate in the current instance, we recommend that you call an overload that explicitly specifies the <xref:System.StringComparison> type.</span></span> <span data-ttu-id="63d79-313">包含 <xref:System.Char> 引數的多載不允許您指定 <xref:System.StringComparison> 類型。</span><span class="sxs-lookup"><span data-stu-id="63d79-313">The overloads that include a <xref:System.Char> argument do not allow you to specify a <xref:System.StringComparison> type.</span></span>

## <a name="methods-that-perform-string-comparison-indirectly"></a><span data-ttu-id="63d79-314">間接執行字串比較的方法</span><span class="sxs-lookup"><span data-stu-id="63d79-314">Methods that perform string comparison indirectly</span></span>

<span data-ttu-id="63d79-315">有一些以字串比較為主要作業的非字串方法會使用 <xref:System.StringComparer> 類型。</span><span class="sxs-lookup"><span data-stu-id="63d79-315">Some non-string methods that have string comparison as a central operation use the <xref:System.StringComparer> type.</span></span> <span data-ttu-id="63d79-316"><xref:System.StringComparer> 類別包含六個靜態屬性，這些屬性會傳回 <xref:System.StringComparer> 執行個體，而這些執行個體的 <xref:System.StringComparer.Compare%2A?displayProperty=nameWithType> 方法可以執行下列類型的字串比較：</span><span class="sxs-lookup"><span data-stu-id="63d79-316">The <xref:System.StringComparer> class includes six static properties that return <xref:System.StringComparer> instances whose <xref:System.StringComparer.Compare%2A?displayProperty=nameWithType> methods perform the following types of string comparisons:</span></span>

- <span data-ttu-id="63d79-317">使用目前文化特性的區分文化特性字串比較。</span><span class="sxs-lookup"><span data-stu-id="63d79-317">Culture-sensitive string comparisons using the current culture.</span></span> <span data-ttu-id="63d79-318">這個 <xref:System.StringComparer> 物件是由 <xref:System.StringComparer.CurrentCulture%2A?displayProperty=nameWithType> 屬性傳回。</span><span class="sxs-lookup"><span data-stu-id="63d79-318">This <xref:System.StringComparer> object is returned by the <xref:System.StringComparer.CurrentCulture%2A?displayProperty=nameWithType> property.</span></span>
- <span data-ttu-id="63d79-319">使用目前文化特性的不區分大小寫比較。</span><span class="sxs-lookup"><span data-stu-id="63d79-319">Case-insensitive comparisons using the current culture.</span></span> <span data-ttu-id="63d79-320">這個 <xref:System.StringComparer> 物件是由 <xref:System.StringComparer.CurrentCultureIgnoreCase%2A?displayProperty=nameWithType> 屬性傳回。</span><span class="sxs-lookup"><span data-stu-id="63d79-320">This <xref:System.StringComparer> object is returned by the <xref:System.StringComparer.CurrentCultureIgnoreCase%2A?displayProperty=nameWithType> property.</span></span>
- <span data-ttu-id="63d79-321">使用不因文化特性而異之字組比較規則的不區分文化特性比較。</span><span class="sxs-lookup"><span data-stu-id="63d79-321">Culture-insensitive comparisons using the word comparison rules of the invariant culture.</span></span> <span data-ttu-id="63d79-322">這個 <xref:System.StringComparer> 物件是由 <xref:System.StringComparer.InvariantCulture%2A?displayProperty=nameWithType> 屬性傳回。</span><span class="sxs-lookup"><span data-stu-id="63d79-322">This <xref:System.StringComparer> object is returned by the <xref:System.StringComparer.InvariantCulture%2A?displayProperty=nameWithType> property.</span></span>
- <span data-ttu-id="63d79-323">使用不因文化特性而異之字組比較規則的不區分大小寫和文化特性比較。</span><span class="sxs-lookup"><span data-stu-id="63d79-323">Case-insensitive and culture-insensitive comparisons using the word comparison rules of the invariant culture.</span></span> <span data-ttu-id="63d79-324">這個 <xref:System.StringComparer> 物件是由 <xref:System.StringComparer.InvariantCultureIgnoreCase%2A?displayProperty=nameWithType> 屬性傳回。</span><span class="sxs-lookup"><span data-stu-id="63d79-324">This <xref:System.StringComparer> object is returned by the <xref:System.StringComparer.InvariantCultureIgnoreCase%2A?displayProperty=nameWithType> property.</span></span>
- <span data-ttu-id="63d79-325">序數比較。</span><span class="sxs-lookup"><span data-stu-id="63d79-325">Ordinal comparison.</span></span> <span data-ttu-id="63d79-326">這個 <xref:System.StringComparer> 物件是由 <xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType> 屬性傳回。</span><span class="sxs-lookup"><span data-stu-id="63d79-326">This <xref:System.StringComparer> object is returned by the <xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType> property.</span></span>
- <span data-ttu-id="63d79-327">不區分大小寫的序數比較。</span><span class="sxs-lookup"><span data-stu-id="63d79-327">Case-insensitive ordinal comparison.</span></span> <span data-ttu-id="63d79-328">這個 <xref:System.StringComparer> 物件是由 <xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType> 屬性傳回。</span><span class="sxs-lookup"><span data-stu-id="63d79-328">This <xref:System.StringComparer> object is returned by the <xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType> property.</span></span>

### <a name="arraysort-and-arraybinarysearch"></a><span data-ttu-id="63d79-329">Array.Sort 和 Array.BinarySearch</span><span class="sxs-lookup"><span data-stu-id="63d79-329">Array.Sort and Array.BinarySearch</span></span>

<span data-ttu-id="63d79-330">預設解譯： <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="63d79-330">Default interpretation: <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="63d79-331">當您將任何資料儲存在集合中，或從檔案或資料庫將保存的資料讀入集合時，切換目前文化特性會使集合中的非變異失效。</span><span class="sxs-lookup"><span data-stu-id="63d79-331">When you store any data in a collection, or read persisted data from a file or database into a collection, switching the current culture can invalidate the invariants in the collection.</span></span> <span data-ttu-id="63d79-332"><xref:System.Array.BinarySearch%2A?displayProperty=nameWithType> 方法假設要搜尋之陣列中的項目已排序。</span><span class="sxs-lookup"><span data-stu-id="63d79-332">The <xref:System.Array.BinarySearch%2A?displayProperty=nameWithType> method assumes that the elements in the array to be searched are already sorted.</span></span> <span data-ttu-id="63d79-333">若要排序陣列中的任何字串項目， <xref:System.Array.Sort%2A?displayProperty=nameWithType> 方法會呼叫 <xref:System.String.Compare%2A?displayProperty=nameWithType> 方法來排序個別項目。</span><span class="sxs-lookup"><span data-stu-id="63d79-333">To sort any string element in the array, the <xref:System.Array.Sort%2A?displayProperty=nameWithType> method calls the <xref:System.String.Compare%2A?displayProperty=nameWithType> method to order individual elements.</span></span> <span data-ttu-id="63d79-334">從排序陣列到搜尋其內容這段時間當中，如果文化特性變更，則使用區分文化特性的比較子可能會有危險。</span><span class="sxs-lookup"><span data-stu-id="63d79-334">Using a culture-sensitive comparer can be dangerous if the culture changes between the time that the array is sorted and its contents are searched.</span></span> <span data-ttu-id="63d79-335">例如，在下列程式碼中，儲存和擷取作業在 `Thread.CurrentThread.CurrentCulture` 屬性。</span><span class="sxs-lookup"><span data-stu-id="63d79-335">For example, in the following code, storage and retrieval operate on the comparer that is provided implicitly by the `Thread.CurrentThread.CurrentCulture` property.</span></span> <span data-ttu-id="63d79-336">如果文化特性在呼叫 `StoreNames` 和 `DoesNameExist`之間可能變更，尤其是如果陣列內容在這兩個方法呼叫之間保存在某處，則二進位搜尋可能會失敗。</span><span class="sxs-lookup"><span data-stu-id="63d79-336">If the culture can change between the calls to `StoreNames` and `DoesNameExist`, and especially if the array contents are persisted somewhere between the two method calls, the binary search may fail.</span></span>

[!code-csharp[Conceptual.Strings.BestPractices#7](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.bestpractices/cs/indirect1.cs#7)]
 [!code-vb[Conceptual.Strings.BestPractices#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.bestpractices/vb/indirect1.vb#7)]

<span data-ttu-id="63d79-337">下列範例中顯示建議的變化，其中使用相同的序數 (不區分文化特性) 比較方法來排序和搜尋陣列。</span><span class="sxs-lookup"><span data-stu-id="63d79-337">A recommended variation appears in the following example, which uses the same ordinal (culture-insensitive) comparison method both to sort and to search the array.</span></span> <span data-ttu-id="63d79-338">在這兩個範例中，標記為 `Line A` 和 `Line B` 的程式碼行中反映程式碼變更。</span><span class="sxs-lookup"><span data-stu-id="63d79-338">The change code is reflected in the lines labeled `Line A` and `Line B` in the two examples.</span></span>

[!code-csharp[Conceptual.Strings.BestPractices#8](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.bestpractices/cs/indirect1.cs#8)]
[!code-vb[Conceptual.Strings.BestPractices#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.bestpractices/vb/indirect1.vb#8)]

<span data-ttu-id="63d79-339">如果跨文化特性來保存和移動這項資料，且使用排序向使用者呈現這項資料，則您可以考慮使用 <xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType>，這在語言上的表現會提供較佳的使用者輸出，且不受未來文化特性變更所影響。</span><span class="sxs-lookup"><span data-stu-id="63d79-339">If this data is persisted and moved across cultures, and sorting is used to present this data to the user, you might consider using <xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType>, which operates linguistically for better user output but is unaffected by changes in culture.</span></span> <span data-ttu-id="63d79-340">下列範例修改前兩個範例，改用不因國別而異的文化特性來排序和搜尋陣列。</span><span class="sxs-lookup"><span data-stu-id="63d79-340">The following example modifies the two previous examples to use the invariant culture for sorting and searching the array.</span></span>

[!code-csharp[Conceptual.Strings.BestPractices#9](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.bestpractices/cs/indirect1.cs#9)]
[!code-vb[Conceptual.Strings.BestPractices#9](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.bestpractices/vb/indirect1.vb#9)]

### <a name="collections-example-hashtable-constructor"></a><span data-ttu-id="63d79-341">集合範例： Hashtable 函數</span><span class="sxs-lookup"><span data-stu-id="63d79-341">Collections example: Hashtable constructor</span></span>

<span data-ttu-id="63d79-342">第二個受到字串比較方式而影響作業的範例是雜湊字串。</span><span class="sxs-lookup"><span data-stu-id="63d79-342">Hashing strings provides a second example of an operation that is affected by the way in which strings are compared.</span></span>

<span data-ttu-id="63d79-343">下列範例將 <xref:System.Collections.Hashtable> 屬性所傳回的 <xref:System.StringComparer> 物件傳遞至 <xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType> 物件，以將後者物件執行個體化。</span><span class="sxs-lookup"><span data-stu-id="63d79-343">The following example instantiates a <xref:System.Collections.Hashtable> object by passing it the <xref:System.StringComparer> object that is returned by the <xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="63d79-344">因為衍生自 <xref:System.StringComparer> 的類別 <xref:System.StringComparer> 實作 <xref:System.Collections.IEqualityComparer> 介面，所以其 <xref:System.Collections.IEqualityComparer.GetHashCode%2A> 方法會用於計算雜湊資料表中之字串的雜湊程式碼。</span><span class="sxs-lookup"><span data-stu-id="63d79-344">Because a class <xref:System.StringComparer> that is derived from <xref:System.StringComparer> implements the <xref:System.Collections.IEqualityComparer> interface, its <xref:System.Collections.IEqualityComparer.GetHashCode%2A> method is used to compute the hash code of strings in the hash table.</span></span>

[!code-csharp[Conceptual.Strings.BestPractices#10](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.bestpractices/cs/indirect2.cs#10)]
[!code-vb[Conceptual.Strings.BestPractices#10](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.bestpractices/vb/indirect2.vb#10)]

## <a name="see-also"></a><span data-ttu-id="63d79-345">請參閱</span><span class="sxs-lookup"><span data-stu-id="63d79-345">See also</span></span>

- [<span data-ttu-id="63d79-346">.NET 應用程式中的全球化</span><span class="sxs-lookup"><span data-stu-id="63d79-346">Globalization in .NET apps</span></span>](../globalization-localization/globalization.md)
