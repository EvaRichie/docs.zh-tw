---
title: 正則運算式行為
ms.date: 03/30/2017
ms.topic: conceptual
dev_langs:
- csharp
- vb
helpviewer_keywords:
- regular expressions, behavior
- .NET regular expressions, behavior
ms.assetid: 0ee1a6b8-caac-41d2-917f-d35570021b10
ms.openlocfilehash: 4007813f2c40c78e3b5e426bed39ac6b6f3747bf
ms.sourcegitcommit: 4313614f57690f9a5119a37314f0a1fd738ebda2
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/22/2021
ms.locfileid: "98692977"
---
# <a name="details-of-regular-expression-behavior"></a><span data-ttu-id="8c9ff-102">規則運算式行為的詳細資訊</span><span class="sxs-lookup"><span data-stu-id="8c9ff-102">Details of regular expression behavior</span></span>

<span data-ttu-id="8c9ff-103">.NET 規則運算式引擎是回溯規則運算式比對器，它結合了傳統的非決定性有限自動化 (NFA) 引擎，例如 Perl、Python、Emacs 和 Tcl 所使用的引擎。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-103">The .NET regular expression engine is a backtracking regular expression matcher that incorporates a traditional Nondeterministic Finite Automaton (NFA) engine such as that used by Perl, Python, Emacs, and Tcl.</span></span> <span data-ttu-id="8c9ff-104">這使得它與較快速、但限制較多的純規則運算式決定性有限自動化 (DFA) 引擎有所區別，例如 awk、egrep 或 lex 中的引擎。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-104">This distinguishes it from faster, but more limited, pure regular expression Deterministic Finite Automaton (DFA) engines such as those found in awk, egrep, or lex.</span></span> <span data-ttu-id="8c9ff-105">這也和標準的但較緩慢的 POSIX NFA 有差異。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-105">This also distinguishes it from standardized, but slower, POSIX NFAs.</span></span> <span data-ttu-id="8c9ff-106">下節描述三種規則運算式引擎，並且說明在 .NET 中為何使用傳統 NFA 引擎來實作規則運算式。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-106">The following section describes the three types of regular expression engines, and explains why regular expressions in .NET are implemented by using a traditional NFA engine.</span></span>

## <a name="benefits-of-the-nfa-engine"></a><span data-ttu-id="8c9ff-107">NFA 引擎的優點</span><span class="sxs-lookup"><span data-stu-id="8c9ff-107">Benefits of the NFA engine</span></span>

 <span data-ttu-id="8c9ff-108">當 DFA 引擎執行模式比對時，其處理順序是由輸入字串所驅動。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-108">When DFA engines perform pattern matching, their processing order is driven by the input string.</span></span> <span data-ttu-id="8c9ff-109">引擎會從輸入字串的開頭開始執行，並循序地繼續判斷下一個字元是否符合規則運算式模式。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-109">The engine begins at the beginning of the input string and proceeds sequentially to determine whether the next character matches the regular expression pattern.</span></span> <span data-ttu-id="8c9ff-110">它們可以保證比對可能最長的字串。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-110">They can guarantee to match the longest string possible.</span></span> <span data-ttu-id="8c9ff-111">因為 DFA 引擎絕不會測試相同的字元兩次，所以不支援回溯。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-111">Because they never test the same character twice, DFA engines do not support backtracking.</span></span> <span data-ttu-id="8c9ff-112">但因為 DFA 引擎只包含有限狀態，它不能以反向參考比對模式，並且因為它不建構明確的展開，所以不能擷取子運算式。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-112">However, because a DFA engine contains only finite state, it cannot match a pattern with backreferences, and because it does not construct an explicit expansion, it cannot capture subexpressions.</span></span>

 <span data-ttu-id="8c9ff-113">和 DFA 引擎不同，傳統 NFA 引擎在執行模式比對時，其處理順序是由規則運算式模式所驅動。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-113">Unlike DFA engines, when traditional NFA engines perform pattern matching, their processing order is driven by the regular expression pattern.</span></span> <span data-ttu-id="8c9ff-114">在處理某特定 language 元素時，引擎會使用 Greedy (窮盡) 比對，亦即盡可能比對輸入字串的最多內容。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-114">As it processes a particular language element, the engine uses greedy matching; that is, it matches as much of the input string as it possibly can.</span></span> <span data-ttu-id="8c9ff-115">但是，它也會在成功比對子運算式之後儲存其狀態。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-115">But it also saves its state after successfully matching a subexpression.</span></span> <span data-ttu-id="8c9ff-116">如果比對最終失敗，此引擎可以回到儲存的狀態，以便嘗試其他比對。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-116">If a match eventually fails, the engine can return to a saved state so it can try additional matches.</span></span> <span data-ttu-id="8c9ff-117">放棄成功的子運算式比對，以便還能比對規則運算式中後續的語言元素，這個程序稱為「回溯」。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-117">This process of abandoning a successful subexpression match so that later language elements in the regular expression can also match is known as *backtracking*.</span></span> <span data-ttu-id="8c9ff-118">NFA 引擎會使用回溯依特定順序測試規則運算式的所有可能展開，並接受第一個符合項目。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-118">NFA engines use backtracking to test all possible expansions of a regular expression in a specific order and accept the first match.</span></span> <span data-ttu-id="8c9ff-119">因為傳統 NFA 引擎會為成功的比對建構規則運算式的特定展開，所以可以擷取子運算式符合項目和比對的反向參考。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-119">Because a traditional NFA engine constructs a specific expansion of the regular expression for a successful match, it can capture subexpression matches and matching backreferences.</span></span> <span data-ttu-id="8c9ff-120">但因為傳統 NFA 會回溯，所以可多次造訪相同的狀態，如果此狀態是經由不同的路徑到達。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-120">However, because a traditional NFA backtracks, it can visit the same state multiple times if it arrives at the state over different paths.</span></span> <span data-ttu-id="8c9ff-121">結果最壞的情況是，它可以指數方式緩慢執行。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-121">As a result, it can run exponentially slowly in the worst case.</span></span> <span data-ttu-id="8c9ff-122">因為傳統 NFA 引擎接受找到的第一個符合項目，所以也可能發現不了其他 (可能是更長的) 符合項目。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-122">Because a traditional NFA engine accepts the first match it finds, it can also leave other (possibly longer) matches undiscovered.</span></span>

 <span data-ttu-id="8c9ff-123">POSIX NFA 引擎很像傳統 NFA 引擎，只是它們會繼續回溯直到能夠保證已經找到最長的可能符合項目。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-123">POSIX NFA engines are like traditional NFA engines, except that they continue to backtrack until they can guarantee that they have found the longest match possible.</span></span> <span data-ttu-id="8c9ff-124">結果，POSIX NFA 引擎比傳統 NFA 引擎更緩慢，而且當您使用 POSIX NFA 引擎時，您不能變更回溯搜尋的順序，讓較短的符合項目優先於較長的符合項目。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-124">As a result, a POSIX NFA engine is slower than a traditional NFA engine, and when you use a POSIX NFA engine, you cannot favor a shorter match over a longer one by changing the order of the backtracking search.</span></span>

 <span data-ttu-id="8c9ff-125">程式設計人員偏愛傳統 NFA 引擎，因為它們比 DFA 或 POSIX NFA 引擎更能夠掌控字串比對。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-125">Traditional NFA engines are favored by programmers because they offer greater control over string matching than either DFA or POSIX NFA engines.</span></span> <span data-ttu-id="8c9ff-126">雖然最壞的情況是它們可能執行緩慢，但您可以使用減低模稜兩可並限制回溯的模式，操縱它們以線性或多項式時間尋找符合項目。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-126">Although, in the worst case, they can run slowly, you can steer them to find matches in linear or polynomial time by using patterns that reduce ambiguities and limit backtracking.</span></span> <span data-ttu-id="8c9ff-127">換句話說，雖然 NFA 引擎能以強大的能力和彈性獲得效能，但在大部分情況下，如果正則運算式是妥善撰寫的，並可避免回溯以指數方式降低效能的情況，就能提供良好的效能。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-127">In other words, although NFA engines trade performance for power and flexibility, in most cases they offer good to acceptable performance if a regular expression is well written and avoids cases in which backtracking degrades performance exponentially.</span></span>

> [!NOTE]
> <span data-ttu-id="8c9ff-128">如需大量回溯所造成效能影響的詳細資訊，以及撰寫規則運算式來解決問題的方式，請參閱[回溯](backtracking-in-regular-expressions.md)。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-128">For information about the performance penalty caused by excessive backtracking and ways to craft a regular expression to work around them, see [Backtracking](backtracking-in-regular-expressions.md).</span></span>

## <a name="net-engine-capabilities"></a><span data-ttu-id="8c9ff-129">.NET 引擎功能</span><span class="sxs-lookup"><span data-stu-id="8c9ff-129">.NET engine capabilities</span></span>

 <span data-ttu-id="8c9ff-130">為利用傳統 NFA 引擎的優點，.NET 規則運算式引擎包含了完整的建構集合，讓程式設計人員可以操縱回溯引擎。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-130">To take advantage of the benefits of a traditional NFA engine, the .NET regular expression engine includes a complete set of constructs to enable programmers to steer the backtracking engine.</span></span> <span data-ttu-id="8c9ff-131">這些建構可用於更快速尋找符合項目，或讓特定展開優先於其他展開。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-131">These constructs can be used to find matches faster or to favor specific expansions over others.</span></span>

 <span data-ttu-id="8c9ff-132">.NET 規則運算式引擎包含下列其他功能：</span><span class="sxs-lookup"><span data-stu-id="8c9ff-132">Other features of the .NET regular expression engine include the following:</span></span>

- <span data-ttu-id="8c9ff-133">延遲數量詞： `??` 、 `*?` 、 `+?` 、 `{` *n* `,` *m* `}?` 。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-133">Lazy quantifiers: `??`, `*?`, `+?`, `{`*n*`,`*m*`}?`.</span></span> <span data-ttu-id="8c9ff-134">這些建構告訴回溯引擎要先搜尋最小數目的重複。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-134">These constructs tell the backtracking engine to search the minimum number of repetitions first.</span></span> <span data-ttu-id="8c9ff-135">相反地，一般 Greedy (窮盡) 數量詞會先嘗試比對最多的重複 項目。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-135">In contrast, ordinary greedy quantifiers try to match the maximum number of repetitions first.</span></span> <span data-ttu-id="8c9ff-136">下例會說明兩者間的差異。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-136">The following example illustrates the difference between the two.</span></span> <span data-ttu-id="8c9ff-137">規則運算式會比對以數字結尾的句子，以及用來擷取該數字的擷取群組。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-137">A regular expression matches a sentence that ends in a number, and a capturing group is intended to extract that number.</span></span> <span data-ttu-id="8c9ff-138">規則運算式 `.+(\d+)\.` 包含 Greedy (窮盡) 數量詞 `.+`，這導致規則運算式引擎只會擷取數字的最後一個位數。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-138">The regular expression `.+(\d+)\.` includes the greedy quantifier `.+`, which causes the regular expression engine to capture only the last digit of the number.</span></span> <span data-ttu-id="8c9ff-139">相反地，規則運算式 `.+?(\d+)\.` 包含 Lazy (最少) 數量詞 `.+?`，這導致規則運算式引擎會擷取整個數字。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-139">In contrast, the regular expression `.+?(\d+)\.` includes the lazy quantifier `.+?`, which causes the regular expression engine to capture the entire number.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lazy1.cs#1)]
     [!code-vb[Conceptual.RegularExpressions.Design#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lazy1.vb#1)]

     <span data-ttu-id="8c9ff-140">此規則運算式的 Greedy (窮盡) 和 Lazy (最少) 版本定義如下表所示：</span><span class="sxs-lookup"><span data-stu-id="8c9ff-140">The greedy and lazy versions of this regular expression are defined as shown in the following table:</span></span>

    |<span data-ttu-id="8c9ff-141">模式</span><span class="sxs-lookup"><span data-stu-id="8c9ff-141">Pattern</span></span>|<span data-ttu-id="8c9ff-142">描述</span><span class="sxs-lookup"><span data-stu-id="8c9ff-142">Description</span></span>|
    |-------------|-----------------|
    |<span data-ttu-id="8c9ff-143">`.+` (Greedy (窮盡) 數量詞)</span><span class="sxs-lookup"><span data-stu-id="8c9ff-143">`.+` (greedy quantifier)</span></span>|<span data-ttu-id="8c9ff-144">比對至少出現一次的任何字元。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-144">Match at least one occurrence of any character.</span></span> <span data-ttu-id="8c9ff-145">這會導致規則運算式引擎比對整個字串，然後視需要進行回溯，以比對模式的其餘部分。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-145">This causes the regular expression engine to match the entire string, and then to backtrack as needed to match the remainder of the pattern.</span></span>|
    |<span data-ttu-id="8c9ff-146">`.+?` (Lazy (最少) 數量詞)</span><span class="sxs-lookup"><span data-stu-id="8c9ff-146">`.+?` (lazy quantifier)</span></span>|<span data-ttu-id="8c9ff-147">出現的任何字元至少比對一次，但比對愈少愈好。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-147">Match at least one occurrence of any character, but match as few as possible.</span></span>|
    |`(\d+)`|<span data-ttu-id="8c9ff-148">比對至少一個數值字元，並將它指派給第一個擷取群組。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-148">Match at least one numeric character, and assign it to the first capturing group.</span></span>|
    |`\.`|<span data-ttu-id="8c9ff-149">比對句點。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-149">Match a period.</span></span>|

     <span data-ttu-id="8c9ff-150">如需 Lazy (最少) 數量詞的詳細資訊，請參閱[數量詞](quantifiers-in-regular-expressions.md)。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-150">For more information about lazy quantifiers, see [Quantifiers](quantifiers-in-regular-expressions.md).</span></span>

- <span data-ttu-id="8c9ff-151">正面的右合： `(?=` *子運算式* `)` 。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-151">Positive lookahead: `(?=`*subexpression*`)`.</span></span> <span data-ttu-id="8c9ff-152">此功能允許回溯引擎在比對子運算式之後返回到文字的相同地方。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-152">This feature allows the backtracking engine to return to the same spot in the text after matching a subexpression.</span></span> <span data-ttu-id="8c9ff-153">這對自相同位置開始驗證多個模式，以全面搜尋文字，很有用處。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-153">It is useful for searching throughout the text by verifying multiple patterns that start from the same position.</span></span> <span data-ttu-id="8c9ff-154">它也可以讓引擎驗證子字串是否存在於符合項目的結尾，而不需在相符的文字中包含該子字串。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-154">It also allows the engine to verify that a substring exists at the end of the match without including the substring in the matched text.</span></span> <span data-ttu-id="8c9ff-155">下例使用右合樣在句子中擷取後面未接標點符號的文字。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-155">The following example uses positive lookahead to extract the words in a sentence that are not followed by punctuation symbols.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lookahead1.cs#2)]
     [!code-vb[Conceptual.RegularExpressions.Design#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lookahead1.vb#2)]

     <span data-ttu-id="8c9ff-156">規則運算式 `\b[A-Z]+\b(?=\P{P})` 的定義如下表所示。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-156">The regular expression `\b[A-Z]+\b(?=\P{P})` is defined as shown in the following table.</span></span>

    |<span data-ttu-id="8c9ff-157">模式</span><span class="sxs-lookup"><span data-stu-id="8c9ff-157">Pattern</span></span>|<span data-ttu-id="8c9ff-158">描述</span><span class="sxs-lookup"><span data-stu-id="8c9ff-158">Description</span></span>|
    |-------------|-----------------|
    |`\b`|<span data-ttu-id="8c9ff-159">開始字緣比對。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-159">Begin the match at a word boundary.</span></span>|
    |`[A-Z]+`|<span data-ttu-id="8c9ff-160">比對任何字母字元一或多次。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-160">Match any alphabetic character one or more times.</span></span> <span data-ttu-id="8c9ff-161">因為 <xref:System.Text.RegularExpressions.Regex.Matches%2A?displayProperty=nameWithType> 方法會使用 <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> 選項來呼叫，所以，比較不會區分大小寫。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-161">Because the <xref:System.Text.RegularExpressions.Regex.Matches%2A?displayProperty=nameWithType> method is called with the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> option, the comparison is case-insensitive.</span></span>|
    |`\b`|<span data-ttu-id="8c9ff-162">結束字緣比對。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-162">End the match at a word boundary.</span></span>|
    |`(?=\P{P})`|<span data-ttu-id="8c9ff-163">向右合樣以判斷下一個字元是否為標點符號。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-163">Look ahead to determine whether the next character is a punctuation symbol.</span></span> <span data-ttu-id="8c9ff-164">如果不是，則比對成功。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-164">If it is not, the match succeeds.</span></span>|

     <span data-ttu-id="8c9ff-165">如需右合樣判斷提示的詳細資訊，請參閱[群組建構](grouping-constructs-in-regular-expressions.md)。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-165">For more information about positive lookahead assertions, see [Grouping Constructs](grouping-constructs-in-regular-expressions.md).</span></span>

- <span data-ttu-id="8c9ff-166">右合樣： `(?!` *子運算式* `)` 。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-166">Negative lookahead: `(?!`*subexpression*`)`.</span></span> <span data-ttu-id="8c9ff-167">此功能加入了只有子運算式無法比對時才會比對運算式的功能。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-167">This feature adds the ability to match an expression only if a subexpression fails to match.</span></span> <span data-ttu-id="8c9ff-168">這項功能對於剪除搜尋很強大，因為提供的運算式通常會比必須包含的案例運算式更簡單。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-168">This is powerful for pruning a search, because it is often simpler to provide an expression for a case that should be eliminated than an expression for cases that must be included.</span></span> <span data-ttu-id="8c9ff-169">例如，針對開頭不是 "non" 的單字撰寫運算式很困難。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-169">For example, it is difficult to write an expression for words that do not begin with "non".</span></span> <span data-ttu-id="8c9ff-170">下例使用右不合樣進行排除。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-170">The following example uses negative lookahead to exclude them.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lookahead2.cs#3)]
     [!code-vb[Conceptual.RegularExpressions.Design#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lookahead2.vb#3)]

     <span data-ttu-id="8c9ff-171">規則運算式模式 `\b(?!non)\w+\b` 的定義如下表所示。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-171">The regular expression pattern `\b(?!non)\w+\b` is defined as shown in the following table.</span></span>

    |<span data-ttu-id="8c9ff-172">模式</span><span class="sxs-lookup"><span data-stu-id="8c9ff-172">Pattern</span></span>|<span data-ttu-id="8c9ff-173">描述</span><span class="sxs-lookup"><span data-stu-id="8c9ff-173">Description</span></span>|
    |-------------|-----------------|
    |`\b`|<span data-ttu-id="8c9ff-174">開始字緣比對。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-174">Begin the match at a word boundary.</span></span>|
    |`(?!non)`|<span data-ttu-id="8c9ff-175">向右合樣以確定目前的字串不是以 "non" 開頭。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-175">Look ahead to ensure that the current string does not begin with "non".</span></span> <span data-ttu-id="8c9ff-176">如果是，則比對失敗。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-176">If it does, the match fails.</span></span>|
    |`(\w+)`|<span data-ttu-id="8c9ff-177">比對一個或多個文字字元。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-177">Match one or more word characters.</span></span>|
    |`\b`|<span data-ttu-id="8c9ff-178">結束字緣比對。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-178">End the match at a word boundary.</span></span>|

     <span data-ttu-id="8c9ff-179">如需右不合樣判斷提示的詳細資訊，請參閱[群組建構](grouping-constructs-in-regular-expressions.md)。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-179">For more information about negative lookahead assertions, see [Grouping Constructs](grouping-constructs-in-regular-expressions.md).</span></span>

- <span data-ttu-id="8c9ff-180">條件式評估： `(?(` *expression* `)` *yes* `|` *否* `)` ， `(?(` *name* `)` *yes 是* `|` *no* `)` ，其中 *expression* 是要比對的子運算式， *name* 是捕捉群組的名稱， *yes* 是符合 *運算式* 的字串，或者 *name* 是有效的非空白的已捕捉群組，而 *no* 是不符合的 *運算式* 或 *名稱* 不是有效、非空白的已捕獲群組時要比對的子運算式。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-180">Conditional evaluation: `(?(`*expression*`)`*yes*`|`*no*`)` and `(?(`*name*`)`*yes*`|`*no*`)`, where *expression* is a subexpression to match, *name* is the name of a capturing group, *yes* is the string to match if *expression* is matched or *name* is a valid, non-empty captured group, and *no* is the subexpression to match if *expression* is not matched or *name* is not a valid, non-empty captured group.</span></span> <span data-ttu-id="8c9ff-181">此功能可讓引擎根據前一個子運算式比對的結果或零寬度判斷提示的結果，使用一個以上的替代模式進行搜尋。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-181">This feature allows the engine to search by using more than one alternate pattern, depending on the result of a previous subexpression match or the result of a zero-width assertion.</span></span> <span data-ttu-id="8c9ff-182">這允許更強大的反向參考形式，例如允許根據前一個子運算式是否相符來比對子運算式。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-182">This allows a more powerful form of backreference that permits, for example, matching a subexpression based on whether a previous subexpression was matched.</span></span> <span data-ttu-id="8c9ff-183">下例中的規則運算式會比對同時可供公用和內部使用的段落。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-183">The regular expression in the following example matches paragraphs that are intended for both public and internal use.</span></span> <span data-ttu-id="8c9ff-184">僅供內部使用的段落會以 `<PRIVATE>` 標記開頭。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-184">Paragraphs intended only for internal use begin with a `<PRIVATE>` tag.</span></span> <span data-ttu-id="8c9ff-185">規則運算式模式 `^(?<Pvt>\<PRIVATE\>\s)?(?(Pvt)((\w+\p{P}?\s)+)|((\w+\p{P}?\s)+))\r?$` 會使用條件式評估，將可供公用和內部使用的段落內容指派給個別的擷取群組。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-185">The regular expression pattern `^(?<Pvt>\<PRIVATE\>\s)?(?(Pvt)((\w+\p{P}?\s)+)|((\w+\p{P}?\s)+))\r?$` uses conditional evaluation to assign the contents of paragraphs intended for public and for internal use to separate capturing groups.</span></span> <span data-ttu-id="8c9ff-186">再以不同的方式來處理這些段落。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-186">These paragraphs can then be handled differently.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/conditional1.cs#4)]
     [!code-vb[Conceptual.RegularExpressions.Design#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/conditional1.vb#4)]

     <span data-ttu-id="8c9ff-187">規則運算式模式的定義如下表所示。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-187">The regular expression pattern is defined as shown in the following table.</span></span>

    |<span data-ttu-id="8c9ff-188">模式</span><span class="sxs-lookup"><span data-stu-id="8c9ff-188">Pattern</span></span>|<span data-ttu-id="8c9ff-189">描述</span><span class="sxs-lookup"><span data-stu-id="8c9ff-189">Description</span></span>|
    |-------------|-----------------|
    |`^`|<span data-ttu-id="8c9ff-190">在一行的開頭開始比對。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-190">Begin the match at the beginning of a line.</span></span>|
    |`(?<Pvt>\<PRIVATE\>\s)?`|<span data-ttu-id="8c9ff-191">比對出現零次或一次且後面接著空白字元的字串 `<PRIVATE>`。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-191">Match zero or one occurrence of the string `<PRIVATE>` followed by a white-space character.</span></span> <span data-ttu-id="8c9ff-192">將相符項目指派給名為 `Pvt` 的擷取群組。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-192">Assign the match to a capturing group named `Pvt`.</span></span>|
    |`(?(Pvt)((\w+\p{P}?\s)+)`|<span data-ttu-id="8c9ff-193">如果 `Pvt` 擷取群組存在，則比對出現一或多次的一或多個單字字元，且該字元後面接著零或一個標點分隔符號和一個空白字元。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-193">If the `Pvt` capturing group exists, match one or more occurrences of one or more word characters followed by zero or one punctuation separator followed by a white-space character.</span></span> <span data-ttu-id="8c9ff-194">將子字串指派給第一個擷取群組。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-194">Assign the substring to the first capturing group.</span></span>|
    |<code>&#124;((\w+\p{P}?\s)+))</code>|<span data-ttu-id="8c9ff-195">如果 `Pvt` 擷取群組不存在，則比對出現一或多次的一或多個單字字元，且該字元後面接著零或一個標點分隔符號和一個空白字元。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-195">If the `Pvt` capturing group does not exist, match one or more occurrences of one or more word characters followed by zero or one punctuation separator followed by a white-space character.</span></span> <span data-ttu-id="8c9ff-196">將子字串指派給第三個擷取群組。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-196">Assign the substring to the third capturing group.</span></span>|
    |`\r?$`|<span data-ttu-id="8c9ff-197">比對行尾或字串結尾。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-197">Match the end of a line or the end of the string.</span></span>|

     <span data-ttu-id="8c9ff-198">如需條件式評估的詳細資訊，請參閱[替代建構](alternation-constructs-in-regular-expressions.md)。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-198">For more information about conditional evaluation, see [Alternation Constructs](alternation-constructs-in-regular-expressions.md).</span></span>

- <span data-ttu-id="8c9ff-199">平衡群組定義： `(?<` *name1* `-` *name2* `>` *子運算式* `)` 。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-199">Balancing group definitions: `(?<`*name1*`-`*name2*`>` *subexpression*`)`.</span></span> <span data-ttu-id="8c9ff-200">此功能可讓規則運算式引擎追蹤巢狀建構，例如括號或左右中括弧。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-200">This feature allows the regular expression engine to keep track of nested constructs such as parentheses or opening and closing brackets.</span></span> <span data-ttu-id="8c9ff-201">如需範例，請參閱[群組建構](grouping-constructs-in-regular-expressions.md)。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-201">For an example, see [Grouping Constructs](grouping-constructs-in-regular-expressions.md).</span></span>

- <span data-ttu-id="8c9ff-202">不可部分完成的群組： `(?>` *子運算式* `)` 。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-202">Atomic groups: `(?>`*subexpression*`)`.</span></span> <span data-ttu-id="8c9ff-203">此功能可讓回溯引擎保證子運算式只比對為該子運算式找到的第一個相符項目，就好像運算式的執行不受其包含運算式的影響。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-203">This feature allows the backtracking engine to guarantee that a subexpression matches only the first match found for that subexpression, as if the expression were running independent of its containing expression.</span></span> <span data-ttu-id="8c9ff-204">如果不使用此建構，較大型運算式中的回溯搜尋可以變更子運算式的行為。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-204">If you do not use this construct, backtracking searches from the larger expression can change the behavior of a subexpression.</span></span> <span data-ttu-id="8c9ff-205">例如，正則運算式會 `(a+)\w` 比對一或多個 "a" 字元，以及在 "a" 字元序列後面的單字字元，並將 "a" 字元的序列指派給第一個捕獲群組。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-205">For example, the regular expression `(a+)\w` matches one or more "a" characters, along with a word character that follows the sequence of "a" characters, and assigns the sequence of "a" characters to the first capturing group.</span></span> <span data-ttu-id="8c9ff-206">但是，如果輸入字串的最後一個字元也是 "a"，它就會由 language 元素比對， `\w` 而且不會包含在被捕獲的群組中。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-206">However, if the final character of the input string is also an "a", it is matched by the `\w` language element and is not included in the captured group.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#7](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/nonbacktracking2.cs#7)]
     [!code-vb[Conceptual.RegularExpressions.Design#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/nonbacktracking2.vb#7)]

     <span data-ttu-id="8c9ff-207">規則運算式 `((?>a+))\w` 可防止此行為發生。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-207">The regular expression `((?>a+))\w` prevents this behavior.</span></span> <span data-ttu-id="8c9ff-208">因為不需要回溯，所有連續的 "a" 字元便已相符，所以第一個擷取群組會包含所有連續的 "a" 字元。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-208">Because all consecutive "a" characters are matched without backtracking, the first capturing group includes all consecutive "a" characters.</span></span> <span data-ttu-id="8c9ff-209">如果 "a" 字元後面未再接著至少一個 "a" 以外的字元，則比對失敗。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-209">If the "a" characters are not followed by at least one more character other than "a", the match fails.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#8](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/nonbacktracking1.cs#8)]
     [!code-vb[Conceptual.RegularExpressions.Design#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/nonbacktracking1.vb#8)]

     <span data-ttu-id="8c9ff-210">如需不可部分完成群組的詳細資訊，請參閱 [群組結構](grouping-constructs-in-regular-expressions.md)。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-210">For more information about atomic groups, see [Grouping Constructs](grouping-constructs-in-regular-expressions.md).</span></span>

- <span data-ttu-id="8c9ff-211">從右至左比對，將 <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> 選項提供給 <xref:System.Text.RegularExpressions.Regex> 類別建構函式或靜態執行個體比對方法，即可指定此種比對。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-211">Right-to-left matching, which is specified by supplying the <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> option to a <xref:System.Text.RegularExpressions.Regex> class constructor or static instance matching method.</span></span> <span data-ttu-id="8c9ff-212">當從右至左搜尋取代從左至右搜尋時，或在從右邊部分 (而非自左邊) 開始比對模式較有效率的情況中，這項功能很有用處。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-212">This feature is useful when searching from right to left instead of from left to right, or in cases where it is more efficient to begin a match at the right part of the pattern instead of the left.</span></span> <span data-ttu-id="8c9ff-213">如下例所示，使用由右至左比對會變更 Greedy (窮盡) 數量詞的行為。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-213">As the following example illustrates, using right-to-left matching can change the behavior of greedy quantifiers.</span></span> <span data-ttu-id="8c9ff-214">此範例會搜尋兩次以數字結尾的句子。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-214">The example conducts two searches for a sentence that ends in a number.</span></span> <span data-ttu-id="8c9ff-215">使用 Greedy (窮盡) 數量詞 `+` 的由左至右搜尋，會比對句子中的六個數字其中一個，而由右至左搜尋會比對全部六個數字。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-215">The left-to-right search that uses the greedy quantifier `+` matches one of the six digits in the sentence, whereas the right-to-left search matches all six digits.</span></span> <span data-ttu-id="8c9ff-216">如需正則運算式模式的描述，請參閱本章節稍早說明的延遲數量詞的範例。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-216">For a description of the regular expression pattern, see the example that illustrates lazy quantifiers earlier in this section.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#6](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/rtl1.cs#6)]
     [!code-vb[Conceptual.RegularExpressions.Design#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/rtl1.vb#6)]

     <span data-ttu-id="8c9ff-217">如需從右至左比對的詳細資訊，請參閱 [正則運算式選項](regular-expression-options.md)。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-217">For more information about right-to-left matching, see [Regular Expression Options](regular-expression-options.md).</span></span>

- <span data-ttu-id="8c9ff-218">正向左合樣：正向左合樣 `(?<=` 的 *子運算式* `)` ，以及反樣樣 `(?<!` 的 *子運算式* `)` 。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-218">Positive and negative lookbehind: `(?<=`*subexpression*`)` for positive lookbehind, and `(?<!`*subexpression*`)` for negative lookbehind.</span></span> <span data-ttu-id="8c9ff-219">此功能類似於本主題前文中所討論的向右合樣。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-219">This feature is similar to lookahead, which is discussed earlier in this topic.</span></span> <span data-ttu-id="8c9ff-220">因為規則運算式引擎允許完整的由右至左比對，規則運算式允許無限制的向左合樣。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-220">Because the regular expression engine allows complete right-to-left matching, regular expressions allow unrestricted lookbehinds.</span></span> <span data-ttu-id="8c9ff-221">當巢狀子運算式為外部運算式的超集時，左合樣和左不合樣也可以用來避免產生巢狀數量詞。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-221">Positive and negative lookbehind can also be used to avoid nesting quantifiers when the nested subexpression is a superset of an outer expression.</span></span> <span data-ttu-id="8c9ff-222">具有此種巢狀數量詞的規則運算式通常效能不佳。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-222">Regular expressions with such nested quantifiers often offer poor performance.</span></span> <span data-ttu-id="8c9ff-223">例如，下例會驗證字串是否以英數字元開頭和結尾，以及字串中的任何其他字元是否為較大子集之一。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-223">For example, the following example verifies that a string begins and ends with an alphanumeric character, and that any other character in the string is one of a larger subset.</span></span> <span data-ttu-id="8c9ff-224">它會構成用來驗證電子郵件地址之規則運算式的一部分；如需詳細資訊，請參閱[如何：確認字串是否為有效的電子郵件格式](how-to-verify-that-strings-are-in-valid-email-format.md)。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-224">It forms a portion of the regular expression used to validate email addresses; for more information, see [How to: Verify that Strings Are in Valid Email Format](how-to-verify-that-strings-are-in-valid-email-format.md).</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lookbehind1.cs#5)]
     [!code-vb[Conceptual.RegularExpressions.Design#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lookbehind1.vb#5)]

     <span data-ttu-id="8c9ff-225">規則運算式 ``^[A-Z0-9]([-!#$%&'.*+/=?^`{}|~\w])*(?<=[A-Z0-9])$`` 的定義如下表所示。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-225">The regular expression ``^[A-Z0-9]([-!#$%&'.*+/=?^`{}|~\w])*(?<=[A-Z0-9])$`` is defined as shown in the following table.</span></span>

    |<span data-ttu-id="8c9ff-226">模式</span><span class="sxs-lookup"><span data-stu-id="8c9ff-226">Pattern</span></span>|<span data-ttu-id="8c9ff-227">描述</span><span class="sxs-lookup"><span data-stu-id="8c9ff-227">Description</span></span>|
    |-------------|-----------------|
    |`^`|<span data-ttu-id="8c9ff-228">從字串的開頭開始比對。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-228">Begin the match at the beginning of the string.</span></span>|
    |`[A-Z0-9]`|<span data-ttu-id="8c9ff-229">比對任何數值或英數字元。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-229">Match any numeric or alphanumeric character.</span></span> <span data-ttu-id="8c9ff-230">(此比較不區分大小寫。)</span><span class="sxs-lookup"><span data-stu-id="8c9ff-230">(The comparison is case-insensitive.)</span></span>|
    |<code>([-!#$%&'.*+/=?^\`{}&#124;~\w])\*</code>|<span data-ttu-id="8c9ff-231">比對出現零或多次的任何文字字元，或下列任何字元：-,!, #、$、%、&、'、.、 \* 、+、/、=、？、^、&#96;、{、}、&#124; 或 ~。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-231">Match zero or more occurrences of any word character, or any of the following characters:  -, !, #, $, %, &, ', ., \*, +, /, =, ?, ^, &#96;, {, }, &#124;, or ~.</span></span>|
    |`(?<=[A-Z0-9])`|<span data-ttu-id="8c9ff-232">向左合樣前一個字元，而該字元必須是數值或英數字元。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-232">Look behind to the previous character, which must be numeric or alphanumeric.</span></span> <span data-ttu-id="8c9ff-233">(此比較不區分大小寫。)</span><span class="sxs-lookup"><span data-stu-id="8c9ff-233">(The comparison is case-insensitive.)</span></span>|
    |`$`|<span data-ttu-id="8c9ff-234">在字串的結尾結束比對。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-234">End the match at the end of the string.</span></span>|

     <span data-ttu-id="8c9ff-235">如需左合樣及左不合樣的詳細資訊，請參閱[群組建構](grouping-constructs-in-regular-expressions.md)。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-235">For more information about positive and negative lookbehind, see [Grouping Constructs](grouping-constructs-in-regular-expressions.md).</span></span>

## <a name="related-articles"></a><span data-ttu-id="8c9ff-236">相關文章</span><span class="sxs-lookup"><span data-stu-id="8c9ff-236">Related articles</span></span>

|<span data-ttu-id="8c9ff-237">標題</span><span class="sxs-lookup"><span data-stu-id="8c9ff-237">Title</span></span>|<span data-ttu-id="8c9ff-238">描述</span><span class="sxs-lookup"><span data-stu-id="8c9ff-238">Description</span></span>|
|-----------|-----------------|
|[<span data-ttu-id="8c9ff-239">回溯</span><span class="sxs-lookup"><span data-stu-id="8c9ff-239">Backtracking</span></span>](backtracking-in-regular-expressions.md)|<span data-ttu-id="8c9ff-240">提供規則運算式回溯如何擴展以尋找替代符合項目的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-240">Provides information about how regular expression backtracking branches to find alternative matches.</span></span>|
|[<span data-ttu-id="8c9ff-241">編譯和重複使用</span><span class="sxs-lookup"><span data-stu-id="8c9ff-241">Compilation and Reuse</span></span>](compilation-and-reuse-in-regular-expressions.md)|<span data-ttu-id="8c9ff-242">提供編譯和重複使用規則運算式以提升效能的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-242">Provides information about compiling and reusing regular expressions to increase performance.</span></span>|
|[<span data-ttu-id="8c9ff-243">執行緒安全性</span><span class="sxs-lookup"><span data-stu-id="8c9ff-243">Thread Safety</span></span>](thread-safety-in-regular-expressions.md)|<span data-ttu-id="8c9ff-244">提供規則運算式執行緒安全的相關資訊，並說明何時應該同步處理規則運算式物件的存取。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-244">Provides information about regular expression thread safety and explains when you should synchronize access to regular expression objects.</span></span>|
|[<span data-ttu-id="8c9ff-245">.NET 規則運算式</span><span class="sxs-lookup"><span data-stu-id="8c9ff-245">.NET Regular Expressions</span></span>](regular-expressions.md)|<span data-ttu-id="8c9ff-246">提供規則運算式的程式設計語言方面的概觀。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-246">Provides an overview of the programming language aspect of regular expressions.</span></span>|
|[<span data-ttu-id="8c9ff-247">規則運算式物件模型</span><span class="sxs-lookup"><span data-stu-id="8c9ff-247">The Regular Expression Object Model</span></span>](the-regular-expression-object-model.md)|<span data-ttu-id="8c9ff-248">提供說明規則運算式類別使用方式的資訊和程式碼範例。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-248">Provides information and code examples illustrating how to use the regular expression classes.</span></span>|
|[<span data-ttu-id="8c9ff-249">規則運算式語言 - 快速參考</span><span class="sxs-lookup"><span data-stu-id="8c9ff-249">Regular Expression Language - Quick Reference</span></span>](regular-expression-language-quick-reference.md)|<span data-ttu-id="8c9ff-250">提供您可以用來定義規則運算式之字元、運算子和建構組合的資訊。</span><span class="sxs-lookup"><span data-stu-id="8c9ff-250">Provides information about the set of characters, operators, and constructs that you can use to define regular expressions.</span></span>|

## <a name="reference"></a><span data-ttu-id="8c9ff-251">參考</span><span class="sxs-lookup"><span data-stu-id="8c9ff-251">Reference</span></span>

- <xref:System.Text.RegularExpressions?displayProperty=nameWithType>
