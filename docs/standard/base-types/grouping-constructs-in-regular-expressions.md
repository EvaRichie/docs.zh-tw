---
title: 規則運算式中的群組建構
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- lookbehinds
- regular expressions, grouping constructs
- lookaheads
- .NET Framework regular expressions, grouping constructs
- constructs, grouping
- grouping constructs
ms.assetid: 0fc18634-f590-4062-8d5c-f0b71abe405b
ms.openlocfilehash: 5be98a5a213592b169bee430d84c4fc3a1d5fcef
ms.sourcegitcommit: 33deec3e814238fb18a49b2a7e89278e27888291
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 06/02/2020
ms.locfileid: "84290522"
---
# <a name="grouping-constructs-in-regular-expressions"></a><span data-ttu-id="43f92-102">規則運算式中的群組建構</span><span class="sxs-lookup"><span data-stu-id="43f92-102">Grouping Constructs in Regular Expressions</span></span>
<span data-ttu-id="43f92-103">群組建構會描寫規則運算式的子運算式，以及擷取輸入字串的子字串。</span><span class="sxs-lookup"><span data-stu-id="43f92-103">Grouping constructs delineate the subexpressions of a regular expression and capture the substrings of an input string.</span></span> <span data-ttu-id="43f92-104">您可以使用分組建構來執行下列作業：</span><span class="sxs-lookup"><span data-stu-id="43f92-104">You can use grouping constructs to do the following:</span></span>  
  
- <span data-ttu-id="43f92-105">比對輸入字串中重複的子運算式。</span><span class="sxs-lookup"><span data-stu-id="43f92-105">Match a subexpression that is repeated in the input string.</span></span>  
  
- <span data-ttu-id="43f92-106">將數量詞套用至具有多個規則運算式語言項目的子運算式。</span><span class="sxs-lookup"><span data-stu-id="43f92-106">Apply a quantifier to a subexpression that has multiple regular expression language elements.</span></span> <span data-ttu-id="43f92-107">如需數量詞的詳細資訊，請參閱 [Quantifiers](quantifiers-in-regular-expressions.md)。</span><span class="sxs-lookup"><span data-stu-id="43f92-107">For more information about quantifiers, see [Quantifiers](quantifiers-in-regular-expressions.md).</span></span>  
  
- <span data-ttu-id="43f92-108">在 <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> 和 <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> 方法傳回的字串中包含子運算式。</span><span class="sxs-lookup"><span data-stu-id="43f92-108">Include a subexpression in the string that is returned by the <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> and <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> methods.</span></span>  
  
- <span data-ttu-id="43f92-109">從 <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> 屬性擷取個別子運算式，再全部一起與相符文字分開處理。</span><span class="sxs-lookup"><span data-stu-id="43f92-109">Retrieve individual subexpressions from the <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> property and process them separately from the matched text as a whole.</span></span>  
  
 <span data-ttu-id="43f92-110">下表列出 .NET 規則運算式引擎支援的群組建構，並指出其為擷取或非擷取。</span><span class="sxs-lookup"><span data-stu-id="43f92-110">The following table lists the grouping constructs supported by the .NET regular expression engine and indicates whether they are capturing or non-capturing.</span></span>  
  
|<span data-ttu-id="43f92-111">分組建構</span><span class="sxs-lookup"><span data-stu-id="43f92-111">Grouping construct</span></span>|<span data-ttu-id="43f92-112">擷取或非擷取</span><span class="sxs-lookup"><span data-stu-id="43f92-112">Capturing or noncapturing</span></span>|  
|------------------------|-------------------------------|  
|[<span data-ttu-id="43f92-113">相符子運算式</span><span class="sxs-lookup"><span data-stu-id="43f92-113">Matched subexpressions</span></span>](#matched_subexpression)|<span data-ttu-id="43f92-114">擷取</span><span class="sxs-lookup"><span data-stu-id="43f92-114">Capturing</span></span>|  
|[<span data-ttu-id="43f92-115">具名的相符子運算式</span><span class="sxs-lookup"><span data-stu-id="43f92-115">Named matched subexpressions</span></span>](#named_matched_subexpression)|<span data-ttu-id="43f92-116">擷取</span><span class="sxs-lookup"><span data-stu-id="43f92-116">Capturing</span></span>|  
|[<span data-ttu-id="43f92-117">平衡群組定義</span><span class="sxs-lookup"><span data-stu-id="43f92-117">Balancing group definitions</span></span>](#balancing_group_definition)|<span data-ttu-id="43f92-118">擷取</span><span class="sxs-lookup"><span data-stu-id="43f92-118">Capturing</span></span>|  
|[<span data-ttu-id="43f92-119">非擷取群組</span><span class="sxs-lookup"><span data-stu-id="43f92-119">Noncapturing groups</span></span>](#noncapturing_group)|<span data-ttu-id="43f92-120">非擷取</span><span class="sxs-lookup"><span data-stu-id="43f92-120">Noncapturing</span></span>|  
|[<span data-ttu-id="43f92-121">群組選項</span><span class="sxs-lookup"><span data-stu-id="43f92-121">Group options</span></span>](#group_options)|<span data-ttu-id="43f92-122">非擷取</span><span class="sxs-lookup"><span data-stu-id="43f92-122">Noncapturing</span></span>|  
|[<span data-ttu-id="43f92-123">零寬度右合樣 (Positive Lookahead) 判斷提示</span><span class="sxs-lookup"><span data-stu-id="43f92-123">Zero-width positive lookahead assertions</span></span>](#zerowidth_positive_lookahead_assertion)|<span data-ttu-id="43f92-124">非擷取</span><span class="sxs-lookup"><span data-stu-id="43f92-124">Noncapturing</span></span>|  
|[<span data-ttu-id="43f92-125">零寬度右不合樣 (Negative Lookahead) 判斷提示</span><span class="sxs-lookup"><span data-stu-id="43f92-125">Zero-width negative lookahead assertions</span></span>](#zerowidth_negative_lookahead_assertion)|<span data-ttu-id="43f92-126">非擷取</span><span class="sxs-lookup"><span data-stu-id="43f92-126">Noncapturing</span></span>|  
|[<span data-ttu-id="43f92-127">零寬度左合樣 (Positive Lookbehind) 判斷提示</span><span class="sxs-lookup"><span data-stu-id="43f92-127">Zero-width positive lookbehind assertions</span></span>](#zerowidth_positive_lookbehind_assertion)|<span data-ttu-id="43f92-128">非擷取</span><span class="sxs-lookup"><span data-stu-id="43f92-128">Noncapturing</span></span>|  
|[<span data-ttu-id="43f92-129">零寬度左不合樣 (Negative Lookbehind) 判斷提示</span><span class="sxs-lookup"><span data-stu-id="43f92-129">Zero-width negative lookbehind assertions</span></span>](#zerowidth_negative_lookbehind_assertion)|<span data-ttu-id="43f92-130">非擷取</span><span class="sxs-lookup"><span data-stu-id="43f92-130">Noncapturing</span></span>|  
|[<span data-ttu-id="43f92-131">不可部分完成的群組</span><span class="sxs-lookup"><span data-stu-id="43f92-131">Atomic groups</span></span>](#atomic_groups)|<span data-ttu-id="43f92-132">非擷取</span><span class="sxs-lookup"><span data-stu-id="43f92-132">Noncapturing</span></span>|  
  
 <span data-ttu-id="43f92-133">如需群組和正則運算式物件模型的詳細資訊，請參閱[群組結構和正則運算式物件](#Objects)。</span><span class="sxs-lookup"><span data-stu-id="43f92-133">For information on groups and the regular expression object model, see [Grouping constructs and regular expression objects](#Objects).</span></span>  
  
<a name="matched_subexpression"></a>
## <a name="matched-subexpressions"></a><span data-ttu-id="43f92-134">相符子運算式</span><span class="sxs-lookup"><span data-stu-id="43f92-134">Matched Subexpressions</span></span>  
 <span data-ttu-id="43f92-135">下列分組建構會擷取相符子運算式：</span><span class="sxs-lookup"><span data-stu-id="43f92-135">The following grouping construct captures a matched subexpression:</span></span>  
  
 <span data-ttu-id="43f92-136"> subexpression`(`\ \** `)`</span><span class="sxs-lookup"><span data-stu-id="43f92-136">`(` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="43f92-137">其中 *subexpression* 是任何有效的規則運算式模式。</span><span class="sxs-lookup"><span data-stu-id="43f92-137">where *subexpression* is any valid regular expression pattern.</span></span> <span data-ttu-id="43f92-138">使用括號的擷取會依據規則運算式中的左括號順序，從一開始，由左至右自動編號。</span><span class="sxs-lookup"><span data-stu-id="43f92-138">Captures that use parentheses are numbered automatically from left to right based on the order of the opening parentheses in the regular expression, starting from one.</span></span> <span data-ttu-id="43f92-139">編號零的擷取是整個規則運算式模式比對的文字。</span><span class="sxs-lookup"><span data-stu-id="43f92-139">The capture that is numbered zero is the text matched by the entire regular expression pattern.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="43f92-140">根據預設， `(` *子運算式* `)` 語言元素會捕捉相符的子運算式。</span><span class="sxs-lookup"><span data-stu-id="43f92-140">By default, the `(`*subexpression*`)` language element captures the matched subexpression.</span></span> <span data-ttu-id="43f92-141">但是如果規則運算式模式比對方法的 <xref:System.Text.RegularExpressions.RegexOptions> 參數包含 <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> 旗標，或這個子運算式套用了 `n` 選項 (請參閱本主題稍後的[群組選項](#group_options))，則不會擷取相符的子運算式。</span><span class="sxs-lookup"><span data-stu-id="43f92-141">But if the <xref:System.Text.RegularExpressions.RegexOptions> parameter of a regular expression pattern matching method includes the <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> flag, or if the `n` option is applied to this subexpression (see [Group options](#group_options) later in this topic), the matched subexpression is not captured.</span></span>  
  
 <span data-ttu-id="43f92-142">您可以用四種方式來存取擷取群組：</span><span class="sxs-lookup"><span data-stu-id="43f92-142">You can access captured groups in four ways:</span></span>  
  
- <span data-ttu-id="43f92-143">在規則運算式中使用反向參考建構。</span><span class="sxs-lookup"><span data-stu-id="43f92-143">By using the backreference construct within the regular expression.</span></span> <span data-ttu-id="43f92-144">使用語法 `\` *number*（其中*number*是所捕獲之子運算式的序號），在相同的正則運算式中參考相符的子運算式。</span><span class="sxs-lookup"><span data-stu-id="43f92-144">The matched subexpression is referenced in the same regular expression by using the syntax `\`*number*, where *number* is the ordinal number of the captured subexpression.</span></span>  
  
- <span data-ttu-id="43f92-145">在規則運算式中使用具名的反向參考建構。</span><span class="sxs-lookup"><span data-stu-id="43f92-145">By using the named backreference construct within the regular expression.</span></span> <span data-ttu-id="43f92-146">使用語法 `\k<` *name* `>` （其中*name*是「捕捉群組」的名稱）或 `\k<` *number* `>` （其中*number*是「捕捉群組」的序號），在相同的正則運算式中參考相符的子運算式。</span><span class="sxs-lookup"><span data-stu-id="43f92-146">The matched subexpression is referenced in the same regular expression by using the syntax `\k<`*name*`>`, where *name* is the name of a capturing group, or `\k<`*number*`>`, where *number* is the ordinal number of a capturing group.</span></span> <span data-ttu-id="43f92-147">擷取群組的預設名稱與其序號相同。</span><span class="sxs-lookup"><span data-stu-id="43f92-147">A capturing group has a default name that is identical to its ordinal number.</span></span> <span data-ttu-id="43f92-148">如需詳細資訊，請參閱本主題稍後的 [具名的相符子運算式](#named_matched_subexpression) 。</span><span class="sxs-lookup"><span data-stu-id="43f92-148">For more information, see [Named matched subexpressions](#named_matched_subexpression) later in this topic.</span></span>  
  
- <span data-ttu-id="43f92-149">在 <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> 或 <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> 方法呼叫中使用 `$`*number* 取代序列，其中 *number* 是所擷取子運算式的序號。</span><span class="sxs-lookup"><span data-stu-id="43f92-149">By using the `$`*number* replacement sequence in a <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> or <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> method call, where *number* is the ordinal number of the captured subexpression.</span></span>  
  
- <span data-ttu-id="43f92-150">以程式設計方式，使用 <xref:System.Text.RegularExpressions.GroupCollection> 屬性傳回的 <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> 物件。</span><span class="sxs-lookup"><span data-stu-id="43f92-150">Programmatically, by using the <xref:System.Text.RegularExpressions.GroupCollection> object returned by the <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="43f92-151">集合中位置為零的成員代表整個規則運算式相符。</span><span class="sxs-lookup"><span data-stu-id="43f92-151">The member at position zero in the collection represents the entire regular expression match.</span></span> <span data-ttu-id="43f92-152">每個後續成員各代表一個相符子運算式。</span><span class="sxs-lookup"><span data-stu-id="43f92-152">Each subsequent member represents a matched subexpression.</span></span> <span data-ttu-id="43f92-153">如需詳細資訊，請參閱 [Grouping Constructs and Regular Expression Objects](#Objects) 一節。</span><span class="sxs-lookup"><span data-stu-id="43f92-153">For more information, see the [Grouping Constructs and Regular Expression Objects](#Objects) section.</span></span>  
  
 <span data-ttu-id="43f92-154">下列範例說明可識別文字中重複文字的規則運算式。</span><span class="sxs-lookup"><span data-stu-id="43f92-154">The following example illustrates a regular expression that identifies duplicated words in text.</span></span> <span data-ttu-id="43f92-155">規則運算式模式的兩個擷取群組代表重複文字的兩個執行個體。</span><span class="sxs-lookup"><span data-stu-id="43f92-155">The regular expression pattern's two capturing groups represent the two instances of the duplicated word.</span></span> <span data-ttu-id="43f92-156">擷取第二個執行個體是為了報告其於輸入字串中的開始位置。</span><span class="sxs-lookup"><span data-stu-id="43f92-156">The second instance is captured to report its starting position in the input string.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#1](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/grouping1.cs#1)]
 [!code-vb[RegularExpressions.Language.Grouping#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/grouping1.vb#1)]  
  
 <span data-ttu-id="43f92-157">規則運算式模式如下：</span><span class="sxs-lookup"><span data-stu-id="43f92-157">The regular expression pattern is the following:</span></span>  
  
`(\w+)\s(\1)\W`  
  
 <span data-ttu-id="43f92-158">下表顯示規則運算式模式的解譯方式。</span><span class="sxs-lookup"><span data-stu-id="43f92-158">The following table shows how the regular expression pattern is interpreted.</span></span>  
  
|<span data-ttu-id="43f92-159">模式</span><span class="sxs-lookup"><span data-stu-id="43f92-159">Pattern</span></span>|<span data-ttu-id="43f92-160">描述</span><span class="sxs-lookup"><span data-stu-id="43f92-160">Description</span></span>|  
|-------------|-----------------|  
|`(\w+)`|<span data-ttu-id="43f92-161">比對一個或多個文字字元。</span><span class="sxs-lookup"><span data-stu-id="43f92-161">Match one or more word characters.</span></span> <span data-ttu-id="43f92-162">這是第一個擷取群組。</span><span class="sxs-lookup"><span data-stu-id="43f92-162">This is the first capturing group.</span></span>|  
|`\s`|<span data-ttu-id="43f92-163">比對空白字元。</span><span class="sxs-lookup"><span data-stu-id="43f92-163">Match a white-space character.</span></span>|  
|`(\1)`|<span data-ttu-id="43f92-164">比對第一個擷取群組中的字串。</span><span class="sxs-lookup"><span data-stu-id="43f92-164">Match the string in the first captured group.</span></span> <span data-ttu-id="43f92-165">這是第二個擷取群組。</span><span class="sxs-lookup"><span data-stu-id="43f92-165">This is the second capturing group.</span></span> <span data-ttu-id="43f92-166">此範例將其指派給擷取的群組，以便從 `Match.Index` 物件。</span><span class="sxs-lookup"><span data-stu-id="43f92-166">The example assigns it to a captured group so that the starting position of the duplicate word can be retrieved from the `Match.Index` property.</span></span>|  
|`\W`|<span data-ttu-id="43f92-167">比對非文字字元，包括空格和標點符號。</span><span class="sxs-lookup"><span data-stu-id="43f92-167">Match a non-word character, including white space and punctuation.</span></span> <span data-ttu-id="43f92-168">如此可防止規則運算式模式比對以第一個擷取群組中的文字為開頭的文字。</span><span class="sxs-lookup"><span data-stu-id="43f92-168">This prevents the regular expression pattern from matching a word that starts with the word from the first captured group.</span></span>|  
  
<a name="named_matched_subexpression"></a>
## <a name="named-matched-subexpressions"></a><span data-ttu-id="43f92-169">具名的相符子運算式</span><span class="sxs-lookup"><span data-stu-id="43f92-169">Named Matched Subexpressions</span></span>  
 <span data-ttu-id="43f92-170">下列分組建構會擷取相符子運算式，並可讓您依名稱或依號碼加以存取。</span><span class="sxs-lookup"><span data-stu-id="43f92-170">The following grouping construct captures a matched subexpression and lets you access it by name or by number:</span></span>  
  
`(?<name>subexpression)`  
  
 <span data-ttu-id="43f92-171">或者：</span><span class="sxs-lookup"><span data-stu-id="43f92-171">or:</span></span>  
  
`(?'name'subexpression)`  
  
 <span data-ttu-id="43f92-172">其中 *name* 是有效的群組名稱，而 *subexpression* 是任何有效的規則運算式模式。</span><span class="sxs-lookup"><span data-stu-id="43f92-172">where *name* is a valid group name, and *subexpression* is any valid regular expression pattern.</span></span> <span data-ttu-id="43f92-173">*name* 絕不能包含任何標點符號字元，而且不能以數字開頭。</span><span class="sxs-lookup"><span data-stu-id="43f92-173">*name* must not contain any punctuation characters and cannot begin with a number.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="43f92-174">如果規則運算式模式比對方法的 <xref:System.Text.RegularExpressions.RegexOptions> 參數包含 <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> 旗標，或這個子運算式套用了 `n` 選項 (請參閱本主題稍後的[群組選項](#group_options))，則擷取子運算式的唯一方式就是明確地為擷取群組命名。</span><span class="sxs-lookup"><span data-stu-id="43f92-174">If the <xref:System.Text.RegularExpressions.RegexOptions> parameter of a regular expression pattern matching method includes the <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> flag, or if the `n` option is applied to this subexpression (see [Group options](#group_options) later in this topic), the only way to capture a subexpression is to explicitly name capturing groups.</span></span>  
  
 <span data-ttu-id="43f92-175">您可以用下列方式來存取具名的擷取群組：</span><span class="sxs-lookup"><span data-stu-id="43f92-175">You can access named captured groups in the following ways:</span></span>  
  
- <span data-ttu-id="43f92-176">在規則運算式中使用具名的反向參考建構。</span><span class="sxs-lookup"><span data-stu-id="43f92-176">By using the named backreference construct within the regular expression.</span></span> <span data-ttu-id="43f92-177">使用語法 `\k<` *name* `>` （其中*name*是所捕獲子運算式的名稱），在相同的正則運算式中參考相符的子運算式。</span><span class="sxs-lookup"><span data-stu-id="43f92-177">The matched subexpression is referenced in the same regular expression by using the syntax `\k<`*name*`>`, where *name* is the name of the captured subexpression.</span></span>  
  
- <span data-ttu-id="43f92-178">在規則運算式中使用反向參考建構。</span><span class="sxs-lookup"><span data-stu-id="43f92-178">By using the backreference construct within the regular expression.</span></span> <span data-ttu-id="43f92-179">使用語法 `\` *number*（其中*number*是所捕獲之子運算式的序號），在相同的正則運算式中參考相符的子運算式。</span><span class="sxs-lookup"><span data-stu-id="43f92-179">The matched subexpression is referenced in the same regular expression by using the syntax `\`*number*, where *number* is the ordinal number of the captured subexpression.</span></span> <span data-ttu-id="43f92-180">具名的相符子運算式會在相符子運算式之後，由左至右連續編號。</span><span class="sxs-lookup"><span data-stu-id="43f92-180">Named matched subexpressions are numbered consecutively from left to right after matched subexpressions.</span></span>  
  
- <span data-ttu-id="43f92-181">`${` *name* `}` 在或方法呼叫中使用 name 取代 <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> 順序 <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> ，其中*name*是所捕獲子運算式的名稱。</span><span class="sxs-lookup"><span data-stu-id="43f92-181">By using the `${`*name*`}` replacement sequence in a <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> or <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> method call, where *name* is the name of the captured subexpression.</span></span>  
  
- <span data-ttu-id="43f92-182">在 <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> 或 <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> 方法呼叫中使用 `$`*number* 取代序列，其中 *number* 是所擷取子運算式的序號。</span><span class="sxs-lookup"><span data-stu-id="43f92-182">By using the `$`*number* replacement sequence in a <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> or <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> method call, where *number* is the ordinal number of the captured subexpression.</span></span>  
  
- <span data-ttu-id="43f92-183">以程式設計方式，使用 <xref:System.Text.RegularExpressions.GroupCollection> 屬性傳回的 <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> 物件。</span><span class="sxs-lookup"><span data-stu-id="43f92-183">Programmatically, by using the <xref:System.Text.RegularExpressions.GroupCollection> object returned by the <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="43f92-184">集合中位置為零的成員代表整個規則運算式相符。</span><span class="sxs-lookup"><span data-stu-id="43f92-184">The member at position zero in the collection represents the entire regular expression match.</span></span> <span data-ttu-id="43f92-185">每個後續成員各代表一個相符子運算式。</span><span class="sxs-lookup"><span data-stu-id="43f92-185">Each subsequent member represents a matched subexpression.</span></span> <span data-ttu-id="43f92-186">具名的擷取群組儲存在集合中，編號的擷取群組之後。</span><span class="sxs-lookup"><span data-stu-id="43f92-186">Named captured groups are stored in the collection after numbered captured groups.</span></span>  
  
- <span data-ttu-id="43f92-187">以程式設計方式，提供子運算式名稱給 <xref:System.Text.RegularExpressions.GroupCollection> 物件的索引子 (在 C# 中) 或其 <xref:System.Text.RegularExpressions.GroupCollection.Item%2A> 屬性 (在 Visual Basic 中)。</span><span class="sxs-lookup"><span data-stu-id="43f92-187">Programmatically, by providing the subexpression name to the <xref:System.Text.RegularExpressions.GroupCollection> object's indexer (in C#) or to its <xref:System.Text.RegularExpressions.GroupCollection.Item%2A> property (in Visual Basic).</span></span>  
  
 <span data-ttu-id="43f92-188">有一個簡單的規則運算式模式，說明如何以程式設計方式，或是使用規則運算式語言語法，來參考編號 (未具名) 和具名群組。</span><span class="sxs-lookup"><span data-stu-id="43f92-188">A simple regular expression pattern illustrates how numbered (unnamed) and named groups can be referenced either programmatically or by using regular expression language syntax.</span></span> <span data-ttu-id="43f92-189">規則運算式 `((?<One>abc)\d+)?(?<Two>xyz)(.*)` 會依號碼或依名稱產生下列擷取群組。</span><span class="sxs-lookup"><span data-stu-id="43f92-189">The regular expression `((?<One>abc)\d+)?(?<Two>xyz)(.*)` produces the following capturing groups by number and by name.</span></span> <span data-ttu-id="43f92-190">第一個擷取群組 (編號 0) 一律參考整個模式。</span><span class="sxs-lookup"><span data-stu-id="43f92-190">The first capturing group (number 0) always refers to the entire pattern.</span></span>  
  
|<span data-ttu-id="43f92-191">Number</span><span class="sxs-lookup"><span data-stu-id="43f92-191">Number</span></span>|<span data-ttu-id="43f92-192">Name</span><span class="sxs-lookup"><span data-stu-id="43f92-192">Name</span></span>|<span data-ttu-id="43f92-193">模式</span><span class="sxs-lookup"><span data-stu-id="43f92-193">Pattern</span></span>|  
|------------|----------|-------------|  
|<span data-ttu-id="43f92-194">0</span><span class="sxs-lookup"><span data-stu-id="43f92-194">0</span></span>|<span data-ttu-id="43f92-195">0 (預設名稱)</span><span class="sxs-lookup"><span data-stu-id="43f92-195">0 (default name)</span></span>|`((?<One>abc)\d+)?(?<Two>xyz)(.*)`|  
|<span data-ttu-id="43f92-196">1</span><span class="sxs-lookup"><span data-stu-id="43f92-196">1</span></span>|<span data-ttu-id="43f92-197">1 (預設名稱)</span><span class="sxs-lookup"><span data-stu-id="43f92-197">1 (default name)</span></span>|`((?<One>abc)\d+)`|  
|<span data-ttu-id="43f92-198">2</span><span class="sxs-lookup"><span data-stu-id="43f92-198">2</span></span>|<span data-ttu-id="43f92-199">2 (預設名稱)</span><span class="sxs-lookup"><span data-stu-id="43f92-199">2 (default name)</span></span>|`(.*)`|  
|<span data-ttu-id="43f92-200">3</span><span class="sxs-lookup"><span data-stu-id="43f92-200">3</span></span>|<span data-ttu-id="43f92-201">一個</span><span class="sxs-lookup"><span data-stu-id="43f92-201">One</span></span>|`(?<One>abc)`|  
|<span data-ttu-id="43f92-202">4</span><span class="sxs-lookup"><span data-stu-id="43f92-202">4</span></span>|<span data-ttu-id="43f92-203">兩個</span><span class="sxs-lookup"><span data-stu-id="43f92-203">Two</span></span>|`(?<Two>xyz)`|  
  
 <span data-ttu-id="43f92-204">下列範例說明的規則運算式可識別重複文字，以及緊接在每個重複文字後面的文字。</span><span class="sxs-lookup"><span data-stu-id="43f92-204">The following example illustrates a regular expression that identifies duplicated words and the word that immediately follows each duplicated word.</span></span> <span data-ttu-id="43f92-205">規則運算式模式會定義兩個具名子運算式： `duplicateWord`代表重複文字，而 `nextWord`代表接在重複文字後面的文字。</span><span class="sxs-lookup"><span data-stu-id="43f92-205">The regular expression pattern defines two named subexpressions: `duplicateWord`, which represents the duplicated word; and `nextWord`, which represents the word that follows the duplicated word.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#2](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/grouping2.cs#2)]
 [!code-vb[RegularExpressions.Language.Grouping#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/grouping2.vb#2)]  
  
 <span data-ttu-id="43f92-206">規則運算式模式如下：</span><span class="sxs-lookup"><span data-stu-id="43f92-206">The regular expression pattern is as follows:</span></span>  
  
`(?<duplicateWord>\w+)\s\k<duplicateWord>\W(?<nextWord>\w+)`  
  
 <span data-ttu-id="43f92-207">下表顯示規則運算式的解譯方式。</span><span class="sxs-lookup"><span data-stu-id="43f92-207">The following table shows how the regular expression is interpreted.</span></span>  
  
|<span data-ttu-id="43f92-208">模式</span><span class="sxs-lookup"><span data-stu-id="43f92-208">Pattern</span></span>|<span data-ttu-id="43f92-209">描述</span><span class="sxs-lookup"><span data-stu-id="43f92-209">Description</span></span>|  
|-------------|-----------------|  
|`(?<duplicateWord>\w+)`|<span data-ttu-id="43f92-210">比對一個或多個文字字元。</span><span class="sxs-lookup"><span data-stu-id="43f92-210">Match one or more word characters.</span></span> <span data-ttu-id="43f92-211">將此擷取群組命名為 `duplicateWord`。</span><span class="sxs-lookup"><span data-stu-id="43f92-211">Name this capturing group `duplicateWord`.</span></span>|  
|`\s`|<span data-ttu-id="43f92-212">比對空白字元。</span><span class="sxs-lookup"><span data-stu-id="43f92-212">Match a white-space character.</span></span>|  
|`\k<duplicateWord>`|<span data-ttu-id="43f92-213">從名為 `duplicateWord`的擷取群組比對字串。</span><span class="sxs-lookup"><span data-stu-id="43f92-213">Match the string from the captured group that is named `duplicateWord`.</span></span>|  
|`\W`|<span data-ttu-id="43f92-214">比對非文字字元，包括空格和標點符號。</span><span class="sxs-lookup"><span data-stu-id="43f92-214">Match a non-word character, including white space and punctuation.</span></span> <span data-ttu-id="43f92-215">如此可防止規則運算式模式比對以第一個擷取群組中的文字為開頭的文字。</span><span class="sxs-lookup"><span data-stu-id="43f92-215">This prevents the regular expression pattern from matching a word that starts with the word from the first captured group.</span></span>|  
|`(?<nextWord>\w+)`|<span data-ttu-id="43f92-216">比對一個或多個文字字元。</span><span class="sxs-lookup"><span data-stu-id="43f92-216">Match one or more word characters.</span></span> <span data-ttu-id="43f92-217">將此擷取群組命名為 `nextWord`。</span><span class="sxs-lookup"><span data-stu-id="43f92-217">Name this capturing group `nextWord`.</span></span>|  
  
 <span data-ttu-id="43f92-218">請注意可以在規則運算式中重複群組名稱。</span><span class="sxs-lookup"><span data-stu-id="43f92-218">Note that a group name can be repeated in a regular expression.</span></span> <span data-ttu-id="43f92-219">例如，可能會有多於一個群組命名為 `digit`，如下列範例所示。</span><span class="sxs-lookup"><span data-stu-id="43f92-219">For example, it is possible for more than one group to be named `digit`, as the following example illustrates.</span></span> <span data-ttu-id="43f92-220">對於重複名稱的案例， <xref:System.Text.RegularExpressions.Group> 物件的值取決於輸入字串中的最後一個成功擷取。</span><span class="sxs-lookup"><span data-stu-id="43f92-220">In the case of duplicate names, the value of the <xref:System.Text.RegularExpressions.Group> object is determined by the last successful capture in the input string.</span></span> <span data-ttu-id="43f92-221">此外，將每個擷取的相關資訊填入 <xref:System.Text.RegularExpressions.CaptureCollection> ，就如同群組名稱不重複的情況。</span><span class="sxs-lookup"><span data-stu-id="43f92-221">In addition, the <xref:System.Text.RegularExpressions.CaptureCollection> is populated with information about each capture just as it would be if the group name was not duplicated.</span></span>  
  
 <span data-ttu-id="43f92-222">在下列範例中，規則運算式 `\D+(?<digit>\d+)\D+(?<digit>\d+)?` 包含兩次出現名為 `digit` 的群組。</span><span class="sxs-lookup"><span data-stu-id="43f92-222">In the following example, the regular expression `\D+(?<digit>\d+)\D+(?<digit>\d+)?` includes two occurrences of a group named `digit`.</span></span> <span data-ttu-id="43f92-223">第一個 `digit` 具名群組擷取一或多個數字字元。</span><span class="sxs-lookup"><span data-stu-id="43f92-223">The first `digit` named group captures one or more digit characters.</span></span> <span data-ttu-id="43f92-224">第二個 `digit` 具名群組擷取一或多個數字字元的零次或一次發生。</span><span class="sxs-lookup"><span data-stu-id="43f92-224">The second `digit` named group captures either zero or one occurrence of one or more digit characters.</span></span> <span data-ttu-id="43f92-225">如範例的輸出所示，如果第二個擷取群組成功地與文字相符，該文字的值會定義 <xref:System.Text.RegularExpressions.Group> 物件的值。</span><span class="sxs-lookup"><span data-stu-id="43f92-225">As the output from the example shows, if the second capturing group successfully matches text, the value of that text defines the value of the <xref:System.Text.RegularExpressions.Group> object.</span></span> <span data-ttu-id="43f92-226">如果第二個擷取群組不符合輸入的字串，則上一次成功比對的值會定義 <xref:System.Text.RegularExpressions.Group> 物件的數值。</span><span class="sxs-lookup"><span data-stu-id="43f92-226">If the second capturing group cannot does not match the input string, the value of the last successful match defines the value of the <xref:System.Text.RegularExpressions.Group> object.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#12](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/duplicate1.cs#12)]
 [!code-vb[RegularExpressions.Language.Grouping#12](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/duplicate1.vb#12)]  
  
 <span data-ttu-id="43f92-227">下表顯示規則運算式的解譯方式。</span><span class="sxs-lookup"><span data-stu-id="43f92-227">The following table shows how the regular expression is interpreted.</span></span>  
  
|<span data-ttu-id="43f92-228">模式</span><span class="sxs-lookup"><span data-stu-id="43f92-228">Pattern</span></span>|<span data-ttu-id="43f92-229">描述</span><span class="sxs-lookup"><span data-stu-id="43f92-229">Description</span></span>|  
|-------------|-----------------|  
|`\D+`|<span data-ttu-id="43f92-230">比對一個或更多非十進位數字字元。</span><span class="sxs-lookup"><span data-stu-id="43f92-230">Match one or more non-decimal digit characters.</span></span>|  
|`(?<digit>\d+)`|<span data-ttu-id="43f92-231">比對一個或更多十進位數字字元。</span><span class="sxs-lookup"><span data-stu-id="43f92-231">Match one or more decimal digit characters.</span></span> <span data-ttu-id="43f92-232">指派 `digit` 具名群組的比對。</span><span class="sxs-lookup"><span data-stu-id="43f92-232">Assign the match to the `digit` named group.</span></span>|  
|`\D+`|<span data-ttu-id="43f92-233">比對一個或更多非十進位數字字元。</span><span class="sxs-lookup"><span data-stu-id="43f92-233">Match one or more non-decimal digit characters.</span></span>|  
|`(?<digit>\d+)?`|<span data-ttu-id="43f92-234">比對一或多個十進位數字字元的零次或一次發生。</span><span class="sxs-lookup"><span data-stu-id="43f92-234">Match zero or one occurrence of one or more decimal digit characters.</span></span> <span data-ttu-id="43f92-235">指派 `digit` 具名群組的比對。</span><span class="sxs-lookup"><span data-stu-id="43f92-235">Assign the match to the `digit` named group.</span></span>|  
  
<a name="balancing_group_definition"></a>
## <a name="balancing-group-definitions"></a><span data-ttu-id="43f92-236">平衡群組定義</span><span class="sxs-lookup"><span data-stu-id="43f92-236">Balancing Group Definitions</span></span>  
 <span data-ttu-id="43f92-237">平衡群組定義會刪除先前定義之群組的定義，並且在目前群組中儲存先前定義的群組與目前群組之間的間隔。</span><span class="sxs-lookup"><span data-stu-id="43f92-237">A balancing group definition deletes the definition of a previously defined group and stores, in the current group, the interval between the previously defined group and the current group.</span></span> <span data-ttu-id="43f92-238">此分組建構的格式如下：</span><span class="sxs-lookup"><span data-stu-id="43f92-238">This grouping construct has the following format:</span></span>  
  
`(?<name1-name2>subexpression)`  
  
 <span data-ttu-id="43f92-239">或者：</span><span class="sxs-lookup"><span data-stu-id="43f92-239">or:</span></span>  
  
`(?'name1-name2' subexpression)`
  
 <span data-ttu-id="43f92-240">其中 *name1* 是目前群組 (選用)， *name2* 是先前定義的群組，而 *subexpression* 是任何有效的規則運算式模式。</span><span class="sxs-lookup"><span data-stu-id="43f92-240">where *name1* is the current group (optional), *name2* is a previously defined group, and *subexpression* is any valid regular expression pattern.</span></span> <span data-ttu-id="43f92-241">平衡群組定義會刪除 *name2* 的定義，並且將 *name2* 與 *name1* 之間的間隔儲存在 *name1*中。</span><span class="sxs-lookup"><span data-stu-id="43f92-241">The balancing group definition deletes the definition of *name2* and stores the interval between *name2* and *name1* in *name1*.</span></span> <span data-ttu-id="43f92-242">如果沒有定義 *name2* 群組，比對結果會回溯。</span><span class="sxs-lookup"><span data-stu-id="43f92-242">If no *name2* group is defined, the match backtracks.</span></span> <span data-ttu-id="43f92-243">因為刪除 *name2* 的最後一個定義會顯示 *name2* 的上一個定義，所以此建構可讓您將擷取堆疊用於群組 *name2*，以作為追蹤巢狀建構 (例如圓括弧或左右方括弧) 的計數器。</span><span class="sxs-lookup"><span data-stu-id="43f92-243">Because deleting the last definition of *name2* reveals the previous definition of *name2*, this construct lets you use the stack of captures for group *name2* as a counter for keeping track of nested constructs such as parentheses or opening and closing brackets.</span></span>  
  
 <span data-ttu-id="43f92-244">平衡群組定義將 *name2* 當作堆疊使用。</span><span class="sxs-lookup"><span data-stu-id="43f92-244">The balancing group definition uses *name2* as a stack.</span></span> <span data-ttu-id="43f92-245">每個巢狀建構的開頭字元都會放在群組及其 <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> 集合中。</span><span class="sxs-lookup"><span data-stu-id="43f92-245">The beginning character of each nested construct is placed in the group and in its <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> collection.</span></span> <span data-ttu-id="43f92-246">找到配對的結尾字元時，就會從群組中移除其對應的開頭字元，而 <xref:System.Text.RegularExpressions.Group.Captures%2A> 集合中就會減少一個。</span><span class="sxs-lookup"><span data-stu-id="43f92-246">When the closing character is matched, its corresponding opening character is removed from the group, and the <xref:System.Text.RegularExpressions.Group.Captures%2A> collection is decreased by one.</span></span> <span data-ttu-id="43f92-247">所有巢狀建構的開頭和結尾字元都配成對之後，*name2* 就空了。</span><span class="sxs-lookup"><span data-stu-id="43f92-247">After the opening and closing characters of all nested constructs have been matched, *name2* is empty.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="43f92-248">在您修改下列範例中的規則運算式來使用巢狀建構的適當開頭和結尾字元之後，即可用它來處理大部分的巢狀建構，例如包含多個巢狀方法呼叫的數學運算式或程式碼字行。</span><span class="sxs-lookup"><span data-stu-id="43f92-248">After you modify the regular expression in the following example to use the appropriate opening and closing character of a nested construct, you can use it to handle most nested constructs, such as mathematical expressions or lines of program code that include multiple nested method calls.</span></span>  
  
 <span data-ttu-id="43f92-249">下列範例使用平衡群組定義來比對輸入字串中的左右角括號 (<>)。</span><span class="sxs-lookup"><span data-stu-id="43f92-249">The following example uses a balancing group definition to match left and right angle brackets (<>) in an input string.</span></span> <span data-ttu-id="43f92-250">此範例定義兩個具名群組 `Open` 和 `Close`，像堆疊一樣可用來追蹤成對的角括號。</span><span class="sxs-lookup"><span data-stu-id="43f92-250">The example defines two named groups, `Open` and `Close`, that are used like a stack to track matching pairs of angle brackets.</span></span> <span data-ttu-id="43f92-251">所擷取的每個左角括號都會被推送至 `Open` 群組的擷取集合中，而所擷取的每個右角括號都會被推送至 `Close` 群組的擷取集合中。</span><span class="sxs-lookup"><span data-stu-id="43f92-251">Each captured left angle bracket is pushed into the capture collection of the `Open` group, and each captured right angle bracket is pushed into the capture collection of the `Close` group.</span></span> <span data-ttu-id="43f92-252">平衡群組定義可確保每個左角括號都有成對的右角括號。</span><span class="sxs-lookup"><span data-stu-id="43f92-252">The balancing group definition ensures that there is a matching right angle bracket for each left angle bracket.</span></span> <span data-ttu-id="43f92-253">如果沒有，唯有當 `(?(Open)(?!))`群組不是空的 (而因此如果所有巢狀建構都未關閉)，才會評估最後的子模式 `Open` 。</span><span class="sxs-lookup"><span data-stu-id="43f92-253">If there is not, the final subpattern, `(?(Open)(?!))`, is evaluated only if the `Open` group is not empty (and, therefore, if all nested constructs have not been closed).</span></span> <span data-ttu-id="43f92-254">如果評估最後的子模式，比對會失敗，因為 `(?!)` 子模式是一律會失敗的零寬度右不合樣 (Negative Lookahead) 判斷提示。</span><span class="sxs-lookup"><span data-stu-id="43f92-254">If the final subpattern is evaluated, the match fails, because the `(?!)` subpattern is a zero-width negative lookahead assertion that always fails.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#3](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/grouping3.cs#3)]
 [!code-vb[RegularExpressions.Language.Grouping#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/grouping3.vb#3)]  
  
 <span data-ttu-id="43f92-255">規則運算式模式為：</span><span class="sxs-lookup"><span data-stu-id="43f92-255">The regular expression pattern is:</span></span>  
  
`^[^<>]*(((?'Open'<)[^<>]*)+((?'Close-Open'>)[^<>]*)+)*(?(Open)(?!))$`  
  
 <span data-ttu-id="43f92-256">規則運算式解譯如下：</span><span class="sxs-lookup"><span data-stu-id="43f92-256">The regular expression is interpreted as follows:</span></span>  
  
|<span data-ttu-id="43f92-257">模式</span><span class="sxs-lookup"><span data-stu-id="43f92-257">Pattern</span></span>|<span data-ttu-id="43f92-258">描述</span><span class="sxs-lookup"><span data-stu-id="43f92-258">Description</span></span>|  
|-------------|-----------------|  
|`^`|<span data-ttu-id="43f92-259">從字串開頭開始。</span><span class="sxs-lookup"><span data-stu-id="43f92-259">Begin at the start of the string.</span></span>|  
|`[^<>]*`|<span data-ttu-id="43f92-260">比對非左右角括號的零或多個字元。</span><span class="sxs-lookup"><span data-stu-id="43f92-260">Match zero or more characters that are not left or right angle brackets.</span></span>|  
|`(?'Open'<)`|<span data-ttu-id="43f92-261">比對左角括號，並將其指派給名為 `Open`的群組。</span><span class="sxs-lookup"><span data-stu-id="43f92-261">Match a left angle bracket and assign it to a group named `Open`.</span></span>|  
|`[^<>]*`|<span data-ttu-id="43f92-262">比對非左右角括號的零或多個字元。</span><span class="sxs-lookup"><span data-stu-id="43f92-262">Match zero or more characters that are not left or right angle brackets.</span></span>|  
|`((?'Open'<)[^<>]*)+`|<span data-ttu-id="43f92-263">比對出現一或數次、後面接零或多個非左右角括號字元的左角括號。</span><span class="sxs-lookup"><span data-stu-id="43f92-263">Match one or more occurrences of a left angle bracket followed by zero or more characters that are not left or right angle brackets.</span></span> <span data-ttu-id="43f92-264">這是第二個擷取群組。</span><span class="sxs-lookup"><span data-stu-id="43f92-264">This is the second capturing group.</span></span>|  
|`(?'Close-Open'>)`|<span data-ttu-id="43f92-265">比對右角括號，將 `Open` 群組與目前群組之間的子字串指派給 `Close` 群組，並刪除 `Open` 群組的定義。</span><span class="sxs-lookup"><span data-stu-id="43f92-265">Match a right angle bracket, assign the substring between the `Open` group and the current group to the `Close` group, and delete the definition of the `Open` group.</span></span>|  
|`[^<>]*`|<span data-ttu-id="43f92-266">比對出現零或數次、非左右角括號的任何字元。</span><span class="sxs-lookup"><span data-stu-id="43f92-266">Match zero or more occurrences of any character that is neither a left  nor a right angle bracket.</span></span>|  
|`((?'Close-Open'>)[^<>]*)+`|<span data-ttu-id="43f92-267">比對出現一或數次、後接零或多個非左右角括號字元的右角括號。</span><span class="sxs-lookup"><span data-stu-id="43f92-267">Match one or more occurrences of a right angle bracket, followed by zero or more occurrences of any character that is neither a left nor a right angle bracket.</span></span> <span data-ttu-id="43f92-268">比對右角括號時，將 `Open` 群組與目前群組之間的子字串指派給 `Close` 群組，並刪除 `Open` 群組的定義。</span><span class="sxs-lookup"><span data-stu-id="43f92-268">When matching the right angle bracket, assign the substring between the `Open` group and the current group to the `Close` group, and delete the definition of the `Open` group.</span></span> <span data-ttu-id="43f92-269">這是第三個擷取群組。</span><span class="sxs-lookup"><span data-stu-id="43f92-269">This is the third capturing group.</span></span>|  
|`(((?'Open'<)[^<>]*)+((?'Close-Open'>)[^<>]*)+)*`|<span data-ttu-id="43f92-270">比對出現零或數次的下列模式：出現一或數次的左角括號，後接零或多個非角括號字元，後接出現一或數次的右角括號，後接出現零或數次的非角括號。</span><span class="sxs-lookup"><span data-stu-id="43f92-270">Match zero or more occurrences of the following pattern: one or more occurrences of a left angle bracket, followed by zero or more non-angle bracket characters, followed by one or more occurrences of a right angle bracket, followed by zero or more occurrences of non-angle brackets.</span></span> <span data-ttu-id="43f92-271">比對右角括號時，刪除 `Open` 群組的定義，並將 `Open` 群組與目前群組之間的子字串指派給 `Close` 群組。</span><span class="sxs-lookup"><span data-stu-id="43f92-271">When matching the right angle bracket, delete the definition of the `Open` group, and assign the substring between the `Open` group and the current group to the `Close` group.</span></span> <span data-ttu-id="43f92-272">這是第一個擷取群組。</span><span class="sxs-lookup"><span data-stu-id="43f92-272">This is the first capturing group.</span></span>|  
|`(?(Open)(?!))`|<span data-ttu-id="43f92-273">如果 `Open` 群組存在，若可以比對空字串，則放棄比對，但不要將字串中的規則運算式引擎的位置向前移動。</span><span class="sxs-lookup"><span data-stu-id="43f92-273">If the `Open` group exists, abandon the match if an empty string can be matched, but do not advance the position of the regular expression engine in the string.</span></span> <span data-ttu-id="43f92-274">這是零寬度右不合樣 (Negative Lookahead) 判斷提示。</span><span class="sxs-lookup"><span data-stu-id="43f92-274">This is a zero-width negative lookahead assertion.</span></span> <span data-ttu-id="43f92-275">因為空字串一律以隱含方式存在於輸入字串中，所以此比對一定會失敗。</span><span class="sxs-lookup"><span data-stu-id="43f92-275">Because an empty string is always implicitly present in an input string, this match always fails.</span></span> <span data-ttu-id="43f92-276">此比對失敗表示角括號不平衡。</span><span class="sxs-lookup"><span data-stu-id="43f92-276">Failure of this match indicates that the angle brackets are not balanced.</span></span>|  
|`$`|<span data-ttu-id="43f92-277">比對輸入字串的結尾。</span><span class="sxs-lookup"><span data-stu-id="43f92-277">Match the end of the input string.</span></span>|  
  
 <span data-ttu-id="43f92-278">最後的子運算式 `(?(Open)(?!))` 指出輸入字串中的巢狀建構是否正確平衡 (例如，是否每個左角括號都有配對的右角括號)。</span><span class="sxs-lookup"><span data-stu-id="43f92-278">The final subexpression, `(?(Open)(?!))`, indicates whether the nesting constructs in the input string are properly balanced (for example, whether each left angle bracket is matched by a right angle bracket).</span></span> <span data-ttu-id="43f92-279">其依據有效的擷取群組進行條件式比對；如需詳細資訊，請參閱 [Alternation Constructs](alternation-constructs-in-regular-expressions.md)。</span><span class="sxs-lookup"><span data-stu-id="43f92-279">It uses conditional matching based on a valid captured group; for more information, see [Alternation Constructs](alternation-constructs-in-regular-expressions.md).</span></span> <span data-ttu-id="43f92-280">如果已定義 `Open` 群組，規則運算式引擎會嘗試比對輸入字串中的子運算式 `(?!)` 。</span><span class="sxs-lookup"><span data-stu-id="43f92-280">If the `Open` group is defined, the regular expression engine attempts to match the subexpression `(?!)` in the input string.</span></span> <span data-ttu-id="43f92-281">唯有當巢狀建構不平衡時，才應定義 `Open` 群組。</span><span class="sxs-lookup"><span data-stu-id="43f92-281">The `Open` group should be defined only if nesting constructs are unbalanced.</span></span> <span data-ttu-id="43f92-282">因此，要在輸入字串中比對的模式，應該是一律導致比對失敗的模式。</span><span class="sxs-lookup"><span data-stu-id="43f92-282">Therefore, the pattern to be matched in the input string should be one that always causes the match to fail.</span></span> <span data-ttu-id="43f92-283">在這個情況下，`(?!)` 是一律失敗的零寬度右不合樣 (Negative Lookahead) 判斷提示，因為空字串一律以隱含方式存在於輸入字串中。</span><span class="sxs-lookup"><span data-stu-id="43f92-283">In this case, `(?!)` is a zero-width negative lookahead assertion that always fails, because an empty string is always implicitly present at the next position in the input string.</span></span>  
  
 <span data-ttu-id="43f92-284">在這個範例中，規則運算式引擎會評估輸入字串 "\<abc><mno\<xyz>>"，如下表所示。</span><span class="sxs-lookup"><span data-stu-id="43f92-284">In the example, the regular expression engine evaluates the input string "\<abc><mno\<xyz>>" as shown in the following table.</span></span>  
  
|<span data-ttu-id="43f92-285">步驟</span><span class="sxs-lookup"><span data-stu-id="43f92-285">Step</span></span>|<span data-ttu-id="43f92-286">模式</span><span class="sxs-lookup"><span data-stu-id="43f92-286">Pattern</span></span>|<span data-ttu-id="43f92-287">結果</span><span class="sxs-lookup"><span data-stu-id="43f92-287">Result</span></span>|  
|----------|-------------|------------|  
|<span data-ttu-id="43f92-288">1</span><span class="sxs-lookup"><span data-stu-id="43f92-288">1</span></span>|`^`|<span data-ttu-id="43f92-289">從輸入字串的開頭開始比對。</span><span class="sxs-lookup"><span data-stu-id="43f92-289">Starts the match at the beginning of the input string</span></span>|  
|<span data-ttu-id="43f92-290">2</span><span class="sxs-lookup"><span data-stu-id="43f92-290">2</span></span>|`[^<>]*`|<span data-ttu-id="43f92-291">在左角括號之前尋找非角括號字元；沒有找到配對。</span><span class="sxs-lookup"><span data-stu-id="43f92-291">Looks for non-angle bracket characters before the left angle bracket;finds no matches.</span></span>|  
|<span data-ttu-id="43f92-292">3</span><span class="sxs-lookup"><span data-stu-id="43f92-292">3</span></span>|`(((?'Open'<)`|<span data-ttu-id="43f92-293">比對 "\<abc>" 中的左角括弧，並將其指派給 `Open` 群組。</span><span class="sxs-lookup"><span data-stu-id="43f92-293">Matches the left angle bracket in "\<abc>" and assigns it to the `Open` group.</span></span>|  
|<span data-ttu-id="43f92-294">4</span><span class="sxs-lookup"><span data-stu-id="43f92-294">4</span></span>|`[^<>]*`|<span data-ttu-id="43f92-295">比對 "abc"。</span><span class="sxs-lookup"><span data-stu-id="43f92-295">Matches "abc".</span></span>|  
|<span data-ttu-id="43f92-296">5</span><span class="sxs-lookup"><span data-stu-id="43f92-296">5</span></span>|`)+`|<span data-ttu-id="43f92-297">"<abc" 是第二個擷取群組的值。</span><span class="sxs-lookup"><span data-stu-id="43f92-297">"<abc" is the value of the second captured group.</span></span><br /><br /> <span data-ttu-id="43f92-298">輸入字串中的下一個字元不是左角括號，所以規則運算式引擎未回送至 `(?'Open'<)[^<>]*)` 子模式。</span><span class="sxs-lookup"><span data-stu-id="43f92-298">The next character in the input string is not a left angle bracket, so the regular expression engine does not loop back to the `(?'Open'<)[^<>]*)` subpattern.</span></span>|  
|<span data-ttu-id="43f92-299">6</span><span class="sxs-lookup"><span data-stu-id="43f92-299">6</span></span>|`((?'Close-Open'>)`|<span data-ttu-id="43f92-300">比對 "\<abc>" 中的右角括弧，將 "abc" (`Open` 群組與右角括弧之間的子字串) 指派給 `Close` 群組，並刪除 `Open` 群組的目前值 ("<")，使其空白。</span><span class="sxs-lookup"><span data-stu-id="43f92-300">Matches the right angle bracket in "\<abc>", assigns "abc", which is the substring between the `Open` group and the right angle bracket, to the `Close` group, and deletes the current value ("<") of the `Open` group, leaving it empty.</span></span>|  
|<span data-ttu-id="43f92-301">7</span><span class="sxs-lookup"><span data-stu-id="43f92-301">7</span></span>|`[^<>]*`|<span data-ttu-id="43f92-302">在右角括號之後尋找非角括號字元；沒有找到配對。</span><span class="sxs-lookup"><span data-stu-id="43f92-302">Looks for non-angle bracket characters after the right angle bracket; finds no matches.</span></span>|  
|<span data-ttu-id="43f92-303">8</span><span class="sxs-lookup"><span data-stu-id="43f92-303">8</span></span>|`)+`|<span data-ttu-id="43f92-304">第三個擷取群組的值是 ">"。</span><span class="sxs-lookup"><span data-stu-id="43f92-304">The value of the third captured group is ">".</span></span><br /><br /> <span data-ttu-id="43f92-305">輸入字串中的下一個字元不是右角括號，所以規則運算式引擎未回送至 `((?'Close-Open'>)[^<>]*)` 子模式。</span><span class="sxs-lookup"><span data-stu-id="43f92-305">The next character in the input string is not a right angle bracket, so the regular expression engine does not loop back to the `((?'Close-Open'>)[^<>]*)` subpattern.</span></span>|  
|<span data-ttu-id="43f92-306">9</span><span class="sxs-lookup"><span data-stu-id="43f92-306">9</span></span>|`)*`|<span data-ttu-id="43f92-307">第一個擷取群組的值是 "\<abc>"。</span><span class="sxs-lookup"><span data-stu-id="43f92-307">The value of the first captured group is "\<abc>".</span></span><br /><br /> <span data-ttu-id="43f92-308">輸入字串中的下一個字元是左角括號，所以規則運算式引擎會回送至 `(((?'Open'<)` 子模式。</span><span class="sxs-lookup"><span data-stu-id="43f92-308">The next character in the input string is a left  angle bracket, so the regular expression engine loops back to the `(((?'Open'<)` subpattern.</span></span>|  
|<span data-ttu-id="43f92-309">10</span><span class="sxs-lookup"><span data-stu-id="43f92-309">10</span></span>|`(((?'Open'<)`|<span data-ttu-id="43f92-310">符合「集合中的左角括弧 \<mno" and assigns it to the `Open` group. Its <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> 現在具有單一值，也就是「<」。</span><span class="sxs-lookup"><span data-stu-id="43f92-310">Matches the left angle bracket in "\<mno" and assigns it to the `Open` group. Its <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> collection now has a single value, "<".</span></span>|  
|<span data-ttu-id="43f92-311">11</span><span class="sxs-lookup"><span data-stu-id="43f92-311">11</span></span>|`[^<>]*`|<span data-ttu-id="43f92-312">比對 "mno"。</span><span class="sxs-lookup"><span data-stu-id="43f92-312">Matches "mno".</span></span>|  
|<span data-ttu-id="43f92-313">12</span><span class="sxs-lookup"><span data-stu-id="43f92-313">12</span></span>|`)+`|<span data-ttu-id="43f92-314">"<mno" 是第二個擷取群組的值。</span><span class="sxs-lookup"><span data-stu-id="43f92-314">"<mno" is the value of the second captured group.</span></span><br /><br /> <span data-ttu-id="43f92-315">輸入字串中的下一個字元是左角括號，所以規則運算式引擎會回送至 `(?'Open'<)[^<>]*)` 子模式。</span><span class="sxs-lookup"><span data-stu-id="43f92-315">The next character in the input string is an left angle bracket, so the regular expression engine loops back to the `(?'Open'<)[^<>]*)` subpattern.</span></span>|  
|<span data-ttu-id="43f92-316">13</span><span class="sxs-lookup"><span data-stu-id="43f92-316">13</span></span>|`(((?'Open'<)`|<span data-ttu-id="43f92-317">比對 "\<xyz>" 中的左角括弧，並將其指派給 `Open` 群組。</span><span class="sxs-lookup"><span data-stu-id="43f92-317">Matches the left angle bracket in "\<xyz>" and assigns it to the `Open` group.</span></span> <span data-ttu-id="43f92-318"><xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType>群組的集合 `Open` 現在包含兩個捕獲： "" 的左角括弧 \<mno", and the left angle bracket from "\<xyz> 。</span><span class="sxs-lookup"><span data-stu-id="43f92-318">The <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> collection of the `Open` group now includes two captures: the left angle bracket from "\<mno", and the left angle bracket from "\<xyz>".</span></span>|  
|<span data-ttu-id="43f92-319">14</span><span class="sxs-lookup"><span data-stu-id="43f92-319">14</span></span>|`[^<>]*`|<span data-ttu-id="43f92-320">比對 "xyz"。</span><span class="sxs-lookup"><span data-stu-id="43f92-320">Matches "xyz".</span></span>|  
|<span data-ttu-id="43f92-321">15</span><span class="sxs-lookup"><span data-stu-id="43f92-321">15</span></span>|`)+`|<span data-ttu-id="43f92-322">"<xyz" 是第二個擷取群組的值。</span><span class="sxs-lookup"><span data-stu-id="43f92-322">"<xyz" is the value of the second captured group.</span></span><br /><br /> <span data-ttu-id="43f92-323">輸入字串中的下一個字元不是左角括號，所以規則運算式引擎未回送至 `(?'Open'<)[^<>]*)` 子模式。</span><span class="sxs-lookup"><span data-stu-id="43f92-323">The next character in the input string is not a left angle bracket, so the regular expression engine does not loop back to the `(?'Open'<)[^<>]*)` subpattern.</span></span>|  
|<span data-ttu-id="43f92-324">16</span><span class="sxs-lookup"><span data-stu-id="43f92-324">16</span></span>|`((?'Close-Open'>)`|<span data-ttu-id="43f92-325">比對 "\<xyz>" 中的右角括弧。</span><span class="sxs-lookup"><span data-stu-id="43f92-325">Matches the right angle bracket in "\<xyz>".</span></span> <span data-ttu-id="43f92-326">"xyz"，將 `Open` 群組與右角括弧之間的子字串指派給 `Close` 群組，並刪除 `Open` 群組目前的值。</span><span class="sxs-lookup"><span data-stu-id="43f92-326">"xyz", assigns the substring between the `Open` group and the right angle bracket to the `Close` group, and deletes the current value of the `Open` group.</span></span> <span data-ttu-id="43f92-327">上一個 capture 的值（「群組集合中的左角括弧 \<mno") becomes the current value of the `Open` group. The <xref:System.Text.RegularExpressions.Group.Captures%2A> `Open` 現在包含單一捕獲，也就是 "" 的左角括弧 \<xyz> 。</span><span class="sxs-lookup"><span data-stu-id="43f92-327">The value of the previous capture (the left angle bracket in "\<mno") becomes the current value of the `Open` group. The <xref:System.Text.RegularExpressions.Group.Captures%2A> collection of the `Open` group now includes a single capture, the left angle bracket from "\<xyz>".</span></span>|  
|<span data-ttu-id="43f92-328">17</span><span class="sxs-lookup"><span data-stu-id="43f92-328">17</span></span>|`[^<>]*`|<span data-ttu-id="43f92-329">尋找非角括號字元；沒有找到配對。</span><span class="sxs-lookup"><span data-stu-id="43f92-329">Looks for non-angle bracket characters; finds no matches.</span></span>|  
|<span data-ttu-id="43f92-330">18</span><span class="sxs-lookup"><span data-stu-id="43f92-330">18</span></span>|`)+`|<span data-ttu-id="43f92-331">第三個擷取群組的值是 ">"。</span><span class="sxs-lookup"><span data-stu-id="43f92-331">The value of the third captured group is ">".</span></span><br /><br /> <span data-ttu-id="43f92-332">輸入字串中的下一個字元是右角括號，所以規則運算式引擎會回送至 `((?'Close-Open'>)[^<>]*)` 子模式。</span><span class="sxs-lookup"><span data-stu-id="43f92-332">The next character in the input string is a right angle bracket, so the regular expression engine loops back to the `((?'Close-Open'>)[^<>]*)` subpattern.</span></span>|  
|<span data-ttu-id="43f92-333">19</span><span class="sxs-lookup"><span data-stu-id="43f92-333">19</span></span>|`((?'Close-Open'>)`|<span data-ttu-id="43f92-334">比對 "xyz>>" 中的最後一個右角括弧，將 "mno\<xyz>" (`Open` 群組與右角括弧之間的子字串) 指派給 `Close` 群組，並刪除 `Open` 群組的目前值。</span><span class="sxs-lookup"><span data-stu-id="43f92-334">Matches the final right angle bracket in "xyz>>", assigns "mno\<xyz>" (the substring between the `Open` group and the right angle bracket) to the `Close` group, and deletes the current value of the `Open` group.</span></span> <span data-ttu-id="43f92-335">`Open` 群組現在是空的。</span><span class="sxs-lookup"><span data-stu-id="43f92-335">The `Open` group is now empty.</span></span>|  
|<span data-ttu-id="43f92-336">20</span><span class="sxs-lookup"><span data-stu-id="43f92-336">20</span></span>|`[^<>]*`|<span data-ttu-id="43f92-337">尋找非角括號字元；沒有找到配對。</span><span class="sxs-lookup"><span data-stu-id="43f92-337">Looks for non-angle bracket characters; finds no matches.</span></span>|  
|<span data-ttu-id="43f92-338">21</span><span class="sxs-lookup"><span data-stu-id="43f92-338">21</span></span>|`)+`|<span data-ttu-id="43f92-339">第三個擷取群組的值是 ">"。</span><span class="sxs-lookup"><span data-stu-id="43f92-339">The value of the third captured group is ">".</span></span><br /><br /> <span data-ttu-id="43f92-340">輸入字串中的下一個字元不是右角括號，所以規則運算式引擎未回送至 `((?'Close-Open'>)[^<>]*)` 子模式。</span><span class="sxs-lookup"><span data-stu-id="43f92-340">The next character in the input string is not a right angle bracket, so the regular expression engine does not loop back to the `((?'Close-Open'>)[^<>]*)` subpattern.</span></span>|  
|<span data-ttu-id="43f92-341">22</span><span class="sxs-lookup"><span data-stu-id="43f92-341">22</span></span>|`)*`|<span data-ttu-id="43f92-342">第一個擷取群組的值是 "<mno\<xyz>>"。</span><span class="sxs-lookup"><span data-stu-id="43f92-342">The value of the first captured group is "<mno\<xyz>>".</span></span><br /><br /> <span data-ttu-id="43f92-343">輸入字串中的下一個字元不是左角括號，所以規則運算式引擎未回送至 `(((?'Open'<)` 子模式。</span><span class="sxs-lookup"><span data-stu-id="43f92-343">The next character in the input string is not a left angle bracket, so the regular expression engine does not loop back to the `(((?'Open'<)` subpattern.</span></span>|  
|<span data-ttu-id="43f92-344">23</span><span class="sxs-lookup"><span data-stu-id="43f92-344">23</span></span>|`(?(Open)(?!))`|<span data-ttu-id="43f92-345">`Open` 群組未定義，所以未嘗試任何比對。</span><span class="sxs-lookup"><span data-stu-id="43f92-345">The `Open` group is not defined, so no match is attempted.</span></span>|  
|<span data-ttu-id="43f92-346">24</span><span class="sxs-lookup"><span data-stu-id="43f92-346">24</span></span>|`$`|<span data-ttu-id="43f92-347">比對輸入字串的結尾。</span><span class="sxs-lookup"><span data-stu-id="43f92-347">Matches the end of the input string.</span></span>|  
  
<a name="noncapturing_group"></a>
## <a name="noncapturing-groups"></a><span data-ttu-id="43f92-348">非擷取群組</span><span class="sxs-lookup"><span data-stu-id="43f92-348">Noncapturing Groups</span></span>  
 <span data-ttu-id="43f92-349">下列分組建構不會擷取由下列子運算式比對的子字串：</span><span class="sxs-lookup"><span data-stu-id="43f92-349">The following grouping construct does not capture the substring that is matched by a subexpression:</span></span>  
  
`(?:subexpression)`
  
 <span data-ttu-id="43f92-350">其中 *subexpression* 是任何有效的規則運算式模式。</span><span class="sxs-lookup"><span data-stu-id="43f92-350">where *subexpression* is any valid regular expression pattern.</span></span> <span data-ttu-id="43f92-351">將數量詞套用至群組時，通常會使用非擷取分組建構，但是群組擷取的子字串沒有用。</span><span class="sxs-lookup"><span data-stu-id="43f92-351">The noncapturing group construct is typically used when a quantifier is applied to a group, but the substrings captured by the group are of no interest.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="43f92-352">如果規則運算式包含巢狀分組建構，則外部非擷取分組建構不會套用至內部巢狀分組建構。</span><span class="sxs-lookup"><span data-stu-id="43f92-352">If a regular expression includes nested grouping constructs, an outer noncapturing group construct does not apply to the inner nested group constructs.</span></span>  
  
 <span data-ttu-id="43f92-353">下列範例說明包含非擷取群組的規則運算式。</span><span class="sxs-lookup"><span data-stu-id="43f92-353">The following example illustrates a regular expression that includes noncapturing groups.</span></span> <span data-ttu-id="43f92-354">請注意，輸出沒有包含任何擷取群組。</span><span class="sxs-lookup"><span data-stu-id="43f92-354">Note that the output does not include any captured groups.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#5](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/noncapture1.cs#5)]
 [!code-vb[RegularExpressions.Language.Grouping#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/noncapture1.vb#5)]  
  
 <span data-ttu-id="43f92-355">規則運算式 `(?:\b(?:\w+)\W*)+\.` 符合以句點終止的句子。</span><span class="sxs-lookup"><span data-stu-id="43f92-355">The regular expression `(?:\b(?:\w+)\W*)+\.` matches a sentence that is terminated by a period.</span></span> <span data-ttu-id="43f92-356">因為規則運算式著重在句子，而不是個別文字，所以分組建構只會用做數量詞。</span><span class="sxs-lookup"><span data-stu-id="43f92-356">Because the regular expression focuses on sentences and not on individual words, grouping constructs are used exclusively as quantifiers.</span></span> <span data-ttu-id="43f92-357">規則運算式模式的解譯方式如下表所示。</span><span class="sxs-lookup"><span data-stu-id="43f92-357">The regular expression pattern is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="43f92-358">模式</span><span class="sxs-lookup"><span data-stu-id="43f92-358">Pattern</span></span>|<span data-ttu-id="43f92-359">描述</span><span class="sxs-lookup"><span data-stu-id="43f92-359">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="43f92-360">開始字緣比對。</span><span class="sxs-lookup"><span data-stu-id="43f92-360">Begin the match at a word boundary.</span></span>|  
|`(?:\w+)`|<span data-ttu-id="43f92-361">比對一個或多個文字字元。</span><span class="sxs-lookup"><span data-stu-id="43f92-361">Match one or more word characters.</span></span> <span data-ttu-id="43f92-362">請勿將相符的文字指派給擷取群組。</span><span class="sxs-lookup"><span data-stu-id="43f92-362">Do not assign the matched text to a captured group.</span></span>|  
|`\W*`|<span data-ttu-id="43f92-363">比對零或多個非文字字元。</span><span class="sxs-lookup"><span data-stu-id="43f92-363">Match zero or more non-word characters.</span></span>|  
|`(?:\b(?:\w+)\W*)+`|<span data-ttu-id="43f92-364">比對下列模式一次或多次：以字邊界開頭的一或多個文字字元，後面接零或多個非文字字元。</span><span class="sxs-lookup"><span data-stu-id="43f92-364">Match the pattern of one or more word characters starting at a word boundary, followed by zero or more non-word characters, one or more times.</span></span> <span data-ttu-id="43f92-365">請勿將相符的文字指派給擷取群組。</span><span class="sxs-lookup"><span data-stu-id="43f92-365">Do not assign the matched text to a captured group.</span></span>|  
|`\.`|<span data-ttu-id="43f92-366">比對句點。</span><span class="sxs-lookup"><span data-stu-id="43f92-366">Match a period.</span></span>|  
  
<a name="group_options"></a>
## <a name="group-options"></a><span data-ttu-id="43f92-367">群組選項</span><span class="sxs-lookup"><span data-stu-id="43f92-367">Group Options</span></span>  
 <span data-ttu-id="43f92-368">下列群組建構會在子運算式中套用或停用指定的選項：</span><span class="sxs-lookup"><span data-stu-id="43f92-368">The following grouping construct applies or disables the specified options within a subexpression:</span></span>  
  
 <span data-ttu-id="43f92-369"> subexpression`(?imnsx-imnsx:`\ \** `)`</span><span class="sxs-lookup"><span data-stu-id="43f92-369">`(?imnsx-imnsx:` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="43f92-370">其中 *subexpression* 是任何有效的規則運算式模式。</span><span class="sxs-lookup"><span data-stu-id="43f92-370">where *subexpression* is any valid regular expression pattern.</span></span> <span data-ttu-id="43f92-371">例如，`(?i-s:)` 會開啟不區分大小寫，並停用單行模式。</span><span class="sxs-lookup"><span data-stu-id="43f92-371">For example, `(?i-s:)` turns on case insensitivity and disables single-line mode.</span></span> <span data-ttu-id="43f92-372">如需您可以指定之內嵌選項的詳細資訊，請參閱[正則運算式選項](regular-expression-options.md)。</span><span class="sxs-lookup"><span data-stu-id="43f92-372">For more information about the inline options you can specify, see [Regular Expression Options](regular-expression-options.md).</span></span>  
  
> [!NOTE]
> <span data-ttu-id="43f92-373">若要將指定的選項套用至整個規則運算式，而不是單一子運算式，您可以使用 <xref:System.Text.RegularExpressions.Regex?displayProperty=nameWithType> 類別建構函式或靜態方法。</span><span class="sxs-lookup"><span data-stu-id="43f92-373">You can specify options that apply to an entire regular expression rather than a subexpression by using a <xref:System.Text.RegularExpressions.Regex?displayProperty=nameWithType> class constructor or a static method.</span></span> <span data-ttu-id="43f92-374">您也可以使用 `(?imnsx-imnsx)` 語言建構，以指定在規則運算式的特定點之後，套用內嵌選項。</span><span class="sxs-lookup"><span data-stu-id="43f92-374">You can also specify inline options that apply after a specific point in a regular expression by using the `(?imnsx-imnsx)` language construct.</span></span>  
  
 <span data-ttu-id="43f92-375">群組選項建構不是擷取群組。</span><span class="sxs-lookup"><span data-stu-id="43f92-375">The group options construct is not a capturing group.</span></span> <span data-ttu-id="43f92-376">也就是說，雖然 *subexpression* 擷取之字串的任何部分都會包含在比對中，但不會包含在擷取群組中，也不會用來填入 <xref:System.Text.RegularExpressions.GroupCollection> 物件。</span><span class="sxs-lookup"><span data-stu-id="43f92-376">That is, although any portion of a string that is captured by *subexpression* is included in the match, it is not included in a captured group nor used to populate the <xref:System.Text.RegularExpressions.GroupCollection> object.</span></span>  
  
 <span data-ttu-id="43f92-377">例如，下列範例中的規則運算式 `\b(?ix: d \w+)\s` 在分組建構中使用內嵌選項，來啟用不區分大小寫的比對，並會在識別以字母 "d" 開頭的所有字組時，忽略模式空白字元。</span><span class="sxs-lookup"><span data-stu-id="43f92-377">For example, the regular expression `\b(?ix: d \w+)\s` in the following example uses inline options in a grouping construct to enable case-insensitive matching and ignore pattern white space in identifying all words that begin with the letter "d".</span></span> <span data-ttu-id="43f92-378">規則運算式的定義如下表所示。</span><span class="sxs-lookup"><span data-stu-id="43f92-378">The regular expression is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="43f92-379">模式</span><span class="sxs-lookup"><span data-stu-id="43f92-379">Pattern</span></span>|<span data-ttu-id="43f92-380">描述</span><span class="sxs-lookup"><span data-stu-id="43f92-380">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="43f92-381">開始字緣比對。</span><span class="sxs-lookup"><span data-stu-id="43f92-381">Begin the match at a word boundary.</span></span>|  
|`(?ix: d \w+)`|<span data-ttu-id="43f92-382">使用不區分大小寫比對，並忽略此模式中的空格，比對後面接一或多個文字字元的 "d"。</span><span class="sxs-lookup"><span data-stu-id="43f92-382">Using case-insensitive matching and ignoring white space in this pattern, match a "d" followed by one or more word characters.</span></span>|  
|`\s`|<span data-ttu-id="43f92-383">比對空白字元。</span><span class="sxs-lookup"><span data-stu-id="43f92-383">Match a white-space character.</span></span>|  
  
 [!code-csharp[Conceptual.Regex.Language.Options#8](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/example1.cs#8)]
 [!code-vb[Conceptual.Regex.Language.Options#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/example1.vb#8)]  
  
<a name="zerowidth_positive_lookahead_assertion"></a>
## <a name="zero-width-positive-lookahead-assertions"></a><span data-ttu-id="43f92-384">零寬度右合樣 (Positive Lookahead) 判斷提示</span><span class="sxs-lookup"><span data-stu-id="43f92-384">Zero-Width Positive Lookahead Assertions</span></span>  
 <span data-ttu-id="43f92-385">下列群組建構可定義零寬度右合樣 (Positive Lookahead) 判斷提示：</span><span class="sxs-lookup"><span data-stu-id="43f92-385">The following grouping construct defines a zero-width positive lookahead assertion:</span></span>  
  
 <span data-ttu-id="43f92-386"> subexpression`(?=`\ \** `)`</span><span class="sxs-lookup"><span data-stu-id="43f92-386">`(?=` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="43f92-387">其中 *subexpression* 是任何規則運算式模式。</span><span class="sxs-lookup"><span data-stu-id="43f92-387">where *subexpression* is any regular expression pattern.</span></span> <span data-ttu-id="43f92-388">若要讓比對成功，輸入字串必須符合 *subexpression*中的規則運算式模式，但是相符的子字串不會包含在比對結果中。</span><span class="sxs-lookup"><span data-stu-id="43f92-388">For a match to be successful, the input string must match the regular expression pattern in *subexpression*, although the matched substring is not included in the match result.</span></span> <span data-ttu-id="43f92-389">零寬度右合樣 (Positive Lookahead) 判斷提示不會回溯。</span><span class="sxs-lookup"><span data-stu-id="43f92-389">A zero-width positive lookahead assertion does not backtrack.</span></span>  
  
 <span data-ttu-id="43f92-390">通常會在規則運算式模式結尾找到零寬度右合樣 (Positive Lookahead) 判斷提示。</span><span class="sxs-lookup"><span data-stu-id="43f92-390">Typically, a zero-width positive lookahead assertion is found at the end of a regular expression pattern.</span></span> <span data-ttu-id="43f92-391">它會定義必須在字串結尾找到，以讓相符項出現的子字串，但不應包含在比對中。</span><span class="sxs-lookup"><span data-stu-id="43f92-391">It defines a substring that must be found at the end of a string for a match to occur but that should not be included in the match.</span></span> <span data-ttu-id="43f92-392">防止過度回溯也很有用。</span><span class="sxs-lookup"><span data-stu-id="43f92-392">It is also useful for preventing excessive backtracking.</span></span> <span data-ttu-id="43f92-393">您可以使用零寬度右合樣 (Positive Lookahead) 判斷提示，以確保特定擷取群組的開頭文字，符合針對該擷取群組所定義的模式子集。</span><span class="sxs-lookup"><span data-stu-id="43f92-393">You can use a zero-width positive lookahead assertion to ensure that a particular captured group begins with text that matches a subset of the pattern defined for that captured group.</span></span> <span data-ttu-id="43f92-394">例如，如果擷取群組符合連續的文字字元，您就可以使用零寬度右合樣 (Positive Lookahead) 判斷提示，要求第一個字元為英文字母大寫字元。</span><span class="sxs-lookup"><span data-stu-id="43f92-394">For example, if a capturing group matches consecutive word characters, you can use a zero-width positive lookahead assertion to require that the first character be an alphabetical uppercase character.</span></span>  
  
 <span data-ttu-id="43f92-395">下列範例使用以零寬度右合樣判斷提示，比對輸入字串中在動詞 "is" 之前的字組。</span><span class="sxs-lookup"><span data-stu-id="43f92-395">The following example uses a zero-width positive lookahead assertion to match the word that precedes the verb "is" in the input string.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#6](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/lookahead1.cs#6)]
 [!code-vb[RegularExpressions.Language.Grouping#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/lookahead1.vb#6)]  
  
 <span data-ttu-id="43f92-396">規則運算式 `\b\w+(?=\sis\b)` 的解譯方式如下表所示。</span><span class="sxs-lookup"><span data-stu-id="43f92-396">The regular expression `\b\w+(?=\sis\b)` is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="43f92-397">模式</span><span class="sxs-lookup"><span data-stu-id="43f92-397">Pattern</span></span>|<span data-ttu-id="43f92-398">描述</span><span class="sxs-lookup"><span data-stu-id="43f92-398">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="43f92-399">開始字緣比對。</span><span class="sxs-lookup"><span data-stu-id="43f92-399">Begin the match at a word boundary.</span></span>|  
|`\w+`|<span data-ttu-id="43f92-400">比對一個或多個文字字元。</span><span class="sxs-lookup"><span data-stu-id="43f92-400">Match one or more word characters.</span></span>|  
|`(?=\sis\b)`|<span data-ttu-id="43f92-401">判定文字字元後面是否接著空格字元和字串 "is"，在字邊界結束。</span><span class="sxs-lookup"><span data-stu-id="43f92-401">Determine whether the word characters are followed by a white-space character and the string "is", which ends on a word boundary.</span></span> <span data-ttu-id="43f92-402">若是如此，比對將會成功。</span><span class="sxs-lookup"><span data-stu-id="43f92-402">If so, the match is successful.</span></span>|  
  
<a name="zerowidth_negative_lookahead_assertion"></a>
## <a name="zero-width-negative-lookahead-assertions"></a><span data-ttu-id="43f92-403">零寬度右不合樣 (Negative Lookahead) 判斷提示</span><span class="sxs-lookup"><span data-stu-id="43f92-403">Zero-Width Negative Lookahead Assertions</span></span>  
 <span data-ttu-id="43f92-404">下列群組建構可定義零寬度右不合樣 (Negative Lookahead) 判斷提示：</span><span class="sxs-lookup"><span data-stu-id="43f92-404">The following grouping construct defines a zero-width negative lookahead assertion:</span></span>  
  
 <span data-ttu-id="43f92-405"> subexpression`(?!`\ \** `)`</span><span class="sxs-lookup"><span data-stu-id="43f92-405">`(?!` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="43f92-406">其中 *subexpression* 是任何規則運算式模式。</span><span class="sxs-lookup"><span data-stu-id="43f92-406">where *subexpression* is any regular expression pattern.</span></span> <span data-ttu-id="43f92-407">為了若要讓比對成功，輸入字串絕不能符合 *subexpression*中的規則運算式模式，但是相符的字串不會包含在比對結果中。</span><span class="sxs-lookup"><span data-stu-id="43f92-407">For the match to be successful, the input string must not match the regular expression pattern in *subexpression*, although the matched string is not included in the match result.</span></span>  
  
 <span data-ttu-id="43f92-408">零寬度右不合樣 (Negative Lookahead) 判斷提示通常會用在規則運算式開頭或結尾。</span><span class="sxs-lookup"><span data-stu-id="43f92-408">A zero-width negative lookahead assertion is typically used either at the beginning or at the end of a regular expression.</span></span> <span data-ttu-id="43f92-409">若是在規則運算式開頭，當規則運算式開頭定義類似但較為廣泛的模式以供比對時，此判斷提示可定義不應相符的模式。</span><span class="sxs-lookup"><span data-stu-id="43f92-409">At the beginning of a regular expression, it can define a specific pattern that should not be matched when the beginning of the regular expression defines a similar but more general pattern to be matched.</span></span> <span data-ttu-id="43f92-410">在此情況下，通常是用來限制回溯。</span><span class="sxs-lookup"><span data-stu-id="43f92-410">In this case, it is often used to limit backtracking.</span></span> <span data-ttu-id="43f92-411">若是在規則運算式結尾，則可定義不能出現在相符項結尾的子運算式。</span><span class="sxs-lookup"><span data-stu-id="43f92-411">At the end of a regular expression, it can define a subexpression that cannot occur at the end of a match.</span></span>  
  
 <span data-ttu-id="43f92-412">下列範例定義的規則運算式在規則運算式開頭使用零寬度右合樣判斷提示，以比對不是以 "un" 開頭的文字。</span><span class="sxs-lookup"><span data-stu-id="43f92-412">The following example defines a regular expression that uses a zero-width lookahead assertion at the beginning of the regular expression to match words that do not begin with "un".</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#7](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/negativelookahead1.cs#7)]
 [!code-vb[RegularExpressions.Language.Grouping#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/negativelookahead1.vb#7)]  
  
 <span data-ttu-id="43f92-413">規則運算式 `\b(?!un)\w+\b` 的解譯方式如下表所示。</span><span class="sxs-lookup"><span data-stu-id="43f92-413">The regular expression `\b(?!un)\w+\b` is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="43f92-414">模式</span><span class="sxs-lookup"><span data-stu-id="43f92-414">Pattern</span></span>|<span data-ttu-id="43f92-415">描述</span><span class="sxs-lookup"><span data-stu-id="43f92-415">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="43f92-416">開始字緣比對。</span><span class="sxs-lookup"><span data-stu-id="43f92-416">Begin the match at a word boundary.</span></span>|  
|`(?!un)`|<span data-ttu-id="43f92-417">判斷下兩個字元是否為 "un"。</span><span class="sxs-lookup"><span data-stu-id="43f92-417">Determine whether the next two characters are "un".</span></span> <span data-ttu-id="43f92-418">如果不是，才可能比對。</span><span class="sxs-lookup"><span data-stu-id="43f92-418">If they are not, a match is possible.</span></span>|  
|`\w+`|<span data-ttu-id="43f92-419">比對一個或多個文字字元。</span><span class="sxs-lookup"><span data-stu-id="43f92-419">Match one or more word characters.</span></span>|  
|`\b`|<span data-ttu-id="43f92-420">結束字緣比對。</span><span class="sxs-lookup"><span data-stu-id="43f92-420">End the match at a word boundary.</span></span>|  
  
 <span data-ttu-id="43f92-421">下列範例定義的規則運算式在規則運算式結尾使用零寬度右合樣判斷提示，以比對不是以標點符號字元結尾的文字。</span><span class="sxs-lookup"><span data-stu-id="43f92-421">The following example defines a regular expression that uses a zero-width lookahead assertion at the end of the regular expression to match words that do not end with a punctuation character.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#8](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/negativelookahead2.cs#8)]
 [!code-vb[RegularExpressions.Language.Grouping#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/negativelookahead2.vb#8)]  
  
 <span data-ttu-id="43f92-422">規則運算式 `\b\w+\b(?!\p{P})` 的解譯方式如下表所示。</span><span class="sxs-lookup"><span data-stu-id="43f92-422">The regular expression `\b\w+\b(?!\p{P})` is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="43f92-423">模式</span><span class="sxs-lookup"><span data-stu-id="43f92-423">Pattern</span></span>|<span data-ttu-id="43f92-424">描述</span><span class="sxs-lookup"><span data-stu-id="43f92-424">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="43f92-425">開始字緣比對。</span><span class="sxs-lookup"><span data-stu-id="43f92-425">Begin the match at a word boundary.</span></span>|  
|`\w+`|<span data-ttu-id="43f92-426">比對一個或多個文字字元。</span><span class="sxs-lookup"><span data-stu-id="43f92-426">Match one or more word characters.</span></span>|  
|`\b`|<span data-ttu-id="43f92-427">結束字緣比對。</span><span class="sxs-lookup"><span data-stu-id="43f92-427">End the match at a word boundary.</span></span>|  
|`\p{P})`|<span data-ttu-id="43f92-428">如果下一個字元不是標點符號 (例如句點或逗號)，則比對成功。</span><span class="sxs-lookup"><span data-stu-id="43f92-428">If the next character is not a punctuation symbol (such as a period or a comma), the match succeeds.</span></span>|  
  
<a name="zerowidth_positive_lookbehind_assertion"></a>
## <a name="zero-width-positive-lookbehind-assertions"></a><span data-ttu-id="43f92-429">零寬度左合樣 (Positive Lookbehind) 判斷提示</span><span class="sxs-lookup"><span data-stu-id="43f92-429">Zero-Width Positive Lookbehind Assertions</span></span>  
 <span data-ttu-id="43f92-430">下列群組建構可定義零寬度左合樣 (Positive Lookbehind) 判斷提示：</span><span class="sxs-lookup"><span data-stu-id="43f92-430">The following grouping construct defines a zero-width positive lookbehind assertion:</span></span>  
  
 <span data-ttu-id="43f92-431"> subexpression`(?<=`\ \** `)`</span><span class="sxs-lookup"><span data-stu-id="43f92-431">`(?<=` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="43f92-432">其中 *subexpression* 是任何規則運算式模式。</span><span class="sxs-lookup"><span data-stu-id="43f92-432">where *subexpression* is any regular expression pattern.</span></span> <span data-ttu-id="43f92-433">若要讓比對成功， *subexpression* 必須出現在目前位置左邊的輸入字串中，但是 `subexpression` 不會包含在比對結果中。</span><span class="sxs-lookup"><span data-stu-id="43f92-433">For a match to be successful, *subexpression* must occur at the input string to the left of the current position, although `subexpression` is not included in the match result.</span></span> <span data-ttu-id="43f92-434">零寬度左合樣 (Positive Lookbehind) 判斷提示不會回溯。</span><span class="sxs-lookup"><span data-stu-id="43f92-434">A zero-width positive lookbehind assertion does not backtrack.</span></span>  
  
 <span data-ttu-id="43f92-435">零寬度左合樣 (Positive Lookbehind) 判斷提示通常會用在規則運算式開頭。</span><span class="sxs-lookup"><span data-stu-id="43f92-435">Zero-width positive lookbehind assertions are typically used at the beginning of regular expressions.</span></span> <span data-ttu-id="43f92-436">其定義的模式是比對的前置條件，但不包含在比對結果中。</span><span class="sxs-lookup"><span data-stu-id="43f92-436">The pattern that they define is a precondition for a match, although it is not a part of the match result.</span></span>  
  
 <span data-ttu-id="43f92-437">例如，下列範例會比對 21 世紀年份的後兩位數 (也就是說，比對的字串前面需要有數字 "20")。</span><span class="sxs-lookup"><span data-stu-id="43f92-437">For example, the following example matches the last two digits of the year for the twenty first century (that is, it requires that the digits "20" precede the matched string).</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#9](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/lookbehind1.cs#9)]
 [!code-vb[RegularExpressions.Language.Grouping#9](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/lookbehind1.vb#9)]  
  
 <span data-ttu-id="43f92-438">規則運算式模式 `(?<=\b20)\d{2}\b` 的解譯方式如下表所示。</span><span class="sxs-lookup"><span data-stu-id="43f92-438">The regular expression pattern `(?<=\b20)\d{2}\b` is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="43f92-439">模式</span><span class="sxs-lookup"><span data-stu-id="43f92-439">Pattern</span></span>|<span data-ttu-id="43f92-440">描述</span><span class="sxs-lookup"><span data-stu-id="43f92-440">Description</span></span>|  
|-------------|-----------------|  
|`\d{2}`|<span data-ttu-id="43f92-441">比對兩個十進位數字。</span><span class="sxs-lookup"><span data-stu-id="43f92-441">Match two decimal digits.</span></span>|  
|`(?<=\b20)`|<span data-ttu-id="43f92-442">如果字邊界上的兩個十進位數字前置十進位數字 "20"，則繼續比對。</span><span class="sxs-lookup"><span data-stu-id="43f92-442">Continue the match if the two decimal digits are preceded by the decimal digits "20" on a word boundary.</span></span>|  
|`\b`|<span data-ttu-id="43f92-443">結束字緣比對。</span><span class="sxs-lookup"><span data-stu-id="43f92-443">End the match at a word boundary.</span></span>|  
  
 <span data-ttu-id="43f92-444">當擷取群組中的最後一或多個字元，必須是符合該群組規則運算式模式的字元子集時，零寬度左合樣 (Positive Lookbehind) 判斷提示也可以用來限制回溯。</span><span class="sxs-lookup"><span data-stu-id="43f92-444">Zero-width positive lookbehind assertions are also used to limit backtracking when the last character or characters in a captured group must be a subset of the characters that match that group's regular expression pattern.</span></span> <span data-ttu-id="43f92-445">例如，如果群組擷取所有連續的文字字元，您就可以使用零寬度左合樣 (Positive Lookbehind) 判斷提示，要求最後一個字元為英文字母。</span><span class="sxs-lookup"><span data-stu-id="43f92-445">For example, if a group captures all consecutive word characters, you can use a zero-width positive lookbehind assertion to require that the last character be alphabetical.</span></span>  
  
<a name="zerowidth_negative_lookbehind_assertion"></a>
## <a name="zero-width-negative-lookbehind-assertions"></a><span data-ttu-id="43f92-446">零寬度左不合樣 (Negative Lookbehind) 判斷提示</span><span class="sxs-lookup"><span data-stu-id="43f92-446">Zero-Width Negative Lookbehind Assertions</span></span>  
 <span data-ttu-id="43f92-447">下列分組建構可定義零寬度左不合樣 (Negative Lookbehind) 判斷提示：</span><span class="sxs-lookup"><span data-stu-id="43f92-447">The following grouping construct defines a zero-width negative lookbehind assertion:</span></span>  
  
 <span data-ttu-id="43f92-448"> subexpression`(?<!`\ \** `)`</span><span class="sxs-lookup"><span data-stu-id="43f92-448">`(?<!` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="43f92-449">其中 *subexpression* 是任何規則運算式模式。</span><span class="sxs-lookup"><span data-stu-id="43f92-449">where *subexpression* is any regular expression pattern.</span></span> <span data-ttu-id="43f92-450">若要讓比對成功，*subexpression* 絕不能出現在目前位置左邊的輸入字串中。</span><span class="sxs-lookup"><span data-stu-id="43f92-450">For a match to be successful, *subexpression* must not occur at the input string to the left of the current position.</span></span> <span data-ttu-id="43f92-451">不過，不符合 `subexpression` 的任何子字串都不會包含在比對結果中。</span><span class="sxs-lookup"><span data-stu-id="43f92-451">However, any substring that does not match `subexpression` is not included in the match result.</span></span>  
  
 <span data-ttu-id="43f92-452">零寬度左不合樣 (Negative Lookbehind) 判斷提示通常會用在規則運算式開頭。</span><span class="sxs-lookup"><span data-stu-id="43f92-452">Zero-width negative lookbehind assertions are typically used at the beginning of regular expressions.</span></span> <span data-ttu-id="43f92-453">其定義的模式排除了後面字串中的比對。</span><span class="sxs-lookup"><span data-stu-id="43f92-453">The pattern that they define precludes a match in the string that follows.</span></span> <span data-ttu-id="43f92-454">當擷取群組中的最後一或多個字元，絕不能是符合該群組規則運算式模式的一或多個字元時，此判斷提示也可以用來限制回溯。</span><span class="sxs-lookup"><span data-stu-id="43f92-454">They are also used to limit backtracking when the last character or characters in a captured group must not be one or more of the characters that match that group's regular expression pattern.</span></span> <span data-ttu-id="43f92-455">例如，如果群組擷取所有連續的文字字元，您就可以使用零寬度左合樣 (Positive Lookbehind) 判斷提示，要求最後一個字元不能是底線 (\_)。</span><span class="sxs-lookup"><span data-stu-id="43f92-455">For example, if a group captures all consecutive word characters, you can use a zero-width positive lookbehind assertion to require that the last character not be an underscore (\_).</span></span>  
  
 <span data-ttu-id="43f92-456">下列範例會比對週間非週末 (不是星期六也不是星期日) 任何一天的日期。</span><span class="sxs-lookup"><span data-stu-id="43f92-456">The following example matches the date for any day of the week that is not a weekend (that is, that is neither Saturday nor Sunday).</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#10](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/negativelookbehind1.cs#10)]
 [!code-vb[RegularExpressions.Language.Grouping#10](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/negativelookbehind1.vb#10)]  
  
 <span data-ttu-id="43f92-457">規則運算式模式 `(?<!(Saturday|Sunday) )\b\w+ \d{1,2}, \d{4}\b` 的解譯方式如下表所示。</span><span class="sxs-lookup"><span data-stu-id="43f92-457">The regular expression pattern `(?<!(Saturday|Sunday) )\b\w+ \d{1,2}, \d{4}\b` is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="43f92-458">模式</span><span class="sxs-lookup"><span data-stu-id="43f92-458">Pattern</span></span>|<span data-ttu-id="43f92-459">描述</span><span class="sxs-lookup"><span data-stu-id="43f92-459">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="43f92-460">開始字緣比對。</span><span class="sxs-lookup"><span data-stu-id="43f92-460">Begin the match at a word boundary.</span></span>|  
|`\w+`|<span data-ttu-id="43f92-461">比對後接空格字元的一或多個文字字元。</span><span class="sxs-lookup"><span data-stu-id="43f92-461">Match one or more word characters followed by a white-space character.</span></span>|  
|`\d{1,2},`|<span data-ttu-id="43f92-462">比對後接空格字元和逗號的一或兩個十進位數。</span><span class="sxs-lookup"><span data-stu-id="43f92-462">Match either one or two decimal digits followed by a white-space character and a comma.</span></span>|  
|`\d{4}\b`|<span data-ttu-id="43f92-463">比對四個十進位數，並且在字邊界上結束比對。</span><span class="sxs-lookup"><span data-stu-id="43f92-463">Match four decimal digits, and end the match at a word boundary.</span></span>|  
|<code>(?<!(Saturday&#124;Sunday) )</code>|<span data-ttu-id="43f92-464">如果比對項目前置文字不是後接空格的字串 "Saturday" 或 "Sunday"，則比對成功。</span><span class="sxs-lookup"><span data-stu-id="43f92-464">If the match is preceded by something other than the strings "Saturday" or "Sunday" followed by a space, the match is successful.</span></span>|  
  
<a name="atomic_groups"></a>
## <a name="atomic-groups"></a><span data-ttu-id="43f92-465">不可部分完成的群組</span><span class="sxs-lookup"><span data-stu-id="43f92-465">Atomic groups</span></span>  
 <span data-ttu-id="43f92-466">下列群組結構代表一個不可部分完成的群組（在某些其他正則運算式引擎中，當做非回溯子運算式、不可部分完成的子運算式，或僅限一次的子運算式）：</span><span class="sxs-lookup"><span data-stu-id="43f92-466">The following grouping construct represents an atomic group (known in some other regular expression engines as a nonbacktracking subexpression, an atomic subexpression, or a once-only subexpression):</span></span>
  
 <span data-ttu-id="43f92-467"> subexpression`(?>`\ \** `)`</span><span class="sxs-lookup"><span data-stu-id="43f92-467">`(?>` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="43f92-468">其中 *subexpression* 是任何規則運算式模式。</span><span class="sxs-lookup"><span data-stu-id="43f92-468">where *subexpression* is any regular expression pattern.</span></span>  
  
 <span data-ttu-id="43f92-469">一般而言，如果規則運算式包含選用性或替代性比對模式，而比對未成功，規則運算式引擎可以分支在多個方向，將輸入字串與模式比對。</span><span class="sxs-lookup"><span data-stu-id="43f92-469">Ordinarily, if a regular expression includes an optional or alternative matching pattern and a match does not succeed, the regular expression engine can branch in multiple directions to match an input string with a pattern.</span></span> <span data-ttu-id="43f92-470">如果採用第一個分支時，沒有找到比對項目，規則運算式引擎可以備份或回溯至採用第一個比對項目的點，並嘗試使用第二個分支來比對。</span><span class="sxs-lookup"><span data-stu-id="43f92-470">If a match is not found when it takes the first branch, the regular expression engine can back up or backtrack to the point where it took the first match and attempt the match using the second branch.</span></span> <span data-ttu-id="43f92-471">此程序可以一直持續到所有分支都試過為止。</span><span class="sxs-lookup"><span data-stu-id="43f92-471">This process can continue until all branches have been tried.</span></span>  
  
 <span data-ttu-id="43f92-472">`(?>`*子運算式* `)` 語言結構會停用回溯。</span><span class="sxs-lookup"><span data-stu-id="43f92-472">The `(?>`*subexpression*`)` language construct disables backtracking.</span></span> <span data-ttu-id="43f92-473">規則運算式引擎會盡可能比對輸入字串中的所有字元。</span><span class="sxs-lookup"><span data-stu-id="43f92-473">The regular expression engine will match as many characters in the input string as it can.</span></span> <span data-ttu-id="43f92-474">如果已無法進一步比對，將不會回溯嘗試替代模式比對。</span><span class="sxs-lookup"><span data-stu-id="43f92-474">When no further match is possible, it will not backtrack to attempt alternate pattern matches.</span></span> <span data-ttu-id="43f92-475">(也就是說，子運算式只會比對該子運算式單獨比對的字串，而不會嘗試依據子運算式和其後的任何子運算式來比對字串。)</span><span class="sxs-lookup"><span data-stu-id="43f92-475">(That is, the subexpression matches only strings that would be matched by the subexpression alone; it does not attempt to match a string based on the subexpression and any subexpressions that follow it.)</span></span>  
  
 <span data-ttu-id="43f92-476">如果您知道回溯會成功，則建議使用此選項。</span><span class="sxs-lookup"><span data-stu-id="43f92-476">This option is recommended if you know that backtracking will not succeed.</span></span> <span data-ttu-id="43f92-477">防止規則運算式引擎執行不必要的搜尋，以提升效能。</span><span class="sxs-lookup"><span data-stu-id="43f92-477">Preventing the regular expression engine from performing unnecessary searching improves performance.</span></span>  
  
 <span data-ttu-id="43f92-478">下列範例說明不可部分完成的群組如何修改模式比對的結果。</span><span class="sxs-lookup"><span data-stu-id="43f92-478">The following example illustrates how an atomic group modifies the results of a pattern match.</span></span> <span data-ttu-id="43f92-479">回溯規則運算式成功比對一連串重複的字元，其後面接著字邊界上出現一或多次的相同字元，而非回溯規則運算式則不成功。</span><span class="sxs-lookup"><span data-stu-id="43f92-479">The backtracking regular expression successfully matches a series of repeated characters followed by one more occurrence of the same character on a word boundary, but the nonbacktracking regular expression does not.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#11](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/nonbacktracking1.cs#11)]
 [!code-vb[RegularExpressions.Language.Grouping#11](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/nonbacktracking1.vb#11)]  
  
 <span data-ttu-id="43f92-480">非回溯規則運算式 `(?>(\w)\1+).\b` 的定義如下表所示。</span><span class="sxs-lookup"><span data-stu-id="43f92-480">The nonbacktracking regular expression `(?>(\w)\1+).\b` is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="43f92-481">模式</span><span class="sxs-lookup"><span data-stu-id="43f92-481">Pattern</span></span>|<span data-ttu-id="43f92-482">描述</span><span class="sxs-lookup"><span data-stu-id="43f92-482">Description</span></span>|  
|-------------|-----------------|  
|`(\w)`|<span data-ttu-id="43f92-483">比對單一文字字元，並將其指派給第一個擷取群組。</span><span class="sxs-lookup"><span data-stu-id="43f92-483">Match a single word character and assign it to the first capturing group.</span></span>|  
|`\1+`|<span data-ttu-id="43f92-484">比對第一個擷取子字串的值一或數次。</span><span class="sxs-lookup"><span data-stu-id="43f92-484">Match the value of the first captured substring one or more times.</span></span>|  
|`.`|<span data-ttu-id="43f92-485">比對任何字元。</span><span class="sxs-lookup"><span data-stu-id="43f92-485">Match any character.</span></span>|  
|`\b`|<span data-ttu-id="43f92-486">結束字邊界比對。</span><span class="sxs-lookup"><span data-stu-id="43f92-486">End the match on a word boundary.</span></span>|  
|`(?>(\w)\1+)`|<span data-ttu-id="43f92-487">比對出現一或數次的重複文字字元，但不要回溯比對字邊界上的最後一個字元。</span><span class="sxs-lookup"><span data-stu-id="43f92-487">Match one or more occurrences of a duplicated word character, but do not backtrack to match the last character on a word boundary.</span></span>|  
  
<a name="Objects"></a>
## <a name="grouping-constructs-and-regular-expression-objects"></a><span data-ttu-id="43f92-488">群組建構和規則運算式物件</span><span class="sxs-lookup"><span data-stu-id="43f92-488">Grouping Constructs and Regular Expression Objects</span></span>  
 <span data-ttu-id="43f92-489">規則運算式擷取群組所比對的子字串會以 <xref:System.Text.RegularExpressions.Group?displayProperty=nameWithType> 物件來代表，此物件可從 <xref:System.Text.RegularExpressions.GroupCollection?displayProperty=nameWithType> 屬性傳回的 <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> 物件來擷取。</span><span class="sxs-lookup"><span data-stu-id="43f92-489">Substrings that are matched by a regular expression capturing group are represented by <xref:System.Text.RegularExpressions.Group?displayProperty=nameWithType> objects, which can be retrieved from the <xref:System.Text.RegularExpressions.GroupCollection?displayProperty=nameWithType> object that is returned by the <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="43f92-490"><xref:System.Text.RegularExpressions.GroupCollection> 物件的填入方式如下：</span><span class="sxs-lookup"><span data-stu-id="43f92-490">The <xref:System.Text.RegularExpressions.GroupCollection> object is populated as follows:</span></span>  
  
- <span data-ttu-id="43f92-491">集合中的第一個 <xref:System.Text.RegularExpressions.Group> 物件 (索引位置為零的物件) 代表整個比對。</span><span class="sxs-lookup"><span data-stu-id="43f92-491">The first <xref:System.Text.RegularExpressions.Group> object in the collection (the object at index zero) represents the entire match.</span></span>  
  
- <span data-ttu-id="43f92-492">下一個 <xref:System.Text.RegularExpressions.Group> 物件組合代表未具名 (編號的) 擷取群組。</span><span class="sxs-lookup"><span data-stu-id="43f92-492">The next set of <xref:System.Text.RegularExpressions.Group> objects represent unnamed (numbered) capturing groups.</span></span> <span data-ttu-id="43f92-493">其出現順序會依照規則運算式中定義的順序，由左至右。</span><span class="sxs-lookup"><span data-stu-id="43f92-493">They appear in the order in which they are defined in the regular expression, from left to right.</span></span> <span data-ttu-id="43f92-494">這些群組的索引值範圍是從 1 到集合中未具名擷取群組的編號。</span><span class="sxs-lookup"><span data-stu-id="43f92-494">The index values of these groups range from 1 to the number of unnamed capturing groups in the collection.</span></span> <span data-ttu-id="43f92-495">(特定群組的索引同等於其編號的反向參考。</span><span class="sxs-lookup"><span data-stu-id="43f92-495">(The index of a particular group is equivalent to its numbered backreference.</span></span> <span data-ttu-id="43f92-496">如需反向參考的詳細資訊，請參閱 [Backreference Constructs](backreference-constructs-in-regular-expressions.md)。)</span><span class="sxs-lookup"><span data-stu-id="43f92-496">For more information about backreferences, see [Backreference Constructs](backreference-constructs-in-regular-expressions.md).)</span></span>  
  
- <span data-ttu-id="43f92-497">最後一個 <xref:System.Text.RegularExpressions.Group> 物件組合代表具名擷取群組。</span><span class="sxs-lookup"><span data-stu-id="43f92-497">The final set of <xref:System.Text.RegularExpressions.Group> objects represent named capturing groups.</span></span> <span data-ttu-id="43f92-498">其出現順序會依照規則運算式中定義的順序，由左至右。</span><span class="sxs-lookup"><span data-stu-id="43f92-498">They appear in the order in which they are defined in the regular expression, from left to right.</span></span> <span data-ttu-id="43f92-499">第一個具名擷取群組的索引值比最後一個未具名擷取群組的索引值大一。</span><span class="sxs-lookup"><span data-stu-id="43f92-499">The index value of the first named capturing group is one greater than the index of the last unnamed capturing group.</span></span> <span data-ttu-id="43f92-500">如果規則運算式中沒有未具名擷取群組，則第一個具名擷取群組的索引值為一。</span><span class="sxs-lookup"><span data-stu-id="43f92-500">If there are no unnamed capturing groups in the regular expression, the index value of the first named capturing group is one.</span></span>  
  
 <span data-ttu-id="43f92-501">如果您將數量詞套用至擷取群組，對應之 <xref:System.Text.RegularExpressions.Group> 物件的 <xref:System.Text.RegularExpressions.Capture.Value%2A?displayProperty=nameWithType>、 <xref:System.Text.RegularExpressions.Capture.Index%2A?displayProperty=nameWithType>和 <xref:System.Text.RegularExpressions.Capture.Length%2A?displayProperty=nameWithType> 屬性會反映擷取群組所擷取的最後一個子字串。</span><span class="sxs-lookup"><span data-stu-id="43f92-501">If you apply a quantifier to a capturing group, the corresponding <xref:System.Text.RegularExpressions.Group> object's <xref:System.Text.RegularExpressions.Capture.Value%2A?displayProperty=nameWithType>, <xref:System.Text.RegularExpressions.Capture.Index%2A?displayProperty=nameWithType>, and <xref:System.Text.RegularExpressions.Capture.Length%2A?displayProperty=nameWithType> properties reflect the last substring that is captured by a capturing group.</span></span> <span data-ttu-id="43f92-502">您可以擷取由群組所擷取的一組完整子字串，那些群組具有 <xref:System.Text.RegularExpressions.CaptureCollection> 屬性傳回之 <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> 物件中的數量詞。</span><span class="sxs-lookup"><span data-stu-id="43f92-502">You can retrieve a complete set of substrings that are captured by groups that have quantifiers from the <xref:System.Text.RegularExpressions.CaptureCollection> object that is returned by the <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="43f92-503">下列範例說明 <xref:System.Text.RegularExpressions.Group> 與 <xref:System.Text.RegularExpressions.Capture> 物件之間的關聯性。</span><span class="sxs-lookup"><span data-stu-id="43f92-503">The following example clarifies the relationship between the <xref:System.Text.RegularExpressions.Group> and <xref:System.Text.RegularExpressions.Capture> objects.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#4](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/objectmodel1.cs#4)]
 [!code-vb[RegularExpressions.Language.Grouping#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/objectmodel1.vb#4)]  
  
 <span data-ttu-id="43f92-504">規則運算式模式 `(\b(\w+)\W+)+` 會從字串擷取個別文字。</span><span class="sxs-lookup"><span data-stu-id="43f92-504">The regular expression pattern `(\b(\w+)\W+)+` extracts individual words from a string.</span></span> <span data-ttu-id="43f92-505">其定義方式如下表所示。</span><span class="sxs-lookup"><span data-stu-id="43f92-505">It is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="43f92-506">模式</span><span class="sxs-lookup"><span data-stu-id="43f92-506">Pattern</span></span>|<span data-ttu-id="43f92-507">描述</span><span class="sxs-lookup"><span data-stu-id="43f92-507">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="43f92-508">開始字緣比對。</span><span class="sxs-lookup"><span data-stu-id="43f92-508">Begin the match at a word boundary.</span></span>|  
|`(\w+)`|<span data-ttu-id="43f92-509">比對一個或多個文字字元。</span><span class="sxs-lookup"><span data-stu-id="43f92-509">Match one or more word characters.</span></span> <span data-ttu-id="43f92-510">這些字元共同構成一個單字。</span><span class="sxs-lookup"><span data-stu-id="43f92-510">Together, these characters form a word.</span></span> <span data-ttu-id="43f92-511">這是第二個擷取群組。</span><span class="sxs-lookup"><span data-stu-id="43f92-511">This is the second capturing group.</span></span>|  
|`\W+`|<span data-ttu-id="43f92-512">比對一或多個非文字字元。</span><span class="sxs-lookup"><span data-stu-id="43f92-512">Match one or more non-word characters.</span></span>|  
|`(\b(\w+)\W+)`|<span data-ttu-id="43f92-513">一或多次比對一或多個文字字元後面接著一或多個非文字字元的模式。</span><span class="sxs-lookup"><span data-stu-id="43f92-513">Match the pattern of one or more word characters followed by one or more non-word characters one or more times.</span></span> <span data-ttu-id="43f92-514">這是第一個擷取群組。</span><span class="sxs-lookup"><span data-stu-id="43f92-514">This is the first capturing group.</span></span>|  
  
 <span data-ttu-id="43f92-515">第二個擷取群組會比對句子中的每個字。</span><span class="sxs-lookup"><span data-stu-id="43f92-515">The second capturing group matches each word of the sentence.</span></span> <span data-ttu-id="43f92-516">第一個擷取群組會比對每個字以及接在該字後面的標點符號和空白字元。</span><span class="sxs-lookup"><span data-stu-id="43f92-516">The first capturing group matches each word along with the punctuation and white space that follow the word.</span></span> <span data-ttu-id="43f92-517">索引為 2 的 <xref:System.Text.RegularExpressions.Group> 物件會提供第二個擷取群組所比對之文字的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="43f92-517">The <xref:System.Text.RegularExpressions.Group> object whose index is 2 provides information about the text matched by the second capturing group.</span></span> <span data-ttu-id="43f92-518">您可以從 <xref:System.Text.RegularExpressions.CaptureCollection> 屬性傳回的 <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> 物件取得擷取群組所擷取的一整組文字。</span><span class="sxs-lookup"><span data-stu-id="43f92-518">The complete set of words captured by the capturing group are available from the <xref:System.Text.RegularExpressions.CaptureCollection> object returned by the <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> property.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="43f92-519">另請參閱</span><span class="sxs-lookup"><span data-stu-id="43f92-519">See also</span></span>

- [<span data-ttu-id="43f92-520">規則運算式語言 - 快速參考</span><span class="sxs-lookup"><span data-stu-id="43f92-520">Regular Expression Language - Quick Reference</span></span>](regular-expression-language-quick-reference.md)
- [<span data-ttu-id="43f92-521">回溯</span><span class="sxs-lookup"><span data-stu-id="43f92-521">Backtracking</span></span>](backtracking-in-regular-expressions.md)
