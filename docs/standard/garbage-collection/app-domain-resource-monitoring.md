---
title: 應用程式定義域資源監視
ms.date: 03/30/2017
helpviewer_keywords:
- monitoring managed memory use by application domain
- application domains, memory use
- memory use, monitoring
- application domains, resource monitoring
ms.assetid: 318bedf8-7f35-4f00-b34a-2b7b8e3fa315
ms.openlocfilehash: c4644defa5a67d9d39c4faa89943a6aa5f763eae
ms.sourcegitcommit: 965a5af7918acb0a3fd3baf342e15d511ef75188
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 11/18/2020
ms.locfileid: "94827824"
---
# <a name="application-domain-resource-monitoring"></a><span data-ttu-id="4fbc6-102">應用程式定義域資源監視</span><span class="sxs-lookup"><span data-stu-id="4fbc6-102">Application Domain Resource Monitoring</span></span>

<span data-ttu-id="4fbc6-103">應用程式定義域資源監視 (ARM) 可讓主機依應用程式定義域來監視 CPU 和記憶體的使用情況。</span><span class="sxs-lookup"><span data-stu-id="4fbc6-103">Application domain resource monitoring (ARM) enables hosts to monitor CPU and memory usage by application domain.</span></span> <span data-ttu-id="4fbc6-104">對於在長時間執行的處理序中使用許多應用程式定義域的主機 (例如 ASP.NET) 來說，這相當有用。</span><span class="sxs-lookup"><span data-stu-id="4fbc6-104">This is useful for hosts such as ASP.NET that use many application domains in a long-running process.</span></span> <span data-ttu-id="4fbc6-105">主機可以將對整個處理序的效能造成負面影響之應用程式的應用程式定義域卸載，但前提是它必須能夠識別有問題的應用程式。</span><span class="sxs-lookup"><span data-stu-id="4fbc6-105">The host can unload the application domain of an application that is adversely affecting the performance of the entire process, but only if it can identify the problematic application.</span></span> <span data-ttu-id="4fbc6-106">ARM 提供可用來協助做出此判斷的資訊。</span><span class="sxs-lookup"><span data-stu-id="4fbc6-106">ARM provides information that can be used to assist in making such decisions.</span></span>

<span data-ttu-id="4fbc6-107">例如，主機服務可能有許多應用程式在 ASP.NET 伺服器上執行。</span><span class="sxs-lookup"><span data-stu-id="4fbc6-107">For example, a hosting service might have many applications running on an ASP.NET server.</span></span> <span data-ttu-id="4fbc6-108">如果處理序中的某個應用程式開始耗用太多記憶體或太多處理器時間，主機服務可以使用 ARM 來識別造成問題的應用程式定義域。</span><span class="sxs-lookup"><span data-stu-id="4fbc6-108">If one application in the process begins consuming too much memory or too much processor time, the hosting service can use ARM to identify the application domain that is causing the problem.</span></span>

<span data-ttu-id="4fbc6-109">ARM 非常輕量，足以在即時應用程式中使用。</span><span class="sxs-lookup"><span data-stu-id="4fbc6-109">ARM is sufficiently lightweight to use in live applications.</span></span> <span data-ttu-id="4fbc6-110">您可以使用 Windows 事件追蹤 (ETW) 或直接透過受控 API 或原生 API 來存取資訊。</span><span class="sxs-lookup"><span data-stu-id="4fbc6-110">You can access the information by using event tracing for Windows (ETW) or directly through managed or native APIs.</span></span>

## <a name="enabling-resource-monitoring"></a><span data-ttu-id="4fbc6-111">啟用資源監視</span><span class="sxs-lookup"><span data-stu-id="4fbc6-111">Enabling Resource Monitoring</span></span>

<span data-ttu-id="4fbc6-112">有四種可啟用 ARM 的方式：藉由在通用語言執行平台 (CLR) 啟動時提供組態檔、藉由使用非受控裝載 API、藉由使用受控碼，或藉由接聽 ARM ETW 事件。</span><span class="sxs-lookup"><span data-stu-id="4fbc6-112">ARM can be enabled in four ways: by supplying a configuration file when the common language runtime (CLR) is started, by using an unmanaged hosting API, by using managed code, or by listening to ARM ETW events.</span></span>

<span data-ttu-id="4fbc6-113">ARM 一經啟用之後，就會立即開始收集處理序中所有應用程式定義域上的資料。如果應用程式定義域的建立時間是在啟用 ARM 之前，就會在啟用 ARM 時開始累積資料，而不是在應用程式定義域建立時。ARM 在啟用後即無法停用。</span><span class="sxs-lookup"><span data-stu-id="4fbc6-113">As soon as ARM is enabled, it begins collecting data on all application domains in the process.If an application domain was created before ARM is enabled, cumulative data starts when ARM is enabled, not when the application domain was created.Once it is enabled, ARM cannot be disabled.</span></span>

- <span data-ttu-id="4fbc6-114">您可以藉由將專案新增 [\<appDomainResourceMonitoring>](../../framework/configure-apps/file-schema/runtime/appdomainresourcemonitoring-element.md) 至設定檔，並將屬性設定為，在 CLR 啟動時啟用 ARM `enabled` `true` 。</span><span class="sxs-lookup"><span data-stu-id="4fbc6-114">You can enable ARM at CLR startup by adding the [\<appDomainResourceMonitoring>](../../framework/configure-apps/file-schema/runtime/appdomainresourcemonitoring-element.md) element to the configuration file, and setting the `enabled` attribute to `true`.</span></span> <span data-ttu-id="4fbc6-115">值為 `false` (預設值) 時，表示只有該 ARM 未在啟動時啟用；您可以稍後使用其中一個其他啟用機制來啟用它。</span><span class="sxs-lookup"><span data-stu-id="4fbc6-115">A value of `false` (the default) means only that ARM is not enabled at startup; you can activate it later by using one of the other activation mechanisms.</span></span>

- <span data-ttu-id="4fbc6-116">主機可以藉由要求 [ICLRAppDomainResourceMonitor](../../framework/unmanaged-api/hosting/iclrappdomainresourcemonitor-interface.md) 主控介面來啟用 ARM。</span><span class="sxs-lookup"><span data-stu-id="4fbc6-116">The host can enable ARM by requesting the [ICLRAppDomainResourceMonitor](../../framework/unmanaged-api/hosting/iclrappdomainresourcemonitor-interface.md) hosting interface.</span></span> <span data-ttu-id="4fbc6-117">順利取得此介面之後，便會啟用 ARM。</span><span class="sxs-lookup"><span data-stu-id="4fbc6-117">Once this interface is successfully obtained, ARM is enabled.</span></span>

- <span data-ttu-id="4fbc6-118">受控碼可以藉由將靜態 (在 Visual Basic 中為 `Shared`) <xref:System.AppDomain.MonitoringIsEnabled%2A?displayProperty=nameWithType> 屬性設定為 `true` 來啟用 ARM。</span><span class="sxs-lookup"><span data-stu-id="4fbc6-118">Managed code can enable ARM by setting the static (`Shared` in Visual Basic) <xref:System.AppDomain.MonitoringIsEnabled%2A?displayProperty=nameWithType> property to `true`.</span></span> <span data-ttu-id="4fbc6-119">設定好此屬性之後，就會立即啟用 ARM。</span><span class="sxs-lookup"><span data-stu-id="4fbc6-119">As soon as the property is set, ARM is enabled.</span></span>

- <span data-ttu-id="4fbc6-120">您可以啟動後藉由接聽 ETW 事件來啟用 ARM。</span><span class="sxs-lookup"><span data-stu-id="4fbc6-120">You can enable ARM after startup by listening to ETW events.</span></span> <span data-ttu-id="4fbc6-121">當您藉由使用 `AppDomainResourceManagementKeyword` 關鍵字來啟用公用提供者 `Microsoft-Windows-DotNETRuntime` 時，ARM 就會變成啟用並開始針對所有應用程式定義域引發事件。</span><span class="sxs-lookup"><span data-stu-id="4fbc6-121">ARM is enabled and begins raising events for all application domains when you enable the public provider `Microsoft-Windows-DotNETRuntime` by using the `AppDomainResourceManagementKeyword` keyword.</span></span> <span data-ttu-id="4fbc6-122">若要將資料與應用程式定義域及執行緒相互關聯，您必須使用 `ThreadingKeyword` 關鍵字來一併啟用 `Microsoft-Windows-DotNETRuntimeRundown` 提供者。</span><span class="sxs-lookup"><span data-stu-id="4fbc6-122">To correlate data with application domains and threads, you must also enable the `Microsoft-Windows-DotNETRuntimeRundown` provider with the `ThreadingKeyword` keyword.</span></span>

## <a name="using-arm"></a><span data-ttu-id="4fbc6-123">使用 ARM</span><span class="sxs-lookup"><span data-stu-id="4fbc6-123">Using ARM</span></span>

<span data-ttu-id="4fbc6-124">ARM 會提供應用程式定義域所使用的處理器時間總計，以及三種有關記憶體使用情況的資訊。</span><span class="sxs-lookup"><span data-stu-id="4fbc6-124">ARM provides the total processor time that is used by an application domain and three kinds of information about memory use.</span></span>

- <span data-ttu-id="4fbc6-125">**應用程式定義域的處理器時間總計 (單位為秒)**：計算方式是將作業系統所回報的執行緒時間加總，這包括所有在存留期內花時間在應用程式定義域中執行的執行緒。</span><span class="sxs-lookup"><span data-stu-id="4fbc6-125">**Total processor time for an application domain, in seconds**: This is calculated by adding up the thread times reported by the operating system for all threads that spent time executing in the application domain during its lifetime.</span></span> <span data-ttu-id="4fbc6-126">已被封鎖或睡眠中的執行緒不會使用處理器時間。</span><span class="sxs-lookup"><span data-stu-id="4fbc6-126">Blocked or sleeping threads do not use processor time.</span></span> <span data-ttu-id="4fbc6-127">當執行緒呼叫原生程式碼時，該執行緒花費在原生程式碼的時間會包含在進行呼叫之應用程式定義域的計數中。</span><span class="sxs-lookup"><span data-stu-id="4fbc6-127">When a thread calls into native code, the time that the thread spends in native code is included in the count for the application domain where the call was made.</span></span>

  - <span data-ttu-id="4fbc6-128">受控 API：<xref:System.AppDomain.MonitoringTotalProcessorTime%2A?displayProperty=nameWithType> 屬性。</span><span class="sxs-lookup"><span data-stu-id="4fbc6-128">Managed API: <xref:System.AppDomain.MonitoringTotalProcessorTime%2A?displayProperty=nameWithType> property.</span></span>

  - <span data-ttu-id="4fbc6-129">裝載 API：[ICLRAppDomainResourceMonitor::GetCurrentCpuTime](../../framework/unmanaged-api/hosting/iclrappdomainresourcemonitor-getcurrentcputime-method.md) 方法。</span><span class="sxs-lookup"><span data-stu-id="4fbc6-129">Hosting API: [ICLRAppDomainResourceMonitor::GetCurrentCpuTime](../../framework/unmanaged-api/hosting/iclrappdomainresourcemonitor-getcurrentcputime-method.md) method.</span></span>

  - <span data-ttu-id="4fbc6-130">ETW 事件：`ThreadCreated``ThreadAppDomainEnter`及 `ThreadTerminated` 事件。</span><span class="sxs-lookup"><span data-stu-id="4fbc6-130">ETW events: `ThreadCreated`, `ThreadAppDomainEnter`, and `ThreadTerminated` events.</span></span> <span data-ttu-id="4fbc6-131">如需有關提供者和關鍵字的資訊，請參閱 [CLR ETW 事件](../../framework/performance/clr-etw-events.md)中的＜AppDomain 資源監視事件＞。</span><span class="sxs-lookup"><span data-stu-id="4fbc6-131">For information about providers and keywords, see "AppDomain Resource Monitoring Events" in [CLR ETW Events](../../framework/performance/clr-etw-events.md).</span></span>

- <span data-ttu-id="4fbc6-132">**應用程式定義域在其存留期內所做的受控配置總計 (單位為位元組)**：配置總計並不一定會反映應用程式定義域所使用的記憶體，因為所配置物件的存留期可能很短。</span><span class="sxs-lookup"><span data-stu-id="4fbc6-132">**Total managed allocations made by an application domain during its lifetime, in bytes**: Total allocations do not always reflect memory use by an application domain, because the allocated objects might be short-lived.</span></span> <span data-ttu-id="4fbc6-133">不過，如果應用程式配置並釋出大量物件，配置成本就可能相當高。</span><span class="sxs-lookup"><span data-stu-id="4fbc6-133">However, if an application allocates and frees huge numbers of objects, the cost of the allocations could be significant.</span></span>

  - <span data-ttu-id="4fbc6-134">受控 API：<xref:System.AppDomain.MonitoringTotalAllocatedMemorySize%2A?displayProperty=nameWithType> 屬性。</span><span class="sxs-lookup"><span data-stu-id="4fbc6-134">Managed API: <xref:System.AppDomain.MonitoringTotalAllocatedMemorySize%2A?displayProperty=nameWithType> property.</span></span>

  - <span data-ttu-id="4fbc6-135">裝載 API：[ICLRAppDomainResourceMonitor::GetCurrentAllocated](../../framework/unmanaged-api/hosting/iclrappdomainresourcemonitor-getcurrentallocated-method.md) 方法。</span><span class="sxs-lookup"><span data-stu-id="4fbc6-135">Hosting API: [ICLRAppDomainResourceMonitor::GetCurrentAllocated](../../framework/unmanaged-api/hosting/iclrappdomainresourcemonitor-getcurrentallocated-method.md) method.</span></span>

  - <span data-ttu-id="4fbc6-136">ETW 事件：`AppDomainMemAllocated` 事件、`Allocated` 欄位。</span><span class="sxs-lookup"><span data-stu-id="4fbc6-136">ETW events: `AppDomainMemAllocated` event, `Allocated` field.</span></span>

- <span data-ttu-id="4fbc6-137">**應用程式定義域所參考並在最近的完整、阻斷式收集中未被回收的受控記憶體 (單位為位元組)**：此數字只有在進行完整、阻斷式收集後才會精確。</span><span class="sxs-lookup"><span data-stu-id="4fbc6-137">**Managed memory, in bytes, that is referenced by an application domain and that survived the most recent full, blocking collection**: This number is accurate only after a full, blocking collection.</span></span> <span data-ttu-id="4fbc6-138"> (這與並行集合相反，這會在背景中發生，且不會封鎖應用程式 ) 。例如，方法多載 <xref:System.GC.Collect?displayProperty=nameWithType> 會導致完整的封鎖集合。</span><span class="sxs-lookup"><span data-stu-id="4fbc6-138">(This is in contrast to concurrent collections, which occur in the background and do not block the application.) For example, the <xref:System.GC.Collect?displayProperty=nameWithType> method overload causes a full, blocking collection.</span></span>

  - <span data-ttu-id="4fbc6-139">受控 API：<xref:System.AppDomain.MonitoringSurvivedMemorySize%2A?displayProperty=nameWithType> 屬性。</span><span class="sxs-lookup"><span data-stu-id="4fbc6-139">Managed API: <xref:System.AppDomain.MonitoringSurvivedMemorySize%2A?displayProperty=nameWithType> property.</span></span>

  - <span data-ttu-id="4fbc6-140">裝載 API：[ICLRAppDomainResourceMonitor::GetCurrentSurvived](../../framework/unmanaged-api/hosting/iclrappdomainresourcemonitor-getcurrentsurvived-method.md) 方法、`pAppDomainBytesSurvived` 參數。</span><span class="sxs-lookup"><span data-stu-id="4fbc6-140">Hosting API: [ICLRAppDomainResourceMonitor::GetCurrentSurvived](../../framework/unmanaged-api/hosting/iclrappdomainresourcemonitor-getcurrentsurvived-method.md) method, `pAppDomainBytesSurvived` parameter.</span></span>

  - <span data-ttu-id="4fbc6-141">ETW 事件：`AppDomainMemSurvived` 事件、`Survived` 欄位。</span><span class="sxs-lookup"><span data-stu-id="4fbc6-141">ETW events: `AppDomainMemSurvived` event, `Survived` field.</span></span>

- <span data-ttu-id="4fbc6-142">**處理序所參考並在最近的完整、阻斷式收集中未被回收的受控記憶體總計 (單位為位元組)**：可以將個別應用程式定義域未被回收的記憶體與此數字做比較。</span><span class="sxs-lookup"><span data-stu-id="4fbc6-142">**Total managed memory, in bytes, that is referenced by the process and that survived the most recent full, blocking collection**: The survived memory for individual application domains can be compared to this number.</span></span>

  - <span data-ttu-id="4fbc6-143">受控 API：<xref:System.AppDomain.MonitoringSurvivedProcessMemorySize%2A?displayProperty=nameWithType> 屬性。</span><span class="sxs-lookup"><span data-stu-id="4fbc6-143">Managed API: <xref:System.AppDomain.MonitoringSurvivedProcessMemorySize%2A?displayProperty=nameWithType> property.</span></span>

  - <span data-ttu-id="4fbc6-144">裝載 API：[ICLRAppDomainResourceMonitor::GetCurrentSurvived](../../framework/unmanaged-api/hosting/iclrappdomainresourcemonitor-getcurrentsurvived-method.md) 方法、`pTotalBytesSurvived` 參數。</span><span class="sxs-lookup"><span data-stu-id="4fbc6-144">Hosting API: [ICLRAppDomainResourceMonitor::GetCurrentSurvived](../../framework/unmanaged-api/hosting/iclrappdomainresourcemonitor-getcurrentsurvived-method.md) method, `pTotalBytesSurvived` parameter.</span></span>

  - <span data-ttu-id="4fbc6-145">ETW 事件：`AppDomainMemSurvived` 事件、`ProcessSurvived` 欄位。</span><span class="sxs-lookup"><span data-stu-id="4fbc6-145">ETW events: `AppDomainMemSurvived` event, `ProcessSurvived` field.</span></span>

### <a name="determining-when-a-full-blocking-collection-occurs"></a><span data-ttu-id="4fbc6-146">判斷發生完整、阻斷式收集的時間</span><span class="sxs-lookup"><span data-stu-id="4fbc6-146">Determining When a Full, Blocking Collection Occurs</span></span>

<span data-ttu-id="4fbc6-147">若要判斷何時的未回收記憶體計數是精確的，您必須知道剛發生完整、阻斷式收集的時間。</span><span class="sxs-lookup"><span data-stu-id="4fbc6-147">To determine when counts of survived memory are accurate, you need to know when a full, blocking collection has just occurred.</span></span> <span data-ttu-id="4fbc6-148">執行這項操作的方法取決於您用來檢查 ARM 統計資料的 API。</span><span class="sxs-lookup"><span data-stu-id="4fbc6-148">The method for doing this depends on the API you use to examine ARM statistics.</span></span>

#### <a name="managed-api"></a><span data-ttu-id="4fbc6-149">受控 API</span><span class="sxs-lookup"><span data-stu-id="4fbc6-149">Managed API</span></span>

<span data-ttu-id="4fbc6-150">如果您使用 <xref:System.AppDomain> 類別的屬性，則可以使用 <xref:System.GC.RegisterForFullGCNotification%2A?displayProperty=nameWithType> 方法來註冊接收完整收集的通知。</span><span class="sxs-lookup"><span data-stu-id="4fbc6-150">If you use the properties of the <xref:System.AppDomain> class, you can use the <xref:System.GC.RegisterForFullGCNotification%2A?displayProperty=nameWithType> method to register for notification of full collections.</span></span> <span data-ttu-id="4fbc6-151">您使用的閾值並不重要，因為您是要等候收集完成，而不是使用收集方法。</span><span class="sxs-lookup"><span data-stu-id="4fbc6-151">The threshold you use is not important, because you are waiting for the completion of a collection rather than the approach of a collection.</span></span> <span data-ttu-id="4fbc6-152">您可以接著呼叫 <xref:System.GC.WaitForFullGCComplete%2A?displayProperty=nameWithType> 方法，這會進行阻斷，直到完整收集完成為止。</span><span class="sxs-lookup"><span data-stu-id="4fbc6-152">You can then call the <xref:System.GC.WaitForFullGCComplete%2A?displayProperty=nameWithType> method, which blocks until a full collection has completed.</span></span> <span data-ttu-id="4fbc6-153">您可以建立一個呼叫迴圈中方法並在方法返回時執行任何必要分析的執行緒。</span><span class="sxs-lookup"><span data-stu-id="4fbc6-153">You can create a thread that calls the method in a loop and does any necessary analysis whenever the method returns.</span></span>

<span data-ttu-id="4fbc6-154">或者，您也可以定期呼叫 <xref:System.GC.CollectionCount%2A?displayProperty=nameWithType> 方法，以查看第 2 代收集的計數是否已增加。</span><span class="sxs-lookup"><span data-stu-id="4fbc6-154">Alternatively, you can call the <xref:System.GC.CollectionCount%2A?displayProperty=nameWithType> method periodically to see if the count of generation 2 collections has increased.</span></span> <span data-ttu-id="4fbc6-155">視輪詢頻率而定，此技術可能無法精確指出完整收集的發生次數。</span><span class="sxs-lookup"><span data-stu-id="4fbc6-155">Depending on the polling frequency, this technique might not provide as accurate an indication of the occurrence of a full collection.</span></span>

#### <a name="hosting-api"></a><span data-ttu-id="4fbc6-156">裝載 API</span><span class="sxs-lookup"><span data-stu-id="4fbc6-156">Hosting API</span></span>

<span data-ttu-id="4fbc6-157">如果您使用非受控裝載 API，您的主機就必須將 [IHostGCManager](../../framework/unmanaged-api/hosting/ihostgcmanager-interface.md) 介面實作傳遞給 CLR。</span><span class="sxs-lookup"><span data-stu-id="4fbc6-157">If you use the unmanaged hosting API, your host must pass the CLR an implementation of the [IHostGCManager](../../framework/unmanaged-api/hosting/ihostgcmanager-interface.md) interface.</span></span> <span data-ttu-id="4fbc6-158">CLR 會在繼續執行發生收集時被暫止的執行緒時，呼叫 [IHostGCManager::SuspensionEnding](../../framework/unmanaged-api/hosting/ihostgcmanager-suspensionending-method.md) 方法。</span><span class="sxs-lookup"><span data-stu-id="4fbc6-158">The CLR calls the [IHostGCManager::SuspensionEnding](../../framework/unmanaged-api/hosting/ihostgcmanager-suspensionending-method.md) method when it resumes execution of threads that have been suspended while a collection occurs.</span></span> <span data-ttu-id="4fbc6-159">CLR 會將已完成的收集世代以方法參數的形式傳遞，讓主機能夠判斷該收集是完整收集還是部分收集。</span><span class="sxs-lookup"><span data-stu-id="4fbc6-159">The CLR passes the generation of the completed collection as a parameter of the method, so the host can determine whether the collection was full or partial.</span></span> <span data-ttu-id="4fbc6-160">您的 [IHostGCManager::SuspensionEnding](../../framework/unmanaged-api/hosting/ihostgcmanager-suspensionending-method.md) 方法實作可以查詢未被回收的記憶體，以確定計數是在更新後所立即擷取的計數。</span><span class="sxs-lookup"><span data-stu-id="4fbc6-160">Your implementation of the [IHostGCManager::SuspensionEnding](../../framework/unmanaged-api/hosting/ihostgcmanager-suspensionending-method.md) method can query for survived memory, to ensure that the counts are retrieved as soon as they are updated.</span></span>

## <a name="see-also"></a><span data-ttu-id="4fbc6-161">請參閱</span><span class="sxs-lookup"><span data-stu-id="4fbc6-161">See also</span></span>

- <xref:System.AppDomain.MonitoringIsEnabled%2A?displayProperty=nameWithType>
- [<span data-ttu-id="4fbc6-162">ICLRAppDomainResourceMonitor 介面</span><span class="sxs-lookup"><span data-stu-id="4fbc6-162">ICLRAppDomainResourceMonitor Interface</span></span>](../../framework/unmanaged-api/hosting/iclrappdomainresourcemonitor-interface.md)
- [\<appDomainResourceMonitoring>](../../framework/configure-apps/file-schema/runtime/appdomainresourcemonitoring-element.md)
- [<span data-ttu-id="4fbc6-163">CLR ETW 事件</span><span class="sxs-lookup"><span data-stu-id="4fbc6-163">CLR ETW Events</span></span>](../../framework/performance/clr-etw-events.md)
