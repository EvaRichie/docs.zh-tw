---
title: 記憶體回收的基本概念
description: 了解記憶體回收行程如何運作，以及如何為它設定最佳效能。
ms.date: 11/15/2019
ms.technology: dotnet-standard
helpviewer_keywords:
- garbage collection, generations
- garbage collection, background
- garbage collection, concurrent
- garbage collection, server
- garbage collection, workstation
- garbage collection, managed heap
ms.assetid: 67c5a20d-1be1-4ea7-8a9a-92b0b08658d2
ms.openlocfilehash: b70eb44c3d92e03ab4b33f81b87d48c70797cec5
ms.sourcegitcommit: 30a686fd4377fe6472aa04e215c0de711bc1c322
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 11/10/2020
ms.locfileid: "94441007"
---
# <a name="fundamentals-of-garbage-collection"></a>記憶體回收的基本概念

在 common language runtime (CLR) 中，垃圾收集行程 (GC) 可作為自動記憶體管理員。 垃圾收集行程會管理應用程式記憶體的配置和釋放。 針對使用 managed 程式碼的開發人員，這表示您不需要撰寫程式碼來執行記憶體管理工作。 自動記憶體管理可以消除常見的問題，例如忘記釋放物件，並導致記憶體流失，或嘗試存取已釋放之物件的記憶體。

本文說明垃圾收集的核心概念。

## <a name="benefits"></a>優點

垃圾收集行程提供下列優點：

- 讓開發人員不必手動釋放記憶體。

- 有效率地在 Managed 堆積上配置物件。

- 回收不再使用的物件、清除其記憶體，並且讓記憶體可供未來的配置使用。 Managed 物件會自動取得乾淨的內容以開始，因此其函式不需要初始化每個資料欄位。

- 確保某個物件無法使用另一個物件的內容，藉以提供記憶體安全性。

## <a name="fundamentals-of-memory"></a>記憶體的基本概念

下列清單摘要說明重要的 CLR 記憶體概念。

- 每個處理序都有各自獨立的虛擬位址空間。 相同電腦上的所有處理常式都會共用相同的實體記憶體和分頁檔（如果有的話）。

- 根據預設，在 32 位元電腦上，每個處理序都有 2 GB 使用者模式虛擬位址空間。

- 身為應用程式開發人員，您只會處理虛擬位址空間，絕不會直接操作實體記憶體。 記憶體回收行程會在 Managed 堆積上自動配置和釋出虛擬記憶體。

  如果您正在撰寫機器碼，則可以使用 Windows 函數來處理虛擬位址空間。 這些函式會在原生堆積上自動配置和釋出虛擬記憶體。

- 虛擬記憶體可以有三種狀態：

  | State | 描述 |
  |---------|---------|
  | 免費 | 記憶體區塊沒有任何參考，可進行配置。 |
  | 保留 | 記憶體區塊可供您使用，但是無法用於任何其他配置要求。 不過，在此記憶體區塊認可之前，您無法將資料儲存到其中。 |
  | 認可 | 記憶體區塊會指派給實體儲存區。 |

- 虛擬位址空間可能會分成片段。 這表示，位址空間中有可用的區塊，也稱為可用的洞 (Hole)。 要求虛擬記憶體配置時，虛擬記憶體管理程式必須找到大小可滿足配置要求的單一可用區塊。 即使您有 2 GB 的可用空間，但需要 2 GB 的配置將會失敗，除非所有的可用空間都在單一位址區塊中。

- 如果沒有足夠的虛擬位址空間可供保留或要認可的實體空間，您就可以用盡記憶體。

  即使實體記憶體壓力 (，也會使用分頁檔，) 的實體記憶體需求較低。 第一次實體記憶體壓力很高時，作業系統必須在實體記憶體中騰出空間來儲存資料，而且會將實體記憶體中的部分資料備份至分頁檔。 該資料在需要時才會進行分頁，因此在實體記憶體不足壓力的情況下，可能會遇到分頁。
  
### <a name="memory-allocation"></a>記憶體配置

當您初始化新的處理序 (Process) 時，Runtime 會保留一塊連續的位址空間區域，供處理序使用。 這塊保留的位址空間稱為 Managed 堆積 (Heap)。 Managed 堆積會保留即將配置給堆積中下一個物件的位址指標。 剛開始會將這個指標設定為 Managed 堆積的基底位址 (Base Address)。 所有參考類型都是在 Managed 堆積上進行配置。 當應用程式建立第一個參考型別時，會為該型別配置 Managed 堆積基底位址的記憶體。 當應用程式建立第二個物件時，記憶體回收行程會為它配置緊接在第一個物件後面位址空間的記憶體。 只要有可供使用的位址空間，記憶體回收行程就會繼續用這種方式為新的物件配置空間。

從 Managed 堆積中配置記憶體要比 Unmanaged 記憶體配置快。 由於執行時間會藉由將值加入至指標來設定物件的記憶體，因此幾乎與從堆疊配置記憶體一樣快。 此外，由於連續配置的新物件會連續儲存在 managed 堆積中，因此應用程式可以快速存取物件。

### <a name="memory-release"></a>記憶體釋放

記憶體回收行程的最佳化引擎會根據所做的配置，決定執行回收的最佳時機。 當記憶體回收行程執行回收時，會將應用程式已經不再使用的物件記憶體釋放出來。 它會檢查應用程式的 *根目錄* ，以判斷哪些物件已不再使用。 應用程式的根目錄包括靜態欄位、執行緒堆疊上的區域變數、CPU 暫存器、GC 控制碼，以及 finalize 佇列。 每一個根目錄都會參考 Managed 堆積上的物件，要不然就是設定為 Null。 垃圾收集行程可以要求這些根目錄的其餘執行時間。 使用這份清單，垃圾收集行程就會建立一個圖形，其中包含可從根連接的所有物件。

不在圖形中的物件就無法從應用程式的根目錄取得。 垃圾收集行程會將無法連線的物件視為垃圾，並釋放配置給它們的記憶體。 在回收期間，記憶體回收行程會檢查 Managed 堆積，尋找無法取得的物件所佔用的位址空間區塊。 每找到一個無法取得的物件時，它便會使用記憶體複製功能，壓縮記憶體中可取得的物件，然後釋放出為無法取得的物件所配置的位址空間區塊。 一旦壓縮完可取得物件的記憶體之後，記憶體回收行程會進行必要的指標更正，使應用程式的根目錄指向新位置中的物件。 它也會將 Managed 堆積的指標放在最後取得物件的後面。

只有在集合發現有大量無法連接的物件時，才會壓縮記憶體。 如果 Managed 堆積中的所有物件在回收之後都存留下來，就不需要壓縮記憶體。

為了改善效能，Runtime 會為大型物件配置不同堆積中的記憶體。 記憶體回收行程會自動釋放大型物件的記憶體。 不過，為了避免在記憶體中移動大型物件，此記憶體通常不會壓縮。

## <a name="conditions-for-a-garbage-collection"></a>記憶體回收的條件

當下列其中一個條件成立時，就會進行記憶體回收：

- 系統的實體記憶體不足。 這是由 OS 的低記憶體通知或主機所指示的記憶體不足通知所偵測到。

- Managed 堆積上設定物件所使用的記憶體超過可接受的臨界值。 這個臨界值會在處理序執行時持續調整。

- 已呼叫 <xref:System.GC.Collect%2A?displayProperty=nameWithType> 方法。 在幾乎所有情況下，您都不需要呼叫這個方法，因為垃圾收集行程會持續執行。 這個方法主要用於獨特的情況和測試。

## <a name="the-managed-heap"></a>Managed 堆積

CLR 初始化記憶體回收行程之後，記憶體回收行程就會配置用來儲存和管理物件的記憶體區段。 這個記憶體稱為 Managed 堆積，與作業系統中的原生堆積相反。

每個 Managed 處理序都有一個 Managed 堆積。 處理序中的所有執行緒都會對相同堆積上的物件配置記憶體。

為了保留記憶體，垃圾收集行程會呼叫 Windows [VirtualAlloc](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc) 函式，並針對 managed 應用程式一次保留一個記憶體區段。 垃圾收集行程也會視需要保留區段，並將區段釋放回作業系統 (在清除任何物件) 的情況下，呼叫 Windows [VirtualFree](/windows/desktop/api/memoryapi/nf-memoryapi-virtualfree) 函數。

> [!IMPORTANT]
> 記憶體回收行程所配置的區段大小是依實作而定，有可能在任何時間，包括在定期更新時做變更。 您的應用程式永遠都不應該對相關或根據特定區段的大小做出假設，也不應嘗試設定區段配置的可用記憶體數量。

配置在堆積上的物件越少，記憶體回收行程必須進行的工作就越少。 當您設定物件時，請勿使用超過您需求的舍入值，例如，當您只需要15個位元組時，配置32個位元組的陣列。

觸發垃圾收集時，垃圾收集行程會回收死物件所佔用的記憶體。 回收處理序會壓縮使用中物件，讓它們集合在一起，並且移除無作用物件，因而讓堆積更小。 這可確保一起配置的物件會在 managed 堆積上保持在一起，以保留其位置。

記憶體回收的干擾程度 (頻率和持續期間) 是 Managed 堆積上之配置量和未被回收記憶體數量的結果。

堆積可以視為兩個堆積的累積： [大型物件堆積](large-object-heap.md) 與小型物件堆積。 大型物件堆積包含的物件為85000個位元組且較大的物件，這些物件通常是陣列。 實例物件很少會非常大。

> [!TIP]
> 您可以設定物件在大型物件堆積上 [的閾值大小](../../core/run-time-config/garbage-collector.md#large-object-heap-threshold) 。

## <a name="generations"></a>層代

GC 演算法是根據幾個考慮：

- 壓縮部分受控堆積的記憶體比整個受控堆積更快。
- 較新物件的存留期較短，而較舊的物件則存留期較長。
- 較新的物件通常會彼此相關，並由應用程式在相同時間存取。

垃圾收集主要發生于回收存留期較短的物件。 為了將垃圾收集行程的效能優化，managed 堆積會分成三個層代，0、1和2，因此它可以個別處理長時間和存留期較長的物件。 垃圾收集行程會將新的物件儲存在層代0中。 在應用程式存留期初期建立的物件則會升階並儲存在第 1 個和第 2 個層代。 由於壓縮一部分的 managed 堆積比整個堆積更快，因此，此配置可讓垃圾收集行程釋放特定層代中的記憶體，而不是在每次執行集合時釋放整個 managed 堆積的記憶體。

- 層 **代 0** 。 這是最新的層代而且包含存留較短的物件。 存留較短的物件範例是暫存變數。 記憶體回收最常在這個層代中進行。

  新配置的物件形成新一代的物件，而且是隱含的層代0回收。 但是，如果它們是大型物件，則會移至大型物件堆積 (LOH) ，有時也稱為「層 *代 3* 」。 第3代是以邏輯方式收集作為層代2一部分的實體世代。

  大部分的物件都會在層代0回收，以進行垃圾收集，而不會存活到下一代。
  
  如果應用程式在層代0已滿時嘗試建立新的物件，垃圾收集行程會在嘗試釋放物件的位址空間時執行集合。 記憶體回收行程是從檢查第 0 個層代中的物件開始，而不是檢查 Managed 堆積中的所有物件。 第0代本身的集合通常會回收足夠的記憶體，讓應用程式繼續建立新的物件。

- **第1代** 。 這個層代包含存留較短的物件，而且當做存留較短物件與存留較長物件之間的緩衝區。

  在垃圾收集行程執行層代0的集合之後，它會壓縮可連線物件的記憶體，並將其升級至第1代。 由於回收之後存留下來的物件通常具有較長的存留期，因此才會將它們提升至較高的層代。 垃圾收集行程不需要在每次執行層代0的集合時重新檢查層代1和2中的物件。
  
  如果層代0的集合未回收足夠的記憶體讓應用程式建立新的物件，垃圾收集行程就可以執行第1代的集合，再執行第2代。 在回收之後存留下來的第 1 個層代物件則會提升至第 2 個層代。

- **第2代** 。 這個層代包含存留較長的物件。 長時間存留的物件範例是伺服器應用程式中的物件，其中包含在進程期間存留的靜態資料。

  層代2中的物件在回收之後仍會保留在層代2中，直到判斷在未來的集合中無法連接為止。
  
  大型物件堆積上的物件 (有時也稱為層 *代 3* ) 也會在層代2中收集。

當條件許可時，記憶體回收會針對特定層代進行。 回收層代是指回收該層代中的物件及其所有較新的層代。 層代2垃圾收集也稱為完整垃圾收集，因為它會回收所有層代中的物件 (也就是說，managed 堆積中的所有物件都) 。

### <a name="survival-and-promotions"></a>未回收和提升

在垃圾收集中未回收的物件稱為 survivors，而且會升級為下一代：

- 在層代0垃圾收集之後存留的物件會提升至層代1。
- 在層代1垃圾收集之後存留的物件會提升至層代2。
- 層代2垃圾收集存留下來的物件會保留在層代2中。

當垃圾收集行程在世代中偵測到生存率很高時，會增加該世代的配置閾值。 下一個集合會取得回收記憶體的大量大小。 CLR 會持續平衡兩個優先順序：不讓應用程式的工作集因為延遲垃圾收集而變得太大，而且無法讓垃圾收集執行太頻繁。

### <a name="ephemeral-generations-and-segments"></a>暫時層代和區段

因為層代0和1中的物件存留期很短，所以這些層代稱為 *暫時* 世代。

暫時層代會配置在稱為暫時區段的記憶體區段中。 記憶體回收行程所取得的每個新區段都會成為新的暫時區段，而且包含在層代 0 記憶體回收中未被回收的物件。 舊的暫時區段會成為新的層代 2 區段。

暫時區段的大小會根據系統是32位或64位，以及它正在執行 ([工作站或伺服器 GC](workstation-server-gc.md)) 的垃圾收集行程類型而有所不同。 下表顯示暫時區段的預設大小。

|工作站/伺服器 GC|32 位元|64 位元|
|-|-------------|-------------|
|工作站 GC|16 MB|256 MB|
|伺服器 GC|64 MB|4 GB|
|具有多於 4 個邏輯 CPU 的伺服器 GC|32 MB|2 GB|
|具有 > 8 個邏輯 CPU 的伺服器 GC|16 MB|1 GB|

暫時區段可能會包括層代 2 物件。 層代 2 物件可以使用多個區段 (取決於處理序所需而且記憶體允許的數目)。

暫時記憶體回收中釋放記憶體的數量會限制為暫時區段的大小。 所釋放的記憶體數量會與無作用物件所佔據的空間成正比。

## <a name="what-happens-during-a-garbage-collection"></a>記憶體回收期間進行的作業

記憶體回收具有下列階段：

- 標記階段：尋找和建立所有使用中物件的清單。

- 重新配置階段：更新即將壓縮之物件的參考。

- 壓縮階段：回收無作用物件所佔據的空間並壓縮未被回收的物件。 壓縮階段會將記憶體回收中未被回收的物件移至區段的較舊端。

  因為層代 2 回收可能會佔據多個區段，所以提升至層代 2 的物件可能會移至較舊區段。 層代 1 和層代 2 的未回收物件都可能會移至不同的區段，因為它們都會被提升至層代 2。

  一般來說，大型物件堆積 (LOH) 不會壓縮，因為複製大型物件會造成效能上的負面影響。 不過，在 .NET Core 和 .NET Framework 4.5.1 和更新版本中，您可以使用 <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> 屬性，視需要壓縮大型物件堆積。 此外，當您指定下列其中一項來設定固定限制時，會自動壓縮 LOH：

  - 容器的記憶體限制。
  - [GCHeapHardLimit](../../core/run-time-config/garbage-collector.md#heap-limit)或[GCHeapHardLimitPercent](../../core/run-time-config/garbage-collector.md#heap-limit-percent)執行時間設定選項。

記憶體回收行程會使用下列資訊來判斷物件是否使用中：

- **堆疊根目錄** 。 Just-in-Time (JIT) 編譯器和堆疊查核器所提供的堆疊變數。 JIT 優化可以延長或縮短將堆疊變數報告到垃圾收集行程中的程式碼區域。

- **垃圾收集控制碼** 。 會指向 Managed 物件，而且可由使用者程式碼或 Common Language Runtime 配置的控制代碼。

- **靜態資料** 。 應用程式定義域中可能參考其他物件的靜態物件。 每個應用程式定義域都會追蹤其靜態物件。

記憶體回收開始之前，所有 Managed 執行緒都會暫停，但觸發記憶體回收的執行緒除外。

下圖顯示觸發記憶體回收且造成其他執行緒暫停的執行緒。

![當執行緒觸發記憶體回收時](media/gc-triggered.png)

## <a name="unmanaged-resources"></a>非受控資源

對於您的應用程式所建立的大部分物件而言，您可以依賴垃圾收集來自動執行必要的記憶體管理工作。 但是，Unmanaged 資源需要明確清除。 最常見的 Unmanaged 資源類型就是包裝作業系統資源 (例如檔案控制代碼、視窗控制代碼或網路連接) 的物件。 雖然垃圾收集行程能夠追蹤封裝非受控資源之受管理物件的存留期，但是它並沒有如何清除資源的特定知識。

當您建立封裝非受控資源的物件時，建議您提供必要的程式碼，以清除公用方法中的非受控資源 `Dispose` 。 您可以提供 `Dispose` 方法，讓物件的使用者在用完物件後，明確釋放出它所佔用的記憶體。 當您使用封裝非受控資源的物件時，請務必 `Dispose` 視需要呼叫。

您也必須提供方法，讓您的非受控資源釋出，以防您類型的取用者忘記呼叫 `Dispose` 。 您可以使用安全控制碼包裝未受管理的資源，或覆寫 <xref:System.Object.Finalize?displayProperty=nameWithType> 方法。

如需清除非受控資源的詳細資訊，請參閱 [清除非受控資源](unmanaged.md)。

## <a name="see-also"></a>請參閱

- [工作站和伺服器記憶體回收](workstation-server-gc.md)
- [背景垃圾收集](background-gc.md)
- [GC 的設定選項](../../core/run-time-config/garbage-collector.md)
- [記憶體回收](index.md)
