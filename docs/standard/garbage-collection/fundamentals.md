---
title: 記憶體回收的基本概念
description: 了解記憶體回收行程如何運作，以及如何為它設定最佳效能。
ms.date: 11/15/2019
ms.technology: dotnet-standard
helpviewer_keywords:
- garbage collection, generations
- garbage collection, background
- garbage collection, concurrent
- garbage collection, server
- garbage collection, workstation
- garbage collection, managed heap
ms.assetid: 67c5a20d-1be1-4ea7-8a9a-92b0b08658d2
ms.openlocfilehash: d59f368f21964c07d371df604f0728fa6ca8ac00
ms.sourcegitcommit: 5280b2aef60a1ed99002dba44e4b9e7f6c830604
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 06/03/2020
ms.locfileid: "84307029"
---
# <a name="fundamentals-of-garbage-collection"></a><span data-ttu-id="128a2-103">記憶體回收的基本概念</span><span class="sxs-lookup"><span data-stu-id="128a2-103">Fundamentals of garbage collection</span></span>

<span data-ttu-id="128a2-104">在 common language runtime （CLR）中，垃圾收集行程（GC）可作為自動記憶體管理員。</span><span class="sxs-lookup"><span data-stu-id="128a2-104">In the common language runtime (CLR), the garbage collector (GC) serves as an automatic memory manager.</span></span> <span data-ttu-id="128a2-105">垃圾收集行程會管理應用程式的記憶體配置和釋放。</span><span class="sxs-lookup"><span data-stu-id="128a2-105">The garbage collector manages the allocation and release of memory for an application.</span></span> <span data-ttu-id="128a2-106">對於使用 managed 程式碼的開發人員，這表示您不需要撰寫程式碼來執行記憶體管理工作。</span><span class="sxs-lookup"><span data-stu-id="128a2-106">For developers working with managed code, this means that you don't have to write code to perform memory management tasks.</span></span> <span data-ttu-id="128a2-107">自動記憶體管理可以排除常見的問題，例如忘記釋放物件，並導致記憶體流失，或嘗試存取已釋放之物件的記憶體。</span><span class="sxs-lookup"><span data-stu-id="128a2-107">Automatic memory management can eliminate common problems, such as forgetting to free an object and causing a memory leak or attempting to access memory for an object that's already been freed.</span></span>

<span data-ttu-id="128a2-108">本文描述垃圾收集的核心概念。</span><span class="sxs-lookup"><span data-stu-id="128a2-108">This article describes the core concepts of garbage collection.</span></span>

## <a name="benefits"></a><span data-ttu-id="128a2-109">優點</span><span class="sxs-lookup"><span data-stu-id="128a2-109">Benefits</span></span>

<span data-ttu-id="128a2-110">垃圾收集行程提供下列優點：</span><span class="sxs-lookup"><span data-stu-id="128a2-110">The garbage collector provides the following benefits:</span></span>

- <span data-ttu-id="128a2-111">讓開發人員不必手動釋放記憶體。</span><span class="sxs-lookup"><span data-stu-id="128a2-111">Frees developers from having to manually release memory.</span></span>

- <span data-ttu-id="128a2-112">有效率地在 Managed 堆積上配置物件。</span><span class="sxs-lookup"><span data-stu-id="128a2-112">Allocates objects on the managed heap efficiently.</span></span>

- <span data-ttu-id="128a2-113">回收不再使用的物件、清除其記憶體，並且讓記憶體可供未來的配置使用。</span><span class="sxs-lookup"><span data-stu-id="128a2-113">Reclaims objects that are no longer being used, clears their memory, and keeps the memory available for future allocations.</span></span> <span data-ttu-id="128a2-114">受管理的物件會自動取得乾淨的內容，使其不需要初始化每個資料欄位。</span><span class="sxs-lookup"><span data-stu-id="128a2-114">Managed objects automatically get clean content to start with, so their constructors don't have to initialize every data field.</span></span>

- <span data-ttu-id="128a2-115">確保某個物件無法使用另一個物件的內容，藉以提供記憶體安全性。</span><span class="sxs-lookup"><span data-stu-id="128a2-115">Provides memory safety by making sure that an object cannot use the content of another object.</span></span>

## <a name="fundamentals-of-memory"></a><span data-ttu-id="128a2-116">記憶體的基本概念</span><span class="sxs-lookup"><span data-stu-id="128a2-116">Fundamentals of memory</span></span>

<span data-ttu-id="128a2-117">下列清單摘要說明重要的 CLR 記憶體概念。</span><span class="sxs-lookup"><span data-stu-id="128a2-117">The following list summarizes important CLR memory concepts.</span></span>

- <span data-ttu-id="128a2-118">每個處理序都有各自獨立的虛擬位址空間。</span><span class="sxs-lookup"><span data-stu-id="128a2-118">Each process has its own, separate virtual address space.</span></span> <span data-ttu-id="128a2-119">相同電腦上的所有處理常式都會共用相同的實體記憶體和分頁檔（如果有的話）。</span><span class="sxs-lookup"><span data-stu-id="128a2-119">All processes on the same computer share the same physical memory and the page file, if there is one.</span></span>

- <span data-ttu-id="128a2-120">根據預設，在 32 位元電腦上，每個處理序都有 2 GB 使用者模式虛擬位址空間。</span><span class="sxs-lookup"><span data-stu-id="128a2-120">By default, on 32-bit computers, each process has a 2-GB user-mode virtual address space.</span></span>

- <span data-ttu-id="128a2-121">身為應用程式開發人員，您只會處理虛擬位址空間，絕不會直接操作實體記憶體。</span><span class="sxs-lookup"><span data-stu-id="128a2-121">As an application developer, you work only with virtual address space and never manipulate physical memory directly.</span></span> <span data-ttu-id="128a2-122">記憶體回收行程會在 Managed 堆積上自動配置和釋出虛擬記憶體。</span><span class="sxs-lookup"><span data-stu-id="128a2-122">The garbage collector allocates and frees virtual memory for you on the managed heap.</span></span>

  <span data-ttu-id="128a2-123">如果您要撰寫機器碼，請使用 Windows 函數來處理虛擬位址空間。</span><span class="sxs-lookup"><span data-stu-id="128a2-123">If you're writing native code, you use Windows functions to work with the virtual address space.</span></span> <span data-ttu-id="128a2-124">這些函式會在原生堆積上自動配置和釋出虛擬記憶體。</span><span class="sxs-lookup"><span data-stu-id="128a2-124">These functions allocate and free virtual memory for you on native heaps.</span></span>

- <span data-ttu-id="128a2-125">虛擬記憶體可以有三種狀態：</span><span class="sxs-lookup"><span data-stu-id="128a2-125">Virtual memory can be in three states:</span></span>

  | <span data-ttu-id="128a2-126">州</span><span class="sxs-lookup"><span data-stu-id="128a2-126">State</span></span> | <span data-ttu-id="128a2-127">描述</span><span class="sxs-lookup"><span data-stu-id="128a2-127">Description</span></span> |
  |---------|---------|
  | <span data-ttu-id="128a2-128">免費</span><span class="sxs-lookup"><span data-stu-id="128a2-128">Free</span></span> | <span data-ttu-id="128a2-129">記憶體區塊沒有任何參考，可進行配置。</span><span class="sxs-lookup"><span data-stu-id="128a2-129">The block of memory has no references to it and is available for allocation.</span></span> |
  | <span data-ttu-id="128a2-130">Reserved</span><span class="sxs-lookup"><span data-stu-id="128a2-130">Reserved</span></span> | <span data-ttu-id="128a2-131">記憶體區塊可供您使用，但是無法用於任何其他配置要求。</span><span class="sxs-lookup"><span data-stu-id="128a2-131">The block of memory is available for your use and cannot be used for any other allocation request.</span></span> <span data-ttu-id="128a2-132">不過，在此記憶體區塊認可之前，您無法將資料儲存到其中。</span><span class="sxs-lookup"><span data-stu-id="128a2-132">However, you cannot store data to this memory block until it is committed.</span></span> |
  | <span data-ttu-id="128a2-133">認可</span><span class="sxs-lookup"><span data-stu-id="128a2-133">Committed</span></span> | <span data-ttu-id="128a2-134">記憶體區塊會指派給實體儲存區。</span><span class="sxs-lookup"><span data-stu-id="128a2-134">The block of memory is assigned to physical storage.</span></span> |

- <span data-ttu-id="128a2-135">虛擬位址空間可能會分成片段。</span><span class="sxs-lookup"><span data-stu-id="128a2-135">Virtual address space can get fragmented.</span></span> <span data-ttu-id="128a2-136">這表示，位址空間中有可用的區塊，也稱為可用的洞 (Hole)。</span><span class="sxs-lookup"><span data-stu-id="128a2-136">This means that there are free blocks, also known as holes, in the address space.</span></span> <span data-ttu-id="128a2-137">要求虛擬記憶體配置時，虛擬記憶體管理程式必須找到大小可滿足配置要求的單一可用區塊。</span><span class="sxs-lookup"><span data-stu-id="128a2-137">When a virtual memory allocation is requested, the virtual memory manager has to find a single free block that is large enough to satisfy that allocation request.</span></span> <span data-ttu-id="128a2-138">即使您有 2 GB 的可用空間，需要 2 GB 的配置也不會成功，除非該可用空間全都在單一位址區塊中。</span><span class="sxs-lookup"><span data-stu-id="128a2-138">Even if you have 2 GB of free space, an allocation that requires 2 GB will be unsuccessful unless all of that free space is in a single address block.</span></span>

- <span data-ttu-id="128a2-139">如果沒有足夠的虛擬位址空間可供保留或實體空間認可，您可以用完記憶體。</span><span class="sxs-lookup"><span data-stu-id="128a2-139">You can run out of memory if there isn't enough virtual address space to reserve or physical space to commit.</span></span>

  <span data-ttu-id="128a2-140">即使實體記憶體壓力（也就是實體記憶體的需求）偏低，也會使用分頁檔案。</span><span class="sxs-lookup"><span data-stu-id="128a2-140">The page file is used even if physical memory pressure (that is, demand for physical memory) is low.</span></span> <span data-ttu-id="128a2-141">第一次實體記憶體壓力很高時，作業系統必須在實體記憶體中騰出空間來儲存資料，而且它會將實體記憶體中的一些資料備份至分頁檔案。</span><span class="sxs-lookup"><span data-stu-id="128a2-141">The first time physical memory pressure is high, the operating system must make room in physical memory to store data, and it backs up some of the data that is in physical memory to the page file.</span></span> <span data-ttu-id="128a2-142">該資料在需要之前不會分頁，因此可能會在實體記憶體不足壓力的情況下遇到分頁。</span><span class="sxs-lookup"><span data-stu-id="128a2-142">That data is not paged until it's needed, so it's possible to encounter paging in situations where the physical memory pressure is low.</span></span>
  
### <a name="memory-allocation"></a><span data-ttu-id="128a2-143">記憶體配置</span><span class="sxs-lookup"><span data-stu-id="128a2-143">Memory allocation</span></span>

<span data-ttu-id="128a2-144">當您初始化新的處理序 (Process) 時，Runtime 會保留一塊連續的位址空間區域，供處理序使用。</span><span class="sxs-lookup"><span data-stu-id="128a2-144">When you initialize a new process, the runtime reserves a contiguous region of address space for the process.</span></span> <span data-ttu-id="128a2-145">這塊保留的位址空間稱為 Managed 堆積 (Heap)。</span><span class="sxs-lookup"><span data-stu-id="128a2-145">This reserved address space is called the managed heap.</span></span> <span data-ttu-id="128a2-146">Managed 堆積會保留即將配置給堆積中下一個物件的位址指標。</span><span class="sxs-lookup"><span data-stu-id="128a2-146">The managed heap maintains a pointer to the address where the next object in the heap will be allocated.</span></span> <span data-ttu-id="128a2-147">剛開始會將這個指標設定為 Managed 堆積的基底位址 (Base Address)。</span><span class="sxs-lookup"><span data-stu-id="128a2-147">Initially, this pointer is set to the managed heap's base address.</span></span> <span data-ttu-id="128a2-148">所有參考類型都是在 Managed 堆積上進行配置。</span><span class="sxs-lookup"><span data-stu-id="128a2-148">All reference types are allocated on the managed heap.</span></span> <span data-ttu-id="128a2-149">當應用程式建立第一個參考型別時，會為該型別配置 Managed 堆積基底位址的記憶體。</span><span class="sxs-lookup"><span data-stu-id="128a2-149">When an application creates the first reference type, memory is allocated for the type at the base address of the managed heap.</span></span> <span data-ttu-id="128a2-150">當應用程式建立第二個物件時，記憶體回收行程會為它配置緊接在第一個物件後面位址空間的記憶體。</span><span class="sxs-lookup"><span data-stu-id="128a2-150">When the application creates the next object, the garbage collector allocates memory for it in the address space immediately following the first object.</span></span> <span data-ttu-id="128a2-151">只要有可供使用的位址空間，記憶體回收行程就會繼續用這種方式為新的物件配置空間。</span><span class="sxs-lookup"><span data-stu-id="128a2-151">As long as address space is available, the garbage collector continues to allocate space for new objects in this manner.</span></span>

<span data-ttu-id="128a2-152">從 Managed 堆積中配置記憶體要比 Unmanaged 記憶體配置快。</span><span class="sxs-lookup"><span data-stu-id="128a2-152">Allocating memory from the managed heap is faster than unmanaged memory allocation.</span></span> <span data-ttu-id="128a2-153">由於執行時間會藉由將值新增至指標來設定物件的記憶體，因此幾乎與從堆疊配置記憶體一樣快。</span><span class="sxs-lookup"><span data-stu-id="128a2-153">Because the runtime allocates memory for an object by adding a value to a pointer, it's almost as fast as allocating memory from the stack.</span></span> <span data-ttu-id="128a2-154">此外，由於連續配置的新物件會連續儲存在受控堆積中，因此應用程式可以快速存取物件。</span><span class="sxs-lookup"><span data-stu-id="128a2-154">In addition, because new objects that are allocated consecutively are stored contiguously in the managed heap, an application can access the objects quickly.</span></span>

### <a name="memory-release"></a><span data-ttu-id="128a2-155">記憶體發行</span><span class="sxs-lookup"><span data-stu-id="128a2-155">Memory release</span></span>

<span data-ttu-id="128a2-156">記憶體回收行程的最佳化引擎會根據所做的配置，決定執行回收的最佳時機。</span><span class="sxs-lookup"><span data-stu-id="128a2-156">The garbage collector's optimizing engine determines the best time to perform a collection based on the allocations being made.</span></span> <span data-ttu-id="128a2-157">當記憶體回收行程執行回收時，會將應用程式已經不再使用的物件記憶體釋放出來。</span><span class="sxs-lookup"><span data-stu-id="128a2-157">When the garbage collector performs a collection, it releases the memory for objects that are no longer being used by the application.</span></span> <span data-ttu-id="128a2-158">它會檢查應用程式的*根目錄*，以判斷哪些物件已不再使用。</span><span class="sxs-lookup"><span data-stu-id="128a2-158">It determines which objects are no longer being used by examining the application's *roots*.</span></span> <span data-ttu-id="128a2-159">應用程式的根目錄包括執行緒堆疊上的靜態欄位、區域變數和參數，以及 CPU 暫存器。</span><span class="sxs-lookup"><span data-stu-id="128a2-159">An application's roots include static fields, local variables and parameters on a thread's stack, and CPU registers.</span></span> <span data-ttu-id="128a2-160">每一個根目錄都會參考 Managed 堆積上的物件，要不然就是設定為 Null。</span><span class="sxs-lookup"><span data-stu-id="128a2-160">Each root either refers to an object on the managed heap or is set to null.</span></span> <span data-ttu-id="128a2-161">記憶體回收行程可以存取 Just-in-Time (JIT) 編譯器和執行階段所保留的使用中根目錄清單。</span><span class="sxs-lookup"><span data-stu-id="128a2-161">The garbage collector has access to the list of active roots that the just-in-time (JIT) compiler and the runtime maintain.</span></span> <span data-ttu-id="128a2-162">使用這份清單，垃圾收集行程會建立一個圖形，其中包含可從根連接的所有物件。</span><span class="sxs-lookup"><span data-stu-id="128a2-162">Using this list, the garbage collector creates a graph that contains all the objects that are reachable from the roots.</span></span>

<span data-ttu-id="128a2-163">不在圖形中的物件就無法從應用程式的根目錄取得。</span><span class="sxs-lookup"><span data-stu-id="128a2-163">Objects that are not in the graph are unreachable from the application's roots.</span></span> <span data-ttu-id="128a2-164">垃圾收集行程會將無法取得的物件視為垃圾，並釋放為它們配置的記憶體。</span><span class="sxs-lookup"><span data-stu-id="128a2-164">The garbage collector considers unreachable objects garbage and releases the memory allocated for them.</span></span> <span data-ttu-id="128a2-165">在回收期間，記憶體回收行程會檢查 Managed 堆積，尋找無法取得的物件所佔用的位址空間區塊。</span><span class="sxs-lookup"><span data-stu-id="128a2-165">During a collection, the garbage collector examines the managed heap, looking for the blocks of address space occupied by unreachable objects.</span></span> <span data-ttu-id="128a2-166">每找到一個無法取得的物件時，它便會使用記憶體複製功能，壓縮記憶體中可取得的物件，然後釋放出為無法取得的物件所配置的位址空間區塊。</span><span class="sxs-lookup"><span data-stu-id="128a2-166">As it discovers each unreachable object, it uses a memory-copying function to compact the reachable objects in memory, freeing up the blocks of address spaces allocated to unreachable objects.</span></span> <span data-ttu-id="128a2-167">一旦壓縮完可取得物件的記憶體之後，記憶體回收行程會進行必要的指標更正，使應用程式的根目錄指向新位置中的物件。</span><span class="sxs-lookup"><span data-stu-id="128a2-167">Once the memory for the reachable objects has been compacted, the garbage collector makes the necessary pointer corrections so that the application's roots point to the objects in their new locations.</span></span> <span data-ttu-id="128a2-168">它也會將 Managed 堆積的指標放在最後取得物件的後面。</span><span class="sxs-lookup"><span data-stu-id="128a2-168">It also positions the managed heap's pointer after the last reachable object.</span></span>

<span data-ttu-id="128a2-169">只有在集合發現大量無法連線的物件時，才會壓縮記憶體。</span><span class="sxs-lookup"><span data-stu-id="128a2-169">Memory is compacted only if a collection discovers a significant number of unreachable objects.</span></span> <span data-ttu-id="128a2-170">如果 Managed 堆積中的所有物件在回收之後都存留下來，就不需要壓縮記憶體。</span><span class="sxs-lookup"><span data-stu-id="128a2-170">If all the objects in the managed heap survive a collection, then there is no need for memory compaction.</span></span>

<span data-ttu-id="128a2-171">為了改善效能，Runtime 會為大型物件配置不同堆積中的記憶體。</span><span class="sxs-lookup"><span data-stu-id="128a2-171">To improve performance, the runtime allocates memory for large objects in a separate heap.</span></span> <span data-ttu-id="128a2-172">記憶體回收行程會自動釋放大型物件的記憶體。</span><span class="sxs-lookup"><span data-stu-id="128a2-172">The garbage collector automatically releases the memory for large objects.</span></span> <span data-ttu-id="128a2-173">不過，為了避免在記憶體中移動大型物件，此記憶體通常不會壓縮。</span><span class="sxs-lookup"><span data-stu-id="128a2-173">However, to avoid moving large objects in memory, this memory is usually not compacted.</span></span>

## <a name="conditions-for-a-garbage-collection"></a><span data-ttu-id="128a2-174">記憶體回收的條件</span><span class="sxs-lookup"><span data-stu-id="128a2-174">Conditions for a garbage collection</span></span>

<span data-ttu-id="128a2-175">當下列其中一個條件成立時，就會進行記憶體回收：</span><span class="sxs-lookup"><span data-stu-id="128a2-175">Garbage collection occurs when one of the following conditions is true:</span></span>

- <span data-ttu-id="128a2-176">系統的實體記憶體不足。</span><span class="sxs-lookup"><span data-stu-id="128a2-176">The system has low physical memory.</span></span> <span data-ttu-id="128a2-177">這是由作業系統的低記憶體通知或主機所指示的記憶體不足所偵測到。</span><span class="sxs-lookup"><span data-stu-id="128a2-177">This is detected by either the low memory notification from the OS or low memory as indicated by the host.</span></span>

- <span data-ttu-id="128a2-178">受控堆積上的已設定物件所使用的記憶體超過可接受的閾值。</span><span class="sxs-lookup"><span data-stu-id="128a2-178">The memory that's used by allocated objects on the managed heap surpasses an acceptable threshold.</span></span> <span data-ttu-id="128a2-179">這個臨界值會在處理序執行時持續調整。</span><span class="sxs-lookup"><span data-stu-id="128a2-179">This threshold is continuously adjusted as the process runs.</span></span>

- <span data-ttu-id="128a2-180">已呼叫 <xref:System.GC.Collect%2A?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="128a2-180">The <xref:System.GC.Collect%2A?displayProperty=nameWithType> method is called.</span></span> <span data-ttu-id="128a2-181">幾乎在所有情況下，您都不需要呼叫這個方法，因為垃圾收集行程會持續執行。</span><span class="sxs-lookup"><span data-stu-id="128a2-181">In almost all cases, you don't have to call this method, because the garbage collector runs continuously.</span></span> <span data-ttu-id="128a2-182">這個方法主要用於獨特的情況和測試。</span><span class="sxs-lookup"><span data-stu-id="128a2-182">This method is primarily used for unique situations and testing.</span></span>

## <a name="the-managed-heap"></a><span data-ttu-id="128a2-183">Managed 堆積</span><span class="sxs-lookup"><span data-stu-id="128a2-183">The managed heap</span></span>

<span data-ttu-id="128a2-184">CLR 初始化記憶體回收行程之後，記憶體回收行程就會配置用來儲存和管理物件的記憶體區段。</span><span class="sxs-lookup"><span data-stu-id="128a2-184">After the garbage collector is initialized by the CLR, it allocates a segment of memory to store and manage objects.</span></span> <span data-ttu-id="128a2-185">這個記憶體稱為 Managed 堆積，與作業系統中的原生堆積相反。</span><span class="sxs-lookup"><span data-stu-id="128a2-185">This memory is called the managed heap, as opposed to a native heap in the operating system.</span></span>

<span data-ttu-id="128a2-186">每個 Managed 處理序都有一個 Managed 堆積。</span><span class="sxs-lookup"><span data-stu-id="128a2-186">There is a managed heap for each managed process.</span></span> <span data-ttu-id="128a2-187">處理序中的所有執行緒都會對相同堆積上的物件配置記憶體。</span><span class="sxs-lookup"><span data-stu-id="128a2-187">All threads in the process allocate memory for objects on the same heap.</span></span>

<span data-ttu-id="128a2-188">為了保留記憶體，垃圾收集行程會呼叫 Windows [VirtualAlloc](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc)函式，並針對 managed 應用程式一次保留一個記憶體區段。</span><span class="sxs-lookup"><span data-stu-id="128a2-188">To reserve memory, the garbage collector calls the Windows [VirtualAlloc](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc) function and reserves one segment of memory at a time for managed applications.</span></span> <span data-ttu-id="128a2-189">垃圾收集行程也會視需要保留區段，並藉由呼叫 Windows [VirtualFree](/windows/desktop/api/memoryapi/nf-memoryapi-virtualfree)函數，將區段釋放回作業系統（在清除任何物件之後）。</span><span class="sxs-lookup"><span data-stu-id="128a2-189">The garbage collector also reserves segments, as needed, and releases segments back to the operating system (after clearing them of any objects) by calling the Windows [VirtualFree](/windows/desktop/api/memoryapi/nf-memoryapi-virtualfree) function.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="128a2-190">記憶體回收行程所配置的區段大小是依實作而定，有可能在任何時間，包括在定期更新時做變更。</span><span class="sxs-lookup"><span data-stu-id="128a2-190">The size of segments allocated by the garbage collector is implementation-specific and is subject to change at any time, including in periodic updates.</span></span> <span data-ttu-id="128a2-191">您的應用程式永遠都不應該對相關或根據特定區段的大小做出假設，也不應嘗試設定區段配置的可用記憶體數量。</span><span class="sxs-lookup"><span data-stu-id="128a2-191">Your app should never make assumptions about or depend on a particular segment size, nor should it attempt to configure the amount of memory available for segment allocations.</span></span>

<span data-ttu-id="128a2-192">配置在堆積上的物件越少，記憶體回收行程必須進行的工作就越少。</span><span class="sxs-lookup"><span data-stu-id="128a2-192">The fewer objects allocated on the heap, the less work the garbage collector has to do.</span></span> <span data-ttu-id="128a2-193">當您設定物件時，請勿使用超出您需求的進位值，例如，當您只需要15個位元組時，會配置32個位元組的陣列。</span><span class="sxs-lookup"><span data-stu-id="128a2-193">When you allocate objects, don't use rounded-up values that exceed your needs, such as allocating an array of 32 bytes when you need only 15 bytes.</span></span>

<span data-ttu-id="128a2-194">觸發垃圾收集時，垃圾收集行程會回收死物件所佔用的記憶體。</span><span class="sxs-lookup"><span data-stu-id="128a2-194">When a garbage collection is triggered, the garbage collector reclaims the memory that's occupied by dead objects.</span></span> <span data-ttu-id="128a2-195">回收處理序會壓縮使用中物件，讓它們集合在一起，並且移除無作用物件，因而讓堆積更小。</span><span class="sxs-lookup"><span data-stu-id="128a2-195">The reclaiming process compacts live objects so that they are moved together, and the dead space is removed, thereby making the heap smaller.</span></span> <span data-ttu-id="128a2-196">這可確保在一起配置的物件會在受控堆積上保持在一起，以保留其位置。</span><span class="sxs-lookup"><span data-stu-id="128a2-196">This ensures that objects that are allocated together stay together on the managed heap to preserve their locality.</span></span>

<span data-ttu-id="128a2-197">記憶體回收的干擾程度 (頻率和持續期間) 是 Managed 堆積上之配置量和未被回收記憶體數量的結果。</span><span class="sxs-lookup"><span data-stu-id="128a2-197">The intrusiveness (frequency and duration) of garbage collections is the result of the volume of allocations and the amount of survived memory on the managed heap.</span></span>

<span data-ttu-id="128a2-198">可以將堆積視為兩個堆積的累積：[大型物件](large-object-heap.md)堆積和小型物件堆積。</span><span class="sxs-lookup"><span data-stu-id="128a2-198">The heap can be considered as the accumulation of two heaps: the [large object heap](large-object-heap.md) and the small object heap.</span></span> <span data-ttu-id="128a2-199">大型物件堆積包含85000個位元組且較大的物件，通常是陣列。</span><span class="sxs-lookup"><span data-stu-id="128a2-199">The large object heap contains objects that are 85,000 bytes and larger, which are usually arrays.</span></span> <span data-ttu-id="128a2-200">實例物件很少會非常大。</span><span class="sxs-lookup"><span data-stu-id="128a2-200">It's rare for an instance object to be extremely large.</span></span>

> [!TIP]
> <span data-ttu-id="128a2-201">您可以設定物件在大型物件堆積上[的臨界值大小](../../core/run-time-config/garbage-collector.md#large-object-heap-threshold)。</span><span class="sxs-lookup"><span data-stu-id="128a2-201">You can [configure the threshold size](../../core/run-time-config/garbage-collector.md#large-object-heap-threshold) for objects to go on the large object heap.</span></span>

## <a name="generations"></a><span data-ttu-id="128a2-202">層代</span><span class="sxs-lookup"><span data-stu-id="128a2-202">Generations</span></span>

<span data-ttu-id="128a2-203">GC 演算法是以數個考慮為基礎：</span><span class="sxs-lookup"><span data-stu-id="128a2-203">The GC algorithm is based on several considerations:</span></span>

- <span data-ttu-id="128a2-204">壓縮部分 managed 堆積的記憶體比整個 managed 堆積更快。</span><span class="sxs-lookup"><span data-stu-id="128a2-204">It's faster to compact the memory for a portion of the managed heap than for the entire managed heap.</span></span>
- <span data-ttu-id="128a2-205">較新的物件具有較短的存留期，而較舊的物件則具有較長</span><span class="sxs-lookup"><span data-stu-id="128a2-205">Newer objects have shorter lifetimes and older objects have longer lifetimes.</span></span>
- <span data-ttu-id="128a2-206">較新的物件通常會彼此相關，而且應用程式會在同一時間進行存取。</span><span class="sxs-lookup"><span data-stu-id="128a2-206">Newer objects tend to be related to each other and accessed by the application around the same time.</span></span>

<span data-ttu-id="128a2-207">垃圾收集主要是在回收短期的物件時執行。</span><span class="sxs-lookup"><span data-stu-id="128a2-207">Garbage collection primarily occurs with the reclamation of short-lived objects.</span></span> <span data-ttu-id="128a2-208">為了優化垃圾收集行程的效能，受控堆積分成三個層代，0、1和2，因此可以分別處理長時間存留和短期的物件。</span><span class="sxs-lookup"><span data-stu-id="128a2-208">To optimize the performance of the garbage collector, the managed heap is divided into three generations, 0, 1, and 2, so it can handle long-lived and short-lived objects separately.</span></span> <span data-ttu-id="128a2-209">垃圾收集行程會將新的物件儲存在層代0中。</span><span class="sxs-lookup"><span data-stu-id="128a2-209">The garbage collector stores new objects in generation 0.</span></span> <span data-ttu-id="128a2-210">在應用程式存留期初期建立的物件則會升階並儲存在第 1 個和第 2 個層代。</span><span class="sxs-lookup"><span data-stu-id="128a2-210">Objects created early in the application's lifetime that survive collections are promoted and stored in generations 1 and 2.</span></span> <span data-ttu-id="128a2-211">由於壓縮部分 managed 堆積的速度比整個堆積更快，因此此配置可讓垃圾收集行程釋放特定層代中的記憶體，而不是在每次執行集合時釋放整個 managed 堆積的記憶體。</span><span class="sxs-lookup"><span data-stu-id="128a2-211">Because it's faster to compact a portion of the managed heap than the entire heap, this scheme allows the garbage collector to release the memory in a specific generation rather than release the memory for the entire managed heap each time it performs a collection.</span></span>

- <span data-ttu-id="128a2-212">層**代 0**。</span><span class="sxs-lookup"><span data-stu-id="128a2-212">**Generation 0**.</span></span> <span data-ttu-id="128a2-213">這是最新的層代而且包含存留較短的物件。</span><span class="sxs-lookup"><span data-stu-id="128a2-213">This is the youngest generation and contains short-lived objects.</span></span> <span data-ttu-id="128a2-214">存留較短的物件範例是暫存變數。</span><span class="sxs-lookup"><span data-stu-id="128a2-214">An example of a short-lived object is a temporary variable.</span></span> <span data-ttu-id="128a2-215">記憶體回收最常在這個層代中進行。</span><span class="sxs-lookup"><span data-stu-id="128a2-215">Garbage collection occurs most frequently in this generation.</span></span>

  <span data-ttu-id="128a2-216">新配置的物件會形成新一代的物件，而且是隱含的層代0集合。</span><span class="sxs-lookup"><span data-stu-id="128a2-216">Newly allocated objects form a new generation of objects and are implicitly generation 0 collections.</span></span> <span data-ttu-id="128a2-217">不過，如果它們是大型物件，則會移至大型物件堆積（LOH），這有時稱為「層*代 3*」。</span><span class="sxs-lookup"><span data-stu-id="128a2-217">However, if they are large objects, they go on the large object heap (LOH), which is sometimes referred to as *generation 3*.</span></span> <span data-ttu-id="128a2-218">第3代是以邏輯方式在層代2中收集的實體世代。</span><span class="sxs-lookup"><span data-stu-id="128a2-218">Generation 3 is a physical generation that's logically collected as part of generation 2.</span></span>

  <span data-ttu-id="128a2-219">大部分物件都會在層代0回收以進行垃圾收集，而不會存留到下一代。</span><span class="sxs-lookup"><span data-stu-id="128a2-219">Most objects are reclaimed for garbage collection in generation 0 and don't survive to the next generation.</span></span>
  
  <span data-ttu-id="128a2-220">如果應用程式在第0個層代已滿時嘗試建立新的物件，垃圾收集行程就會執行集合，以嘗試釋放物件的位址空間。</span><span class="sxs-lookup"><span data-stu-id="128a2-220">If an application attempts to create a new object when generation 0 is full, the garbage collector performs a collection in an attempt to free address space for the object.</span></span> <span data-ttu-id="128a2-221">記憶體回收行程是從檢查第 0 個層代中的物件開始，而不是檢查 Managed 堆積中的所有物件。</span><span class="sxs-lookup"><span data-stu-id="128a2-221">The garbage collector starts by examining the objects in generation 0 rather than all objects in the managed heap.</span></span> <span data-ttu-id="128a2-222">層代0的集合本身通常會回收足夠的記憶體，讓應用程式繼續建立新的物件。</span><span class="sxs-lookup"><span data-stu-id="128a2-222">A collection of generation 0 alone often reclaims enough memory to enable the application to continue creating new objects.</span></span>

- <span data-ttu-id="128a2-223">**第1代**。</span><span class="sxs-lookup"><span data-stu-id="128a2-223">**Generation 1**.</span></span> <span data-ttu-id="128a2-224">這個層代包含存留較短的物件，而且當做存留較短物件與存留較長物件之間的緩衝區。</span><span class="sxs-lookup"><span data-stu-id="128a2-224">This generation contains short-lived objects and serves as a buffer between short-lived objects and long-lived objects.</span></span>

  <span data-ttu-id="128a2-225">在垃圾收集行程執行層代0的集合之後，它會壓縮可連線物件的記憶體，並將其升級至層代1。</span><span class="sxs-lookup"><span data-stu-id="128a2-225">After the garbage collector performs a collection of generation 0, it compacts the memory for the reachable objects and promotes them to generation 1.</span></span> <span data-ttu-id="128a2-226">由於回收之後存留下來的物件通常具有較長的存留期，因此才會將它們提升至較高的層代。</span><span class="sxs-lookup"><span data-stu-id="128a2-226">Because objects that survive collections tend to have longer lifetimes, it makes sense to promote them to a higher generation.</span></span> <span data-ttu-id="128a2-227">垃圾收集行程每次執行層代0的集合時，都不需要重新檢查第1層和第2代中的物件。</span><span class="sxs-lookup"><span data-stu-id="128a2-227">The garbage collector doesn't have to reexamine the objects in generations 1 and 2 each time it performs a collection of generation 0.</span></span>
  
  <span data-ttu-id="128a2-228">如果層代0的集合不會回收足夠的記憶體，讓應用程式建立新的物件，垃圾收集行程就可以執行層代1的集合，然後第2代。</span><span class="sxs-lookup"><span data-stu-id="128a2-228">If a collection of generation 0 does not reclaim enough memory for the application to create a new object, the garbage collector can perform a collection of generation 1, then generation 2.</span></span> <span data-ttu-id="128a2-229">在回收之後存留下來的第 1 個層代物件則會提升至第 2 個層代。</span><span class="sxs-lookup"><span data-stu-id="128a2-229">Objects in generation 1 that survive collections are promoted to generation 2.</span></span>

- <span data-ttu-id="128a2-230">**第2代**。</span><span class="sxs-lookup"><span data-stu-id="128a2-230">**Generation 2**.</span></span> <span data-ttu-id="128a2-231">這個層代包含存留較長的物件。</span><span class="sxs-lookup"><span data-stu-id="128a2-231">This generation contains long-lived objects.</span></span> <span data-ttu-id="128a2-232">長時間存留物件的範例是伺服器應用程式中的物件，其中包含在進程期間即時的靜態資料。</span><span class="sxs-lookup"><span data-stu-id="128a2-232">An example of a long-lived object is an object in a server application that contains static data that's live for the duration of the process.</span></span>

  <span data-ttu-id="128a2-233">第2代中的物件在回收後仍會保留在層代2中，直到判斷未來的集合無法連線為止。</span><span class="sxs-lookup"><span data-stu-id="128a2-233">Objects in generation 2 that survive a collection remain in generation 2 until they are determined to be unreachable in a future collection.</span></span>
  
  <span data-ttu-id="128a2-234">在「層代2」中也會收集大型物件堆積上的物件（有時也稱為「層*代 3*」）。</span><span class="sxs-lookup"><span data-stu-id="128a2-234">Objects on the large object heap (which is sometimes referred to as *generation 3*) are also collected in generation 2.</span></span>

<span data-ttu-id="128a2-235">當條件許可時，記憶體回收會針對特定層代進行。</span><span class="sxs-lookup"><span data-stu-id="128a2-235">Garbage collections occur on specific generations as conditions warrant.</span></span> <span data-ttu-id="128a2-236">回收層代是指回收該層代中的物件及其所有較新的層代。</span><span class="sxs-lookup"><span data-stu-id="128a2-236">Collecting a generation means collecting objects in that generation and all its younger generations.</span></span> <span data-ttu-id="128a2-237">層代2垃圾收集也稱為完整垃圾收集，因為它會回收所有層代中的物件（也就是 managed 堆積中的所有物件）。</span><span class="sxs-lookup"><span data-stu-id="128a2-237">A generation 2 garbage collection is also known as a full garbage collection, because it reclaims objects in all generations (that is, all objects in the managed heap).</span></span>

### <a name="survival-and-promotions"></a><span data-ttu-id="128a2-238">未回收和提升</span><span class="sxs-lookup"><span data-stu-id="128a2-238">Survival and promotions</span></span>

<span data-ttu-id="128a2-239">未在垃圾收集中回收的物件稱為「survivors」，並會升級為下一代：</span><span class="sxs-lookup"><span data-stu-id="128a2-239">Objects that are not reclaimed in a garbage collection are known as survivors and are promoted to the next generation:</span></span>

- <span data-ttu-id="128a2-240">在層代0垃圾收集後存留的物件會升級至層代1。</span><span class="sxs-lookup"><span data-stu-id="128a2-240">Objects that survive a generation 0 garbage collection are promoted to generation 1.</span></span>
- <span data-ttu-id="128a2-241">在層代1垃圾收集之後的物件會升級為層代2。</span><span class="sxs-lookup"><span data-stu-id="128a2-241">Objects that survive a generation 1 garbage collection are promoted to generation 2.</span></span>
- <span data-ttu-id="128a2-242">在層代2垃圾收集之後存留的物件會保留在第2代。</span><span class="sxs-lookup"><span data-stu-id="128a2-242">Objects that survive a generation 2 garbage collection remain in generation 2.</span></span>

<span data-ttu-id="128a2-243">當垃圾收集行程偵測到產生中的生存率很高時，它會增加該世代的配置臨界值。</span><span class="sxs-lookup"><span data-stu-id="128a2-243">When the garbage collector detects that the survival rate is high in a generation, it increases the threshold of allocations for that generation.</span></span> <span data-ttu-id="128a2-244">下一個集合會取得大量回收的記憶體大小。</span><span class="sxs-lookup"><span data-stu-id="128a2-244">The next collection gets a substantial size of reclaimed memory.</span></span> <span data-ttu-id="128a2-245">CLR 會持續平衡兩個優先順序：不讓應用程式的工作集變得太大，因為會延遲垃圾收集，而不會讓垃圾收集的執行頻率太高。</span><span class="sxs-lookup"><span data-stu-id="128a2-245">The CLR continually balances two priorities: not letting an application's working set get too large by delaying garbage collection and not letting the garbage collection run too frequently.</span></span>

### <a name="ephemeral-generations-and-segments"></a><span data-ttu-id="128a2-246">暫時層代和區段</span><span class="sxs-lookup"><span data-stu-id="128a2-246">Ephemeral generations and segments</span></span>

<span data-ttu-id="128a2-247">因為層代0和1中的物件存留期很短，所以這些層代稱為*暫時層代*。</span><span class="sxs-lookup"><span data-stu-id="128a2-247">Because objects in generations 0 and 1 are short-lived, these generations are known as the *ephemeral generations*.</span></span>

<span data-ttu-id="128a2-248">暫時層代會配置在稱為暫時區段的記憶體區段中。</span><span class="sxs-lookup"><span data-stu-id="128a2-248">Ephemeral generations are allocated in the memory segment that's known as the ephemeral segment.</span></span> <span data-ttu-id="128a2-249">記憶體回收行程所取得的每個新區段都會成為新的暫時區段，而且包含在層代 0 記憶體回收中未被回收的物件。</span><span class="sxs-lookup"><span data-stu-id="128a2-249">Each new segment acquired by the garbage collector becomes the new ephemeral segment and contains the objects that survived a generation 0 garbage collection.</span></span> <span data-ttu-id="128a2-250">舊的暫時區段會成為新的層代 2 區段。</span><span class="sxs-lookup"><span data-stu-id="128a2-250">The old ephemeral segment becomes the new generation 2 segment.</span></span>

<span data-ttu-id="128a2-251">暫時區段的大小會根據系統是32位還是64位，以及它正在執行的垃圾收集行程類型而有所不同（[工作站或伺服器 GC](workstation-server-gc.md)）。</span><span class="sxs-lookup"><span data-stu-id="128a2-251">The size of the ephemeral segment varies depending on whether a system is 32-bit or 64-bit and on the type of garbage collector it is running ([workstation or server GC](workstation-server-gc.md)).</span></span> <span data-ttu-id="128a2-252">下表顯示暫時區段的預設大小。</span><span class="sxs-lookup"><span data-stu-id="128a2-252">The following table shows the default sizes of the ephemeral segment.</span></span>

|<span data-ttu-id="128a2-253">工作站/伺服器 GC</span><span class="sxs-lookup"><span data-stu-id="128a2-253">Workstation/server GC</span></span>|<span data-ttu-id="128a2-254">32 位元</span><span class="sxs-lookup"><span data-stu-id="128a2-254">32-bit</span></span>|<span data-ttu-id="128a2-255">64 位元</span><span class="sxs-lookup"><span data-stu-id="128a2-255">64-bit</span></span>|
|-|-------------|-------------|
|<span data-ttu-id="128a2-256">工作站 GC</span><span class="sxs-lookup"><span data-stu-id="128a2-256">Workstation GC</span></span>|<span data-ttu-id="128a2-257">16 MB</span><span class="sxs-lookup"><span data-stu-id="128a2-257">16 MB</span></span>|<span data-ttu-id="128a2-258">256 MB</span><span class="sxs-lookup"><span data-stu-id="128a2-258">256 MB</span></span>|
|<span data-ttu-id="128a2-259">伺服器 GC</span><span class="sxs-lookup"><span data-stu-id="128a2-259">Server GC</span></span>|<span data-ttu-id="128a2-260">64 MB</span><span class="sxs-lookup"><span data-stu-id="128a2-260">64 MB</span></span>|<span data-ttu-id="128a2-261">4 GB</span><span class="sxs-lookup"><span data-stu-id="128a2-261">4 GB</span></span>|
|<span data-ttu-id="128a2-262">具有多於 4 個邏輯 CPU 的伺服器 GC</span><span class="sxs-lookup"><span data-stu-id="128a2-262">Server GC with > 4 logical CPUs</span></span>|<span data-ttu-id="128a2-263">32 MB</span><span class="sxs-lookup"><span data-stu-id="128a2-263">32 MB</span></span>|<span data-ttu-id="128a2-264">2 GB</span><span class="sxs-lookup"><span data-stu-id="128a2-264">2 GB</span></span>|
|<span data-ttu-id="128a2-265">具有 > 8 個邏輯 CPU 的伺服器 GC</span><span class="sxs-lookup"><span data-stu-id="128a2-265">Server GC with > 8 logical CPUs</span></span>|<span data-ttu-id="128a2-266">16 MB</span><span class="sxs-lookup"><span data-stu-id="128a2-266">16 MB</span></span>|<span data-ttu-id="128a2-267">1 GB</span><span class="sxs-lookup"><span data-stu-id="128a2-267">1 GB</span></span>|

<span data-ttu-id="128a2-268">暫時區段可能會包括層代 2 物件。</span><span class="sxs-lookup"><span data-stu-id="128a2-268">The ephemeral segment can include generation 2 objects.</span></span> <span data-ttu-id="128a2-269">層代 2 物件可以使用多個區段 (取決於處理序所需而且記憶體允許的數目)。</span><span class="sxs-lookup"><span data-stu-id="128a2-269">Generation 2 objects can use multiple segments (as many as your process requires and memory allows for).</span></span>

<span data-ttu-id="128a2-270">暫時記憶體回收中釋放記憶體的數量會限制為暫時區段的大小。</span><span class="sxs-lookup"><span data-stu-id="128a2-270">The amount of freed memory from an ephemeral garbage collection is limited to the size of the ephemeral segment.</span></span> <span data-ttu-id="128a2-271">所釋放的記憶體數量會與無作用物件所佔據的空間成正比。</span><span class="sxs-lookup"><span data-stu-id="128a2-271">The amount of memory that is freed is proportional to the space that was occupied by the dead objects.</span></span>

## <a name="what-happens-during-a-garbage-collection"></a><span data-ttu-id="128a2-272">記憶體回收期間進行的作業</span><span class="sxs-lookup"><span data-stu-id="128a2-272">What happens during a garbage collection</span></span>

<span data-ttu-id="128a2-273">記憶體回收具有下列階段：</span><span class="sxs-lookup"><span data-stu-id="128a2-273">A garbage collection has the following phases:</span></span>

- <span data-ttu-id="128a2-274">標記階段：尋找和建立所有使用中物件的清單。</span><span class="sxs-lookup"><span data-stu-id="128a2-274">A marking phase that finds and creates a list of all live objects.</span></span>

- <span data-ttu-id="128a2-275">重新配置階段：更新即將壓縮之物件的參考。</span><span class="sxs-lookup"><span data-stu-id="128a2-275">A relocating phase that updates the references to the objects that will be compacted.</span></span>

- <span data-ttu-id="128a2-276">壓縮階段：回收無作用物件所佔據的空間並壓縮未被回收的物件。</span><span class="sxs-lookup"><span data-stu-id="128a2-276">A compacting phase that reclaims the space occupied by the dead objects and compacts the surviving objects.</span></span> <span data-ttu-id="128a2-277">壓縮階段會將記憶體回收中未被回收的物件移至區段的較舊端。</span><span class="sxs-lookup"><span data-stu-id="128a2-277">The compacting phase moves objects that have survived a garbage collection toward the older end of the segment.</span></span>

  <span data-ttu-id="128a2-278">因為層代 2 回收可能會佔據多個區段，所以提升至層代 2 的物件可能會移至較舊區段。</span><span class="sxs-lookup"><span data-stu-id="128a2-278">Because generation 2 collections can occupy multiple segments, objects that are promoted into generation 2 can be moved into an older segment.</span></span> <span data-ttu-id="128a2-279">層代 1 和層代 2 的未回收物件都可能會移至不同的區段，因為它們都會被提升至層代 2。</span><span class="sxs-lookup"><span data-stu-id="128a2-279">Both generation 1 and generation 2 survivors can be moved to a different segment, because they are promoted to generation 2.</span></span>

  <span data-ttu-id="128a2-280">一般來說，大型物件堆積（LOH）不會壓縮，因為複製大型物件會造成效能上的負面影響。</span><span class="sxs-lookup"><span data-stu-id="128a2-280">Ordinarily, the large object heap (LOH) is not compacted, because copying large objects imposes a performance penalty.</span></span> <span data-ttu-id="128a2-281">不過，在 .NET Core 和 .NET Framework 4.5.1 和更新版本中，您可以使用 <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> 屬性，視需要壓縮大型物件堆積。</span><span class="sxs-lookup"><span data-stu-id="128a2-281">However, in .NET Core and in .NET Framework 4.5.1 and later, you can use the <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> property to compact the large object heap on demand.</span></span> <span data-ttu-id="128a2-282">此外，藉由指定下列任一項來設定固定限制時，會自動壓縮 LOH：</span><span class="sxs-lookup"><span data-stu-id="128a2-282">In addition, the LOH is automatically compacted when a hard limit is set by specifying either:</span></span>

  - <span data-ttu-id="128a2-283">容器的記憶體限制。</span><span class="sxs-lookup"><span data-stu-id="128a2-283">A memory limit on a container.</span></span>
  - <span data-ttu-id="128a2-284">[GCHeapHardLimit](../../core/run-time-config/garbage-collector.md#systemgcheaphardlimitcomplus_gcheaphardlimit)或[GCHeapHardLimitPercent](../../core/run-time-config/garbage-collector.md#systemgcheaphardlimitpercentcomplus_gcheaphardlimitpercent)執行時間設定選項。</span><span class="sxs-lookup"><span data-stu-id="128a2-284">The [GCHeapHardLimit](../../core/run-time-config/garbage-collector.md#systemgcheaphardlimitcomplus_gcheaphardlimit) or [GCHeapHardLimitPercent](../../core/run-time-config/garbage-collector.md#systemgcheaphardlimitpercentcomplus_gcheaphardlimitpercent) run-time configuration options.</span></span>

<span data-ttu-id="128a2-285">記憶體回收行程會使用下列資訊來判斷物件是否使用中：</span><span class="sxs-lookup"><span data-stu-id="128a2-285">The garbage collector uses the following information to determine whether objects are live:</span></span>

- <span data-ttu-id="128a2-286">**堆疊根**。</span><span class="sxs-lookup"><span data-stu-id="128a2-286">**Stack roots**.</span></span> <span data-ttu-id="128a2-287">Just-in-Time (JIT) 編譯器和堆疊查核器所提供的堆疊變數。</span><span class="sxs-lookup"><span data-stu-id="128a2-287">Stack variables provided by the just-in-time (JIT) compiler and stack walker.</span></span> <span data-ttu-id="128a2-288">JIT 優化可以延長或縮短在其中向垃圾收集行程報告堆疊變數的程式碼區域。</span><span class="sxs-lookup"><span data-stu-id="128a2-288">JIT optimizations can lengthen or shorten regions of code within which stack variables are reported to the garbage collector.</span></span>

- <span data-ttu-id="128a2-289">**垃圾收集控制碼**。</span><span class="sxs-lookup"><span data-stu-id="128a2-289">**Garbage collection handles**.</span></span> <span data-ttu-id="128a2-290">會指向 Managed 物件，而且可由使用者程式碼或 Common Language Runtime 配置的控制代碼。</span><span class="sxs-lookup"><span data-stu-id="128a2-290">Handles that point to managed objects and that can be allocated by user code or by the common language runtime.</span></span>

- <span data-ttu-id="128a2-291">**靜態資料**。</span><span class="sxs-lookup"><span data-stu-id="128a2-291">**Static data**.</span></span> <span data-ttu-id="128a2-292">應用程式定義域中可能參考其他物件的靜態物件。</span><span class="sxs-lookup"><span data-stu-id="128a2-292">Static objects in application domains that could be referencing other objects.</span></span> <span data-ttu-id="128a2-293">每個應用程式定義域都會追蹤其靜態物件。</span><span class="sxs-lookup"><span data-stu-id="128a2-293">Each application domain keeps track of its static objects.</span></span>

<span data-ttu-id="128a2-294">記憶體回收開始之前，所有 Managed 執行緒都會暫停，但觸發記憶體回收的執行緒除外。</span><span class="sxs-lookup"><span data-stu-id="128a2-294">Before a garbage collection starts, all managed threads are suspended except for the thread that triggered the garbage collection.</span></span>

<span data-ttu-id="128a2-295">下圖顯示觸發記憶體回收且造成其他執行緒暫停的執行緒。</span><span class="sxs-lookup"><span data-stu-id="128a2-295">The following illustration shows a thread that triggers a garbage collection and causes the other threads to be suspended.</span></span>

![當執行緒觸發記憶體回收時](media/gc-triggered.png)

## <a name="unmanaged-resources"></a><span data-ttu-id="128a2-297">非受控資源</span><span class="sxs-lookup"><span data-stu-id="128a2-297">Unmanaged resources</span></span>

<span data-ttu-id="128a2-298">對於您的應用程式所建立的大部分物件而言，您可以依賴垃圾收集來自動執行必要的記憶體管理工作。</span><span class="sxs-lookup"><span data-stu-id="128a2-298">For most of the objects that your application creates, you can rely on garbage collection to automatically perform the necessary memory management tasks.</span></span> <span data-ttu-id="128a2-299">但是，Unmanaged 資源需要明確清除。</span><span class="sxs-lookup"><span data-stu-id="128a2-299">However, unmanaged resources require explicit cleanup.</span></span> <span data-ttu-id="128a2-300">最常見的 Unmanaged 資源類型就是包裝作業系統資源 (例如檔案控制代碼、視窗控制代碼或網路連接) 的物件。</span><span class="sxs-lookup"><span data-stu-id="128a2-300">The most common type of unmanaged resource is an object that wraps an operating system resource, such as a file handle, window handle, or network connection.</span></span> <span data-ttu-id="128a2-301">雖然垃圾收集行程能夠追蹤封裝非受控資源之受管理物件的存留期，但是它並沒有如何清除資源的特定知識。</span><span class="sxs-lookup"><span data-stu-id="128a2-301">Although the garbage collector is able to track the lifetime of a managed object that encapsulates an unmanaged resource, it doesn't have specific knowledge about how to clean up the resource.</span></span>

<span data-ttu-id="128a2-302">當您建立封裝非受控資源的物件時，建議您提供必要的程式碼，以清除公用方法中的非受控資源 `Dispose` 。</span><span class="sxs-lookup"><span data-stu-id="128a2-302">When you create an object that encapsulates an unmanaged resource, it's recommended that you provide the necessary code to clean up the unmanaged resource in a public `Dispose` method.</span></span> <span data-ttu-id="128a2-303">您可以提供 `Dispose` 方法，讓物件的使用者在用完物件後，明確釋放出它所佔用的記憶體。</span><span class="sxs-lookup"><span data-stu-id="128a2-303">By providing a `Dispose` method, you enable users of your object to explicitly free its memory when they are finished with the object.</span></span> <span data-ttu-id="128a2-304">當您使用封裝非受控資源的物件時，請務必 `Dispose` 視需要呼叫。</span><span class="sxs-lookup"><span data-stu-id="128a2-304">When you use an object that encapsulates an unmanaged resource, make sure to call `Dispose` as necessary.</span></span>

<span data-ttu-id="128a2-305">您也必須提供一個方法，讓您的非受控資源在您的類型消費者忘記呼叫時釋放 `Dispose` 。</span><span class="sxs-lookup"><span data-stu-id="128a2-305">You must also provide a way for your unmanaged resources to be released in case a consumer of your type forgets to call `Dispose`.</span></span> <span data-ttu-id="128a2-306">您可以使用安全控制碼來包裝非受控資源，或覆寫 <xref:System.Object.Finalize?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="128a2-306">You can either use a safe handle to wrap the unmanaged resource, or override the <xref:System.Object.Finalize?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="128a2-307">如需有關清除非受控資源的詳細資訊，請參閱[清除非受控資源](unmanaged.md)。</span><span class="sxs-lookup"><span data-stu-id="128a2-307">For more information about cleaning up unmanaged resources, see [Clean up unmanaged resources](unmanaged.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="128a2-308">另請參閱</span><span class="sxs-lookup"><span data-stu-id="128a2-308">See also</span></span>

- [<span data-ttu-id="128a2-309">工作站和伺服器記憶體回收</span><span class="sxs-lookup"><span data-stu-id="128a2-309">Workstation and server garbage collection</span></span>](workstation-server-gc.md)
- [<span data-ttu-id="128a2-310">背景垃圾收集</span><span class="sxs-lookup"><span data-stu-id="128a2-310">Background garbage collection</span></span>](background-gc.md)
- [<span data-ttu-id="128a2-311">GC 的設定選項</span><span class="sxs-lookup"><span data-stu-id="128a2-311">Configuration options for GC</span></span>](../../core/run-time-config/garbage-collector.md)
- [<span data-ttu-id="128a2-312">記憶體回收</span><span class="sxs-lookup"><span data-stu-id="128a2-312">Garbage collection</span></span>](index.md)
