---
title: 實作 Dispose 方法
description: 在本文中，您將瞭解如何執行 Dispose 方法，以釋放您的程式碼在 .NET 中使用的非受控資源。
ms.date: 09/08/2020
dev_langs:
- csharp
- vb
helpviewer_keywords:
- Dispose method
- garbage collection, Dispose method
ms.assetid: eb4e1af0-3b48-4fbc-ad4e-fc2f64138bf9
ms.openlocfilehash: c9b13b2aa77449809f149ea26681d75fea629b61
ms.sourcegitcommit: 965a5af7918acb0a3fd3baf342e15d511ef75188
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 11/18/2020
ms.locfileid: "94827785"
---
# <a name="implement-a-dispose-method"></a><span data-ttu-id="d3e91-103">實作 Dispose 方法</span><span class="sxs-lookup"><span data-stu-id="d3e91-103">Implement a Dispose method</span></span>

<span data-ttu-id="d3e91-104">執行 <xref:System.IDisposable.Dispose%2A> 方法主要是用來釋放非受控資源。</span><span class="sxs-lookup"><span data-stu-id="d3e91-104">Implementing the <xref:System.IDisposable.Dispose%2A> method is primarily for releasing unmanaged resources.</span></span> <span data-ttu-id="d3e91-105">使用實作為實作為的實例成員時 <xref:System.IDisposable> ，通常會發生 cascade <xref:System.IDisposable.Dispose%2A> 呼叫。</span><span class="sxs-lookup"><span data-stu-id="d3e91-105">When working with instance members that are <xref:System.IDisposable> implementations, it's common to cascade <xref:System.IDisposable.Dispose%2A> calls.</span></span> <span data-ttu-id="d3e91-106">有其他原因需要執行 <xref:System.IDisposable.Dispose%2A> ，例如若要釋放已配置的記憶體，請移除已加入至集合的專案，或發出已取得之鎖定的版本。</span><span class="sxs-lookup"><span data-stu-id="d3e91-106">There are additional reasons for implementing <xref:System.IDisposable.Dispose%2A>, for example, to free memory that was allocated, remove an item that was added to a collection, or signal the release of a lock that was acquired.</span></span>

<span data-ttu-id="d3e91-107">[.Net 垃圾收集](index.md)行程不會配置或釋放非受控記憶體。</span><span class="sxs-lookup"><span data-stu-id="d3e91-107">The [.NET garbage collector](index.md) does not allocate or release unmanaged memory.</span></span> <span data-ttu-id="d3e91-108">處置物件的模式稱為處置模式，會在物件的存留期上強加順序。</span><span class="sxs-lookup"><span data-stu-id="d3e91-108">The pattern for disposing an object, referred to as the dispose pattern, imposes order on the lifetime of an object.</span></span> <span data-ttu-id="d3e91-109">處置模式用於執行介面的物件 <xref:System.IDisposable> ，而且在與檔案和管道控制碼、登錄控制碼、等候控制碼或非受控記憶體的指標指標互動時很常見。</span><span class="sxs-lookup"><span data-stu-id="d3e91-109">The dispose pattern is used for objects that implement the <xref:System.IDisposable> interface, and is common when interacting with file and pipe handles, registry handles, wait handles, or pointers to blocks of unmanaged memory.</span></span> <span data-ttu-id="d3e91-110">這是因為垃圾收集行程無法回收未受管理的物件。</span><span class="sxs-lookup"><span data-stu-id="d3e91-110">This is because the garbage collector is unable to reclaim unmanaged objects.</span></span>

<span data-ttu-id="d3e91-111">為了協助確保資源一律會適當地清除， <xref:System.IDisposable.Dispose%2A> 方法應該具有等冪性，使其可在不擲回例外狀況的情況下呼叫多次。</span><span class="sxs-lookup"><span data-stu-id="d3e91-111">To help ensure that resources are always cleaned up appropriately, a <xref:System.IDisposable.Dispose%2A> method should be idempotent, such that it is callable multiple times without throwing an exception.</span></span> <span data-ttu-id="d3e91-112">此外，的後續調用 <xref:System.IDisposable.Dispose%2A> 也不應該執行任何動作。</span><span class="sxs-lookup"><span data-stu-id="d3e91-112">Furthermore, subsequent invocations of <xref:System.IDisposable.Dispose%2A> should do nothing.</span></span>

<span data-ttu-id="d3e91-113">針對此方法提供的程式碼範例會 <xref:System.GC.KeepAlive%2A?displayProperty=nameWithType> 顯示垃圾收集如何造成完成項的執行，而物件或其成員的非受控參考仍在使用中。</span><span class="sxs-lookup"><span data-stu-id="d3e91-113">The code example provided for the <xref:System.GC.KeepAlive%2A?displayProperty=nameWithType> method shows how garbage collection can cause a finalizer to run, while an unmanaged reference to the object or its members is still in use.</span></span> <span data-ttu-id="d3e91-114">利用 <xref:System.GC.KeepAlive%2A?displayProperty=nameWithType> 來讓物件不符合從目前常式開始到呼叫這個方法的時間點的垃圾收集，是合理的。</span><span class="sxs-lookup"><span data-stu-id="d3e91-114">It may make sense to utilize <xref:System.GC.KeepAlive%2A?displayProperty=nameWithType> to make the object ineligible for garbage collection from the start of the current routine to the point where this method is called.</span></span>

## <a name="safe-handles"></a><span data-ttu-id="d3e91-115">安全控制碼</span><span class="sxs-lookup"><span data-stu-id="d3e91-115">Safe handles</span></span>

<span data-ttu-id="d3e91-116">撰寫物件完成項的程式碼是一項複雜的工作，若未正確撰寫，可能會造成問題。</span><span class="sxs-lookup"><span data-stu-id="d3e91-116">Writing code for an object's finalizer is a complex task that can cause problems if not done correctly.</span></span> <span data-ttu-id="d3e91-117">因此，建議您建構 <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> 物件，而不要實作完成項。</span><span class="sxs-lookup"><span data-stu-id="d3e91-117">Therefore, we recommend that you construct <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> objects instead of implementing a finalizer.</span></span>

<span data-ttu-id="d3e91-118">是一種 <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> 抽象的 managed 型別，可包裝 <xref:System.IntPtr?displayProperty=nameWithType> 識別非受控資源的。</span><span class="sxs-lookup"><span data-stu-id="d3e91-118">A <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> is an abstract managed type that wraps an <xref:System.IntPtr?displayProperty=nameWithType> that identifies an unmanaged resource.</span></span> <span data-ttu-id="d3e91-119">在 Windows 上，它可能會識別 Unix 上的控制碼，也就是檔案描述項。</span><span class="sxs-lookup"><span data-stu-id="d3e91-119">On Windows it might identify a handle while on Unix, a file descriptor.</span></span> <span data-ttu-id="d3e91-120">它會提供所有必要的邏輯，以確保此資源只會釋出一次，而當 `SafeHandle` 處置或的所有參考都已卸載， `SafeHandle` 且 `SafeHandle` 實例已完成時。</span><span class="sxs-lookup"><span data-stu-id="d3e91-120">It provides all of the logic necessary to ensure that this resource is released once and only once, when the `SafeHandle` is disposed of or when all references to the `SafeHandle` have been dropped and the `SafeHandle` instance is finalized.</span></span>

<span data-ttu-id="d3e91-121"><xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>是抽象基類。</span><span class="sxs-lookup"><span data-stu-id="d3e91-121">The <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> is an abstract base class.</span></span> <span data-ttu-id="d3e91-122">衍生類別提供不同類型之控制碼的特定實例。</span><span class="sxs-lookup"><span data-stu-id="d3e91-122">Derived classes provide specific instances for different kinds of handle.</span></span> <span data-ttu-id="d3e91-123">這些衍生類別會驗證的值 <xref:System.IntPtr?displayProperty=nameWithType> 會被視為無效，以及實際釋放控制碼的方式。</span><span class="sxs-lookup"><span data-stu-id="d3e91-123">These derived classes validate what values for the <xref:System.IntPtr?displayProperty=nameWithType> are considered invalid and how to actually free the handle.</span></span> <span data-ttu-id="d3e91-124">例如， <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> 衍生自 `SafeHandle` 以包裝來 `IntPtrs` 識別開啟的檔案控制代碼/描述項，並覆寫其 <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle?displayProperty=nameWithType> 方法，以透過 Unix 上的函式 `close` 或 Windows) 上的函式將其關閉 (`CloseHandle` 。</span><span class="sxs-lookup"><span data-stu-id="d3e91-124">For example, <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> derives from `SafeHandle` to wrap `IntPtrs` that identify open file handles/descriptors, and overrides its <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle?displayProperty=nameWithType> method to close it (via the `close` function on Unix or `CloseHandle` function on Windows).</span></span> <span data-ttu-id="d3e91-125">在 .NET 程式庫中建立非受控資源的大部分 Api 都會將其包裝在中， `SafeHandle` 並 `SafeHandle` 視需要傳回給您，而不是傳回原始指標。</span><span class="sxs-lookup"><span data-stu-id="d3e91-125">Most APIs in .NET libraries that create an unmanaged resource will wrap it in a `SafeHandle` and return that `SafeHandle` to you as needed, rather than handing back the raw pointer.</span></span> <span data-ttu-id="d3e91-126">在您與非受控元件互動並取得 `IntPtr` 非受控資源的情況下，您可以建立自己的 `SafeHandle` 型別來包裝。</span><span class="sxs-lookup"><span data-stu-id="d3e91-126">In situations where you interact with an unmanaged component and get an `IntPtr` for an unmanaged resource, you can create your own `SafeHandle` type to wrap it.</span></span> <span data-ttu-id="d3e91-127">因此，少數的非 `SafeHandle` 類型需要執行完成項; 大部分可處置的模式執行只會結束其他 managed 資源的包裝，其中某些可能是 `SafeHandle` 。</span><span class="sxs-lookup"><span data-stu-id="d3e91-127">As a result, few non-`SafeHandle` types need to implement finalizers; most disposable pattern implementations only end up wrapping other managed resources, some of which may be `SafeHandle`s.</span></span>

<span data-ttu-id="d3e91-128"><xref:Microsoft.Win32.SafeHandles> 命名空間中的下列衍生類別會提供安全控制代碼：</span><span class="sxs-lookup"><span data-stu-id="d3e91-128">The following derived classes in the <xref:Microsoft.Win32.SafeHandles> namespace provide safe handles:</span></span>

- <span data-ttu-id="d3e91-129"><xref:Microsoft.Win32.SafeHandles.SafeFileHandle>、<xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle> 和 <xref:Microsoft.Win32.SafeHandles.SafePipeHandle> 類別，適用於檔案、記憶體對應檔案和管道。</span><span class="sxs-lookup"><span data-stu-id="d3e91-129">The <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>, <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle>, and <xref:Microsoft.Win32.SafeHandles.SafePipeHandle> class, for files, memory mapped files, and pipes.</span></span>
- <span data-ttu-id="d3e91-130"><xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> 類別，適用於記憶體檢視。</span><span class="sxs-lookup"><span data-stu-id="d3e91-130">The <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> class, for memory views.</span></span>
- <span data-ttu-id="d3e91-131"><xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>、<xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle> 和 <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> 類別，適用於加密建構。</span><span class="sxs-lookup"><span data-stu-id="d3e91-131">The <xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>, and <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> classes, for cryptography constructs.</span></span>
- <span data-ttu-id="d3e91-132"><xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> 類別，適用於登錄機碼。</span><span class="sxs-lookup"><span data-stu-id="d3e91-132">The <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> class, for registry keys.</span></span>
- <span data-ttu-id="d3e91-133"><xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> 類別，適用於等候控制代碼。</span><span class="sxs-lookup"><span data-stu-id="d3e91-133">The <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> class, for wait handles.</span></span>

## <a name="dispose-and-disposebool"></a><span data-ttu-id="d3e91-134">Dispose ( # A1 和 Dispose (bool) </span><span class="sxs-lookup"><span data-stu-id="d3e91-134">Dispose() and Dispose(bool)</span></span>

<span data-ttu-id="d3e91-135"><xref:System.IDisposable> 介面要求實作單一無參數方法 <xref:System.IDisposable.Dispose%2A>。</span><span class="sxs-lookup"><span data-stu-id="d3e91-135">The <xref:System.IDisposable> interface requires the implementation of a single parameterless method, <xref:System.IDisposable.Dispose%2A>.</span></span> <span data-ttu-id="d3e91-136">此外，任何非密封類別都應該要執行額外的多載 `Dispose(bool)` 方法：</span><span class="sxs-lookup"><span data-stu-id="d3e91-136">Also, any non-sealed class should have an additional `Dispose(bool)` overload method to be implemented:</span></span>

- <span data-ttu-id="d3e91-137">沒有 `public` `NonInheritable` 參數的 Visual Basic) 執行中的非虛擬 (<xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="d3e91-137">A `public` non-virtual (`NonInheritable` in Visual Basic) <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementation that has no parameters.</span></span>

- <span data-ttu-id="d3e91-138">`protected virtual`Visual Basic) 方法的 (，其簽章 `Overridable` `Dispose` 為：</span><span class="sxs-lookup"><span data-stu-id="d3e91-138">A `protected virtual` (`Overridable` in Visual Basic) `Dispose` method whose signature is:</span></span>

  [!code-csharp[Conceptual.Disposable#8](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/dispose1.cs#8)]
  [!code-vb[Conceptual.Disposable#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/dispose1.vb#8)]

  > [!IMPORTANT]
  > <span data-ttu-id="d3e91-139">`disposing`參數應該是 `false` 從完成項呼叫，並 `true` 從方法呼叫時 <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="d3e91-139">The `disposing` parameter should be `false` when called from a finalizer, and `true` when called from the <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="d3e91-140">換句話說，它會在具 `true` 決定性的呼叫時，以及 `false` 不具決定性的呼叫時。</span><span class="sxs-lookup"><span data-stu-id="d3e91-140">In other words, it is `true` when deterministically called and `false` when non-deterministically called.</span></span>

### <a name="the-dispose-method"></a><span data-ttu-id="d3e91-141">Dispose ( # A1 方法</span><span class="sxs-lookup"><span data-stu-id="d3e91-141">The Dispose() method</span></span>

<span data-ttu-id="d3e91-142">因為 `public` Visual Basic) 中的非虛擬 (`NonInheritable` ，無參數 `Dispose` 方法是由型別的取用者呼叫，其目的是要釋放未受管理的資源、執行一般清除，以及指出完成項（如果有的話）不需要執行。</span><span class="sxs-lookup"><span data-stu-id="d3e91-142">Because the `public`, non-virtual (`NonInheritable` in Visual Basic), parameterless `Dispose` method is called by a consumer of the type, its purpose is to free unmanaged resources, perform general cleanup, and to indicate that the finalizer, if one is present, doesn't have to run.</span></span> <span data-ttu-id="d3e91-143">釋放與受管理物件相關聯的實際記憶體一律是 [垃圾收集](index.md)行程的網域。</span><span class="sxs-lookup"><span data-stu-id="d3e91-143">Freeing the actual memory associated with a managed object is always the domain of the [garbage collector](index.md).</span></span> <span data-ttu-id="d3e91-144">因此，它擁有標準實作：</span><span class="sxs-lookup"><span data-stu-id="d3e91-144">Because of this, it has a standard implementation:</span></span>

[!code-csharp[Conceptual.Disposable#7](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/dispose1.cs#7)]
[!code-vb[Conceptual.Disposable#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/dispose1.vb#7)]

<span data-ttu-id="d3e91-145">`Dispose` 方法會執行所有物件清除，所以記憶體回收行程不需要再呼叫物件的 <xref:System.Object.Finalize%2A?displayProperty=nameWithType> 覆寫。</span><span class="sxs-lookup"><span data-stu-id="d3e91-145">The `Dispose` method performs all object cleanup, so the garbage collector no longer needs to call the objects' <xref:System.Object.Finalize%2A?displayProperty=nameWithType> override.</span></span> <span data-ttu-id="d3e91-146">因此，呼叫 <xref:System.GC.SuppressFinalize%2A> 方法會防止記憶體回收行程執行完成項。</span><span class="sxs-lookup"><span data-stu-id="d3e91-146">Therefore, the call to the <xref:System.GC.SuppressFinalize%2A> method prevents the garbage collector from running the finalizer.</span></span> <span data-ttu-id="d3e91-147">如果類型沒有完成項，則呼叫 <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> 沒有作用。</span><span class="sxs-lookup"><span data-stu-id="d3e91-147">If the type has no finalizer, the call to <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> has no effect.</span></span> <span data-ttu-id="d3e91-148">請注意，實際清除是由方法多載所執行 `Dispose(bool)` 。</span><span class="sxs-lookup"><span data-stu-id="d3e91-148">Note that the actual cleanup is performed by the `Dispose(bool)` method overload.</span></span>

### <a name="the-disposebool-method-overload"></a><span data-ttu-id="d3e91-149">Dispose (bool) 方法多載</span><span class="sxs-lookup"><span data-stu-id="d3e91-149">The Dispose(bool) method overload</span></span>

<span data-ttu-id="d3e91-150">在多載中， `disposing` 參數是 <xref:System.Boolean> ，指出方法呼叫 <xref:System.IDisposable.Dispose%2A> 是來自方法 (它的值是 `true`) 或從完成項 (其值 `false`) 。</span><span class="sxs-lookup"><span data-stu-id="d3e91-150">In the overload, the `disposing` parameter is a <xref:System.Boolean> that indicates whether the method call comes from a <xref:System.IDisposable.Dispose%2A> method (its value is `true`) or from a finalizer (its value is `false`).</span></span>

<span data-ttu-id="d3e91-151">方法的主體是由兩個程式碼區塊所構成：</span><span class="sxs-lookup"><span data-stu-id="d3e91-151">The body of the method consists of two blocks of code:</span></span>

- <span data-ttu-id="d3e91-152">釋放 Unmanaged 資源的區塊。</span><span class="sxs-lookup"><span data-stu-id="d3e91-152">A block that frees unmanaged resources.</span></span> <span data-ttu-id="d3e91-153">不論 `disposing` 參數的值為何，這個區塊都會執行。</span><span class="sxs-lookup"><span data-stu-id="d3e91-153">This block executes regardless of the value of the `disposing` parameter.</span></span>
- <span data-ttu-id="d3e91-154">釋放 Managed 資源的條件性區塊。</span><span class="sxs-lookup"><span data-stu-id="d3e91-154">A conditional block that frees managed resources.</span></span> <span data-ttu-id="d3e91-155">如果 `disposing` 的值為 `true`，這個區塊就會執行。</span><span class="sxs-lookup"><span data-stu-id="d3e91-155">This block executes if the value of `disposing` is `true`.</span></span> <span data-ttu-id="d3e91-156">它所釋放的 Managed 資源可能包括：</span><span class="sxs-lookup"><span data-stu-id="d3e91-156">The managed resources that it frees can include:</span></span>

  - <span data-ttu-id="d3e91-157">**實作 <xref:System.IDisposable> 的受控物件。**</span><span class="sxs-lookup"><span data-stu-id="d3e91-157">**Managed objects that implement <xref:System.IDisposable>.**</span></span> <span data-ttu-id="d3e91-158">條件式區塊可以用來呼叫其 <xref:System.IDisposable.Dispose%2A> 實 (cascade dispose) 。</span><span class="sxs-lookup"><span data-stu-id="d3e91-158">The conditional block can be used to call their <xref:System.IDisposable.Dispose%2A> implementation (cascade dispose).</span></span> <span data-ttu-id="d3e91-159">如果您使用的衍生類別 <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> 來包裝未受管理的資源，您應該在 <xref:System.Runtime.InteropServices.SafeHandle.Dispose?displayProperty=nameWithType> 這裡呼叫執行。</span><span class="sxs-lookup"><span data-stu-id="d3e91-159">If you have used a derived class of <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> to wrap your unmanaged resource, you should call the <xref:System.Runtime.InteropServices.SafeHandle.Dispose?displayProperty=nameWithType> implementation here.</span></span>

  - <span data-ttu-id="d3e91-160">**耗用大量記憶體或耗用少量資源的 Managed 物件。**</span><span class="sxs-lookup"><span data-stu-id="d3e91-160">**Managed objects that consume large amounts of memory or consume scarce resources.**</span></span> <span data-ttu-id="d3e91-161">將大型的 managed 物件參考指派給， `null` 使其更容易無法連接。</span><span class="sxs-lookup"><span data-stu-id="d3e91-161">Assign large managed object references to `null` to make them more likely to be unreachable.</span></span> <span data-ttu-id="d3e91-162">這會比以非決定性的方式來釋出它們，而這通常是在條件式區塊之外進行。</span><span class="sxs-lookup"><span data-stu-id="d3e91-162">This releases them faster than if they were reclaimed non-deterministically, and this is usually done outside of the conditional block.</span></span>

<span data-ttu-id="d3e91-163">如果方法呼叫來自完成項，則只應執行釋出非受控資源的程式碼。</span><span class="sxs-lookup"><span data-stu-id="d3e91-163">If the method call comes from a finalizer, only the code that frees unmanaged resources should execute.</span></span> <span data-ttu-id="d3e91-164">實施者負責確保 false 路徑不會與可能已回收的 managed 物件互動。</span><span class="sxs-lookup"><span data-stu-id="d3e91-164">The implementer is responsible for ensuring the the false path doesn't interact with managed objects that may have been reclaimed.</span></span> <span data-ttu-id="d3e91-165">這點很重要，因為垃圾收集行程在完成期間終結 managed 物件的順序不具決定性。</span><span class="sxs-lookup"><span data-stu-id="d3e91-165">This is important because the order in which the garbage collector destroys managed objects during finalization is non-deterministic.</span></span>

## <a name="cascade-dispose-calls"></a><span data-ttu-id="d3e91-166">Cascade dispose 呼叫</span><span class="sxs-lookup"><span data-stu-id="d3e91-166">Cascade dispose calls</span></span>

<span data-ttu-id="d3e91-167">如果您的類別擁有欄位或屬性，且其型別為實 <xref:System.IDisposable> ，則包含類別本身也應該會執行 <xref:System.IDisposable> 。</span><span class="sxs-lookup"><span data-stu-id="d3e91-167">If your class owns a field or property, and its type implements <xref:System.IDisposable>, the containing class itself should also implement <xref:System.IDisposable>.</span></span> <span data-ttu-id="d3e91-168">具 <xref:System.IDisposable> 現化實作為實例成員並將其儲存為實例成員的類別，也會負責其清除。</span><span class="sxs-lookup"><span data-stu-id="d3e91-168">A class that instantiates an <xref:System.IDisposable> implementation and storing it as an instance member, is also responsible for its cleanup.</span></span> <span data-ttu-id="d3e91-169">這是為了協助確保參考的可處置型別有機會透過方法明確地執行清除 <xref:System.IDisposable.Dispose%2A> 。</span><span class="sxs-lookup"><span data-stu-id="d3e91-169">This is to help ensure that the referenced disposable types are given the opportunity to deterministically perform clean up through the <xref:System.IDisposable.Dispose%2A> method.</span></span> <span data-ttu-id="d3e91-170">在此範例中，類別是 `sealed` `NotInheritable` 在 Visual Basic) 中 (或。</span><span class="sxs-lookup"><span data-stu-id="d3e91-170">In this example, the class is `sealed` (or `NotInheritable` in Visual Basic).</span></span>

[!code-csharp[Conceptual.Disposable#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/disposable1.cs#1)]
[!code-vb[Conceptual.Disposable#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/disposable1.vb#1)]

## <a name="implement-the-dispose-pattern"></a><span data-ttu-id="d3e91-171">執行處置模式</span><span class="sxs-lookup"><span data-stu-id="d3e91-171">Implement the dispose pattern</span></span>

<span data-ttu-id="d3e91-172">所有非密封類別或 (Visual Basic 類別未修改為 `NotInheritable`) 應該被視為可能的基類，因為它們可以被繼承。</span><span class="sxs-lookup"><span data-stu-id="d3e91-172">All non-sealed classes or (Visual Basic classes not modified as `NotInheritable`) should be considered a potential base class, because they could be inherited.</span></span> <span data-ttu-id="d3e91-173">如果您針對任何可能的基類執行處置模式，則必須提供下列各項：</span><span class="sxs-lookup"><span data-stu-id="d3e91-173">If you implement the dispose pattern for any potential base class, you must provide the following:</span></span>

- <span data-ttu-id="d3e91-174">呼叫 <xref:System.IDisposable.Dispose%2A> 方法的 `Dispose(bool)` 實作。</span><span class="sxs-lookup"><span data-stu-id="d3e91-174">A <xref:System.IDisposable.Dispose%2A> implementation that calls the `Dispose(bool)` method.</span></span>
- <span data-ttu-id="d3e91-175">`Dispose(bool)`執行實際清除的方法。</span><span class="sxs-lookup"><span data-stu-id="d3e91-175">A `Dispose(bool)` method that performs the actual cleanup.</span></span>
- <span data-ttu-id="d3e91-176">衍生自包裝您的 Unmanaged 資源之 <xref:System.Runtime.InteropServices.SafeHandle> 的類別 (建議使用)，或式 <xref:System.Object.Finalize%2A?displayProperty=nameWithType> 方法的覆寫。</span><span class="sxs-lookup"><span data-stu-id="d3e91-176">Either a class derived from <xref:System.Runtime.InteropServices.SafeHandle> that wraps your unmanaged resource (recommended), or an override to the <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="d3e91-177"><xref:System.Runtime.InteropServices.SafeHandle>類別會提供完成項，因此您不需要自行撰寫。</span><span class="sxs-lookup"><span data-stu-id="d3e91-177">The <xref:System.Runtime.InteropServices.SafeHandle> class provides a finalizer, so you do not have to write one yourself.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="d3e91-178">基類可以只參考 managed 物件，並執行處置模式。</span><span class="sxs-lookup"><span data-stu-id="d3e91-178">It is possible for a base class to only reference managed objects, and implement the dispose pattern.</span></span> <span data-ttu-id="d3e91-179">在這些情況下，不需要完成項。</span><span class="sxs-lookup"><span data-stu-id="d3e91-179">In these cases, a finalizer is unnecessary.</span></span> <span data-ttu-id="d3e91-180">只有當您直接參考未受管理的資源時，才需要完成項。</span><span class="sxs-lookup"><span data-stu-id="d3e91-180">A finalizer is only required if you directly reference unmanaged resources.</span></span>

<span data-ttu-id="d3e91-181">以下一般模式將會實作使用安全控制代碼之基底類別的處置模式。</span><span class="sxs-lookup"><span data-stu-id="d3e91-181">Here's the general pattern for implementing the dispose pattern for a base class that uses a safe handle.</span></span>

[!code-csharp[System.IDisposable#3](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/base1.cs#3)]
[!code-vb[System.IDisposable#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/base1.vb#3)]

> [!NOTE]
> <span data-ttu-id="d3e91-182">上一個範例使用 <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> 物件來說明模式；可改用任何衍生自 <xref:System.Runtime.InteropServices.SafeHandle> 的物件。</span><span class="sxs-lookup"><span data-stu-id="d3e91-182">The previous example uses a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object to illustrate the pattern; any object derived from <xref:System.Runtime.InteropServices.SafeHandle> could be used instead.</span></span> <span data-ttu-id="d3e91-183">請注意，該範例未正確地執行個體化其 <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> 物件。</span><span class="sxs-lookup"><span data-stu-id="d3e91-183">Note that the example does not properly instantiate its <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object.</span></span>

<span data-ttu-id="d3e91-184">以下一般模式將會實作覆寫 <xref:System.Object.Finalize%2A?displayProperty=nameWithType> 之基底類別的處置模式。</span><span class="sxs-lookup"><span data-stu-id="d3e91-184">Here's the general pattern for implementing the dispose pattern for a base class that overrides <xref:System.Object.Finalize%2A?displayProperty=nameWithType>.</span></span>

[!code-csharp[System.IDisposable#5](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/base2.cs#5)]
[!code-vb[System.IDisposable#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/base2.vb#5)]

> [!TIP]
> <span data-ttu-id="d3e91-185">在 c # 中，您可以 [藉由覆](../../csharp/programming-guide/classes-and-structs/destructors.md) 寫來建立完成項 <xref:System.Object.Finalize%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="d3e91-185">In C#, you create a [finalizer](../../csharp/programming-guide/classes-and-structs/destructors.md) by overriding <xref:System.Object.Finalize%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d3e91-186">在 Visual Basic 中，這是透過進行 `Protected Overrides Sub Finalize()` 。</span><span class="sxs-lookup"><span data-stu-id="d3e91-186">In Visual Basic, this is done with `Protected Overrides Sub Finalize()`.</span></span>

## <a name="implement-the-dispose-pattern-for-a-derived-class"></a><span data-ttu-id="d3e91-187">執行衍生類別的處置模式</span><span class="sxs-lookup"><span data-stu-id="d3e91-187">Implement the dispose pattern for a derived class</span></span>

<span data-ttu-id="d3e91-188">從實作 <xref:System.IDisposable> 介面的類別衍生的類別不應該實作 <xref:System.IDisposable>，因為 <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> 的基底類別實作會由其衍生類別繼承。</span><span class="sxs-lookup"><span data-stu-id="d3e91-188">A class derived from a class that implements the <xref:System.IDisposable> interface shouldn't implement <xref:System.IDisposable>, because the base class implementation of <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> is inherited by its derived classes.</span></span> <span data-ttu-id="d3e91-189">相反地，若要清除衍生類別，請提供下列各項：</span><span class="sxs-lookup"><span data-stu-id="d3e91-189">Instead, to cleanup a derived class, you provide the following:</span></span>

- <span data-ttu-id="d3e91-190">`protected override void Dispose(bool)`覆寫基類方法並執行衍生類別實際清除的方法。</span><span class="sxs-lookup"><span data-stu-id="d3e91-190">A `protected override void Dispose(bool)` method that overrides the base class method and performs the actual cleanup of the derived class.</span></span> <span data-ttu-id="d3e91-191">這個方法也必須 `base.Dispose(bool)` `MyBase.Dispose(bool)` 在基類的 Visual Basic) 方法中呼叫 (，並將其處置狀態傳遞給引數。</span><span class="sxs-lookup"><span data-stu-id="d3e91-191">This method must also call the `base.Dispose(bool)` (`MyBase.Dispose(bool)` in Visual Basic) method of the base class and pass its disposing status for the argument.</span></span>
- <span data-ttu-id="d3e91-192">衍生自包裝您的 Unmanaged 資源之 <xref:System.Runtime.InteropServices.SafeHandle> 的類別 (建議使用)，或式 <xref:System.Object.Finalize%2A?displayProperty=nameWithType> 方法的覆寫。</span><span class="sxs-lookup"><span data-stu-id="d3e91-192">Either a class derived from <xref:System.Runtime.InteropServices.SafeHandle> that wraps your unmanaged resource (recommended), or an override to the <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="d3e91-193"><xref:System.Runtime.InteropServices.SafeHandle> 類別會提供完成項，讓您不必自行撰寫程式碼。</span><span class="sxs-lookup"><span data-stu-id="d3e91-193">The <xref:System.Runtime.InteropServices.SafeHandle> class provides a finalizer that frees you from having to code one.</span></span> <span data-ttu-id="d3e91-194">如果您提供完成項，它必須 `Dispose(bool)` 使用的 `disposing` 引數來呼叫多載 `false` 。</span><span class="sxs-lookup"><span data-stu-id="d3e91-194">If you do provide a finalizer, it must call the `Dispose(bool)` overload with a `disposing` argument of `false`.</span></span>

<span data-ttu-id="d3e91-195">以下一般模式將會實作使用安全控制代碼之衍生類別的處置模式：</span><span class="sxs-lookup"><span data-stu-id="d3e91-195">Here's the general pattern for implementing the dispose pattern for a derived class that uses a safe handle:</span></span>

[!code-csharp[System.IDisposable#4](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/derived1.cs#4)]
[!code-vb[System.IDisposable#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/derived1.vb#4)]

> [!NOTE]
> <span data-ttu-id="d3e91-196">上一個範例使用 <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> 物件來說明模式；可改用任何衍生自 <xref:System.Runtime.InteropServices.SafeHandle> 的物件。</span><span class="sxs-lookup"><span data-stu-id="d3e91-196">The previous example uses a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object to illustrate the pattern; any object derived from <xref:System.Runtime.InteropServices.SafeHandle> could be used instead.</span></span> <span data-ttu-id="d3e91-197">請注意，該範例未正確地執行個體化其 <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> 物件。</span><span class="sxs-lookup"><span data-stu-id="d3e91-197">Note that the example does not properly instantiate its <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object.</span></span>

<span data-ttu-id="d3e91-198">以下一般模式將會實作覆寫 <xref:System.Object.Finalize%2A?displayProperty=nameWithType> 之衍生類別的處置模式：</span><span class="sxs-lookup"><span data-stu-id="d3e91-198">Here's the general pattern for implementing the dispose pattern for a derived class that overrides <xref:System.Object.Finalize%2A?displayProperty=nameWithType>:</span></span>

[!code-csharp[System.IDisposable#6](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/derived2.cs#6)]
[!code-vb[System.IDisposable#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/derived2.vb#6)]

## <a name="implement-the-dispose-pattern-with-safe-handles"></a><span data-ttu-id="d3e91-199">使用安全控制碼來執行處置模式</span><span class="sxs-lookup"><span data-stu-id="d3e91-199">Implement the dispose pattern with safe handles</span></span>

<span data-ttu-id="d3e91-200">下列範例將說明使用安全控制代碼封裝 Unmanaged 資源之基底類別 `DisposableStreamResource` 的處置模式。</span><span class="sxs-lookup"><span data-stu-id="d3e91-200">The following example illustrates the dispose pattern for a base class, `DisposableStreamResource`, that uses a safe handle to encapsulate unmanaged resources.</span></span> <span data-ttu-id="d3e91-201">它會定義 `DisposableStreamResource` 類別，該類別使用 <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> 包裝代表開啟檔案的 <xref:System.IO.Stream> 物件。</span><span class="sxs-lookup"><span data-stu-id="d3e91-201">It defines a `DisposableStreamResource` class that uses a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> to wrap a <xref:System.IO.Stream> object that represents an open file.</span></span> <span data-ttu-id="d3e91-202">此類別也包含單一屬性，這個屬性會傳回檔案 `Size` 資料流程中的總位元組數。</span><span class="sxs-lookup"><span data-stu-id="d3e91-202">The class also includes a single property, `Size`, that returns the total number of bytes in the file stream.</span></span>

[!code-csharp[Conceptual.Disposable#9](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/base1.cs#9)]
[!code-vb[Conceptual.Disposable#9](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/base1.vb#9)]

## <a name="implement-the-dispose-pattern-for-a-derived-class-with-safe-handles"></a><span data-ttu-id="d3e91-203">使用安全控制碼來執行衍生類別的處置模式</span><span class="sxs-lookup"><span data-stu-id="d3e91-203">Implement the dispose pattern for a derived class with safe handles</span></span>

<span data-ttu-id="d3e91-204">下列範例將說明衍生類別 `DisposableStreamResource2` 的處置模式，該類別繼承自上述範例中顯示的 `DisposableStreamResource` 類別。</span><span class="sxs-lookup"><span data-stu-id="d3e91-204">The following example illustrates the dispose pattern for a derived class, `DisposableStreamResource2`, that inherits from the `DisposableStreamResource` class presented in the previous example.</span></span> <span data-ttu-id="d3e91-205">這個類別會加入額外的方法 `WriteFileInfo`，並使用 <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> 物件包裝可寫入檔案的控制代碼。</span><span class="sxs-lookup"><span data-stu-id="d3e91-205">The class adds an additional method, `WriteFileInfo`, and uses a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object to wrap the handle of the writable file.</span></span>

[!code-csharp[Conceptual.Disposable#10](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/derived1.cs#10)]
[!code-vb[Conceptual.Disposable#10](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/derived1.vb#10)]

## <a name="see-also"></a><span data-ttu-id="d3e91-206">請參閱</span><span class="sxs-lookup"><span data-stu-id="d3e91-206">See also</span></span>

- <xref:System.GC.SuppressFinalize%2A>
- <xref:System.IDisposable>
- <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>
- <xref:Microsoft.Win32.SafeHandles>
- <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>
- <xref:System.Object.Finalize%2A?displayProperty=nameWithType>
- [<span data-ttu-id="d3e91-207">定義和使用類別和結構 (c + +/CLI) </span><span class="sxs-lookup"><span data-stu-id="d3e91-207">Define and consume classes and structs (C++/CLI)</span></span>](/cpp/dotnet/how-to-define-and-consume-classes-and-structs-cpp-cli)
