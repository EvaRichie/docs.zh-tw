---
title: 實作 Dispose 方法
description: 在本文中，您將學習如何執行 Dispose 方法，以釋放您的程式碼在 .NET 中使用的非受控資源。
ms.date: 05/27/2020
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- Dispose method
- garbage collection, Dispose method
ms.assetid: eb4e1af0-3b48-4fbc-ad4e-fc2f64138bf9
ms.openlocfilehash: c8b4b9a79577776bc049ef77e222d63374178708
ms.sourcegitcommit: b16c00371ea06398859ecd157defc81301c9070f
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 06/05/2020
ms.locfileid: "84447169"
---
# <a name="implement-a-dispose-method"></a><span data-ttu-id="e8f36-103">實作 Dispose 方法</span><span class="sxs-lookup"><span data-stu-id="e8f36-103">Implement a Dispose method</span></span>

<span data-ttu-id="e8f36-104">執行 <xref:System.IDisposable.Dispose%2A> 方法主要是用來釋放程式碼所使用的非受控資源。</span><span class="sxs-lookup"><span data-stu-id="e8f36-104">Implementing the <xref:System.IDisposable.Dispose%2A> method is primarily for releasing unmanaged resources used by your code.</span></span> <span data-ttu-id="e8f36-105">使用實作為實作為實例成員時 <xref:System.IDisposable> ，通常會使用 cascade <xref:System.IDisposable.Dispose%2A> 呼叫。</span><span class="sxs-lookup"><span data-stu-id="e8f36-105">When working with instance members that are <xref:System.IDisposable> implementations, it's common to cascade <xref:System.IDisposable.Dispose%2A> calls.</span></span> <span data-ttu-id="e8f36-106">有其他的原因需要執行 <xref:System.IDisposable.Dispose%2A> ，例如復原先前完成的專案。</span><span class="sxs-lookup"><span data-stu-id="e8f36-106">There are additional reasons for implementing <xref:System.IDisposable.Dispose%2A>, such as undoing something that was previously done.</span></span> <span data-ttu-id="e8f36-107">例如，釋放已配置的記憶體、從已新增的集合中移除專案、發出已取得鎖定的釋放信號等等。</span><span class="sxs-lookup"><span data-stu-id="e8f36-107">For example, freeing memory that was allocated, removing an item from a collection that was added, signaling the release of a lock that was acquired, and so on.</span></span>

<span data-ttu-id="e8f36-108">[.Net 垃圾收集](index.md)行程不會配置或釋放非受控記憶體。</span><span class="sxs-lookup"><span data-stu-id="e8f36-108">The [.NET garbage collector](index.md) does not allocate or release unmanaged memory.</span></span> <span data-ttu-id="e8f36-109">處置物件的模式稱為處置模式，會在物件的存留期加上順序。</span><span class="sxs-lookup"><span data-stu-id="e8f36-109">The pattern for disposing an object, referred to as the dispose pattern, imposes order on the lifetime of an object.</span></span> <span data-ttu-id="e8f36-110">處置模式用於實作為介面的物件 <xref:System.IDisposable> ，而且與檔案和管道控制碼、登錄控制碼、等候控制碼或非受控記憶體區塊的指標互動時很常見。</span><span class="sxs-lookup"><span data-stu-id="e8f36-110">The dispose pattern is used for objects that implement the <xref:System.IDisposable> interface, and is common when interacting with file and pipe handles, registry handles, wait handles, or pointers to blocks of unmanaged memory.</span></span> <span data-ttu-id="e8f36-111">這是因為垃圾收集行程無法回收未受管理的物件。</span><span class="sxs-lookup"><span data-stu-id="e8f36-111">This is because the garbage collector is unable to reclaim unmanaged objects.</span></span>

<span data-ttu-id="e8f36-112">為了協助確保一律適當地清除資源， <xref:System.IDisposable.Dispose%2A> 方法應該具有等冪性，讓它可以呼叫多次，而不會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="e8f36-112">To help ensure that resources are always cleaned up appropriately, a <xref:System.IDisposable.Dispose%2A> method should be idempotent, such that it is callable multiple times without throwing an exception.</span></span> <span data-ttu-id="e8f36-113">此外，的後續調用 <xref:System.IDisposable.Dispose%2A> 也不會執行任何動作。</span><span class="sxs-lookup"><span data-stu-id="e8f36-113">Furthermore, subsequent invocations of <xref:System.IDisposable.Dispose%2A> should do nothing.</span></span>

<span data-ttu-id="e8f36-114">針對方法提供的程式碼範例會 <xref:System.GC.KeepAlive%2A?displayProperty=nameWithType> 顯示垃圾收集如何導致完成項執行，而物件或其成員的非受控參考仍在使用中。</span><span class="sxs-lookup"><span data-stu-id="e8f36-114">The code example provided for the <xref:System.GC.KeepAlive%2A?displayProperty=nameWithType> method shows how garbage collection can cause a finalizer to run, while an unmanaged reference to the object or its members is still in use.</span></span> <span data-ttu-id="e8f36-115">利用 <xref:System.GC.KeepAlive%2A?displayProperty=nameWithType> ，讓物件無法從目前常式的開始進行垃圾收集，到呼叫這個方法的時間點，是合理的作法。</span><span class="sxs-lookup"><span data-stu-id="e8f36-115">It may make sense to utilize <xref:System.GC.KeepAlive%2A?displayProperty=nameWithType> to make the object ineligible for garbage collection from the start of the current routine to the point where this method is called.</span></span>

## <a name="safe-handles"></a><span data-ttu-id="e8f36-116">安全控制碼</span><span class="sxs-lookup"><span data-stu-id="e8f36-116">Safe handles</span></span>

<span data-ttu-id="e8f36-117">撰寫物件完成項的程式碼是一項複雜的工作，若未正確撰寫，可能會造成問題。</span><span class="sxs-lookup"><span data-stu-id="e8f36-117">Writing code for an object's finalizer is a complex task that can cause problems if not done correctly.</span></span> <span data-ttu-id="e8f36-118">因此，建議您建構 <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> 物件，而不要實作完成項。</span><span class="sxs-lookup"><span data-stu-id="e8f36-118">Therefore, we recommend that you construct <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> objects instead of implementing a finalizer.</span></span>

<span data-ttu-id="e8f36-119"><xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>是一個抽象的 managed 型別，它會包裝 <xref:System.IntPtr?displayProperty=nameWithType> 可識別非受控資源的。</span><span class="sxs-lookup"><span data-stu-id="e8f36-119">A <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> is an abstract managed type that wraps an <xref:System.IntPtr?displayProperty=nameWithType> that identifies an unmanaged resource.</span></span> <span data-ttu-id="e8f36-120">在 Windows 上，it 可能會在 Unix 上識別控制碼，也就是檔案描述項。</span><span class="sxs-lookup"><span data-stu-id="e8f36-120">On Windows it might identify a handle while on Unix, a file descriptor.</span></span> <span data-ttu-id="e8f36-121">它會提供所有必要的邏輯，確保此資源只會釋出一次，或在已卸載 `SafeHandle` 所有的參考 `SafeHandle` ，且已完成實例時才釋放 `SafeHandle` 。</span><span class="sxs-lookup"><span data-stu-id="e8f36-121">It provides all of the logic necessary to ensure that this resource is released once and only once, when the `SafeHandle` is disposed of or when all references to the `SafeHandle` have been dropped and the `SafeHandle` instance is finalized.</span></span>

<span data-ttu-id="e8f36-122"><xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>是抽象基類。</span><span class="sxs-lookup"><span data-stu-id="e8f36-122">The <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> is an abstract base class.</span></span> <span data-ttu-id="e8f36-123">衍生類別會針對不同類型的控制碼提供特定的實例。</span><span class="sxs-lookup"><span data-stu-id="e8f36-123">Derived classes provide specific instances for different kinds of handle.</span></span> <span data-ttu-id="e8f36-124">這些衍生的類別會驗證哪些值 <xref:System.IntPtr?displayProperty=nameWithType> 被視為無效，以及如何實際釋放控制碼。</span><span class="sxs-lookup"><span data-stu-id="e8f36-124">These derived classes validate what values for the <xref:System.IntPtr?displayProperty=nameWithType> are considered invalid and how to actually free the handle.</span></span> <span data-ttu-id="e8f36-125">例如， <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> 衍生自 `SafeHandle` 來包裝以 `IntPtrs` 識別開啟的檔案控制代碼/描述元，並覆寫其 <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle?displayProperty=nameWithType> 方法來關閉它（透過 Unix 上的函式 `close` 或 Windows 上的函式 `CloseHandle` ）。</span><span class="sxs-lookup"><span data-stu-id="e8f36-125">For example, <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> derives from `SafeHandle` to wrap `IntPtrs` that identify open file handles/descriptors, and overrides its <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle?displayProperty=nameWithType> method to close it (via the `close` function on Unix or `CloseHandle` function on Windows).</span></span> <span data-ttu-id="e8f36-126">.NET 程式庫中建立非受控資源的大部分 Api 會將它包裝在中， `SafeHandle` 並 `SafeHandle` 視需要傳回給您，而不是處理原始指標。</span><span class="sxs-lookup"><span data-stu-id="e8f36-126">Most APIs in .NET libraries that create an unmanaged resource will wrap it in a `SafeHandle` and return that `SafeHandle` to you as needed, rather than handing back the raw pointer.</span></span> <span data-ttu-id="e8f36-127">在您與非受控元件互動並取得 `IntPtr` 非受控資源的情況下，您可以建立自己的 `SafeHandle` 類型來包裝它。</span><span class="sxs-lookup"><span data-stu-id="e8f36-127">In situations where you interact with an unmanaged component and get an `IntPtr` for an unmanaged resource, you can create your own `SafeHandle` type to wrap it.</span></span> <span data-ttu-id="e8f36-128">因此，少數的非型別 `SafeHandle` 需要實作為完成項; 大部分可處置的模式執行只會包裝其他 managed 資源，其中有些可能是 `SafeHandle` s。</span><span class="sxs-lookup"><span data-stu-id="e8f36-128">As a result, few non-`SafeHandle` types need to implement finalizers; most disposable pattern implementations only end up wrapping other managed resources, some of which may be `SafeHandle`s.</span></span>

<span data-ttu-id="e8f36-129"><xref:Microsoft.Win32.SafeHandles> 命名空間中的下列衍生類別會提供安全控制代碼：</span><span class="sxs-lookup"><span data-stu-id="e8f36-129">The following derived classes in the <xref:Microsoft.Win32.SafeHandles> namespace provide safe handles:</span></span>

- <span data-ttu-id="e8f36-130"><xref:Microsoft.Win32.SafeHandles.SafeFileHandle>、<xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle> 和 <xref:Microsoft.Win32.SafeHandles.SafePipeHandle> 類別，適用於檔案、記憶體對應檔案和管道。</span><span class="sxs-lookup"><span data-stu-id="e8f36-130">The <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>, <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle>, and <xref:Microsoft.Win32.SafeHandles.SafePipeHandle> class, for files, memory mapped files, and pipes.</span></span>
- <span data-ttu-id="e8f36-131"><xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> 類別，適用於記憶體檢視。</span><span class="sxs-lookup"><span data-stu-id="e8f36-131">The <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> class, for memory views.</span></span>
- <span data-ttu-id="e8f36-132"><xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>、<xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle> 和 <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> 類別，適用於加密建構。</span><span class="sxs-lookup"><span data-stu-id="e8f36-132">The <xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>, and <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> classes, for cryptography constructs.</span></span>
- <span data-ttu-id="e8f36-133"><xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> 類別，適用於登錄機碼。</span><span class="sxs-lookup"><span data-stu-id="e8f36-133">The <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> class, for registry keys.</span></span>
- <span data-ttu-id="e8f36-134"><xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> 類別，適用於等候控制代碼。</span><span class="sxs-lookup"><span data-stu-id="e8f36-134">The <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> class, for wait handles.</span></span>

## <a name="dispose-and-disposebool"></a><span data-ttu-id="e8f36-135">Dispose （）和 Dispose （bool）</span><span class="sxs-lookup"><span data-stu-id="e8f36-135">Dispose() and Dispose(bool)</span></span>

<span data-ttu-id="e8f36-136"><xref:System.IDisposable> 介面要求實作單一無參數方法 <xref:System.IDisposable.Dispose%2A>。</span><span class="sxs-lookup"><span data-stu-id="e8f36-136">The <xref:System.IDisposable> interface requires the implementation of a single parameterless method, <xref:System.IDisposable.Dispose%2A>.</span></span> <span data-ttu-id="e8f36-137">此外，任何非密封的類別都應該要有額外的多載 `Dispose(bool)` 方法來執行：</span><span class="sxs-lookup"><span data-stu-id="e8f36-137">Also, any non-sealed class should have an additional `Dispose(bool)` overload method to be implemented:</span></span>

- <span data-ttu-id="e8f36-138">沒有 `public` 任何參數的非虛擬（ `NonInheritable` 在 Visual Basic 中） <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> 執行。</span><span class="sxs-lookup"><span data-stu-id="e8f36-138">A `public` non-virtual (`NonInheritable` in Visual Basic) <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementation that has no parameters.</span></span>

- <span data-ttu-id="e8f36-139">`protected virtual`（ `Overridable` 在 Visual Basic） `Dispose` 方法，其簽章為：</span><span class="sxs-lookup"><span data-stu-id="e8f36-139">A `protected virtual` (`Overridable` in Visual Basic) `Dispose` method whose signature is:</span></span>

  [!code-csharp[Conceptual.Disposable#8](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/dispose1.cs#8)]
  [!code-vb[Conceptual.Disposable#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/dispose1.vb#8)]

  > [!IMPORTANT]
  > <span data-ttu-id="e8f36-140">`disposing` `false` 從完成項呼叫時，以及 `true` 從方法呼叫時，參數應該是 <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="e8f36-140">The `disposing` parameter should be `false` when called from a finalizer, and `true` when called from the <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="e8f36-141">換句話說，它是以決定性的方式 `true` 呼叫，並在不具決定性的情況下呼叫 `false` 。</span><span class="sxs-lookup"><span data-stu-id="e8f36-141">In other words, it is `true` when deterministically called and `false` when non-deterministically called.</span></span>

### <a name="the-dispose-method"></a><span data-ttu-id="e8f36-142">Dispose （）方法</span><span class="sxs-lookup"><span data-stu-id="e8f36-142">The Dispose() method</span></span>

<span data-ttu-id="e8f36-143">因為 `public` 非虛擬（ `NonInheritable` 在 Visual Basic）中，無參數 `Dispose` 方法是由類型的取用者呼叫，其目的是要釋放非受控資源、執行一般清除，並指出完成項（如果有的話）不需要執行。</span><span class="sxs-lookup"><span data-stu-id="e8f36-143">Because the `public`, non-virtual (`NonInheritable` in Visual Basic), parameterless `Dispose` method is called by a consumer of the type, its purpose is to free unmanaged resources, perform general cleanup, and to indicate that the finalizer, if one is present, doesn't have to run.</span></span> <span data-ttu-id="e8f36-144">釋放與 managed 物件相關聯的實際記憶體一律是[垃圾收集](index.md)行程的網域。</span><span class="sxs-lookup"><span data-stu-id="e8f36-144">Freeing the actual memory associated with a managed object is always the domain of the [garbage collector](index.md).</span></span> <span data-ttu-id="e8f36-145">因此，它擁有標準實作：</span><span class="sxs-lookup"><span data-stu-id="e8f36-145">Because of this, it has a standard implementation:</span></span>

[!code-csharp[Conceptual.Disposable#7](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/dispose1.cs#7)]
[!code-vb[Conceptual.Disposable#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/dispose1.vb#7)]

<span data-ttu-id="e8f36-146">`Dispose` 方法會執行所有物件清除，所以記憶體回收行程不需要再呼叫物件的 <xref:System.Object.Finalize%2A?displayProperty=nameWithType> 覆寫。</span><span class="sxs-lookup"><span data-stu-id="e8f36-146">The `Dispose` method performs all object cleanup, so the garbage collector no longer needs to call the objects' <xref:System.Object.Finalize%2A?displayProperty=nameWithType> override.</span></span> <span data-ttu-id="e8f36-147">因此，呼叫 <xref:System.GC.SuppressFinalize%2A> 方法會防止記憶體回收行程執行完成項。</span><span class="sxs-lookup"><span data-stu-id="e8f36-147">Therefore, the call to the <xref:System.GC.SuppressFinalize%2A> method prevents the garbage collector from running the finalizer.</span></span> <span data-ttu-id="e8f36-148">如果類型沒有完成項，則呼叫 <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> 沒有作用。</span><span class="sxs-lookup"><span data-stu-id="e8f36-148">If the type has no finalizer, the call to <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> has no effect.</span></span> <span data-ttu-id="e8f36-149">請注意，方法多載會執行實際的清除作業 `Dispose(bool)` 。</span><span class="sxs-lookup"><span data-stu-id="e8f36-149">Note that the actual cleanup is performed by the `Dispose(bool)` method overload.</span></span>

### <a name="the-disposebool-method-overload"></a><span data-ttu-id="e8f36-150">Dispose （bool）方法多載</span><span class="sxs-lookup"><span data-stu-id="e8f36-150">The Dispose(bool) method overload</span></span>

<span data-ttu-id="e8f36-151">在多載中， `disposing` 參數為 <xref:System.Boolean> ，指出方法呼叫是來自 <xref:System.IDisposable.Dispose%2A> 方法（其值為 `true` ）或來自完成項（其值為 `false` ）。</span><span class="sxs-lookup"><span data-stu-id="e8f36-151">In the overload, the `disposing` parameter is a <xref:System.Boolean> that indicates whether the method call comes from a <xref:System.IDisposable.Dispose%2A> method (its value is `true`) or from a finalizer (its value is `false`).</span></span>

<span data-ttu-id="e8f36-152">方法的主體是由兩個程式碼區塊所構成：</span><span class="sxs-lookup"><span data-stu-id="e8f36-152">The body of the method consists of two blocks of code:</span></span>

- <span data-ttu-id="e8f36-153">釋放 Unmanaged 資源的區塊。</span><span class="sxs-lookup"><span data-stu-id="e8f36-153">A block that frees unmanaged resources.</span></span> <span data-ttu-id="e8f36-154">不論 `disposing` 參數的值為何，這個區塊都會執行。</span><span class="sxs-lookup"><span data-stu-id="e8f36-154">This block executes regardless of the value of the `disposing` parameter.</span></span>
- <span data-ttu-id="e8f36-155">釋放 Managed 資源的條件性區塊。</span><span class="sxs-lookup"><span data-stu-id="e8f36-155">A conditional block that frees managed resources.</span></span> <span data-ttu-id="e8f36-156">如果 `disposing` 的值為 `true`，這個區塊就會執行。</span><span class="sxs-lookup"><span data-stu-id="e8f36-156">This block executes if the value of `disposing` is `true`.</span></span> <span data-ttu-id="e8f36-157">它所釋放的 Managed 資源可能包括：</span><span class="sxs-lookup"><span data-stu-id="e8f36-157">The managed resources that it frees can include:</span></span>

  - <span data-ttu-id="e8f36-158">**實作 <xref:System.IDisposable> 的受控物件。**</span><span class="sxs-lookup"><span data-stu-id="e8f36-158">**Managed objects that implement <xref:System.IDisposable>.**</span></span> <span data-ttu-id="e8f36-159">條件式區塊可以用來呼叫其 <xref:System.IDisposable.Dispose%2A> 實作為（cascade dispose）。</span><span class="sxs-lookup"><span data-stu-id="e8f36-159">The conditional block can be used to call their <xref:System.IDisposable.Dispose%2A> implementation (cascade dispose).</span></span> <span data-ttu-id="e8f36-160">如果您已使用的衍生類別 <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> 來包裝您的非受控資源，您應該在 <xref:System.Runtime.InteropServices.SafeHandle.Dispose?displayProperty=nameWithType> 這裡呼叫執行。</span><span class="sxs-lookup"><span data-stu-id="e8f36-160">If you have used a derived class of <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> to wrap your unmanaged resource, you should call the <xref:System.Runtime.InteropServices.SafeHandle.Dispose?displayProperty=nameWithType> implementation here.</span></span>

  - <span data-ttu-id="e8f36-161">**耗用大量記憶體或耗用少量資源的 Managed 物件。**</span><span class="sxs-lookup"><span data-stu-id="e8f36-161">**Managed objects that consume large amounts of memory or consume scarce resources.**</span></span> <span data-ttu-id="e8f36-162">將大型 managed 物件參考指派給， `null` 使其更容易到達。</span><span class="sxs-lookup"><span data-stu-id="e8f36-162">Assign large managed object references to `null` to make them more likely to be unreachable.</span></span> <span data-ttu-id="e8f36-163">比起以非決定性的方式回收，這會比更快地釋放它們。</span><span class="sxs-lookup"><span data-stu-id="e8f36-163">This releases them faster than if they were reclaimed non-deterministically.</span></span>

<span data-ttu-id="e8f36-164">如果方法呼叫來自完成項，則只會執行釋放非受控資源的程式碼。</span><span class="sxs-lookup"><span data-stu-id="e8f36-164">If the method call comes from a finalizer, only the code that frees unmanaged resources should execute.</span></span> <span data-ttu-id="e8f36-165">實施者負責確保錯誤路徑不會與可能已回收的受管理物件互動。</span><span class="sxs-lookup"><span data-stu-id="e8f36-165">The implementer is responsible for ensuring the the false path doesn't interact with managed objects that may have been reclaimed.</span></span> <span data-ttu-id="e8f36-166">這很重要，因為垃圾收集行程在最終處理期間終結 managed 物件的順序不具決定性。</span><span class="sxs-lookup"><span data-stu-id="e8f36-166">This is important because the order in which the garbage collector destroys managed objects during finalization is non-deterministic.</span></span>

## <a name="cascade-dispose-calls"></a><span data-ttu-id="e8f36-167">Cascade dispose 呼叫</span><span class="sxs-lookup"><span data-stu-id="e8f36-167">Cascade dispose calls</span></span>

<span data-ttu-id="e8f36-168">如果您的類別擁有欄位或屬性，而且它的型別為 <xref:System.IDisposable> ，則包含類別本身也應該會執行 <xref:System.IDisposable> 。</span><span class="sxs-lookup"><span data-stu-id="e8f36-168">If your class owns a field or property, and its type implements <xref:System.IDisposable>, the containing class itself should also implement <xref:System.IDisposable>.</span></span> <span data-ttu-id="e8f36-169">具 <xref:System.IDisposable> 現化實作為實例成員的類別，也會負責其清除。</span><span class="sxs-lookup"><span data-stu-id="e8f36-169">A class that instantiates an <xref:System.IDisposable> implementation and storing it as an instance member, is also responsible for its cleanup.</span></span> <span data-ttu-id="e8f36-170">這是為了協助確保參考的可處置型別有機會透過方法，以決定性的方式執行清除 <xref:System.IDisposable.Dispose%2A> 。</span><span class="sxs-lookup"><span data-stu-id="e8f36-170">This is to help ensure that the referenced disposable types are given the opportunity to deterministically perform clean up through the <xref:System.IDisposable.Dispose%2A> method.</span></span> <span data-ttu-id="e8f36-171">在此範例中，類別是 `sealed` （或 `NotInheritable` Visual Basic 中的）。</span><span class="sxs-lookup"><span data-stu-id="e8f36-171">In this example, the class is `sealed` (or `NotInheritable` in Visual Basic).</span></span>

[!code-csharp[Conceptual.Disposable#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/disposable1.cs#1)]
[!code-vb[Conceptual.Disposable#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/disposable1.vb#1)]

## <a name="implement-the-dispose-pattern"></a><span data-ttu-id="e8f36-172">執行處置模式</span><span class="sxs-lookup"><span data-stu-id="e8f36-172">Implement the dispose pattern</span></span>

<span data-ttu-id="e8f36-173">所有非密封類別或（Visual Basic 類別未修改為 `NotInheritable` ）都應該視為可能的基類，因為它們可以被繼承。</span><span class="sxs-lookup"><span data-stu-id="e8f36-173">All non-sealed classes or (Visual Basic classes not modified as `NotInheritable`) should be considered a potential base class, because they could be inherited.</span></span> <span data-ttu-id="e8f36-174">如果您針對任何可能的基類執行處置模式，您必須提供下列各項：</span><span class="sxs-lookup"><span data-stu-id="e8f36-174">If you implement the dispose pattern for any potential base class, you must provide the following:</span></span>

- <span data-ttu-id="e8f36-175">呼叫 <xref:System.IDisposable.Dispose%2A> 方法的 `Dispose(bool)` 實作。</span><span class="sxs-lookup"><span data-stu-id="e8f36-175">A <xref:System.IDisposable.Dispose%2A> implementation that calls the `Dispose(bool)` method.</span></span>
- <span data-ttu-id="e8f36-176">`Dispose(bool)`執行實際清除的方法。</span><span class="sxs-lookup"><span data-stu-id="e8f36-176">A `Dispose(bool)` method that performs the actual cleanup.</span></span>
- <span data-ttu-id="e8f36-177">衍生自包裝您的 Unmanaged 資源之 <xref:System.Runtime.InteropServices.SafeHandle> 的類別 (建議使用)，或式 <xref:System.Object.Finalize%2A?displayProperty=nameWithType> 方法的覆寫。</span><span class="sxs-lookup"><span data-stu-id="e8f36-177">Either a class derived from <xref:System.Runtime.InteropServices.SafeHandle> that wraps your unmanaged resource (recommended), or an override to the <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="e8f36-178"><xref:System.Runtime.InteropServices.SafeHandle>類別會提供完成項，因此您不需要自行撰寫。</span><span class="sxs-lookup"><span data-stu-id="e8f36-178">The <xref:System.Runtime.InteropServices.SafeHandle> class provides a finalizer, so you do not have to write one yourself.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="e8f36-179">基類可能只會參考 managed 物件，並實作為處置模式。</span><span class="sxs-lookup"><span data-stu-id="e8f36-179">It is possible for a base class to only reference managed objects, and implement the dispose pattern.</span></span> <span data-ttu-id="e8f36-180">在這些情況下，不需要完成項。</span><span class="sxs-lookup"><span data-stu-id="e8f36-180">In these cases, a finalizer is unnecessary.</span></span> <span data-ttu-id="e8f36-181">只有當您直接參考非受控資源時，才需要完成項。</span><span class="sxs-lookup"><span data-stu-id="e8f36-181">A finalizer is only required if you directly reference unmanaged resources.</span></span>

<span data-ttu-id="e8f36-182">以下一般模式將會實作使用安全控制代碼之基底類別的處置模式。</span><span class="sxs-lookup"><span data-stu-id="e8f36-182">Here's the general pattern for implementing the dispose pattern for a base class that uses a safe handle.</span></span>

[!code-csharp[System.IDisposable#3](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/base1.cs#3)]
[!code-vb[System.IDisposable#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/base1.vb#3)]

> [!NOTE]
> <span data-ttu-id="e8f36-183">上一個範例使用 <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> 物件來說明模式；可改用任何衍生自 <xref:System.Runtime.InteropServices.SafeHandle> 的物件。</span><span class="sxs-lookup"><span data-stu-id="e8f36-183">The previous example uses a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object to illustrate the pattern; any object derived from <xref:System.Runtime.InteropServices.SafeHandle> could be used instead.</span></span> <span data-ttu-id="e8f36-184">請注意，該範例未正確地執行個體化其 <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> 物件。</span><span class="sxs-lookup"><span data-stu-id="e8f36-184">Note that the example does not properly instantiate its <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object.</span></span>

<span data-ttu-id="e8f36-185">以下一般模式將會實作覆寫 <xref:System.Object.Finalize%2A?displayProperty=nameWithType> 之基底類別的處置模式。</span><span class="sxs-lookup"><span data-stu-id="e8f36-185">Here's the general pattern for implementing the dispose pattern for a base class that overrides <xref:System.Object.Finalize%2A?displayProperty=nameWithType>.</span></span>

[!code-csharp[System.IDisposable#5](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/base2.cs#5)]
[!code-vb[System.IDisposable#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/base2.vb#5)]

> [!TIP]
> <span data-ttu-id="e8f36-186">在 c # 中，您可以[藉由覆](../../csharp/programming-guide/classes-and-structs/destructors.md)寫來建立完成項 <xref:System.Object.Finalize%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="e8f36-186">In C#, you create a [finalizer](../../csharp/programming-guide/classes-and-structs/destructors.md) by overriding <xref:System.Object.Finalize%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="e8f36-187">在 Visual Basic 中，這是使用來完成 `Protected Overrides Sub Finalize()` 。</span><span class="sxs-lookup"><span data-stu-id="e8f36-187">In Visual Basic, this is done with `Protected Overrides Sub Finalize()`.</span></span>

## <a name="implement-the-dispose-pattern-for-a-derived-class"></a><span data-ttu-id="e8f36-188">執行衍生類別的處置模式</span><span class="sxs-lookup"><span data-stu-id="e8f36-188">Implement the dispose pattern for a derived class</span></span>

<span data-ttu-id="e8f36-189">從實作 <xref:System.IDisposable> 介面的類別衍生的類別不應該實作 <xref:System.IDisposable>，因為 <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> 的基底類別實作會由其衍生類別繼承。</span><span class="sxs-lookup"><span data-stu-id="e8f36-189">A class derived from a class that implements the <xref:System.IDisposable> interface shouldn't implement <xref:System.IDisposable>, because the base class implementation of <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> is inherited by its derived classes.</span></span> <span data-ttu-id="e8f36-190">相反地，若要清除衍生類別，請提供下列內容：</span><span class="sxs-lookup"><span data-stu-id="e8f36-190">Instead, to cleanup a derived class, you provide the following:</span></span>

- <span data-ttu-id="e8f36-191">一種 `protected override void Dispose(bool)` 方法，會覆寫基類方法，並執行衍生類別的實際清除。</span><span class="sxs-lookup"><span data-stu-id="e8f36-191">A `protected override void Dispose(bool)` method that overrides the base class method and performs the actual cleanup of the derived class.</span></span> <span data-ttu-id="e8f36-192">這個方法也必須呼叫 `base.Dispose(bool)` 基類的（ `MyBase.Dispose(bool)` 在 Visual Basic）方法中，並傳遞引數的處置狀態。</span><span class="sxs-lookup"><span data-stu-id="e8f36-192">This method must also call the `base.Dispose(bool)` (`MyBase.Dispose(bool)` in Visual Basic) method of the base class and pass its disposing status for the argument.</span></span>
- <span data-ttu-id="e8f36-193">衍生自包裝您的 Unmanaged 資源之 <xref:System.Runtime.InteropServices.SafeHandle> 的類別 (建議使用)，或式 <xref:System.Object.Finalize%2A?displayProperty=nameWithType> 方法的覆寫。</span><span class="sxs-lookup"><span data-stu-id="e8f36-193">Either a class derived from <xref:System.Runtime.InteropServices.SafeHandle> that wraps your unmanaged resource (recommended), or an override to the <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="e8f36-194"><xref:System.Runtime.InteropServices.SafeHandle> 類別會提供完成項，讓您不必自行撰寫程式碼。</span><span class="sxs-lookup"><span data-stu-id="e8f36-194">The <xref:System.Runtime.InteropServices.SafeHandle> class provides a finalizer that frees you from having to code one.</span></span> <span data-ttu-id="e8f36-195">如果您提供完成項，它必須呼叫具有之 `Dispose(bool)` `disposing` 引數的多載 `false` 。</span><span class="sxs-lookup"><span data-stu-id="e8f36-195">If you do provide a finalizer, it must call the `Dispose(bool)` overload with a `disposing` argument of `false`.</span></span>

<span data-ttu-id="e8f36-196">以下一般模式將會實作使用安全控制代碼之衍生類別的處置模式：</span><span class="sxs-lookup"><span data-stu-id="e8f36-196">Here's the general pattern for implementing the dispose pattern for a derived class that uses a safe handle:</span></span>

[!code-csharp[System.IDisposable#4](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/derived1.cs#4)]
[!code-vb[System.IDisposable#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/derived1.vb#4)]

> [!NOTE]
> <span data-ttu-id="e8f36-197">上一個範例使用 <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> 物件來說明模式；可改用任何衍生自 <xref:System.Runtime.InteropServices.SafeHandle> 的物件。</span><span class="sxs-lookup"><span data-stu-id="e8f36-197">The previous example uses a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object to illustrate the pattern; any object derived from <xref:System.Runtime.InteropServices.SafeHandle> could be used instead.</span></span> <span data-ttu-id="e8f36-198">請注意，該範例未正確地執行個體化其 <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> 物件。</span><span class="sxs-lookup"><span data-stu-id="e8f36-198">Note that the example does not properly instantiate its <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object.</span></span>

<span data-ttu-id="e8f36-199">以下一般模式將會實作覆寫 <xref:System.Object.Finalize%2A?displayProperty=nameWithType> 之衍生類別的處置模式：</span><span class="sxs-lookup"><span data-stu-id="e8f36-199">Here's the general pattern for implementing the dispose pattern for a derived class that overrides <xref:System.Object.Finalize%2A?displayProperty=nameWithType>:</span></span>

[!code-csharp[System.IDisposable#6](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/derived2.cs#6)]
[!code-vb[System.IDisposable#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/derived2.vb#6)]

## <a name="implement-the-dispose-pattern-with-safe-handles"></a><span data-ttu-id="e8f36-200">使用安全控制碼來執行處置模式</span><span class="sxs-lookup"><span data-stu-id="e8f36-200">Implement the dispose pattern with safe handles</span></span>

<span data-ttu-id="e8f36-201">下列範例將說明使用安全控制代碼封裝 Unmanaged 資源之基底類別 `DisposableStreamResource` 的處置模式。</span><span class="sxs-lookup"><span data-stu-id="e8f36-201">The following example illustrates the dispose pattern for a base class, `DisposableStreamResource`, that uses a safe handle to encapsulate unmanaged resources.</span></span> <span data-ttu-id="e8f36-202">它會定義 `DisposableStreamResource` 類別，該類別使用 <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> 包裝代表開啟檔案的 <xref:System.IO.Stream> 物件。</span><span class="sxs-lookup"><span data-stu-id="e8f36-202">It defines a `DisposableStreamResource` class that uses a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> to wrap a <xref:System.IO.Stream> object that represents an open file.</span></span> <span data-ttu-id="e8f36-203">類別也包含單一屬性， `Size` 它會傳回檔案資料流程中的總位元組數。</span><span class="sxs-lookup"><span data-stu-id="e8f36-203">The class also includes a single property, `Size`, that returns the total number of bytes in the file stream.</span></span>

[!code-csharp[Conceptual.Disposable#9](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/base1.cs#9)]
[!code-vb[Conceptual.Disposable#9](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/base1.vb#9)]

## <a name="implement-the-dispose-pattern-for-a-derived-class-with-safe-handles"></a><span data-ttu-id="e8f36-204">使用安全控制碼來執行衍生類別的處置模式</span><span class="sxs-lookup"><span data-stu-id="e8f36-204">Implement the dispose pattern for a derived class with safe handles</span></span>

<span data-ttu-id="e8f36-205">下列範例將說明衍生類別 `DisposableStreamResource2` 的處置模式，該類別繼承自上述範例中顯示的 `DisposableStreamResource` 類別。</span><span class="sxs-lookup"><span data-stu-id="e8f36-205">The following example illustrates the dispose pattern for a derived class, `DisposableStreamResource2`, that inherits from the `DisposableStreamResource` class presented in the previous example.</span></span> <span data-ttu-id="e8f36-206">這個類別會加入額外的方法 `WriteFileInfo`，並使用 <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> 物件包裝可寫入檔案的控制代碼。</span><span class="sxs-lookup"><span data-stu-id="e8f36-206">The class adds an additional method, `WriteFileInfo`, and uses a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object to wrap the handle of the writable file.</span></span>

[!code-csharp[Conceptual.Disposable#10](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/derived1.cs#10)]
[!code-vb[Conceptual.Disposable#10](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/derived1.vb#10)]

## <a name="see-also"></a><span data-ttu-id="e8f36-207">請參閱</span><span class="sxs-lookup"><span data-stu-id="e8f36-207">See also</span></span>

- <xref:System.GC.SuppressFinalize%2A>
- <xref:System.IDisposable>
- <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>
- <xref:Microsoft.Win32.SafeHandles>
- <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>
- <xref:System.Object.Finalize%2A?displayProperty=nameWithType>
- [<span data-ttu-id="e8f36-208">定義和使用類別和結構（c + +/CLI）</span><span class="sxs-lookup"><span data-stu-id="e8f36-208">Define and consume classes and structs (C++/CLI)</span></span>](/cpp/dotnet/how-to-define-and-consume-classes-and-structs-cpp-cli)
