---
title: .NET 中的組件
description: 元件是適用于的部署、版本控制、重複使用、啟用範圍和安全性許可權的基本單位。以網路為基礎的應用程式。
ms.date: 08/15/2019
ms.assetid: 149f5ca5-5b34-4746-9542-1ae43b2d0256
helpviewer_keywords:
- dynamic assemblies
- security [.NET Framework], boundaries
- boundaries of assemblies
- assemblies [.NET Framework], about
- assemblies [.NET Framework], boundaries
- reference scope boundaries
- assemblies [.NET Framework]
- version boundaries
- type boundaries
ms.openlocfilehash: 364a1a8c0fbaae93a02495aaf2e8c519ffb46451
ms.sourcegitcommit: 33deec3e814238fb18a49b2a7e89278e27888291
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 06/02/2020
ms.locfileid: "84290937"
---
# <a name="assemblies-in-net"></a><span data-ttu-id="1aeab-103">.NET 中的組件</span><span class="sxs-lookup"><span data-stu-id="1aeab-103">Assemblies in .NET</span></span>

<span data-ttu-id="1aeab-104">元件會形成部署、版本控制、重複使用、啟用範圍和安全性許可權的基本單位。以網路為基礎的應用程式。</span><span class="sxs-lookup"><span data-stu-id="1aeab-104">Assemblies form the fundamental units of deployment, version control, reuse, activation scoping, and security permissions for .NET-based applications.</span></span> <span data-ttu-id="1aeab-105">組件是建置來共同運作及構成一個功能邏輯單位的型別與資源集合。</span><span class="sxs-lookup"><span data-stu-id="1aeab-105">An assembly is a collection of types and resources that are built to work together and form a logical unit of functionality.</span></span> <span data-ttu-id="1aeab-106">元件採用可執行檔（*.exe*）或動態連結程式庫（*.dll*）檔案的形式，而且是 .net 應用程式的建立區塊。</span><span class="sxs-lookup"><span data-stu-id="1aeab-106">Assemblies take the form of executable (*.exe*) or dynamic link library (*.dll*) files, and are the building blocks of .NET applications.</span></span> <span data-ttu-id="1aeab-107">它們為通用語言執行平台提供了感知型別實作所需的資訊。</span><span class="sxs-lookup"><span data-stu-id="1aeab-107">They provide the common language runtime with the information it needs to be aware of type implementations.</span></span>

<span data-ttu-id="1aeab-108">在 .NET Core 和 .NET Framework 中，您可以從一或多個原始程式碼檔建立元件。</span><span class="sxs-lookup"><span data-stu-id="1aeab-108">In .NET Core and .NET Framework, you can build an assembly from one or more source code files.</span></span> <span data-ttu-id="1aeab-109">在 .NET Framework 中，組件可以包含一或多個模組。</span><span class="sxs-lookup"><span data-stu-id="1aeab-109">In .NET Framework, assemblies can contain one or more modules.</span></span> <span data-ttu-id="1aeab-110">這可讓您規劃更大的專案，讓數個開發人員可以使用個別的原始程式碼檔案或模組，這些檔案會結合以建立單一元件。</span><span class="sxs-lookup"><span data-stu-id="1aeab-110">This allows larger projects to be planned so that several developers can work on separate source code files or modules, which are combined to create a single assembly.</span></span> <span data-ttu-id="1aeab-111">如需模組的詳細資訊，請參閱[如何：建立](../../framework/app-domains/build-multifile-assembly.md)多檔案元件。</span><span class="sxs-lookup"><span data-stu-id="1aeab-111">For more information about modules, see [How to: Build a multifile assembly](../../framework/app-domains/build-multifile-assembly.md).</span></span>

<span data-ttu-id="1aeab-112">組件包含下列屬性：</span><span class="sxs-lookup"><span data-stu-id="1aeab-112">Assemblies have the following properties:</span></span>

- <span data-ttu-id="1aeab-113">元件會實作為 *.exe*或 *.dll*檔案。</span><span class="sxs-lookup"><span data-stu-id="1aeab-113">Assemblies are implemented as *.exe* or *.dll* files.</span></span>

- <span data-ttu-id="1aeab-114">針對以 .NET Framework 為目標的程式庫，您可以將元件放在[全域組件快取（GAC）](../../framework/app-domains/gac.md)中，以在應用程式之間共用它們。</span><span class="sxs-lookup"><span data-stu-id="1aeab-114">For libraries that target the .NET Framework, you can share assemblies between applications by putting them in the [global assembly cache (GAC)](../../framework/app-domains/gac.md).</span></span> <span data-ttu-id="1aeab-115">您必須先將元件強式名稱，才可以將它們包含在 GAC 中。</span><span class="sxs-lookup"><span data-stu-id="1aeab-115">You must strong-name assemblies before you can include them in the GAC.</span></span> <span data-ttu-id="1aeab-116">如需詳細資訊，請參閱[強式名稱的元件](strong-named.md)。</span><span class="sxs-lookup"><span data-stu-id="1aeab-116">For more information, see [Strong-named assemblies](strong-named.md).</span></span>

- <span data-ttu-id="1aeab-117">系統只會在需要時才將組件載入到記憶體。</span><span class="sxs-lookup"><span data-stu-id="1aeab-117">Assemblies are only loaded into memory if they are required.</span></span> <span data-ttu-id="1aeab-118">如果未使用，則不會載入它們。</span><span class="sxs-lookup"><span data-stu-id="1aeab-118">If they aren't used, they aren't loaded.</span></span> <span data-ttu-id="1aeab-119">這表示使用組件可以有效地管理大型專案中的資源。</span><span class="sxs-lookup"><span data-stu-id="1aeab-119">This means that assemblies can be an efficient way to manage resources in larger projects.</span></span>

- <span data-ttu-id="1aeab-120">藉由使用反映，您能以程式設計方式取得組件的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="1aeab-120">You can programmatically obtain information about an assembly by using reflection.</span></span> <span data-ttu-id="1aeab-121">如需詳細資訊，請參閱[反映 (C#)](../../csharp/programming-guide/concepts/reflection.md) 或 [Reflection (Visual Basic)](../../visual-basic/programming-guide/concepts/reflection.md) (反映 (Visual Basic))。</span><span class="sxs-lookup"><span data-stu-id="1aeab-121">For more information, see [Reflection (C#)](../../csharp/programming-guide/concepts/reflection.md) or [Reflection (Visual Basic)](../../visual-basic/programming-guide/concepts/reflection.md).</span></span>

- <span data-ttu-id="1aeab-122">您可以載入元件，只要使用 <xref:System.Reflection.MetadataLoadContext> .Net core 中的類別，以及 <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType> <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A?displayProperty=nameWithType> .net core 和 .NET Framework 中的或方法，即可加以檢查。</span><span class="sxs-lookup"><span data-stu-id="1aeab-122">You can load an assembly just to inspect it by using the <xref:System.Reflection.MetadataLoadContext> class in .NET Core and the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A?displayProperty=nameWithType> methods in .NET Core and .NET Framework.</span></span>

## <a name="assemblies-in-the-common-language-runtime"></a><span data-ttu-id="1aeab-123">Common language runtime 中的元件</span><span class="sxs-lookup"><span data-stu-id="1aeab-123">Assemblies in the common language runtime</span></span>

<span data-ttu-id="1aeab-124">元件會提供通用語言執行平臺所需的資訊，以感知型別實作為。</span><span class="sxs-lookup"><span data-stu-id="1aeab-124">Assemblies provide the common language runtime with the information it needs to be aware of type implementations.</span></span> <span data-ttu-id="1aeab-125">對於執行階段而言，型別不會存在於組件的內容以外。</span><span class="sxs-lookup"><span data-stu-id="1aeab-125">To the runtime, a type does not exist outside the context of an assembly.</span></span>

<span data-ttu-id="1aeab-126">元件會定義下列資訊：</span><span class="sxs-lookup"><span data-stu-id="1aeab-126">An assembly defines the following information:</span></span>

- <span data-ttu-id="1aeab-127">Common language runtime 所執行的程式碼。</span><span class="sxs-lookup"><span data-stu-id="1aeab-127">Code that the common language runtime executes.</span></span> <span data-ttu-id="1aeab-128">請注意，每個元件只能有一個進入點： `DllMain` 、 `WinMain` 或 `Main` 。</span><span class="sxs-lookup"><span data-stu-id="1aeab-128">Note that each assembly can have only one entry point: `DllMain`, `WinMain`, or `Main`.</span></span>

- <span data-ttu-id="1aeab-129">安全性界限。</span><span class="sxs-lookup"><span data-stu-id="1aeab-129">Security boundary.</span></span> <span data-ttu-id="1aeab-130">組件是要求和授與權限的單位。</span><span class="sxs-lookup"><span data-stu-id="1aeab-130">An assembly is the unit at which permissions are requested and granted.</span></span> <span data-ttu-id="1aeab-131">如需元件中安全性界限的詳細資訊，請參閱[元件安全性考慮](security-considerations.md)。</span><span class="sxs-lookup"><span data-stu-id="1aeab-131">For more information about security boundaries in assemblies, see [Assembly security considerations](security-considerations.md).</span></span>

- <span data-ttu-id="1aeab-132">類型界限。</span><span class="sxs-lookup"><span data-stu-id="1aeab-132">Type boundary.</span></span> <span data-ttu-id="1aeab-133">每種型別的識別都包含該型別所在之組件的名稱。</span><span class="sxs-lookup"><span data-stu-id="1aeab-133">Every type's identity includes the name of the assembly in which it resides.</span></span> <span data-ttu-id="1aeab-134">在某個組件範圍中載入的型別 `MyType` 與在另一個組件範圍中載入的型別 `MyType` 不同。</span><span class="sxs-lookup"><span data-stu-id="1aeab-134">A type called `MyType` that is loaded in the scope of one assembly is not the same as a type called `MyType` that is loaded in the scope of another assembly.</span></span>

- <span data-ttu-id="1aeab-135">參考範圍界限。</span><span class="sxs-lookup"><span data-stu-id="1aeab-135">Reference scope boundary.</span></span> <span data-ttu-id="1aeab-136">[組件資訊清單](#assembly-manifest)具有用來解析類型及滿足資源要求的中繼資料。</span><span class="sxs-lookup"><span data-stu-id="1aeab-136">The [assembly manifest](#assembly-manifest) has metadata that is used for resolving types and satisfying resource requests.</span></span> <span data-ttu-id="1aeab-137">資訊清單會指定要在元件外部公開的類型和資源，並列舉其相依的其他元件。</span><span class="sxs-lookup"><span data-stu-id="1aeab-137">The manifest specifies the types and resources to expose outside the assembly, and enumerates other assemblies on which it depends.</span></span> <span data-ttu-id="1aeab-138">可移植執行檔（PE）中的 Microsoft 中繼語言（MSIL）程式碼不會執行，除非它有相關聯的[元件資訊清單](#assembly-manifest)。</span><span class="sxs-lookup"><span data-stu-id="1aeab-138">Microsoft intermediate language (MSIL) code in a portable executable (PE) file won't be executed unless it has an associated [assembly manifest](#assembly-manifest).</span></span>

- <span data-ttu-id="1aeab-139">版本界限。</span><span class="sxs-lookup"><span data-stu-id="1aeab-139">Version boundary.</span></span> <span data-ttu-id="1aeab-140">元件是 common language runtime 中的最小可控制版本單位。</span><span class="sxs-lookup"><span data-stu-id="1aeab-140">The assembly is the smallest versionable unit in the common language runtime.</span></span> <span data-ttu-id="1aeab-141">相同元件中的所有類型和資源都是以一個單位進行版本設定。</span><span class="sxs-lookup"><span data-stu-id="1aeab-141">All types and resources in the same assembly are versioned as a unit.</span></span> <span data-ttu-id="1aeab-142">[組件資訊清單](#assembly-manifest)會描述您為任何相依元件指定的版本相依性。</span><span class="sxs-lookup"><span data-stu-id="1aeab-142">The [assembly manifest](#assembly-manifest) describes the version dependencies you specify for any dependent assemblies.</span></span> <span data-ttu-id="1aeab-143">如需版本控制的詳細資訊，請參閱[元件版本控制](versioning.md)。</span><span class="sxs-lookup"><span data-stu-id="1aeab-143">For more information about versioning, see [Assembly versioning](versioning.md).</span></span>

- <span data-ttu-id="1aeab-144">部署單位。</span><span class="sxs-lookup"><span data-stu-id="1aeab-144">Deployment unit.</span></span> <span data-ttu-id="1aeab-145">當應用程式啟動時，一定要有應用程式一開始所呼叫的組件。</span><span class="sxs-lookup"><span data-stu-id="1aeab-145">When an application starts, only the assemblies that the application initially calls must be present.</span></span> <span data-ttu-id="1aeab-146">其他元件（例如包含當地語系化資源或公用程式類別的元件）則可依需求抓取。</span><span class="sxs-lookup"><span data-stu-id="1aeab-146">Other assemblies, such as assemblies containing localization resources or utility classes, can be retrieved on demand.</span></span> <span data-ttu-id="1aeab-147">這可讓應用程式在第一次下載時保持簡單且精簡。</span><span class="sxs-lookup"><span data-stu-id="1aeab-147">This allows apps to be simple and thin when first downloaded.</span></span> <span data-ttu-id="1aeab-148">如需部署元件的詳細資訊，請參閱[部署應用程式](../../framework/deployment/index.md)。</span><span class="sxs-lookup"><span data-stu-id="1aeab-148">For more information about deploying assemblies, see [Deploy applications](../../framework/deployment/index.md).</span></span>

- <span data-ttu-id="1aeab-149">並存執行單位。</span><span class="sxs-lookup"><span data-stu-id="1aeab-149">Side-by-side execution unit.</span></span> <span data-ttu-id="1aeab-150">如需有關執行元件之多個版本的詳細資訊，請參閱[元件和並存執行](side-by-side-execution.md)。</span><span class="sxs-lookup"><span data-stu-id="1aeab-150">For more information about running multiple versions of an assembly, see [Assemblies and side-by-side execution](side-by-side-execution.md).</span></span>

## <a name="create-an-assembly"></a><span data-ttu-id="1aeab-151">建立元件</span><span class="sxs-lookup"><span data-stu-id="1aeab-151">Create an assembly</span></span>

<span data-ttu-id="1aeab-152">組件可以是靜態，也可以是動態。</span><span class="sxs-lookup"><span data-stu-id="1aeab-152">Assemblies can be static or dynamic.</span></span> <span data-ttu-id="1aeab-153">靜態組件儲存在磁碟上的可攜式執行檔 (PE) 中。</span><span class="sxs-lookup"><span data-stu-id="1aeab-153">Static assemblies are stored on disk in portable executable (PE) files.</span></span> <span data-ttu-id="1aeab-154">靜態元件可以包含介面、類別和資源（例如點陣圖、JPEG 檔案和其他資源檔）。</span><span class="sxs-lookup"><span data-stu-id="1aeab-154">Static assemblies can include interfaces, classes, and resources like bitmaps, JPEG files, and other resource files.</span></span> <span data-ttu-id="1aeab-155">您也可以建立動態元件，它們會直接從記憶體執行，而且不會在執行前儲存至磁片。</span><span class="sxs-lookup"><span data-stu-id="1aeab-155">You can also create dynamic assemblies, which are run directly from memory and aren't saved to disk before execution.</span></span> <span data-ttu-id="1aeab-156">您可以在執行動態組件之後，再將其儲存至磁碟。</span><span class="sxs-lookup"><span data-stu-id="1aeab-156">You can save dynamic assemblies to disk after they have executed.</span></span>

<span data-ttu-id="1aeab-157">您可以使用幾種方式建立組件。</span><span class="sxs-lookup"><span data-stu-id="1aeab-157">There are several ways to create assemblies.</span></span> <span data-ttu-id="1aeab-158">您可以使用可建立 *.dll*或 *.exe*檔案的開發工具（例如 Visual Studio）。</span><span class="sxs-lookup"><span data-stu-id="1aeab-158">You can use development tools, such as Visual Studio, that can create *.dll* or *.exe* files.</span></span> <span data-ttu-id="1aeab-159">您可以使用 Windows SDK 中的工具，利用其他開發環境中的模組來建立元件。</span><span class="sxs-lookup"><span data-stu-id="1aeab-159">You can use tools in the Windows SDK to create assemblies with modules from other development environments.</span></span> <span data-ttu-id="1aeab-160">您也可以使用 Common Language Runtime API (例如 <xref:System.Reflection.Emit?displayProperty=nameWithType>) 來建立動態組件。</span><span class="sxs-lookup"><span data-stu-id="1aeab-160">You can also use common language runtime APIs, such as <xref:System.Reflection.Emit?displayProperty=nameWithType>, to create dynamic assemblies.</span></span>

<span data-ttu-id="1aeab-161">藉由使用 .NET Core 命令列介面工具建立元件，或使用命令列編譯器建立 .NET Framework 元件，藉 Visual Studio 以編譯元件。</span><span class="sxs-lookup"><span data-stu-id="1aeab-161">Compile assemblies by building them in Visual Studio, building them with .NET Core command-line interface tools, or building .NET Framework assemblies with a command-line compiler.</span></span> <span data-ttu-id="1aeab-162">如需使用 .NET Core CLI 建立元件的詳細資訊，請參閱[.NET Core CLI 總覽](../../core/tools/index.md)。</span><span class="sxs-lookup"><span data-stu-id="1aeab-162">For more information about building assemblies using .NET Core CLI, see [.NET Core CLI overview](../../core/tools/index.md).</span></span> <span data-ttu-id="1aeab-163">如需使用命令列編譯器建立元件，請參閱使用適用于 c # 的[csc 的命令列組建](../../csharp/language-reference/compiler-options/command-line-building-with-csc-exe.md)，或[從 Visual Basic 的命令列建立](../../visual-basic/reference/command-line-compiler/building-from-the-command-line.md)。</span><span class="sxs-lookup"><span data-stu-id="1aeab-163">For building assemblies with the command-line compilers, see [Command-line build with csc.exe](../../csharp/language-reference/compiler-options/command-line-building-with-csc-exe.md) for C#, or [Build from the command line](../../visual-basic/reference/command-line-compiler/building-from-the-command-line.md) for Visual Basic.</span></span>

> [!NOTE]
> <span data-ttu-id="1aeab-164">若要在 Visual Studio 中建立元件，請在 [**建立**] 功能表上，選取 [**建立**]。</span><span class="sxs-lookup"><span data-stu-id="1aeab-164">To build an assembly in Visual Studio, on the **Build** menu, select **Build**.</span></span>

## <a name="assembly-manifest"></a><span data-ttu-id="1aeab-165">資訊清單</span><span class="sxs-lookup"><span data-stu-id="1aeab-165">Assembly manifest</span></span>

<span data-ttu-id="1aeab-166">每個元件都有一個*組件資訊清單*檔。</span><span class="sxs-lookup"><span data-stu-id="1aeab-166">Every assembly has an *assembly manifest* file.</span></span> <span data-ttu-id="1aeab-167">類似于目錄，組件資訊清單包含：</span><span class="sxs-lookup"><span data-stu-id="1aeab-167">Similar to a table of contents, the assembly manifest contains:</span></span>

- <span data-ttu-id="1aeab-168">組件的身分識別 (其名稱和版本)。</span><span class="sxs-lookup"><span data-stu-id="1aeab-168">The assembly's identity (its name and version).</span></span>

- <span data-ttu-id="1aeab-169">一個檔案表格，描述組成元件的所有其他檔案，例如您所建立的其他元件，亦即您的 *.exe*或 *.dll*檔案依賴、點陣圖檔案或讀我檔案。</span><span class="sxs-lookup"><span data-stu-id="1aeab-169">A file table describing all the other files that make up the assembly, such as other assemblies you created that your *.exe* or *.dll* file relies on, bitmap files, or Readme files.</span></span>

- <span data-ttu-id="1aeab-170">*元件參考清單*，這是所有外部相依性的清單，例如 *.dll*s 或其他檔案。</span><span class="sxs-lookup"><span data-stu-id="1aeab-170">An *assembly reference list*, which is a list of all external dependencies, such as *.dll*s or other files.</span></span> <span data-ttu-id="1aeab-171">組件參考同時包含全域和私用物件的參考。</span><span class="sxs-lookup"><span data-stu-id="1aeab-171">Assembly references contain references to both global and private objects.</span></span> <span data-ttu-id="1aeab-172">所有其他應用程式皆可使用全域物件。</span><span class="sxs-lookup"><span data-stu-id="1aeab-172">Global objects are available to all other applications.</span></span> <span data-ttu-id="1aeab-173">在 .NET Core 中，全域物件會與特定的 .NET Core 執行時間結合。</span><span class="sxs-lookup"><span data-stu-id="1aeab-173">In .NET Core, global objects are coupled with a particular .NET Core runtime.</span></span> <span data-ttu-id="1aeab-174">在 .NET Framework 中，全域物件位於全域組件快取（GAC）中。</span><span class="sxs-lookup"><span data-stu-id="1aeab-174">In .NET Framework, global objects reside in the global assembly cache (GAC).</span></span> <span data-ttu-id="1aeab-175">*System.web*是 GAC 中元件的範例。</span><span class="sxs-lookup"><span data-stu-id="1aeab-175">*System.IO.dll* is an example of an assembly in the GAC.</span></span> <span data-ttu-id="1aeab-176">私用物件必須在您應用程式安裝所在目錄的目錄層級中。</span><span class="sxs-lookup"><span data-stu-id="1aeab-176">Private objects must be in a directory level at or below the directory in which your app is installed.</span></span>

<span data-ttu-id="1aeab-177">因為元件包含內容、版本設定及相依性的相關資訊，所以使用它們的應用程式不需要依賴外部來源（例如 Windows 系統上的登錄），就能正常運作。</span><span class="sxs-lookup"><span data-stu-id="1aeab-177">Because assemblies contain information about content, versioning, and dependencies, the applications that use them needn't rely on external sources, such as the registry on Windows systems, to function properly.</span></span> <span data-ttu-id="1aeab-178">元件可減少 *.dll 的*衝突，讓您的應用程式更可靠且更容易部署。</span><span class="sxs-lookup"><span data-stu-id="1aeab-178">Assemblies reduce *.dll* conflicts and make your applications more reliable and easier to deploy.</span></span> <span data-ttu-id="1aeab-179">在許多情況下，您只要將 .NET 型應用程式的檔案複製到目標電腦，即完成安裝。</span><span class="sxs-lookup"><span data-stu-id="1aeab-179">In many cases, you can install a .NET-based application simply by copying its files to the target computer.</span></span> <span data-ttu-id="1aeab-180">如需詳細資訊，請參閱[組件資訊清單](manifest.md)。</span><span class="sxs-lookup"><span data-stu-id="1aeab-180">For more information, see [Assembly manifest](manifest.md).</span></span>

## <a name="add-a-reference-to-an-assembly"></a><span data-ttu-id="1aeab-181">加入元件的參考</span><span class="sxs-lookup"><span data-stu-id="1aeab-181">Add a reference to an assembly</span></span>

<span data-ttu-id="1aeab-182">若要在應用程式中使用元件，您必須加入它的參考。</span><span class="sxs-lookup"><span data-stu-id="1aeab-182">To use an assembly in an application, you must add a reference to it.</span></span> <span data-ttu-id="1aeab-183">參考元件之後，所有可存取的類型、屬性、方法和其命名空間的其他成員，都可供您的應用程式使用，就像其程式碼屬於您的來源檔案。</span><span class="sxs-lookup"><span data-stu-id="1aeab-183">Once an assembly is referenced, all the accessible types, properties, methods, and other members of its namespaces are available to your application as if their code were part of your source file.</span></span>

> [!NOTE]
> <span data-ttu-id="1aeab-184">系統會自動參考 .NET 類別庫中的大多數組件。</span><span class="sxs-lookup"><span data-stu-id="1aeab-184">Most assemblies from the .NET Class Library are referenced automatically.</span></span> <span data-ttu-id="1aeab-185">如果未自動參考系統元件，則針對 .NET Core，您可以加入包含元件之 NuGet 套件的參考。</span><span class="sxs-lookup"><span data-stu-id="1aeab-185">If a system assembly isn't automatically referenced, for .NET Core, you can add a reference to the NuGet package that contains the assembly.</span></span> <span data-ttu-id="1aeab-186">請使用 Visual Studio 中的 NuGet 套件管理員，或將 [\<PackageReference>](../../core/tools/dependencies.md#the-packagereference-element) 元件的元素新增至 *.csproj*或 *. vbproj*專案。</span><span class="sxs-lookup"><span data-stu-id="1aeab-186">Either use the NuGet Package Manager in Visual Studio, or add a [\<PackageReference>](../../core/tools/dependencies.md#the-packagereference-element) element for the assembly to the *.csproj* or *.vbproj* project.</span></span> <span data-ttu-id="1aeab-187">在 .NET Framework 中，您可以使用 Visual Studio 中的 [**加入參考**] 對話方塊，或使用 `-reference` [c #](../../csharp/language-reference/compiler-options/reference-compiler-option.md)或[Visual Basic](../../visual-basic/reference/command-line-compiler/reference.md)編譯器的命令列選項，將參考加入至元件。</span><span class="sxs-lookup"><span data-stu-id="1aeab-187">In .NET Framework, you can add a reference to the assembly by using the **Add Reference** dialog in Visual Studio, or by using the `-reference` command line option for the [C#](../../csharp/language-reference/compiler-options/reference-compiler-option.md) or [Visual Basic](../../visual-basic/reference/command-line-compiler/reference.md) compilers.</span></span>

<span data-ttu-id="1aeab-188">在 c # 中，您可以在單一應用程式中使用相同元件的兩個版本。</span><span class="sxs-lookup"><span data-stu-id="1aeab-188">In C#, you can use two versions of the same assembly in a single application.</span></span> <span data-ttu-id="1aeab-189">如需詳細資訊，請參閱[外部別名](../../csharp/language-reference/keywords/extern-alias.md)。</span><span class="sxs-lookup"><span data-stu-id="1aeab-189">For more information, see [extern alias](../../csharp/language-reference/keywords/extern-alias.md).</span></span>

## <a name="related-content"></a><span data-ttu-id="1aeab-190">相關內容</span><span class="sxs-lookup"><span data-stu-id="1aeab-190">Related content</span></span>

|<span data-ttu-id="1aeab-191">Title</span><span class="sxs-lookup"><span data-stu-id="1aeab-191">Title</span></span>|<span data-ttu-id="1aeab-192">描述</span><span class="sxs-lookup"><span data-stu-id="1aeab-192">Description</span></span>|
|-----------|-----------------|
|[<span data-ttu-id="1aeab-193">組件內容</span><span class="sxs-lookup"><span data-stu-id="1aeab-193">Assembly contents</span></span>](contents.md)|<span data-ttu-id="1aeab-194">組成元件的元素。</span><span class="sxs-lookup"><span data-stu-id="1aeab-194">Elements that make up an assembly.</span></span>|
|[<span data-ttu-id="1aeab-195">組件資訊清單</span><span class="sxs-lookup"><span data-stu-id="1aeab-195">Assembly manifest</span></span>](manifest.md)|<span data-ttu-id="1aeab-196">組件資訊清單中的資料，以及它如何儲存在元件中。</span><span class="sxs-lookup"><span data-stu-id="1aeab-196">Data in the assembly manifest, and how it is stored in assemblies.</span></span>|
|[<span data-ttu-id="1aeab-197">全域組件快取</span><span class="sxs-lookup"><span data-stu-id="1aeab-197">Global assembly cache</span></span>](../../framework/app-domains/gac.md)|<span data-ttu-id="1aeab-198">GAC 儲存和使用元件的方式。</span><span class="sxs-lookup"><span data-stu-id="1aeab-198">How the GAC stores and uses assemblies.</span></span>|
|[<span data-ttu-id="1aeab-199">強式名稱組件</span><span class="sxs-lookup"><span data-stu-id="1aeab-199">Strong-named assemblies</span></span>](strong-named.md)|<span data-ttu-id="1aeab-200">強式名稱元件的特性。</span><span class="sxs-lookup"><span data-stu-id="1aeab-200">Characteristics of strong-named assemblies.</span></span>|
|[<span data-ttu-id="1aeab-201">組件安全性考量</span><span class="sxs-lookup"><span data-stu-id="1aeab-201">Assembly security considerations</span></span>](security-considerations.md)|<span data-ttu-id="1aeab-202">元件的安全性運作方式。</span><span class="sxs-lookup"><span data-stu-id="1aeab-202">How security works with assemblies.</span></span>|
|[<span data-ttu-id="1aeab-203">組件版本控制</span><span class="sxs-lookup"><span data-stu-id="1aeab-203">Assembly versioning</span></span>](versioning.md)|<span data-ttu-id="1aeab-204">.NET Framework 版本控制原則的總覽。</span><span class="sxs-lookup"><span data-stu-id="1aeab-204">Overview of the .NET Framework versioning policy.</span></span>|
|[<span data-ttu-id="1aeab-205">組件放置</span><span class="sxs-lookup"><span data-stu-id="1aeab-205">Assembly placement</span></span>](../../framework/app-domains/assembly-placement.md)|<span data-ttu-id="1aeab-206">哪裡可以找到元件。</span><span class="sxs-lookup"><span data-stu-id="1aeab-206">Where to locate assemblies.</span></span>|
|[<span data-ttu-id="1aeab-207">組件和並存執行</span><span class="sxs-lookup"><span data-stu-id="1aeab-207">Assemblies and side-by-side execution</span></span>](side-by-side-execution.md)|<span data-ttu-id="1aeab-208">同時使用多個版本的執行時間或元件。</span><span class="sxs-lookup"><span data-stu-id="1aeab-208">Use multiple versions of the runtime or an assembly simultaneously.</span></span>|
|[<span data-ttu-id="1aeab-209">發出動態方法和組件</span><span class="sxs-lookup"><span data-stu-id="1aeab-209">Emit dynamic methods and assemblies</span></span>](../../framework/reflection-and-codedom/emitting-dynamic-methods-and-assemblies.md)|<span data-ttu-id="1aeab-210">如何建立動態元件。</span><span class="sxs-lookup"><span data-stu-id="1aeab-210">How to create dynamic assemblies.</span></span>|
|[<span data-ttu-id="1aeab-211">執行時間如何找出元件</span><span class="sxs-lookup"><span data-stu-id="1aeab-211">How the runtime locates assemblies</span></span>](../../framework/deployment/how-the-runtime-locates-assemblies.md)|<span data-ttu-id="1aeab-212">.NET Framework 如何在執行時間解析元件參考。</span><span class="sxs-lookup"><span data-stu-id="1aeab-212">How the .NET Framework resolves assembly references at run time.</span></span>|

## <a name="reference"></a><span data-ttu-id="1aeab-213">參考</span><span class="sxs-lookup"><span data-stu-id="1aeab-213">Reference</span></span>

<xref:System.Reflection.Assembly?displayProperty=nameWithType>

## <a name="see-also"></a><span data-ttu-id="1aeab-214">另請參閱</span><span class="sxs-lookup"><span data-stu-id="1aeab-214">See also</span></span>

- [<span data-ttu-id="1aeab-215">.NET 組件檔格式</span><span class="sxs-lookup"><span data-stu-id="1aeab-215">.NET assembly file format</span></span>](file-format.md)
- [<span data-ttu-id="1aeab-216">Friend 組件</span><span class="sxs-lookup"><span data-stu-id="1aeab-216">Friend assemblies</span></span>](friend.md)
- [<span data-ttu-id="1aeab-217">參考組件</span><span class="sxs-lookup"><span data-stu-id="1aeab-217">Reference assemblies</span></span>](reference-assemblies.md)
- [<span data-ttu-id="1aeab-218">如何：載入和卸載元件</span><span class="sxs-lookup"><span data-stu-id="1aeab-218">How to: Load and unload assemblies</span></span>](load-unload.md)
- [<span data-ttu-id="1aeab-219">如何：在 .NET Core 中使用和 debug 元件卸載功能</span><span class="sxs-lookup"><span data-stu-id="1aeab-219">How to: Use and debug assembly unloadability in .NET Core</span></span>](unloadability.md)
- [<span data-ttu-id="1aeab-220">如何：判斷檔案是否為元件</span><span class="sxs-lookup"><span data-stu-id="1aeab-220">How to: Determine if a file is an assembly</span></span>](identify.md)
- [<span data-ttu-id="1aeab-221">如何：使用 MetadataLoadCoNtext 檢查元件內容</span><span class="sxs-lookup"><span data-stu-id="1aeab-221">How to: Inspect assembly contents using MetadataLoadContext</span></span>](inspect-contents-using-metadataloadcontext.md)
