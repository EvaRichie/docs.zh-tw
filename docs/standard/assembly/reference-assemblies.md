---
title: 參考組件
description: 瞭解參考元件，這是 .NET 中只包含程式庫公用 API 介面的特殊元件類型
author: MSDN-WhiteKnight
ms.date: 09/12/2019
ms.openlocfilehash: 2f7f026c7fca4b772be85671dcc3a2a6d50a385c
ms.sourcegitcommit: 965a5af7918acb0a3fd3baf342e15d511ef75188
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 11/18/2020
ms.locfileid: "94831048"
---
# <a name="reference-assemblies"></a><span data-ttu-id="ab0c9-103">參考組件</span><span class="sxs-lookup"><span data-stu-id="ab0c9-103">Reference assemblies</span></span>

<span data-ttu-id="ab0c9-104">*參考元件* 是一種特殊類型的元件，其中只包含代表程式庫公用 API 介面所需的最少量中繼資料。</span><span class="sxs-lookup"><span data-stu-id="ab0c9-104">*Reference assemblies* are a special type of assembly that contain only the minimum amount of metadata required to represent the library's public API surface.</span></span> <span data-ttu-id="ab0c9-105">它們包括在組建工具中參考元件時，所有重要成員的宣告，但排除對其 API 合約沒有任何影響的私用成員的所有成員執行和宣告。</span><span class="sxs-lookup"><span data-stu-id="ab0c9-105">They include declarations for all members that are significant when referencing an assembly in build tools, but exclude all member implementations and declarations of private members that have no observable impact on their API contract.</span></span> <span data-ttu-id="ab0c9-106">相反地，一般元件稱為「 *實元件*」。</span><span class="sxs-lookup"><span data-stu-id="ab0c9-106">In contrast, regular assemblies are called *implementation assemblies*.</span></span>

<span data-ttu-id="ab0c9-107">無法載入參考元件來執行，但是可以用與實元件相同的方式，將它們當作編譯器輸入來傳遞。</span><span class="sxs-lookup"><span data-stu-id="ab0c9-107">Reference assemblies can't be loaded for execution, but they can be passed as compiler input in the same way as implementation assemblies.</span></span> <span data-ttu-id="ab0c9-108">參考元件通常會與特定平臺或程式庫 (SDK) 的軟體發展工具組一起散發。</span><span class="sxs-lookup"><span data-stu-id="ab0c9-108">Reference assemblies are usually distributed with the Software Development Kit (SDK) of a particular platform or library.</span></span>

<span data-ttu-id="ab0c9-109">使用參考元件可讓開發人員建立以特定程式庫版本為目標的程式，而不會有該版本的完整實元件。</span><span class="sxs-lookup"><span data-stu-id="ab0c9-109">Using a reference assembly enables developers to build programs that target a specific library version without having the full implementation assembly for that version.</span></span> <span data-ttu-id="ab0c9-110">假設您的電腦上只有一些程式庫的最新版本，但您想要建立以該程式庫舊版為目標的程式。</span><span class="sxs-lookup"><span data-stu-id="ab0c9-110">Suppose, you have only the latest version of some library on your machine, but you want to build a program that targets an earlier version of that library.</span></span> <span data-ttu-id="ab0c9-111">如果您直接針對實程式元件進行編譯，您可能會不小心使用先前版本中無法使用的 API 成員。</span><span class="sxs-lookup"><span data-stu-id="ab0c9-111">If you compile directly against the implementation assembly, you might inadvertently use API members that aren't available in the earlier version.</span></span> <span data-ttu-id="ab0c9-112">在目的電腦上測試程式時，您只會發現這個錯誤。</span><span class="sxs-lookup"><span data-stu-id="ab0c9-112">You'll only find this mistake when testing the program on the target machine.</span></span> <span data-ttu-id="ab0c9-113">如果您針對較早版本的參考元件進行編譯，您將會立即收到編譯時期錯誤。</span><span class="sxs-lookup"><span data-stu-id="ab0c9-113">If you compile against the reference assembly for the earlier version, you'll immediately get a compile-time error.</span></span>

<span data-ttu-id="ab0c9-114">參考元件也可以代表合約，也就是一組未對應到具體實元件的 Api。</span><span class="sxs-lookup"><span data-stu-id="ab0c9-114">A reference assembly can also represent a contract, that is, a set of APIs that don't correspond to the concrete implementation assembly.</span></span> <span data-ttu-id="ab0c9-115">這類稱為 *合約元件* 的參考元件可以用來將多個平臺的目標設定為支援相同的 api 集。</span><span class="sxs-lookup"><span data-stu-id="ab0c9-115">Such reference assemblies, called the *contract assembly*, can be used to target multiple platforms that support the same set of APIs.</span></span> <span data-ttu-id="ab0c9-116">例如，.NET Standard 提供合約元件 *netstandard.dll*，代表在不同 .net 平臺之間共用的一組通用 api。</span><span class="sxs-lookup"><span data-stu-id="ab0c9-116">For example, .NET Standard provides the contract assembly, *netstandard.dll*, that represents the set of common APIs shared between different .NET platforms.</span></span> <span data-ttu-id="ab0c9-117">這些 Api 的執行是包含在不同平臺上的不同元件中，例如在 .NET Framework 上的 *mscorlib.dll* 或 .net Core 上的 *System.Private.CoreLib.dll* 。</span><span class="sxs-lookup"><span data-stu-id="ab0c9-117">The implementations of these APIs are contained in different assemblies on different platforms, such as *mscorlib.dll* on .NET Framework or *System.Private.CoreLib.dll* on .NET Core.</span></span> <span data-ttu-id="ab0c9-118">以 .NET Standard 為目標的程式庫可以在支援 .NET Standard 的所有平臺上執行。</span><span class="sxs-lookup"><span data-stu-id="ab0c9-118">A library that targets .NET Standard can run on all platforms that support .NET Standard.</span></span>

## <a name="using-reference-assemblies"></a><span data-ttu-id="ab0c9-119">使用參考元件</span><span class="sxs-lookup"><span data-stu-id="ab0c9-119">Using reference assemblies</span></span>

<span data-ttu-id="ab0c9-120">若要從您的專案使用特定 Api，您必須將參考加入其元件中。</span><span class="sxs-lookup"><span data-stu-id="ab0c9-120">To use certain APIs from your project, you must add references to their assemblies.</span></span> <span data-ttu-id="ab0c9-121">您可以新增對實元件或參考元件的參考。</span><span class="sxs-lookup"><span data-stu-id="ab0c9-121">You can add references to either implementation assemblies or to reference assemblies.</span></span> <span data-ttu-id="ab0c9-122">建議您在每次有參考元件時使用。</span><span class="sxs-lookup"><span data-stu-id="ab0c9-122">It's recommended you use reference assemblies whenever they're available.</span></span> <span data-ttu-id="ab0c9-123">這麼做可確保您只會在目標版本中使用支援的 API 成員，以供 API 設計師使用。</span><span class="sxs-lookup"><span data-stu-id="ab0c9-123">Doing so ensures that you're using only the supported API members in the target version, meant to be used by API designers.</span></span> <span data-ttu-id="ab0c9-124">使用參考元件可確保您不會依賴執行的詳細資料。</span><span class="sxs-lookup"><span data-stu-id="ab0c9-124">Using the reference assembly ensures you're not taking a dependency on implementation details.</span></span>

<span data-ttu-id="ab0c9-125">.NET Framework 程式庫的參考元件會以目標套件來散發。</span><span class="sxs-lookup"><span data-stu-id="ab0c9-125">Reference assemblies for the .NET Framework libraries are distributed with targeting packs.</span></span> <span data-ttu-id="ab0c9-126">您可以下載獨立安裝程式，或在 Visual Studio 安裝程式中選取元件來取得它們。</span><span class="sxs-lookup"><span data-stu-id="ab0c9-126">You can obtain them by downloading a standalone installer or by selecting a component in Visual Studio installer.</span></span> <span data-ttu-id="ab0c9-127">如需詳細資訊，請參閱 [安裝適用于開發人員的 .NET Framework](../../framework/install/guide-for-developers.md)。</span><span class="sxs-lookup"><span data-stu-id="ab0c9-127">For more information, see [Install the .NET Framework for developers](../../framework/install/guide-for-developers.md).</span></span> <span data-ttu-id="ab0c9-128">若是 .NET Core 和 .NET Standard，參考元件會視需要自動下載， (透過 NuGet) 並加以參考。</span><span class="sxs-lookup"><span data-stu-id="ab0c9-128">For .NET Core and .NET Standard, reference assemblies are automatically downloaded as necessary (via NuGet) and referenced.</span></span> <span data-ttu-id="ab0c9-129">針對 .NET Core 3.0 和更新版本，核心架構的參考元件會在 NETCore 中，而不是使用 3.0) 之前的版本，而是使用 ([Microsoft.NETCore.App.Ref](https://www.nuget.org/packages/Microsoft.NETCore.App.Ref) [套件。](https://www.nuget.org/packages/Microsoft.NETCore.App)</span><span class="sxs-lookup"><span data-stu-id="ab0c9-129">For .NET Core 3.0 and higher, the reference assemblies for the core framework are in the [Microsoft.NETCore.App.Ref](https://www.nuget.org/packages/Microsoft.NETCore.App.Ref) package (the [Microsoft.NETCore.App](https://www.nuget.org/packages/Microsoft.NETCore.App) package is used instead for versions before 3.0).</span></span>

<span data-ttu-id="ab0c9-130">當您使用 [ **加入參考** ] 對話方塊在 Visual Studio 中新增 .NET Framework 元件的參考時，您會從清單中選取元件，而 Visual Studio 會自動尋找對應至您專案中所選取之目標 Framework 版本的參考元件。</span><span class="sxs-lookup"><span data-stu-id="ab0c9-130">When you add references to .NET Framework assemblies in Visual Studio using the **Add reference** dialog, you select an assembly from the list, and Visual Studio automatically finds reference assemblies that correspond to the target framework version selected in your project.</span></span> <span data-ttu-id="ab0c9-131">同樣適用于使用  [參考](/visualstudio/msbuild/common-msbuild-project-items#reference) 專案專案直接將參考新增至 MSBuild 專案：您只需要指定元件名稱，而不是完整檔案路徑。</span><span class="sxs-lookup"><span data-stu-id="ab0c9-131">The same applies to adding references directly into MSBuild project using the  [Reference](/visualstudio/msbuild/common-msbuild-project-items#reference) project item: you only need to specify the assembly name, not the full file path.</span></span> <span data-ttu-id="ab0c9-132">當您在命令列中使用 `-reference` 編譯器選項 ([在 c #](../../csharp/language-reference/compiler-options/reference-compiler-option.md) 和 [Visual Basic](../../visual-basic/reference/command-line-compiler/reference.md)) 或使用 Roslyn API 中的方法來新增這些元件的參考時 <xref:Microsoft.CodeAnalysis.Compilation.AddReferences%2A?displayProperty=nameWithType> ，您必須手動指定正確目標平臺版本的參考元件檔。</span><span class="sxs-lookup"><span data-stu-id="ab0c9-132">When you add references to these assemblies in the command line by using the `-reference` compiler option ([in C#](../../csharp/language-reference/compiler-options/reference-compiler-option.md) and in [Visual Basic](../../visual-basic/reference/command-line-compiler/reference.md)) or by using the <xref:Microsoft.CodeAnalysis.Compilation.AddReferences%2A?displayProperty=nameWithType> method in the Roslyn API, you must manually specify reference assembly files for the correct target platform version.</span></span> <span data-ttu-id="ab0c9-133">.NET Framework 參考元件檔位於 *% ProgramFiles (x86) % \\ reference 元件 \\ Microsoft \\ Framework \\ 。.Netframework* 目錄。</span><span class="sxs-lookup"><span data-stu-id="ab0c9-133">.NET Framework reference assembly files are located in the *%ProgramFiles(x86)%\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework* directory.</span></span> <span data-ttu-id="ab0c9-134">若是 .NET Core，您可以藉由將專案屬性設定為，強制發行作業將目標平臺的參考元件複製到輸出目錄的 *發行/refs* 子目錄中 `PreserveCompilationContext` `true` 。</span><span class="sxs-lookup"><span data-stu-id="ab0c9-134">For .NET Core, you can force publish operation to copy reference assemblies for your target platform into the *publish/refs* subdirectory of your output directory by setting the `PreserveCompilationContext` project property to `true`.</span></span> <span data-ttu-id="ab0c9-135">然後，您可以將這些參考元件檔傳遞給編譯器。</span><span class="sxs-lookup"><span data-stu-id="ab0c9-135">Then you can pass these reference assembly files to the compiler.</span></span> <span data-ttu-id="ab0c9-136">使用 `DependencyContext` [DependencyModel](https://www.nuget.org/packages/Microsoft.Extensions.DependencyModel/) 套件可協助找出其路徑。</span><span class="sxs-lookup"><span data-stu-id="ab0c9-136">Using `DependencyContext` from [Microsoft.Extensions.DependencyModel](https://www.nuget.org/packages/Microsoft.Extensions.DependencyModel/) package can help locate their paths.</span></span>

<span data-ttu-id="ab0c9-137">因為它們不包含任何執行，所以無法載入參考元件以執行。</span><span class="sxs-lookup"><span data-stu-id="ab0c9-137">Because they contain no implementation, reference assemblies can't be loaded for execution.</span></span> <span data-ttu-id="ab0c9-138">嘗試這麼做會導致 <xref:System.BadImageFormatException?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="ab0c9-138">Trying to do so results in a <xref:System.BadImageFormatException?displayProperty=nameWithType>.</span></span> <span data-ttu-id="ab0c9-139">如果您想要檢查參考元件的內容，您可以使用) 的方法，將它載入至僅限反映的內容，並將它載入 <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType> 至 <xref:System.Reflection.MetadataLoadContext> .net Core 中的 .NET Framework (。</span><span class="sxs-lookup"><span data-stu-id="ab0c9-139">If you want to examine the contents of a reference assembly, you can load it into the reflection-only context in .NET Framework (using the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType> method) or into the <xref:System.Reflection.MetadataLoadContext> in .NET Core.</span></span>

## <a name="generating-reference-assemblies"></a><span data-ttu-id="ab0c9-140">產生參考元件</span><span class="sxs-lookup"><span data-stu-id="ab0c9-140">Generating reference assemblies</span></span>

<span data-ttu-id="ab0c9-141">當您的程式庫取用者需要針對許多不同的程式庫版本建立程式時，產生程式庫的參考元件會很有用。</span><span class="sxs-lookup"><span data-stu-id="ab0c9-141">Generating reference assemblies for your libraries can be useful when your library consumers need to build their programs against many different versions of the library.</span></span> <span data-ttu-id="ab0c9-142">因為這些版本的大小很大，所以散發這些版本的實作為元件可能不切實際。</span><span class="sxs-lookup"><span data-stu-id="ab0c9-142">Distributing implementation assemblies for all these versions might be impractical because of their large size.</span></span> <span data-ttu-id="ab0c9-143">參考元件的大小較小，而將它們發佈為程式庫 SDK 的一部分，可減少下載大小並節省磁碟空間。</span><span class="sxs-lookup"><span data-stu-id="ab0c9-143">Reference assemblies are smaller in size, and distributing them as a part of your library's SDK reduces download size and saves disk space.</span></span>

<span data-ttu-id="ab0c9-144">Ide 和組建工具也可以利用參考元件，以在由多個類別庫組成的大型方案時減少組建時間。</span><span class="sxs-lookup"><span data-stu-id="ab0c9-144">IDEs and build tools also can take advantage of reference assemblies to reduce build times in case of large solutions consisting of multiple class libraries.</span></span> <span data-ttu-id="ab0c9-145">通常，在累加式組建案例中，專案會在其任何輸入檔變更時重建，包括它所相依的元件。</span><span class="sxs-lookup"><span data-stu-id="ab0c9-145">Usually, in incremental build scenarios a project is rebuilt when any of its input files are changed, including the assemblies it depends on.</span></span> <span data-ttu-id="ab0c9-146">每次程式設計師變更任何成員的執行時，就會變更實組元件。</span><span class="sxs-lookup"><span data-stu-id="ab0c9-146">The implementation assembly changes whenever the programmer changes the implementation of any member.</span></span> <span data-ttu-id="ab0c9-147">只有在參考元件的公用 API 受到影響時，參考元件才會變更。</span><span class="sxs-lookup"><span data-stu-id="ab0c9-147">The reference assembly only changes when its public API is affected.</span></span> <span data-ttu-id="ab0c9-148">因此，在某些情況下，使用參考元件做為輸入檔（而非實作為元件）可略過相依專案的組建。</span><span class="sxs-lookup"><span data-stu-id="ab0c9-148">So, using the reference assembly as an input file instead of the implementation assembly allows skipping the build of the dependent project in some cases.</span></span>

<span data-ttu-id="ab0c9-149">您可以產生參考元件：</span><span class="sxs-lookup"><span data-stu-id="ab0c9-149">You can generate reference assemblies:</span></span>

- <span data-ttu-id="ab0c9-150">在 MSBuild 專案中，使用[ `ProduceReferenceAssembly` 專案屬性](/visualstudio/msbuild/common-msbuild-project-properties)。</span><span class="sxs-lookup"><span data-stu-id="ab0c9-150">In an MSBuild project, by using the [`ProduceReferenceAssembly` project property](/visualstudio/msbuild/common-msbuild-project-properties).</span></span>
- <span data-ttu-id="ab0c9-151">從命令列編譯器時，指定 `-refonly` ([c #](../../csharp/language-reference/compiler-options/refonly-compiler-option.md)  /  [Visual Basic](../../visual-basic/reference/command-line-compiler/refonly-compiler-option.md) ) 或 `-refout` ([c #](../../csharp/language-reference/compiler-options/refout-compiler-option.md)  /  [Visual Basic](../../visual-basic/reference/command-line-compiler/refout-compiler-option.md)) 編譯器選項。</span><span class="sxs-lookup"><span data-stu-id="ab0c9-151">When compiling program from command line, by specifiying `-refonly` ([C#](../../csharp/language-reference/compiler-options/refonly-compiler-option.md) / [Visual Basic](../../visual-basic/reference/command-line-compiler/refonly-compiler-option.md) ) or `-refout` ([C#](../../csharp/language-reference/compiler-options/refout-compiler-option.md) / [Visual Basic](../../visual-basic/reference/command-line-compiler/refout-compiler-option.md)) compiler options.</span></span>
- <span data-ttu-id="ab0c9-152">使用 Roslyn API 時， <xref:Microsoft.CodeAnalysis.Emit.EmitOptions.EmitMetadataOnly?displayProperty=nameWithType> `true` <xref:Microsoft.CodeAnalysis.Emit.EmitOptions.IncludePrivateMembers?displayProperty=nameWithType> `false` 在傳遞至方法的物件中將設定為和 <xref:Microsoft.CodeAnalysis.Compilation.Emit%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="ab0c9-152">When using the Roslyn API, by setting <xref:Microsoft.CodeAnalysis.Emit.EmitOptions.EmitMetadataOnly?displayProperty=nameWithType> to `true` and <xref:Microsoft.CodeAnalysis.Emit.EmitOptions.IncludePrivateMembers?displayProperty=nameWithType> to `false` in an object passed to the <xref:Microsoft.CodeAnalysis.Compilation.Emit%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="ab0c9-153">如果您想要使用 NuGet 套件散發參考元件，則必須將它們包含在封裝目錄下的 *ref \\* 子目錄中，而不是在用於實元件的 *lib \\* 子目錄中。</span><span class="sxs-lookup"><span data-stu-id="ab0c9-153">If you want to distribute reference assemblies with NuGet packages, you must include them in the *ref\\* subdirectory under the package directory instead of in the *lib\\* subdirectory used for implementation assemblies.</span></span>

## <a name="reference-assemblies-structure"></a><span data-ttu-id="ab0c9-154">參考元件結構</span><span class="sxs-lookup"><span data-stu-id="ab0c9-154">Reference assemblies structure</span></span>

<span data-ttu-id="ab0c9-155">參考元件是相關概念的擴充，也就是 *僅中繼資料的元件*。</span><span class="sxs-lookup"><span data-stu-id="ab0c9-155">Reference assemblies are an expansion of the related concept, *metadata-only assemblies*.</span></span> <span data-ttu-id="ab0c9-156">僅中繼資料組件以單一的 `throw null` 主體取代其方法主體，但包含匿名型別以外的所有成員。</span><span class="sxs-lookup"><span data-stu-id="ab0c9-156">Metadata-only assemblies have their method bodies replaced with a single `throw null` body, but include all members except anonymous types.</span></span> <span data-ttu-id="ab0c9-157">使用 `throw null` 主體 (而不是) 主體的原因，是為了讓 **PEVerify** 可以執行並通過 (，進而驗證中繼資料) 的完整性。</span><span class="sxs-lookup"><span data-stu-id="ab0c9-157">The reason for using `throw null` bodies (as opposed to no bodies) is so that **PEVerify** can run and pass (thus validating the completeness of the metadata).</span></span>

<span data-ttu-id="ab0c9-158">參考組件會進一步移除來自僅中繼資料組件的中繼資料 (私用成員)：</span><span class="sxs-lookup"><span data-stu-id="ab0c9-158">Reference assemblies further remove metadata (private members) from metadata-only assemblies:</span></span>

- <span data-ttu-id="ab0c9-159">參考組件只有在 API 介面中所需項目的參考。</span><span class="sxs-lookup"><span data-stu-id="ab0c9-159">A reference assembly only has references for what it needs in the API surface.</span></span> <span data-ttu-id="ab0c9-160">實際的組件可能有與特定實作相關的其他參考。</span><span class="sxs-lookup"><span data-stu-id="ab0c9-160">The real assembly may have additional references related to specific implementations.</span></span> <span data-ttu-id="ab0c9-161">例如，的參考元件 `class C { private void M() { dynamic d = 1; ... } }` 不會參考所需的任何類型 `dynamic` 。</span><span class="sxs-lookup"><span data-stu-id="ab0c9-161">For instance, the reference assembly for `class C { private void M() { dynamic d = 1; ... } }` doesn't reference any types required for `dynamic`.</span></span>
- <span data-ttu-id="ab0c9-162">如果移除它們不會明顯影響編譯的話，則會移除私用函式的成員 (方法、屬性和事件)。</span><span class="sxs-lookup"><span data-stu-id="ab0c9-162">Private function-members (methods, properties, and events) are removed in cases where their removal doesn't observably impact compilation.</span></span> <span data-ttu-id="ab0c9-163">如果沒有 [InternalsVisibleTo](xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute) 屬性，則也會移除內建函式成員。</span><span class="sxs-lookup"><span data-stu-id="ab0c9-163">If there are no [InternalsVisibleTo](xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute) attributes, internal function members are also removed.</span></span>

<span data-ttu-id="ab0c9-164">參考元件中的中繼資料會繼續保留下列資訊：</span><span class="sxs-lookup"><span data-stu-id="ab0c9-164">The metadata in reference assemblies continues to keep the following information:</span></span>

- <span data-ttu-id="ab0c9-165">所有類型，包括私用和巢狀型別。</span><span class="sxs-lookup"><span data-stu-id="ab0c9-165">All types, including private and nested types.</span></span>
- <span data-ttu-id="ab0c9-166">所有屬性，甚至是內部屬性。</span><span class="sxs-lookup"><span data-stu-id="ab0c9-166">All attributes, even internal ones.</span></span>
- <span data-ttu-id="ab0c9-167">所有虛擬方法。</span><span class="sxs-lookup"><span data-stu-id="ab0c9-167">All virtual methods.</span></span>
- <span data-ttu-id="ab0c9-168">明確的介面實現。</span><span class="sxs-lookup"><span data-stu-id="ab0c9-168">Explicit interface implementations.</span></span>
- <span data-ttu-id="ab0c9-169">明確實作為屬性和事件，因為其存取子是虛擬的。</span><span class="sxs-lookup"><span data-stu-id="ab0c9-169">Explicitly implemented properties and events, because their accessors are virtual.</span></span>
- <span data-ttu-id="ab0c9-170">結構的所有欄位。</span><span class="sxs-lookup"><span data-stu-id="ab0c9-170">All fields of structures.</span></span>

<span data-ttu-id="ab0c9-171">參考元件包含元件層級的 [ReferenceAssembly](xref:System.Runtime.CompilerServices.ReferenceAssemblyAttribute) 屬性。</span><span class="sxs-lookup"><span data-stu-id="ab0c9-171">Reference assemblies include an assembly-level [ReferenceAssembly](xref:System.Runtime.CompilerServices.ReferenceAssemblyAttribute) attribute.</span></span> <span data-ttu-id="ab0c9-172">這個屬性可以在來源中指定;然後編譯器不需要合成它。</span><span class="sxs-lookup"><span data-stu-id="ab0c9-172">This attribute may be specified in source; then the compiler won't need to synthesize it.</span></span> <span data-ttu-id="ab0c9-173">由於這個屬性的原因，執行時間會拒絕載入參考元件以執行 (但可以在僅限反映模式中載入) 。</span><span class="sxs-lookup"><span data-stu-id="ab0c9-173">Because of this attribute, runtimes will refuse to load reference assemblies for execution (but they can be loaded in reflection-only mode).</span></span>

<span data-ttu-id="ab0c9-174">確切的參考元件結構詳細資料取決於編譯器版本。</span><span class="sxs-lookup"><span data-stu-id="ab0c9-174">Exact reference assembly structure details depend on the compiler version.</span></span> <span data-ttu-id="ab0c9-175">如果較新的版本被判定為不影響公用 API 介面，則可選擇排除更多中繼資料。</span><span class="sxs-lookup"><span data-stu-id="ab0c9-175">Newer versions may choose to exclude more metadata if it's determined as not affecting the public API surface.</span></span>

> [!NOTE]
> <span data-ttu-id="ab0c9-176">本節中的資訊僅適用于從 c # 7.1 版或 Visual Basic 版本15.3 開始的 Roslyn 編譯器所產生的參考元件。</span><span class="sxs-lookup"><span data-stu-id="ab0c9-176">Information in this section is applicable only to reference assemblies generated by Roslyn compilers starting from C# version 7.1 or Visual Basic version 15.3.</span></span> <span data-ttu-id="ab0c9-177">.NET Framework 和 .NET Core 程式庫之參考元件的結構可能會因某些細節而異，因為它們會使用自己產生參考元件的機制。</span><span class="sxs-lookup"><span data-stu-id="ab0c9-177">The structure of reference assemblies for .NET Framework and .NET Core libraries can differ in some details, because they use their own mechanism of generating reference assemblies.</span></span> <span data-ttu-id="ab0c9-178">例如，它們可能會有完全空白的方法主體，而不是 `throw null` 主體。</span><span class="sxs-lookup"><span data-stu-id="ab0c9-178">For example, they might have totally empty method bodies instead of the `throw null` body.</span></span> <span data-ttu-id="ab0c9-179">但一般原則仍然適用：它們沒有可使用的方法執行，而且只包含對公用 API 觀點有明顯影響的成員的中繼資料。</span><span class="sxs-lookup"><span data-stu-id="ab0c9-179">But the general principle still applies: they don't have usable method implementations and contain metadata only for members that have an observable impact from a public API perspective.</span></span>

## <a name="see-also"></a><span data-ttu-id="ab0c9-180">請參閱</span><span class="sxs-lookup"><span data-stu-id="ab0c9-180">See also</span></span>

- [<span data-ttu-id="ab0c9-181">.NET 中的組件</span><span class="sxs-lookup"><span data-stu-id="ab0c9-181">Assemblies in .NET</span></span>](index.md)
- [<span data-ttu-id="ab0c9-182">Framework 目標概觀</span><span class="sxs-lookup"><span data-stu-id="ab0c9-182">Framework targeting overview</span></span>](/visualstudio/ide/visual-studio-multi-targeting-overview)
- [<span data-ttu-id="ab0c9-183">如何：使用參考管理員新增或移除參考</span><span class="sxs-lookup"><span data-stu-id="ab0c9-183">How to: Add or remove references by using the Reference Manager</span></span>](/visualstudio/ide/how-to-add-or-remove-references-by-using-the-reference-manager)
