---
title: 參考組件
description: 瞭解參考元件，這是 .NET 中只包含程式庫公用 API 介面的特殊元件類型
author: MSDN-WhiteKnight
ms.date: 09/12/2019
ms.technology: dotnet-standard
ms.openlocfilehash: 43a9dab037f4d0f1926ff67f8f38eaa6734a6d67
ms.sourcegitcommit: 87cfeb69226fef01acb17c56c86f978f4f4a13db
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 07/24/2020
ms.locfileid: "87164527"
---
# <a name="reference-assemblies"></a><span data-ttu-id="8b672-103">參考組件</span><span class="sxs-lookup"><span data-stu-id="8b672-103">Reference assemblies</span></span>

<span data-ttu-id="8b672-104">*參考元件*是一種特殊類型的元件，其中只包含代表程式庫公用 API 介面所需的最小中繼資料量。</span><span class="sxs-lookup"><span data-stu-id="8b672-104">*Reference assemblies* are a special type of assembly that contain only the minimum amount of metadata required to represent the library's public API surface.</span></span> <span data-ttu-id="8b672-105">其中包括在建立工具中參考元件時，所有重要成員的宣告，但會排除所有成員的執行，以及對其 API 合約沒有明顯影響的私用成員宣告。</span><span class="sxs-lookup"><span data-stu-id="8b672-105">They include declarations for all members that are significant when referencing an assembly in build tools, but exclude all member implementations and declarations of private members that have no observable impact on their API contract.</span></span> <span data-ttu-id="8b672-106">相反地，一般元件稱為「*實做元件*」。</span><span class="sxs-lookup"><span data-stu-id="8b672-106">In contrast, regular assemblies are called *implementation assemblies*.</span></span>

<span data-ttu-id="8b672-107">無法載入參考元件來執行，但是可以用相同的方式將它們當做編譯器輸入來傳遞。</span><span class="sxs-lookup"><span data-stu-id="8b672-107">Reference assemblies can't be loaded for execution, but they can be passed as compiler input in the same way as implementation assemblies.</span></span> <span data-ttu-id="8b672-108">參考元件通常會與特定平臺或程式庫的軟體發展工具組（SDK）一起散發。</span><span class="sxs-lookup"><span data-stu-id="8b672-108">Reference assemblies are usually distributed with the Software Development Kit (SDK) of a particular platform or library.</span></span>

<span data-ttu-id="8b672-109">使用參考元件可讓開發人員建立以特定程式庫版本為目標的程式，而不需要該版本的完整執行元件。</span><span class="sxs-lookup"><span data-stu-id="8b672-109">Using a reference assembly enables developers to build programs that target a specific library version without having the full implementation assembly for that version.</span></span> <span data-ttu-id="8b672-110">假設您的電腦上只有部分程式庫的最新版本，但您想要建立以該程式庫較舊版本為目標的程式。</span><span class="sxs-lookup"><span data-stu-id="8b672-110">Suppose, you have only the latest version of some library on your machine, but you want to build a program that targets an earlier version of that library.</span></span> <span data-ttu-id="8b672-111">如果您直接針對執行元件進行編譯，可能會不小心使用舊版中未提供的 API 成員。</span><span class="sxs-lookup"><span data-stu-id="8b672-111">If you compile directly against the implementation assembly, you might inadvertently use API members that aren't available in the earlier version.</span></span> <span data-ttu-id="8b672-112">在目的電腦上測試程式時，您只會發現這個錯誤。</span><span class="sxs-lookup"><span data-stu-id="8b672-112">You'll only find this mistake when testing the program on the target machine.</span></span> <span data-ttu-id="8b672-113">如果您針對較早版本的參考元件進行編譯，則會立即收到編譯時期錯誤。</span><span class="sxs-lookup"><span data-stu-id="8b672-113">If you compile against the reference assembly for the earlier version, you'll immediately get a compile-time error.</span></span>

<span data-ttu-id="8b672-114">參考元件也可以代表合約，也就是不會對應到具體執行元件的一組 Api。</span><span class="sxs-lookup"><span data-stu-id="8b672-114">A reference assembly can also represent a contract, that is, a set of APIs that don't correspond to the concrete implementation assembly.</span></span> <span data-ttu-id="8b672-115">這類參考元件（稱為*合約元件*）可用來以支援同一組 api 的多個平臺為目標。</span><span class="sxs-lookup"><span data-stu-id="8b672-115">Such reference assemblies, called the *contract assembly*, can be used to target multiple platforms that support the same set of APIs.</span></span> <span data-ttu-id="8b672-116">例如，.NET Standard 提供合約元件， *netstandard.dll*，代表不同 .net 平臺之間共用的一組通用 api。</span><span class="sxs-lookup"><span data-stu-id="8b672-116">For example, .NET Standard provides the contract assembly, *netstandard.dll*, that represents the set of common APIs shared between different .NET platforms.</span></span> <span data-ttu-id="8b672-117">這些 Api 的執行包含在不同平臺上的不同元件中，例如在 .NET Core 上 .NET Framework 或*System.Private.CoreLib.dll*上*mscorlib.dll* 。</span><span class="sxs-lookup"><span data-stu-id="8b672-117">The implementations of these APIs are contained in different assemblies on different platforms, such as *mscorlib.dll* on .NET Framework or *System.Private.CoreLib.dll* on .NET Core.</span></span> <span data-ttu-id="8b672-118">以 .NET Standard 為目標的程式庫可以在支援 .NET Standard 的所有平臺上執行。</span><span class="sxs-lookup"><span data-stu-id="8b672-118">A library that targets .NET Standard can run on all platforms that support .NET Standard.</span></span>

## <a name="using-reference-assemblies"></a><span data-ttu-id="8b672-119">使用參考元件</span><span class="sxs-lookup"><span data-stu-id="8b672-119">Using reference assemblies</span></span>

<span data-ttu-id="8b672-120">若要使用專案中的特定 Api，您必須加入其元件的參考。</span><span class="sxs-lookup"><span data-stu-id="8b672-120">To use certain APIs from your project, you must add references to their assemblies.</span></span> <span data-ttu-id="8b672-121">您可以將參考加入至其中一個執行元件或參考元件。</span><span class="sxs-lookup"><span data-stu-id="8b672-121">You can add references to either implementation assemblies or to reference assemblies.</span></span> <span data-ttu-id="8b672-122">我們建議您在每次有參考元件時使用它們。</span><span class="sxs-lookup"><span data-stu-id="8b672-122">It's recommended you use reference assemblies whenever they're available.</span></span> <span data-ttu-id="8b672-123">這麼做可確保您只會使用目標版本中支援的 API 成員，以供 API 設計人員使用。</span><span class="sxs-lookup"><span data-stu-id="8b672-123">Doing so ensures that you're using only the supported API members in the target version, meant to be used by API designers.</span></span> <span data-ttu-id="8b672-124">使用參考元件可確保您不會依賴執行的詳細資料。</span><span class="sxs-lookup"><span data-stu-id="8b672-124">Using the reference assembly ensures you're not taking a dependency on implementation details.</span></span>

<span data-ttu-id="8b672-125">.NET Framework 程式庫的參考元件會與目標套件一起散發。</span><span class="sxs-lookup"><span data-stu-id="8b672-125">Reference assemblies for the .NET Framework libraries are distributed with targeting packs.</span></span> <span data-ttu-id="8b672-126">您可以藉由下載獨立安裝程式或在 Visual Studio 安裝程式中選取元件來取得它們。</span><span class="sxs-lookup"><span data-stu-id="8b672-126">You can obtain them by downloading a standalone installer or by selecting a component in Visual Studio installer.</span></span> <span data-ttu-id="8b672-127">如需詳細資訊，請參閱[安裝適用于開發人員的 .NET Framework](../../framework/install/guide-for-developers.md)。</span><span class="sxs-lookup"><span data-stu-id="8b672-127">For more information, see [Install the .NET Framework for developers](../../framework/install/guide-for-developers.md).</span></span> <span data-ttu-id="8b672-128">針對 .NET Core 和 .NET Standard，參考元件會視需要自動下載（透過 NuGet）並加以參考。</span><span class="sxs-lookup"><span data-stu-id="8b672-128">For .NET Core and .NET Standard, reference assemblies are automatically downloaded as necessary (via NuGet) and referenced.</span></span> <span data-ttu-id="8b672-129">針對 .NET Core 3.0 和更新版本，核心架構的參考元件位於[NETCore](https://www.nuget.org/packages/Microsoft.NETCore.App.Ref)中，而不是使用[NETCore 應用程式](https://www.nuget.org/packages/Microsoft.NETCore.App)套件（3.0 之前的版本）。</span><span class="sxs-lookup"><span data-stu-id="8b672-129">For .NET Core 3.0 and higher, the reference assemblies for the core framework are in the [Microsoft.NETCore.App.Ref](https://www.nuget.org/packages/Microsoft.NETCore.App.Ref) package (the [Microsoft.NETCore.App](https://www.nuget.org/packages/Microsoft.NETCore.App) package is used instead for versions before 3.0).</span></span>

<span data-ttu-id="8b672-130">當您使用 [**加入參考**] 對話方塊在 Visual Studio 中加入 .NET Framework 元件的參考時，會從清單中選取元件，而且 Visual Studio 會自動尋找對應至專案中所選目標 Framework 版本的參考元件。</span><span class="sxs-lookup"><span data-stu-id="8b672-130">When you add references to .NET Framework assemblies in Visual Studio using the **Add reference** dialog, you select an assembly from the list, and Visual Studio automatically finds reference assemblies that correspond to the target framework version selected in your project.</span></span> <span data-ttu-id="8b672-131">這同樣適用于使用[參考](/visualstudio/msbuild/common-msbuild-project-items#reference)專案專案，直接在 MSBuild 專案中加入參考：您只需要指定元件名稱，而不是完整的檔案路徑。</span><span class="sxs-lookup"><span data-stu-id="8b672-131">The same applies to adding references directly into MSBuild project using the  [Reference](/visualstudio/msbuild/common-msbuild-project-items#reference) project item: you only need to specify the assembly name, not the full file path.</span></span> <span data-ttu-id="8b672-132">當您使用 `-reference` 編譯器選項（[c # 中](../../csharp/language-reference/compiler-options/reference-compiler-option.md)的和[Visual Basic](../../visual-basic/reference/command-line-compiler/reference.md)中的），或使用 Roslyn API 中的方法，在命令列中加入這些元件的參考時 <xref:Microsoft.CodeAnalysis.Compilation.AddReferences%2A?displayProperty=nameWithType> ，您必須手動指定正確目標平臺版本的參考元件檔案。</span><span class="sxs-lookup"><span data-stu-id="8b672-132">When you add references to these assemblies in the command line by using the `-reference` compiler option ([in C#](../../csharp/language-reference/compiler-options/reference-compiler-option.md) and in [Visual Basic](../../visual-basic/reference/command-line-compiler/reference.md)) or by using the <xref:Microsoft.CodeAnalysis.Compilation.AddReferences%2A?displayProperty=nameWithType> method in the Roslyn API, you must manually specify reference assembly files for the correct target platform version.</span></span> <span data-ttu-id="8b672-133">.NET Framework 參考元件檔案位於 *% ProgramFiles （x86）% \\ reference assembly \\ Microsoft \\ Framework \\ 。.Netframework*目錄。</span><span class="sxs-lookup"><span data-stu-id="8b672-133">.NET Framework reference assembly files are located in the *%ProgramFiles(x86)%\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework* directory.</span></span> <span data-ttu-id="8b672-134">針對 .NET Core，您可以藉由將專案屬性設定為，強制發行作業將目標平臺的參考元件複製到輸出目錄的*publish/refs*子目錄中 `PreserveCompilationContext` `true` 。</span><span class="sxs-lookup"><span data-stu-id="8b672-134">For .NET Core, you can force publish operation to copy reference assemblies for your target platform into the *publish/refs* subdirectory of your output directory by setting the `PreserveCompilationContext` project property to `true`.</span></span> <span data-ttu-id="8b672-135">然後您可以將這些參考元件檔案傳遞給編譯器。</span><span class="sxs-lookup"><span data-stu-id="8b672-135">Then you can pass these reference assembly files to the compiler.</span></span> <span data-ttu-id="8b672-136">使用 `DependencyContext` [DependencyModel](https://www.nuget.org/packages/Microsoft.Extensions.DependencyModel/)封裝有助於找出其路徑。</span><span class="sxs-lookup"><span data-stu-id="8b672-136">Using `DependencyContext` from [Microsoft.Extensions.DependencyModel](https://www.nuget.org/packages/Microsoft.Extensions.DependencyModel/) package can help locate their paths.</span></span>

<span data-ttu-id="8b672-137">因為它們不包含任何實作為，所以無法載入參考元件來執行。</span><span class="sxs-lookup"><span data-stu-id="8b672-137">Because they contain no implementation, reference assemblies can't be loaded for execution.</span></span> <span data-ttu-id="8b672-138">嘗試這麼做會導致 <xref:System.BadImageFormatException?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="8b672-138">Trying to do so results in a <xref:System.BadImageFormatException?displayProperty=nameWithType>.</span></span> <span data-ttu-id="8b672-139">如果您想要檢查參考元件的內容，您可以在 .NET Framework （使用 <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType> 方法）或 .Net Core 的中，將它載入至僅限反映的內容中 <xref:System.Reflection.MetadataLoadContext> 。</span><span class="sxs-lookup"><span data-stu-id="8b672-139">If you want to examine the contents of a reference assembly, you can load it into the reflection-only context in .NET Framework (using the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType> method) or into the <xref:System.Reflection.MetadataLoadContext> in .NET Core.</span></span>

## <a name="generating-reference-assemblies"></a><span data-ttu-id="8b672-140">產生參考元件</span><span class="sxs-lookup"><span data-stu-id="8b672-140">Generating reference assemblies</span></span>

<span data-ttu-id="8b672-141">當您的程式庫取用者需要針對許多不同版本的程式庫建立其程式時，為您的程式庫產生參考元件會很有用。</span><span class="sxs-lookup"><span data-stu-id="8b672-141">Generating reference assemblies for your libraries can be useful when your library consumers need to build their programs against many different versions of the library.</span></span> <span data-ttu-id="8b672-142">散發所有這些版本的實做元件，可能會因為大小龐大而不實際。</span><span class="sxs-lookup"><span data-stu-id="8b672-142">Distributing implementation assemblies for all these versions might be impractical because of their large size.</span></span> <span data-ttu-id="8b672-143">參考元件的大小較小，並將它們散發為程式庫 SDK 的一部分，可減少下載大小並節省磁碟空間。</span><span class="sxs-lookup"><span data-stu-id="8b672-143">Reference assemblies are smaller in size, and distributing them as a part of your library's SDK reduces download size and saves disk space.</span></span>

<span data-ttu-id="8b672-144">Ide 和 build 工具也可以利用參考元件，在包含多個類別庫的大型解決方案時，減少組建時間。</span><span class="sxs-lookup"><span data-stu-id="8b672-144">IDEs and build tools also can take advantage of reference assemblies to reduce build times in case of large solutions consisting of multiple class libraries.</span></span> <span data-ttu-id="8b672-145">通常，在累加組建案例中，當任何輸入檔變更時，會重建專案，包括它所相依的元件。</span><span class="sxs-lookup"><span data-stu-id="8b672-145">Usually, in incremental build scenarios a project is rebuilt when any of its input files are changed, including the assemblies it depends on.</span></span> <span data-ttu-id="8b672-146">每當程式設計人員變更任何成員的執行時，就會變更執行元件。</span><span class="sxs-lookup"><span data-stu-id="8b672-146">The implementation assembly changes whenever the programmer changes the implementation of any member.</span></span> <span data-ttu-id="8b672-147">參考元件只會在其公用 API 受到影響時變更。</span><span class="sxs-lookup"><span data-stu-id="8b672-147">The reference assembly only changes when its public API is affected.</span></span> <span data-ttu-id="8b672-148">因此，在某些情況下，使用參考元件做為輸入檔，而不是執行元件，可以略過相依專案的組建。</span><span class="sxs-lookup"><span data-stu-id="8b672-148">So, using the reference assembly as an input file instead of the implementation assembly allows skipping the build of the dependent project in some cases.</span></span>

<span data-ttu-id="8b672-149">您可以產生參考元件：</span><span class="sxs-lookup"><span data-stu-id="8b672-149">You can generate reference assemblies:</span></span>

- <span data-ttu-id="8b672-150">在 MSBuild 專案中，使用[ `ProduceReferenceAssembly` 專案屬性](/visualstudio/msbuild/common-msbuild-project-properties)。</span><span class="sxs-lookup"><span data-stu-id="8b672-150">In an MSBuild project, by using the [`ProduceReferenceAssembly` project property](/visualstudio/msbuild/common-msbuild-project-properties).</span></span>
- <span data-ttu-id="8b672-151">從命令列編譯器時，請依指定 `-refonly` （[c #](../../csharp/language-reference/compiler-options/refonly-compiler-option.md)  /  [Visual Basic](../../visual-basic/reference/command-line-compiler/refonly-compiler-option.md) ）或 `-refout` （[c #](../../csharp/language-reference/compiler-options/refout-compiler-option.md)  /  [Visual Basic](../../visual-basic/reference/command-line-compiler/refout-compiler-option.md)）編譯器選項。</span><span class="sxs-lookup"><span data-stu-id="8b672-151">When compiling program from command line, by specifiying `-refonly` ([C#](../../csharp/language-reference/compiler-options/refonly-compiler-option.md) / [Visual Basic](../../visual-basic/reference/command-line-compiler/refonly-compiler-option.md) ) or `-refout` ([C#](../../csharp/language-reference/compiler-options/refout-compiler-option.md) / [Visual Basic](../../visual-basic/reference/command-line-compiler/refout-compiler-option.md)) compiler options.</span></span>
- <span data-ttu-id="8b672-152">使用 Roslyn API 時，會 <xref:Microsoft.CodeAnalysis.Emit.EmitOptions.EmitMetadataOnly?displayProperty=nameWithType> `true` <xref:Microsoft.CodeAnalysis.Emit.EmitOptions.IncludePrivateMembers?displayProperty=nameWithType> `false` 在傳遞至方法的物件中，將設定為和 <xref:Microsoft.CodeAnalysis.Compilation.Emit%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="8b672-152">When using the Roslyn API, by setting <xref:Microsoft.CodeAnalysis.Emit.EmitOptions.EmitMetadataOnly?displayProperty=nameWithType> to `true` and <xref:Microsoft.CodeAnalysis.Emit.EmitOptions.IncludePrivateMembers?displayProperty=nameWithType> to `false` in an object passed to the <xref:Microsoft.CodeAnalysis.Compilation.Emit%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="8b672-153">如果您想要使用 NuGet 套件散發參考元件，您必須將它們包含在封裝目錄下的\*ref \\ *子目錄中，而不是在用於執行元件的*lib \\ \*子目錄中。</span><span class="sxs-lookup"><span data-stu-id="8b672-153">If you want to distribute reference assemblies with NuGet packages, you must include them in the *ref\\* subdirectory under the package directory instead of in the *lib\\* subdirectory used for implementation assemblies.</span></span>

## <a name="reference-assemblies-structure"></a><span data-ttu-id="8b672-154">參考元件結構</span><span class="sxs-lookup"><span data-stu-id="8b672-154">Reference assemblies structure</span></span>

<span data-ttu-id="8b672-155">參考元件是相關概念的擴充，*僅限中繼資料的元件*。</span><span class="sxs-lookup"><span data-stu-id="8b672-155">Reference assemblies are an expansion of the related concept, *metadata-only assemblies*.</span></span> <span data-ttu-id="8b672-156">僅中繼資料組件以單一的 `throw null` 主體取代其方法主體，但包含匿名型別以外的所有成員。</span><span class="sxs-lookup"><span data-stu-id="8b672-156">Metadata-only assemblies have their method bodies replaced with a single `throw null` body, but include all members except anonymous types.</span></span> <span data-ttu-id="8b672-157">使用 `throw null` 主體（而不是任何主體）的原因，是為了讓**PEVerify**能夠執行和傳遞（進而驗證中繼資料的完整性）。</span><span class="sxs-lookup"><span data-stu-id="8b672-157">The reason for using `throw null` bodies (as opposed to no bodies) is so that **PEVerify** can run and pass (thus validating the completeness of the metadata).</span></span>

<span data-ttu-id="8b672-158">參考組件會進一步移除來自僅中繼資料組件的中繼資料 (私用成員)：</span><span class="sxs-lookup"><span data-stu-id="8b672-158">Reference assemblies further remove metadata (private members) from metadata-only assemblies:</span></span>

- <span data-ttu-id="8b672-159">參考組件只有在 API 介面中所需項目的參考。</span><span class="sxs-lookup"><span data-stu-id="8b672-159">A reference assembly only has references for what it needs in the API surface.</span></span> <span data-ttu-id="8b672-160">實際的組件可能有與特定實作相關的其他參考。</span><span class="sxs-lookup"><span data-stu-id="8b672-160">The real assembly may have additional references related to specific implementations.</span></span> <span data-ttu-id="8b672-161">例如，的參考元件 `class C { private void M() { dynamic d = 1; ... } }` 不會參考所需的任何類型 `dynamic` 。</span><span class="sxs-lookup"><span data-stu-id="8b672-161">For instance, the reference assembly for `class C { private void M() { dynamic d = 1; ... } }` doesn't reference any types required for `dynamic`.</span></span>
- <span data-ttu-id="8b672-162">如果移除它們不會明顯影響編譯的話，則會移除私用函式的成員 (方法、屬性和事件)。</span><span class="sxs-lookup"><span data-stu-id="8b672-162">Private function-members (methods, properties, and events) are removed in cases where their removal doesn't observably impact compilation.</span></span> <span data-ttu-id="8b672-163">如果沒有[InternalsVisibleTo](xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute)屬性，內部函式成員也會一併移除。</span><span class="sxs-lookup"><span data-stu-id="8b672-163">If there are no [InternalsVisibleTo](xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute) attributes, internal function members are also removed.</span></span>

<span data-ttu-id="8b672-164">參考元件中的中繼資料會繼續保留下列資訊：</span><span class="sxs-lookup"><span data-stu-id="8b672-164">The metadata in reference assemblies continues to keep the following information:</span></span>

- <span data-ttu-id="8b672-165">所有類型，包括私用和巢狀型別。</span><span class="sxs-lookup"><span data-stu-id="8b672-165">All types, including private and nested types.</span></span>
- <span data-ttu-id="8b672-166">所有屬性，甚至是內部屬性。</span><span class="sxs-lookup"><span data-stu-id="8b672-166">All attributes, even internal ones.</span></span>
- <span data-ttu-id="8b672-167">所有的虛擬方法。</span><span class="sxs-lookup"><span data-stu-id="8b672-167">All virtual methods.</span></span>
- <span data-ttu-id="8b672-168">明確介面的實現。</span><span class="sxs-lookup"><span data-stu-id="8b672-168">Explicit interface implementations.</span></span>
- <span data-ttu-id="8b672-169">明確實作為屬性和事件，因為它們的存取子是虛擬的。</span><span class="sxs-lookup"><span data-stu-id="8b672-169">Explicitly implemented properties and events, because their accessors are virtual.</span></span>
- <span data-ttu-id="8b672-170">結構的所有欄位。</span><span class="sxs-lookup"><span data-stu-id="8b672-170">All fields of structures.</span></span>

<span data-ttu-id="8b672-171">參考元件包含元件層級的[ReferenceAssembly](xref:System.Runtime.CompilerServices.ReferenceAssemblyAttribute)屬性。</span><span class="sxs-lookup"><span data-stu-id="8b672-171">Reference assemblies include an assembly-level [ReferenceAssembly](xref:System.Runtime.CompilerServices.ReferenceAssemblyAttribute) attribute.</span></span> <span data-ttu-id="8b672-172">可以在來源中指定這個屬性。然後編譯器不需要合成它。</span><span class="sxs-lookup"><span data-stu-id="8b672-172">This attribute may be specified in source; then the compiler won't need to synthesize it.</span></span> <span data-ttu-id="8b672-173">由於這個屬性，執行時間會拒絕載入參考元件以執行（但可以在僅限反映模式中載入）。</span><span class="sxs-lookup"><span data-stu-id="8b672-173">Because of this attribute, runtimes will refuse to load reference assemblies for execution (but they can be loaded in reflection-only mode).</span></span>

<span data-ttu-id="8b672-174">確切的參考元件結構詳細資料取決於編譯器版本。</span><span class="sxs-lookup"><span data-stu-id="8b672-174">Exact reference assembly structure details depend on the compiler version.</span></span> <span data-ttu-id="8b672-175">如果判斷為不會影響公用 API 介面，較新版本可能會選擇排除更多的中繼資料。</span><span class="sxs-lookup"><span data-stu-id="8b672-175">Newer versions may choose to exclude more metadata if it's determined as not affecting the public API surface.</span></span>

> [!NOTE]
> <span data-ttu-id="8b672-176">本節中的資訊僅適用于從 c # 版本7.1 或 Visual Basic 版本15.3 開始的 Roslyn 編譯器所產生的參考元件。</span><span class="sxs-lookup"><span data-stu-id="8b672-176">Information in this section is applicable only to reference assemblies generated by Roslyn compilers starting from C# version 7.1 or Visual Basic version 15.3.</span></span> <span data-ttu-id="8b672-177">.NET Framework 和 .NET Core 程式庫的參考元件結構在某些詳細資料中可能會有不同，因為它們會使用自己產生參考元件的機制。</span><span class="sxs-lookup"><span data-stu-id="8b672-177">The structure of reference assemblies for .NET Framework and .NET Core libraries can differ in some details, because they use their own mechanism of generating reference assemblies.</span></span> <span data-ttu-id="8b672-178">例如，它們可能會有完全空白的方法主體，而不是 `throw null` 主體。</span><span class="sxs-lookup"><span data-stu-id="8b672-178">For example, they might have totally empty method bodies instead of the `throw null` body.</span></span> <span data-ttu-id="8b672-179">但是一般原則仍然適用：它們沒有可使用的方法，而且只包含對公用 API 觀點有明顯影響的成員的中繼資料。</span><span class="sxs-lookup"><span data-stu-id="8b672-179">But the general principle still applies: they don't have usable method implementations and contain metadata only for members that have an observable impact from a public API perspective.</span></span>

## <a name="see-also"></a><span data-ttu-id="8b672-180">另請參閱</span><span class="sxs-lookup"><span data-stu-id="8b672-180">See also</span></span>

- [<span data-ttu-id="8b672-181">.NET 中的組件</span><span class="sxs-lookup"><span data-stu-id="8b672-181">Assemblies in .NET</span></span>](index.md)
- [<span data-ttu-id="8b672-182">Framework 目標概觀</span><span class="sxs-lookup"><span data-stu-id="8b672-182">Framework targeting overview</span></span>](/visualstudio/ide/visual-studio-multi-targeting-overview)
- [<span data-ttu-id="8b672-183">如何：使用參考管理員加入或移除參考</span><span class="sxs-lookup"><span data-stu-id="8b672-183">How to: Add or remove references by using the Reference Manager</span></span>](/visualstudio/ide/how-to-add-or-remove-references-by-using-the-reference-manager)
