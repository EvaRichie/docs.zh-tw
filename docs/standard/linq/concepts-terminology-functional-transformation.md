---
title: 概念和術語 (功能性轉換) -LINQ to XML
description: 瞭解純功能性轉換的概念與術語。
ms.date: 07/20/2015
ms.assetid: 03defb3a-7e17-4ab1-8efa-4dd66621e860
ms.openlocfilehash: 0ecdbdf88ee9f868143f466222fa06f0ccf641d8
ms.sourcegitcommit: 27a15a55019f6b5f2733961738babe94aec0def3
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 09/15/2020
ms.locfileid: "90558108"
---
# <a name="concepts-and-terminology-functional-transformation-linq-to-xml"></a><span data-ttu-id="b6408-103">概念和術語 (功能性轉換)  (LINQ to XML) </span><span class="sxs-lookup"><span data-stu-id="b6408-103">Concepts and terminology (functional transformation) (LINQ to XML)</span></span>

<span data-ttu-id="b6408-104">本文介紹純功能性轉換的概念和術語。</span><span class="sxs-lookup"><span data-stu-id="b6408-104">This article introduces the concepts and terminology of pure functional transformations.</span></span> <span data-ttu-id="b6408-105">轉換資料的功能性轉換方法會產生程式碼，通常比更傳統的命令式程式設計更快、更具表達性，而且更容易進行偵測和維護。</span><span class="sxs-lookup"><span data-stu-id="b6408-105">The functional transformation approach to transforming data yields code that's often quicker to program, more expressive, and easier to debug and maintain than more traditional, imperative programming.</span></span>

<span data-ttu-id="b6408-106">請注意，本節中的文章並不是要完整解說功能性程式設計。</span><span class="sxs-lookup"><span data-stu-id="b6408-106">Note that the articles in this section aren't intended to fully explain functional programming.</span></span> <span data-ttu-id="b6408-107">相反地，這些文章會識別一些功能性程式設計功能，讓您更輕鬆地將 XML 轉換成另一個圖形。</span><span class="sxs-lookup"><span data-stu-id="b6408-107">Instead, these articles identify some of the functional programming capabilities that make it easier to transform XML from one shape to another.</span></span>

## <a name="what-is-pure-functional-transformation"></a><span data-ttu-id="b6408-108">什麼是純功能性轉換</span><span class="sxs-lookup"><span data-stu-id="b6408-108">What is pure functional transformation</span></span>

<span data-ttu-id="b6408-109">在「純功能性轉換」\*\* 中，一組稱為「純虛擬函式」\*\* 的函式會定義如何將一組結構化的資料從其原始格式轉換為另一個格式。</span><span class="sxs-lookup"><span data-stu-id="b6408-109">In *pure functional transformation*, a set of functions, called *pure functions*, define how to transform a set of structured data from its original form into another form.</span></span> <span data-ttu-id="b6408-110">"Pure" 這個字表示函式是可 *組合*的，這需要它們是：</span><span class="sxs-lookup"><span data-stu-id="b6408-110">The word "pure" indicates that the functions are *composable*, which requires that they're:</span></span>

- <span data-ttu-id="b6408-111">「獨立的」\*\*，讓這些函式可以自由排列與重新整理，而不會與程式的其餘部分有任何牽連或互相依賴。</span><span class="sxs-lookup"><span data-stu-id="b6408-111">*Self-contained*, so that they can be freely ordered and rearranged without entanglement or interdependencies with the rest of the program.</span></span> <span data-ttu-id="b6408-112">純轉換與其環境無關，也不會影響其環境。</span><span class="sxs-lookup"><span data-stu-id="b6408-112">Pure transformations have no knowledge of or effect upon their environment.</span></span> <span data-ttu-id="b6408-113">也就是說，用於轉換的函式沒有「副作用」\*\*。</span><span class="sxs-lookup"><span data-stu-id="b6408-113">That is, the functions used in the transformation have no *side effects*.</span></span>
- <span data-ttu-id="b6408-114">「無狀態」\*\*，如此一來，在相同的輸入上執行相同的函式或特定一組函式時，永遠會導致相同的輸出。</span><span class="sxs-lookup"><span data-stu-id="b6408-114">*Stateless*, so that executing the same function or specific set of functions on the same input will always result in the same output.</span></span> <span data-ttu-id="b6408-115">純轉換絲毫不會記得其先前的用途。</span><span class="sxs-lookup"><span data-stu-id="b6408-115">Pure transformations have no memory of their prior use.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="b6408-116">在本教學課程的其餘部分，「純虛擬函式」這個名詞用於一般含意，表示程式設計方法而非特定的語言功能。</span><span class="sxs-lookup"><span data-stu-id="b6408-116">In the rest of this tutorial, the term "pure function" is used in a general sense to indicate a programming approach, and not a specific language feature.</span></span>
>
> <span data-ttu-id="b6408-117">請注意，純虛擬函式必須實作為 c # 中的方法，以及做為 Visual Basic 中的函式。</span><span class="sxs-lookup"><span data-stu-id="b6408-117">Note that pure functions must be implemented as methods in C#, and as functions in Visual Basic.</span></span>
>
> <span data-ttu-id="b6408-118">您不應該將純虛擬函式與 c + + 中的純虛擬方法混淆。</span><span class="sxs-lookup"><span data-stu-id="b6408-118">You shouldn't confuse pure functions with pure virtual methods in C++.</span></span> <span data-ttu-id="b6408-119">後者表示包含的類別是抽象的，而且不會提供任何方法主體。</span><span class="sxs-lookup"><span data-stu-id="b6408-119">The latter indicates that the containing class is abstract and that no method body is supplied.</span></span>

### <a name="functional-programming"></a><span data-ttu-id="b6408-120">函式程式設計</span><span class="sxs-lookup"><span data-stu-id="b6408-120">Functional programming</span></span>

<span data-ttu-id="b6408-121">「函式程式設計」\*\* 是一種程式設計方法，可直接支援純功能性轉換。</span><span class="sxs-lookup"><span data-stu-id="b6408-121">*Functional programming* is a programming approach that directly supports pure functional transformation.</span></span>

<span data-ttu-id="b6408-122">根據過去的經驗，一般用途的函式程式設計語言 (例如，ML、Scheme、Haskell 與 F#) 主要受到學術團體的注意。</span><span class="sxs-lookup"><span data-stu-id="b6408-122">Historically, general-purpose functional programming languages, such as ML, Scheme, Haskell, and F#, have been primarily of interest to the academic community.</span></span> <span data-ttu-id="b6408-123">雖然功能性程式設計一直可以在 C# 和 Visual Basic 中撰寫純功能性轉換，但是其困難度始終讓大部分的程式設計人員卻步。</span><span class="sxs-lookup"><span data-stu-id="b6408-123">Although it has always been possible to write pure functional transformations in C# and Visual Basic, the difficulty of doing so has not made it an attractive option to most programmers.</span></span> <span data-ttu-id="b6408-124">不過，在這些語言的最新版本中，新的語言結構（例如 lambda 運算式和型別推斷）讓功能性程式設計更簡單且更具生產力。</span><span class="sxs-lookup"><span data-stu-id="b6408-124">In recent versions of these languages, however, new language constructs such as lambda expressions and type inference make functional programming much easier and more productive.</span></span>

<span data-ttu-id="b6408-125">如需功能性程式設計的詳細資訊，請參閱功能性程式設計 [與命令式程式設計](functional-vs-imperative-programming.md)的比較。</span><span class="sxs-lookup"><span data-stu-id="b6408-125">For more information about functional programming, see [Functional programming vs. imperative programming](functional-vs-imperative-programming.md).</span></span>

#### <a name="domain-specific-functional-programming-languages"></a><span data-ttu-id="b6408-126">特定領域的功能性程式設計語言</span><span class="sxs-lookup"><span data-stu-id="b6408-126">Domain-specific functional programming languages</span></span>

<span data-ttu-id="b6408-127">雖然尚未廣泛採用一般功能性程式設計語言，但某些特定領域的功能性程式設計語言已有更好的成功。</span><span class="sxs-lookup"><span data-stu-id="b6408-127">Although general functional programming languages haven't been widely adopted, some domain-specific functional programming languages have had better success.</span></span> <span data-ttu-id="b6408-128">例如，階層式樣式表 (CSS) 用來判斷許多網頁的外觀和操作方式，而且 (XSLT) 樣式表單中的可延伸樣式表單語言轉換會廣泛用於 XML 資料操作中。</span><span class="sxs-lookup"><span data-stu-id="b6408-128">For example, Cascading Style Sheets (CSS) are used to determine the look and feel of many web pages, and Extensible Stylesheet Language Transformations (XSLT) style sheets are used extensively in XML data manipulation.</span></span> <span data-ttu-id="b6408-129">如需 XSLT 的詳細資訊，請參閱 [XSLT 轉換](../data/xml/xslt-transformations.md)。</span><span class="sxs-lookup"><span data-stu-id="b6408-129">For more information about XSLT, see [XSLT Transformations](../data/xml/xslt-transformations.md).</span></span>

## <a name="terminology"></a><span data-ttu-id="b6408-130">詞彙</span><span class="sxs-lookup"><span data-stu-id="b6408-130">Terminology</span></span>

<span data-ttu-id="b6408-131">下列清單定義一些與功能轉換相關的詞彙。</span><span class="sxs-lookup"><span data-stu-id="b6408-131">The following list defines some terms related to functional transformations.</span></span>

<span data-ttu-id="b6408-132">高順序 (第一級) 函式 </span><span class="sxs-lookup"><span data-stu-id="b6408-132">higher-order (first-class) function </span></span>\
<span data-ttu-id="b6408-133">可以視為程式設計物件的函式。</span><span class="sxs-lookup"><span data-stu-id="b6408-133">A function that can be treated as a programmatic object.</span></span> <span data-ttu-id="b6408-134">例如，高順序函式可以傳遞到其他函式，或從其他函式傳回。</span><span class="sxs-lookup"><span data-stu-id="b6408-134">For example, a higher-order function can be passed to or returned from other functions.</span></span> <span data-ttu-id="b6408-135">在 C# 和 Visual Basic 中，委派和 Lambda 運算式都是支援高順序函式的語言功能。</span><span class="sxs-lookup"><span data-stu-id="b6408-135">In C# and Visual Basic, delegates and lambda expressions are language features that support higher-order functions.</span></span> <span data-ttu-id="b6408-136">若要撰寫高順序函式，您可以宣告一或多個引數以取得委派，而且在呼叫高順序函式時，您通常可以使用 Lambda 運算式。</span><span class="sxs-lookup"><span data-stu-id="b6408-136">To write a higher-order function, you declare one or more arguments to take delegates, and you often use lambda expressions when calling it.</span></span> <span data-ttu-id="b6408-137">許多標準查詢運算子都是高順序函式。</span><span class="sxs-lookup"><span data-stu-id="b6408-137">Many of the standard query operators are higher-order functions.</span></span>

<span data-ttu-id="b6408-138">如需詳細資訊，請參閱 [標準查詢運算子總覽 (c # ) ](../../csharp/programming-guide/concepts/linq/standard-query-operators-overview.md) 和 [標準查詢運算子總覽 (Visual Basic) ](../../visual-basic/programming-guide/concepts/linq/standard-query-operators-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="b6408-138">For more information, see [Standard Query Operators Overview (C#)](../../csharp/programming-guide/concepts/linq/standard-query-operators-overview.md) and [Standard Query Operators Overview (Visual Basic)](../../visual-basic/programming-guide/concepts/linq/standard-query-operators-overview.md).</span></span>

<span data-ttu-id="b6408-139">Lambda 運算式 </span><span class="sxs-lookup"><span data-stu-id="b6408-139">lambda expression </span></span>\
<span data-ttu-id="b6408-140">基本上，這是可用於任何需要委派型別之處的內嵌匿名函式。</span><span class="sxs-lookup"><span data-stu-id="b6408-140">Essentially, an inline anonymous function that can be used wherever a delegate type is expected.</span></span> <span data-ttu-id="b6408-141">這是 lambda 運算式的簡化定義，但適用于本教學課程的目的。</span><span class="sxs-lookup"><span data-stu-id="b6408-141">This is a simplified definition of lambda expressions, but it's adequate for the purposes of this tutorial.</span></span>

<span data-ttu-id="b6408-142">如需詳細資訊，請參閱 [lambda 運算式 (c # 程式設計手冊) ](../../csharp/language-reference/operators/lambda-expressions.md) 和 [lambda 運算式 (Visual Basic) # B4 ](../../visual-basic/programming-guide/language-features/procedures/lambda-expressions.md)。</span><span class="sxs-lookup"><span data-stu-id="b6408-142">For more information, see [Lambda expressions (C# Programming Guide)](../../csharp/language-reference/operators/lambda-expressions.md) and [Lambda Expressions (Visual Basic))](../../visual-basic/programming-guide/language-features/procedures/lambda-expressions.md).</span></span>

<span data-ttu-id="b6408-143">集合 </span><span class="sxs-lookup"><span data-stu-id="b6408-143">collection </span></span>\
<span data-ttu-id="b6408-144">一組結構化的資料，通常屬於統一的型別。</span><span class="sxs-lookup"><span data-stu-id="b6408-144">A structured set of data, usually of a uniform type.</span></span> <span data-ttu-id="b6408-145">為與 LINQ 相容，集合必須實作 <xref:System.Collections.IEnumerable> 介面或 <xref:System.Linq.IQueryable> 介面 (或以下其中一個泛型對應項目：<xref:System.Collections.Generic.IEnumerator%601> 或 <xref:System.Linq.IQueryable%601>)。</span><span class="sxs-lookup"><span data-stu-id="b6408-145">To be compatible with LINQ, a collection must implement the <xref:System.Collections.IEnumerable> interface or the <xref:System.Linq.IQueryable> interface (or one of their generic counterparts, <xref:System.Collections.Generic.IEnumerator%601> or <xref:System.Linq.IQueryable%601>).</span></span>

<span data-ttu-id="b6408-146">元組 (匿名型別) </span><span class="sxs-lookup"><span data-stu-id="b6408-146">tuple (anonymous types) </span></span>\
<span data-ttu-id="b6408-147">這是一個數學概念，一個 Tuple 表示一個有限的物件順序，每個都有特定的型別。</span><span class="sxs-lookup"><span data-stu-id="b6408-147">A mathematical concept, a tuple is a finite sequence of objects, each of a specific type.</span></span> <span data-ttu-id="b6408-148">Tuple 也稱為排序清單。</span><span class="sxs-lookup"><span data-stu-id="b6408-148">A tuple is also known as an ordered list.</span></span> <span data-ttu-id="b6408-149">匿名型別為此概念的語言實作，可以宣告未具名的類別型別，並同時具現化該類別的物件。</span><span class="sxs-lookup"><span data-stu-id="b6408-149">Anonymous types are a language implementation of this concept, which enable an unnamed class type to be declared and an object of that type to be instantiated at the same time.</span></span>

<span data-ttu-id="b6408-150">如需詳細資訊，請參閱 [匿名型別 (c # 程式設計手冊) ](../../csharp/programming-guide/classes-and-structs/anonymous-types.md) 和 [匿名型別 (Visual Basic) ](../../visual-basic/programming-guide/language-features/objects-and-classes/anonymous-types.md)。</span><span class="sxs-lookup"><span data-stu-id="b6408-150">For more information, see [Anonymous Types (C# Programming Guide)](../../csharp/programming-guide/classes-and-structs/anonymous-types.md) and [Anonymous Types (Visual Basic)](../../visual-basic/programming-guide/language-features/objects-and-classes/anonymous-types.md).</span></span>

<span data-ttu-id="b6408-151">型別推斷 (隱含型別) </span><span class="sxs-lookup"><span data-stu-id="b6408-151">type inference (implicit typing) </span></span>\
<span data-ttu-id="b6408-152">編譯器在沒有明確的型別宣告時，判斷變數型別的能力。</span><span class="sxs-lookup"><span data-stu-id="b6408-152">The ability of a compiler to determine the type of a variable in the absence of an explicit type declaration.</span></span>

<span data-ttu-id="b6408-153">如需詳細資訊，請參閱 [隱含類型區域變數 (c # 程式設計手冊) ](../../csharp/programming-guide/classes-and-structs/implicitly-typed-local-variables.md) 和 [區欄位型別推斷 (Visual Basic) ](../../visual-basic/programming-guide/language-features/variables/local-type-inference.md)。</span><span class="sxs-lookup"><span data-stu-id="b6408-153">For more information, see [Implicitly typed local variables (C# Programming Guide)](../../csharp/programming-guide/classes-and-structs/implicitly-typed-local-variables.md) and [Local Type Inference (Visual Basic)](../../visual-basic/programming-guide/language-features/variables/local-type-inference.md).</span></span>

<span data-ttu-id="b6408-154">延後執行與延遲評估 </span><span class="sxs-lookup"><span data-stu-id="b6408-154">deferred execution and lazy evaluation </span></span>\
<span data-ttu-id="b6408-155">延後運算式的評估，直到實際需要其解決的值為止。</span><span class="sxs-lookup"><span data-stu-id="b6408-155">The delaying of evaluation of an expression until its resolved value is actually required.</span></span> <span data-ttu-id="b6408-156">在集合中，支援延後執行。</span><span class="sxs-lookup"><span data-stu-id="b6408-156">Deferred execution is supported in collections.</span></span>

<span data-ttu-id="b6408-157">如需更多 c # 資訊，請參閱 [LINQ 查詢的簡介 (c # ) ](../../csharp/programming-guide/concepts/linq/introduction-to-linq-queries.md) 和 [LINQ to XML (c # ) 中的順延強制和延遲評估 ](./deferred-execution-lazy-evaluation.md)。</span><span class="sxs-lookup"><span data-stu-id="b6408-157">For more C# information, see [Introduction to LINQ Queries (C#)](../../csharp/programming-guide/concepts/linq/introduction-to-linq-queries.md) and [Deferred Execution and Lazy Evaluation in LINQ to XML (C#)](./deferred-execution-lazy-evaluation.md).</span></span>

<span data-ttu-id="b6408-158">如需詳細 Visual Basic 資訊，請參閱 LINQ to XML (Visual Basic) 中的 [基本查詢作業 (Visual Basic) ](../../visual-basic/programming-guide/concepts/linq/basic-query-operations.md) 和 [延後執行和延遲評估 ](./deferred-execution-lazy-evaluation.md)。</span><span class="sxs-lookup"><span data-stu-id="b6408-158">For more Visual Basic information, see [Basic Query Operations (Visual Basic)](../../visual-basic/programming-guide/concepts/linq/basic-query-operations.md) and [Deferred Execution and Lazy Evaluation in LINQ to XML (Visual Basic)](./deferred-execution-lazy-evaluation.md).</span></span>

<span data-ttu-id="b6408-159">這些語言功能將用於本節的所有程式碼範例中。</span><span class="sxs-lookup"><span data-stu-id="b6408-159">These language features will be used in code samples throughout this section.</span></span>

## <a name="see-also"></a><span data-ttu-id="b6408-160">另請參閱</span><span class="sxs-lookup"><span data-stu-id="b6408-160">See also</span></span>

- [<span data-ttu-id="b6408-161">純功能轉換簡介</span><span class="sxs-lookup"><span data-stu-id="b6408-161">Introduction to pure functional transformations</span></span>](introduction-pure-functional-transformations.md)
- [<span data-ttu-id="b6408-162">功能程式設計與命令式程式設計的比較</span><span class="sxs-lookup"><span data-stu-id="b6408-162">Functional programming vs. imperative programming</span></span>](functional-vs-imperative-programming.md)
