---
title: LINQ to XML 與其他 XML 技術的比較
description: 瞭解 LINQ to XML 與 XSLT、MSXML 和 XmlLite 的比較，以提供更好的技術選擇。
ms.date: 07/20/2015
ms.assetid: 01b8e746-12d3-471d-b811-7539e4547784
ms.openlocfilehash: ac118543bd1101e50edfcf99a609a715b885bfbd
ms.sourcegitcommit: 0c3ce6d2e7586d925a30f231f32046b7b3934acb
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 09/08/2020
ms.locfileid: "89552268"
---
# <a name="linq-to-xml-vs-other-xml-technologies"></a><span data-ttu-id="22a8c-103">LINQ to XML 與其他 XML 技術的比較</span><span class="sxs-lookup"><span data-stu-id="22a8c-103">LINQ to XML vs. other XML technologies</span></span>

<span data-ttu-id="22a8c-104">本文將比較 LINQ to XML 與下列 XML 技術： <xref:System.Xml.XmlReader> 、XSLT、MSXML 和 XmlLite。</span><span class="sxs-lookup"><span data-stu-id="22a8c-104">This article compares LINQ to XML to the following XML technologies: <xref:System.Xml.XmlReader>, XSLT, MSXML, and XmlLite.</span></span> <span data-ttu-id="22a8c-105">此資訊可協助您決定要使用的技術。</span><span class="sxs-lookup"><span data-stu-id="22a8c-105">This information can help you decide which technologies to use.</span></span>

<span data-ttu-id="22a8c-106">如需 LINQ to XML 與檔物件模型 (DOM) 的比較，請參閱 [LINQ to XML 與 dom](linq-xml-vs-dom.md)的比較。</span><span class="sxs-lookup"><span data-stu-id="22a8c-106">For a comparison of LINQ to XML to the Document Object Model (DOM), see [LINQ to XML vs. DOM](linq-xml-vs-dom.md).</span></span>

## <a name="linq-to-xml-vs-xmlreader"></a><span data-ttu-id="22a8c-107">LINQ to XML 與 XmlReader 之比較</span><span class="sxs-lookup"><span data-stu-id="22a8c-107">LINQ to XML vs. XmlReader</span></span>

<span data-ttu-id="22a8c-108"><xref:System.Xml.XmlReader> 是一個快速、順向、非快取的剖析器。</span><span class="sxs-lookup"><span data-stu-id="22a8c-108"><xref:System.Xml.XmlReader> is a fast, forward-only, non-caching parser.</span></span>

<span data-ttu-id="22a8c-109">LINQ to XML 會在之上執行 <xref:System.Xml.XmlReader> ，而且它們會緊密整合。</span><span class="sxs-lookup"><span data-stu-id="22a8c-109">LINQ to XML is implemented on top of <xref:System.Xml.XmlReader>, and they're tightly integrated.</span></span> <span data-ttu-id="22a8c-110">不過，您也可以 <xref:System.Xml.XmlReader> 直接使用。</span><span class="sxs-lookup"><span data-stu-id="22a8c-110">However, you can also use <xref:System.Xml.XmlReader> directly.</span></span>

<span data-ttu-id="22a8c-111">例如，假設您要建立一個會每秒剖析數百個 XML 檔的 Web 服務，而且檔具有相同的結構，這表示您只需要撰寫程式碼的其中一個程式碼，就可以剖析 XML。</span><span class="sxs-lookup"><span data-stu-id="22a8c-111">For example, suppose you're building a Web service that will parse hundreds of XML documents per second, and the documents have the same structure, meaning that you only have to write one implementation of the code to parse the XML.</span></span> <span data-ttu-id="22a8c-112">在此情況下，您可能會想要 <xref:System.Xml.XmlReader> 直接使用。</span><span class="sxs-lookup"><span data-stu-id="22a8c-112">In this case, you'd probably want to use <xref:System.Xml.XmlReader> directly.</span></span>

<span data-ttu-id="22a8c-113">相反地，如果您要建立剖析許多較小 XML 檔的系統，而且每個檔都不同，您可能會想要利用 LINQ to XML 所提供的產能改善功能。</span><span class="sxs-lookup"><span data-stu-id="22a8c-113">In contrast, if you're building a system that parses many smaller XML documents, and each one is different, you'd want to take advantage of the productivity improvements that LINQ to XML provides.</span></span>

## <a name="linq-to-xml-vs-xslt"></a><span data-ttu-id="22a8c-114">LINQ to XML 與 XSLT 之比較</span><span class="sxs-lookup"><span data-stu-id="22a8c-114">LINQ to XML vs. XSLT</span></span>

<span data-ttu-id="22a8c-115">LINQ to XML 和 XSLT 都提供大量的 XML 檔轉換功能。</span><span class="sxs-lookup"><span data-stu-id="22a8c-115">Both LINQ to XML and XSLT provide extensive XML document transformation capabilities.</span></span> <span data-ttu-id="22a8c-116">XSLT 是一種以規則為基礎的宣告式方法。</span><span class="sxs-lookup"><span data-stu-id="22a8c-116">XSLT is a rule-based, declarative approach.</span></span> <span data-ttu-id="22a8c-117">高級的 XSLT 程式設計人員會以功能性程式設計方式，撰寫強調沒有狀態 (Stateless) 方法的 XSLT。</span><span class="sxs-lookup"><span data-stu-id="22a8c-117">Advanced XSLT programmers write XSLT in a functional programming style that emphasizes a stateless approach.</span></span> <span data-ttu-id="22a8c-118">您可以使用實作時沒有副作用的純虛擬函式來撰寫轉換。</span><span class="sxs-lookup"><span data-stu-id="22a8c-118">Transformations can be written using pure functions that are implemented without side effects.</span></span> <span data-ttu-id="22a8c-119">許多開發人員不熟悉這個以規則為基礎或功能性方法，而且學習起來可能既困難又耗時。</span><span class="sxs-lookup"><span data-stu-id="22a8c-119">This rule-based or functional approach is unfamiliar to many developers, and can be difficult and time-consuming to learn.</span></span>

<span data-ttu-id="22a8c-120">XSLT 可以是產生高效能應用程式的生產系統。</span><span class="sxs-lookup"><span data-stu-id="22a8c-120">XSLT can be a productive system that yields high-performance applications.</span></span> <span data-ttu-id="22a8c-121">例如，某些大型的網路公司會使用 XSLT，從 XML 產生 HTML，並從不同類型的資料存放區提取。</span><span class="sxs-lookup"><span data-stu-id="22a8c-121">For example, some large Web companies use XSLT as a way to generate HTML from XML that has been pulled from different kinds of data stores.</span></span> <span data-ttu-id="22a8c-122">Managed XSLT 引擎會將 XSLT 編譯為 common language runtime (CLR) 程式碼，在某些情況下執行的效果更優於原生 XSLT 引擎。</span><span class="sxs-lookup"><span data-stu-id="22a8c-122">The managed XSLT engine compiles XSLT to common language runtime (CLR) code, and performs even better in some scenarios than the native XSLT engine.</span></span>

<span data-ttu-id="22a8c-123">不過，XSLT 無法利用許多開發人員所擁有的 c # 和 Visual Basic 知識。</span><span class="sxs-lookup"><span data-stu-id="22a8c-123">However, XSLT doesn't take advantage of the C# and Visual Basic knowledge that many developers have.</span></span> <span data-ttu-id="22a8c-124">它需要開發人員以不同而且複雜的程式設計語言撰寫程式碼。</span><span class="sxs-lookup"><span data-stu-id="22a8c-124">It requires developers to write code in a different and complex programming language.</span></span> <span data-ttu-id="22a8c-125">使用兩個非整合式開發系統 (例如，C# (或 Visual Basic) 和 XSLT) 會使軟體系統難以開發與維護。</span><span class="sxs-lookup"><span data-stu-id="22a8c-125">Using two non-integrated development systems such as C# (or Visual Basic) and XSLT results in software systems that are more difficult to develop and maintain.</span></span>

<span data-ttu-id="22a8c-126">在您 LINQ to XML 查詢運算式之後，LINQ to XML 轉換是很容易使用的強大技術。</span><span class="sxs-lookup"><span data-stu-id="22a8c-126">After you've mastered LINQ to XML query expressions, LINQ to XML transformations are a powerful technology that's easy to use.</span></span> <span data-ttu-id="22a8c-127">基本上，您可以形成自己的 XML 文件，方法是，使用功能結構、從各種來源納入資料、動態建構 <xref:System.Xml.Linq.XElement> 物件，然後將全部組合成一個新的 XML 樹狀結構。</span><span class="sxs-lookup"><span data-stu-id="22a8c-127">Basically, you form your XML document by using functional construction, pulling in data from various sources, constructing <xref:System.Xml.Linq.XElement> objects dynamically, and assembling the whole into a new XML tree.</span></span> <span data-ttu-id="22a8c-128">轉換可以產生全新的文件。</span><span class="sxs-lookup"><span data-stu-id="22a8c-128">The transformation can generate a completely new document.</span></span> <span data-ttu-id="22a8c-129">在 LINQ to XML 中建立轉換相當簡單且直覺化，而且產生的程式碼是可讀取的。</span><span class="sxs-lookup"><span data-stu-id="22a8c-129">Constructing transformations in LINQ to XML is relatively easy and intuitive, and the resulting code is readable.</span></span> <span data-ttu-id="22a8c-130">這會降低開發與維護的成本。</span><span class="sxs-lookup"><span data-stu-id="22a8c-130">This reduces development and maintenance costs.</span></span>

<span data-ttu-id="22a8c-131">LINQ to XML 不適合取代 XSLT。</span><span class="sxs-lookup"><span data-stu-id="22a8c-131">LINQ to XML isn't intended to replace XSLT.</span></span> <span data-ttu-id="22a8c-132">XSLT 仍然是複雜且以檔為主的 XML 轉換所選擇的工具，特別是當檔的結構未妥善定義時。</span><span class="sxs-lookup"><span data-stu-id="22a8c-132">XSLT is still the tool of choice for complicated and document-centric XML transformations, especially if the structure of the document isn't well defined.</span></span>

<span data-ttu-id="22a8c-133">XSLT 具有做為全球資訊網協會 (W3C) 標準的優點。</span><span class="sxs-lookup"><span data-stu-id="22a8c-133">XSLT has the advantage of being a World Wide Web Consortium (W3C) standard.</span></span> <span data-ttu-id="22a8c-134">如果您的需求為只使用標準的技術，XSLT 可能更合適。</span><span class="sxs-lookup"><span data-stu-id="22a8c-134">If you have a requirement that you use only technologies that are standards, XSLT might be more appropriate.</span></span>

<span data-ttu-id="22a8c-135">XSLT 是 XML，因此可以用程式設計的方式操作。</span><span class="sxs-lookup"><span data-stu-id="22a8c-135">XSLT is XML, and that's why it can be programmatically manipulated.</span></span>

## <a name="linq-to-xml-vs-msxml"></a><span data-ttu-id="22a8c-136">LINQ to XML 與 MSXML 之比較</span><span class="sxs-lookup"><span data-stu-id="22a8c-136">LINQ to XML vs. MSXML</span></span>

<span data-ttu-id="22a8c-137">MSXML 是以 COM 為基礎的技術，用於處理 Microsoft Windows 隨附的 XML。</span><span class="sxs-lookup"><span data-stu-id="22a8c-137">MSXML is the COM-based technology for processing XML that's included with Microsoft Windows.</span></span> <span data-ttu-id="22a8c-138">MSXML 會提供 DOM 的原始實作 (包含對於 XPath 和 XSLT 的支援)，</span><span class="sxs-lookup"><span data-stu-id="22a8c-138">MSXML provides a native implementation of the DOM with support for XPath and XSLT.</span></span> <span data-ttu-id="22a8c-139">同時也包含 SAX2 非快取的事件型剖析器。</span><span class="sxs-lookup"><span data-stu-id="22a8c-139">It also contains the SAX2 non-caching, event-based parser.</span></span>

<span data-ttu-id="22a8c-140">MSXML 的執行效果很好，在大部分的情況下預設是安全的，而且可以在 Internet Explorer 中存取，以在 AJAX 樣式的應用程式中進行用戶端 XML 處理。</span><span class="sxs-lookup"><span data-stu-id="22a8c-140">MSXML performs well, is secure by default in most scenarios, and can be accessed in Internet Explorer for doing client-side XML processing in AJAX-style applications.</span></span> <span data-ttu-id="22a8c-141">從支援 COM (包括 C++、JavaScript 和 Visual Basic 6.0) 的任何程式設計語言都可以使用 MSXML。</span><span class="sxs-lookup"><span data-stu-id="22a8c-141">MSXML can be used from any programming language that supports COM, including C++, JavaScript, and Visual Basic 6.0.</span></span>

<span data-ttu-id="22a8c-142">不建議在以 CLR 為基礎的 managed 程式碼中使用 MSXML。</span><span class="sxs-lookup"><span data-stu-id="22a8c-142">MSXML isn't recommended for use in managed code based on the CLR.</span></span>

## <a name="linq-to-xml-vs-xmllite"></a><span data-ttu-id="22a8c-143">LINQ to XML 與 XmlLite 之比較</span><span class="sxs-lookup"><span data-stu-id="22a8c-143">LINQ to XML vs. XmlLite</span></span>

<span data-ttu-id="22a8c-144">XmlLite 是一個非快取、順向、提取的剖析器。</span><span class="sxs-lookup"><span data-stu-id="22a8c-144">XmlLite is a non-caching, forward only, pull parser.</span></span> <span data-ttu-id="22a8c-145">開發人員主要會使用 XmlLite 搭配 C++。</span><span class="sxs-lookup"><span data-stu-id="22a8c-145">Developers primarily use XmlLite with C++.</span></span> <span data-ttu-id="22a8c-146">開發人員不建議將 XmlLite 與 managed 程式碼搭配使用。</span><span class="sxs-lookup"><span data-stu-id="22a8c-146">It's not recommended for developers to use XmlLite with managed code.</span></span>

<span data-ttu-id="22a8c-147">XmlLite 的主要優點是，它是輕量、快速的 XML 剖析器，在大部分的情況下都是安全的。</span><span class="sxs-lookup"><span data-stu-id="22a8c-147">The main advantage of XmlLite is that it's a lightweight, fast XML parser that's secure in most scenarios.</span></span> <span data-ttu-id="22a8c-148">它的威脅表面區域很小。</span><span class="sxs-lookup"><span data-stu-id="22a8c-148">Its threat surface area is small.</span></span> <span data-ttu-id="22a8c-149">如果您必須剖析不受信任的文件，而且您想要防止諸如阻絕服務或洩漏資料等攻擊，XmlLite 可能是一個相當好的選擇。</span><span class="sxs-lookup"><span data-stu-id="22a8c-149">If you have to parse untrusted documents and you want to protect against attacks such as denial of service or exposure of data, XmlLite might be a good option.</span></span>

<span data-ttu-id="22a8c-150">XmlLite 未與 (LINQ) 的語言整合式查詢整合。</span><span class="sxs-lookup"><span data-stu-id="22a8c-150">XmlLite isn't integrated with Language-Integrated Query (LINQ).</span></span> <span data-ttu-id="22a8c-151">它不會讓程式設計人員的產能改善成為 LINQ 背後的動機。</span><span class="sxs-lookup"><span data-stu-id="22a8c-151">It doesn't yield the programmer productivity improvements that are the motivating force behind LINQ.</span></span>

## <a name="see-also"></a><span data-ttu-id="22a8c-152">另請參閱</span><span class="sxs-lookup"><span data-stu-id="22a8c-152">See also</span></span>

- [<span data-ttu-id="22a8c-153">LINQ to XML 總覽</span><span class="sxs-lookup"><span data-stu-id="22a8c-153">LINQ to XML overview</span></span>](linq-xml-overview.md)
