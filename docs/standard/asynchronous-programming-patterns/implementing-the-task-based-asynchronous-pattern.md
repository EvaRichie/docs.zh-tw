---
title: 實作以工作為基礎的非同步模式
description: 本文說明如何執行以工作為基礎的非同步模式。 您可以使用它來執行計算系結和 i/o 系結的非同步作業。
ms.date: 06/14/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- asynchronous design patterns, .NET
- TAP, .NET support for
- Task-based Asynchronous Pattern, .NET support for
- .NET, asynchronous design patterns
ms.assetid: fab6bd41-91bd-44ad-86f9-d8319988aa78
ms.openlocfilehash: 8bac9d265211d2f266db634d4bcebb87c2debd9a
ms.sourcegitcommit: 4a938327bad8b2e20cabd0f46a9dc50882596f13
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 10/28/2020
ms.locfileid: "92888772"
---
# <a name="implementing-the-task-based-asynchronous-pattern"></a><span data-ttu-id="e51c8-104">實作以工作為基礎的非同步模式</span><span class="sxs-lookup"><span data-stu-id="e51c8-104">Implementing the Task-based Asynchronous Pattern</span></span>
<span data-ttu-id="e51c8-105">您可以採用三種方式實作工作式非同步模式 (TAP)：使用 Visual Studio 中的 C# 和 Visual Basic 編譯器、手動，或是透過編譯器和手動方法的組合。</span><span class="sxs-lookup"><span data-stu-id="e51c8-105">You can implement the Task-based Asynchronous Pattern (TAP) in three ways: by using the C# and Visual Basic compilers in Visual Studio, manually, or through a combination of the compiler and manual methods.</span></span> <span data-ttu-id="e51c8-106">下列章節詳細討論每一種方法。</span><span class="sxs-lookup"><span data-stu-id="e51c8-106">The following sections discuss each method in detail.</span></span> <span data-ttu-id="e51c8-107">您可以使用 TAP 方法實作計算繫結和 I/O 繫結的非同步作業。</span><span class="sxs-lookup"><span data-stu-id="e51c8-107">You can use the TAP pattern to implement both compute-bound and I/O-bound asynchronous operations.</span></span> <span data-ttu-id="e51c8-108">[工作負載](#workloads)一節討論每種作業類型。</span><span class="sxs-lookup"><span data-stu-id="e51c8-108">The [Workloads](#workloads) section discusses each type of operation.</span></span>

## <a name="generating-tap-methods"></a><span data-ttu-id="e51c8-109">產生 TAP 方法</span><span class="sxs-lookup"><span data-stu-id="e51c8-109">Generating TAP methods</span></span>

### <a name="using-the-compilers"></a><span data-ttu-id="e51c8-110">使用編譯器</span><span class="sxs-lookup"><span data-stu-id="e51c8-110">Using the compilers</span></span>
<span data-ttu-id="e51c8-111">從 .NET Framework 4.5 開始，屬性具有 `async` 關鍵字 (在 Visual Basic 中為 `Async`) 的任何方法都會視為非同步方法，而 C# 和 Visual Basic 編譯器會使用 TAP 執行必要的轉換，藉此透過非同步的方式實作這個方法。</span><span class="sxs-lookup"><span data-stu-id="e51c8-111">Starting with .NET Framework 4.5, any method that is attributed with the `async` keyword (`Async` in Visual Basic) is considered an asynchronous method, and the C# and Visual Basic compilers perform the necessary transformations to implement the method asynchronously by using TAP.</span></span> <span data-ttu-id="e51c8-112">非同步方法應該傳回 <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> 或 <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> 物件。</span><span class="sxs-lookup"><span data-stu-id="e51c8-112">An asynchronous method should return either a <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> or a <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> object.</span></span> <span data-ttu-id="e51c8-113">若是後者，函式主體應該會傳回 `TResult`，而編譯器會確保這個結果是透過產生的工作物件提供。</span><span class="sxs-lookup"><span data-stu-id="e51c8-113">For the latter, the body of the function should return a `TResult`, and the compiler ensures that this result is made available through the resulting task object.</span></span> <span data-ttu-id="e51c8-114">同樣地，方法主體內未處理的任何例外狀況會封送處理至輸出工作，並導致產生的工作在 <xref:System.Threading.Tasks.TaskStatus.Faulted?displayProperty=nameWithType> 狀態結束。</span><span class="sxs-lookup"><span data-stu-id="e51c8-114">Similarly, any exceptions that go unhandled within the body of the method are marshaled to the output task and cause the resulting task to end in the <xref:System.Threading.Tasks.TaskStatus.Faulted?displayProperty=nameWithType> state.</span></span> <span data-ttu-id="e51c8-115">這項規則的例外狀況是當 <xref:System.OperationCanceledException> (或衍生型別) 未處理時，產生的工作會以狀態結束 <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="e51c8-115">The exception to this rule is when an <xref:System.OperationCanceledException> (or derived type) goes unhandled, in which case the resulting task ends in the <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> state.</span></span>

### <a name="generating-tap-methods-manually"></a><span data-ttu-id="e51c8-116">以手動方式產生 TAP 方法</span><span class="sxs-lookup"><span data-stu-id="e51c8-116">Generating TAP methods manually</span></span>
<span data-ttu-id="e51c8-117">您可以手動實作 TAP 模式，以便更有效控制實作。</span><span class="sxs-lookup"><span data-stu-id="e51c8-117">You may implement the TAP pattern manually for better control over implementation.</span></span> <span data-ttu-id="e51c8-118">編譯器會依賴從 <xref:System.Threading.Tasks?displayProperty=nameWithType> 命名空間公開的公用表面區域，和 <xref:System.Runtime.CompilerServices?displayProperty=nameWithType> 命名空間中的支援類型。</span><span class="sxs-lookup"><span data-stu-id="e51c8-118">The compiler relies on the public surface area exposed from the <xref:System.Threading.Tasks?displayProperty=nameWithType> namespace and supporting types in the <xref:System.Runtime.CompilerServices?displayProperty=nameWithType> namespace.</span></span> <span data-ttu-id="e51c8-119">若要自行實作 TAP，請建立 <xref:System.Threading.Tasks.TaskCompletionSource%601> 物件、執行非同步作業，並完成之後呼叫 <xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult%2A>、<xref:System.Threading.Tasks.TaskCompletionSource%601.SetException%2A> 或 <xref:System.Threading.Tasks.TaskCompletionSource%601.SetCanceled%2A> 方法，或其中一個方法的 `Try` 版本。</span><span class="sxs-lookup"><span data-stu-id="e51c8-119">To implement the TAP yourself, you create a <xref:System.Threading.Tasks.TaskCompletionSource%601> object, perform the asynchronous operation, and when it completes, call the <xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult%2A>, <xref:System.Threading.Tasks.TaskCompletionSource%601.SetException%2A>, or <xref:System.Threading.Tasks.TaskCompletionSource%601.SetCanceled%2A> method, or the `Try` version of one of these methods.</span></span> <span data-ttu-id="e51c8-120">當您以手動方式實作 TAP 方法時，您必須在代表的非同步作業完成時，完成產生的工作。</span><span class="sxs-lookup"><span data-stu-id="e51c8-120">When you implement a TAP method manually, you must complete the resulting task when the represented asynchronous operation completes.</span></span> <span data-ttu-id="e51c8-121">例如：</span><span class="sxs-lookup"><span data-stu-id="e51c8-121">For example:</span></span>

[!code-csharp[Conceptual.TAP_Patterns#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#1)]
[!code-vb[Conceptual.TAP_Patterns#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#1)]

### <a name="hybrid-approach"></a><span data-ttu-id="e51c8-122">混合式方法</span><span class="sxs-lookup"><span data-stu-id="e51c8-122">Hybrid approach</span></span>
 <span data-ttu-id="e51c8-123">您可能會發現以手動方式實作 TAP 模式，但將實作的核心邏輯委派給編譯器很實用。</span><span class="sxs-lookup"><span data-stu-id="e51c8-123">You may find it useful to implement the TAP pattern manually but to delegate the core logic for the implementation to the compiler.</span></span> <span data-ttu-id="e51c8-124">例如，當您想要驗證編譯器產生的非同步方法之外的引數時，您可能會想要使用混合式方法，讓例外狀況可以 escape 至方法的直接呼叫端，而不是透過 <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> 物件公開：</span><span class="sxs-lookup"><span data-stu-id="e51c8-124">For example, you may want to use the hybrid approach when you want to verify arguments outside a compiler-generated asynchronous method so that exceptions can escape to the method's direct caller rather than being exposed through the <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> object:</span></span>

 [!code-csharp[Conceptual.TAP_Patterns#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#2)]
 [!code-vb[Conceptual.TAP_Patterns#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#2)]

 <span data-ttu-id="e51c8-125">這類委派的另一種實用情況是在您實作快速路徑最佳化，而且想要傳回快取工作之時。</span><span class="sxs-lookup"><span data-stu-id="e51c8-125">Another case where such delegation is useful is when you're implementing fast-path optimization and want to return a cached task.</span></span>

## <a name="workloads"></a><span data-ttu-id="e51c8-126">工作負載</span><span class="sxs-lookup"><span data-stu-id="e51c8-126">Workloads</span></span>
<span data-ttu-id="e51c8-127">您可以將計算繫結和 I/O 繫結的非同步作業都實作為 TAP 方法。</span><span class="sxs-lookup"><span data-stu-id="e51c8-127">You may implement both compute-bound and I/O-bound asynchronous operations as TAP methods.</span></span> <span data-ttu-id="e51c8-128">不過，當 TAP 方法從程式庫公開時，它們只應該提供給牽涉到 I/O 繫結操作 (它們可能也牽涉到計算，但不應該完全只有計算) 的工作負載。</span><span class="sxs-lookup"><span data-stu-id="e51c8-128">However, when TAP methods are exposed publicly from a library, they should be provided only for workloads that involve I/O-bound operations (they may also involve computation, but should not be purely computational).</span></span> <span data-ttu-id="e51c8-129">如果是單純的計算繫結方法，則只可將它當做同步實作公開。</span><span class="sxs-lookup"><span data-stu-id="e51c8-129">If a method is purely compute-bound, it should be exposed only as a synchronous implementation.</span></span> <span data-ttu-id="e51c8-130">使用該方法的程式碼就可以選擇是否在工作中包裝該同步方法的引動過程，以便將工作卸載至另一個執行緒或實現平行處理。</span><span class="sxs-lookup"><span data-stu-id="e51c8-130">The code that consumes it may then choose whether to wrap an invocation of that synchronous method into a task to offload the work to another thread or to achieve parallelism.</span></span> <span data-ttu-id="e51c8-131">而且，如果是 I/O 繫結方法，則只可將它當作非同步實作公開。</span><span class="sxs-lookup"><span data-stu-id="e51c8-131">And if a method is I/O-bound, it should be exposed only as an asynchronous implementation.</span></span>

### <a name="compute-bound-tasks"></a><span data-ttu-id="e51c8-132">計算繫結工作</span><span class="sxs-lookup"><span data-stu-id="e51c8-132">Compute-bound tasks</span></span>
<span data-ttu-id="e51c8-133"><xref:System.Threading.Tasks.Task?displayProperty=nameWithType> 類別非常適合代表耗用大量運算資源的作業。</span><span class="sxs-lookup"><span data-stu-id="e51c8-133">The <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> class is ideally suited for representing computationally intensive operations.</span></span> <span data-ttu-id="e51c8-134">根據預設，它會利用 <xref:System.Threading.ThreadPool> 類別內的特殊支援提供有效率的執行，而且它也提供對要於何時、何處、及如何執行非同步計算的重大控制。</span><span class="sxs-lookup"><span data-stu-id="e51c8-134">By default, it takes advantage of special support within the <xref:System.Threading.ThreadPool> class to provide efficient execution, and it also provides significant control over when, where, and how asynchronous computations execute.</span></span>

<span data-ttu-id="e51c8-135">您可以以下列方式產生計算繫結工作：</span><span class="sxs-lookup"><span data-stu-id="e51c8-135">You can generate compute-bound tasks in the following ways:</span></span>

- <span data-ttu-id="e51c8-136">在 .NET Framework 4.5 和更新版本中 (包括 .NET Core 和 .NET 5 +) ，請使用靜態 <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> 方法作為的快捷方式 <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="e51c8-136">In .NET Framework 4.5 and later versions (including .NET Core and .NET 5+), use the static <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> method as a shortcut to <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="e51c8-137">您可以使用 <xref:System.Threading.Tasks.Task.Run%2A>，輕鬆啟動以執行緒集區為目標的計算繫結工作。</span><span class="sxs-lookup"><span data-stu-id="e51c8-137">You may use <xref:System.Threading.Tasks.Task.Run%2A> to easily launch a compute-bound task that targets the thread pool.</span></span> <span data-ttu-id="e51c8-138">這是啟動計算系結工作的慣用機制。</span><span class="sxs-lookup"><span data-stu-id="e51c8-138">This is the preferred mechanism for launching a compute-bound task.</span></span> <span data-ttu-id="e51c8-139">只有在您想要對工作擁有更細部的掌控時，才直接使用 `StartNew`。</span><span class="sxs-lookup"><span data-stu-id="e51c8-139">Use `StartNew` directly only when you want more fine-grained control over the task.</span></span>

- <span data-ttu-id="e51c8-140">在 .NET Framework 4 中，使用 <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> 方法，它會接受委派 (通常是 <xref:System.Action%601> 或 <xref:System.Func%601> 要以非同步方式執行) 。</span><span class="sxs-lookup"><span data-stu-id="e51c8-140">In .NET Framework 4, use the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> method, which accepts a delegate (typically an <xref:System.Action%601> or a <xref:System.Func%601>) to be executed asynchronously.</span></span> <span data-ttu-id="e51c8-141">如果您提供 <xref:System.Action%601> 委派，方法會傳回 <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> 物件，代表該委派的非同步執行。</span><span class="sxs-lookup"><span data-stu-id="e51c8-141">If you provide an <xref:System.Action%601> delegate, the method returns a <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> object that represents the asynchronous execution of that delegate.</span></span> <span data-ttu-id="e51c8-142">如果您提供 <xref:System.Func%601> 委派，則該方法會傳回 <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> 物件。</span><span class="sxs-lookup"><span data-stu-id="e51c8-142">If you provide a <xref:System.Func%601> delegate, the method returns a <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> object.</span></span> <span data-ttu-id="e51c8-143"><xref:System.Threading.Tasks.TaskFactory.StartNew%2A> 方法的多載接受取消語彙基元 (<xref:System.Threading.CancellationToken>)、工作建立選項 (<xref:System.Threading.Tasks.TaskCreationOptions>) 和工作排程器 (<xref:System.Threading.Tasks.TaskScheduler>)，這些全都對工作的排程和執行提供精細的控制。</span><span class="sxs-lookup"><span data-stu-id="e51c8-143">Overloads of the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> method accept a cancellation token (<xref:System.Threading.CancellationToken>), task creation options (<xref:System.Threading.Tasks.TaskCreationOptions>), and a task scheduler (<xref:System.Threading.Tasks.TaskScheduler>), all of which provide fine-grained control over the scheduling and execution of the task.</span></span> <span data-ttu-id="e51c8-144">以目前工作排程器為目標的 Factory 執行個體可以當做 <xref:System.Threading.Tasks.Task.Factory%2A> 類別的靜態屬性(<xref:System.Threading.Tasks.Task>)，例如：`Task.Factory.StartNew(…)`。</span><span class="sxs-lookup"><span data-stu-id="e51c8-144">A factory instance that targets the current task scheduler is available as a static property (<xref:System.Threading.Tasks.Task.Factory%2A>) of the <xref:System.Threading.Tasks.Task> class; for example: `Task.Factory.StartNew(…)`.</span></span>

- <span data-ttu-id="e51c8-145">如果您想要個別產生並排定工作，請使用 `Task` 類型的建構函式或 `Start` 方法。</span><span class="sxs-lookup"><span data-stu-id="e51c8-145">Use the constructors of the `Task` type or the `Start` method if you want to generate and schedule the task separately.</span></span> <span data-ttu-id="e51c8-146">公用方法只能傳回已啟動的工作。</span><span class="sxs-lookup"><span data-stu-id="e51c8-146">Public methods must only return tasks that have already been started.</span></span>

- <span data-ttu-id="e51c8-147">使用 <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> 方法的多載。</span><span class="sxs-lookup"><span data-stu-id="e51c8-147">Use the overloads of the <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="e51c8-148">這個方法會建立新的工作，此工作排定在另一個工作完成時。</span><span class="sxs-lookup"><span data-stu-id="e51c8-148">This method creates a new task that is scheduled when another task completes.</span></span> <span data-ttu-id="e51c8-149">部分 <xref:System.Threading.Tasks.Task.ContinueWith%2A> 多載接受取消語彙基元、接續選項，以及工作排程器，以便更有效控制接續工作的排程和執行。</span><span class="sxs-lookup"><span data-stu-id="e51c8-149">Some of the <xref:System.Threading.Tasks.Task.ContinueWith%2A> overloads accept a cancellation token, continuation options, and a task scheduler for better control over the scheduling and execution of the continuation task.</span></span>

- <span data-ttu-id="e51c8-150">使用 <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A?displayProperty=nameWithType> 和 <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="e51c8-150">Use the <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A?displayProperty=nameWithType> and <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="e51c8-151">這些方法會建立新的工作，此工作排定在所有或任何提供的一組工作完成時。</span><span class="sxs-lookup"><span data-stu-id="e51c8-151">These methods create a new task that is scheduled when all or any of a supplied set of tasks completes.</span></span> <span data-ttu-id="e51c8-152">這些方法也會提供多載以控制這些工作的排程和執行。</span><span class="sxs-lookup"><span data-stu-id="e51c8-152">These methods also provide overloads to control the scheduling and execution of these tasks.</span></span>

<span data-ttu-id="e51c8-153">在計算繫結工作中，如果系統在開始執行工作前收到取消要求，系統可以避免執行排定的工作。</span><span class="sxs-lookup"><span data-stu-id="e51c8-153">In compute-bound tasks, the system can prevent the execution of a scheduled task if it receives a cancellation request before it starts running the task.</span></span> <span data-ttu-id="e51c8-154">因此，如果您提供取消語彙基元 (<xref:System.Threading.CancellationToken> 物件)，您可以將該語彙基元傳遞至監視語彙基元的非同步程式碼。</span><span class="sxs-lookup"><span data-stu-id="e51c8-154">As such, if you provide a cancellation token (<xref:System.Threading.CancellationToken> object), you can pass that token to the asynchronous code that monitors the token.</span></span> <span data-ttu-id="e51c8-155">您也可以將語彙基元提供給先前所述方法之一，例如 `StartNew` 或 `Run`，讓 `Task` 執行階段也能監視語彙基元。</span><span class="sxs-lookup"><span data-stu-id="e51c8-155">You can also provide the token to one of the previously mentioned methods such as `StartNew` or `Run` so that the `Task` runtime may also monitor the token.</span></span>

<span data-ttu-id="e51c8-156">例如，請考慮呈現影像的非同步方法。</span><span class="sxs-lookup"><span data-stu-id="e51c8-156">For example, consider an asynchronous method that renders an image.</span></span> <span data-ttu-id="e51c8-157">工作主體可以輪詢取消語彙基元，如果在呈現期間收到取消要求，程式碼可以提早結束。</span><span class="sxs-lookup"><span data-stu-id="e51c8-157">The body of the task can poll the cancellation token so that the code may exit early if a cancellation request arrives during rendering.</span></span> <span data-ttu-id="e51c8-158">此外，如果取消要求在轉譯開始之前到達，您會想要避免轉譯作業：</span><span class="sxs-lookup"><span data-stu-id="e51c8-158">In addition, if the cancellation request arrives before rendering starts, you'll want to prevent the rendering operation:</span></span>

[!code-csharp[Conceptual.TAP_Patterns#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#3)]
[!code-vb[Conceptual.TAP_Patterns#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#3)]

<span data-ttu-id="e51c8-159">如果下列條件至少其一為真，則計算繫結工作會在 <xref:System.Threading.Tasks.TaskStatus.Canceled> 狀態結束：</span><span class="sxs-lookup"><span data-stu-id="e51c8-159">Compute-bound tasks end in a <xref:System.Threading.Tasks.TaskStatus.Canceled> state if at least one of the following conditions is true:</span></span>

- <span data-ttu-id="e51c8-160">在工作轉換成 <xref:System.Threading.CancellationToken> 狀態之前，取消要求透過 `StartNew` 物件到達，此物件提供作為建立方法的引數 (例如，`Run` 或 <xref:System.Threading.Tasks.TaskStatus.Running>)。</span><span class="sxs-lookup"><span data-stu-id="e51c8-160">A cancellation request arrives through the <xref:System.Threading.CancellationToken> object, which is provided as an argument to the creation method (for example, `StartNew` or `Run`) before the task transitions to the <xref:System.Threading.Tasks.TaskStatus.Running> state.</span></span>

- <span data-ttu-id="e51c8-161">這類工作主體內未處理 <xref:System.OperationCanceledException> 例外狀況，該例外狀況包含傳遞給工作的相同 <xref:System.Threading.CancellationToken>，且該語彙基元顯示已要求取消。</span><span class="sxs-lookup"><span data-stu-id="e51c8-161">An <xref:System.OperationCanceledException> exception goes unhandled within the body of such a task, that exception contains the same <xref:System.Threading.CancellationToken> that is passed to the task, and that token shows that cancellation is requested.</span></span>

<span data-ttu-id="e51c8-162">如果在工作主體中未處理另一個例外狀況，則工作會在 <xref:System.Threading.Tasks.TaskStatus.Faulted> 狀態結束，且任何等待該工作或存取其結果的嘗試都會造成擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="e51c8-162">If another exception goes unhandled within the body of the task, the task ends in the <xref:System.Threading.Tasks.TaskStatus.Faulted> state, and any attempts to wait on the task or access its result causes an exception to be thrown.</span></span>

### <a name="io-bound-tasks"></a><span data-ttu-id="e51c8-163">I/O 繫結工作</span><span class="sxs-lookup"><span data-stu-id="e51c8-163">I/O-bound tasks</span></span>
<span data-ttu-id="e51c8-164">若要建立不該在整個執行緒執行期間直接支援的工作，請使用 <xref:System.Threading.Tasks.TaskCompletionSource%601> 類型。</span><span class="sxs-lookup"><span data-stu-id="e51c8-164">To create a task that should not be directly backed by a thread for the entirety of its execution, use the <xref:System.Threading.Tasks.TaskCompletionSource%601> type.</span></span> <span data-ttu-id="e51c8-165">這個類型會公開 <xref:System.Threading.Tasks.TaskCompletionSource%601.Task%2A> 屬性，此屬性傳回相關的 <xref:System.Threading.Tasks.Task%601> 執行個體。</span><span class="sxs-lookup"><span data-stu-id="e51c8-165">This type exposes a <xref:System.Threading.Tasks.TaskCompletionSource%601.Task%2A> property that returns an associated <xref:System.Threading.Tasks.Task%601> instance.</span></span> <span data-ttu-id="e51c8-166">此工作的生命週期是由 <xref:System.Threading.Tasks.TaskCompletionSource%601> 方法所控制，例如 <xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult%2A>、<xref:System.Threading.Tasks.TaskCompletionSource%601.SetException%2A>、<xref:System.Threading.Tasks.TaskCompletionSource%601.SetCanceled%2A> 及其 `TrySet` 變體。</span><span class="sxs-lookup"><span data-stu-id="e51c8-166">The life cycle of this task is controlled by <xref:System.Threading.Tasks.TaskCompletionSource%601> methods such as <xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult%2A>, <xref:System.Threading.Tasks.TaskCompletionSource%601.SetException%2A>, <xref:System.Threading.Tasks.TaskCompletionSource%601.SetCanceled%2A>, and their `TrySet` variants.</span></span>

<span data-ttu-id="e51c8-167">我們假設您想要建立在指定的一段時間後才會完成的工作。</span><span class="sxs-lookup"><span data-stu-id="e51c8-167">Let's say that you want to create a task that will complete after a specified period of time.</span></span> <span data-ttu-id="e51c8-168">例如，您可能想要延遲使用者介面中的活動。</span><span class="sxs-lookup"><span data-stu-id="e51c8-168">For example, you may want to delay an activity in the user interface.</span></span> <span data-ttu-id="e51c8-169"><xref:System.Threading.Timer?displayProperty=nameWithType> 類別已提供在一段指定的時間之後以非同步方式叫用委派的功能，您可以使用 <xref:System.Threading.Tasks.TaskCompletionSource%601> 將 <xref:System.Threading.Tasks.Task%601> 置於計時器之前，例如：</span><span class="sxs-lookup"><span data-stu-id="e51c8-169">The <xref:System.Threading.Timer?displayProperty=nameWithType> class already provides the ability to asynchronously invoke a delegate after a specified period of time, and by using <xref:System.Threading.Tasks.TaskCompletionSource%601> you can put a <xref:System.Threading.Tasks.Task%601> front on the timer, for example:</span></span>

[!code-csharp[Conceptual.TAP_Patterns#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#4)]
[!code-vb[Conceptual.TAP_Patterns#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#4)]

<span data-ttu-id="e51c8-170"><xref:System.Threading.Tasks.Task.Delay%2A?displayProperty=nameWithType>此方法是為此目的而提供，您可以在另一個非同步方法中使用它，例如，用來執行非同步輪詢迴圈：</span><span class="sxs-lookup"><span data-stu-id="e51c8-170">The <xref:System.Threading.Tasks.Task.Delay%2A?displayProperty=nameWithType> method is provided for this purpose, and you can use it inside another asynchronous method, for example, to implement an asynchronous polling loop:</span></span>

[!code-csharp[Conceptual.TAP_Patterns#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#5)]
[!code-vb[Conceptual.TAP_Patterns#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#5)]

<span data-ttu-id="e51c8-171"><xref:System.Threading.Tasks.TaskCompletionSource%601> 類別沒有非泛型對應項目。</span><span class="sxs-lookup"><span data-stu-id="e51c8-171">The <xref:System.Threading.Tasks.TaskCompletionSource%601> class doesn't have a non-generic counterpart.</span></span> <span data-ttu-id="e51c8-172">不過，<xref:System.Threading.Tasks.Task%601> 衍生自 <xref:System.Threading.Tasks.Task>，所以您可以針對只傳回一項工作的 I/O 繫結方法使用泛型 <xref:System.Threading.Tasks.TaskCompletionSource%601> 物件。</span><span class="sxs-lookup"><span data-stu-id="e51c8-172">However, <xref:System.Threading.Tasks.Task%601> derives from <xref:System.Threading.Tasks.Task>, so you can use the generic <xref:System.Threading.Tasks.TaskCompletionSource%601> object for I/O-bound methods that simply return a task.</span></span> <span data-ttu-id="e51c8-173">若要執行這項操作，您可以使用具有假 `TResult` 的來源 (<xref:System.Boolean> 是很好的預設選擇，但如果您擔心 <xref:System.Threading.Tasks.Task> 的使用者將它向下轉換成 <xref:System.Threading.Tasks.Task%601>，您可以改用私用 `TResult` 類型)。</span><span class="sxs-lookup"><span data-stu-id="e51c8-173">To do this, you can use a source with a dummy `TResult` (<xref:System.Boolean> is a good default choice, but if you're concerned about the user of the <xref:System.Threading.Tasks.Task> downcasting it to a <xref:System.Threading.Tasks.Task%601>, you can use a private `TResult` type instead).</span></span> <span data-ttu-id="e51c8-174">例如，在先前範例中的 `Delay` 方法會傳回目前的時間，以及所產生的位移 (`Task<DateTimeOffset>`)。</span><span class="sxs-lookup"><span data-stu-id="e51c8-174">For example, the `Delay` method in the previous example returns the current time along with the resulting offset (`Task<DateTimeOffset>`).</span></span> <span data-ttu-id="e51c8-175">如果這樣的結果值是不必要的，方法可以改為編碼如下 (請注意變更傳回之類型和引數為 <xref:System.Threading.Tasks.TaskCompletionSource%601.TrySetResult%2A>)：</span><span class="sxs-lookup"><span data-stu-id="e51c8-175">If such a result value is unnecessary, the method could instead be coded as follows (note the change of return type and the change of argument to <xref:System.Threading.Tasks.TaskCompletionSource%601.TrySetResult%2A>):</span></span>

[!code-csharp[Conceptual.TAP_Patterns#6](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#6)]
[!code-vb[Conceptual.TAP_Patterns#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#6)]

### <a name="mixed-compute-bound-and-io-bound-tasks"></a><span data-ttu-id="e51c8-176">混合計算繫結和 I/O 繫結工作</span><span class="sxs-lookup"><span data-stu-id="e51c8-176">Mixed compute-bound and I/O-bound tasks</span></span>
<span data-ttu-id="e51c8-177">非同步方法並不限於只有計算繫結或 I/O 繫結作業，而是可能出現兩者的混合。</span><span class="sxs-lookup"><span data-stu-id="e51c8-177">Asynchronous methods are not limited to just compute-bound or I/O-bound operations but may represent a mixture of the two.</span></span> <span data-ttu-id="e51c8-178">事實上，經常會將多個非同步作業結合成較大的混合作業。</span><span class="sxs-lookup"><span data-stu-id="e51c8-178">In fact, multiple asynchronous operations are often combined into larger mixed operations.</span></span> <span data-ttu-id="e51c8-179">例如，在上述範例中的 `RenderAsync` 方法會執行密集運算的作業，以某些輸入的 `imageData` 為基礎呈現影像。</span><span class="sxs-lookup"><span data-stu-id="e51c8-179">For example, the `RenderAsync` method in a previous example performed a computationally intensive operation to render an image based on some input `imageData`.</span></span> <span data-ttu-id="e51c8-180">這個 `imageData` 可能來自您以非同步的方式存取的 Web 服務：</span><span class="sxs-lookup"><span data-stu-id="e51c8-180">This `imageData` could come from a web service that you asynchronously access:</span></span>

[!code-csharp[Conceptual.TAP_Patterns#7](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#7)]
[!code-vb[Conceptual.TAP_Patterns#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#7)]

<span data-ttu-id="e51c8-181">這個範例也示範單一取消語彙基元如何透過多個非同步作業進行執行緒處理。</span><span class="sxs-lookup"><span data-stu-id="e51c8-181">This example also demonstrates how a single cancellation token may be threaded through multiple asynchronous operations.</span></span> <span data-ttu-id="e51c8-182">如需詳細資訊，請參閱[使用以工作為基礎的非同步模式](consuming-the-task-based-asynchronous-pattern.md)的取消使用方式一節。</span><span class="sxs-lookup"><span data-stu-id="e51c8-182">For more information, see the cancellation usage section in [Consuming the Task-based Asynchronous Pattern](consuming-the-task-based-asynchronous-pattern.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="e51c8-183">請參閱</span><span class="sxs-lookup"><span data-stu-id="e51c8-183">See also</span></span>

- [<span data-ttu-id="e51c8-184">以工作為基礎的非同步模式 (TAP)</span><span class="sxs-lookup"><span data-stu-id="e51c8-184">Task-based Asynchronous Pattern (TAP)</span></span>](task-based-asynchronous-pattern-tap.md)
- [<span data-ttu-id="e51c8-185">使用以工作為基礎的非同步模式</span><span class="sxs-lookup"><span data-stu-id="e51c8-185">Consuming the Task-based Asynchronous Pattern</span></span>](consuming-the-task-based-asynchronous-pattern.md)
- [<span data-ttu-id="e51c8-186">Interop 與其他非同步模式和類型</span><span class="sxs-lookup"><span data-stu-id="e51c8-186">Interop with Other Asynchronous Patterns and Types</span></span>](interop-with-other-asynchronous-patterns-and-types.md)
