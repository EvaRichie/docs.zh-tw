---
title: 實作事件架構非同步模式的最佳作法
ms.date: 03/30/2017
ms.technology: dotnet-standard
helpviewer_keywords:
- Event-based Asynchronous Pattern
- ProgressChangedEventArgs class
- BackgroundWorker component
- events [.NET], asynchronous
- AsyncOperationManager class
- threading [.NET], asynchronous features
- AsyncOperation class
- AsyncCompletedEventArgs class
ms.assetid: 4acd2094-4f46-4eff-9190-92d0d9ff47db
ms.openlocfilehash: 8f2b1b4d6793be3e4de6fbc9fc09e8a7e690762c
ms.sourcegitcommit: 4a938327bad8b2e20cabd0f46a9dc50882596f13
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 10/28/2020
ms.locfileid: "92888915"
---
# <a name="best-practices-for-implementing-the-event-based-asynchronous-pattern"></a><span data-ttu-id="7bde3-102">實作事件架構非同步模式的最佳作法</span><span class="sxs-lookup"><span data-stu-id="7bde3-102">Best Practices for Implementing the Event-based Asynchronous Pattern</span></span>

<span data-ttu-id="7bde3-103">事件架構非同步模式提供有效率的方式，讓您運用熟悉的事件和委派語意，公開類別中的非同步行為。</span><span class="sxs-lookup"><span data-stu-id="7bde3-103">The Event-based Asynchronous Pattern provides you with an effective way to expose asynchronous behavior in classes, with familiar event and delegate semantics.</span></span> <span data-ttu-id="7bde3-104">若要實作事件架構非同步模式，您需要遵循一些特定的行為需求。</span><span class="sxs-lookup"><span data-stu-id="7bde3-104">To implement Event-based Asynchronous Pattern, you need to follow some specific behavioral requirements.</span></span> <span data-ttu-id="7bde3-105">下列各節說明在實作遵循事件架構非同步模式的類別時，所應考量的需求和方針。</span><span class="sxs-lookup"><span data-stu-id="7bde3-105">The following sections describe requirements and guidelines you should consider when you implement a class that follows the Event-based Asynchronous Pattern.</span></span>  
  
 <span data-ttu-id="7bde3-106">如需概觀，請參閱[實作事件架構非同步模式](implementing-the-event-based-asynchronous-pattern.md)。</span><span class="sxs-lookup"><span data-stu-id="7bde3-106">For an overview, see [Implementing the Event-based Asynchronous Pattern](implementing-the-event-based-asynchronous-pattern.md).</span></span>  
  
## <a name="required-behavioral-guarantees"></a><span data-ttu-id="7bde3-107">需要的行為保證</span><span class="sxs-lookup"><span data-stu-id="7bde3-107">Required Behavioral Guarantees</span></span>

 <span data-ttu-id="7bde3-108">如果您實作事件架構非同步模式，則必須提供一些保證，以確保類別的行為正確，並且類別的用戶端可依賴此行為。</span><span class="sxs-lookup"><span data-stu-id="7bde3-108">If you implement the Event-based Asynchronous Pattern, you must provide a number of guarantees to ensure that your class will behave properly and clients of your class can rely on such behavior.</span></span>  
  
### <a name="completion"></a><span data-ttu-id="7bde3-109">Completion</span><span class="sxs-lookup"><span data-stu-id="7bde3-109">Completion</span></span>

 <span data-ttu-id="7bde3-110">在成功完成、發生錯誤或取消時，一律會叫用 <em>MethodName</em>**Completed** 事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="7bde3-110">Always invoke the <em>MethodName</em>**Completed** event handler when you have successful completion, an error, or a cancellation.</span></span> <span data-ttu-id="7bde3-111">應用程式絕對不應該發生保持閒置狀態和永遠無法完成的情況。</span><span class="sxs-lookup"><span data-stu-id="7bde3-111">Applications should never encounter a situation where they remain idle and completion never occurs.</span></span> <span data-ttu-id="7bde3-112">這項規則的唯一例外，是在非同步作業本身設計為永遠無法完成的時候。</span><span class="sxs-lookup"><span data-stu-id="7bde3-112">One exception to this rule is if the asynchronous operation itself is designed so that it never completes.</span></span>  
  
### <a name="completed-event-and-eventargs"></a><span data-ttu-id="7bde3-113">Completed 事件和 EventArgs</span><span class="sxs-lookup"><span data-stu-id="7bde3-113">Completed Event and EventArgs</span></span>

<span data-ttu-id="7bde3-114">對每個 <em>MethodName</em>**Async** 方法，會套用下列設計需求：</span><span class="sxs-lookup"><span data-stu-id="7bde3-114">For each separate <em>MethodName</em>**Async** method, apply the following design requirements:</span></span>  
  
- <span data-ttu-id="7bde3-115">在與此方法相同的類別上定義 <em>MethodName</em>**Completed** 事件。</span><span class="sxs-lookup"><span data-stu-id="7bde3-115">Define a <em>MethodName</em>**Completed** event on the same class as the method.</span></span>  
  
- <span data-ttu-id="7bde3-116">對衍生自 <xref:System.ComponentModel.AsyncCompletedEventArgs> 類別的 <em>MethodName</em>**Completed** 事件，定義 <xref:System.EventArgs> 類別和伴隨的委派。</span><span class="sxs-lookup"><span data-stu-id="7bde3-116">Define an <xref:System.EventArgs> class and accompanying delegate for the <em>MethodName</em>**Completed** event that derives from the <xref:System.ComponentModel.AsyncCompletedEventArgs> class.</span></span> <span data-ttu-id="7bde3-117">預設類別名稱的格式應該為 <em>MethodName</em>**CompletedEventArgs** 。</span><span class="sxs-lookup"><span data-stu-id="7bde3-117">The default class name should be of the form <em>MethodName</em>**CompletedEventArgs** .</span></span>  
  
- <span data-ttu-id="7bde3-118">確定 <xref:System.EventArgs> 類別是 <em>MethodName</em> 方法的傳回值所特有。</span><span class="sxs-lookup"><span data-stu-id="7bde3-118">Ensure that the <xref:System.EventArgs> class is specific to the return values of the <em>MethodName</em> method.</span></span> <span data-ttu-id="7bde3-119">當您使用 <xref:System.EventArgs> 類別時，應該不需要開發人員轉換結果。</span><span class="sxs-lookup"><span data-stu-id="7bde3-119">When you use the <xref:System.EventArgs> class, you should never require developers to cast the result.</span></span>  
  
     <span data-ttu-id="7bde3-120">下列程式碼範例分別示範這項設計需求的良好和不良實作。</span><span class="sxs-lookup"><span data-stu-id="7bde3-120">The following code example shows good and bad implementation of this design requirement respectively.</span></span>  
  
```csharp  
// Good design  
private void Form1_MethodNameCompleted(object sender, xxxCompletedEventArgs e)
{
    DemoType result = e.Result;  
}  
  
// Bad design  
private void Form1_MethodNameCompleted(object sender, MethodNameCompletedEventArgs e)
{
    DemoType result = (DemoType)(e.Result);  
}  
```  
  
- <span data-ttu-id="7bde3-121">請勿對傳回 <xref:System.EventArgs> 的傳回方法定義 `void` 類別，</span><span class="sxs-lookup"><span data-stu-id="7bde3-121">Do not define an <xref:System.EventArgs> class for returning methods that return `void`.</span></span> <span data-ttu-id="7bde3-122">而是使用 <xref:System.ComponentModel.AsyncCompletedEventArgs> 類別的執行個體。</span><span class="sxs-lookup"><span data-stu-id="7bde3-122">Instead, use an instance of the <xref:System.ComponentModel.AsyncCompletedEventArgs> class.</span></span>  
  
- <span data-ttu-id="7bde3-123">確定一律引發 <em>MethodName</em>**Completed** 事件。</span><span class="sxs-lookup"><span data-stu-id="7bde3-123">Ensure that you always raise the <em>MethodName</em>**Completed** event.</span></span> <span data-ttu-id="7bde3-124">此事件應該在成功完成、發生錯誤或取消時引發。</span><span class="sxs-lookup"><span data-stu-id="7bde3-124">This event should be raised on successful completion, on an error, or on cancellation.</span></span> <span data-ttu-id="7bde3-125">應用程式絕對不應該發生保持閒置狀態和永遠無法完成的情況。</span><span class="sxs-lookup"><span data-stu-id="7bde3-125">Applications should never encounter a situation where they remain idle and completion never occurs.</span></span>  
  
- <span data-ttu-id="7bde3-126">確定攔截非同步作業中發生的任何例外狀況，並且將攔截到的例外狀況指派給 <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> 屬性。</span><span class="sxs-lookup"><span data-stu-id="7bde3-126">Ensure that you catch any exceptions that occur in the asynchronous operation and assign the caught exception to the <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> property.</span></span>  
  
- <span data-ttu-id="7bde3-127">如果完成工作時發生錯誤，應該會無法存取結果。</span><span class="sxs-lookup"><span data-stu-id="7bde3-127">If there was an error completing the task, the results should not be accessible.</span></span> <span data-ttu-id="7bde3-128">當 <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> 屬性不是 `null` 時，確定存取 <xref:System.EventArgs> 結構中的任何屬性都會引發例外狀況。</span><span class="sxs-lookup"><span data-stu-id="7bde3-128">When the <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> property is not `null`, ensure that accessing any property in the <xref:System.EventArgs> structure raises an exception.</span></span> <span data-ttu-id="7bde3-129">使用 <xref:System.ComponentModel.AsyncCompletedEventArgs.RaiseExceptionIfNecessary%2A> 方法來執行這項驗證。</span><span class="sxs-lookup"><span data-stu-id="7bde3-129">Use the <xref:System.ComponentModel.AsyncCompletedEventArgs.RaiseExceptionIfNecessary%2A> method to perform this verification.</span></span>  
  
- <span data-ttu-id="7bde3-130">將逾時模型化為錯誤。</span><span class="sxs-lookup"><span data-stu-id="7bde3-130">Model a time out as an error.</span></span> <span data-ttu-id="7bde3-131">如果發生逾時，則引發 <em>MethodName</em>**Completed** 事件，並將 <xref:System.TimeoutException> 指派給 <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> 屬性。</span><span class="sxs-lookup"><span data-stu-id="7bde3-131">When a time out occurs, raise the <em>MethodName</em>**Completed** event and assign a <xref:System.TimeoutException> to the <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> property.</span></span>  
  
- <span data-ttu-id="7bde3-132">如果您的類別支援多個並行引動過程，請確定 <em>MethodName</em>**Completed** 事件包含適當的 `userSuppliedState` 物件。</span><span class="sxs-lookup"><span data-stu-id="7bde3-132">If your class supports multiple concurrent invocations, ensure that the <em>MethodName</em>**Completed** event contains the appropriate `userSuppliedState` object.</span></span>  
  
- <span data-ttu-id="7bde3-133">確定 <em>MethodName</em>**Completed** 事件會在適當的執行緒上，以及應用程式生命週期中的適當時間引發。</span><span class="sxs-lookup"><span data-stu-id="7bde3-133">Ensure that the <em>MethodName</em>**Completed** event is raised on the appropriate thread and at the appropriate time in the application lifecycle.</span></span> <span data-ttu-id="7bde3-134">如需詳細資訊，請參閱＜執行緒和內容＞一節。</span><span class="sxs-lookup"><span data-stu-id="7bde3-134">For more information, see the Threading and Contexts section.</span></span>  
  
### <a name="simultaneously-executing-operations"></a><span data-ttu-id="7bde3-135">同時執行作業</span><span class="sxs-lookup"><span data-stu-id="7bde3-135">Simultaneously Executing Operations</span></span>  
  
- <span data-ttu-id="7bde3-136">如果您的類別支援多個並行引動過程，請讓開發人員定義 <em>MethodName</em>**Async** 多載 (此多載使用物件值狀態參數，或是稱為 `userSuppliedState` 的工作 ID)，以分別追蹤每個引動過程。</span><span class="sxs-lookup"><span data-stu-id="7bde3-136">If your class supports multiple concurrent invocations, enable the developer to track each invocation separately by defining the <em>MethodName</em>**Async** overload that takes an object-valued state parameter, or task ID, called `userSuppliedState`.</span></span> <span data-ttu-id="7bde3-137">這個參數應該一律是 <em>MethodName</em>**Async** 方法簽章中的最後一個參數。</span><span class="sxs-lookup"><span data-stu-id="7bde3-137">This parameter should always be the last parameter in the <em>MethodName</em>**Async** method's signature.</span></span>  
  
- <span data-ttu-id="7bde3-138">如果您的類別定義使用物件值狀態參數或工作 ID 的 <em>MethodName</em>**Async** 多載，請務必使用此工作 ID 來追蹤作業的存留期，並務必將此 ID 傳回完成處理常式。</span><span class="sxs-lookup"><span data-stu-id="7bde3-138">If your class defines the <em>MethodName</em>**Async** overload that takes an object-valued state parameter, or task ID, be sure to track the lifetime of the operation with that task ID, and be sure to provide it back into the completion handler.</span></span> <span data-ttu-id="7bde3-139">有一些 Helper 類別能提供協助。</span><span class="sxs-lookup"><span data-stu-id="7bde3-139">There are helper classes available to assist.</span></span> <span data-ttu-id="7bde3-140">如需並行管理的詳細資訊，請參閱[操作說明：實作支援事件架構非同步模式的元件](component-that-supports-the-event-based-asynchronous-pattern.md)\(英文\)。</span><span class="sxs-lookup"><span data-stu-id="7bde3-140">For more information on concurrency management, see [How to: Implement a Component That Supports the Event-based Asynchronous Pattern](component-that-supports-the-event-based-asynchronous-pattern.md).</span></span>  
  
- <span data-ttu-id="7bde3-141">如果您的類別定義不含狀態參數的 <em>MethodName</em>**Async** 方法，而且不支援多個並行引動過程，請確定之前的 <em>MethodName</em>**Async** 引動過程完成之前，叫用 <em>MethodName</em>**Async** 的任何嘗試動作都會引發 <xref:System.InvalidOperationException>。</span><span class="sxs-lookup"><span data-stu-id="7bde3-141">If your class defines the <em>MethodName</em>**Async** method without the state parameter, and it does not support multiple concurrent invocations, ensure that any attempt to invoke <em>MethodName</em>**Async** before the prior <em>MethodName</em>**Async** invocation has completed raises an <xref:System.InvalidOperationException>.</span></span>  
  
- <span data-ttu-id="7bde3-142">一般而言，如果叫用 <em>MethodName</em>**Async** 方法多次而不使用 `userSuppliedState` 參數，就會形成多個未完成作業，此時請不要引發例外狀況。</span><span class="sxs-lookup"><span data-stu-id="7bde3-142">In general, do not raise an exception if the <em>MethodName</em>**Async** method without the `userSuppliedState` parameter is invoked multiple times so that there are multiple outstanding operations.</span></span> <span data-ttu-id="7bde3-143">當您的類別明確地無法處理這種情況，但開發人員應該能夠處理這些無法區分的多個回呼時，便可以引發例外狀況。</span><span class="sxs-lookup"><span data-stu-id="7bde3-143">You can raise an exception when your class explicitly cannot handle that situation, but assume that developers can handle these multiple indistinguishable callbacks</span></span>  
  
### <a name="accessing-results"></a><span data-ttu-id="7bde3-144">存取結果</span><span class="sxs-lookup"><span data-stu-id="7bde3-144">Accessing Results</span></span>  
  
- <span data-ttu-id="7bde3-145">如果在執行非同步作業時發生錯誤，應該會無法存取結果。</span><span class="sxs-lookup"><span data-stu-id="7bde3-145">If there was an error during execution of the asynchronous operation, the results should not be accessible.</span></span> <span data-ttu-id="7bde3-146">確定當 <xref:System.ComponentModel.AsyncCompletedEventArgs> 不是 <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> 時，存取 `null` 中的任何屬性，都會引發 <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> 所參考的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="7bde3-146">Ensure that accessing any property in the <xref:System.ComponentModel.AsyncCompletedEventArgs> when <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> is not `null` raises the exception referenced by <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A>.</span></span> <span data-ttu-id="7bde3-147">為此，<xref:System.ComponentModel.AsyncCompletedEventArgs> 類別提供了 <xref:System.ComponentModel.AsyncCompletedEventArgs.RaiseExceptionIfNecessary%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="7bde3-147">The <xref:System.ComponentModel.AsyncCompletedEventArgs> class provides the <xref:System.ComponentModel.AsyncCompletedEventArgs.RaiseExceptionIfNecessary%2A> method for this purpose.</span></span>  
  
- <span data-ttu-id="7bde3-148">確定存取結果的任何嘗試動作都會引發 <xref:System.InvalidOperationException>，指出作業已取消。</span><span class="sxs-lookup"><span data-stu-id="7bde3-148">Ensure that any attempt to access the result raises an <xref:System.InvalidOperationException> stating that the operation was canceled.</span></span> <span data-ttu-id="7bde3-149">使用 <xref:System.ComponentModel.AsyncCompletedEventArgs.RaiseExceptionIfNecessary%2A?displayProperty=nameWithType> 方法來執行這項驗證。</span><span class="sxs-lookup"><span data-stu-id="7bde3-149">Use the <xref:System.ComponentModel.AsyncCompletedEventArgs.RaiseExceptionIfNecessary%2A?displayProperty=nameWithType> method to perform this verification.</span></span>  
  
### <a name="progress-reporting"></a><span data-ttu-id="7bde3-150">進度報表</span><span class="sxs-lookup"><span data-stu-id="7bde3-150">Progress Reporting</span></span>  
  
- <span data-ttu-id="7bde3-151">在可能的情況下，會支援進度報告。</span><span class="sxs-lookup"><span data-stu-id="7bde3-151">Support progress reporting, if possible.</span></span> <span data-ttu-id="7bde3-152">這讓開發人員能在使用您的類別時，對應用程式使用者提供更好的體驗。</span><span class="sxs-lookup"><span data-stu-id="7bde3-152">This enables developers to provide a better application user experience when they use your class.</span></span>  
  
- <span data-ttu-id="7bde3-153">如果您實作 **ProgressChanged** 或 <em>MethodName</em>**ProgressChanged** 事件，請確定在引發特定非同步作業的 <em>MethodName</em>**Completed** 事件之後，不會對該作業引發這類事件。</span><span class="sxs-lookup"><span data-stu-id="7bde3-153">If you implement a **ProgressChanged** or <em>MethodName</em>**ProgressChanged** event, ensure that there are no such events raised for a particular asynchronous operation after that operation's <em>MethodName</em>**Completed** event has been raised.</span></span>  
  
- <span data-ttu-id="7bde3-154">如果已填入標準 <xref:System.ComponentModel.ProgressChangedEventArgs>，請確定 <xref:System.ComponentModel.ProgressChangedEventArgs.ProgressPercentage%2A> 一律可以解譯為百分比。</span><span class="sxs-lookup"><span data-stu-id="7bde3-154">If the standard <xref:System.ComponentModel.ProgressChangedEventArgs> is being populated, ensure that the <xref:System.ComponentModel.ProgressChangedEventArgs.ProgressPercentage%2A> can always be interpreted as a percentage.</span></span> <span data-ttu-id="7bde3-155">百分比不需要很精確，但應該代表某個百分比。</span><span class="sxs-lookup"><span data-stu-id="7bde3-155">The percentage does not need to be accurate, but it should represent a percentage.</span></span> <span data-ttu-id="7bde3-156">如果您的進度報告單位必須是百分比以外的單位，請從 <xref:System.ComponentModel.ProgressChangedEventArgs> 類別衍生一個類別，並將 <xref:System.ComponentModel.ProgressChangedEventArgs.ProgressPercentage%2A> 保持為 0。</span><span class="sxs-lookup"><span data-stu-id="7bde3-156">If your progress reporting metric must be something other than a percentage, derive a class from the <xref:System.ComponentModel.ProgressChangedEventArgs> class and leave <xref:System.ComponentModel.ProgressChangedEventArgs.ProgressPercentage%2A> at 0.</span></span> <span data-ttu-id="7bde3-157">避免使用百分比以外的報告單位。</span><span class="sxs-lookup"><span data-stu-id="7bde3-157">Avoid using a reporting metric other than a percentage.</span></span>  
  
- <span data-ttu-id="7bde3-158">確定 `ProgressChanged` 事件會在適當的執行緒上，以及應用程式生命週期中的適當時間引發。</span><span class="sxs-lookup"><span data-stu-id="7bde3-158">Ensure that the `ProgressChanged` event is raised on the appropriate thread and at the appropriate time in the application lifecycle.</span></span> <span data-ttu-id="7bde3-159">如需詳細資訊，請參閱＜執行緒和內容＞一節。</span><span class="sxs-lookup"><span data-stu-id="7bde3-159">For more information, see the Threading and Contexts section.</span></span>  
  
### <a name="isbusy-implementation"></a><span data-ttu-id="7bde3-160">IsBusy 實作</span><span class="sxs-lookup"><span data-stu-id="7bde3-160">IsBusy Implementation</span></span>  
  
- <span data-ttu-id="7bde3-161">如果您的類別支援多個並行引動過程，請勿公開 `IsBusy` 屬性。</span><span class="sxs-lookup"><span data-stu-id="7bde3-161">Do not expose an `IsBusy` property if your class supports multiple concurrent invocations.</span></span> <span data-ttu-id="7bde3-162">例如，XML Web 服務 Proxy 不會公開 `IsBusy` 屬性，因為這些 Proxy 支援非同步方法的多個並行引動過程。</span><span class="sxs-lookup"><span data-stu-id="7bde3-162">For example, XML Web service proxies do not expose an `IsBusy` property because they support multiple concurrent invocations of asynchronous methods.</span></span>  
  
- <span data-ttu-id="7bde3-163">`IsBusy` 屬性在呼叫 <em>MethodName</em>**Async** 方法之後，以及引發 <em>MethodName</em>**Completed** 事件之前，應該傳回 `true`。</span><span class="sxs-lookup"><span data-stu-id="7bde3-163">The `IsBusy` property should return `true` after the <em>MethodName</em>**Async** method has been called and before the <em>MethodName</em>**Completed** event has been raised.</span></span> <span data-ttu-id="7bde3-164">否則應該傳回 `false`。</span><span class="sxs-lookup"><span data-stu-id="7bde3-164">Otherwise it should return `false`.</span></span> <span data-ttu-id="7bde3-165"><xref:System.ComponentModel.BackgroundWorker> 和 <xref:System.Net.WebClient> 元件都是公開 `IsBusy` 屬性之類別的範例。</span><span class="sxs-lookup"><span data-stu-id="7bde3-165">The <xref:System.ComponentModel.BackgroundWorker> and <xref:System.Net.WebClient> components are examples of classes that expose an `IsBusy` property.</span></span>  
  
### <a name="cancellation"></a><span data-ttu-id="7bde3-166">取消</span><span class="sxs-lookup"><span data-stu-id="7bde3-166">Cancellation</span></span>  
  
- <span data-ttu-id="7bde3-167">在可能的情況下，會支援取消。</span><span class="sxs-lookup"><span data-stu-id="7bde3-167">Support cancellation, if possible.</span></span> <span data-ttu-id="7bde3-168">這讓開發人員能在使用您的類別時，對應用程式使用者提供更好的體驗。</span><span class="sxs-lookup"><span data-stu-id="7bde3-168">This enables developers to provide a better application user experience when they use your class.</span></span>  
  
- <span data-ttu-id="7bde3-169">在取消的情況下，請設定 <xref:System.ComponentModel.AsyncCompletedEventArgs.Cancelled%2A> 物件中的 <xref:System.ComponentModel.AsyncCompletedEventArgs> 旗標。</span><span class="sxs-lookup"><span data-stu-id="7bde3-169">In the case of cancellation, set the <xref:System.ComponentModel.AsyncCompletedEventArgs.Cancelled%2A> flag in the <xref:System.ComponentModel.AsyncCompletedEventArgs> object.</span></span>  
  
- <span data-ttu-id="7bde3-170">確定存取結果的任何嘗試動作都會引發 <xref:System.InvalidOperationException>，指出作業已取消。</span><span class="sxs-lookup"><span data-stu-id="7bde3-170">Ensure that any attempt to access the result raises an <xref:System.InvalidOperationException> stating that the operation was canceled.</span></span> <span data-ttu-id="7bde3-171">使用 <xref:System.ComponentModel.AsyncCompletedEventArgs.RaiseExceptionIfNecessary%2A?displayProperty=nameWithType> 方法來執行這項驗證。</span><span class="sxs-lookup"><span data-stu-id="7bde3-171">Use the <xref:System.ComponentModel.AsyncCompletedEventArgs.RaiseExceptionIfNecessary%2A?displayProperty=nameWithType> method to perform this verification.</span></span>  
  
- <span data-ttu-id="7bde3-172">確定對取消方法的呼叫一律會成功傳回，而且絕對不會引發例外狀況。</span><span class="sxs-lookup"><span data-stu-id="7bde3-172">Ensure that calls to a cancellation method always return successfully, and never raise an exception.</span></span> <span data-ttu-id="7bde3-173">一般而言，用戶端不會收到通知，指出作業是否真的可以在任何指定時間取消；用戶端也不會收到通知，指出先前發出的取消是否成功。</span><span class="sxs-lookup"><span data-stu-id="7bde3-173">In general, a client is not notified as to whether an operation is truly cancelable at any given time, and is not notified as to whether a previously issued cancellation has succeeded.</span></span> <span data-ttu-id="7bde3-174">不過，由於應用程式參與完成狀態，因此應用程式一律會在取消成功時收到通知。</span><span class="sxs-lookup"><span data-stu-id="7bde3-174">However, the application will always be given notification when a cancellation succeeded, because the application takes part in the completion status.</span></span>  
  
- <span data-ttu-id="7bde3-175">在取消作業時，引發 <em>MethodName</em>**Completed** 事件。</span><span class="sxs-lookup"><span data-stu-id="7bde3-175">Raise the <em>MethodName</em>**Completed** event when the operation is canceled.</span></span>  
  
### <a name="errors-and-exceptions"></a><span data-ttu-id="7bde3-176">錯誤和例外狀況</span><span class="sxs-lookup"><span data-stu-id="7bde3-176">Errors and Exceptions</span></span>  
  
- <span data-ttu-id="7bde3-177">攔截非同步作業中發生的任何例外狀況，並將 <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A?displayProperty=nameWithType> 屬性的值設定為該例外狀況。</span><span class="sxs-lookup"><span data-stu-id="7bde3-177">Catch any exceptions that occur in the asynchronous operation and set the value of the <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A?displayProperty=nameWithType> property to that exception.</span></span>  
  
### <a name="threading-and-contexts"></a><span data-ttu-id="7bde3-178">執行緒和內容</span><span class="sxs-lookup"><span data-stu-id="7bde3-178">Threading and Contexts</span></span>

 <span data-ttu-id="7bde3-179">類別若要正常運作，必須在適當執行緒上或指定應用程式模型 (包括 ASP.NET 和 Windows Forms 應用程式) 的內容中，叫用用戶端的事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="7bde3-179">For correct operation of your class, it is critical that the client's event handlers are invoked on the proper thread or context for the given application model, including ASP.NET and Windows Forms applications.</span></span> <span data-ttu-id="7bde3-180"><xref:System.ComponentModel.AsyncOperation> 和 <xref:System.ComponentModel.AsyncOperationManager> 等兩個重要的 Helper 類別，可用於確保您的非同步類別在任何應用程式模型下皆運作正常。</span><span class="sxs-lookup"><span data-stu-id="7bde3-180">Two important helper classes are provided to ensure that your asynchronous class behaves correctly under any application model: <xref:System.ComponentModel.AsyncOperation> and <xref:System.ComponentModel.AsyncOperationManager>.</span></span>  
  
 <span data-ttu-id="7bde3-181"><xref:System.ComponentModel.AsyncOperationManager> 提供一個方法 <xref:System.ComponentModel.AsyncOperationManager.CreateOperation%2A>，此方法會傳回 <xref:System.ComponentModel.AsyncOperation>。</span><span class="sxs-lookup"><span data-stu-id="7bde3-181"><xref:System.ComponentModel.AsyncOperationManager> provides one method, <xref:System.ComponentModel.AsyncOperationManager.CreateOperation%2A>, which returns an <xref:System.ComponentModel.AsyncOperation>.</span></span> <span data-ttu-id="7bde3-182">您的 <em>MethodName</em>**Async** 方法會呼叫 <xref:System.ComponentModel.AsyncOperationManager.CreateOperation%2A>，而您的類別會使用傳回的 <xref:System.ComponentModel.AsyncOperation> 來追蹤非同步工作的存留期。</span><span class="sxs-lookup"><span data-stu-id="7bde3-182">Your <em>MethodName</em>**Async** method calls <xref:System.ComponentModel.AsyncOperationManager.CreateOperation%2A> and your class uses the returned <xref:System.ComponentModel.AsyncOperation> to track the lifetime of the asynchronous task.</span></span>  
  
 <span data-ttu-id="7bde3-183">若要向用戶端報告進度、累加結果和完成，請呼叫 <xref:System.ComponentModel.AsyncOperation.Post%2A> 上的 <xref:System.ComponentModel.AsyncOperation.OperationCompleted%2A> 和 <xref:System.ComponentModel.AsyncOperation> 方法。</span><span class="sxs-lookup"><span data-stu-id="7bde3-183">To report progress, incremental results, and completion to the client, call the <xref:System.ComponentModel.AsyncOperation.Post%2A> and <xref:System.ComponentModel.AsyncOperation.OperationCompleted%2A> methods on the <xref:System.ComponentModel.AsyncOperation>.</span></span> <span data-ttu-id="7bde3-184"><xref:System.ComponentModel.AsyncOperation> 會負責將用戶端事件處理常式的呼叫，封送處理至適當的執行緒或內容。</span><span class="sxs-lookup"><span data-stu-id="7bde3-184"><xref:System.ComponentModel.AsyncOperation> is responsible for marshaling calls to the client's event handlers to the proper thread or context.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="7bde3-185">如果要明確違背應用程式模型的原則，不過依然要受益於使用事件架構非同步模式的其他優點，您可以規避這些規則。</span><span class="sxs-lookup"><span data-stu-id="7bde3-185">You can circumvent these rules if you explicitly want to go against the policy of the application model, but still benefit from the other advantages of using the Event-based Asynchronous Pattern.</span></span> <span data-ttu-id="7bde3-186">例如，您可能需要將 Windows Form 中執行的類別設定為無限制執行緒的類別。</span><span class="sxs-lookup"><span data-stu-id="7bde3-186">For example, you may want a class operating in Windows Forms to be free threaded.</span></span> <span data-ttu-id="7bde3-187">只要開發人員了解隱含的限制，您就可以建立無限制執行緒的類別。</span><span class="sxs-lookup"><span data-stu-id="7bde3-187">You can create a free threaded class, as long as developers understand the implied restrictions.</span></span> <span data-ttu-id="7bde3-188">主控台應用程式不會同步執行 <xref:System.ComponentModel.AsyncOperation.Post%2A> 呼叫。</span><span class="sxs-lookup"><span data-stu-id="7bde3-188">Console applications do not synchronize the execution of <xref:System.ComponentModel.AsyncOperation.Post%2A> calls.</span></span> <span data-ttu-id="7bde3-189">這可能會造成 `ProgressChanged` 事件不按順序引發。</span><span class="sxs-lookup"><span data-stu-id="7bde3-189">This can cause `ProgressChanged` events to be raised out of order.</span></span> <span data-ttu-id="7bde3-190">如果您想要以序列化方式執行 <xref:System.ComponentModel.AsyncOperation.Post%2A> 呼叫，請實作及安裝 <xref:System.Threading.SynchronizationContext?displayProperty=nameWithType> 類別。</span><span class="sxs-lookup"><span data-stu-id="7bde3-190">If you wish to have serialized execution of <xref:System.ComponentModel.AsyncOperation.Post%2A> calls, implement and install a <xref:System.Threading.SynchronizationContext?displayProperty=nameWithType> class.</span></span>  
  
 <span data-ttu-id="7bde3-191">如需使用 <xref:System.ComponentModel.AsyncOperation> 與 <xref:System.ComponentModel.AsyncOperationManager> 以啟用非同步作業的詳細資訊，請參閱[操作說明：實作支援事件架構非同步模式的元件](component-that-supports-the-event-based-asynchronous-pattern.md) \(英文\)。</span><span class="sxs-lookup"><span data-stu-id="7bde3-191">For more information about using <xref:System.ComponentModel.AsyncOperation> and <xref:System.ComponentModel.AsyncOperationManager> to enable your asynchronous operations, see [How to: Implement a Component That Supports the Event-based Asynchronous Pattern](component-that-supports-the-event-based-asynchronous-pattern.md).</span></span>  
  
## <a name="guidelines"></a><span data-ttu-id="7bde3-192">指導方針</span><span class="sxs-lookup"><span data-stu-id="7bde3-192">Guidelines</span></span>  
  
- <span data-ttu-id="7bde3-193">理想上，每個方法引動過程都應該獨立於其他引動過程。</span><span class="sxs-lookup"><span data-stu-id="7bde3-193">Ideally, each method invocation should be independent of others.</span></span> <span data-ttu-id="7bde3-194">您應該避免將引動過程與共用資源結合。</span><span class="sxs-lookup"><span data-stu-id="7bde3-194">You should avoid coupling invocations with shared resources.</span></span> <span data-ttu-id="7bde3-195">如果要在引動過程之間共用資源，您需要在實作中提供適當的同步處理機制。</span><span class="sxs-lookup"><span data-stu-id="7bde3-195">If resources are to be shared among invocations, you will need to provide a proper synchronization mechanism in your implementation.</span></span>  
  
- <span data-ttu-id="7bde3-196">不建議使用需要用戶端實作同步處理的設計。</span><span class="sxs-lookup"><span data-stu-id="7bde3-196">Designs that require the client to implement synchronization are discouraged.</span></span> <span data-ttu-id="7bde3-197">例如，您可以有一個非同步方法，接收全域靜態物件做為參數；這種方法的多個並行引動過程可能會造成資料損毀或死結。</span><span class="sxs-lookup"><span data-stu-id="7bde3-197">For example, you could have an asynchronous method that receives a global static object as a parameter; multiple concurrent invocations of such a method could result in data corruption or deadlocks.</span></span>  
  
- <span data-ttu-id="7bde3-198">如果您實作具有多個引動過程多載 (簽章中的 `userState`) 的方法，您的類別將需要管理使用者狀態 (或工作 ID) 及其對應暫止作業的集合。</span><span class="sxs-lookup"><span data-stu-id="7bde3-198">If you implement a method with the multiple-invocation overload (`userState` in the signature), your class will need to manage a collection of user states, or task IDs, and their corresponding pending operations.</span></span> <span data-ttu-id="7bde3-199">這個集合應該以 `lock` 區域保護，因為各種引動過程都會加入和移除集合中的 `userState` 物件。</span><span class="sxs-lookup"><span data-stu-id="7bde3-199">This collection should be protected with `lock` regions, because the various invocations add and remove `userState` objects in the collection.</span></span>  
  
- <span data-ttu-id="7bde3-200">如果可行且適當，請考慮重複使用 `CompletedEventArgs` 類別。</span><span class="sxs-lookup"><span data-stu-id="7bde3-200">Consider reusing `CompletedEventArgs` classes where feasible and appropriate.</span></span> <span data-ttu-id="7bde3-201">在此情況下，由於指定的委派和 <xref:System.EventArgs> 類型不會繫結至單一方法，因此命名將不會與方法名稱一致。</span><span class="sxs-lookup"><span data-stu-id="7bde3-201">In this case, the naming is not consistent with the method name, because a given delegate and <xref:System.EventArgs> type are not tied to a single method.</span></span> <span data-ttu-id="7bde3-202">不過，絕對禁止強制開發人員轉換從 <xref:System.EventArgs> 上屬性擷取的值。</span><span class="sxs-lookup"><span data-stu-id="7bde3-202">However, forcing developers to cast the value retrieved from a property on the <xref:System.EventArgs> is never acceptable.</span></span>  
  
- <span data-ttu-id="7bde3-203">如果您正在撰寫衍生自 <xref:System.ComponentModel.Component> 的類別，請勿實作及安裝您自己的 <xref:System.Threading.SynchronizationContext> 類別。</span><span class="sxs-lookup"><span data-stu-id="7bde3-203">If you are authoring a class that derives from <xref:System.ComponentModel.Component>, do not implement and install your own <xref:System.Threading.SynchronizationContext> class.</span></span> <span data-ttu-id="7bde3-204">應用程式模型 (而不是元件) 會控制使用的 <xref:System.Threading.SynchronizationContext>。</span><span class="sxs-lookup"><span data-stu-id="7bde3-204">Application models, not components, control the <xref:System.Threading.SynchronizationContext> that is used.</span></span>  
  
- <span data-ttu-id="7bde3-205">當您使用任何類型的多執行緒時，您很有可能會暴露在非常嚴重且複雜的錯誤下。</span><span class="sxs-lookup"><span data-stu-id="7bde3-205">When you use multithreading of any sort, you potentially expose yourself to very serious and complex bugs.</span></span> <span data-ttu-id="7bde3-206">在實作任何使用多執行緒的解決方案之前，請參閱 [Managed 執行緒最佳做法](../threading/managed-threading-best-practices.md)。</span><span class="sxs-lookup"><span data-stu-id="7bde3-206">Before implementing any solution that uses multithreading, see [Managed Threading Best Practices](../threading/managed-threading-best-practices.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="7bde3-207">請參閱</span><span class="sxs-lookup"><span data-stu-id="7bde3-207">See also</span></span>

- <xref:System.ComponentModel.AsyncOperation>
- <xref:System.ComponentModel.AsyncOperationManager>
- <xref:System.ComponentModel.AsyncCompletedEventArgs>
- <xref:System.ComponentModel.ProgressChangedEventArgs>
- <xref:System.ComponentModel.BackgroundWorker>
- [<span data-ttu-id="7bde3-208">實作事件架構非同步模式</span><span class="sxs-lookup"><span data-stu-id="7bde3-208">Implementing the Event-based Asynchronous Pattern</span></span>](implementing-the-event-based-asynchronous-pattern.md)
- [<span data-ttu-id="7bde3-209">事件架構非同步模式 (EAP)</span><span class="sxs-lookup"><span data-stu-id="7bde3-209">Event-based Asynchronous Pattern (EAP)</span></span>](event-based-asynchronous-pattern-eap.md)
- [<span data-ttu-id="7bde3-210">決定何時實作事件架構非同步模式</span><span class="sxs-lookup"><span data-stu-id="7bde3-210">Deciding When to Implement the Event-based Asynchronous Pattern</span></span>](deciding-when-to-implement-the-event-based-asynchronous-pattern.md)
- [<span data-ttu-id="7bde3-211">實作事件架構非同步模式的最佳作法</span><span class="sxs-lookup"><span data-stu-id="7bde3-211">Best Practices for Implementing the Event-based Asynchronous Pattern</span></span>](best-practices-for-implementing-the-event-based-asynchronous-pattern.md)
- [<span data-ttu-id="7bde3-212">作法：使用支援事件架構非同步模式的元件</span><span class="sxs-lookup"><span data-stu-id="7bde3-212">How to: Use Components That Support the Event-based Asynchronous Pattern</span></span>](how-to-use-components-that-support-the-event-based-asynchronous-pattern.md)
- [<span data-ttu-id="7bde3-213">作法：實作支援事件架構非同步模式的元件</span><span class="sxs-lookup"><span data-stu-id="7bde3-213">How to: Implement a Component That Supports the Event-based Asynchronous Pattern</span></span>](component-that-supports-the-event-based-asynchronous-pattern.md)
