---
title: 泛型中的共變數和反變數
description: 瞭解共變數（可讓您使用更多衍生型別）和反變數（可讓您在 .NET 泛型中使用較不衍生的型別）。
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- generics, covariance and contravariance
- generics, variance
- covariance and contravariance in generics
- generic type parameters
ms.assetid: 2678dc63-c7f9-4590-9ddc-0a4df684d42e
ms.openlocfilehash: 9d5d5b27fb77500aa5f6deff3fcb1c739ba8b094
ms.sourcegitcommit: d8020797a6657d0fbbdff362b80300815f682f94
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 11/24/2020
ms.locfileid: "95722657"
---
# <a name="covariance-and-contravariance-in-generics"></a><span data-ttu-id="6d9bc-103">泛型中的共變數和反變數</span><span class="sxs-lookup"><span data-stu-id="6d9bc-103">Covariance and contravariance in generics</span></span>

<span data-ttu-id="6d9bc-104">共變數 *和反\*\*變數* 是指使用更多衍生型別的能力 (更明確的) 或較少衍生的類型 (比原先指定更少的特定) 。</span><span class="sxs-lookup"><span data-stu-id="6d9bc-104">*Covariance* and *contravariance* are terms that refer to the ability to use a more derived type (more specific) or a less derived type (less specific) than originally specified.</span></span> <span data-ttu-id="6d9bc-105">泛型類型參數支援共變數和反變數，可在指派和使用泛型類型時提供更大的彈性。</span><span class="sxs-lookup"><span data-stu-id="6d9bc-105">Generic type parameters support covariance and contravariance to provide greater flexibility in assigning and using generic types.</span></span>

<span data-ttu-id="6d9bc-106">當您指的是類型系統、共變數、反變數和 invariance 時，會有下列定義。</span><span class="sxs-lookup"><span data-stu-id="6d9bc-106">When you're referring to a type system, covariance, contravariance, and invariance have the following definitions.</span></span> <span data-ttu-id="6d9bc-107">範例中會假設名為 `Base` 的基底類別，以及名為 `Derived`的衍生類別。</span><span class="sxs-lookup"><span data-stu-id="6d9bc-107">The examples assume a base class named `Base` and a derived class named `Derived`.</span></span>  
  
- `Covariance`  
  
     <span data-ttu-id="6d9bc-108">可讓您使用比原本指定更多衍生的類型。</span><span class="sxs-lookup"><span data-stu-id="6d9bc-108">Enables you to use a more derived type than originally specified.</span></span>  
  
     <span data-ttu-id="6d9bc-109">您可以將的實例指派 `IEnumerable<Derived>` 給類型的變數 `IEnumerable<Base>` 。</span><span class="sxs-lookup"><span data-stu-id="6d9bc-109">You can assign an instance of `IEnumerable<Derived>` to a variable of type `IEnumerable<Base>`.</span></span>  
  
- `Contravariance`  
  
     <span data-ttu-id="6d9bc-110">可讓您使用比原本所指定更泛型 (較少衍生) 的類型。</span><span class="sxs-lookup"><span data-stu-id="6d9bc-110">Enables you to use a more generic (less derived) type than originally specified.</span></span>  
  
     <span data-ttu-id="6d9bc-111">您可以將的實例指派 `Action<Base>` 給類型的變數 `Action<Derived>` 。</span><span class="sxs-lookup"><span data-stu-id="6d9bc-111">You can assign an instance of `Action<Base>` to a variable of type `Action<Derived>`.</span></span>  
  
- `Invariance`  
  
     <span data-ttu-id="6d9bc-112">表示您只能使用原本指定的型別。</span><span class="sxs-lookup"><span data-stu-id="6d9bc-112">Means that you can use only the type originally specified.</span></span> <span data-ttu-id="6d9bc-113">非變異的泛型型別參數不是協變數也不是逆變的。</span><span class="sxs-lookup"><span data-stu-id="6d9bc-113">An invariant generic type parameter is neither covariant nor contravariant.</span></span>  
  
     <span data-ttu-id="6d9bc-114">您無法將的實例指派 `List<Base>` 給類型的變數，反之亦然 `List<Derived>` 。</span><span class="sxs-lookup"><span data-stu-id="6d9bc-114">You cannot assign an instance of `List<Base>` to a variable of type `List<Derived>` or vice versa.</span></span>  
  
 <span data-ttu-id="6d9bc-115">Covariant 型別參數可讓您進行看起來很像一般[多型](../../csharp/programming-guide/classes-and-structs/polymorphism.md)的指派，如下列程式碼所示。</span><span class="sxs-lookup"><span data-stu-id="6d9bc-115">Covariant type parameters enable you to make assignments that look much like ordinary [Polymorphism](../../csharp/programming-guide/classes-and-structs/polymorphism.md), as shown in the following code.</span></span>  
  
 [!code-csharp[CoContraSimpleIEnum#1](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontrasimpleienum/cs/example.cs#1)]
 [!code-vb[CoContraSimpleIEnum#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontrasimpleienum/vb/example.vb#1)]  
  
 <span data-ttu-id="6d9bc-116"><xref:System.Collections.Generic.List%601> 類別會實作 <xref:System.Collections.Generic.IEnumerable%601> 介面，因此 `List<Derived>` (在 Visual Basic 中則為`List(Of Derived)` ) 會實作 `IEnumerable<Derived>`。</span><span class="sxs-lookup"><span data-stu-id="6d9bc-116">The <xref:System.Collections.Generic.List%601> class implements the <xref:System.Collections.Generic.IEnumerable%601> interface, so `List<Derived>` (`List(Of Derived)` in Visual Basic) implements `IEnumerable<Derived>`.</span></span> <span data-ttu-id="6d9bc-117">Covariant 型別參數會完成其餘工作。</span><span class="sxs-lookup"><span data-stu-id="6d9bc-117">The covariant type parameter does the rest.</span></span>  
  
 <span data-ttu-id="6d9bc-118">而 Contravariance 看起來則違反直覺。</span><span class="sxs-lookup"><span data-stu-id="6d9bc-118">Contravariance, on the other hand, seems counterintuitive.</span></span> <span data-ttu-id="6d9bc-119">下列範例會建立 `Action<Base>` (在 Visual Basic 中則為`Action(Of Base)` ) 類型的委派，然後將該委派指派給 `Action<Derived>`類型的變數。</span><span class="sxs-lookup"><span data-stu-id="6d9bc-119">The following example creates a delegate of type `Action<Base>` (`Action(Of Base)` in Visual Basic), and then assigns that delegate to a variable of type `Action<Derived>`.</span></span>  
  
 [!code-csharp[CoContraSimpleAction#1](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontrasimpleaction/cs/example.cs#1)]
 [!code-vb[CoContraSimpleAction#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontrasimpleaction/vb/example.vb#1)]  
  
 <span data-ttu-id="6d9bc-120">這看起來是反向的，但是在編譯和執行時是類型安全的程式碼。</span><span class="sxs-lookup"><span data-stu-id="6d9bc-120">This seems backward, but it is type-safe code that compiles and runs.</span></span> <span data-ttu-id="6d9bc-121">Lambda 運算式符合指派給它的委派，因此它會定義一個方法，此方法會接受一個類型的參數， `Base` 而且沒有傳回值。</span><span class="sxs-lookup"><span data-stu-id="6d9bc-121">The lambda expression matches the delegate it's assigned to, so it defines a method that takes one parameter of type `Base` and that has no return value.</span></span> <span data-ttu-id="6d9bc-122">結果產生的委派可以指派給 `Action<Derived>` 類型的變數，因為 `T` 委派的 <xref:System.Action%601> 類型參數是 Contravariant。</span><span class="sxs-lookup"><span data-stu-id="6d9bc-122">The resulting delegate can be assigned to a variable of type `Action<Derived>` because the type parameter `T` of the <xref:System.Action%601> delegate is contravariant.</span></span> <span data-ttu-id="6d9bc-123">程式碼是類型安全的，因為 `T` 指定參數類型。</span><span class="sxs-lookup"><span data-stu-id="6d9bc-123">The code is type-safe because `T` specifies a parameter type.</span></span> <span data-ttu-id="6d9bc-124">當 `Action<Base>` 類型的委派當成 `Action<Derived>`類型的委派被叫用時，引數必須是 `Derived`類型。</span><span class="sxs-lookup"><span data-stu-id="6d9bc-124">When the delegate of type `Action<Base>` is invoked as if it were a delegate of type `Action<Derived>`, its argument must be of type `Derived`.</span></span> <span data-ttu-id="6d9bc-125">此引數永遠可以安全地傳遞至基礎方法，因為方法的參數是 `Base`類型。</span><span class="sxs-lookup"><span data-stu-id="6d9bc-125">This argument can always be passed safely to the underlying method, because the method's parameter is of type `Base`.</span></span>  
  
 <span data-ttu-id="6d9bc-126">一般來說，Covariant 類型參數可以用來做為委派的傳回類型，而 Contravariant 類型參數可以用來做為參數類型。</span><span class="sxs-lookup"><span data-stu-id="6d9bc-126">In general, a covariant type parameter can be used as the return type of a delegate, and contravariant type parameters can be used as parameter types.</span></span> <span data-ttu-id="6d9bc-127">例如，Covariant 類型參數可以用來做為介面方法的傳回類型，而 Contravariant 類型參數可以用來做為介面方法的參數類型。</span><span class="sxs-lookup"><span data-stu-id="6d9bc-127">For an interface, covariant type parameters can be used as the return types of the interface's methods, and contravariant type parameters can be used as the parameter types of the interface's methods.</span></span>  
  
 <span data-ttu-id="6d9bc-128">共變數和反變數合稱為「變異數」。</span><span class="sxs-lookup"><span data-stu-id="6d9bc-128">Covariance and contravariance are collectively referred to as *variance*.</span></span> <span data-ttu-id="6d9bc-129">未標示 Covariant 或 Contravariant 的泛型類型參數，稱為 *Invariant* 參數。</span><span class="sxs-lookup"><span data-stu-id="6d9bc-129">A generic type parameter that is not marked covariant or contravariant is referred to as *invariant*.</span></span> <span data-ttu-id="6d9bc-130">通用語言執行平台中變異數事實的簡短摘要。</span><span class="sxs-lookup"><span data-stu-id="6d9bc-130">A brief summary of facts about variance in the common language runtime:</span></span>  
  
- <span data-ttu-id="6d9bc-131">Variant 型別參數限制為泛型介面和泛型委派類型。</span><span class="sxs-lookup"><span data-stu-id="6d9bc-131">Variant type parameters are restricted to generic interface and generic delegate types.</span></span>  
  
- <span data-ttu-id="6d9bc-132">泛型介面或泛型委派類型可以同時具有 Covariant 和 Contravariant 類型參數。</span><span class="sxs-lookup"><span data-stu-id="6d9bc-132">A generic interface or generic delegate type can have both covariant and contravariant type parameters.</span></span>  
  
- <span data-ttu-id="6d9bc-133">變異數只適用於參考類型，因此如果將 Variant 類型參數指定為實值類型，該類型參數最後建構的類型會是 Invariant。</span><span class="sxs-lookup"><span data-stu-id="6d9bc-133">Variance applies only to reference types; if you specify a value type for a variant type parameter, that type parameter is invariant for the resulting constructed type.</span></span>  
  
- <span data-ttu-id="6d9bc-134">變異數不適用於委派組合。</span><span class="sxs-lookup"><span data-stu-id="6d9bc-134">Variance does not apply to delegate combination.</span></span> <span data-ttu-id="6d9bc-135">也就是說，如果有分別適用於 `Action<Derived>` 和 `Action<Base>` (在 Visual Basic 中則為`Action(Of Derived)` 和 `Action(Of Base)` ) 類型的兩個委派，您無法將第二個委派與第一個委派組合 (雖然結果會是類型安全的)。</span><span class="sxs-lookup"><span data-stu-id="6d9bc-135">That is, given two delegates of types `Action<Derived>` and `Action<Base>` (`Action(Of Derived)` and `Action(Of Base)` in Visual Basic), you cannot combine the second delegate with the first although the result would be type safe.</span></span> <span data-ttu-id="6d9bc-136">變異數允許將第二個委派指派給 `Action<Derived>`類型的變數，但是委派只有在類型完全相符時才能組合。</span><span class="sxs-lookup"><span data-stu-id="6d9bc-136">Variance allows the second delegate to be assigned to a variable of type `Action<Derived>`, but delegates can combine only if their types match exactly.</span></span>

- <span data-ttu-id="6d9bc-137">從 c # 9 開始，支援協變數傳回類型。</span><span class="sxs-lookup"><span data-stu-id="6d9bc-137">Starting in C# 9, covariant return types are supported.</span></span> <span data-ttu-id="6d9bc-138">覆寫方法可以宣告它所覆寫的方法更衍生的傳回型別，而覆寫的唯讀屬性可以宣告更多衍生的型別。</span><span class="sxs-lookup"><span data-stu-id="6d9bc-138">An overriding method can declare a more derived return type the method it overrides, and an overriding, read-only property can declare a more derived type.</span></span>

<a name="InterfaceCovariantTypeParameters"></a>

## <a name="generic-interfaces-with-covariant-type-parameters"></a><span data-ttu-id="6d9bc-139">具有協變數型別參數的泛型介面</span><span class="sxs-lookup"><span data-stu-id="6d9bc-139">Generic interfaces with covariant type parameters</span></span>

<span data-ttu-id="6d9bc-140">數個泛型介面具有協變數型別參數，例如，、、 <xref:System.Collections.Generic.IEnumerable%601> <xref:System.Collections.Generic.IEnumerator%601> <xref:System.Linq.IQueryable%601> 和 <xref:System.Linq.IGrouping%602> 。</span><span class="sxs-lookup"><span data-stu-id="6d9bc-140">Several generic interfaces have covariant type parameters, for example, <xref:System.Collections.Generic.IEnumerable%601>, <xref:System.Collections.Generic.IEnumerator%601>, <xref:System.Linq.IQueryable%601>, and <xref:System.Linq.IGrouping%602>.</span></span> <span data-ttu-id="6d9bc-141">這些介面的所有類型參數都是共變數，因此類型參數只能用於成員的傳回類型。</span><span class="sxs-lookup"><span data-stu-id="6d9bc-141">All the type parameters of these interfaces are covariant, so the type parameters are used only for the return types of the members.</span></span>  
  
 <span data-ttu-id="6d9bc-142">下列範例會說明 Covariant 類型參數。</span><span class="sxs-lookup"><span data-stu-id="6d9bc-142">The following example illustrates covariant type parameters.</span></span> <span data-ttu-id="6d9bc-143">這個範例定義兩個類型： `Base` 具有名為 `PrintBases` 的靜態方法，此方法會接受 `IEnumerable<Base>` (在 Visual Basic 中則為`IEnumerable(Of Base)` ) 並列印項目。</span><span class="sxs-lookup"><span data-stu-id="6d9bc-143">The example defines two types: `Base` has a static method named `PrintBases` that takes an `IEnumerable<Base>` (`IEnumerable(Of Base)` in Visual Basic) and prints the elements.</span></span> <span data-ttu-id="6d9bc-144">`Derived` 繼承自 `Base`。</span><span class="sxs-lookup"><span data-stu-id="6d9bc-144">`Derived` inherits from `Base`.</span></span> <span data-ttu-id="6d9bc-145">範例會建立空的 `List<Derived>` (在 Visual Basic 中則為 `List(Of Derived)`)，並示範可將此類型傳遞至 `PrintBases`，再指派給類型為 `IEnumerable<Base>` 的變數而不用轉型。</span><span class="sxs-lookup"><span data-stu-id="6d9bc-145">The example creates an empty `List<Derived>` (`List(Of Derived)` in Visual Basic) and demonstrates that this type can be passed to `PrintBases` and assigned to a variable of type `IEnumerable<Base>` without casting.</span></span> <span data-ttu-id="6d9bc-146"><xref:System.Collections.Generic.List%601> 會實作 <xref:System.Collections.Generic.IEnumerable%601>，後者具有單一 Covariant 類型參數。</span><span class="sxs-lookup"><span data-stu-id="6d9bc-146"><xref:System.Collections.Generic.List%601> implements <xref:System.Collections.Generic.IEnumerable%601>, which has a single covariant type parameter.</span></span> <span data-ttu-id="6d9bc-147">Covariant 類型參數是可以使用 `IEnumerable<Derived>` 的執行個體而不能使用 `IEnumerable<Base>`的執行個體的原因。</span><span class="sxs-lookup"><span data-stu-id="6d9bc-147">The covariant type parameter is the reason why an instance of `IEnumerable<Derived>` can be used instead of `IEnumerable<Base>`.</span></span>  
  
 [!code-csharp[CoContravarianceInClrGenericI#1](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravarianceinclrgenerici/cs/example.cs#1)]
 [!code-vb[CoContravarianceInClrGenericI#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravarianceinclrgenerici/vb/example.vb#1)]  
  
## <a name="generic-interfaces-with-contravariant-type-parameters"></a><span data-ttu-id="6d9bc-148">具有逆變型別參數的泛型介面</span><span class="sxs-lookup"><span data-stu-id="6d9bc-148">Generic interfaces with contravariant type parameters</span></span>

<span data-ttu-id="6d9bc-149">數個泛型介面具有逆變型別參數;例如： <xref:System.Collections.Generic.IComparer%601> 、 <xref:System.IComparable%601> 和 <xref:System.Collections.Generic.IEqualityComparer%601> 。</span><span class="sxs-lookup"><span data-stu-id="6d9bc-149">Several generic interfaces have contravariant type parameters; for example: <xref:System.Collections.Generic.IComparer%601>, <xref:System.IComparable%601>, and <xref:System.Collections.Generic.IEqualityComparer%601>.</span></span> <span data-ttu-id="6d9bc-150">這些介面只有 Contravariant 型別參數，因此型別參數只用來做為介面成員中的參數類型。</span><span class="sxs-lookup"><span data-stu-id="6d9bc-150">These interfaces have only contravariant type parameters, so the type parameters are used only as parameter types in the members of the interfaces.</span></span>  
  
 <span data-ttu-id="6d9bc-151">下列範例會說明 Contravariant 類型參數。</span><span class="sxs-lookup"><span data-stu-id="6d9bc-151">The following example illustrates contravariant type parameters.</span></span> <span data-ttu-id="6d9bc-152">範例定義了包含`MustInherit` 屬性的抽象 (在 Visual Basic 中為 `Shape` ) `Area` 類別。</span><span class="sxs-lookup"><span data-stu-id="6d9bc-152">The example defines an abstract (`MustInherit` in Visual Basic) `Shape` class with an `Area` property.</span></span> <span data-ttu-id="6d9bc-153">範例還定義了實作 `ShapeAreaComparer` (在 Visual Basic 中則為 `IComparer<Shape>` ) 的`IComparer(Of Shape)` 類別。</span><span class="sxs-lookup"><span data-stu-id="6d9bc-153">The example also defines a `ShapeAreaComparer` class that implements `IComparer<Shape>` (`IComparer(Of Shape)` in Visual Basic).</span></span> <span data-ttu-id="6d9bc-154"><xref:System.Collections.Generic.IComparer%601.Compare%2A?displayProperty=nameWithType> 方法的實作是以 `Area` 屬性值為基礎，因此可以使用 `ShapeAreaComparer` 依區域排序 `Shape` 物件。</span><span class="sxs-lookup"><span data-stu-id="6d9bc-154">The implementation of the <xref:System.Collections.Generic.IComparer%601.Compare%2A?displayProperty=nameWithType> method is based on the value of the `Area` property, so `ShapeAreaComparer` can be used to sort `Shape` objects by area.</span></span>  
  
 <span data-ttu-id="6d9bc-155">`Circle` 類別會繼承 `Shape` 並覆寫 `Area`。</span><span class="sxs-lookup"><span data-stu-id="6d9bc-155">The `Circle` class inherits `Shape` and overrides `Area`.</span></span> <span data-ttu-id="6d9bc-156">此範例會使用採用 <xref:System.Collections.Generic.SortedSet%601> (在 Visual Basic 中為 `Circle` ) 的建構函式建立 `IComparer<Circle>` 物件的`IComparer(Of Circle)` 。</span><span class="sxs-lookup"><span data-stu-id="6d9bc-156">The example creates a <xref:System.Collections.Generic.SortedSet%601> of `Circle` objects, using a constructor that takes an `IComparer<Circle>` (`IComparer(Of Circle)` in Visual Basic).</span></span> <span data-ttu-id="6d9bc-157">不過，此範例不會傳遞 `IComparer<Circle>`，而是傳遞實作 `ShapeAreaComparer` 的 `IComparer<Shape>` 物件。</span><span class="sxs-lookup"><span data-stu-id="6d9bc-157">However, instead of passing an `IComparer<Circle>`, the example passes a `ShapeAreaComparer` object, which implements `IComparer<Shape>`.</span></span> <span data-ttu-id="6d9bc-158">當程式碼呼叫衍生程度較大類型 (`Shape`) 的比較子時，範例可以傳遞衍生程度較小類型 (`Circle`) 的比較子，因為 <xref:System.Collections.Generic.IComparer%601> 泛型介面的類型參數為 Contravariant。</span><span class="sxs-lookup"><span data-stu-id="6d9bc-158">The example can pass a comparer of a less derived type (`Shape`) when the code calls for a comparer of a more derived type (`Circle`), because the type parameter of the <xref:System.Collections.Generic.IComparer%601> generic interface is contravariant.</span></span>  
  
 <span data-ttu-id="6d9bc-159">將新的 `Circle` 物件加入至 `SortedSet<Circle>`時， `IComparer<Shape>.Compare` 物件的`IComparer(Of Shape).Compare` 方法 (在 Visual Basic 中為 `ShapeAreaComparer` 方法) 會在每次新項目與現有項目比較時呼叫。</span><span class="sxs-lookup"><span data-stu-id="6d9bc-159">When a new `Circle` object is added to the `SortedSet<Circle>`, the `IComparer<Shape>.Compare` method (`IComparer(Of Shape).Compare` method in Visual Basic) of the `ShapeAreaComparer` object is called each time the new element is compared to an existing element.</span></span> <span data-ttu-id="6d9bc-160">這個方法的類型參數 (`Shape`) 相較於傳遞的類型 (`Circle`)，其衍生程度較小，因此該呼叫具備類型安全。</span><span class="sxs-lookup"><span data-stu-id="6d9bc-160">The parameter type of the method (`Shape`) is less derived than the type that is being passed (`Circle`), so the call is type safe.</span></span> <span data-ttu-id="6d9bc-161">反變數 (Contravariance) 可讓 `ShapeAreaComparer` 排序衍生自 `Shape`的任何單一類型集合，以及混合類型集合。</span><span class="sxs-lookup"><span data-stu-id="6d9bc-161">Contravariance enables `ShapeAreaComparer` to sort a collection of any single type, as well as a mixed collection of types, that derive from `Shape`.</span></span>  
  
 [!code-csharp[CoContravarianceInClrGenericI2#1](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravarianceinclrgenerici2/cs/example.cs#1)]
 [!code-vb[CoContravarianceInClrGenericI2#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravarianceinclrgenerici2/vb/example.vb#1)]  

## <a name="generic-delegates-with-variant-type-parameters"></a><span data-ttu-id="6d9bc-162">具有 variant 類型參數的泛型委派</span><span class="sxs-lookup"><span data-stu-id="6d9bc-162">Generic delegates with variant type parameters</span></span>

<span data-ttu-id="6d9bc-163">`Func`泛型委派（例如 <xref:System.Func%602> ）具有協變數傳回類型和逆變參數類型。</span><span class="sxs-lookup"><span data-stu-id="6d9bc-163">The `Func` generic delegates, such as <xref:System.Func%602>, have covariant return types and contravariant parameter types.</span></span> <span data-ttu-id="6d9bc-164">`Action` 泛型委派 (例如 <xref:System.Action%602>) 則具有 Contravariant 類型參數。</span><span class="sxs-lookup"><span data-stu-id="6d9bc-164">The `Action` generic delegates, such as <xref:System.Action%602>, have contravariant parameter types.</span></span> <span data-ttu-id="6d9bc-165">這表示可以將委派指派給具有衍生程度較大參數類型及 (如果是 `Func` 泛型委派) 衍生程度較小的傳回類型的變數。</span><span class="sxs-lookup"><span data-stu-id="6d9bc-165">This means that the delegates can be assigned to variables that have more derived parameter types and (in the case of the `Func` generic delegates) less derived return types.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="6d9bc-166">`Func` 泛型委派的最後一個泛型類型參數會指定委派簽章中的傳回值類型。</span><span class="sxs-lookup"><span data-stu-id="6d9bc-166">The last generic type parameter of the `Func` generic delegates specifies the type of the return value in the delegate signature.</span></span> <span data-ttu-id="6d9bc-167">這個參數是 Covariant (`out` 關鍵字)，而其他泛型類型參數則是 Contravariant (`in` 關鍵字)。</span><span class="sxs-lookup"><span data-stu-id="6d9bc-167">It is covariant (`out` keyword), whereas the other generic type parameters are contravariant (`in` keyword).</span></span>  
  
 <span data-ttu-id="6d9bc-168">下列程式碼會說明這一點。</span><span class="sxs-lookup"><span data-stu-id="6d9bc-168">The following code illustrates this.</span></span> <span data-ttu-id="6d9bc-169">程式碼的第一段會定義名為 `Base`的類別、繼承 `Derived` 的 `Base`類別，和另一個具有 `static` 方法 (在 Visual Basic 中則為`Shared` 方法) 的 `MyMethod`類別。</span><span class="sxs-lookup"><span data-stu-id="6d9bc-169">The first piece of code defines a class named `Base`, a class named `Derived` that inherits `Base`, and another class with a `static` method (`Shared` in Visual Basic) named `MyMethod`.</span></span> <span data-ttu-id="6d9bc-170">這個方法會接受 `Base` 的執行個體，然後傳回 `Derived`的執行個體</span><span class="sxs-lookup"><span data-stu-id="6d9bc-170">The method takes an instance of `Base` and returns an instance of `Derived`.</span></span> <span data-ttu-id="6d9bc-171"> (如果引數為的實例 `Derived` ，就會傳回 `MyMethod` 它; 如果引數是的實例，就會傳回的 `Base` `MyMethod` 新實例 `Derived` 。 ) 在中 `Main()` ，此範例會在 `Func<Base, Derived>` 代表的 Visual Basic) 中建立 (的實例，並將 `Func(Of Base, Derived)` `MyMethod` 它儲存在變數中 `f1` 。</span><span class="sxs-lookup"><span data-stu-id="6d9bc-171">(If the argument is an instance of `Derived`, `MyMethod` returns it; if the argument is an instance of `Base`, `MyMethod` returns a new instance of `Derived`.) In `Main()`, the example creates an instance of `Func<Base, Derived>` (`Func(Of Base, Derived)` in Visual Basic) that represents `MyMethod`, and stores it in the variable `f1`.</span></span>  
  
 [!code-csharp[CoContravarianceDelegates#2](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravariancedelegates/cs/example.cs#2)]
 [!code-vb[CoContravarianceDelegates#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravariancedelegates/vb/example.vb#2)]  
  
 <span data-ttu-id="6d9bc-172">程式碼的第二段顯示可以將委派指派給類型為 `Func<Base, Base>` (在 Visual Basic 中則為`Func(Of Base, Base)` ) 的變數，因為傳回類型是 Covariant。</span><span class="sxs-lookup"><span data-stu-id="6d9bc-172">The second piece of code shows that the delegate can be assigned to a variable of type `Func<Base, Base>` (`Func(Of Base, Base)` in Visual Basic), because the return type is covariant.</span></span>  
  
 [!code-csharp[CoContravarianceDelegates#3](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravariancedelegates/cs/example.cs#3)]
 [!code-vb[CoContravarianceDelegates#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravariancedelegates/vb/example.vb#3)]  
  
 <span data-ttu-id="6d9bc-173">程式碼的第三段顯示可以將委派指派給類型為 `Func<Derived, Derived>` (在 Visual Basic 中則為`Func(Of Derived, Derived)` ) 的變數，因為參數類型是 Contravariant。</span><span class="sxs-lookup"><span data-stu-id="6d9bc-173">The third piece of code shows that the delegate can be assigned to a variable of type `Func<Derived, Derived>` (`Func(Of Derived, Derived)` in Visual Basic), because the parameter type is contravariant.</span></span>  
  
 [!code-csharp[CoContravarianceDelegates#4](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravariancedelegates/cs/example.cs#4)]
 [!code-vb[CoContravarianceDelegates#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravariancedelegates/vb/example.vb#4)]  
  
 <span data-ttu-id="6d9bc-174">程式碼的最後一段顯示結合 Contravariant 參數類型與 Covariant 傳回類型的效果，即可將委派指派給類型為 `Func<Derived, Base>` (在 Visual Basic 中則為`Func(Of Derived, Base)` ) 的變數。</span><span class="sxs-lookup"><span data-stu-id="6d9bc-174">The final piece of code shows that the delegate can be assigned to a variable of type `Func<Derived, Base>` (`Func(Of Derived, Base)` in Visual Basic), combining the effects of the contravariant parameter type and the covariant return type.</span></span>  
  
 [!code-csharp[CoContravarianceDelegates#5](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravariancedelegates/cs/example.cs#5)]
 [!code-vb[CoContravarianceDelegates#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravariancedelegates/vb/example.vb#5)]  
  
### <a name="variance-in-non-generic-delegates"></a><span data-ttu-id="6d9bc-175">非泛型委派中的變異數</span><span class="sxs-lookup"><span data-stu-id="6d9bc-175">Variance in non-generic delegates</span></span>

 <span data-ttu-id="6d9bc-176">在上述的程式碼中，`MyMethod` 的簽章與建構的泛型委派 `Func<Base, Derived>` (在 Visual Basic 中則為 `Func(Of Base, Derived)`) 之簽章完全相符。</span><span class="sxs-lookup"><span data-stu-id="6d9bc-176">In the preceding code, the signature of `MyMethod` exactly matches the signature of the constructed generic delegate: `Func<Base, Derived>` (`Func(Of Base, Derived)` in Visual Basic).</span></span> <span data-ttu-id="6d9bc-177">這個範例顯示，只要所有委派類型都是從泛型委派類型 <xref:System.Func%602>建構的，即可將這個泛型委派儲存在具有衍生程度較大參數類型及衍生程度較小傳回類型的變數或方法參數中。</span><span class="sxs-lookup"><span data-stu-id="6d9bc-177">The example shows that this generic delegate can be stored in variables or method parameters that have more derived parameter types and less derived return types, as long as all the delegate types are constructed from the generic delegate type <xref:System.Func%602>.</span></span>  
  
 <span data-ttu-id="6d9bc-178">這一點很重要。</span><span class="sxs-lookup"><span data-stu-id="6d9bc-178">This is an important point.</span></span> <span data-ttu-id="6d9bc-179">泛型委派參數類型中的共變數和反變數效果類似於一般委派繫結中的共變數和反變數效果 (請參閱[委派中的變異數 (C# )](../../csharp/programming-guide/concepts/covariance-contravariance/variance-in-delegates.md) 和[委派中的變異數 (Visual Basic)](../../visual-basic/programming-guide/concepts/covariance-contravariance/variance-in-delegates.md))。</span><span class="sxs-lookup"><span data-stu-id="6d9bc-179">The effects of covariance and contravariance in the type parameters of generic delegates are similar to the effects of covariance and contravariance in ordinary delegate binding (see [Variance in Delegates (C#)](../../csharp/programming-guide/concepts/covariance-contravariance/variance-in-delegates.md) and [Variance in Delegates (Visual Basic)](../../visual-basic/programming-guide/concepts/covariance-contravariance/variance-in-delegates.md)).</span></span> <span data-ttu-id="6d9bc-180">不過，委派繫結中的變異數可以使用所有的委派類型，而不只是具有 Variant 型別參數的泛型委派類型。</span><span class="sxs-lookup"><span data-stu-id="6d9bc-180">However, variance in delegate binding works with all delegate types, not just with generic delegate types that have variant type parameters.</span></span> <span data-ttu-id="6d9bc-181">此外，委派繫結中的變異數可讓方法繫結至任何具有較嚴格參數類型及較不嚴格傳回類型的委派，而泛型委派的指派只適用於這兩種委派類型都是從相同泛型類型定義建構的情況。</span><span class="sxs-lookup"><span data-stu-id="6d9bc-181">Furthermore, variance in delegate binding enables a method to be bound to any delegate that has more restrictive parameter types and a less restrictive return type, whereas the assignment of generic delegates works only if both delegate types are constructed from the same generic type definition.</span></span>  
  
 <span data-ttu-id="6d9bc-182">在下列範例中，會說明委派繫結中的變異數與泛型類型參數中的變異數合併之效果。</span><span class="sxs-lookup"><span data-stu-id="6d9bc-182">The following example shows the combined effects of variance in delegate binding and variance in generic type parameters.</span></span> <span data-ttu-id="6d9bc-183">範例中定義包含三個類型的類型階層，其中衍生程度最小的是`Type1`，而最大的是`Type3`。</span><span class="sxs-lookup"><span data-stu-id="6d9bc-183">The example defines a type hierarchy that includes three types, from least derived (`Type1`) to most derived (`Type3`).</span></span> <span data-ttu-id="6d9bc-184">在一般委派繫結中，會使用變異數以將參數類型為 `Type1` 且傳回類型為 `Type3` 的方法繫結至參數類型為 `Type2` 且傳回類型為 `Type2`的泛型委派。</span><span class="sxs-lookup"><span data-stu-id="6d9bc-184">Variance in ordinary delegate binding is used to bind a method with a parameter type of `Type1` and a return type of `Type3` to a generic delegate with a parameter type of `Type2` and a return type of `Type2`.</span></span> <span data-ttu-id="6d9bc-185">然後，範例會使用泛型類型參數的共變數和反變數，將產生的泛型委派指派給另一個參數類型為 `Type3` 且傳回類型為 `Type1` 的泛型委派類型變數。</span><span class="sxs-lookup"><span data-stu-id="6d9bc-185">The resulting generic delegate is then assigned to another variable whose generic delegate type has a parameter of type `Type3` and a return type of `Type1`, using the covariance and contravariance of generic type parameters.</span></span> <span data-ttu-id="6d9bc-186">在第二項指派中，變數類型和委派類型都必須是從相同的泛型類型定義 (在本範例中為 <xref:System.Func%602>) 建構的。</span><span class="sxs-lookup"><span data-stu-id="6d9bc-186">The second assignment requires both the variable type and the delegate type to be constructed from the same generic type definition, in this case, <xref:System.Func%602>.</span></span>  
  
 [!code-csharp[CoContravarianceDelegatesGenRelaxed#1](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravariancedelegatesgenrelaxed/cs/example.cs#1)]
 [!code-vb[CoContravarianceDelegatesGenRelaxed#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravariancedelegatesgenrelaxed/vb/example.vb#1)]  

## <a name="define-variant-generic-interfaces-and-delegates"></a><span data-ttu-id="6d9bc-187">定義 variant 泛型介面和委派</span><span class="sxs-lookup"><span data-stu-id="6d9bc-187">Define variant generic interfaces and delegates</span></span>

<span data-ttu-id="6d9bc-188">Visual Basic 和 c # 都有關鍵詞，可讓您將介面和委派的泛型型別參數標示為協變數或逆變。</span><span class="sxs-lookup"><span data-stu-id="6d9bc-188">Visual Basic and C# have keywords that enable you to mark the generic type parameters of interfaces and delegates as covariant or contravariant.</span></span>
  
 <span data-ttu-id="6d9bc-189">`out`在 Visual Basic) 中，以關鍵字 (關鍵字標記的協變數型別參數 `Out` 。</span><span class="sxs-lookup"><span data-stu-id="6d9bc-189">A covariant type parameter is marked with the `out` keyword (`Out` keyword in Visual Basic).</span></span> <span data-ttu-id="6d9bc-190">您可以使用 Covariant 類型參數當做屬於介面之方法的傳回值，或當做委派的傳回類型。</span><span class="sxs-lookup"><span data-stu-id="6d9bc-190">You can use a covariant type parameter as the return value of a method that belongs to an interface, or as the return type of a delegate.</span></span> <span data-ttu-id="6d9bc-191">但是，您不能將 Covariant 類型參數當做介面方法的泛型類型條件約束使用。</span><span class="sxs-lookup"><span data-stu-id="6d9bc-191">You cannot use a covariant type parameter as a generic type constraint for interface methods.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="6d9bc-192">如果介面的方法具有泛型委派類型的參數，就可以使用介面類型的 Covariant 類型參數指定委派類型的 Contravariant 類型參數。</span><span class="sxs-lookup"><span data-stu-id="6d9bc-192">If a method of an interface has a parameter that is a generic delegate type, a covariant type parameter of the interface type can be used to specify a contravariant type parameter of the delegate type.</span></span>  
  
 <span data-ttu-id="6d9bc-193">`in`在 Visual Basic) 中，以關鍵字 (關鍵字標記的逆變型別參數 `In` 。</span><span class="sxs-lookup"><span data-stu-id="6d9bc-193">A contravariant type parameter is marked with the `in` keyword (`In` keyword in Visual Basic).</span></span> <span data-ttu-id="6d9bc-194">您可以使用 Contravariant 類型參數當做屬於介面之方法的參數類型，或當做委派的參數類型。</span><span class="sxs-lookup"><span data-stu-id="6d9bc-194">You can use a contravariant type parameter as the type of a parameter of a method that belongs to an interface, or as the type of a parameter of a delegate.</span></span> <span data-ttu-id="6d9bc-195">此外，您也可以將 Contravariant 類型參數當做介面方法的泛型類型條件約束使用。</span><span class="sxs-lookup"><span data-stu-id="6d9bc-195">You can use a contravariant type parameter as a generic type constraint for an interface method.</span></span>  
  
 <span data-ttu-id="6d9bc-196">只有介面類型和委派類型可以有 Variant 類型參數。</span><span class="sxs-lookup"><span data-stu-id="6d9bc-196">Only interface types and delegate types can have variant type parameters.</span></span> <span data-ttu-id="6d9bc-197">介面或委派類型可以同時具有 Covariant 和 Contravariant 類型參數。</span><span class="sxs-lookup"><span data-stu-id="6d9bc-197">An interface or delegate type can have both covariant and contravariant type parameters.</span></span>  
  
 <span data-ttu-id="6d9bc-198">Visual Basic 和 C# 不允許您違反使用 Covariant 和 Contravariant 類型參數的規則，也不允許您將 Covariant 和 Contravariant 附註加入至介面及委派以外類型的類型參數。</span><span class="sxs-lookup"><span data-stu-id="6d9bc-198">Visual Basic and C# do not allow you to violate the rules for using covariant and contravariant type parameters, or to add covariance and contravariance annotations to the type parameters of types other than interfaces and delegates.</span></span>
  
 <span data-ttu-id="6d9bc-199">如需詳細資訊與範例程式碼，請參閱[泛型介面中的變異數 (C#)](../../csharp/programming-guide/concepts/covariance-contravariance/variance-in-generic-interfaces.md) 和[泛型介面中的變異數 (Visual Basic)](../../visual-basic/programming-guide/concepts/covariance-contravariance/variance-in-generic-interfaces.md)。</span><span class="sxs-lookup"><span data-stu-id="6d9bc-199">For information and example code, see [Variance in Generic Interfaces (C#)](../../csharp/programming-guide/concepts/covariance-contravariance/variance-in-generic-interfaces.md) and [Variance in Generic Interfaces (Visual Basic)](../../visual-basic/programming-guide/concepts/covariance-contravariance/variance-in-generic-interfaces.md).</span></span>  

## <a name="list-of-types"></a><span data-ttu-id="6d9bc-200">類型清單</span><span class="sxs-lookup"><span data-stu-id="6d9bc-200">List of types</span></span>

<span data-ttu-id="6d9bc-201">下列介面和委派類型具有協變數和/或逆變型別參數。</span><span class="sxs-lookup"><span data-stu-id="6d9bc-201">The following interface and delegate types have covariant and/or contravariant type parameters.</span></span>  
  
|<span data-ttu-id="6d9bc-202">類型</span><span class="sxs-lookup"><span data-stu-id="6d9bc-202">Type</span></span>|<span data-ttu-id="6d9bc-203">Covariant 類型參數</span><span class="sxs-lookup"><span data-stu-id="6d9bc-203">Covariant type parameters</span></span>|<span data-ttu-id="6d9bc-204">Contravariant 類型參數</span><span class="sxs-lookup"><span data-stu-id="6d9bc-204">Contravariant type parameters</span></span>|  
|----------|-------------------------------|-----------------------------------|  
|<span data-ttu-id="6d9bc-205"><xref:System.Action%601> 到 <xref:System.Action%6016></span><span class="sxs-lookup"><span data-stu-id="6d9bc-205"><xref:System.Action%601> to <xref:System.Action%6016></span></span>||<span data-ttu-id="6d9bc-206">是</span><span class="sxs-lookup"><span data-stu-id="6d9bc-206">Yes</span></span>|  
|<xref:System.Comparison%601>||<span data-ttu-id="6d9bc-207">是</span><span class="sxs-lookup"><span data-stu-id="6d9bc-207">Yes</span></span>|  
|<xref:System.Converter%602>|<span data-ttu-id="6d9bc-208">是</span><span class="sxs-lookup"><span data-stu-id="6d9bc-208">Yes</span></span>|<span data-ttu-id="6d9bc-209">是</span><span class="sxs-lookup"><span data-stu-id="6d9bc-209">Yes</span></span>|  
|<xref:System.Func%601>|<span data-ttu-id="6d9bc-210">是</span><span class="sxs-lookup"><span data-stu-id="6d9bc-210">Yes</span></span>||  
|<span data-ttu-id="6d9bc-211"><xref:System.Func%602> 到 <xref:System.Func%6017></span><span class="sxs-lookup"><span data-stu-id="6d9bc-211"><xref:System.Func%602> to <xref:System.Func%6017></span></span>|<span data-ttu-id="6d9bc-212">是</span><span class="sxs-lookup"><span data-stu-id="6d9bc-212">Yes</span></span>|<span data-ttu-id="6d9bc-213">是</span><span class="sxs-lookup"><span data-stu-id="6d9bc-213">Yes</span></span>|  
|<xref:System.IComparable%601>||<span data-ttu-id="6d9bc-214">是</span><span class="sxs-lookup"><span data-stu-id="6d9bc-214">Yes</span></span>|  
|<xref:System.Predicate%601>||<span data-ttu-id="6d9bc-215">是</span><span class="sxs-lookup"><span data-stu-id="6d9bc-215">Yes</span></span>|  
|<xref:System.Collections.Generic.IComparer%601>||<span data-ttu-id="6d9bc-216">是</span><span class="sxs-lookup"><span data-stu-id="6d9bc-216">Yes</span></span>|  
|<xref:System.Collections.Generic.IEnumerable%601>|<span data-ttu-id="6d9bc-217">是</span><span class="sxs-lookup"><span data-stu-id="6d9bc-217">Yes</span></span>||  
|<xref:System.Collections.Generic.IEnumerator%601>|<span data-ttu-id="6d9bc-218">是</span><span class="sxs-lookup"><span data-stu-id="6d9bc-218">Yes</span></span>||  
|<xref:System.Collections.Generic.IEqualityComparer%601>||<span data-ttu-id="6d9bc-219">是</span><span class="sxs-lookup"><span data-stu-id="6d9bc-219">Yes</span></span>|  
|<xref:System.Linq.IGrouping%602>|<span data-ttu-id="6d9bc-220">是</span><span class="sxs-lookup"><span data-stu-id="6d9bc-220">Yes</span></span>||  
|<xref:System.Linq.IOrderedEnumerable%601>|<span data-ttu-id="6d9bc-221">是</span><span class="sxs-lookup"><span data-stu-id="6d9bc-221">Yes</span></span>||  
|<xref:System.Linq.IOrderedQueryable%601>|<span data-ttu-id="6d9bc-222">是</span><span class="sxs-lookup"><span data-stu-id="6d9bc-222">Yes</span></span>||  
|<xref:System.Linq.IQueryable%601>|<span data-ttu-id="6d9bc-223">是</span><span class="sxs-lookup"><span data-stu-id="6d9bc-223">Yes</span></span>||  
  
## <a name="see-also"></a><span data-ttu-id="6d9bc-224">另請參閱</span><span class="sxs-lookup"><span data-stu-id="6d9bc-224">See also</span></span>

- [<span data-ttu-id="6d9bc-225">共變數和反變數 (C#)</span><span class="sxs-lookup"><span data-stu-id="6d9bc-225">Covariance and Contravariance (C#)</span></span>](../../csharp/programming-guide/concepts/covariance-contravariance/index.md)
- [<span data-ttu-id="6d9bc-226">共變數和反變數 (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="6d9bc-226">Covariance and Contravariance (Visual Basic)</span></span>](../../visual-basic/programming-guide/concepts/covariance-contravariance/index.md)
- [<span data-ttu-id="6d9bc-227">委派中的差異 (C#)</span><span class="sxs-lookup"><span data-stu-id="6d9bc-227">Variance in Delegates (C#)</span></span>](../../csharp/programming-guide/concepts/covariance-contravariance/variance-in-delegates.md)
- [<span data-ttu-id="6d9bc-228">委派中的變異數 (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="6d9bc-228">Variance in Delegates (Visual Basic)</span></span>](../../visual-basic/programming-guide/concepts/covariance-contravariance/variance-in-delegates.md)
