---
title: 密碼編譯服務
description: 閱讀 .NET 支援的加密方法和做法總覽，例如 ClickOnce 資訊清單、Suite B & 新一代密碼編譯（CNG）支援。
ms.date: 03/30/2017
ms.technology: dotnet-standard
helpviewer_keywords:
- cryptography [.NET Framework]
- pattern of derived class inheritance
- digital signatures
- asymmetric cryptographic algorithms
- digital signatures, public-key systems
- public keys
- decryption [.NET Framework]
- private keys
- MAC algorithms
- cryptographic algorithms
- private keys, overview
- encryption [.NET Framework]
- security [.NET Framework], encryption
- cryptographic services
- symmetric cryptographic algorithms
- hash
- message authentication codes
- derived class inheritance
- cryptography [.NET Framework], about
- random number generation
ms.assetid: f96284bc-7b73-44b5-ac59-fac613ad09f8
ms.openlocfilehash: 701dce82669395743c884a613512bfadc06c91b3
ms.sourcegitcommit: cdb295dd1db589ce5169ac9ff096f01fd0c2da9d
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 06/09/2020
ms.locfileid: "84596328"
---
# <a name="cryptographic-services"></a><span data-ttu-id="45b38-103">密碼編譯服務</span><span class="sxs-lookup"><span data-stu-id="45b38-103">Cryptographic Services</span></span>

<span data-ttu-id="45b38-104">公用網路（例如網際網路）無法在兩實體之間提供一種可安全通訊的方式。</span><span class="sxs-lookup"><span data-stu-id="45b38-104">Public networks such as the Internet do not provide a means of secure communication between entities.</span></span> <span data-ttu-id="45b38-105">這類網路上的通訊很容易被人讀取，或是被未經授權的協力廠商所修改。</span><span class="sxs-lookup"><span data-stu-id="45b38-105">Communication over such networks is susceptible to being read or even modified by unauthorized third parties.</span></span> <span data-ttu-id="45b38-106">密碼編譯有助於保護資料不受人檢視，可提供一種方式來偵測資料是否已遭修改，比起其他非安全的通道，它有助提供安全的通訊方式。</span><span class="sxs-lookup"><span data-stu-id="45b38-106">Cryptography helps protect data from being viewed, provides ways to detect whether data has been modified, and helps provide a secure means of communication over otherwise nonsecure channels.</span></span> <span data-ttu-id="45b38-107">比方說，可以利用密碼編譯演算法來加密資料，並以加密的狀態傳送，而稍後由指定的一方解密資料。</span><span class="sxs-lookup"><span data-stu-id="45b38-107">For example, data can be encrypted by using a cryptographic algorithm, transmitted in an encrypted state, and later decrypted by the intended party.</span></span> <span data-ttu-id="45b38-108">假使第三方攔截到加密資料，也難以破解。</span><span class="sxs-lookup"><span data-stu-id="45b38-108">If a third party intercepts the encrypted data, it will be difficult to decipher.</span></span>

<span data-ttu-id="45b38-109">在 .NET Framework 中，在 <xref:System.Security.Cryptography?displayProperty=nameWithType> 類別的命名空間可為您管理許多密碼編譯的細節。</span><span class="sxs-lookup"><span data-stu-id="45b38-109">In the .NET Framework, the classes in the <xref:System.Security.Cryptography?displayProperty=nameWithType> namespace manage many details of cryptography for you.</span></span> <span data-ttu-id="45b38-110">其中某些類別是 Unmanaged Microsoft CryptoAPI 的包裝函式，其他則純粹是 Managed 實作。</span><span class="sxs-lookup"><span data-stu-id="45b38-110">Some are wrappers for the unmanaged Microsoft Cryptography API (CryptoAPI), while others are purely managed implementations.</span></span> <span data-ttu-id="45b38-111">您不用是加密專家才能使用這些類別。</span><span class="sxs-lookup"><span data-stu-id="45b38-111">You do not need to be an expert in cryptography to use these classes.</span></span> <span data-ttu-id="45b38-112">當您在其中一個加密演算法類別中建立新執行個體時，會自動產生金鑰以便於使用，而且預設屬性盡可能以安全為主。</span><span class="sxs-lookup"><span data-stu-id="45b38-112">When you create a new instance of one of the encryption algorithm classes, keys are autogenerated for ease of use, and default properties are as safe and secure as possible.</span></span>

<span data-ttu-id="45b38-113">本總覽提供 .NET Framework 支援的加密方法和做法的概要，包括 .NET Framework 3.5 中引進的 ClickOnce 資訊清單、Suite B 和新一代密碼編譯（CNG）支援。</span><span class="sxs-lookup"><span data-stu-id="45b38-113">This overview provides a synopsis of the encryption methods and practices supported by the .NET Framework, including the ClickOnce manifests, Suite B, and Cryptography Next Generation (CNG) support introduced in the .NET Framework 3.5.</span></span>

<span data-ttu-id="45b38-114">如需有關密碼編譯、Microsoft 服務、元件，以及可讓您新增密碼編譯安全性至應用程式之工具的相關資訊，請參閱此文件安全性之＜Win32 和 COM 開發＞一節。</span><span class="sxs-lookup"><span data-stu-id="45b38-114">For additional information about cryptography and about Microsoft services, components, and tools that enable you to add cryptographic security to your applications, see the Win32 and COM Development, Security section of this documentation.</span></span>

## <a name="cryptographic-primitives"></a><span data-ttu-id="45b38-115">密碼編譯基本類型</span><span class="sxs-lookup"><span data-stu-id="45b38-115">Cryptographic Primitives</span></span>

<span data-ttu-id="45b38-116">通常會使用密碼編譯情況是，兩方 (Alice 和 Bob) 透過不安全的通道通訊時。</span><span class="sxs-lookup"><span data-stu-id="45b38-116">In a typical situation where cryptography is used, two parties (Alice and Bob) communicate over a nonsecure channel.</span></span> <span data-ttu-id="45b38-117">Alice 和 Bob 想確保兩人間的通訊，不被可能正在接聽的任何人所理解。</span><span class="sxs-lookup"><span data-stu-id="45b38-117">Alice and Bob want to ensure that their communication remains incomprehensible by anyone who might be listening.</span></span> <span data-ttu-id="45b38-118">不僅如此，由於 Alice 和 Bob 兩人身處遠端，Alice 必須確保在傳輸期間，她所接收到來自 Bob 的資訊未被任何人竄改。</span><span class="sxs-lookup"><span data-stu-id="45b38-118">Furthermore, because Alice and Bob are in remote locations, Alice must make sure that the information she receives from Bob has not been modified by anyone during transmission.</span></span> <span data-ttu-id="45b38-119">此外，她必須確保資訊的確來自 Bob，而非假扮成他的人。</span><span class="sxs-lookup"><span data-stu-id="45b38-119">In addition, she must make sure that the information really does originate from Bob and not from someone who is impersonating Bob.</span></span>

<span data-ttu-id="45b38-120">密碼編譯的用途為達成下列目標：</span><span class="sxs-lookup"><span data-stu-id="45b38-120">Cryptography is used to achieve the following goals:</span></span>

- <span data-ttu-id="45b38-121">機密性：協助保護使用者的身分或資料不被他人讀取。</span><span class="sxs-lookup"><span data-stu-id="45b38-121">Confidentiality: To help protect a user's identity or data from being read.</span></span>

- <span data-ttu-id="45b38-122">資料完整性：協助保護資料不遭人變更。</span><span class="sxs-lookup"><span data-stu-id="45b38-122">Data integrity: To help protect data from being changed.</span></span>

- <span data-ttu-id="45b38-123">驗證：確保資料來自特定對象。</span><span class="sxs-lookup"><span data-stu-id="45b38-123">Authentication: To ensure that data originates from a particular party.</span></span>

- <span data-ttu-id="45b38-124">不可否認性：防止特定對象否認自己曾傳送訊息。</span><span class="sxs-lookup"><span data-stu-id="45b38-124">Non-repudiation: To prevent a particular party from denying that they sent a message.</span></span>

<span data-ttu-id="45b38-125">若要達成這些目標，您可以將演算法與稱為密碼編譯基本類型的做法搭配組合，以創造密碼編譯的配置。</span><span class="sxs-lookup"><span data-stu-id="45b38-125">To achieve these goals, you can use a combination of algorithms and practices known as cryptographic primitives to create a cryptographic scheme.</span></span> <span data-ttu-id="45b38-126">下表列出密碼編譯基本類型以及它們的用法。</span><span class="sxs-lookup"><span data-stu-id="45b38-126">The following table lists the cryptographic primitives and their uses.</span></span>

|<span data-ttu-id="45b38-127">密碼編譯基本類型</span><span class="sxs-lookup"><span data-stu-id="45b38-127">Cryptographic primitive</span></span>|<span data-ttu-id="45b38-128">使用</span><span class="sxs-lookup"><span data-stu-id="45b38-128">Use</span></span>|
|-----------------------------|---------|
|<span data-ttu-id="45b38-129">私密金鑰加密 (對稱密碼編譯)</span><span class="sxs-lookup"><span data-stu-id="45b38-129">Secret-key encryption (symmetric cryptography)</span></span>|<span data-ttu-id="45b38-130">執行資料轉換，以防止第三方讀取。</span><span class="sxs-lookup"><span data-stu-id="45b38-130">Performs a transformation on data to keep it from being read by third parties.</span></span> <span data-ttu-id="45b38-131">這類加密使用單一共用的私密金鑰來加密和解密資料。</span><span class="sxs-lookup"><span data-stu-id="45b38-131">This type of encryption uses a single shared, secret key to encrypt and decrypt data.</span></span>|
|<span data-ttu-id="45b38-132">公開金鑰加密 (非對稱密碼編譯)</span><span class="sxs-lookup"><span data-stu-id="45b38-132">Public-key encryption (asymmetric cryptography)</span></span>|<span data-ttu-id="45b38-133">執行資料轉換，以防止第三方讀取。</span><span class="sxs-lookup"><span data-stu-id="45b38-133">Performs a transformation on data to keep it from being read by third parties.</span></span> <span data-ttu-id="45b38-134">這類加密使用公開/私密金鑰組來加密和解密資料。</span><span class="sxs-lookup"><span data-stu-id="45b38-134">This type of encryption uses a public/private key pair to encrypt and decrypt data.</span></span>|
|<span data-ttu-id="45b38-135">密碼編譯簽署</span><span class="sxs-lookup"><span data-stu-id="45b38-135">Cryptographic signing</span></span>|<span data-ttu-id="45b38-136">可以透過專屬於該對象數位簽章，確認資料來自特定對象。</span><span class="sxs-lookup"><span data-stu-id="45b38-136">Helps verify that data originates from a specific party by creating a digital signature that is unique to that party.</span></span> <span data-ttu-id="45b38-137">此程序也會使用雜湊函式。</span><span class="sxs-lookup"><span data-stu-id="45b38-137">This process also uses hash functions.</span></span>|
|<span data-ttu-id="45b38-138">密碼編譯雜湊</span><span class="sxs-lookup"><span data-stu-id="45b38-138">Cryptographic hashes</span></span>|<span data-ttu-id="45b38-139">將資料從任何長度對應至固定長度的位元組序列。</span><span class="sxs-lookup"><span data-stu-id="45b38-139">Maps data from any length to a fixed-length byte sequence.</span></span> <span data-ttu-id="45b38-140">雜湊是統計上唯一一種不同兩個位元組序列，而且不會出現相同值的雜湊。</span><span class="sxs-lookup"><span data-stu-id="45b38-140">Hashes are statistically unique; a different two-byte sequence will not hash to the same value.</span></span>|

## <a name="secret-key-encryption"></a><span data-ttu-id="45b38-141">私密金鑰加密</span><span class="sxs-lookup"><span data-stu-id="45b38-141">Secret-Key Encryption</span></span>

<span data-ttu-id="45b38-142">私密金鑰加密演算法使用單一私密金鑰來加密或解密資料。</span><span class="sxs-lookup"><span data-stu-id="45b38-142">Secret-key encryption algorithms use a single secret key to encrypt and decrypt data.</span></span> <span data-ttu-id="45b38-143">您必須確認未經授權的代理程式無法存取金鑰，因為任何具有金鑰的一方可用它來解密您的資料或加密自己的資料，並宣告資料來自於您。</span><span class="sxs-lookup"><span data-stu-id="45b38-143">You must secure the key from access by unauthorized agents, because any party that has the key can use it to decrypt your data or encrypt their own data, claiming it originated from you.</span></span>

<span data-ttu-id="45b38-144">私密金鑰加密也稱為對稱式加密，因為加密和解密可用相同的金鑰。</span><span class="sxs-lookup"><span data-stu-id="45b38-144">Secret-key encryption is also referred to as symmetric encryption because the same key is used for encryption and decryption.</span></span> <span data-ttu-id="45b38-145">相較於公開金鑰演算法，秘密金鑰加密演算法十分迅速，並且適用於執行大型流量資料的密碼編譯轉換。</span><span class="sxs-lookup"><span data-stu-id="45b38-145">Secret-key encryption algorithms are very fast (compared with public-key algorithms) and are well suited for performing cryptographic transformations on large streams of data.</span></span> <span data-ttu-id="45b38-146">例如 RSA 的非對稱式加密演算法，在多少資料可以加密的數學相關方面則受到限制。</span><span class="sxs-lookup"><span data-stu-id="45b38-146">Asymmetric encryption algorithms such as RSA are limited mathematically in how much data they can encrypt.</span></span> <span data-ttu-id="45b38-147">對稱式加密演算法通常不具備這些問題。</span><span class="sxs-lookup"><span data-stu-id="45b38-147">Symmetric encryption algorithms do not generally have those problems.</span></span>

<span data-ttu-id="45b38-148">一種稱為區塊編碼器的私密金鑰演算法，可用來一次加密一個資料區塊。</span><span class="sxs-lookup"><span data-stu-id="45b38-148">A type of secret-key algorithm called a block cipher is used to encrypt one block of data at a time.</span></span> <span data-ttu-id="45b38-149">像是資料加密標準 (DES)、TripleDES、進階加密標準 (AES) 這類區塊編碼器，會以密碼編譯方式將 *n* 個位元組的輸入區塊轉換成加密位元組輸出區塊。</span><span class="sxs-lookup"><span data-stu-id="45b38-149">Block ciphers such as Data Encryption Standard (DES), TripleDES, and Advanced Encryption Standard (AES) cryptographically transform an input block of *n* bytes into an output block of encrypted bytes.</span></span> <span data-ttu-id="45b38-150">如果您想要加密或解密位元組序列，就必以區塊為單位進行。</span><span class="sxs-lookup"><span data-stu-id="45b38-150">If you want to encrypt or decrypt a sequence of bytes, you have to do it block by block.</span></span> <span data-ttu-id="45b38-151">因為 *n* 很小 (DES 和 TripleDES 為 8 個位元組；AES 為 16 個位元組 [預設值]、24 個位元組或 32 個位元組)，所以大於 *n* 的資料值必須一次以一個區塊為單位加密。</span><span class="sxs-lookup"><span data-stu-id="45b38-151">Because *n* is small (8 bytes for DES and TripleDES; 16 bytes [the default], 24 bytes, or 32 bytes for AES), data values that are larger than *n* have to be encrypted one block at a time.</span></span> <span data-ttu-id="45b38-152">資料值小於 *n* 必須展開成 *n* 以便進行處理。</span><span class="sxs-lookup"><span data-stu-id="45b38-152">Data values that are smaller than *n* have to be expanded to *n* in order to be processed.</span></span>

<span data-ttu-id="45b38-153">有一種簡易的區塊編碼器型式，稱為電子碼書 (ECB) 模式。</span><span class="sxs-lookup"><span data-stu-id="45b38-153">One simple form of block cipher is called the electronic codebook (ECB) mode.</span></span> <span data-ttu-id="45b38-154">ECB 模式並不算安全，因為它不會使用初始化向量來初始化第一個純文字區塊。</span><span class="sxs-lookup"><span data-stu-id="45b38-154">ECB mode is not considered secure, because it does not use an initialization vector to initialize the first plaintext block.</span></span> <span data-ttu-id="45b38-155">對於某個指定的私密金鑰 *k*，不使用初始化向量的簡單區塊編碼器會將同一個純文字輸入區塊加密成同一個加密文字輸出區塊。</span><span class="sxs-lookup"><span data-stu-id="45b38-155">For a given secret key *k*, a simple block cipher that does not use an initialization vector will encrypt the same input block of plaintext into the same output block of ciphertext.</span></span> <span data-ttu-id="45b38-156">因此，如果您的輸入純文字資料流中有重複的區塊，在輸出加密文字資料流中也會有重複區塊。</span><span class="sxs-lookup"><span data-stu-id="45b38-156">Therefore, if you have duplicate blocks in your input plaintext stream, you will have duplicate blocks in your output ciphertext stream.</span></span> <span data-ttu-id="45b38-157">這些重複的輸出區塊會警示未經授權的使用者，可能已採用弱式加密之演算法，以及可能的攻擊模式。</span><span class="sxs-lookup"><span data-stu-id="45b38-157">These duplicate output blocks alert unauthorized users to the weak encryption used the algorithms that might have been employed, and the possible modes of attack.</span></span> <span data-ttu-id="45b38-158">因此 ECB Cipher 模式比較容易對分析，以及最終的金鑰探索受到攻擊。</span><span class="sxs-lookup"><span data-stu-id="45b38-158">The ECB cipher mode is therefore quite vulnerable to analysis, and ultimately, key discovery.</span></span>

<span data-ttu-id="45b38-159">在基底類別程式庫中提供的的區塊編碼器類別會使用稱為 Cipher 區塊鏈結 (CBC) 的預設鏈結模式，但是若您想變更，也可以變更此預設值。</span><span class="sxs-lookup"><span data-stu-id="45b38-159">The block cipher classes that are provided in the base class library use a default chaining mode called cipher-block chaining (CBC), although you can change this default if you want.</span></span>

<span data-ttu-id="45b38-160">CBC 加密使用初始化向量 (IV) 來加密純文字的第一個區塊，克服了與 ECB 加密相關的問題。</span><span class="sxs-lookup"><span data-stu-id="45b38-160">CBC ciphers overcome the problems associated with ECB ciphers by using an initialization vector (IV) to encrypt the first block of plaintext.</span></span> <span data-ttu-id="45b38-161">每個後續純文字區塊會經歷位元互斥，或是 (`XOR`) 在加密前與先前的加密文字區塊作業。</span><span class="sxs-lookup"><span data-stu-id="45b38-161">Each subsequent block of plaintext undergoes a bitwise exclusive OR (`XOR`) operation with the previous ciphertext block before it is encrypted.</span></span> <span data-ttu-id="45b38-162">因此每個加密文字區塊都會與先前的所有區塊相依。</span><span class="sxs-lookup"><span data-stu-id="45b38-162">Each ciphertext block is therefore dependent on all previous blocks.</span></span> <span data-ttu-id="45b38-163">當使用此系統時，可能會讓未授權使用者知道的通用訊息標頭，不能用來在金鑰上進行反向工程。</span><span class="sxs-lookup"><span data-stu-id="45b38-163">When this system is used, common message headers that might be known to an unauthorized user cannot be used to reverse-engineer a key.</span></span>

<span data-ttu-id="45b38-164">可能危及 CBC 加密資料的一種方法是徹底搜索每種可能的金鑰。</span><span class="sxs-lookup"><span data-stu-id="45b38-164">One way to compromise data that is encrypted with a CBC cipher is to perform an exhaustive search of every possible key.</span></span> <span data-ttu-id="45b38-165">依據用來執行加密的金鑰大小而定，即使使用最迅速的電腦，這種搜尋仍然非常耗時，因此並不可行。</span><span class="sxs-lookup"><span data-stu-id="45b38-165">Depending on the size of the key that is used to perform encryption, this kind of search is very time-consuming using even the fastest computers and is therefore infeasible.</span></span> <span data-ttu-id="45b38-166">較大的金鑰會更難破解。</span><span class="sxs-lookup"><span data-stu-id="45b38-166">Larger key sizes are more difficult to decipher.</span></span> <span data-ttu-id="45b38-167">雖然理論上加密並非可讓對手完全無法擷取加密的資料，但是它卻會增加擷取資料的成本。</span><span class="sxs-lookup"><span data-stu-id="45b38-167">Although encryption does not make it theoretically impossible for an adversary to retrieve the encrypted data, it does raise the cost of doing this.</span></span> <span data-ttu-id="45b38-168">如果需要花三個月的時間執行徹底搜尋，卻只擷取到在幾天內才具有意義的資料，則徹底搜尋就變得不切實際。</span><span class="sxs-lookup"><span data-stu-id="45b38-168">If it takes three months to perform an exhaustive search to retrieve data that is meaningful only for a few days, the exhaustive search method is impractical.</span></span>

<span data-ttu-id="45b38-169">私密金鑰加密的缺點是，它假設兩方都已同意一個金鑰與 IV，並且通訊過其值。</span><span class="sxs-lookup"><span data-stu-id="45b38-169">The disadvantage of secret-key encryption is that it presumes two parties have agreed on a key and IV, and communicated their values.</span></span> <span data-ttu-id="45b38-170">IV 不算是機密，而且能用訊息以純文字傳輸。</span><span class="sxs-lookup"><span data-stu-id="45b38-170">The IV is not considered a secret and can be transmitted in plaintext with the message.</span></span> <span data-ttu-id="45b38-171">不過，金鑰必須保持機密，不可讓未授權使用者知道。</span><span class="sxs-lookup"><span data-stu-id="45b38-171">However, the key must be kept secret from unauthorized users.</span></span> <span data-ttu-id="45b38-172">由於這些問題，私密金鑰加密通常會與公開金鑰加密搭配使用，以利私下通訊金鑰和 IV 的值。</span><span class="sxs-lookup"><span data-stu-id="45b38-172">Because of these problems, secret-key encryption is often used together with public-key encryption to privately communicate the values of the key and IV.</span></span>

<span data-ttu-id="45b38-173">假設 Alice 和 Bob 是想要透過非安全通道進行通訊的兩方，它們可使用私密金鑰加密，如下所示：Alice 和 Bob 同意將特定金鑰和特定 IV 與一種特定演算法 (例如 AES) 搭配使用。</span><span class="sxs-lookup"><span data-stu-id="45b38-173">Assuming that Alice and Bob are two parties who want to communicate over a nonsecure channel, they might use secret-key encryption as follows: Alice and Bob agree to use one particular algorithm (AES, for example) with a particular key and IV.</span></span> <span data-ttu-id="45b38-174">Alice 撰寫一則訊息，並建立要傳送訊息的網路串流（可能是具名管道或網路電子郵件）。</span><span class="sxs-lookup"><span data-stu-id="45b38-174">Alice composes a message and creates a network stream (perhaps a named pipe or network email) on which to send the message.</span></span> <span data-ttu-id="45b38-175">接下來，她使用金鑰和 IV 將文字加密，並透過內部網路傳送加密訊息和 IV 給 Bob。</span><span class="sxs-lookup"><span data-stu-id="45b38-175">Next, she encrypts the text using the key and IV, and sends the encrypted message and IV to Bob over the intranet.</span></span> <span data-ttu-id="45b38-176">Bob 收到加密文字，並使用該 IV 和先前同意的金鑰解密文字。</span><span class="sxs-lookup"><span data-stu-id="45b38-176">Bob receives the encrypted text and decrypts it by using the IV and previously agreed upon key.</span></span> <span data-ttu-id="45b38-177">如果傳輸遭到攔截，攔截器就無法復原原始訊息，因為它們不知道金鑰。</span><span class="sxs-lookup"><span data-stu-id="45b38-177">If the transmission is intercepted, the interceptor cannot recover the original message, because they do not know the key.</span></span> <span data-ttu-id="45b38-178">在此案例中，要保持機密的僅有金鑰。</span><span class="sxs-lookup"><span data-stu-id="45b38-178">In this scenario, only the key must remain secret.</span></span> <span data-ttu-id="45b38-179">在真實案例中，Alice 或 Bob 兩方都沒有產生私密金鑰，而是使用公開金鑰 (非對稱式) 加密來傳輸私密 (對稱) 金鑰至其他對象。</span><span class="sxs-lookup"><span data-stu-id="45b38-179">In a real world scenario, either Alice or Bob generates a secret key and uses public-key (asymmetric) encryption to transfer the secret (symmetric) key to the other party.</span></span> <span data-ttu-id="45b38-180">(如需公開金鑰加密的詳細資訊，請參閱下一節)。</span><span class="sxs-lookup"><span data-stu-id="45b38-180">For more information about public-key encryption, see the next section.</span></span>

<span data-ttu-id="45b38-181">.NET Framework 提供下列可執行秘密金鑰加密演算法的類別：</span><span class="sxs-lookup"><span data-stu-id="45b38-181">The .NET Framework provides the following classes that implement secret-key encryption algorithms:</span></span>

- <span data-ttu-id="45b38-182"><xref:System.Security.Cryptography.AesManaged>（在 .NET Framework 3.5 中引進）。</span><span class="sxs-lookup"><span data-stu-id="45b38-182"><xref:System.Security.Cryptography.AesManaged> (introduced in the .NET Framework 3.5).</span></span>

- <span data-ttu-id="45b38-183"><xref:System.Security.Cryptography.DESCryptoServiceProvider>.</span><span class="sxs-lookup"><span data-stu-id="45b38-183"><xref:System.Security.Cryptography.DESCryptoServiceProvider>.</span></span>

- <span data-ttu-id="45b38-184"><xref:System.Security.Cryptography.HMACSHA1> (技術上算是秘密金鑰演算法，因為它代表使用結合私密金鑰的加密編譯雜湊函式所計算出的訊息驗證碼。</span><span class="sxs-lookup"><span data-stu-id="45b38-184"><xref:System.Security.Cryptography.HMACSHA1> (This is technically a secret-key algorithm because it represents message authentication code that is calculated by using a cryptographic hash function combined with a secret key.</span></span> <span data-ttu-id="45b38-185">請參閱本主題稍後的 [雜湊值](#hash-values))</span><span class="sxs-lookup"><span data-stu-id="45b38-185">See [Hash Values](#hash-values), later in this topic.)</span></span>

- <span data-ttu-id="45b38-186"><xref:System.Security.Cryptography.RC2CryptoServiceProvider>.</span><span class="sxs-lookup"><span data-stu-id="45b38-186"><xref:System.Security.Cryptography.RC2CryptoServiceProvider>.</span></span>

- <span data-ttu-id="45b38-187"><xref:System.Security.Cryptography.RijndaelManaged>.</span><span class="sxs-lookup"><span data-stu-id="45b38-187"><xref:System.Security.Cryptography.RijndaelManaged>.</span></span>

- <span data-ttu-id="45b38-188"><xref:System.Security.Cryptography.TripleDESCryptoServiceProvider>.</span><span class="sxs-lookup"><span data-stu-id="45b38-188"><xref:System.Security.Cryptography.TripleDESCryptoServiceProvider>.</span></span>

## <a name="public-key-encryption"></a><span data-ttu-id="45b38-189">公開金鑰加密</span><span class="sxs-lookup"><span data-stu-id="45b38-189">Public-Key Encryption</span></span>

<span data-ttu-id="45b38-190">公開金鑰需要使用一個需對未授權使用者保持機密的私密金鑰，以及一個可以對任何人公開的公開金鑰。</span><span class="sxs-lookup"><span data-stu-id="45b38-190">Public-key encryption uses a private key that must be kept secret from unauthorized users and a public key that can be made public to anyone.</span></span> <span data-ttu-id="45b38-191">公開金鑰和私密金鑰以數學方式相連，以公開金鑰加密的資料只能用私密金鑰解密，而且以私密金鑰簽署的資料只能以公開金鑰驗證。</span><span class="sxs-lookup"><span data-stu-id="45b38-191">The public key and the private key are mathematically linked; data that is encrypted with the public key can be decrypted only with the private key, and data that is signed with the private key can be verified only with the public key.</span></span> <span data-ttu-id="45b38-192">公開金鑰可開放給任何人；它是用來加密要傳送給私密金鑰持有者的資料。</span><span class="sxs-lookup"><span data-stu-id="45b38-192">The public key can be made available to anyone; it is used for encrypting data to be sent to the keeper of the private key.</span></span> <span data-ttu-id="45b38-193">公開金鑰密碼編譯演算法也稱為非對稱演算法，因為一個金鑰需要用來加密資料，而另一個金鑰需要用來解密資料。</span><span class="sxs-lookup"><span data-stu-id="45b38-193">Public-key cryptographic algorithms are also known as asymmetric algorithms because one key is required to encrypt data, and another key is required to decrypt data.</span></span> <span data-ttu-id="45b38-194">基本密碼編譯規則禁止重複使用金鑰，而且每個通訊工作階段中應有專屬的兩個金鑰。</span><span class="sxs-lookup"><span data-stu-id="45b38-194">A basic cryptographic rule prohibits key reuse, and both keys should be unique for each communication session.</span></span> <span data-ttu-id="45b38-195">不過在實務上，非對稱金鑰通常存留較久。</span><span class="sxs-lookup"><span data-stu-id="45b38-195">However, in practice, asymmetric keys are generally long-lived.</span></span>

<span data-ttu-id="45b38-196">兩方 (Alice 和 Bob) 可能會使用公開金鑰加密，如下所示：首先 Alice 產生公開/私密金鑰組。</span><span class="sxs-lookup"><span data-stu-id="45b38-196">Two parties (Alice and Bob) might use public-key encryption as follows: First, Alice generates a public/private key pair.</span></span> <span data-ttu-id="45b38-197">如果 Bob 想要傳送 Alice 加密訊息，他會像她要求她的公開金鑰。</span><span class="sxs-lookup"><span data-stu-id="45b38-197">If Bob wants to send Alice an encrypted message, he asks her for her public key.</span></span> <span data-ttu-id="45b38-198">Alice 透過非安全的網路將公開金鑰傳送 Bob，他會使用這個金鑰來加密訊息。</span><span class="sxs-lookup"><span data-stu-id="45b38-198">Alice sends Bob her public key over a nonsecure network, and Bob uses this key to encrypt a message.</span></span> <span data-ttu-id="45b38-199">Bob 將加密訊息傳送給 Alice，然後她會使用自己的私密金鑰解密。</span><span class="sxs-lookup"><span data-stu-id="45b38-199">Bob sends the encrypted message to Alice, and she decrypts it by using her private key.</span></span> <span data-ttu-id="45b38-200">如果 Bob 透過非安全的通道收到 Alice 的金鑰，例如在公用網路，Bob 等於開放給攔截攻擊。</span><span class="sxs-lookup"><span data-stu-id="45b38-200">If Bob received Alice's key over a nonsecure channel, such as a public network, Bob is open to a man-in-the-middle attack.</span></span> <span data-ttu-id="45b38-201">因此，Bob 必須與 Alice 確認他有她的公開金鑰正確副本。</span><span class="sxs-lookup"><span data-stu-id="45b38-201">Therefore, Bob must verify with Alice that he has a correct copy of her public key.</span></span>

<span data-ttu-id="45b38-202">在 Alice 使用公開金鑰傳輸的過程中，未經授權的代理程式可能會攔截到此金鑰。</span><span class="sxs-lookup"><span data-stu-id="45b38-202">During the transmission of Alice's public key, an unauthorized agent might intercept the key.</span></span> <span data-ttu-id="45b38-203">此外，相同的代理程式可能會從 Bob 攔截到加密訊息。</span><span class="sxs-lookup"><span data-stu-id="45b38-203">Furthermore, the same agent might intercept the encrypted message from Bob.</span></span> <span data-ttu-id="45b38-204">不過，代理程式無法使用公開金鑰解密訊息。</span><span class="sxs-lookup"><span data-stu-id="45b38-204">However, the agent cannot decrypt the message with the public key.</span></span> <span data-ttu-id="45b38-205">若要解密訊息，只能搭配 Alice 未傳送的私用金鑰。</span><span class="sxs-lookup"><span data-stu-id="45b38-205">The message can be decrypted only with Alice's private key, which has not been transmitted.</span></span> <span data-ttu-id="45b38-206">Alice 並未使用她的私密金鑰來加密回覆訊息給 Bob，因為任何知道公開金鑰的人都能解密訊息。</span><span class="sxs-lookup"><span data-stu-id="45b38-206">Alice does not use her private key to encrypt a reply message to Bob, because anyone with the public key could decrypt the message.</span></span> <span data-ttu-id="45b38-207">如果 Alice 想要將訊息回傳給 Bob，她會向他要求他的公開金鑰，並用該公開金鑰加密她的訊息。</span><span class="sxs-lookup"><span data-stu-id="45b38-207">If Alice wants to send a message back to Bob, she asks Bob for his public key and encrypts her message using that public key.</span></span> <span data-ttu-id="45b38-208">然後 Bob 會使用他相關聯的私密金鑰解密訊息。</span><span class="sxs-lookup"><span data-stu-id="45b38-208">Bob then decrypts the message using his associated private key.</span></span>

<span data-ttu-id="45b38-209">在此案例中，Alice 和 Bob 使用公開金鑰 (非對稱) 加密来傳送私密 (對稱) 金鑰，並在工作階段的其餘部分使用私密金鑰加密。</span><span class="sxs-lookup"><span data-stu-id="45b38-209">In this scenario, Alice and Bob use public-key (asymmetric) encryption to transfer a secret (symmetric) key and use secret-key encryption for the remainder of their session.</span></span>

<span data-ttu-id="45b38-210">下列清單提供公開金鑰和私密金鑰密碼編譯演算法之間的比較：</span><span class="sxs-lookup"><span data-stu-id="45b38-210">The following list offers comparisons between public-key and secret-key cryptographic algorithms:</span></span>

- <span data-ttu-id="45b38-211">公開金鑰密碼編譯演算法會使用固定的緩衝區大小，而私密金鑰密碼編譯演算法使用可變長度的緩衝區。</span><span class="sxs-lookup"><span data-stu-id="45b38-211">Public-key cryptographic algorithms use a fixed buffer size, whereas secret-key cryptographic algorithms use a variable-length buffer.</span></span>

- <span data-ttu-id="45b38-212">公開金鑰演算法無法像私密金鑰演算法一樣，可將資料鏈結成資料流，因為只有小量資料可以被加密。</span><span class="sxs-lookup"><span data-stu-id="45b38-212">Public-key algorithms cannot be used to chain data together into streams the way secret-key algorithms can, because only small amounts of data can be encrypted.</span></span> <span data-ttu-id="45b38-213">因此，非對稱作業不像對稱作業一樣，可使用相同的資料流模型。</span><span class="sxs-lookup"><span data-stu-id="45b38-213">Therefore, asymmetric operations do not use the same streaming model as symmetric operations.</span></span>

- <span data-ttu-id="45b38-214">公開金鑰加密與私密金鑰加密相比，有一個較大的金鑰空間 (金鑰可能值的範圍)。</span><span class="sxs-lookup"><span data-stu-id="45b38-214">Public-key encryption has a much larger keyspace (range of possible values for the key) than secret-key encryption.</span></span> <span data-ttu-id="45b38-215">因此，公開金鑰加密較不易受到徹底搜索每個可能金鑰的攻擊。</span><span class="sxs-lookup"><span data-stu-id="45b38-215">Therefore, public-key encryption is less susceptible to exhaustive attacks that try every possible key.</span></span>

- <span data-ttu-id="45b38-216">公開金鑰不需要受到保護，所以可輕鬆地散發，前提是有已知方法來驗證寄件者。</span><span class="sxs-lookup"><span data-stu-id="45b38-216">Public keys are easy to distribute because they do not have to be secured, provided that some way exists to verify the identity of the sender.</span></span>

- <span data-ttu-id="45b38-217">有些公開金鑰演算法 (例如 RSA 和 DSA，但非 Diffie-hellman) 可用來建立數位簽章，以驗證資料寄件者的身份識別。</span><span class="sxs-lookup"><span data-stu-id="45b38-217">Some public-key algorithms (such as RSA and DSA, but not Diffie-Hellman) can be used to create digital signatures to verify the identity of the sender of data.</span></span>

- <span data-ttu-id="45b38-218">相較於私密金鑰演算法，公開金鑰演算法速度很慢，並非設計來加密大量資料。</span><span class="sxs-lookup"><span data-stu-id="45b38-218">Public-key algorithms are very slow compared with secret-key algorithms, and are not designed to encrypt large amounts of data.</span></span> <span data-ttu-id="45b38-219">公開金鑰演算法只適合傳送非常少量的資料。</span><span class="sxs-lookup"><span data-stu-id="45b38-219">Public-key algorithms are useful only for transferring very small amounts of data.</span></span> <span data-ttu-id="45b38-220">通常，公開金鑰加密是用來加密要使用私密金鑰演算法來加密的金鑰和 IV。</span><span class="sxs-lookup"><span data-stu-id="45b38-220">Typically, public-key encryption is used to encrypt a key and IV to be used by a secret-key algorithm.</span></span> <span data-ttu-id="45b38-221">金鑰和 IV 傳送之後，其餘的工作階段會使用私密金鑰加密。</span><span class="sxs-lookup"><span data-stu-id="45b38-221">After the key and IV are transferred, secret-key encryption is used for the remainder of the session.</span></span>

<span data-ttu-id="45b38-222">.NET Framework 提供下列執行公開金鑰加密演算法的類別：</span><span class="sxs-lookup"><span data-stu-id="45b38-222">The .NET Framework provides the following classes that implement public-key encryption algorithms:</span></span>

- <xref:System.Security.Cryptography.DSACryptoServiceProvider>

- <xref:System.Security.Cryptography.RSACryptoServiceProvider>

- <span data-ttu-id="45b38-223"><xref:System.Security.Cryptography.ECDiffieHellman> (基底類別)</span><span class="sxs-lookup"><span data-stu-id="45b38-223"><xref:System.Security.Cryptography.ECDiffieHellman> (base class)</span></span>

- <xref:System.Security.Cryptography.ECDiffieHellmanCng>

- <span data-ttu-id="45b38-224"><xref:System.Security.Cryptography.ECDiffieHellmanCngPublicKey> (基底類別)</span><span class="sxs-lookup"><span data-stu-id="45b38-224"><xref:System.Security.Cryptography.ECDiffieHellmanCngPublicKey> (base class)</span></span>

- <span data-ttu-id="45b38-225"><xref:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction> (基底類別)</span><span class="sxs-lookup"><span data-stu-id="45b38-225"><xref:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction> (base class)</span></span>

- <xref:System.Security.Cryptography.ECDsaCng>

<span data-ttu-id="45b38-226">RSA 允許加密和簽章，但是 DSA 只能用於簽章，而且 Diffie-hellman 僅用於產生金鑰。</span><span class="sxs-lookup"><span data-stu-id="45b38-226">RSA allows both encryption and signing, but DSA can be used only for signing, and Diffie-Hellman can be used only for key generation.</span></span> <span data-ttu-id="45b38-227">一般來說，公開金鑰演算法在用途上比私密金鑰演算法更受到限制。</span><span class="sxs-lookup"><span data-stu-id="45b38-227">In general, public-key algorithms are more limited in their uses than private-key algorithms.</span></span>

## <a name="digital-signatures"></a><span data-ttu-id="45b38-228">數位簽章</span><span class="sxs-lookup"><span data-stu-id="45b38-228">Digital Signatures</span></span>

<span data-ttu-id="45b38-229">公開金鑰演算法也可用於形成數位簽章。</span><span class="sxs-lookup"><span data-stu-id="45b38-229">Public-key algorithms can also be used to form digital signatures.</span></span> <span data-ttu-id="45b38-230">數位簽章驗證的寄件者的身份識別 (如果您信任該寄件者的公開金鑰)，並協助保護資料的完整性。</span><span class="sxs-lookup"><span data-stu-id="45b38-230">Digital signatures authenticate the identity of a sender (if you trust the sender's public key) and help protect the integrity of data.</span></span> <span data-ttu-id="45b38-231">使用 Alice 所產生的公開金鑰，Alice 資料的收件者可以藉由比較 Alice 資料與其公開金鑰的數位簽章，確認傳送者為 Alice。</span><span class="sxs-lookup"><span data-stu-id="45b38-231">Using a public key generated by Alice, the recipient of Alice's data can verify that Alice sent it by comparing the digital signature to Alice's data and Alice's public key.</span></span>

<span data-ttu-id="45b38-232">若要使用公開金鑰密碼編譯來數位簽署訊息，Alice 必須先在訊息中套用雜湊演算法來建立訊息摘要。</span><span class="sxs-lookup"><span data-stu-id="45b38-232">To use public-key cryptography to digitally sign a message, Alice first applies a hash algorithm to the message to create a message digest.</span></span> <span data-ttu-id="45b38-233">訊息摘要是資料壓縮和獨特的表示方式。</span><span class="sxs-lookup"><span data-stu-id="45b38-233">The message digest is a compact and unique representation of data.</span></span> <span data-ttu-id="45b38-234">Alice 接著會使用她的私密金鑰來建立個人簽章，並加密訊息摘要。</span><span class="sxs-lookup"><span data-stu-id="45b38-234">Alice then encrypts the message digest with her private key to create her personal signature.</span></span> <span data-ttu-id="45b38-235">收到訊息和簽章後，Bob 會使用 Alice 的公開金鑰來復原訊息摘要，並用與 Alice 所用的相同雜湊演算法來雜湊簽章。</span><span class="sxs-lookup"><span data-stu-id="45b38-235">Upon receiving the message and signature, Bob decrypts the signature using Alice's public key to recover the message digest and hashes the message using the same hash algorithm that Alice used.</span></span> <span data-ttu-id="45b38-236">如果 Bob 所計算的訊息摘要符合從 Alice 收到的訊息摘要，Bob 就可以確信訊息來自私密金鑰的擁有人，且資料未被修改。</span><span class="sxs-lookup"><span data-stu-id="45b38-236">If the message digest that Bob computes exactly matches the message digest received from Alice, Bob is assured that the message came from the possessor of the private key and that the data has not been modified.</span></span> <span data-ttu-id="45b38-237">如果 Bob 信任 Alice 就是私密金鑰的擁有人，他就知道訊息來自 Alice。</span><span class="sxs-lookup"><span data-stu-id="45b38-237">If Bob trusts that Alice is the possessor of the private key, he knows that the message came from Alice.</span></span>

> [!NOTE]
> <span data-ttu-id="45b38-238">任何人都可以驗證簽章，因為寄件者的公開金鑰是通用資訊，而且通常包含於數位簽章格式中。</span><span class="sxs-lookup"><span data-stu-id="45b38-238">A signature can be verified by anyone because the sender's public key is common knowledge and is typically included in the digital signature format.</span></span> <span data-ttu-id="45b38-239">此方法不保留訊息的機密性，對於需要保密的訊息，還是必須經過加密。</span><span class="sxs-lookup"><span data-stu-id="45b38-239">This method does not retain the secrecy of the message; for the message to be secret, it must also be encrypted.</span></span>

<span data-ttu-id="45b38-240">.NET Framework 提供下列可執行數位簽章演算法的類別：</span><span class="sxs-lookup"><span data-stu-id="45b38-240">The .NET Framework provides the following classes that implement digital signature algorithms:</span></span>

- <xref:System.Security.Cryptography.DSACryptoServiceProvider>

- <xref:System.Security.Cryptography.RSACryptoServiceProvider>

- <span data-ttu-id="45b38-241"><xref:System.Security.Cryptography.ECDsa> (基底類別)</span><span class="sxs-lookup"><span data-stu-id="45b38-241"><xref:System.Security.Cryptography.ECDsa> (base class)</span></span>

- <xref:System.Security.Cryptography.ECDsaCng>

## <a name="hash-values"></a><span data-ttu-id="45b38-242">雜湊值</span><span class="sxs-lookup"><span data-stu-id="45b38-242">Hash Values</span></span>

<span data-ttu-id="45b38-243">雜湊演算法會將任意長度的二進位值對應到固定長度較小的二進位值，又稱為雜湊值。</span><span class="sxs-lookup"><span data-stu-id="45b38-243">Hash algorithms map binary values of an arbitrary length to smaller binary values of a fixed length, known as hash values.</span></span> <span data-ttu-id="45b38-244">雜湊值是一段資料的數值表示法。</span><span class="sxs-lookup"><span data-stu-id="45b38-244">A hash value is a numerical representation of a piece of data.</span></span> <span data-ttu-id="45b38-245">如果您雜湊純文字段落，但只要變更了段落中的一個字母，後續的雜湊就會產生不同的值。</span><span class="sxs-lookup"><span data-stu-id="45b38-245">If you hash a paragraph of plaintext and change even one letter of the paragraph, a subsequent hash will produce a different value.</span></span> <span data-ttu-id="45b38-246">如果雜湊密碼編譯的強度夠強，其值將會大幅變更。</span><span class="sxs-lookup"><span data-stu-id="45b38-246">If the hash is cryptographically strong, its value will change significantly.</span></span> <span data-ttu-id="45b38-247">比方說，如果變更訊息的一小部份，強式雜湊函式可能會產生相異百分之 50 的輸出。</span><span class="sxs-lookup"><span data-stu-id="45b38-247">For example, if a single bit of a message is changed, a strong hash function may produce an output that differs by 50 percent.</span></span> <span data-ttu-id="45b38-248">許多輸入的值可雜湊出相同的輸出值。</span><span class="sxs-lookup"><span data-stu-id="45b38-248">Many input values may hash to the same output value.</span></span> <span data-ttu-id="45b38-249">不過，就運算資源而言，要找到兩個相異的輸入可雜湊處理至相同的值並不可行。</span><span class="sxs-lookup"><span data-stu-id="45b38-249">However, it is computationally infeasible to find two distinct inputs that hash to the same value.</span></span>

<span data-ttu-id="45b38-250">兩方 (Alice 和 Bob) 可以使用雜湊函式以確保訊息的完整性。</span><span class="sxs-lookup"><span data-stu-id="45b38-250">Two parties (Alice and Bob) could use a hash function to ensure message integrity.</span></span> <span data-ttu-id="45b38-251">他們會選取雜湊演算法來簽署其訊息。</span><span class="sxs-lookup"><span data-stu-id="45b38-251">They would select a hash algorithm to sign their messages.</span></span> <span data-ttu-id="45b38-252">Alice 會寫入訊息，並使用所選的演算法建立該訊息的雜湊。</span><span class="sxs-lookup"><span data-stu-id="45b38-252">Alice would write a message, and then create a hash of that message by using the selected algorithm.</span></span> <span data-ttu-id="45b38-253">接著他們會遵循下列方法之一：</span><span class="sxs-lookup"><span data-stu-id="45b38-253">They would then follow one of the following methods:</span></span>

- <span data-ttu-id="45b38-254">Alice 傳送純文字訊息和雜湊訊息 (數位簽章) 給 Bob。</span><span class="sxs-lookup"><span data-stu-id="45b38-254">Alice sends the plaintext message and the hashed message (digital signature) to Bob.</span></span> <span data-ttu-id="45b38-255">Bob 收到後雜湊該訊息，並將他從 Alice 接收到的雜湊值與自己的雜湊值相比較。</span><span class="sxs-lookup"><span data-stu-id="45b38-255">Bob receives and hashes the message and compares his hash value to the hash value that he received from Alice.</span></span> <span data-ttu-id="45b38-256">如果雜湊值完全相同，訊息未遭竄改。</span><span class="sxs-lookup"><span data-stu-id="45b38-256">If the hash values are identical, the message was not altered.</span></span> <span data-ttu-id="45b38-257">如果值不相同，則 Alice 撰寫訊息後已遭修改。</span><span class="sxs-lookup"><span data-stu-id="45b38-257">If the values are not identical, the message was altered after Alice wrote it.</span></span>

  <span data-ttu-id="45b38-258">可惜這個方法無法確認寄件者的真實性。</span><span class="sxs-lookup"><span data-stu-id="45b38-258">Unfortunately, this method does not establish the authenticity of the sender.</span></span> <span data-ttu-id="45b38-259">任何人都可以模擬 Alice 並傳送訊息給 Bob。</span><span class="sxs-lookup"><span data-stu-id="45b38-259">Anyone can impersonate Alice and send a message to Bob.</span></span> <span data-ttu-id="45b38-260">他們可以使用相同的雜湊演算法來簽署訊息，而且 Bob 只能用符合其簽章的訊息來判斷。</span><span class="sxs-lookup"><span data-stu-id="45b38-260">They can use the same hash algorithm to sign their message, and all Bob can determine is that the message matches its signature.</span></span> <span data-ttu-id="45b38-261">這是一種攔截攻擊的形式。</span><span class="sxs-lookup"><span data-stu-id="45b38-261">This is one form of a man-in-the-middle attack.</span></span> <span data-ttu-id="45b38-262">如需詳細資訊，請參閱[新一代密碼編譯（CNG）安全通訊範例](https://docs.microsoft.com/previous-versions/cc488018(v=vs.100))。</span><span class="sxs-lookup"><span data-stu-id="45b38-262">For more information, see [Cryptography Next Generation (CNG) Secure Communication Example](https://docs.microsoft.com/previous-versions/cc488018(v=vs.100)).</span></span>

- <span data-ttu-id="45b38-263">Alice 透過非安全的公用通道傳送純文字訊息給 Bob。</span><span class="sxs-lookup"><span data-stu-id="45b38-263">Alice sends the plaintext message to Bob over a nonsecure public channel.</span></span> <span data-ttu-id="45b38-264">Alice 透過安全的私用通道傳雜湊送息給 Bob。</span><span class="sxs-lookup"><span data-stu-id="45b38-264">She sends the hashed message to Bob over a secure private channel.</span></span> <span data-ttu-id="45b38-265">Bob 收到純文字訊息，然後進行雜湊，並將該雜湊與私下交換的雜湊相比。</span><span class="sxs-lookup"><span data-stu-id="45b38-265">Bob receives the plaintext message, hashes it, and compares the hash to the privately exchanged hash.</span></span> <span data-ttu-id="45b38-266">如果雜湊相符，Bob 就知道兩件事：</span><span class="sxs-lookup"><span data-stu-id="45b38-266">If the hashes match, Bob knows two things:</span></span>

  - <span data-ttu-id="45b38-267">訊息未經更改。</span><span class="sxs-lookup"><span data-stu-id="45b38-267">The message was not altered.</span></span>

  - <span data-ttu-id="45b38-268">寄件者的訊息 (Alice) 已經過驗證。</span><span class="sxs-lookup"><span data-stu-id="45b38-268">The sender of the message (Alice) is authentic.</span></span>

  <span data-ttu-id="45b38-269">若要讓此系統成功運作，Alice 必須對 Bob 除外的所有對象隱藏原始雜湊值。</span><span class="sxs-lookup"><span data-stu-id="45b38-269">For this system to work, Alice must hide her original hash value from all parties except Bob.</span></span>

- <span data-ttu-id="45b38-270">Alice 透過非安全的公用通道傳送純文字訊息給 Bob，並將已雜湊的訊息放在可讓人公開檢視的網站上。</span><span class="sxs-lookup"><span data-stu-id="45b38-270">Alice sends the plaintext message to Bob over a nonsecure public channel and places the hashed message on her publicly viewable Web site.</span></span>

  <span data-ttu-id="45b38-271">此方法藉由防止任何人修改雜湊值來預防訊息遭到竄改。</span><span class="sxs-lookup"><span data-stu-id="45b38-271">This method prevents message tampering by preventing anyone from modifying the hash value.</span></span> <span data-ttu-id="45b38-272">雖然任何人都可以讀取訊息和其雜湊，但是只有 Alice 可以變更雜湊值。</span><span class="sxs-lookup"><span data-stu-id="45b38-272">Although the message and its hash can be read by anyone, the hash value can be changed only by Alice.</span></span> <span data-ttu-id="45b38-273">若攻擊者想要模擬 Alice，就需要存取她的網站。</span><span class="sxs-lookup"><span data-stu-id="45b38-273">An attacker who wants to impersonate Alice would require access to Alice's Web site.</span></span>

<span data-ttu-id="45b38-274">先前的方法中，沒有一項能防止他人讀取 Alice 的訊息，因為它們會以純文字傳送。</span><span class="sxs-lookup"><span data-stu-id="45b38-274">None of the previous methods will prevent someone from reading Alice's messages, because they are transmitted in plaintext.</span></span> <span data-ttu-id="45b38-275">完整的安全性通常需有數位簽章和加密 (訊息簽章)。</span><span class="sxs-lookup"><span data-stu-id="45b38-275">Full security typically requires digital signatures (message signing) and encryption.</span></span>

<span data-ttu-id="45b38-276">.NET Framework 提供下列可執行雜湊演算法的類別：</span><span class="sxs-lookup"><span data-stu-id="45b38-276">The .NET Framework provides the following classes that implement hashing algorithms:</span></span>

- <span data-ttu-id="45b38-277"><xref:System.Security.Cryptography.HMACSHA1>.</span><span class="sxs-lookup"><span data-stu-id="45b38-277"><xref:System.Security.Cryptography.HMACSHA1>.</span></span>

- <span data-ttu-id="45b38-278"><xref:System.Security.Cryptography.MACTripleDES>.</span><span class="sxs-lookup"><span data-stu-id="45b38-278"><xref:System.Security.Cryptography.MACTripleDES>.</span></span>

- <span data-ttu-id="45b38-279"><xref:System.Security.Cryptography.MD5CryptoServiceProvider>.</span><span class="sxs-lookup"><span data-stu-id="45b38-279"><xref:System.Security.Cryptography.MD5CryptoServiceProvider>.</span></span>

- <span data-ttu-id="45b38-280"><xref:System.Security.Cryptography.RIPEMD160>.</span><span class="sxs-lookup"><span data-stu-id="45b38-280"><xref:System.Security.Cryptography.RIPEMD160>.</span></span>

- <span data-ttu-id="45b38-281"><xref:System.Security.Cryptography.SHA1Managed>.</span><span class="sxs-lookup"><span data-stu-id="45b38-281"><xref:System.Security.Cryptography.SHA1Managed>.</span></span>

- <span data-ttu-id="45b38-282"><xref:System.Security.Cryptography.SHA256Managed>.</span><span class="sxs-lookup"><span data-stu-id="45b38-282"><xref:System.Security.Cryptography.SHA256Managed>.</span></span>

- <span data-ttu-id="45b38-283"><xref:System.Security.Cryptography.SHA384Managed>.</span><span class="sxs-lookup"><span data-stu-id="45b38-283"><xref:System.Security.Cryptography.SHA384Managed>.</span></span>

- <span data-ttu-id="45b38-284"><xref:System.Security.Cryptography.SHA512Managed>.</span><span class="sxs-lookup"><span data-stu-id="45b38-284"><xref:System.Security.Cryptography.SHA512Managed>.</span></span>

- <span data-ttu-id="45b38-285">所有安全雜湊演算法 (SHA) 的 HMAC 變數，訊息摘要 5 (MD5) 和 RIPEMD-160 演算法。</span><span class="sxs-lookup"><span data-stu-id="45b38-285">HMAC variants of all of the Secure Hash Algorithm (SHA), Message Digest 5 (MD5), and RIPEMD-160 algorithms.</span></span>

- <span data-ttu-id="45b38-286">所有 SHA 演算法的 CryptoServiceProvider 實作 (Managed 程式碼包裝函式)。</span><span class="sxs-lookup"><span data-stu-id="45b38-286">CryptoServiceProvider implementations (managed code wrappers) of all the SHA algorithms.</span></span>

- <span data-ttu-id="45b38-287">所有 MD5 與 SHA 演算法的新一代密碼編譯 (CNG) 實作。</span><span class="sxs-lookup"><span data-stu-id="45b38-287">Cryptography Next Generation (CNG) implementations of all the MD5 and SHA algorithms.</span></span>

> [!NOTE]
> <span data-ttu-id="45b38-288">1996 年中發現了 MD5 設計的缺陷，並已建議改用 SHA-1。</span><span class="sxs-lookup"><span data-stu-id="45b38-288">MD5 design flaws were discovered in 1996, and SHA-1 was recommended instead.</span></span> <span data-ttu-id="45b38-289">在 2004 年又發現其他缺陷，因此不再將 MD5 演算法視為安全。</span><span class="sxs-lookup"><span data-stu-id="45b38-289">In 2004, additional flaws were discovered, and the MD5 algorithm is no longer considered secure.</span></span> <span data-ttu-id="45b38-290">SHA-1 演算法也被發現具有危險性，目前建議改用 SHA-2。</span><span class="sxs-lookup"><span data-stu-id="45b38-290">The SHA-1 algorithm has also been found to be insecure, and SHA-2 is now recommended instead.</span></span>

## <a name="random-number-generation"></a><span data-ttu-id="45b38-291">產生變數</span><span class="sxs-lookup"><span data-stu-id="45b38-291">Random Number Generation</span></span>

<span data-ttu-id="45b38-292">對許多密碼編譯作業而言，亂數產生是不可或缺的項目。</span><span class="sxs-lookup"><span data-stu-id="45b38-292">Random number generation is integral to many cryptographic operations.</span></span> <span data-ttu-id="45b38-293">例如，密碼編譯金鑰需要盡可能為隨機產生，以致於其他人無法重現金鑰。</span><span class="sxs-lookup"><span data-stu-id="45b38-293">For example, cryptographic keys need to be as random as possible so that it is infeasible to reproduce them.</span></span> <span data-ttu-id="45b38-294">密碼編譯亂數產生器需產生在運算資源上，無法預測的機率必須大於一半之輸出。</span><span class="sxs-lookup"><span data-stu-id="45b38-294">Cryptographic random number generators must generate output that is computationally infeasible to predict with a probability that is better than one half.</span></span> <span data-ttu-id="45b38-295">因此，任何預測下一個輸出位元的方法，必須不能優於隨機猜測的方式。</span><span class="sxs-lookup"><span data-stu-id="45b38-295">Therefore, any method of predicting the next output bit must not perform better than random guessing.</span></span> <span data-ttu-id="45b38-296">.NET Framework 中的類別會使用亂數產生器來產生密碼編譯金鑰。</span><span class="sxs-lookup"><span data-stu-id="45b38-296">The classes in the .NET Framework use random number generators to generate cryptographic keys.</span></span>

<span data-ttu-id="45b38-297"><xref:System.Security.Cryptography.RNGCryptoServiceProvider> 類別是亂數產生器演算法的一種實作。</span><span class="sxs-lookup"><span data-stu-id="45b38-297">The <xref:System.Security.Cryptography.RNGCryptoServiceProvider> class is an implementation of a random number generator algorithm.</span></span>

## <a name="clickonce-manifests"></a><span data-ttu-id="45b38-298">ClickOnce 資訊清單</span><span class="sxs-lookup"><span data-stu-id="45b38-298">ClickOnce Manifests</span></span>

<span data-ttu-id="45b38-299">在 .NET Framework 3.5 中，下列的密碼編譯類別可讓您取得並驗證使用[ClickOnce 技術](/visualstudio/deployment/clickonce-security-and-deployment)部署之應用程式的資訊清單簽章資訊：</span><span class="sxs-lookup"><span data-stu-id="45b38-299">In the .NET Framework 3.5, the following cryptography classes let you obtain and verify information about manifest signatures for applications that are deployed using [ClickOnce technology](/visualstudio/deployment/clickonce-security-and-deployment):</span></span>

- <span data-ttu-id="45b38-300">當您使用它的 <xref:System.Security.Cryptography.ManifestSignatureInformation> 方法多載時， <xref:System.Security.Cryptography.ManifestSignatureInformation.VerifySignature%2A> 類別可取得資訊清單簽章的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="45b38-300">The <xref:System.Security.Cryptography.ManifestSignatureInformation> class obtains information about a manifest signature when you use its <xref:System.Security.Cryptography.ManifestSignatureInformation.VerifySignature%2A> method overloads.</span></span>

- <span data-ttu-id="45b38-301">您可以使用 <xref:System.Security.ManifestKinds> 列舉來指定要確認哪一個資訊清單。</span><span class="sxs-lookup"><span data-stu-id="45b38-301">You can use the <xref:System.Security.ManifestKinds> enumeration to specify which manifests to verify.</span></span> <span data-ttu-id="45b38-302">驗證的結果是 <xref:System.Security.Cryptography.SignatureVerificationResult> 的其中一個列舉值。</span><span class="sxs-lookup"><span data-stu-id="45b38-302">The result of the verification is one of the <xref:System.Security.Cryptography.SignatureVerificationResult> enumeration values.</span></span>

- <span data-ttu-id="45b38-303"><xref:System.Security.Cryptography.ManifestSignatureInformationCollection> 類別提供已驗證簽章的唯讀集合 <xref:System.Security.Cryptography.ManifestSignatureInformation> 物件。</span><span class="sxs-lookup"><span data-stu-id="45b38-303">The <xref:System.Security.Cryptography.ManifestSignatureInformationCollection> class provides a read-only collection of <xref:System.Security.Cryptography.ManifestSignatureInformation> objects of the verified signatures.</span></span>

 <span data-ttu-id="45b38-304">此外，下列類別會提供特定的簽章資訊：</span><span class="sxs-lookup"><span data-stu-id="45b38-304">In addition, the following classes provide specific signature information:</span></span>

- <span data-ttu-id="45b38-305"><xref:System.Security.Cryptography.StrongNameSignatureInformation> 替資訊清單保存強式名稱的簽章資訊。</span><span class="sxs-lookup"><span data-stu-id="45b38-305"><xref:System.Security.Cryptography.StrongNameSignatureInformation> holds the strong name signature information for a manifest.</span></span>

- <span data-ttu-id="45b38-306"><xref:System.Security.Cryptography.X509Certificates.AuthenticodeSignatureInformation> 代表資訊清單的 Authenticode 簽章資訊。</span><span class="sxs-lookup"><span data-stu-id="45b38-306"><xref:System.Security.Cryptography.X509Certificates.AuthenticodeSignatureInformation> represents the Authenticode signature information for a manifest.</span></span>

- <span data-ttu-id="45b38-307"><xref:System.Security.Cryptography.X509Certificates.TimestampInformation> 包含了在 Authenticode 簽章上的時間戳記相關資訊。</span><span class="sxs-lookup"><span data-stu-id="45b38-307"><xref:System.Security.Cryptography.X509Certificates.TimestampInformation> contains information about the time stamp on an Authenticode signature.</span></span>

- <span data-ttu-id="45b38-308"><xref:System.Security.Cryptography.X509Certificates.TrustStatus> 提供簡單的方法來檢查 Authenticode 簽章是否受到信任。</span><span class="sxs-lookup"><span data-stu-id="45b38-308"><xref:System.Security.Cryptography.X509Certificates.TrustStatus> provides a simple way to check whether an Authenticode signature is trusted.</span></span>

## <a name="suite-b-support"></a><span data-ttu-id="45b38-309">Suite B 支援</span><span class="sxs-lookup"><span data-stu-id="45b38-309">Suite B Support</span></span>

<span data-ttu-id="45b38-310">.NET Framework 3.5 支援國家安全機構（NSA）所發佈的 Suite B 組密碼編譯演算法。</span><span class="sxs-lookup"><span data-stu-id="45b38-310">The .NET Framework 3.5 supports the Suite B set of cryptographic algorithms published by the National Security Agency (NSA).</span></span> <span data-ttu-id="45b38-311">如需 Suite B 的詳細資訊，請參閱 [NSA Suite B 密碼編譯說明書](https://www.nsa.gov/what-we-do/information-assurance/)。</span><span class="sxs-lookup"><span data-stu-id="45b38-311">For more information about Suite B, see the [NSA Suite B Cryptography Fact Sheet](https://www.nsa.gov/what-we-do/information-assurance/).</span></span>

<span data-ttu-id="45b38-312">下列演算法包含：</span><span class="sxs-lookup"><span data-stu-id="45b38-312">The following algorithms are included:</span></span>

- <span data-ttu-id="45b38-313">進階加密標準 (AES) 演算法，其加密金鑰大小為 128、192，以及 256 位元。</span><span class="sxs-lookup"><span data-stu-id="45b38-313">Advanced Encryption Standard (AES) algorithm with key sizes of 128, 192, , and 256 bits for encryption.</span></span>

- <span data-ttu-id="45b38-314">安全雜湊演算法 SHA-1、SHA-256、SHA-384，以及 SHA-512 雜湊。</span><span class="sxs-lookup"><span data-stu-id="45b38-314">Secure Hash Algorithms SHA-1, SHA-256, SHA-384, and SHA-512 for hashing.</span></span> <span data-ttu-id="45b38-315">(最後三個是通常為一群組，並稱為 SHA-2。)</span><span class="sxs-lookup"><span data-stu-id="45b38-315">(The last three are generally grouped together and referred to as SHA-2.)</span></span>

- <span data-ttu-id="45b38-316">Elliptic Curve Digital Signature Algorithm (ECDSA)，使用曲線為 256 位元、384 位元和 521 位元的第一個模組來簽署。</span><span class="sxs-lookup"><span data-stu-id="45b38-316">Elliptic Curve Digital Signature Algorithm (ECDSA), using curves of 256-bit, 384-bit, and 521-bit prime moduli for signing.</span></span> <span data-ttu-id="45b38-317">NSA 文件特別定義了這些曲線，並稱它們為 P-256、P-384 以及 P-521。</span><span class="sxs-lookup"><span data-stu-id="45b38-317">The NSA documentation specifically defines these curves, and calls them P-256, P-384, and P-521.</span></span> <span data-ttu-id="45b38-318">這個演算法由 <xref:System.Security.Cryptography.ECDsaCng> 類別提供。</span><span class="sxs-lookup"><span data-stu-id="45b38-318">This algorithm is provided by the <xref:System.Security.Cryptography.ECDsaCng> class.</span></span> <span data-ttu-id="45b38-319">它可讓您使用私密金鑰簽署，並以公開金鑰來驗證簽章。</span><span class="sxs-lookup"><span data-stu-id="45b38-319">It enables you to sign with a private key and verify the signature with a public key.</span></span>

- <span data-ttu-id="45b38-320">橢圓曲線 Diffie-Hellman (ECDH) 演算法，使用曲線為 256 位元、384 位元和 521 位元的第一個模組作為金鑰交換和密碼協議。</span><span class="sxs-lookup"><span data-stu-id="45b38-320">Elliptic Curve Diffie-Hellman (ECDH) algorithm, using curves of 256-bit, 384-bit, and 521-bit prime moduli for the key exchange and secret agreement.</span></span> <span data-ttu-id="45b38-321">這個演算法由 <xref:System.Security.Cryptography.ECDiffieHellmanCng> 類別提供。</span><span class="sxs-lookup"><span data-stu-id="45b38-321">This algorithm is provided by the <xref:System.Security.Cryptography.ECDiffieHellmanCng> class.</span></span>

<span data-ttu-id="45b38-322">美國聯邦資訊處理標準 (FIPS) 認證的 Managed 程式碼包裝函式為 AES、SHA-256、SHA-384，與 SHA-512 實作，現在可見於新的 <xref:System.Security.Cryptography.AesCryptoServiceProvider>、 <xref:System.Security.Cryptography.SHA256CryptoServiceProvider>、 <xref:System.Security.Cryptography.SHA384CryptoServiceProvider>，以及 <xref:System.Security.Cryptography.SHA512CryptoServiceProvider> 類別中。</span><span class="sxs-lookup"><span data-stu-id="45b38-322">Managed code wrappers for the Federal Information Processing Standard (FIPS) certified implementations of the AES, SHA-256, SHA-384, and SHA-512 implementations are available in the new <xref:System.Security.Cryptography.AesCryptoServiceProvider>, <xref:System.Security.Cryptography.SHA256CryptoServiceProvider>, <xref:System.Security.Cryptography.SHA384CryptoServiceProvider>, and <xref:System.Security.Cryptography.SHA512CryptoServiceProvider> classes.</span></span>

## <a name="cryptography-next-generation-cng-classes"></a><span data-ttu-id="45b38-323">新一代密碼編譯 (CNG) 類別</span><span class="sxs-lookup"><span data-stu-id="45b38-323">Cryptography Next Generation (CNG) Classes</span></span>

<span data-ttu-id="45b38-324">新一代密碼編譯 (CNG) 類別提供可在原生 CNG 函式周圍的 Managed 包裝函式。</span><span class="sxs-lookup"><span data-stu-id="45b38-324">The Cryptography Next Generation (CNG) classes provide a managed wrapper around the native CNG functions.</span></span> <span data-ttu-id="45b38-325">（CNG 取代了 CryptoAPI）。這些類別具有 "Cng" 作為其名稱的一部分。</span><span class="sxs-lookup"><span data-stu-id="45b38-325">(CNG is the replacement for CryptoAPI.) These classes have "Cng" as part of their names.</span></span> <span data-ttu-id="45b38-326">CNG 包裝函式類別的中心是 <xref:System.Security.Cryptography.CngKey> 金鑰容器類別，其會擷取儲存體和使用 CNG 金鑰。</span><span class="sxs-lookup"><span data-stu-id="45b38-326">Central to the CNG wrapper classes is the <xref:System.Security.Cryptography.CngKey> key container class, which abstracts the storage and use of CNG keys.</span></span> <span data-ttu-id="45b38-327">這個類別可讓您安全地儲存金鑰組或公開金鑰，並使用簡單的字串名稱參考它。</span><span class="sxs-lookup"><span data-stu-id="45b38-327">This class lets you store a key pair or a public key securely and refer to it by using a simple string name.</span></span> <span data-ttu-id="45b38-328">橢圓曲線基礎 <xref:System.Security.Cryptography.ECDsaCng> 簽章類別和 <xref:System.Security.Cryptography.ECDiffieHellmanCng> 加密類別可以使用 <xref:System.Security.Cryptography.CngKey> 物件。</span><span class="sxs-lookup"><span data-stu-id="45b38-328">The elliptic curve-based <xref:System.Security.Cryptography.ECDsaCng> signature class and the <xref:System.Security.Cryptography.ECDiffieHellmanCng> encryption class can use <xref:System.Security.Cryptography.CngKey> objects.</span></span>

<span data-ttu-id="45b38-329"><xref:System.Security.Cryptography.CngKey> 類別用於各種其他作業，包括開啟、建立、刪除及匯出金鑰。</span><span class="sxs-lookup"><span data-stu-id="45b38-329">The <xref:System.Security.Cryptography.CngKey> class is used for a variety of additional operations, including opening, creating, deleting, and exporting keys.</span></span> <span data-ttu-id="45b38-330">它也提供存取基礎金鑰控制代碼，以便在直接呼叫原生函式時使用。</span><span class="sxs-lookup"><span data-stu-id="45b38-330">It also provides access to the underlying key handle to use when calling native functions directly.</span></span>

<span data-ttu-id="45b38-331">.NET Framework 3.5 也包括各種支援的 CNG 類別，如下所示：</span><span class="sxs-lookup"><span data-stu-id="45b38-331">The .NET Framework 3.5 also includes a variety of supporting CNG classes, such as the following:</span></span>

- <span data-ttu-id="45b38-332"><xref:System.Security.Cryptography.CngProvider> 維護金鑰儲存提供者。</span><span class="sxs-lookup"><span data-stu-id="45b38-332"><xref:System.Security.Cryptography.CngProvider> maintains a key storage provider.</span></span>

- <span data-ttu-id="45b38-333"><xref:System.Security.Cryptography.CngAlgorithm> 維護 CNG 演算法。</span><span class="sxs-lookup"><span data-stu-id="45b38-333"><xref:System.Security.Cryptography.CngAlgorithm> maintains a CNG algorithm.</span></span>

- <span data-ttu-id="45b38-334"><xref:System.Security.Cryptography.CngProperty> 維護常用的金鑰屬性。</span><span class="sxs-lookup"><span data-stu-id="45b38-334"><xref:System.Security.Cryptography.CngProperty> maintains frequently used key properties.</span></span>

## <a name="related-topics"></a><span data-ttu-id="45b38-335">[相關主題]</span><span class="sxs-lookup"><span data-stu-id="45b38-335">Related Topics</span></span>

|<span data-ttu-id="45b38-336">Title</span><span class="sxs-lookup"><span data-stu-id="45b38-336">Title</span></span>|<span data-ttu-id="45b38-337">描述</span><span class="sxs-lookup"><span data-stu-id="45b38-337">Description</span></span>|
|-----------|-----------------|
|[<span data-ttu-id="45b38-338">加密模型</span><span class="sxs-lookup"><span data-stu-id="45b38-338">Cryptography Model</span></span>](cryptography-model.md)|<span data-ttu-id="45b38-339">描述基底類別程式庫中如何實作密碼編譯。</span><span class="sxs-lookup"><span data-stu-id="45b38-339">Describes how cryptography is implemented in the base class library.</span></span>|
|[<span data-ttu-id="45b38-340">逐步解說： 建立密碼編譯的應用程式</span><span class="sxs-lookup"><span data-stu-id="45b38-340">Walkthrough: Creating a Cryptographic Application</span></span>](walkthrough-creating-a-cryptographic-application.md)|<span data-ttu-id="45b38-341">示範基本的加密和解密工作。</span><span class="sxs-lookup"><span data-stu-id="45b38-341">Demonstrates basic encryption and decryption tasks.</span></span>|
|[<span data-ttu-id="45b38-342">設定密碼編譯類別</span><span class="sxs-lookup"><span data-stu-id="45b38-342">Configuring Cryptography Classes</span></span>](../../framework/configure-apps/configure-cryptography-classes.md)|<span data-ttu-id="45b38-343">描述如何將演算法名稱對應到密碼編譯類別，並將物件識別碼對應至密碼編譯演算法。</span><span class="sxs-lookup"><span data-stu-id="45b38-343">Describes how to map algorithm names to cryptographic classes and map object identifiers to a cryptographic algorithm.</span></span>|
