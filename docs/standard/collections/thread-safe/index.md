---
title: 安全執行緒集合
ms.date: 03/30/2017
ms.technology: dotnet-standard
helpviewer_keywords:
- thread-safe collections, overview
ms.assetid: 2e7ca21f-786c-4367-96be-0cf3f3dcc6bd
ms.openlocfilehash: 7af59cf0fdbe8d5c7d7d586b4b86992ae1dc7601
ms.sourcegitcommit: 33deec3e814238fb18a49b2a7e89278e27888291
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 06/02/2020
ms.locfileid: "84290366"
---
# <a name="thread-safe-collections"></a><span data-ttu-id="a1f93-102">安全執行緒集合</span><span class="sxs-lookup"><span data-stu-id="a1f93-102">Thread-Safe Collections</span></span>
<span data-ttu-id="a1f93-103">.NET Framework 4 引進了 <xref:System.Collections.Concurrent?displayProperty=nameWithType> 命名空間，其中包含數個兼具安全執行緒與調整能力的集合類別。</span><span class="sxs-lookup"><span data-stu-id="a1f93-103">The .NET Framework 4 introduces the <xref:System.Collections.Concurrent?displayProperty=nameWithType> namespace, which includes several collection classes that are both thread-safe and scalable.</span></span> <span data-ttu-id="a1f93-104">多個執行緒可以安全且有效率地新增或移除這些集合中的項目，而不需要利用使用者程式碼進行額外同步處理。</span><span class="sxs-lookup"><span data-stu-id="a1f93-104">Multiple threads can safely and efficiently add or remove items from these collections, without requiring additional synchronization in user code.</span></span> <span data-ttu-id="a1f93-105">當您撰寫新的程式碼時，只要多個執行緒將同時寫入集合，就使用並行集合類別。</span><span class="sxs-lookup"><span data-stu-id="a1f93-105">When you write new code, use the concurrent collection classes whenever multiple threads will write to the collection concurrently.</span></span> <span data-ttu-id="a1f93-106">如果您僅讀取共用集合，則可以使用 <xref:System.Collections.Generic?displayProperty=nameWithType> 命名空間中的類別。</span><span class="sxs-lookup"><span data-stu-id="a1f93-106">If you are only reading from a shared collection, then you can use the classes in the <xref:System.Collections.Generic?displayProperty=nameWithType> namespace.</span></span> <span data-ttu-id="a1f93-107">除非您需要將目標設為 .NET Framework 1.1 或舊版本的執行階段，否則建議您不要使用 1.0 集合類別。</span><span class="sxs-lookup"><span data-stu-id="a1f93-107">We recommend that you do not use 1.0 collection classes unless you are required to target the .NET Framework 1.1 or earlier runtime.</span></span>  
  
## <a name="thread-synchronization-in-the-net-framework-10-and-20-collections"></a><span data-ttu-id="a1f93-108">.NET Framework 1.0 和 2.0 集合中的執行緒同步處理</span><span class="sxs-lookup"><span data-stu-id="a1f93-108">Thread Synchronization in the .NET Framework 1.0 and 2.0 Collections</span></span>  
 <span data-ttu-id="a1f93-109">您可以在 <xref:System.Collections?displayProperty=nameWithType> 命名空間中找到 .NET Framework 1.0 中引進的集合。</span><span class="sxs-lookup"><span data-stu-id="a1f93-109">The collections introduced in the .NET Framework 1.0 are found in the <xref:System.Collections?displayProperty=nameWithType> namespace.</span></span> <span data-ttu-id="a1f93-110">這些包括常用 <xref:System.Collections.ArrayList> 和 <xref:System.Collections.Hashtable> 的集合透過 `Synchronized` 屬性來提供某種安全執行緒，而這個屬性會傳回集合的安全執行緒包裝函式。</span><span class="sxs-lookup"><span data-stu-id="a1f93-110">These collections, which include the commonly used <xref:System.Collections.ArrayList> and <xref:System.Collections.Hashtable>, provide some thread-safety through the `Synchronized` property, which returns a thread-safe wrapper around the collection.</span></span> <span data-ttu-id="a1f93-111">包裝函式的運作方式是針對每個新增或移除作業鎖定整個集合。</span><span class="sxs-lookup"><span data-stu-id="a1f93-111">The wrapper works by locking the entire collection on every add or remove operation.</span></span> <span data-ttu-id="a1f93-112">因此，嘗試存取集合的每個執行緒都必須等待，直到輪到它取得一個鎖定。</span><span class="sxs-lookup"><span data-stu-id="a1f93-112">Therefore, each thread that is attempting to access the collection must wait for its turn to take the one lock.</span></span> <span data-ttu-id="a1f93-113">這無法進行擴充，而且可能會造成大型集合的重大效能下降。</span><span class="sxs-lookup"><span data-stu-id="a1f93-113">This is not scalable and can cause significant performance degradation for large collections.</span></span> <span data-ttu-id="a1f93-114">此外，設計未完全保護競爭情形。</span><span class="sxs-lookup"><span data-stu-id="a1f93-114">Also, the design is not completely protected from race conditions.</span></span> <span data-ttu-id="a1f93-115">如需詳細資訊，請參閱[泛型集合中的同步處理](https://docs.microsoft.com/archive/blogs/bclteam/synchronization-in-generic-collections-brian-grunkemeyer)。</span><span class="sxs-lookup"><span data-stu-id="a1f93-115">For more information, see [Synchronization in Generic Collections](https://docs.microsoft.com/archive/blogs/bclteam/synchronization-in-generic-collections-brian-grunkemeyer).</span></span>  
  
 <span data-ttu-id="a1f93-116">您可以在 <xref:System.Collections.Generic?displayProperty=nameWithType> 命名空間中找到 .NET Framework 2.0 中引進的集合類別，</span><span class="sxs-lookup"><span data-stu-id="a1f93-116">The collection classes introduced in the .NET Framework 2.0 are found in the <xref:System.Collections.Generic?displayProperty=nameWithType> namespace.</span></span> <span data-ttu-id="a1f93-117">包括 <xref:System.Collections.Generic.List%601>、<xref:System.Collections.Generic.Dictionary%602> 等。</span><span class="sxs-lookup"><span data-stu-id="a1f93-117">These include <xref:System.Collections.Generic.List%601>, <xref:System.Collections.Generic.Dictionary%602>, and so on.</span></span> <span data-ttu-id="a1f93-118">這些類別提供相較起 .NET Framework 1.0 類別的改良型別安全和效能。</span><span class="sxs-lookup"><span data-stu-id="a1f93-118">These classes provide improved type safety and performance compared to the .NET Framework 1.0 classes.</span></span> <span data-ttu-id="a1f93-119">不過，.NET Framework 2.0 集合類別不會提供任何執行緒同步處理；在多個執行緒上同時新增或移除項目時，使用者程式碼必須提供所有同步處理。</span><span class="sxs-lookup"><span data-stu-id="a1f93-119">However, the .NET Framework 2.0 collection classes do not provide any thread synchronization; user code must provide all synchronization when items are added or removed on multiple threads concurrently.</span></span>  
  
 <span data-ttu-id="a1f93-120">建議您使用 NET Framework 4 中的並行集合類別，因為這些類別不僅提供 .NET Framework 2.0 集合類別的型別安全，而且提供比 .NET Framework 1.0 集合更高的效率及更完整的執行緒安全性。</span><span class="sxs-lookup"><span data-stu-id="a1f93-120">We recommend the concurrent collections classes in the .NET Framework 4 because they provide not only the type safety of the .NET Framework 2.0 collection classes, but also more efficient and more complete thread safety than the .NET Framework 1.0 collections provide.</span></span>  
  
## <a name="fine-grained-locking-and-lock-free-mechanisms"></a><span data-ttu-id="a1f93-121">更細緻的鎖定和無鎖定機制</span><span class="sxs-lookup"><span data-stu-id="a1f93-121">Fine-Grained Locking and Lock-Free Mechanisms</span></span>  
 <span data-ttu-id="a1f93-122">有些並行集合類型會使用輕量型同步處理機制，例如 .NET Framework 4 中新增的 <xref:System.Threading.SpinLock>、<xref:System.Threading.SpinWait>、<xref:System.Threading.SemaphoreSlim> 和 <xref:System.Threading.CountdownEvent>。</span><span class="sxs-lookup"><span data-stu-id="a1f93-122">Some of the concurrent collection types use lightweight synchronization mechanisms such as <xref:System.Threading.SpinLock>, <xref:System.Threading.SpinWait>, <xref:System.Threading.SemaphoreSlim>, and <xref:System.Threading.CountdownEvent>, which are new in the .NET Framework 4.</span></span> <span data-ttu-id="a1f93-123">這些同步處理型別通常會先使用短期間的*忙碌旋轉*，再讓執行緒進入真正的 Wait 狀態。</span><span class="sxs-lookup"><span data-stu-id="a1f93-123">These synchronization types typically use *busy spinning* for brief periods before they put the thread into a true Wait state.</span></span> <span data-ttu-id="a1f93-124">預期等候時間很短時，旋轉的費用遠低於等待，這包含昂貴的核心轉換。</span><span class="sxs-lookup"><span data-stu-id="a1f93-124">When wait times are expected to be very short, spinning is far less computationally expensive than waiting, which involves an expensive kernel transition.</span></span> <span data-ttu-id="a1f93-125">針對使用旋轉的集合類別，這個效率表示多個執行緒可以使用極高的速率來新增和移除項目。</span><span class="sxs-lookup"><span data-stu-id="a1f93-125">For collection classes that use spinning, this efficiency means that multiple threads can add and remove items at a very high rate.</span></span> <span data-ttu-id="a1f93-126">如需旋轉與封鎖比較的詳細資訊，請參閱 [SpinLock](../../threading/spinlock.md) 和 [SpinWait](../../threading/spinwait.md)。</span><span class="sxs-lookup"><span data-stu-id="a1f93-126">For more information about spinning vs. blocking, see [SpinLock](../../threading/spinlock.md) and [SpinWait](../../threading/spinwait.md).</span></span>  
  
 <span data-ttu-id="a1f93-127"><xref:System.Collections.Concurrent.ConcurrentQueue%601> 和 <xref:System.Collections.Concurrent.ConcurrentStack%601> 類別完全不使用鎖定。</span><span class="sxs-lookup"><span data-stu-id="a1f93-127">The <xref:System.Collections.Concurrent.ConcurrentQueue%601> and <xref:System.Collections.Concurrent.ConcurrentStack%601> classes do not use locks at all.</span></span> <span data-ttu-id="a1f93-128">相反地，它們依賴 <xref:System.Threading.Interlocked> 作業來取得安全執行緒。</span><span class="sxs-lookup"><span data-stu-id="a1f93-128">Instead, they rely on <xref:System.Threading.Interlocked> operations to achieve thread-safety.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="a1f93-129">因為並行集合類別支援 <xref:System.Collections.ICollection>，所以會提供 <xref:System.Collections.ICollection.IsSynchronized%2A> 和 <xref:System.Collections.ICollection.SyncRoot%2A> 屬性的實作，即使這些屬性無關也是一樣。</span><span class="sxs-lookup"><span data-stu-id="a1f93-129">Because the concurrent collections classes support <xref:System.Collections.ICollection>, they provide implementations for the <xref:System.Collections.ICollection.IsSynchronized%2A> and <xref:System.Collections.ICollection.SyncRoot%2A> properties, even though these properties are irrelevant.</span></span> <span data-ttu-id="a1f93-130">`IsSynchronized` 一律會傳回 `false`，而 `SyncRoot` 一律為 `null` (在 Visual Basic 中為 `Nothing`)。</span><span class="sxs-lookup"><span data-stu-id="a1f93-130">`IsSynchronized` always returns `false` and `SyncRoot` is always `null` (`Nothing` in Visual Basic).</span></span>  
  
 <span data-ttu-id="a1f93-131">下表列出 <xref:System.Collections.Concurrent?displayProperty=nameWithType> 命名空間中的集合類型。</span><span class="sxs-lookup"><span data-stu-id="a1f93-131">The following table lists the collection types in the <xref:System.Collections.Concurrent?displayProperty=nameWithType> namespace.</span></span>  
  
|<span data-ttu-id="a1f93-132">類型</span><span class="sxs-lookup"><span data-stu-id="a1f93-132">Type</span></span>|<span data-ttu-id="a1f93-133">Description</span><span class="sxs-lookup"><span data-stu-id="a1f93-133">Description</span></span>|  
|----------|-----------------|  
|<xref:System.Collections.Concurrent.BlockingCollection%601>|<span data-ttu-id="a1f93-134">提供任何可實作 <xref:System.Collections.Concurrent.IProducerConsumerCollection%601> 之類型的界限和封鎖功能。</span><span class="sxs-lookup"><span data-stu-id="a1f93-134">Provides bounding and blocking functionality for any type that implements <xref:System.Collections.Concurrent.IProducerConsumerCollection%601>.</span></span> <span data-ttu-id="a1f93-135">如需詳細資訊，請參閱 [BlockingCollection 概觀](blockingcollection-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="a1f93-135">For more information, see [BlockingCollection Overview](blockingcollection-overview.md).</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentDictionary%602>|<span data-ttu-id="a1f93-136">索引鍵/值組字典的安全執行緒實作。</span><span class="sxs-lookup"><span data-stu-id="a1f93-136">Thread-safe implementation of a dictionary of key-value pairs.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentQueue%601>|<span data-ttu-id="a1f93-137">FIFO (先進先出) 佇列的安全執行緒實作。</span><span class="sxs-lookup"><span data-stu-id="a1f93-137">Thread-safe implementation of a FIFO (first-in, first-out) queue.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentStack%601>|<span data-ttu-id="a1f93-138">LIFO (後進先出) 堆疊的安全執行緒實作。</span><span class="sxs-lookup"><span data-stu-id="a1f93-138">Thread-safe implementation of a LIFO (last-in, first-out) stack.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentBag%601>|<span data-ttu-id="a1f93-139">未排序元素集合的安全執行緒實作。</span><span class="sxs-lookup"><span data-stu-id="a1f93-139">Thread-safe implementation of an unordered collection of elements.</span></span>|  
|<xref:System.Collections.Concurrent.IProducerConsumerCollection%601>|<span data-ttu-id="a1f93-140">類型必須實作以在 `BlockingCollection` 中使用的介面。</span><span class="sxs-lookup"><span data-stu-id="a1f93-140">The interface that a type must implement to be used in a `BlockingCollection`.</span></span>|  
  
## <a name="related-topics"></a><span data-ttu-id="a1f93-141">[相關主題]</span><span class="sxs-lookup"><span data-stu-id="a1f93-141">Related Topics</span></span>  
  
|<span data-ttu-id="a1f93-142">Title</span><span class="sxs-lookup"><span data-stu-id="a1f93-142">Title</span></span>|<span data-ttu-id="a1f93-143">描述</span><span class="sxs-lookup"><span data-stu-id="a1f93-143">Description</span></span>|  
|-----------|-----------------|  
|[<span data-ttu-id="a1f93-144">BlockingCollection 概觀</span><span class="sxs-lookup"><span data-stu-id="a1f93-144">BlockingCollection Overview</span></span>](blockingcollection-overview.md)|<span data-ttu-id="a1f93-145">描述 <xref:System.Collections.Concurrent.BlockingCollection%601> 類型所提供的功能。</span><span class="sxs-lookup"><span data-stu-id="a1f93-145">Describes the functionality provided by the <xref:System.Collections.Concurrent.BlockingCollection%601> type.</span></span>|  
|[<span data-ttu-id="a1f93-146">如何：在 ConcurrentDictionary 中加入和移除項目</span><span class="sxs-lookup"><span data-stu-id="a1f93-146">How to: Add and Remove Items from a ConcurrentDictionary</span></span>](how-to-add-and-remove-items.md)|<span data-ttu-id="a1f93-147">描述如何新增和移除 <xref:System.Collections.Concurrent.ConcurrentDictionary%602> 中的項目</span><span class="sxs-lookup"><span data-stu-id="a1f93-147">Describes how to add and remove elements from a <xref:System.Collections.Concurrent.ConcurrentDictionary%602></span></span>|  
|[<span data-ttu-id="a1f93-148">操作說明：從 BlockingCollection 個別新增和擷取項目</span><span class="sxs-lookup"><span data-stu-id="a1f93-148">How to: Add and Take Items Individually from a BlockingCollection</span></span>](how-to-add-and-take-items.md)|<span data-ttu-id="a1f93-149">描述在未使用唯讀列舉值的情況下，如何新增和擷取封鎖回收中的項目。</span><span class="sxs-lookup"><span data-stu-id="a1f93-149">Describes how to add and retrieve items from a blocking collection without using the read-only enumerator.</span></span>|  
|[<span data-ttu-id="a1f93-150">如何：將界限和封鎖功能新增至集合</span><span class="sxs-lookup"><span data-stu-id="a1f93-150">How to: Add Bounding and Blocking Functionality to a Collection</span></span>](how-to-add-bounding-and-blocking.md)|<span data-ttu-id="a1f93-151">描述如何使用任何集合類別作為 <xref:System.Collections.Concurrent.IProducerConsumerCollection%601> 集合的基礎儲存機制。</span><span class="sxs-lookup"><span data-stu-id="a1f93-151">Describes how to use any collection class as the underlying storage mechanism for an <xref:System.Collections.Concurrent.IProducerConsumerCollection%601> collection.</span></span>|  
|[<span data-ttu-id="a1f93-152">如何：使用 ForEach 來移除 BlockingCollection 中的項目</span><span class="sxs-lookup"><span data-stu-id="a1f93-152">How to: Use ForEach to Remove Items in a BlockingCollection</span></span>](how-to-use-foreach-to-remove.md)|<span data-ttu-id="a1f93-153">描述如何使用 `foreach` (在 Visual Basic 中為 `For Each`) 來移除封鎖集合中的所有項目。</span><span class="sxs-lookup"><span data-stu-id="a1f93-153">Describes how to use `foreach`, (`For Each` in Visual Basic) to remove all items in a blocking collection.</span></span>|  
|[<span data-ttu-id="a1f93-154">如何：在管線中使用封鎖集合的陣列</span><span class="sxs-lookup"><span data-stu-id="a1f93-154">How to: Use Arrays of Blocking Collections in a Pipeline</span></span>](how-to-use-arrays-of-blockingcollections.md)|<span data-ttu-id="a1f93-155">描述如何同時使用多個封鎖回收來實作管線。</span><span class="sxs-lookup"><span data-stu-id="a1f93-155">Describes how to use multiple blocking collections at the same time to implement a pipeline.</span></span>|  
|[<span data-ttu-id="a1f93-156">如何：使用 ConcurrentBag 建立物件集區</span><span class="sxs-lookup"><span data-stu-id="a1f93-156">How to: Create an Object Pool by Using a ConcurrentBag</span></span>](how-to-create-an-object-pool.md)|<span data-ttu-id="a1f93-157">示範在您可以重複使用物件而非持續建立新物件的情況下，如何使用並行資料包改善效能。</span><span class="sxs-lookup"><span data-stu-id="a1f93-157">Shows how to use a concurrent bag to improve performance in scenarios where you can reuse objects instead of continually creating new ones.</span></span>|  
  
## <a name="reference"></a><span data-ttu-id="a1f93-158">參考</span><span class="sxs-lookup"><span data-stu-id="a1f93-158">Reference</span></span>  
 <xref:System.Collections.Concurrent?displayProperty=nameWithType>
