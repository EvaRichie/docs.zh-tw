---
title: 集合和資料結構
description: 瞭解如何在 .NET 中使用集合和資料結構。 在安全線程作業中使用泛型和非泛型集合。
ms.date: 04/30/2020
helpviewer_keywords:
- grouping data in collections
- objects [.NET], grouping in collections
- Array class, grouping data in collections
- threading [.NET], safety
- Collections classes
- collections [.NET]
ms.assetid: 60cc581f-1db5-445b-ba04-a173396bf872
ms.openlocfilehash: 3b92f3aa8c21cc3d171e14100db190d88f2c0284
ms.sourcegitcommit: 965a5af7918acb0a3fd3baf342e15d511ef75188
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 11/18/2020
ms.locfileid: "94823845"
---
# <a name="collections-and-data-structures"></a><span data-ttu-id="f9d1d-104">集合和資料結構</span><span class="sxs-lookup"><span data-stu-id="f9d1d-104">Collections and Data Structures</span></span>

<span data-ttu-id="f9d1d-105">使用集合進行儲存與管理時，通常可以更有效率地處理類似的資料。</span><span class="sxs-lookup"><span data-stu-id="f9d1d-105">Similar data can often be handled more efficiently when stored and manipulated as a collection.</span></span> <span data-ttu-id="f9d1d-106">您可以使用 <xref:System.Array?displayProperty=nameWithType> 類別或 <xref:System.Collections> 、 <xref:System.Collections.Generic> 、和命名空間中的類別， <xref:System.Collections.Concurrent> <xref:System.Collections.Immutable> 來新增、移除和修改集合中的個別專案或元素範圍。</span><span class="sxs-lookup"><span data-stu-id="f9d1d-106">You can use the <xref:System.Array?displayProperty=nameWithType> class or the classes in the <xref:System.Collections>, <xref:System.Collections.Generic>, <xref:System.Collections.Concurrent>, and <xref:System.Collections.Immutable> namespaces to add, remove, and modify either individual elements or a range of elements in a collection.</span></span>

<span data-ttu-id="f9d1d-107">有兩種主要的集合類型；泛型集合和非泛型集合。</span><span class="sxs-lookup"><span data-stu-id="f9d1d-107">There are two main types of collections; generic collections and non-generic collections.</span></span> <span data-ttu-id="f9d1d-108">泛型集合在編譯時間具有型別安全。</span><span class="sxs-lookup"><span data-stu-id="f9d1d-108">Generic collections are type-safe at compile time.</span></span> <span data-ttu-id="f9d1d-109">因此，泛型集合通常會有較佳的效能。</span><span class="sxs-lookup"><span data-stu-id="f9d1d-109">Because of this, generic collections typically offer better performance.</span></span> <span data-ttu-id="f9d1d-110">建構泛型集合後，泛型集合可接受類型參數，且當您加入或移除集合中的項目時，不需要轉換成 <xref:System.Object> 類型或從該類型進行轉換。</span><span class="sxs-lookup"><span data-stu-id="f9d1d-110">Generic collections accept a type parameter when they are constructed and do not require that you cast to and from the <xref:System.Object> type when you add or remove items from the collection.</span></span>  <span data-ttu-id="f9d1d-111">此外，Windows Store 應用程式中支援大部分的泛型集合。</span><span class="sxs-lookup"><span data-stu-id="f9d1d-111">In addition, most generic collections are supported in Windows Store apps.</span></span> <span data-ttu-id="f9d1d-112">非泛型集合會將專案儲存為 <xref:System.Object> 、需要轉換，而且大部分都不支援 Windows store 應用程式開發。</span><span class="sxs-lookup"><span data-stu-id="f9d1d-112">Non-generic collections store items as <xref:System.Object>, require casting, and most are not supported for Windows Store app development.</span></span> <span data-ttu-id="f9d1d-113">但您可能會在較舊的程式碼中看到非泛型集合。</span><span class="sxs-lookup"><span data-stu-id="f9d1d-113">However, you may see non-generic collections in older code.</span></span>

<span data-ttu-id="f9d1d-114">從 .NET Framework 4 開始，命名空間中的集合 <xref:System.Collections.Concurrent> 提供了有效率的安全線程作業，可從多個執行緒存取集合專案。</span><span class="sxs-lookup"><span data-stu-id="f9d1d-114">Starting with .NET Framework 4, the collections in the <xref:System.Collections.Concurrent> namespace provide efficient thread-safe operations for accessing collection items from multiple threads.</span></span> <span data-ttu-id="f9d1d-115"><xref:System.Collections.Immutable>命名空間 ([NuGet 套件](https://www.nuget.org/packages/System.Collections.Immutable)) 中的不可變集合類別，原本就是安全線程，因為作業是在原創組合的複本上執行，而且無法修改原創組合。</span><span class="sxs-lookup"><span data-stu-id="f9d1d-115">The immutable collection classes in the <xref:System.Collections.Immutable> namespace ([NuGet package](https://www.nuget.org/packages/System.Collections.Immutable)) are inherently thread-safe because operations are performed on a copy of the original collection and the original collection cannot be modified.</span></span>

<a name="BKMK_Commoncollectionfeatures"></a>
## <a name="common-collection-features"></a><span data-ttu-id="f9d1d-116">常見集合功能</span><span class="sxs-lookup"><span data-stu-id="f9d1d-116">Common collection features</span></span>

<span data-ttu-id="f9d1d-117">所有集合都會提供方法來加入、移除或尋找集合中的專案。</span><span class="sxs-lookup"><span data-stu-id="f9d1d-117">All collections provide methods for adding, removing, or finding items in the collection.</span></span> <span data-ttu-id="f9d1d-118">此外，直接或間接實作 <xref:System.Collections.ICollection> 介面或 <xref:System.Collections.Generic.ICollection%601> 介面的所有集合，都可共用這些功能：</span><span class="sxs-lookup"><span data-stu-id="f9d1d-118">In addition, all collections that directly or indirectly implement the <xref:System.Collections.ICollection> interface or the <xref:System.Collections.Generic.ICollection%601> interface share these features:</span></span>

- <span data-ttu-id="f9d1d-119">**列舉集合的能力**</span><span class="sxs-lookup"><span data-stu-id="f9d1d-119">**The ability to enumerate the collection**</span></span>

    <span data-ttu-id="f9d1d-120">.NET 集合可能 <xref:System.Collections.IEnumerable?displayProperty=nameWithType> 會執行或 <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> 啟用集合，以進行逐一查看。</span><span class="sxs-lookup"><span data-stu-id="f9d1d-120">.NET collections either implement <xref:System.Collections.IEnumerable?displayProperty=nameWithType> or <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> to enable the collection to be iterated through.</span></span> <span data-ttu-id="f9d1d-121">列舉程式可視為集合中任何元素可移動的指標。</span><span class="sxs-lookup"><span data-stu-id="f9d1d-121">An enumerator can be thought of as a movable pointer to any element in the collection.</span></span> <span data-ttu-id="f9d1d-122">[foreach, in](../../csharp/language-reference/keywords/foreach-in.md) 陳述式和 [For Each...Next 陳述式](../../visual-basic/language-reference/statements/for-each-next-statement.md)，會使用 <xref:System.Collections.IEnumerable.GetEnumerator%2A> 方法所公開的列舉程式，並會隱藏管理列舉程式的複雜程度。</span><span class="sxs-lookup"><span data-stu-id="f9d1d-122">The [foreach, in](../../csharp/language-reference/keywords/foreach-in.md) statement  and the [For Each...Next Statement](../../visual-basic/language-reference/statements/for-each-next-statement.md) use the enumerator exposed by the <xref:System.Collections.IEnumerable.GetEnumerator%2A> method and hide the complexity of manipulating the enumerator.</span></span> <span data-ttu-id="f9d1d-123">此外，實作 <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> 的任何集合，會視為「可查詢類型」，且可使用 LINQ 進行查詢。</span><span class="sxs-lookup"><span data-stu-id="f9d1d-123">In addition, any collection that implements <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> is considered a *queryable type* and can be queried with LINQ.</span></span> <span data-ttu-id="f9d1d-124">LINQ 查詢提供存取資料的常見模式。</span><span class="sxs-lookup"><span data-stu-id="f9d1d-124">LINQ queries provide a common pattern for accessing data.</span></span> <span data-ttu-id="f9d1d-125">且通常比標準 `foreach` 迴圈更簡潔易懂，並提供篩選、排序和分組的功能。</span><span class="sxs-lookup"><span data-stu-id="f9d1d-125">They are typically more concise and readable than standard `foreach` loops, and provide filtering, ordering and grouping capabilities.</span></span> <span data-ttu-id="f9d1d-126">LINQ 查詢也可以提升效能。</span><span class="sxs-lookup"><span data-stu-id="f9d1d-126">LINQ queries can also improve performance.</span></span> <span data-ttu-id="f9d1d-127">如需詳細資訊，請參閱 [LINQ to Objects (C#)](../../csharp/programming-guide/concepts/linq/linq-to-objects.md)、[LINQ to Objects (Visual Basic)](../../visual-basic/programming-guide/concepts/linq/linq-to-objects.md)、[Parallel LINQ (PLINQ)](../parallel-programming/introduction-to-plinq.md)、[LINQ 查詢簡介 (C#)](../../csharp/programming-guide/concepts/linq/introduction-to-linq-queries.md) 及[基本查詢作業 (Visual Basic)](../../visual-basic/programming-guide/concepts/linq/basic-query-operations.md)。</span><span class="sxs-lookup"><span data-stu-id="f9d1d-127">For more information, see [LINQ to Objects (C#)](../../csharp/programming-guide/concepts/linq/linq-to-objects.md), [LINQ to Objects (Visual Basic)](../../visual-basic/programming-guide/concepts/linq/linq-to-objects.md), [Parallel LINQ (PLINQ)](../parallel-programming/introduction-to-plinq.md), [Introduction to LINQ Queries (C#)](../../csharp/programming-guide/concepts/linq/introduction-to-linq-queries.md), and [Basic Query Operations (Visual Basic)](../../visual-basic/programming-guide/concepts/linq/basic-query-operations.md).</span></span>

- <span data-ttu-id="f9d1d-128">**將集合內容複製到陣列的能力**</span><span class="sxs-lookup"><span data-stu-id="f9d1d-128">**The ability to copy the collection contents to an array**</span></span>

    <span data-ttu-id="f9d1d-129">所有集合都可使用 **CopyTo** 方法複製到陣列。但新陣列中的元素順序，會根據列舉程式傳回元素的順序排列。</span><span class="sxs-lookup"><span data-stu-id="f9d1d-129">All collections can be copied to an array using the **CopyTo** method; however, the order of the elements in the new array is based on the sequence in which the enumerator returns them.</span></span> <span data-ttu-id="f9d1d-130">產生的陣列一律會是一維陣列，且其下限為零。</span><span class="sxs-lookup"><span data-stu-id="f9d1d-130">The resulting array is always one-dimensional with a lower bound of zero.</span></span>

<span data-ttu-id="f9d1d-131">此外，許多集合類別包含下列功能：</span><span class="sxs-lookup"><span data-stu-id="f9d1d-131">In addition, many collection classes contain the following features:</span></span>

- <span data-ttu-id="f9d1d-132">**容量和計數屬性**</span><span class="sxs-lookup"><span data-stu-id="f9d1d-132">**Capacity and Count properties**</span></span>

    <span data-ttu-id="f9d1d-133">集合的容量是它可以包含的元素數目。</span><span class="sxs-lookup"><span data-stu-id="f9d1d-133">The capacity of a collection is the number of elements it can contain.</span></span> <span data-ttu-id="f9d1d-134">集合的計數是它實際包含的元素數目。</span><span class="sxs-lookup"><span data-stu-id="f9d1d-134">The count of a collection is the number of elements it actually contains.</span></span> <span data-ttu-id="f9d1d-135">某些集合會隱藏容量或計數，或同時隱藏兩者。</span><span class="sxs-lookup"><span data-stu-id="f9d1d-135">Some collections hide the capacity or the count or both.</span></span>

    <span data-ttu-id="f9d1d-136">達到目前的容量時，大多數集合會自動擴大容量。</span><span class="sxs-lookup"><span data-stu-id="f9d1d-136">Most collections automatically expand in capacity when the current capacity is reached.</span></span> <span data-ttu-id="f9d1d-137">將會重新配置記憶體，並從舊集合將元素複製到新的集合。</span><span class="sxs-lookup"><span data-stu-id="f9d1d-137">The memory is reallocated, and the elements are copied from the old collection to the new one.</span></span> <span data-ttu-id="f9d1d-138">這樣可以減少使用集合所需的程式碼；不過，可能會對集合效能產生負面的影響。</span><span class="sxs-lookup"><span data-stu-id="f9d1d-138">This reduces the code required to use the collection; however, the performance of the collection might be negatively affected.</span></span> <span data-ttu-id="f9d1d-139">例如， <xref:System.Collections.Generic.List%601> 如果小於，則 <xref:System.Collections.Generic.List%601.Count%2A> <xref:System.Collections.Generic.List%601.Capacity%2A> 加入專案是 O (1) 作業。</span><span class="sxs-lookup"><span data-stu-id="f9d1d-139">For example, for <xref:System.Collections.Generic.List%601>, if <xref:System.Collections.Generic.List%601.Count%2A> is less than <xref:System.Collections.Generic.List%601.Capacity%2A>, adding an item is an O(1) operation.</span></span> <span data-ttu-id="f9d1d-140">如果需要增加容量以容納新的元素，則加入專案會變成 O (`n`) 作業，其中 `n` 是 <xref:System.Collections.Generic.List%601.Count%2A> 。</span><span class="sxs-lookup"><span data-stu-id="f9d1d-140">If the capacity needs to be increased to accommodate the new element, adding an item becomes an O(`n`) operation, where `n` is <xref:System.Collections.Generic.List%601.Count%2A>.</span></span> <span data-ttu-id="f9d1d-141">避免多次重新配置造成的效能不佳之最佳方式，是將初始容量設定為集合的預估大小。</span><span class="sxs-lookup"><span data-stu-id="f9d1d-141">The best way to avoid poor performance caused by multiple reallocations is to set the initial capacity to be the estimated size of the collection.</span></span>

    <span data-ttu-id="f9d1d-142"><xref:System.Collections.BitArray> 是特殊的情況；它的容量等同於長度，計數也是。</span><span class="sxs-lookup"><span data-stu-id="f9d1d-142">A <xref:System.Collections.BitArray> is a special case; its capacity is the same as its length, which is the same as its count.</span></span>

- <span data-ttu-id="f9d1d-143">**一致的下限**</span><span class="sxs-lookup"><span data-stu-id="f9d1d-143">**A consistent lower bound**</span></span>

    <span data-ttu-id="f9d1d-144">集合的下限是其第一個元素的索引。</span><span class="sxs-lookup"><span data-stu-id="f9d1d-144">The lower bound of a collection is the index of its first element.</span></span> <span data-ttu-id="f9d1d-145"><xref:System.Collections> 命名空間中的所有索引集合下限皆為零，表示它們為 0 索引。</span><span class="sxs-lookup"><span data-stu-id="f9d1d-145">All indexed collections in the <xref:System.Collections> namespaces have a lower bound of zero, meaning they are 0-indexed.</span></span> <span data-ttu-id="f9d1d-146"><xref:System.Array> 預設的下限為零，但使用建立 **陣列** 類別的實例時，可以定義不同的下限 <xref:System.Array.CreateInstance%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="f9d1d-146"><xref:System.Array> has a lower bound of zero by default, but a different lower bound can be defined when creating an instance of the **Array** class using <xref:System.Array.CreateInstance%2A?displayProperty=nameWithType>.</span></span>

- <span data-ttu-id="f9d1d-147">**從多個執行緒存取的同步** 處理 (<xref:System.Collections> 類別僅) 。</span><span class="sxs-lookup"><span data-stu-id="f9d1d-147">**Synchronization for access from multiple threads** (<xref:System.Collections> classes only).</span></span>

    <span data-ttu-id="f9d1d-148"><xref:System.Collections> 命名空間中的非泛型集合類型，提供一些同步處理的執行緒安全性；通常會透過 <xref:System.Collections.ICollection.SyncRoot%2A> 和 <xref:System.Collections.ICollection.IsSynchronized%2A> 成員公開。</span><span class="sxs-lookup"><span data-stu-id="f9d1d-148">Non-generic collection types in the <xref:System.Collections> namespace provide some thread safety with synchronization; typically exposed through the <xref:System.Collections.ICollection.SyncRoot%2A> and  <xref:System.Collections.ICollection.IsSynchronized%2A> members.</span></span> <span data-ttu-id="f9d1d-149">這些集合不是預設的安全執行緒。</span><span class="sxs-lookup"><span data-stu-id="f9d1d-149">These collections are not thread-safe by default.</span></span> <span data-ttu-id="f9d1d-150">如果您需要可調整且有效地以多執行緒存取集合，請使用 <xref:System.Collections.Concurrent> 命名空間中的其中一個類別，或考慮使用不可變的集合。</span><span class="sxs-lookup"><span data-stu-id="f9d1d-150">If you require scalable and efficient multi-threaded access to a collection, use one of the classes in the <xref:System.Collections.Concurrent> namespace or consider using an immutable collection.</span></span> <span data-ttu-id="f9d1d-151">如需詳細資訊，請參閱[安全執行緒集合](thread-safe/index.md)。</span><span class="sxs-lookup"><span data-stu-id="f9d1d-151">For more information, see [Thread-Safe Collections](thread-safe/index.md).</span></span>

<a name="BKMK_Choosingacollection"></a>
## <a name="choose-a-collection"></a><span data-ttu-id="f9d1d-152">選擇集合</span><span class="sxs-lookup"><span data-stu-id="f9d1d-152">Choose a collection</span></span>

<span data-ttu-id="f9d1d-153">一般情況下，您應該使用泛型集合。</span><span class="sxs-lookup"><span data-stu-id="f9d1d-153">In general, you should use generic collections.</span></span> <span data-ttu-id="f9d1d-154">下表說明一些常見的集合案例，以及您可以為這些案例使用的集合類別。</span><span class="sxs-lookup"><span data-stu-id="f9d1d-154">The following table describes some common collection scenarios and the collection classes you can use for those scenarios.</span></span> <span data-ttu-id="f9d1d-155">如果您是泛型集合的新手，此表格可協助您選擇最適合您工作的泛型集合。</span><span class="sxs-lookup"><span data-stu-id="f9d1d-155">If you are new to generic collections, this table will help you choose the generic collection that works the best for your task.</span></span>

|<span data-ttu-id="f9d1d-156">我想要…</span><span class="sxs-lookup"><span data-stu-id="f9d1d-156">I want to…</span></span>|<span data-ttu-id="f9d1d-157">泛型集合的選項</span><span class="sxs-lookup"><span data-stu-id="f9d1d-157">Generic collection options</span></span>|<span data-ttu-id="f9d1d-158">非泛型集合的選項</span><span class="sxs-lookup"><span data-stu-id="f9d1d-158">Non-generic collection options</span></span>|<span data-ttu-id="f9d1d-159">安全執行緒或固定集合的選項</span><span class="sxs-lookup"><span data-stu-id="f9d1d-159">Thread-safe or immutable collection options</span></span>|
|-|-|-|-|
|<span data-ttu-id="f9d1d-160">儲存項目為成對的索引鍵/值，以供依據索引鍵快速查詢</span><span class="sxs-lookup"><span data-stu-id="f9d1d-160">Store items as key/value pairs for quick look-up by key</span></span>|<xref:System.Collections.Generic.Dictionary%602>|<xref:System.Collections.Hashtable><br /><br /> <span data-ttu-id="f9d1d-161">(成對的機碼/值之集合，依據機碼的雜湊碼加以組織)。</span><span class="sxs-lookup"><span data-stu-id="f9d1d-161">(A collection of key/value pairs that are organized based on the hash code of the key.)</span></span>|<xref:System.Collections.Concurrent.ConcurrentDictionary%602><br /><br /> <xref:System.Collections.ObjectModel.ReadOnlyDictionary%602><br /><br /> <xref:System.Collections.Immutable.ImmutableDictionary%602>|
|<span data-ttu-id="f9d1d-162">依索引存取項目</span><span class="sxs-lookup"><span data-stu-id="f9d1d-162">Access items by index</span></span>|<xref:System.Collections.Generic.List%601>|<xref:System.Array><br /><br /> <xref:System.Collections.ArrayList>|<xref:System.Collections.Immutable.ImmutableList%601><br /><br /> <xref:System.Collections.Immutable.ImmutableArray>|
|<span data-ttu-id="f9d1d-163">先進先出 (FIFO) 地使用項目</span><span class="sxs-lookup"><span data-stu-id="f9d1d-163">Use items first-in-first-out (FIFO)</span></span>|<xref:System.Collections.Generic.Queue%601>|<xref:System.Collections.Queue>|<xref:System.Collections.Concurrent.ConcurrentQueue%601><br /><br /> <xref:System.Collections.Immutable.ImmutableQueue%601>|
|<span data-ttu-id="f9d1d-164">後進先出 (LIFO) 地使用資料</span><span class="sxs-lookup"><span data-stu-id="f9d1d-164">Use data Last-In-First-Out (LIFO)</span></span>|<xref:System.Collections.Generic.Stack%601>|<xref:System.Collections.Stack>|<xref:System.Collections.Concurrent.ConcurrentStack%601><br /><br /> <xref:System.Collections.Immutable.ImmutableStack%601>|
|<span data-ttu-id="f9d1d-165">循序存取項目</span><span class="sxs-lookup"><span data-stu-id="f9d1d-165">Access items sequentially</span></span>|<xref:System.Collections.Generic.LinkedList%601>|<span data-ttu-id="f9d1d-166">不推薦</span><span class="sxs-lookup"><span data-stu-id="f9d1d-166">No recommendation</span></span>|<span data-ttu-id="f9d1d-167">不推薦</span><span class="sxs-lookup"><span data-stu-id="f9d1d-167">No recommendation</span></span>|
|<span data-ttu-id="f9d1d-168">當集合中有項目移除或加入時，收到通知。</span><span class="sxs-lookup"><span data-stu-id="f9d1d-168">Receive notifications when items are removed or added to the collection.</span></span> <span data-ttu-id="f9d1d-169">(實作 <xref:System.ComponentModel.INotifyPropertyChanged> 和 <xref:System.Collections.Specialized.INotifyCollectionChanged>)</span><span class="sxs-lookup"><span data-stu-id="f9d1d-169">(implements <xref:System.ComponentModel.INotifyPropertyChanged> and <xref:System.Collections.Specialized.INotifyCollectionChanged>)</span></span>|<xref:System.Collections.ObjectModel.ObservableCollection%601>|<span data-ttu-id="f9d1d-170">不推薦</span><span class="sxs-lookup"><span data-stu-id="f9d1d-170">No recommendation</span></span>|<span data-ttu-id="f9d1d-171">不推薦</span><span class="sxs-lookup"><span data-stu-id="f9d1d-171">No recommendation</span></span>|
|<span data-ttu-id="f9d1d-172">排序的集合</span><span class="sxs-lookup"><span data-stu-id="f9d1d-172">A sorted collection</span></span>|<xref:System.Collections.Generic.SortedList%602>|<xref:System.Collections.SortedList>|<xref:System.Collections.Immutable.ImmutableSortedDictionary%602><br /><br /> <xref:System.Collections.Immutable.ImmutableSortedSet%601>|
|<span data-ttu-id="f9d1d-173">數學函式的集合</span><span class="sxs-lookup"><span data-stu-id="f9d1d-173">A set for mathematical functions</span></span>|<xref:System.Collections.Generic.HashSet%601><br /><br /> <xref:System.Collections.Generic.SortedSet%601>|<span data-ttu-id="f9d1d-174">不推薦</span><span class="sxs-lookup"><span data-stu-id="f9d1d-174">No recommendation</span></span>|<xref:System.Collections.Immutable.ImmutableHashSet%601><br /><br /> <xref:System.Collections.Immutable.ImmutableSortedSet%601>|

### <a name="algorithmic-complexity-of-collections"></a><span data-ttu-id="f9d1d-175">集合的演算法複雜度</span><span class="sxs-lookup"><span data-stu-id="f9d1d-175">Algorithmic complexity of collections</span></span>

<span data-ttu-id="f9d1d-176">選擇 [集合類別](selecting-a-collection-class.md)時，值得考慮效能可能會有取捨。</span><span class="sxs-lookup"><span data-stu-id="f9d1d-176">When choosing a [collection class](selecting-a-collection-class.md), it is worth considering potential tradeoffs in performance.</span></span> <span data-ttu-id="f9d1d-177">您可以使用下表參考不同的可變動集合類型與其對應的不可變對應專案在演算法複雜度中的比較方式。</span><span class="sxs-lookup"><span data-stu-id="f9d1d-177">Use the following table to reference how various mutable collection types compare in algorithmic complexity to their corresponding immutable counterparts.</span></span> <span data-ttu-id="f9d1d-178">不可變的集合類型通常較不具效能，但卻提供了永久性，這通常是有效的比較優點。</span><span class="sxs-lookup"><span data-stu-id="f9d1d-178">Often immutable collection types are less performant but provide immutability - which is often a valid comparative benefit.</span></span>

| <span data-ttu-id="f9d1d-179">可變動</span><span class="sxs-lookup"><span data-stu-id="f9d1d-179">Mutable</span></span>                   | <span data-ttu-id="f9d1d-180">攤 銷</span><span class="sxs-lookup"><span data-stu-id="f9d1d-180">Amortized</span></span>  | <span data-ttu-id="f9d1d-181">最糟的情況</span><span class="sxs-lookup"><span data-stu-id="f9d1d-181">Worst Case</span></span>                | <span data-ttu-id="f9d1d-182">固定</span><span class="sxs-lookup"><span data-stu-id="f9d1d-182">Immutable</span></span>                          | <span data-ttu-id="f9d1d-183">複雜度</span><span class="sxs-lookup"><span data-stu-id="f9d1d-183">Complexity</span></span> |
|---------------------------|------------|---------------------------|------------------------------------|------------|
| `Stack<T>.Push`           | <span data-ttu-id="f9d1d-184">O (1) </span><span class="sxs-lookup"><span data-stu-id="f9d1d-184">O(1)</span></span>       | <span data-ttu-id="f9d1d-185">O (`n`) </span><span class="sxs-lookup"><span data-stu-id="f9d1d-185">O(`n`)</span></span>                    | `ImmutableStack<T>.Push`           | <span data-ttu-id="f9d1d-186">O (1) </span><span class="sxs-lookup"><span data-stu-id="f9d1d-186">O(1)</span></span>       |
| `Queue<T>.Enqueue`        | <span data-ttu-id="f9d1d-187">O (1) </span><span class="sxs-lookup"><span data-stu-id="f9d1d-187">O(1)</span></span>       | <span data-ttu-id="f9d1d-188">O (`n`) </span><span class="sxs-lookup"><span data-stu-id="f9d1d-188">O(`n`)</span></span>                    | `ImmutableQueue<T>.Enqueue`        | <span data-ttu-id="f9d1d-189">O (1) </span><span class="sxs-lookup"><span data-stu-id="f9d1d-189">O(1)</span></span>       |
| `List<T>.Add`             | <span data-ttu-id="f9d1d-190">O (1) </span><span class="sxs-lookup"><span data-stu-id="f9d1d-190">O(1)</span></span>       | <span data-ttu-id="f9d1d-191">O (`n`) </span><span class="sxs-lookup"><span data-stu-id="f9d1d-191">O(`n`)</span></span>                    | `ImmutableList<T>.Add`             | <span data-ttu-id="f9d1d-192">O (記錄 `n`) </span><span class="sxs-lookup"><span data-stu-id="f9d1d-192">O(log `n`)</span></span> |
| `List<T>.Item[Int32]`     | <span data-ttu-id="f9d1d-193">O (1) </span><span class="sxs-lookup"><span data-stu-id="f9d1d-193">O(1)</span></span>       | <span data-ttu-id="f9d1d-194">O (1) </span><span class="sxs-lookup"><span data-stu-id="f9d1d-194">O(1)</span></span>                      | `ImmutableList<T>.Item[Int32]`     | <span data-ttu-id="f9d1d-195">O (記錄 `n`) </span><span class="sxs-lookup"><span data-stu-id="f9d1d-195">O(log `n`)</span></span> |
| `List<T>.Enumerator`      | <span data-ttu-id="f9d1d-196">O (`n`) </span><span class="sxs-lookup"><span data-stu-id="f9d1d-196">O(`n`)</span></span>     | <span data-ttu-id="f9d1d-197">O (`n`) </span><span class="sxs-lookup"><span data-stu-id="f9d1d-197">O(`n`)</span></span>                    | `ImmutableList<T>.Enumerator`      | <span data-ttu-id="f9d1d-198">O (`n`) </span><span class="sxs-lookup"><span data-stu-id="f9d1d-198">O(`n`)</span></span>     |
| <span data-ttu-id="f9d1d-199">`HashSet<T>.Add`查找</span><span class="sxs-lookup"><span data-stu-id="f9d1d-199">`HashSet<T>.Add`, lookup</span></span>  | <span data-ttu-id="f9d1d-200">O (1) </span><span class="sxs-lookup"><span data-stu-id="f9d1d-200">O(1)</span></span>       | <span data-ttu-id="f9d1d-201">O (`n`) </span><span class="sxs-lookup"><span data-stu-id="f9d1d-201">O(`n`)</span></span>                    | `ImmutableHashSet<T>.Add`          | <span data-ttu-id="f9d1d-202">O (記錄 `n`) </span><span class="sxs-lookup"><span data-stu-id="f9d1d-202">O(log `n`)</span></span> |
| `SortedSet<T>.Add`        | <span data-ttu-id="f9d1d-203">O (記錄 `n`) </span><span class="sxs-lookup"><span data-stu-id="f9d1d-203">O(log `n`)</span></span> | <span data-ttu-id="f9d1d-204">O (`n`) </span><span class="sxs-lookup"><span data-stu-id="f9d1d-204">O(`n`)</span></span>                    | `ImmutableSortedSet<T>.Add`        | <span data-ttu-id="f9d1d-205">O (記錄 `n`) </span><span class="sxs-lookup"><span data-stu-id="f9d1d-205">O(log `n`)</span></span> |
| `Dictionary<T>.Add`       | <span data-ttu-id="f9d1d-206">O (1) </span><span class="sxs-lookup"><span data-stu-id="f9d1d-206">O(1)</span></span>       | <span data-ttu-id="f9d1d-207">O (`n`) </span><span class="sxs-lookup"><span data-stu-id="f9d1d-207">O(`n`)</span></span>                    | `ImmutableDictionary<T>.Add`       | <span data-ttu-id="f9d1d-208">O (記錄 `n`) </span><span class="sxs-lookup"><span data-stu-id="f9d1d-208">O(log `n`)</span></span> |
| <span data-ttu-id="f9d1d-209">`Dictionary<T>` 查找</span><span class="sxs-lookup"><span data-stu-id="f9d1d-209">`Dictionary<T>` lookup</span></span>    | <span data-ttu-id="f9d1d-210">O (1) </span><span class="sxs-lookup"><span data-stu-id="f9d1d-210">O(1)</span></span>       | <span data-ttu-id="f9d1d-211">O (1) –或嚴格的 (`n`) </span><span class="sxs-lookup"><span data-stu-id="f9d1d-211">O(1) – or strictly O(`n`)</span></span> | <span data-ttu-id="f9d1d-212">`ImmutableDictionary<T>` 查找</span><span class="sxs-lookup"><span data-stu-id="f9d1d-212">`ImmutableDictionary<T>` lookup</span></span>    | <span data-ttu-id="f9d1d-213">O (記錄 `n`) </span><span class="sxs-lookup"><span data-stu-id="f9d1d-213">O(log `n`)</span></span> |
| `SortedDictionary<T>.Add` | <span data-ttu-id="f9d1d-214">O (記錄 `n`) </span><span class="sxs-lookup"><span data-stu-id="f9d1d-214">O(log `n`)</span></span> | <span data-ttu-id="f9d1d-215">O (`n` 記錄 `n`) </span><span class="sxs-lookup"><span data-stu-id="f9d1d-215">O(`n` log `n`)</span></span>            | `ImmutableSortedDictionary<T>.Add` | <span data-ttu-id="f9d1d-216">O (記錄 `n`) </span><span class="sxs-lookup"><span data-stu-id="f9d1d-216">O(log `n`)</span></span> |

<span data-ttu-id="f9d1d-217">您 `List<T>` 可以使用迴圈或迴圈來有效率地列舉 `for` `foreach` 。</span><span class="sxs-lookup"><span data-stu-id="f9d1d-217">A `List<T>` can be efficiently enumerated using either a `for` loop or a `foreach` loop.</span></span> <span data-ttu-id="f9d1d-218">不過，在 `ImmutableList<T>` 迴圈內執行的作業不佳 `for` ，因為它的索引子的 O (記錄 `n`) 時間。</span><span class="sxs-lookup"><span data-stu-id="f9d1d-218">An `ImmutableList<T>`, however, does a poor job inside a `for` loop, due to the O(log `n`) time for its indexer.</span></span> <span data-ttu-id="f9d1d-219">`ImmutableList<T>`使用 `foreach` 迴圈來列舉會很有效率，因為 `ImmutableList<T>` 它會使用二進位樹狀結構來儲存其資料，而不是像使用一樣的簡單陣列 `List<T>` 。</span><span class="sxs-lookup"><span data-stu-id="f9d1d-219">Enumerating an `ImmutableList<T>` using a `foreach` loop is efficient because `ImmutableList<T>` uses a binary tree to store its data instead of a simple array like `List<T>` uses.</span></span> <span data-ttu-id="f9d1d-220">陣列可非常快速地編制索引，而二進位樹狀結構必須在找到具有所需索引的節點時才開始。</span><span class="sxs-lookup"><span data-stu-id="f9d1d-220">An array can be very quickly indexed into, whereas a binary tree must be walked down until the node with the desired index is found.</span></span>

<span data-ttu-id="f9d1d-221">此外， `SortedSet<T>` 的複雜性與相同 `ImmutableSortedSet<T>` 。</span><span class="sxs-lookup"><span data-stu-id="f9d1d-221">Additionally, `SortedSet<T>` has the same complexity as `ImmutableSortedSet<T>`.</span></span> <span data-ttu-id="f9d1d-222">這是因為它們都使用二進位樹狀結構。</span><span class="sxs-lookup"><span data-stu-id="f9d1d-222">That's because they both use binary trees.</span></span> <span data-ttu-id="f9d1d-223">當然，主要的差異在於 `ImmutableSortedSet<T>` 使用不可變的二進位樹狀目錄。</span><span class="sxs-lookup"><span data-stu-id="f9d1d-223">The significant difference, of course, is that `ImmutableSortedSet<T>` uses an immutable binary tree.</span></span> <span data-ttu-id="f9d1d-224">因為 `ImmutableSortedSet<T>` 也提供可 <xref:System.Collections.Immutable.ImmutableSortedSet%601.Builder?displayProperty=nameWithType> 允許變動的類別，所以您可以同時擁有永久性和效能。</span><span class="sxs-lookup"><span data-stu-id="f9d1d-224">Since `ImmutableSortedSet<T>` also offers a <xref:System.Collections.Immutable.ImmutableSortedSet%601.Builder?displayProperty=nameWithType> class that allows mutation, you can have both immutability and performance.</span></span>

<a name="BKMK_RelatedTopics"></a>
## <a name="related-topics"></a><span data-ttu-id="f9d1d-225">相關主題</span><span class="sxs-lookup"><span data-stu-id="f9d1d-225">Related Topics</span></span>

|<span data-ttu-id="f9d1d-226">標題</span><span class="sxs-lookup"><span data-stu-id="f9d1d-226">Title</span></span>|<span data-ttu-id="f9d1d-227">說明</span><span class="sxs-lookup"><span data-stu-id="f9d1d-227">Description</span></span>|
|-----------|-----------------|
|[<span data-ttu-id="f9d1d-228">選取集合類別</span><span class="sxs-lookup"><span data-stu-id="f9d1d-228">Selecting a Collection Class</span></span>](selecting-a-collection-class.md)|<span data-ttu-id="f9d1d-229">說明不同的集合，並協助您選取用於您案例的集合。</span><span class="sxs-lookup"><span data-stu-id="f9d1d-229">Describes the different collections and helps you select one for your scenario.</span></span>|
|[<span data-ttu-id="f9d1d-230">常用的集合類型</span><span class="sxs-lookup"><span data-stu-id="f9d1d-230">Commonly Used Collection Types</span></span>](commonly-used-collection-types.md)|<span data-ttu-id="f9d1d-231">說明常用的泛型與非泛型集合類型，例如 <xref:System.Array?displayProperty=nameWithType>、<xref:System.Collections.Generic.List%601?displayProperty=nameWithType> 和 <xref:System.Collections.Generic.Dictionary%602?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="f9d1d-231">Describes commonly used generic and nongeneric collection types such as <xref:System.Array?displayProperty=nameWithType>, <xref:System.Collections.Generic.List%601?displayProperty=nameWithType>, and <xref:System.Collections.Generic.Dictionary%602?displayProperty=nameWithType>.</span></span>|
|[<span data-ttu-id="f9d1d-232">使用泛型集合的時機</span><span class="sxs-lookup"><span data-stu-id="f9d1d-232">When to Use Generic Collections</span></span>](when-to-use-generic-collections.md)|<span data-ttu-id="f9d1d-233">說明泛型集合類型的用法。</span><span class="sxs-lookup"><span data-stu-id="f9d1d-233">Discusses the use of generic collection types.</span></span>|
|[<span data-ttu-id="f9d1d-234">集合中的比較和排序</span><span class="sxs-lookup"><span data-stu-id="f9d1d-234">Comparisons and Sorts Within Collections</span></span>](comparisons-and-sorts-within-collections.md)|<span data-ttu-id="f9d1d-235">討論在集合中使用相等比較和排序比較。</span><span class="sxs-lookup"><span data-stu-id="f9d1d-235">Discusses the use of equality comparisons and sorting comparisons in collections.</span></span>|
|[<span data-ttu-id="f9d1d-236">排序的集合類型</span><span class="sxs-lookup"><span data-stu-id="f9d1d-236">Sorted Collection Types</span></span>](sorted-collection-types.md)|<span data-ttu-id="f9d1d-237">說明經過排序之集合的效能與特性</span><span class="sxs-lookup"><span data-stu-id="f9d1d-237">Describes sorted collections performance and characteristics</span></span>|
|[<span data-ttu-id="f9d1d-238">Hashtable 和 Dictionary 集合類型</span><span class="sxs-lookup"><span data-stu-id="f9d1d-238">Hashtable and Dictionary Collection Types</span></span>](hashtable-and-dictionary-collection-types.md)|<span data-ttu-id="f9d1d-239">說明泛型和非泛型雜湊字典類型的功能。</span><span class="sxs-lookup"><span data-stu-id="f9d1d-239">Describes the features of generic and non-generic hash-based dictionary types.</span></span>|
|[<span data-ttu-id="f9d1d-240">安全線程集合</span><span class="sxs-lookup"><span data-stu-id="f9d1d-240">Thread-Safe Collections</span></span>](thread-safe/index.md)|<span data-ttu-id="f9d1d-241">說明如 <xref:System.Collections.Concurrent.BlockingCollection%601?displayProperty=nameWithType> 和 <xref:System.Collections.Concurrent.ConcurrentBag%601?displayProperty=nameWithType> 這類集合類型，這類類型支援從多個執行緒進行安全有效率的並行存取。</span><span class="sxs-lookup"><span data-stu-id="f9d1d-241">Describes collection types such as <xref:System.Collections.Concurrent.BlockingCollection%601?displayProperty=nameWithType> and <xref:System.Collections.Concurrent.ConcurrentBag%601?displayProperty=nameWithType> that support safe and efficient concurrent access from multiple threads.</span></span>|
|<span data-ttu-id="f9d1d-242">System.Collections.Immutable</span><span class="sxs-lookup"><span data-stu-id="f9d1d-242">System.Collections.Immutable</span></span>|<span data-ttu-id="f9d1d-243">介紹不可變的集合並提供集合類型的連結。</span><span class="sxs-lookup"><span data-stu-id="f9d1d-243">Introduces the immutable collections and provides links to the collection types.</span></span>|

<a name="BKMK_Reference"></a>
## <a name="reference"></a><span data-ttu-id="f9d1d-244">參考</span><span class="sxs-lookup"><span data-stu-id="f9d1d-244">Reference</span></span>
<xref:System.Array?displayProperty=nameWithType>
<xref:System.Collections?displayProperty=nameWithType>
<xref:System.Collections.Concurrent?displayProperty=nameWithType>
<xref:System.Collections.Generic?displayProperty=nameWithType>
<xref:System.Collections.Specialized?displayProperty=nameWithType>
<xref:System.Linq?displayProperty=nameWithType>
<xref:System.Collections.Immutable>
