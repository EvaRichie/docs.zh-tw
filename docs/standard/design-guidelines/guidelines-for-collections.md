---
title: 集合方針
ms.date: 10/22/2008
ms.assetid: 297b8f1d-b11f-4dc6-960a-8e990817304e
ms.openlocfilehash: 2306462d933e71d0d23021a0e036e8cc23100c68
ms.sourcegitcommit: 965a5af7918acb0a3fd3baf342e15d511ef75188
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 11/18/2020
ms.locfileid: "94821082"
---
# <a name="guidelines-for-collections"></a><span data-ttu-id="36d20-102">集合方針</span><span class="sxs-lookup"><span data-stu-id="36d20-102">Guidelines for Collections</span></span>
<span data-ttu-id="36d20-103">任何專為操作一組具有一般特性的物件而設計的型別，都可以被視為一個集合。</span><span class="sxs-lookup"><span data-stu-id="36d20-103">Any type designed specifically to manipulate a group of objects having some common characteristic can be considered a collection.</span></span> <span data-ttu-id="36d20-104">這類型別幾乎一律適合用來執行 <xref:System.Collections.IEnumerable> 或 <xref:System.Collections.Generic.IEnumerable%601> ，所以在本節中，我們只會考慮將這些介面的其中一個或兩個都實作為集合的類型。</span><span class="sxs-lookup"><span data-stu-id="36d20-104">It is almost always appropriate for such types to implement <xref:System.Collections.IEnumerable> or <xref:System.Collections.Generic.IEnumerable%601>, so in this section we only consider types implementing one or both of those interfaces to be collections.</span></span>

 <span data-ttu-id="36d20-105">❌ 請勿在公用 Api 中使用弱式型別集合。</span><span class="sxs-lookup"><span data-stu-id="36d20-105">❌ DO NOT use weakly typed collections in public APIs.</span></span>

 <span data-ttu-id="36d20-106">所有傳回值的型別和代表收集項目的參數都應該是確切的專案類型，而不是它的任何基底類型 (這只適用于集合) 的公用成員。</span><span class="sxs-lookup"><span data-stu-id="36d20-106">The type of all return values and parameters representing collection items should be the exact item type, not any of its base types (this applies only to public members of the collection).</span></span>

 <span data-ttu-id="36d20-107">❌ 請勿 <xref:System.Collections.ArrayList> <xref:System.Collections.Generic.List%601> 在公用 api 中使用或。</span><span class="sxs-lookup"><span data-stu-id="36d20-107">❌ DO NOT use <xref:System.Collections.ArrayList> or <xref:System.Collections.Generic.List%601> in public APIs.</span></span>

 <span data-ttu-id="36d20-108">這些類型是設計用來內部執行的資料結構，而不是公用 Api。</span><span class="sxs-lookup"><span data-stu-id="36d20-108">These types are data structures designed to be used in internal implementation, not in public APIs.</span></span> <span data-ttu-id="36d20-109">`List<T>` 已針對效能和強大功能進行優化，以 cleanness Api 和彈性。</span><span class="sxs-lookup"><span data-stu-id="36d20-109">`List<T>` is optimized for performance and power at the cost of cleanness of the APIs and flexibility.</span></span> <span data-ttu-id="36d20-110">例如，如果您傳回 `List<T>` ，當用戶端程式代碼修改集合時，您將無法接收通知。</span><span class="sxs-lookup"><span data-stu-id="36d20-110">For example, if you return `List<T>`, you will not ever be able to receive notifications when client code modifies the collection.</span></span> <span data-ttu-id="36d20-111">此外，也 `List<T>` 會公開許多 <xref:System.Collections.Generic.List%601.BinarySearch%2A> 在許多情況下都不實用或適用的成員（例如）。</span><span class="sxs-lookup"><span data-stu-id="36d20-111">Also, `List<T>` exposes many members, such as <xref:System.Collections.Generic.List%601.BinarySearch%2A>, that are not useful or applicable in many scenarios.</span></span> <span data-ttu-id="36d20-112">下列兩節描述特別針對公用 Api 中使用所設計)  (抽象類別型。</span><span class="sxs-lookup"><span data-stu-id="36d20-112">The following two sections describe types (abstractions) designed specifically for use in public APIs.</span></span>

 <span data-ttu-id="36d20-113">❌ 請勿 `Hashtable` `Dictionary<TKey,TValue>` 在公用 api 中使用或。</span><span class="sxs-lookup"><span data-stu-id="36d20-113">❌ DO NOT use `Hashtable` or `Dictionary<TKey,TValue>` in public APIs.</span></span>

 <span data-ttu-id="36d20-114">這些類型是設計用來內部執行的資料結構。</span><span class="sxs-lookup"><span data-stu-id="36d20-114">These types are data structures designed to be used in internal implementation.</span></span> <span data-ttu-id="36d20-115">公用 Api 應該使用 <xref:System.Collections.IDictionary> 、 `IDictionary <TKey, TValue>` 或執行一或兩個介面的自訂類型。</span><span class="sxs-lookup"><span data-stu-id="36d20-115">Public APIs should use <xref:System.Collections.IDictionary>, `IDictionary <TKey, TValue>`, or a custom type implementing one or both of the interfaces.</span></span>

 <span data-ttu-id="36d20-116">❌ 請勿使用 <xref:System.Collections.Generic.IEnumerator%601> 、 <xref:System.Collections.IEnumerator> 或任何其他實作為這些介面的型別，除了方法的傳回型別以外 `GetEnumerator` 。</span><span class="sxs-lookup"><span data-stu-id="36d20-116">❌ DO NOT use <xref:System.Collections.Generic.IEnumerator%601>, <xref:System.Collections.IEnumerator>, or any other type that implements either of these interfaces, except as the return type of a `GetEnumerator` method.</span></span>

 <span data-ttu-id="36d20-117">從以外的方法傳回列舉值的類型， `GetEnumerator` 不能與語句一起使用 `foreach` 。</span><span class="sxs-lookup"><span data-stu-id="36d20-117">Types returning enumerators from methods other than `GetEnumerator` cannot be used with the `foreach` statement.</span></span>

 <span data-ttu-id="36d20-118">❌ 請勿同時 `IEnumerator<T>` `IEnumerable<T>` 在相同的類型上執行和。</span><span class="sxs-lookup"><span data-stu-id="36d20-118">❌ DO NOT implement both `IEnumerator<T>` and `IEnumerable<T>` on the same type.</span></span> <span data-ttu-id="36d20-119">這同樣適用于非泛型介面 `IEnumerator` 和 `IEnumerable` 。</span><span class="sxs-lookup"><span data-stu-id="36d20-119">The same applies to the nongeneric interfaces `IEnumerator` and `IEnumerable`.</span></span>

## <a name="collection-parameters"></a><span data-ttu-id="36d20-120">集合參數</span><span class="sxs-lookup"><span data-stu-id="36d20-120">Collection Parameters</span></span>
 <span data-ttu-id="36d20-121">✔️請盡可能使用最少的特製化型別作為參數類型。</span><span class="sxs-lookup"><span data-stu-id="36d20-121">✔️ DO use the least-specialized type possible as a parameter type.</span></span> <span data-ttu-id="36d20-122">大部分採用集合做為參數的成員都會使用 `IEnumerable<T>` 介面。</span><span class="sxs-lookup"><span data-stu-id="36d20-122">Most members taking collections as parameters use the `IEnumerable<T>` interface.</span></span>

 <span data-ttu-id="36d20-123">❌ 請避免使用 <xref:System.Collections.Generic.ICollection%601> 或 <xref:System.Collections.ICollection> 作為參數，只是用來存取 `Count` 屬性。</span><span class="sxs-lookup"><span data-stu-id="36d20-123">❌ AVOID using <xref:System.Collections.Generic.ICollection%601> or <xref:System.Collections.ICollection> as a parameter just to access the `Count` property.</span></span>

 <span data-ttu-id="36d20-124">相反地，請考慮使用 `IEnumerable<T>` 或 `IEnumerable` ，以動態方式檢查物件是否為 `ICollection<T>` 或 `ICollection` 。</span><span class="sxs-lookup"><span data-stu-id="36d20-124">Instead, consider using `IEnumerable<T>` or `IEnumerable` and dynamically checking whether the object implements `ICollection<T>` or `ICollection`.</span></span>

## <a name="collection-properties-and-return-values"></a><span data-ttu-id="36d20-125">集合屬性和傳回值</span><span class="sxs-lookup"><span data-stu-id="36d20-125">Collection Properties and Return Values</span></span>
 <span data-ttu-id="36d20-126">❌ 請勿提供可設定的集合屬性。</span><span class="sxs-lookup"><span data-stu-id="36d20-126">❌ DO NOT provide settable collection properties.</span></span>

 <span data-ttu-id="36d20-127">使用者可以先清除集合，然後加入新的內容，以取代集合的內容。</span><span class="sxs-lookup"><span data-stu-id="36d20-127">Users can replace the contents of the collection by clearing the collection first and then adding the new contents.</span></span> <span data-ttu-id="36d20-128">如果將整個集合取代為常見的案例，請考慮在 `AddRange` 集合上提供方法。</span><span class="sxs-lookup"><span data-stu-id="36d20-128">If replacing the whole collection is a common scenario, consider providing the `AddRange` method on the collection.</span></span>

 <span data-ttu-id="36d20-129">✔️請使用 `Collection<T>` 或的子類別 `Collection<T>` ，以取得代表讀取/寫入集合的屬性或傳回值。</span><span class="sxs-lookup"><span data-stu-id="36d20-129">✔️ DO use `Collection<T>` or a subclass of `Collection<T>` for properties or return values representing read/write collections.</span></span>

 <span data-ttu-id="36d20-130">如果不 `Collection<T>` 符合某些需求 (例如，集合不能實 <xref:System.Collections.IList>) ，請執行、或來使用自訂集合 `IEnumerable<T>` `ICollection<T>` <xref:System.Collections.Generic.IList%601> 。</span><span class="sxs-lookup"><span data-stu-id="36d20-130">If `Collection<T>` does not meet some requirement (e.g., the collection must not implement <xref:System.Collections.IList>), use a custom collection by implementing `IEnumerable<T>`, `ICollection<T>`, or <xref:System.Collections.Generic.IList%601>.</span></span>

 <span data-ttu-id="36d20-131">✔️請使用 <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> 、或的子類別， `ReadOnlyCollection<T>` 或在少數案例中， `IEnumerable<T>` 代表唯讀集合的屬性或傳回值。</span><span class="sxs-lookup"><span data-stu-id="36d20-131">✔️ DO use <xref:System.Collections.ObjectModel.ReadOnlyCollection%601>, a subclass of `ReadOnlyCollection<T>`, or in rare cases `IEnumerable<T>` for properties or return values representing read-only collections.</span></span>

 <span data-ttu-id="36d20-132">一般來說，偏好使用 `ReadOnlyCollection<T>` 。</span><span class="sxs-lookup"><span data-stu-id="36d20-132">In general, prefer `ReadOnlyCollection<T>`.</span></span> <span data-ttu-id="36d20-133">如果它不符合某些需求 (例如，集合不能實 `IList`) ，請執行、或來使用自訂集合 `IEnumerable<T>` `ICollection<T>` `IList<T>` 。</span><span class="sxs-lookup"><span data-stu-id="36d20-133">If it does not meet some requirement (e.g., the collection must not implement `IList`), use a custom collection by implementing `IEnumerable<T>`, `ICollection<T>`, or `IList<T>`.</span></span> <span data-ttu-id="36d20-134">如果您執行的是自訂唯讀集合，則會執行， `ICollection<T>.IsReadOnly` 以傳回 `true` 。</span><span class="sxs-lookup"><span data-stu-id="36d20-134">If you do implement a custom read-only collection, implement `ICollection<T>.IsReadOnly` to return `true`.</span></span>

 <span data-ttu-id="36d20-135">如果您確定您要支援的唯一案例是僅向前反覆運算，您可以直接使用 `IEnumerable<T>` 。</span><span class="sxs-lookup"><span data-stu-id="36d20-135">In cases where you are sure that the only scenario you will ever want to support is forward-only iteration, you can simply use `IEnumerable<T>`.</span></span>

 <span data-ttu-id="36d20-136">✔️考慮使用泛型基底集合的子類別，而不是直接使用集合。</span><span class="sxs-lookup"><span data-stu-id="36d20-136">✔️ CONSIDER using subclasses of generic base collections instead of using the collections directly.</span></span>

 <span data-ttu-id="36d20-137">這可讓您取得更好的名稱，以及新增不存在於基底集合類型上的 helper 成員。</span><span class="sxs-lookup"><span data-stu-id="36d20-137">This allows for a better name and for adding helper members that are not present on the base collection types.</span></span> <span data-ttu-id="36d20-138">這特別適用于高層級 Api。</span><span class="sxs-lookup"><span data-stu-id="36d20-138">This is especially applicable to high-level APIs.</span></span>

 <span data-ttu-id="36d20-139">✔️考慮 `Collection<T>` `ReadOnlyCollection<T>` 從非常常用的方法和屬性傳回或的子類別。</span><span class="sxs-lookup"><span data-stu-id="36d20-139">✔️ CONSIDER returning a subclass of `Collection<T>` or `ReadOnlyCollection<T>` from very commonly used methods and properties.</span></span>

 <span data-ttu-id="36d20-140">這可讓您在未來加入 helper 方法或變更集合的執行。</span><span class="sxs-lookup"><span data-stu-id="36d20-140">This will make it possible for you to add helper methods or change the collection implementation in the future.</span></span>

 <span data-ttu-id="36d20-141">✔️如果儲存在集合中的專案具有唯一的索引鍵 (名稱、識別碼等 ) ，請考慮使用索引集合。</span><span class="sxs-lookup"><span data-stu-id="36d20-141">✔️ CONSIDER using a keyed collection if the items stored in the collection have unique keys (names, IDs, etc.).</span></span> <span data-ttu-id="36d20-142">索引集合是可由整數和索引鍵編制索引的集合，通常是藉由繼承自來執行 `KeyedCollection<TKey,TItem>` 。</span><span class="sxs-lookup"><span data-stu-id="36d20-142">Keyed collections are collections that can be indexed by both an integer and a key and are usually implemented by inheriting from `KeyedCollection<TKey,TItem>`.</span></span>

 <span data-ttu-id="36d20-143">索引集合通常會有較大的記憶體佔用量，如果記憶體額外負荷超過擁有金鑰的優點，則不應使用。</span><span class="sxs-lookup"><span data-stu-id="36d20-143">Keyed collections usually have larger memory footprints and should not be used if the memory overhead outweighs the benefits of having the keys.</span></span>

 <span data-ttu-id="36d20-144">❌ 請勿從集合屬性或傳回集合的方法傳回 null 值。</span><span class="sxs-lookup"><span data-stu-id="36d20-144">❌ DO NOT return null values from collection properties or from methods returning collections.</span></span> <span data-ttu-id="36d20-145">改為傳回空集合或空的陣列。</span><span class="sxs-lookup"><span data-stu-id="36d20-145">Return an empty collection or an empty array instead.</span></span>

 <span data-ttu-id="36d20-146">一般規則是 null 和空白 (0 專案) 集合或陣列應視為相同。</span><span class="sxs-lookup"><span data-stu-id="36d20-146">The general rule is that null and empty (0 item) collections or arrays should be treated the same.</span></span>

### <a name="snapshots-versus-live-collections"></a><span data-ttu-id="36d20-147">快照集與即時集合</span><span class="sxs-lookup"><span data-stu-id="36d20-147">Snapshots Versus Live Collections</span></span>
 <span data-ttu-id="36d20-148">代表某個時間點狀態的集合稱為快照集集合。</span><span class="sxs-lookup"><span data-stu-id="36d20-148">Collections representing a state at some point in time are called snapshot collections.</span></span> <span data-ttu-id="36d20-149">例如，包含資料庫查詢所傳回之資料列的集合將會是快照集。</span><span class="sxs-lookup"><span data-stu-id="36d20-149">For example, a collection containing rows returned from a database query would be a snapshot.</span></span> <span data-ttu-id="36d20-150">一律代表目前狀態的集合稱為即時集合。</span><span class="sxs-lookup"><span data-stu-id="36d20-150">Collections that always represent the current state are called live collections.</span></span> <span data-ttu-id="36d20-151">例如， `ComboBox` 專案集合是即時集合。</span><span class="sxs-lookup"><span data-stu-id="36d20-151">For example, a collection of `ComboBox` items is a live collection.</span></span>

 <span data-ttu-id="36d20-152">❌ 請勿從屬性傳回快照集集合。</span><span class="sxs-lookup"><span data-stu-id="36d20-152">❌ DO NOT return snapshot collections from properties.</span></span> <span data-ttu-id="36d20-153">屬性應該會傳回即時集合。</span><span class="sxs-lookup"><span data-stu-id="36d20-153">Properties should return live collections.</span></span>

 <span data-ttu-id="36d20-154">屬性 getter 應該是非常輕量的作業。</span><span class="sxs-lookup"><span data-stu-id="36d20-154">Property getters should be very lightweight operations.</span></span> <span data-ttu-id="36d20-155">傳回快照集需要在 O (n) 作業中建立內部集合的複本。</span><span class="sxs-lookup"><span data-stu-id="36d20-155">Returning a snapshot requires creating a copy of an internal collection in an O(n) operation.</span></span>

 <span data-ttu-id="36d20-156">✔️請使用快照集集合或即時 `IEnumerable<T>` (或它的子類型) 來表示變動 (的集合，也就是可以變更，而不需要明確地修改集合) 。</span><span class="sxs-lookup"><span data-stu-id="36d20-156">✔️ DO use either a snapshot collection or a live `IEnumerable<T>` (or its subtype) to represent collections that are volatile (i.e., that can change without explicitly modifying the collection).</span></span>

 <span data-ttu-id="36d20-157">一般來說，代表共用資源的所有集合 (例如，目錄) 中的檔案都是暫時性的。</span><span class="sxs-lookup"><span data-stu-id="36d20-157">In general, all collections representing a shared resource (e.g., files in a directory) are volatile.</span></span> <span data-ttu-id="36d20-158">這類集合很難或無法實作為即時集合，除非實作為僅向前的列舉值。</span><span class="sxs-lookup"><span data-stu-id="36d20-158">Such collections are very difficult or impossible to implement as live collections unless the implementation is simply a forward-only enumerator.</span></span>

## <a name="choosing-between-arrays-and-collections"></a><span data-ttu-id="36d20-159">在陣列和集合之間進行選擇</span><span class="sxs-lookup"><span data-stu-id="36d20-159">Choosing Between Arrays and Collections</span></span>
 <span data-ttu-id="36d20-160">✔️會偏好陣列的集合。</span><span class="sxs-lookup"><span data-stu-id="36d20-160">✔️ DO prefer collections over arrays.</span></span>

 <span data-ttu-id="36d20-161">集合可讓您更充分掌控內容、可以隨時間演進，而且更容易使用。</span><span class="sxs-lookup"><span data-stu-id="36d20-161">Collections provide more control over contents, can evolve over time, and are more usable.</span></span> <span data-ttu-id="36d20-162">此外，不建議針對唯讀案例使用陣列，因為複製陣列的成本很高。</span><span class="sxs-lookup"><span data-stu-id="36d20-162">In addition, using arrays for read-only scenarios is discouraged because the cost of cloning the array is prohibitive.</span></span> <span data-ttu-id="36d20-163">可用性研究顯示某些開發人員更熟悉使用以集合為基礎的 Api。</span><span class="sxs-lookup"><span data-stu-id="36d20-163">Usability studies have shown that some developers feel more comfortable using collection-based APIs.</span></span>

 <span data-ttu-id="36d20-164">但是，如果您正在開發低層級的 Api，則使用陣列來進行讀寫案例可能比較理想。</span><span class="sxs-lookup"><span data-stu-id="36d20-164">However, if you are developing low-level APIs, it might be better to use arrays for read-write scenarios.</span></span> <span data-ttu-id="36d20-165">陣列擁有較小的記憶體使用量，有助於減少工作集，而對陣列中的元素的存取會更快，因為它是由執行時間優化。</span><span class="sxs-lookup"><span data-stu-id="36d20-165">Arrays have a smaller memory footprint, which helps reduce the working set, and access to elements in an array is faster because it is optimized by the runtime.</span></span>

 <span data-ttu-id="36d20-166">✔️考慮使用低層級 Api 中的陣列，將記憶體耗用量降至最低，並將效能最大化。</span><span class="sxs-lookup"><span data-stu-id="36d20-166">✔️ CONSIDER using arrays in low-level APIs to minimize memory consumption and maximize performance.</span></span>

 <span data-ttu-id="36d20-167">✔️確實使用位元組陣列，而不是位元組的集合。</span><span class="sxs-lookup"><span data-stu-id="36d20-167">✔️ DO use byte arrays instead of collections of bytes.</span></span>

 <span data-ttu-id="36d20-168">❌ 如果屬性必須傳回新陣列 (例如，在每次呼叫屬性 getter 時) 內部陣列的複本，請不要使用屬性的陣列。</span><span class="sxs-lookup"><span data-stu-id="36d20-168">❌ DO NOT use arrays for properties if the property would have to return a new array (e.g., a copy of an internal array) every time the property getter is called.</span></span>

## <a name="implementing-custom-collections"></a><span data-ttu-id="36d20-169">執行自訂集合</span><span class="sxs-lookup"><span data-stu-id="36d20-169">Implementing Custom Collections</span></span>
 <span data-ttu-id="36d20-170">✔️ `Collection<T>` `ReadOnlyCollection<T>` `KeyedCollection<TKey,TItem>` 在設計新的集合時，請考慮從、或進行繼承。</span><span class="sxs-lookup"><span data-stu-id="36d20-170">✔️ CONSIDER inheriting from `Collection<T>`, `ReadOnlyCollection<T>`, or `KeyedCollection<TKey,TItem>` when designing new collections.</span></span>

 <span data-ttu-id="36d20-171">✔️ `IEnumerable<T>` 在設計新的集合時，就會執行。</span><span class="sxs-lookup"><span data-stu-id="36d20-171">✔️ DO implement `IEnumerable<T>` when designing new collections.</span></span> <span data-ttu-id="36d20-172">請考慮採用 `ICollection<T>` 或甚至 `IList<T>` 是有意義的地方。</span><span class="sxs-lookup"><span data-stu-id="36d20-172">Consider implementing `ICollection<T>` or even `IList<T>` where it makes sense.</span></span>

 <span data-ttu-id="36d20-173">在執行這類自訂集合時，請遵循和盡可能緊密地建立的 API 模式 `Collection<T>` `ReadOnlyCollection<T>` 。</span><span class="sxs-lookup"><span data-stu-id="36d20-173">When implementing such custom collection, follow the API pattern established by `Collection<T>` and `ReadOnlyCollection<T>` as closely as possible.</span></span> <span data-ttu-id="36d20-174">也就是說，明確地執行相同的成員，將參數命名為這兩個集合的名稱，依此類推。</span><span class="sxs-lookup"><span data-stu-id="36d20-174">That is, implement the same members explicitly, name the parameters like these two collections name them, and so on.</span></span>

 <span data-ttu-id="36d20-175">✔️考慮採用非泛型集合介面 (`IList` 和 `ICollection`) ，如果集合通常會傳遞至採用這些介面作為輸入的 api。</span><span class="sxs-lookup"><span data-stu-id="36d20-175">✔️ CONSIDER implementing nongeneric collection interfaces (`IList` and `ICollection`) if the collection will often be passed to APIs taking these interfaces as input.</span></span>

 <span data-ttu-id="36d20-176">❌ 避免在具有與集合概念不相關之複雜 Api 的類型上執行集合介面。</span><span class="sxs-lookup"><span data-stu-id="36d20-176">❌ AVOID implementing collection interfaces on types with complex APIs unrelated to the concept of a collection.</span></span>

 <span data-ttu-id="36d20-177">❌ 請勿繼承自非泛型基底集合，例如 `CollectionBase` 。</span><span class="sxs-lookup"><span data-stu-id="36d20-177">❌ DO NOT inherit from nongeneric base collections such as `CollectionBase`.</span></span> <span data-ttu-id="36d20-178">請改用 `Collection<T>`、`ReadOnlyCollection<T>` 和 `KeyedCollection<TKey,TItem>`。</span><span class="sxs-lookup"><span data-stu-id="36d20-178">Use `Collection<T>`, `ReadOnlyCollection<T>`, and `KeyedCollection<TKey,TItem>` instead.</span></span>

### <a name="naming-custom-collections"></a><span data-ttu-id="36d20-179">命名自訂集合</span><span class="sxs-lookup"><span data-stu-id="36d20-179">Naming Custom Collections</span></span>
 <span data-ttu-id="36d20-180">因為有 `IEnumerable` 兩個原因，所以會建立實) 的集合 (類型： (1) 以結構專屬的作業建立新的資料結構，而且通常與現有的資料結構有不同的效能特性 (例如、  <xref:System.Collections.Generic.List%601> 、 <xref:System.Collections.Generic.LinkedList%601> 、 <xref:System.Collections.Generic.Stack%601>) 和 (2) 建立特殊集合來保存一組特定的專案 (例如，  <xref:System.Collections.Specialized.StringCollection>) 。</span><span class="sxs-lookup"><span data-stu-id="36d20-180">Collections (types that implement `IEnumerable`) are created mainly for two reasons: (1) to create a new data structure with structure-specific operations and often different performance characteristics than existing data structures (e.g.,  <xref:System.Collections.Generic.List%601>, <xref:System.Collections.Generic.LinkedList%601>, <xref:System.Collections.Generic.Stack%601>), and (2) to create a specialized collection for holding a specific set of items (e.g.,  <xref:System.Collections.Specialized.StringCollection>).</span></span> <span data-ttu-id="36d20-181">資料結構最常用於應用程式和程式庫的內部執行。</span><span class="sxs-lookup"><span data-stu-id="36d20-181">Data structures are most often used in the internal implementation of applications and libraries.</span></span> <span data-ttu-id="36d20-182">特殊化的集合主要是在 Api 中公開 (作為屬性和參數類型) 。</span><span class="sxs-lookup"><span data-stu-id="36d20-182">Specialized collections are mainly to be exposed in APIs (as property and parameter types).</span></span>

 <span data-ttu-id="36d20-183">✔️請在執行或的抽象概念名稱中使用 "Dictionary" 尾碼 `IDictionary` `IDictionary<TKey,TValue>` 。</span><span class="sxs-lookup"><span data-stu-id="36d20-183">✔️ DO use the "Dictionary" suffix in names of abstractions implementing `IDictionary` or `IDictionary<TKey,TValue>`.</span></span>

 <span data-ttu-id="36d20-184">✔️請在實 (的型別名稱或任何其子系) 的名稱中使用 "Collection" 後置詞 `IEnumerable` ，並代表專案清單。</span><span class="sxs-lookup"><span data-stu-id="36d20-184">✔️ DO use the "Collection" suffix in names of types implementing `IEnumerable` (or any of its descendants) and representing a list of items.</span></span>

 <span data-ttu-id="36d20-185">✔️請為自訂資料結構使用適當的資料結構名稱。</span><span class="sxs-lookup"><span data-stu-id="36d20-185">✔️ DO use the appropriate data structure name for custom data structures.</span></span>

 <span data-ttu-id="36d20-186">❌ 請避免使用任何尾碼來隱含特定的實作為集合抽象的名稱，例如 "LinkedList" 或 "Hashtable"。</span><span class="sxs-lookup"><span data-stu-id="36d20-186">❌ AVOID using any suffixes implying particular implementation, such as "LinkedList" or "Hashtable," in names of collection abstractions.</span></span>

 <span data-ttu-id="36d20-187">✔️考慮在集合名稱前面加上專案類型的名稱。</span><span class="sxs-lookup"><span data-stu-id="36d20-187">✔️ CONSIDER prefixing collection names with the name of the item type.</span></span> <span data-ttu-id="36d20-188">例如，儲存型別 (的專案集合 `Address` `IEnumerable<Address>` 應該命名為) `AddressCollection` 。</span><span class="sxs-lookup"><span data-stu-id="36d20-188">For example, a collection storing items of type `Address` (implementing `IEnumerable<Address>`) should be named `AddressCollection`.</span></span> <span data-ttu-id="36d20-189">如果專案類型是介面，則可以省略專案類型的 "I" 前置詞。</span><span class="sxs-lookup"><span data-stu-id="36d20-189">If the item type is an interface, the "I" prefix of the item type can be omitted.</span></span> <span data-ttu-id="36d20-190">因此， <xref:System.IDisposable> 可以呼叫專案的集合 `DisposableCollection` 。</span><span class="sxs-lookup"><span data-stu-id="36d20-190">Thus, a collection of <xref:System.IDisposable> items can be called `DisposableCollection`.</span></span>

 <span data-ttu-id="36d20-191">如果對應的可寫入集合可能已存在於架構中，✔️請考慮在唯讀集合的名稱中使用 "ReadOnly" 前置詞。</span><span class="sxs-lookup"><span data-stu-id="36d20-191">✔️ CONSIDER using the "ReadOnly" prefix in names of read-only collections if a corresponding writeable collection might be added or already exists in the framework.</span></span>

 <span data-ttu-id="36d20-192">例如，應呼叫字串的唯讀集合 `ReadOnlyStringCollection` 。</span><span class="sxs-lookup"><span data-stu-id="36d20-192">For example, a read-only collection of strings should be called `ReadOnlyStringCollection`.</span></span>

 <span data-ttu-id="36d20-193">*部分©2005、2009 Microsoft Corporation。保留的擁有權限。*</span><span class="sxs-lookup"><span data-stu-id="36d20-193">*Portions © 2005, 2009 Microsoft Corporation. All rights reserved.*</span></span>

 <span data-ttu-id="36d20-194">獲 Pearson Education, Inc. 的授權再版，從 Krzysztof Cwalina 和 Brad Abrams 撰寫，並在 2008 年 10 月 22 日由 Addison-Wesley Professional 出版，作為 Microsoft Windows Development Series 一部份的 [Framework Design Guidelines: Conventions, Idioms, and Patterns for Reusable .NET Libraries, 2nd Edition](https://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619) 節錄。</span><span class="sxs-lookup"><span data-stu-id="36d20-194">*Reprinted by permission of Pearson Education, Inc. from [Framework Design Guidelines: Conventions, Idioms, and Patterns for Reusable .NET Libraries, 2nd Edition](https://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619) by Krzysztof Cwalina and Brad Abrams, published Oct 22, 2008 by Addison-Wesley Professional as part of the Microsoft Windows Development Series.*</span></span>

## <a name="see-also"></a><span data-ttu-id="36d20-195">請參閱</span><span class="sxs-lookup"><span data-stu-id="36d20-195">See also</span></span>

- [<span data-ttu-id="36d20-196">架構設計指導方針</span><span class="sxs-lookup"><span data-stu-id="36d20-196">Framework Design Guidelines</span></span>](index.md)
- [<span data-ttu-id="36d20-197">使用指導方針</span><span class="sxs-lookup"><span data-stu-id="36d20-197">Usage Guidelines</span></span>](usage-guidelines.md)
