---
title: gRPC
description: 瞭解 gRPC、其在雲端原生應用程式中的角色，以及它與 HTTP RESTful 通訊有何不同。
author: robvet
no-loc:
- Blazor
- Blazor WebAssembly
ms.date: 05/13/2020
ms.openlocfilehash: 4a0c88472d2b19efb2ff0f58395003b1b6409131
ms.sourcegitcommit: ef50c99928183a0bba75e07b9f22895cd4c480f8
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/07/2020
ms.locfileid: "87914888"
---
# <a name="grpc"></a><span data-ttu-id="b7db4-103">gRPC</span><span class="sxs-lookup"><span data-stu-id="b7db4-103">gRPC</span></span>

<span data-ttu-id="b7db4-104">到目前為止，我們都著重于以[REST 為基礎的](https://docs.microsoft.com/azure/architecture/best-practices/api-design)通訊。</span><span class="sxs-lookup"><span data-stu-id="b7db4-104">So far in this book, we've focused on [REST-based](https://docs.microsoft.com/azure/architecture/best-practices/api-design) communication.</span></span> <span data-ttu-id="b7db4-105">我們已瞭解 REST 是彈性的架構樣式，其定義以 CRUD 為基礎的實體資源作業。</span><span class="sxs-lookup"><span data-stu-id="b7db4-105">We've seen that REST is a flexible architectural style that defines CRUD-based operations against entity resources.</span></span> <span data-ttu-id="b7db4-106">用戶端會使用要求/回應通訊模型，透過 HTTP 與資源互動。</span><span class="sxs-lookup"><span data-stu-id="b7db4-106">Clients interact with resources across HTTP with a request/response communication model.</span></span> <span data-ttu-id="b7db4-107">雖然 REST 已廣泛實行，但較新的通訊技術 gRPC 在雲端原生的社區獲得了巨大的動力。</span><span class="sxs-lookup"><span data-stu-id="b7db4-107">While REST is widely implemented, a newer communication technology, gRPC, has gained tremendous momentum across the cloud-native community.</span></span>

## <a name="what-is-grpc"></a><span data-ttu-id="b7db4-108">什麼是 gRPC？</span><span class="sxs-lookup"><span data-stu-id="b7db4-108">What is gRPC?</span></span>

<span data-ttu-id="b7db4-109">gRPC 是一種現代化、高效能的架構，會 (RPC) 通訊協定來演變過時的[遠端程序呼叫](https://en.wikipedia.org/wiki/Remote_procedure_call)。</span><span class="sxs-lookup"><span data-stu-id="b7db4-109">gRPC is a modern, high-performance framework that evolves the age-old [remote procedure call (RPC)](https://en.wikipedia.org/wiki/Remote_procedure_call) protocol.</span></span> <span data-ttu-id="b7db4-110">在應用層級，gRPC 會簡化用戶端和後端服務之間的訊息處理。</span><span class="sxs-lookup"><span data-stu-id="b7db4-110">At the application level, gRPC streamlines messaging between clients and back-end services.</span></span> <span data-ttu-id="b7db4-111">源自 Google、gRPC 是開放原始碼，而[雲端原生運算基礎](https://www.cncf.io/)的一部分， (由 cncf 雲端原生供應專案的) 生態系統。</span><span class="sxs-lookup"><span data-stu-id="b7db4-111">Originating from Google, gRPC is open source and part of the  [Cloud Native Computing Foundation (CNCF)](https://www.cncf.io/) ecosystem of cloud-native offerings.</span></span> <span data-ttu-id="b7db4-112">由 CNCF 會將 gRPC 視為[發展專案](https://github.com/cncf/toc/blob/master/process/graduation_criteria.adoc)。</span><span class="sxs-lookup"><span data-stu-id="b7db4-112">CNCF considers gRPC an [incubating project](https://github.com/cncf/toc/blob/master/process/graduation_criteria.adoc).</span></span> <span data-ttu-id="b7db4-113">發展表示終端使用者在生產應用程式中使用此技術，而專案的參與者數目良好。</span><span class="sxs-lookup"><span data-stu-id="b7db4-113">Incubating means end users are using the technology in production applications, and the project has a healthy number of contributors.</span></span>

<span data-ttu-id="b7db4-114">一般的 gRPC 用戶端應用程式會公開可執行商務作業的本機、同進程函式。</span><span class="sxs-lookup"><span data-stu-id="b7db4-114">A typical gRPC client app will expose a local, in-process function that implements a business operation.</span></span> <span data-ttu-id="b7db4-115">實際上，該區域函式會在遠端電腦上叫用另一個函式。</span><span class="sxs-lookup"><span data-stu-id="b7db4-115">Under the covers, that local function invokes another function on a remote machine.</span></span> <span data-ttu-id="b7db4-116">所謂的本機呼叫基本上會成為對遠端服務的透明跨進程呼叫。</span><span class="sxs-lookup"><span data-stu-id="b7db4-116">What appears to be a local call essentially becomes a transparent out-of-process call to a remote service.</span></span> <span data-ttu-id="b7db4-117">RPC 配會將點對點網路通訊、序列化和電腦之間的執行抽象化。</span><span class="sxs-lookup"><span data-stu-id="b7db4-117">The RPC plumbing abstracts the point-to-point networking communication, serialization, and execution between computers.</span></span>

<span data-ttu-id="b7db4-118">在雲端原生應用程式中，開發人員通常可以跨程式設計語言、架構和技術來工作。</span><span class="sxs-lookup"><span data-stu-id="b7db4-118">In cloud-native applications, developers often work across programming languages, frameworks, and technologies.</span></span> <span data-ttu-id="b7db4-119">此*互通性*會使訊息合約和跨平臺通訊所需的管道變得複雜。</span><span class="sxs-lookup"><span data-stu-id="b7db4-119">This *interoperability* complicates message contracts and the plumbing required for cross-platform communication.</span></span>  <span data-ttu-id="b7db4-120">gRPC 提供「統一水準層」，可將這些考慮抽象化。</span><span class="sxs-lookup"><span data-stu-id="b7db4-120">gRPC provides a "uniform horizontal layer" that abstracts these concerns.</span></span> <span data-ttu-id="b7db4-121">開發人員在其原生平臺中撰寫著重于商務功能的程式碼，而 gRPC 則會處理通訊。</span><span class="sxs-lookup"><span data-stu-id="b7db4-121">Developers code in their native platform focused on business functionality, while gRPC handles communication plumbing.</span></span>

<span data-ttu-id="b7db4-122">gRPC 在最熱門的開發堆疊中提供全方位的支援，包括 JAVA、JavaScript、c #、Go、Swift 和 NodeJS。</span><span class="sxs-lookup"><span data-stu-id="b7db4-122">gRPC offers comprehensive support across most popular development stacks, including Java, JavaScript, C#, Go, Swift, and NodeJS.</span></span>

## <a name="grpc-benefits"></a><span data-ttu-id="b7db4-123">gRPC 權益</span><span class="sxs-lookup"><span data-stu-id="b7db4-123">gRPC Benefits</span></span>

<span data-ttu-id="b7db4-124">gRPC 會使用 HTTP/2 作為其傳輸通訊協定。</span><span class="sxs-lookup"><span data-stu-id="b7db4-124">gRPC uses HTTP/2 for its transport protocol.</span></span> <span data-ttu-id="b7db4-125">與 HTTP 1.1 相容，HTTP/2 具備許多先進的功能：</span><span class="sxs-lookup"><span data-stu-id="b7db4-125">While compatible with HTTP 1.1, HTTP/2 features many advanced capabilities:</span></span>

- <span data-ttu-id="b7db4-126">用於資料傳輸的二進位框架通訊協定-與 HTTP 1.1 不同，這是以文字為基礎。</span><span class="sxs-lookup"><span data-stu-id="b7db4-126">A binary framing protocol for data transport - unlike HTTP 1.1, which is text based.</span></span>
- <span data-ttu-id="b7db4-127">多工支援透過相同的連接傳送多個平行要求-HTTP 1.1 限制一次處理一個要求/回應訊息。</span><span class="sxs-lookup"><span data-stu-id="b7db4-127">Multiplexing support for sending multiple parallel requests over the same connection - HTTP 1.1 limits processing to one request/response message at a time.</span></span>
- <span data-ttu-id="b7db4-128">雙向的全雙工通訊，可同時傳送用戶端要求和伺服器回應。</span><span class="sxs-lookup"><span data-stu-id="b7db4-128">Bidirectional full-duplex communication for sending both client requests and server responses simultaneously.</span></span>
- <span data-ttu-id="b7db4-129">內建串流功能，可讓要求和回應以非同步方式串流處理大型資料集。</span><span class="sxs-lookup"><span data-stu-id="b7db4-129">Built-in streaming enabling requests and responses to asynchronously stream large data sets.</span></span>
- <span data-ttu-id="b7db4-130">可減少網路使用量的標頭壓縮。</span><span class="sxs-lookup"><span data-stu-id="b7db4-130">Header compression that reduces network usage.</span></span>

<span data-ttu-id="b7db4-131">gRPC 是輕量且高效能。</span><span class="sxs-lookup"><span data-stu-id="b7db4-131">gRPC is lightweight and highly performant.</span></span> <span data-ttu-id="b7db4-132">其最高可比 JSON 序列化更快，且訊息60-80% 較小。</span><span class="sxs-lookup"><span data-stu-id="b7db4-132">It can be up to 8x faster than JSON serialization with messages 60-80% smaller.</span></span> <span data-ttu-id="b7db4-133">在 Microsoft [Windows Communication Foundation 中 (WCF) ](https://docs.microsoft.com/dotnet/framework/wcf/whats-wcf)用語中，gRPC 效能超過高度優化[NetTCP](https://docs.microsoft.com/dotnet/api/system.servicemodel.nettcpbinding?view=netframework-4.8)系結的速度和效率。</span><span class="sxs-lookup"><span data-stu-id="b7db4-133">In Microsoft [Windows Communication Foundation (WCF)](https://docs.microsoft.com/dotnet/framework/wcf/whats-wcf) parlance, gRPC performance exceeds the speed and efficiency of the highly optimized [NetTCP bindings](https://docs.microsoft.com/dotnet/api/system.servicemodel.nettcpbinding?view=netframework-4.8).</span></span> <span data-ttu-id="b7db4-134">不同于 NetTCP，這是 Microsoft stack 的優先，gRPC 是跨平臺。</span><span class="sxs-lookup"><span data-stu-id="b7db4-134">Unlike NetTCP, which favors the Microsoft stack, gRPC is cross-platform.</span></span>

## <a name="protocol-buffers"></a><span data-ttu-id="b7db4-135">通訊協定緩衝區</span><span class="sxs-lookup"><span data-stu-id="b7db4-135">Protocol Buffers</span></span>

<span data-ttu-id="b7db4-136">gRPC 採用稱為[通訊協定緩衝區](https://developers.google.com/protocol-buffers/docs/overview)的開放原始碼技術。</span><span class="sxs-lookup"><span data-stu-id="b7db4-136">gRPC embraces an open-source technology called [Protocol Buffers](https://developers.google.com/protocol-buffers/docs/overview).</span></span> <span data-ttu-id="b7db4-137">它們提供高度有效率和平臺中立的序列化格式，以便將服務傳送至彼此的結構化訊息進行序列化。</span><span class="sxs-lookup"><span data-stu-id="b7db4-137">They provide a highly efficient and platform-neutral serialization format for serializing structured messages that services send to each other.</span></span> <span data-ttu-id="b7db4-138">使用跨平臺介面定義語言 (IDL) ，開發人員會針對每個微服務定義服務合約。</span><span class="sxs-lookup"><span data-stu-id="b7db4-138">Using a cross-platform Interface Definition Language (IDL), developers define a service contract for each microservice.</span></span> <span data-ttu-id="b7db4-139">合約（實作為以文字為基礎的檔案 `.proto` ）會說明每個服務的方法、輸入和輸出。</span><span class="sxs-lookup"><span data-stu-id="b7db4-139">The contract, implemented as a text-based `.proto` file, describes the methods, inputs, and outputs for each service.</span></span> <span data-ttu-id="b7db4-140">相同的合約檔案可以用於 gRPC 在不同開發平臺上建立的用戶端和服務。</span><span class="sxs-lookup"><span data-stu-id="b7db4-140">The same contract file can be used for gRPC clients and services built on different development platforms.</span></span>

<span data-ttu-id="b7db4-141">使用 proto 檔案（Protobuf 編譯器），會 `protoc` 為您的目標平臺產生用戶端和服務程式代碼。</span><span class="sxs-lookup"><span data-stu-id="b7db4-141">Using the proto file, the Protobuf compiler, `protoc`, generates both client and service code for your target platform.</span></span> <span data-ttu-id="b7db4-142">程式碼包含下列元件：</span><span class="sxs-lookup"><span data-stu-id="b7db4-142">The code includes the following components:</span></span>

- <span data-ttu-id="b7db4-143">由用戶端和服務共用的強型別物件，代表訊息的服務作業和資料元素。</span><span class="sxs-lookup"><span data-stu-id="b7db4-143">Strongly typed objects, shared by the client and service, that represent the service operations and data elements for a message.</span></span>
- <span data-ttu-id="b7db4-144">具有遠端 gRPC 服務可繼承和擴充之必要網路配管的強型別基類。</span><span class="sxs-lookup"><span data-stu-id="b7db4-144">A strongly typed base class with the required network plumbing that the remote gRPC service can inherit and extend.</span></span>
- <span data-ttu-id="b7db4-145">用戶端存根，其中包含叫用遠端 gRPC 服務所需的管道。</span><span class="sxs-lookup"><span data-stu-id="b7db4-145">A client stub that contains the required plumbing to invoke the remote gRPC service.</span></span>

<span data-ttu-id="b7db4-146">在執行時間，每個訊息會序列化為標準的 Protobuf 標記法，並在用戶端與遠端服務之間交換。</span><span class="sxs-lookup"><span data-stu-id="b7db4-146">At runtime, each message is serialized as a standard Protobuf representation and exchanged between the client and remote service.</span></span> <span data-ttu-id="b7db4-147">不同于 JSON 或 XML，Protobuf 訊息會序列化為已編譯的二進位位元組。</span><span class="sxs-lookup"><span data-stu-id="b7db4-147">Unlike JSON or XML, Protobuf messages are serialized as compiled binary bytes.</span></span>

<span data-ttu-id="b7db4-148">[GRPC FOR WCF 開發人員](https://docs.microsoft.com/dotnet/architecture/grpc-for-wcf-developers/)（可從 Microsoft 架構網站取得）提供 GRPC 和通訊協定緩衝區的深入涵蓋範圍。</span><span class="sxs-lookup"><span data-stu-id="b7db4-148">The book, [gRPC for WCF Developers](https://docs.microsoft.com/dotnet/architecture/grpc-for-wcf-developers/), available from the Microsoft Architecture site, provides in-depth coverage of gRPC and Protocol Buffers.</span></span>

## <a name="grpc-support-in-net"></a><span data-ttu-id="b7db4-149">.NET 中的 gRPC 支援</span><span class="sxs-lookup"><span data-stu-id="b7db4-149">gRPC support in .NET</span></span>

<span data-ttu-id="b7db4-150">gRPC 已整合到 .NET Core 3.0 SDK 和更新版本中。</span><span class="sxs-lookup"><span data-stu-id="b7db4-150">gRPC is integrated into .NET Core 3.0 SDK and later.</span></span> <span data-ttu-id="b7db4-151">下列工具支援它：</span><span class="sxs-lookup"><span data-stu-id="b7db4-151">The following tools support it:</span></span>

- <span data-ttu-id="b7db4-152">Visual Studio 2019、16.3 版或更新版本，並已安裝 網頁程式開發工作負載。</span><span class="sxs-lookup"><span data-stu-id="b7db4-152">Visual Studio 2019, version 16.3 or later, with the web development workload installed.</span></span>
- <span data-ttu-id="b7db4-153">Visual Studio Code</span><span class="sxs-lookup"><span data-stu-id="b7db4-153">Visual Studio Code</span></span>
- <span data-ttu-id="b7db4-154">dotnet CLI</span><span class="sxs-lookup"><span data-stu-id="b7db4-154">the dotnet CLI</span></span>

<span data-ttu-id="b7db4-155">SDK 包含端點路由、內建 IoC 和記錄的工具。</span><span class="sxs-lookup"><span data-stu-id="b7db4-155">The SDK includes tooling for endpoint routing, built-in IoC, and logging.</span></span> <span data-ttu-id="b7db4-156">開放原始碼 Kestrel web 伺服器支援 HTTP/2 連接。</span><span class="sxs-lookup"><span data-stu-id="b7db4-156">The open-source Kestrel web server supports HTTP/2 connections.</span></span> <span data-ttu-id="b7db4-157">圖4-20 顯示的 Visual Studio 2019 範本會 scaffold gRPC 服務的基本架構專案。</span><span class="sxs-lookup"><span data-stu-id="b7db4-157">Figure 4-20 shows a Visual Studio 2019 template that scaffolds a skeleton project for a gRPC service.</span></span> <span data-ttu-id="b7db4-158">請注意 .NET Core 如何完全支援 Windows、Linux 和 macOS。</span><span class="sxs-lookup"><span data-stu-id="b7db4-158">Note how .NET Core fully supports Windows, Linux, and macOS.</span></span>

![Visual Studio 2019 中的 gRPC 支援](./media/visual-studio-2019-grpc-template.png)

<span data-ttu-id="b7db4-160">**圖 4-20**：</span><span class="sxs-lookup"><span data-stu-id="b7db4-160">**Figure 4-20**.</span></span> <span data-ttu-id="b7db4-161">Visual Studio 2019 中的 gRPC 支援</span><span class="sxs-lookup"><span data-stu-id="b7db4-161">gRPC support in Visual Studio 2019</span></span>
  
<span data-ttu-id="b7db4-162">圖4-21 顯示從 Visual Studio 2019 所包含的內建樣板產生的基本架構 gRPC 服務。</span><span class="sxs-lookup"><span data-stu-id="b7db4-162">Figure 4-21 shows the skeleton gRPC service generated from the built-in scaffolding included in Visual Studio 2019.</span></span>  

![Visual Studio 2019 中的 gRPC 專案](./media/grpc-project.png  )

<span data-ttu-id="b7db4-164">**圖 4-21**：</span><span class="sxs-lookup"><span data-stu-id="b7db4-164">**Figure 4-21**.</span></span> <span data-ttu-id="b7db4-165">Visual Studio 2019 中的 gRPC 專案</span><span class="sxs-lookup"><span data-stu-id="b7db4-165">gRPC project in Visual Studio 2019</span></span>

<span data-ttu-id="b7db4-166">在上圖中，請注意 proto 描述檔案和服務程式代碼。</span><span class="sxs-lookup"><span data-stu-id="b7db4-166">In the previous figure, note the proto description file and service code.</span></span> <span data-ttu-id="b7db4-167">您很快就會看到，Visual Studio 會在啟動類別和基礎專案檔案中產生額外的設定。</span><span class="sxs-lookup"><span data-stu-id="b7db4-167">As you'll see shortly, Visual Studio generates additional configuration in both the Startup class and underlying project file.</span></span>

## <a name="grpc-usage"></a><span data-ttu-id="b7db4-168">gRPC 使用方式</span><span class="sxs-lookup"><span data-stu-id="b7db4-168">gRPC usage</span></span>

<span data-ttu-id="b7db4-169">在下列案例中偏好 gRPC：</span><span class="sxs-lookup"><span data-stu-id="b7db4-169">Favor gRPC for the following scenarios:</span></span>

- <span data-ttu-id="b7db4-170">同步後端微服務對微服務通訊，其中需要立即回應才能繼續處理。</span><span class="sxs-lookup"><span data-stu-id="b7db4-170">Synchronous backend microservice-to-microservice communication where an immediate response is required to continue processing.</span></span>
- <span data-ttu-id="b7db4-171">多語言需要支援混合程式設計平臺的環境。</span><span class="sxs-lookup"><span data-stu-id="b7db4-171">Polyglot environments that need to support mixed programming platforms.</span></span>
- <span data-ttu-id="b7db4-172">效能非常重要的低延遲和高輸送量通訊。</span><span class="sxs-lookup"><span data-stu-id="b7db4-172">Low latency and high throughput communication where performance is critical.</span></span>
- <span data-ttu-id="b7db4-173">點對點即時通訊-gRPC 可以即時推播訊息，而不需輪詢，而且具有雙向串流的絕佳支援。</span><span class="sxs-lookup"><span data-stu-id="b7db4-173">Point-to-point real-time communication - gRPC can push messages in real time without polling and has excellent support for bi-directional streaming.</span></span>
- <span data-ttu-id="b7db4-174">網路限制環境–二進位 gRPC 訊息一律會小於對等的以文字為基礎的 JSON 訊息。</span><span class="sxs-lookup"><span data-stu-id="b7db4-174">Network constrained environments – binary gRPC messages are always smaller than an equivalent text-based JSON message.</span></span>

<span data-ttu-id="b7db4-175">在撰寫本文時，gRPC 主要是與後端服務搭配使用。</span><span class="sxs-lookup"><span data-stu-id="b7db4-175">At the time, of this writing, gRPC is primarily used with backend services.</span></span> <span data-ttu-id="b7db4-176">現代化的瀏覽器無法提供支援前端 gRPC 用戶端所需的 HTTP/2 控制層級。</span><span class="sxs-lookup"><span data-stu-id="b7db4-176">Modern browsers can't provide the level of HTTP/2 control required to support a front-end gRPC client.</span></span> <span data-ttu-id="b7db4-177">話雖如此，支援[使用 .net 的 GRPC Web](https://devblogs.microsoft.com/aspnet/grpc-web-for-net-now-available/) ，讓您能夠從以 JavaScript 或技術為基礎的瀏覽器應用程式進行 gRPC 通訊 Blazor WebAssembly 。</span><span class="sxs-lookup"><span data-stu-id="b7db4-177">That said, there's support for [gRPC-Web with .NET](https://devblogs.microsoft.com/aspnet/grpc-web-for-net-now-available/) that enables gRPC communication from browser-based apps built with JavaScript or Blazor WebAssembly technologies.</span></span> <span data-ttu-id="b7db4-178">[gRPC-Web](https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-WEB.md)可讓 ASP.NET Core gRPC 應用程式支援瀏覽器應用程式中的 gRPC 功能：</span><span class="sxs-lookup"><span data-stu-id="b7db4-178">[gRPC-Web](https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-WEB.md) enables an ASP.NET Core gRPC app to support gRPC features in browser apps:</span></span>

- <span data-ttu-id="b7db4-179">強型別、程式碼產生的用戶端</span><span class="sxs-lookup"><span data-stu-id="b7db4-179">Strongly typed, code-generated clients</span></span>
- <span data-ttu-id="b7db4-180">Compact Protobuf 訊息</span><span class="sxs-lookup"><span data-stu-id="b7db4-180">Compact Protobuf messages</span></span>
- <span data-ttu-id="b7db4-181">伺服器串流</span><span class="sxs-lookup"><span data-stu-id="b7db4-181">Server streaming</span></span>

## <a name="grpc-implementation"></a><span data-ttu-id="b7db4-182">gRPC 執行</span><span class="sxs-lookup"><span data-stu-id="b7db4-182">gRPC implementation</span></span>

<span data-ttu-id="b7db4-183">微服務參考架構（由 Microsoft[在容器上 eShop](https://github.com/dotnet-architecture/eShopOnContainers)）示範如何在 .net Core 應用程式中執行 gRPC 服務。</span><span class="sxs-lookup"><span data-stu-id="b7db4-183">The microservice reference architecture, [eShop on Containers](https://github.com/dotnet-architecture/eShopOnContainers), from Microsoft, shows how to implement gRPC services in .NET Core applications.</span></span> <span data-ttu-id="b7db4-184">圖4-22 顯示後端架構。</span><span class="sxs-lookup"><span data-stu-id="b7db4-184">Figure 4-22 presents the back-end architecture.</span></span>

![容器上的 eShop 後端架構](./media/eshop-with-aggregators.png)

<span data-ttu-id="b7db4-186">**圖 4-22**。</span><span class="sxs-lookup"><span data-stu-id="b7db4-186">**Figure 4-22**.</span></span> <span data-ttu-id="b7db4-187">容器上的 eShop 後端架構</span><span class="sxs-lookup"><span data-stu-id="b7db4-187">Backend architecture for eShop on Containers</span></span>

<span data-ttu-id="b7db4-188">在上圖中，請注意 eShop 如何藉由公開多個 API 閘道，[來為前端模式提供後端](https://docs.microsoft.com/azure/architecture/patterns/backends-for-frontends) (BFF) 。</span><span class="sxs-lookup"><span data-stu-id="b7db4-188">In the previous figure, note how eShop embraces the [Backend for Frontends pattern](https://docs.microsoft.com/azure/architecture/patterns/backends-for-frontends) (BFF) by exposing multiple API gateways.</span></span> <span data-ttu-id="b7db4-189">我們在本章稍早討論過 BFF 模式。</span><span class="sxs-lookup"><span data-stu-id="b7db4-189">We discussed the BFF pattern earlier in this chapter.</span></span> <span data-ttu-id="b7db4-190">請密切注意位於 Web 購物 API 閘道與後端購物微服務之間的灰色) 的匯總工具微服務 (。</span><span class="sxs-lookup"><span data-stu-id="b7db4-190">Pay close attention to the Aggregator microservice (in gray) that sits between the Web-Shopping API Gateway and backend Shopping microservices.</span></span> <span data-ttu-id="b7db4-191">匯總工具會接收來自用戶端的單一要求、將其分派至各種微服務、匯總結果，並將其傳回給要求的用戶端。</span><span class="sxs-lookup"><span data-stu-id="b7db4-191">The Aggregator receives a single request from a client, dispatches it to various microservices, aggregates the results, and sends them back to the requesting client.</span></span> <span data-ttu-id="b7db4-192">這類作業通常需要同步通訊，才能產生立即回應。</span><span class="sxs-lookup"><span data-stu-id="b7db4-192">Such operations typically require synchronous communication as to produce an immediate response.</span></span> <span data-ttu-id="b7db4-193">在 eShop 中，會使用 gRPC 來執行來自匯總工具的後端呼叫，如圖4-23 所示。</span><span class="sxs-lookup"><span data-stu-id="b7db4-193">In eShop, backend calls from the Aggregator are performed using gRPC as shown in Figure 4-23.</span></span>

![容器上 eShop 中的 gRPC](./media/grpc-implementation.png)

<span data-ttu-id="b7db4-195">**圖 4-23**：</span><span class="sxs-lookup"><span data-stu-id="b7db4-195">**Figure 4-23**.</span></span> <span data-ttu-id="b7db4-196">容器上 eShop 中的 gRPC</span><span class="sxs-lookup"><span data-stu-id="b7db4-196">gRPC in eShop on Containers</span></span>

<span data-ttu-id="b7db4-197">gRPC 通訊需要用戶端和伺服器元件。</span><span class="sxs-lookup"><span data-stu-id="b7db4-197">gRPC communication requires both client and server components.</span></span> <span data-ttu-id="b7db4-198">在上圖中，請注意購物匯總工具如何實行 gRPC 用戶端。</span><span class="sxs-lookup"><span data-stu-id="b7db4-198">In the previous figure, note how the Shopping Aggregator implements a gRPC client.</span></span> <span data-ttu-id="b7db4-199">用戶端會進行同步 gRPC 呼叫， (以 red) 對後端微服務，每個都會執行 gRPC 伺服器。</span><span class="sxs-lookup"><span data-stu-id="b7db4-199">The client makes synchronous gRPC calls (in red) to backend microservices, each of which implement a gRPC server.</span></span> <span data-ttu-id="b7db4-200">用戶端和伺服器都利用來自 .NET Core SDK 的內建 gRPC 配管。</span><span class="sxs-lookup"><span data-stu-id="b7db4-200">Both the client and server take advantage of the built-in gRPC plumbing from the .NET Core SDK.</span></span> <span data-ttu-id="b7db4-201">用戶端*stub*提供了用來叫用遠端 gRPC 呼叫的管道。</span><span class="sxs-lookup"><span data-stu-id="b7db4-201">Client-side *stubs* provide the plumbing to invoke remote gRPC calls.</span></span> <span data-ttu-id="b7db4-202">伺服器端元件提供自訂服務類別可以繼承和使用的 gRPC 配管。</span><span class="sxs-lookup"><span data-stu-id="b7db4-202">Server-side components provide gRPC plumbing that custom service classes can inherit and consume.</span></span>

<span data-ttu-id="b7db4-203">公開 RESTful API 和 gRPC 通訊的微服務需要多個端點來管理流量。</span><span class="sxs-lookup"><span data-stu-id="b7db4-203">Microservices that expose both a RESTful API and gRPC communication require multiple endpoints to manage traffic.</span></span> <span data-ttu-id="b7db4-204">您會開啟一個端點，以接聽 RESTful 呼叫的 HTTP 流量，另一個用於 gRPC 呼叫。</span><span class="sxs-lookup"><span data-stu-id="b7db4-204">You would open an endpoint that listens for HTTP traffic for the RESTful calls and another for gRPC calls.</span></span> <span data-ttu-id="b7db4-205">GRPC 端點必須針對 gRPC 通訊所需的 HTTP/2 通訊協定進行設定。</span><span class="sxs-lookup"><span data-stu-id="b7db4-205">The gRPC endpoint must be configured for the HTTP/2 protocol that is required for gRPC communication.</span></span>

<span data-ttu-id="b7db4-206">雖然我們致力於將微服務與非同步通訊模式分離，但某些作業需要直接呼叫。</span><span class="sxs-lookup"><span data-stu-id="b7db4-206">While we strive to decouple microservices with asynchronous communication patterns, some operations require direct calls.</span></span> <span data-ttu-id="b7db4-207">gRPC 應該是微服務之間直接同步通訊的主要選擇。</span><span class="sxs-lookup"><span data-stu-id="b7db4-207">gRPC should be the primary choice for direct synchronous communication between microservices.</span></span> <span data-ttu-id="b7db4-208">其高效能通訊協定（根據 HTTP/2 和通訊協定緩衝區）讓它成為最佳選擇。</span><span class="sxs-lookup"><span data-stu-id="b7db4-208">Its high-performance communication protocol, based on HTTP/2 and protocol buffers, make it a perfect choice.</span></span>

## <a name="looking-ahead"></a><span data-ttu-id="b7db4-209">展望未來</span><span class="sxs-lookup"><span data-stu-id="b7db4-209">Looking ahead</span></span>

<span data-ttu-id="b7db4-210">在未來，gRPC 會繼續為雲端原生系統取得吸引力。</span><span class="sxs-lookup"><span data-stu-id="b7db4-210">Looking ahead, gRPC will continue to gain traction for cloud-native systems.</span></span> <span data-ttu-id="b7db4-211">效能優勢和開發的便利性很吸引人。</span><span class="sxs-lookup"><span data-stu-id="b7db4-211">The performance benefits and ease of development are compelling.</span></span> <span data-ttu-id="b7db4-212">不過，REST 可能會有很長一段時間。</span><span class="sxs-lookup"><span data-stu-id="b7db4-212">However, REST will likely be around for a long time.</span></span> <span data-ttu-id="b7db4-213">它會針對公開公開的 Api 和回溯相容性的理由而擅長。</span><span class="sxs-lookup"><span data-stu-id="b7db4-213">It excels for publicly exposed APIs and for backward compatibility reasons.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="b7db4-214">[上一個](service-to-service-communication.md) 
>[下一步](service-mesh-communication-infrastructure.md)</span><span class="sxs-lookup"><span data-stu-id="b7db4-214">[Previous](service-to-service-communication.md)
[Next](service-mesh-communication-infrastructure.md)</span></span>
