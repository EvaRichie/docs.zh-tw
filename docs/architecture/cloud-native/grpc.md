---
title: gRPC
description: 瞭解 gRPC、其在雲端原生應用程式中的角色，以及它與 HTTP RESTful 通訊的不同之處。
author: robvet
no-loc:
- Blazor
- Blazor WebAssembly
ms.date: 05/13/2020
ms.openlocfilehash: 9ed6906bd388a1ddef7f97bbaac001b4274853f9
ms.sourcegitcommit: 5b475c1855b32cf78d2d1bbb4295e4c236f39464
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 09/24/2020
ms.locfileid: "91158080"
---
# <a name="grpc"></a><span data-ttu-id="406ad-103">gRPC</span><span class="sxs-lookup"><span data-stu-id="406ad-103">gRPC</span></span>

<span data-ttu-id="406ad-104">到目前為止，我們將著重于以 [REST 為基礎](/azure/architecture/best-practices/api-design) 的通訊。</span><span class="sxs-lookup"><span data-stu-id="406ad-104">So far in this book, we've focused on [REST-based](/azure/architecture/best-practices/api-design) communication.</span></span> <span data-ttu-id="406ad-105">我們已瞭解 REST 是一種彈性的架構樣式，可針對實體資源定義 CRUD 作業。</span><span class="sxs-lookup"><span data-stu-id="406ad-105">We've seen that REST is a flexible architectural style that defines CRUD-based operations against entity resources.</span></span> <span data-ttu-id="406ad-106">用戶端會使用要求/回應通訊模型，在 HTTP 之間與資源互動。</span><span class="sxs-lookup"><span data-stu-id="406ad-106">Clients interact with resources across HTTP with a request/response communication model.</span></span> <span data-ttu-id="406ad-107">雖然 REST 已廣泛實行，但較新的通訊技術 gRPC，在雲端原生的全球各地獲得了巨大的動力。</span><span class="sxs-lookup"><span data-stu-id="406ad-107">While REST is widely implemented, a newer communication technology, gRPC, has gained tremendous momentum across the cloud-native community.</span></span>

## <a name="what-is-grpc"></a><span data-ttu-id="406ad-108">什麼是 gRPC？</span><span class="sxs-lookup"><span data-stu-id="406ad-108">What is gRPC?</span></span>

<span data-ttu-id="406ad-109">gRPC 是現代化、高效能的架構， (RPC) 通訊協定來發展舊的 [遠端程序呼叫 ](https://en.wikipedia.org/wiki/Remote_procedure_call) 。</span><span class="sxs-lookup"><span data-stu-id="406ad-109">gRPC is a modern, high-performance framework that evolves the age-old [remote procedure call (RPC)](https://en.wikipedia.org/wiki/Remote_procedure_call) protocol.</span></span> <span data-ttu-id="406ad-110">在應用層級，gRPC 可簡化用戶端與後端服務之間的訊息傳遞。</span><span class="sxs-lookup"><span data-stu-id="406ad-110">At the application level, gRPC streamlines messaging between clients and back-end services.</span></span> <span data-ttu-id="406ad-111">從 Google 開始，gRPC 是開放原始碼和  [雲端原生運算基礎 ](https://www.cncf.io/) 的一部分， (CNCF 雲端原生供應專案的) 生態系統。</span><span class="sxs-lookup"><span data-stu-id="406ad-111">Originating from Google, gRPC is open source and part of the  [Cloud Native Computing Foundation (CNCF)](https://www.cncf.io/) ecosystem of cloud-native offerings.</span></span> <span data-ttu-id="406ad-112">CNCF 會考慮 gRPC [發展專案](https://github.com/cncf/toc/blob/master/process/graduation_criteria.adoc)。</span><span class="sxs-lookup"><span data-stu-id="406ad-112">CNCF considers gRPC an [incubating project](https://github.com/cncf/toc/blob/master/process/graduation_criteria.adoc).</span></span> <span data-ttu-id="406ad-113">發展表示終端使用者在生產應用程式中使用此技術，而專案的參與者數目狀況良好。</span><span class="sxs-lookup"><span data-stu-id="406ad-113">Incubating means end users are using the technology in production applications, and the project has a healthy number of contributors.</span></span>

<span data-ttu-id="406ad-114">一般的 gRPC 用戶端應用程式會公開本機的同進程函數，以執行商務作業。</span><span class="sxs-lookup"><span data-stu-id="406ad-114">A typical gRPC client app will expose a local, in-process function that implements a business operation.</span></span> <span data-ttu-id="406ad-115">在幕後，該區域函數會叫用遠端電腦上的另一個函式。</span><span class="sxs-lookup"><span data-stu-id="406ad-115">Under the covers, that local function invokes another function on a remote machine.</span></span> <span data-ttu-id="406ad-116">所謂的本機呼叫基本上會成為遠端服務的透明跨進程呼叫。</span><span class="sxs-lookup"><span data-stu-id="406ad-116">What appears to be a local call essentially becomes a transparent out-of-process call to a remote service.</span></span> <span data-ttu-id="406ad-117">RPC 檢測會將點對點網路通訊、序列化以及電腦之間的執行抽象化。</span><span class="sxs-lookup"><span data-stu-id="406ad-117">The RPC plumbing abstracts the point-to-point networking communication, serialization, and execution between computers.</span></span>

<span data-ttu-id="406ad-118">在雲端原生應用程式中，開發人員通常可以跨程式設計語言、架構和技術。</span><span class="sxs-lookup"><span data-stu-id="406ad-118">In cloud-native applications, developers often work across programming languages, frameworks, and technologies.</span></span> <span data-ttu-id="406ad-119">這種 *互通性* 會使訊息合約和跨平臺通訊所需的管道變得更複雜。</span><span class="sxs-lookup"><span data-stu-id="406ad-119">This *interoperability* complicates message contracts and the plumbing required for cross-platform communication.</span></span>  <span data-ttu-id="406ad-120">gRPC 會提供「統一水準圖層」，以摘要說明這些考慮。</span><span class="sxs-lookup"><span data-stu-id="406ad-120">gRPC provides a "uniform horizontal layer" that abstracts these concerns.</span></span> <span data-ttu-id="406ad-121">開發人員在其原生平臺中撰寫的程式碼著重于商務功能，而 gRPC 會處理通訊管道。</span><span class="sxs-lookup"><span data-stu-id="406ad-121">Developers code in their native platform focused on business functionality, while gRPC handles communication plumbing.</span></span>

<span data-ttu-id="406ad-122">gRPC 為最受歡迎的開發堆疊提供完整的支援，包括 JAVA、JavaScript、c #、Go、Swift 和 NodeJS。</span><span class="sxs-lookup"><span data-stu-id="406ad-122">gRPC offers comprehensive support across most popular development stacks, including Java, JavaScript, C#, Go, Swift, and NodeJS.</span></span>

## <a name="grpc-benefits"></a><span data-ttu-id="406ad-123">gRPC 權益</span><span class="sxs-lookup"><span data-stu-id="406ad-123">gRPC Benefits</span></span>

<span data-ttu-id="406ad-124">gRPC 會針對其傳輸通訊協定使用 HTTP/2。</span><span class="sxs-lookup"><span data-stu-id="406ad-124">gRPC uses HTTP/2 for its transport protocol.</span></span> <span data-ttu-id="406ad-125">與 HTTP 1.1 相容時，HTTP/2 有許多先進的功能：</span><span class="sxs-lookup"><span data-stu-id="406ad-125">While compatible with HTTP 1.1, HTTP/2 features many advanced capabilities:</span></span>

- <span data-ttu-id="406ad-126">用於資料傳輸的二進位框架通訊協定，與以文字為基礎的 HTTP 1.1 不同。</span><span class="sxs-lookup"><span data-stu-id="406ad-126">A binary framing protocol for data transport - unlike HTTP 1.1, which is text based.</span></span>
- <span data-ttu-id="406ad-127">透過相同連線傳送多個平行要求的多工支援-HTTP 1.1 一次會將處理限制為一個要求/回應訊息。</span><span class="sxs-lookup"><span data-stu-id="406ad-127">Multiplexing support for sending multiple parallel requests over the same connection - HTTP 1.1 limits processing to one request/response message at a time.</span></span>
- <span data-ttu-id="406ad-128">雙向全雙工通訊，可同時傳送用戶端要求和伺服器回應。</span><span class="sxs-lookup"><span data-stu-id="406ad-128">Bidirectional full-duplex communication for sending both client requests and server responses simultaneously.</span></span>
- <span data-ttu-id="406ad-129">內建串流，可讓要求和回應以非同步方式串流處理大型資料集。</span><span class="sxs-lookup"><span data-stu-id="406ad-129">Built-in streaming enabling requests and responses to asynchronously stream large data sets.</span></span>
- <span data-ttu-id="406ad-130">減少網路使用量的標頭壓縮。</span><span class="sxs-lookup"><span data-stu-id="406ad-130">Header compression that reduces network usage.</span></span>

<span data-ttu-id="406ad-131">gRPC 是輕量且高效能。</span><span class="sxs-lookup"><span data-stu-id="406ad-131">gRPC is lightweight and highly performant.</span></span> <span data-ttu-id="406ad-132">其最多可比 JSON 序列化更快，且訊息60-80% 較小。</span><span class="sxs-lookup"><span data-stu-id="406ad-132">It can be up to 8x faster than JSON serialization with messages 60-80% smaller.</span></span> <span data-ttu-id="406ad-133">在 Microsoft [Windows Communication Foundation (WCF) ](../../framework/wcf/whats-wcf.md) 說法中，gRPC 效能超過高度優化 [NetTCP](/dotnet/api/system.servicemodel.nettcpbinding?view=netframework-4.8)系結的速度和效率。</span><span class="sxs-lookup"><span data-stu-id="406ad-133">In Microsoft [Windows Communication Foundation (WCF)](../../framework/wcf/whats-wcf.md) parlance, gRPC performance exceeds the speed and efficiency of the highly optimized [NetTCP bindings](/dotnet/api/system.servicemodel.nettcpbinding?view=netframework-4.8).</span></span> <span data-ttu-id="406ad-134">不同于 NetTCP （喜好 Microsoft stack），gRPC 是跨平臺。</span><span class="sxs-lookup"><span data-stu-id="406ad-134">Unlike NetTCP, which favors the Microsoft stack, gRPC is cross-platform.</span></span>

## <a name="protocol-buffers"></a><span data-ttu-id="406ad-135">通訊協定緩衝區</span><span class="sxs-lookup"><span data-stu-id="406ad-135">Protocol Buffers</span></span>

<span data-ttu-id="406ad-136">gRPC 採用稱為 [通訊協定緩衝區](https://developers.google.com/protocol-buffers/docs/overview)的開放原始碼技術。</span><span class="sxs-lookup"><span data-stu-id="406ad-136">gRPC embraces an open-source technology called [Protocol Buffers](https://developers.google.com/protocol-buffers/docs/overview).</span></span> <span data-ttu-id="406ad-137">它們提供高效率且與平臺無關的序列化格式，可將服務傳送給彼此的結構化訊息進行序列化。</span><span class="sxs-lookup"><span data-stu-id="406ad-137">They provide a highly efficient and platform-neutral serialization format for serializing structured messages that services send to each other.</span></span> <span data-ttu-id="406ad-138">使用跨平臺介面定義語言 (IDL) ，開發人員會定義每個微服務的服務合約。</span><span class="sxs-lookup"><span data-stu-id="406ad-138">Using a cross-platform Interface Definition Language (IDL), developers define a service contract for each microservice.</span></span> <span data-ttu-id="406ad-139">合約（實作為以文字為基礎的檔案 `.proto` ）會描述每個服務的方法、輸入和輸出。</span><span class="sxs-lookup"><span data-stu-id="406ad-139">The contract, implemented as a text-based `.proto` file, describes the methods, inputs, and outputs for each service.</span></span> <span data-ttu-id="406ad-140">相同的合約檔案可以用來 gRPC 以不同開發平臺為基礎的用戶端和服務。</span><span class="sxs-lookup"><span data-stu-id="406ad-140">The same contract file can be used for gRPC clients and services built on different development platforms.</span></span>

<span data-ttu-id="406ad-141">Protobuf 編譯器會使用 proto 檔案， `protoc` 為您的目標平臺產生用戶端和服務程式代碼。</span><span class="sxs-lookup"><span data-stu-id="406ad-141">Using the proto file, the Protobuf compiler, `protoc`, generates both client and service code for your target platform.</span></span> <span data-ttu-id="406ad-142">此程式碼包含下列元件：</span><span class="sxs-lookup"><span data-stu-id="406ad-142">The code includes the following components:</span></span>

- <span data-ttu-id="406ad-143">用戶端和服務所共用的強型別物件，代表訊息的服務作業和資料元素。</span><span class="sxs-lookup"><span data-stu-id="406ad-143">Strongly typed objects, shared by the client and service, that represent the service operations and data elements for a message.</span></span>
- <span data-ttu-id="406ad-144">強型別基類，具有遠端 gRPC 服務可以繼承和擴充的必要網路配管。</span><span class="sxs-lookup"><span data-stu-id="406ad-144">A strongly typed base class with the required network plumbing that the remote gRPC service can inherit and extend.</span></span>
- <span data-ttu-id="406ad-145">用戶端存根，包含叫用遠端 gRPC 服務所需的管線。</span><span class="sxs-lookup"><span data-stu-id="406ad-145">A client stub that contains the required plumbing to invoke the remote gRPC service.</span></span>

<span data-ttu-id="406ad-146">在執行時間，每個訊息都會序列化為標準 Protobuf 標記法，並在用戶端與遠端服務之間交換。</span><span class="sxs-lookup"><span data-stu-id="406ad-146">At runtime, each message is serialized as a standard Protobuf representation and exchanged between the client and remote service.</span></span> <span data-ttu-id="406ad-147">不同于 JSON 或 XML，Protobuf 訊息會序列化為編譯的二進位位元組。</span><span class="sxs-lookup"><span data-stu-id="406ad-147">Unlike JSON or XML, Protobuf messages are serialized as compiled binary bytes.</span></span>

<span data-ttu-id="406ad-148">Microsoft 架構網站提供的 [WCF 開發人員 gRPC](../grpc-for-wcf-developers/index.md)書籍，提供 GRPC 和通訊協定緩衝區的深入探討。</span><span class="sxs-lookup"><span data-stu-id="406ad-148">The book, [gRPC for WCF Developers](../grpc-for-wcf-developers/index.md), available from the Microsoft Architecture site, provides in-depth coverage of gRPC and Protocol Buffers.</span></span>

## <a name="grpc-support-in-net"></a><span data-ttu-id="406ad-149">.NET 中的 gRPC 支援</span><span class="sxs-lookup"><span data-stu-id="406ad-149">gRPC support in .NET</span></span>

<span data-ttu-id="406ad-150">gRPC 已整合到 .NET Core 3.0 SDK 和更新版本中。</span><span class="sxs-lookup"><span data-stu-id="406ad-150">gRPC is integrated into .NET Core 3.0 SDK and later.</span></span> <span data-ttu-id="406ad-151">以下是支援的工具：</span><span class="sxs-lookup"><span data-stu-id="406ad-151">The following tools support it:</span></span>

- <span data-ttu-id="406ad-152">已安裝 網頁程式開發工作負載的 Visual Studio 2019 16.3 版或更新版本。</span><span class="sxs-lookup"><span data-stu-id="406ad-152">Visual Studio 2019, version 16.3 or later, with the web development workload installed.</span></span>
- <span data-ttu-id="406ad-153">Visual Studio Code</span><span class="sxs-lookup"><span data-stu-id="406ad-153">Visual Studio Code</span></span>
- <span data-ttu-id="406ad-154">dotnet CLI</span><span class="sxs-lookup"><span data-stu-id="406ad-154">the dotnet CLI</span></span>

<span data-ttu-id="406ad-155">SDK 包含用於端點路由、內建 IoC 和記錄的工具。</span><span class="sxs-lookup"><span data-stu-id="406ad-155">The SDK includes tooling for endpoint routing, built-in IoC, and logging.</span></span> <span data-ttu-id="406ad-156">開放原始碼 Kestrel web 伺服器支援 HTTP/2 連接。</span><span class="sxs-lookup"><span data-stu-id="406ad-156">The open-source Kestrel web server supports HTTP/2 connections.</span></span> <span data-ttu-id="406ad-157">圖4-20 顯示的 Visual Studio 2019 範本會 scaffold gRPC 服務的基本架構專案。</span><span class="sxs-lookup"><span data-stu-id="406ad-157">Figure 4-20 shows a Visual Studio 2019 template that scaffolds a skeleton project for a gRPC service.</span></span> <span data-ttu-id="406ad-158">請注意 .NET Core 如何完全支援 Windows、Linux 和 macOS。</span><span class="sxs-lookup"><span data-stu-id="406ad-158">Note how .NET Core fully supports Windows, Linux, and macOS.</span></span>

![Visual Studio 2019 中的 gRPC 支援](./media/visual-studio-2019-grpc-template.png)

<span data-ttu-id="406ad-160">**圖 4-20**：</span><span class="sxs-lookup"><span data-stu-id="406ad-160">**Figure 4-20**.</span></span> <span data-ttu-id="406ad-161">Visual Studio 2019 中的 gRPC 支援</span><span class="sxs-lookup"><span data-stu-id="406ad-161">gRPC support in Visual Studio 2019</span></span>
  
<span data-ttu-id="406ad-162">圖4-21 顯示的基本架構 gRPC 服務是由 Visual Studio 2019 中包含的內建架構所產生。</span><span class="sxs-lookup"><span data-stu-id="406ad-162">Figure 4-21 shows the skeleton gRPC service generated from the built-in scaffolding included in Visual Studio 2019.</span></span>  

![Visual Studio 2019 中的 gRPC 專案](./media/grpc-project.png  )

<span data-ttu-id="406ad-164">**圖 4-21**：</span><span class="sxs-lookup"><span data-stu-id="406ad-164">**Figure 4-21**.</span></span> <span data-ttu-id="406ad-165">Visual Studio 2019 中的 gRPC 專案</span><span class="sxs-lookup"><span data-stu-id="406ad-165">gRPC project in Visual Studio 2019</span></span>

<span data-ttu-id="406ad-166">在上圖中，請注意 proto 描述檔案和服務程式代碼。</span><span class="sxs-lookup"><span data-stu-id="406ad-166">In the previous figure, note the proto description file and service code.</span></span> <span data-ttu-id="406ad-167">您很快就會看到，Visual Studio 會在啟動類別和基礎專案檔中產生額外的設定。</span><span class="sxs-lookup"><span data-stu-id="406ad-167">As you'll see shortly, Visual Studio generates additional configuration in both the Startup class and underlying project file.</span></span>

## <a name="grpc-usage"></a><span data-ttu-id="406ad-168">gRPC 使用方式</span><span class="sxs-lookup"><span data-stu-id="406ad-168">gRPC usage</span></span>

<span data-ttu-id="406ad-169">適用于下列案例的 gRPC：</span><span class="sxs-lookup"><span data-stu-id="406ad-169">Favor gRPC for the following scenarios:</span></span>

- <span data-ttu-id="406ad-170">同步後端微服務對微服務通訊，需要立即回應才能繼續處理。</span><span class="sxs-lookup"><span data-stu-id="406ad-170">Synchronous backend microservice-to-microservice communication where an immediate response is required to continue processing.</span></span>
- <span data-ttu-id="406ad-171">多語言需要支援混合式程式設計平臺的環境。</span><span class="sxs-lookup"><span data-stu-id="406ad-171">Polyglot environments that need to support mixed programming platforms.</span></span>
- <span data-ttu-id="406ad-172">效能至關重要的低延遲和高輸送量通訊。</span><span class="sxs-lookup"><span data-stu-id="406ad-172">Low latency and high throughput communication where performance is critical.</span></span>
- <span data-ttu-id="406ad-173">點對點即時通訊-gRPC 可以即時推播訊息，而不需要輪詢，並且對雙向串流有絕佳的支援。</span><span class="sxs-lookup"><span data-stu-id="406ad-173">Point-to-point real-time communication - gRPC can push messages in real time without polling and has excellent support for bi-directional streaming.</span></span>
- <span data-ttu-id="406ad-174">網路受限的環境–二進位 gRPC 訊息一律小於相等的文字型 JSON 訊息。</span><span class="sxs-lookup"><span data-stu-id="406ad-174">Network constrained environments – binary gRPC messages are always smaller than an equivalent text-based JSON message.</span></span>

<span data-ttu-id="406ad-175">在撰寫本文時，gRPC 主要是與後端服務搭配使用。</span><span class="sxs-lookup"><span data-stu-id="406ad-175">At the time, of this writing, gRPC is primarily used with backend services.</span></span> <span data-ttu-id="406ad-176">新式瀏覽器無法提供支援前端 gRPC 用戶端所需的 HTTP/2 控制層級。</span><span class="sxs-lookup"><span data-stu-id="406ad-176">Modern browsers can't provide the level of HTTP/2 control required to support a front-end gRPC client.</span></span> <span data-ttu-id="406ad-177">話雖如此， [GRPC Web 與 .net](https://devblogs.microsoft.com/aspnet/grpc-web-for-net-now-available/) 的支援可讓您從以 JavaScript 或技術為基礎的瀏覽器型應用程式進行 gRPC 通訊 Blazor WebAssembly 。</span><span class="sxs-lookup"><span data-stu-id="406ad-177">That said, there's support for [gRPC-Web with .NET](https://devblogs.microsoft.com/aspnet/grpc-web-for-net-now-available/) that enables gRPC communication from browser-based apps built with JavaScript or Blazor WebAssembly technologies.</span></span> <span data-ttu-id="406ad-178">[GRPC Web](https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-WEB.md) 可讓 ASP.NET Core gRPC 應用程式支援瀏覽器應用程式中的 gRPC 功能：</span><span class="sxs-lookup"><span data-stu-id="406ad-178">[gRPC-Web](https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-WEB.md) enables an ASP.NET Core gRPC app to support gRPC features in browser apps:</span></span>

- <span data-ttu-id="406ad-179">強型別，程式碼產生的用戶端</span><span class="sxs-lookup"><span data-stu-id="406ad-179">Strongly typed, code-generated clients</span></span>
- <span data-ttu-id="406ad-180">Compact Protobuf 訊息</span><span class="sxs-lookup"><span data-stu-id="406ad-180">Compact Protobuf messages</span></span>
- <span data-ttu-id="406ad-181">伺服器串流</span><span class="sxs-lookup"><span data-stu-id="406ad-181">Server streaming</span></span>

## <a name="grpc-implementation"></a><span data-ttu-id="406ad-182">gRPC 執行</span><span class="sxs-lookup"><span data-stu-id="406ad-182">gRPC implementation</span></span>

<span data-ttu-id="406ad-183">Microsoft 的 [容器上 eShop](https://github.com/dotnet-architecture/eShopOnContainers)的微服務參考架構會顯示如何在 .net Core 應用程式中執行 gRPC 服務。</span><span class="sxs-lookup"><span data-stu-id="406ad-183">The microservice reference architecture, [eShop on Containers](https://github.com/dotnet-architecture/eShopOnContainers), from Microsoft, shows how to implement gRPC services in .NET Core applications.</span></span> <span data-ttu-id="406ad-184">圖4-22 提供後端架構。</span><span class="sxs-lookup"><span data-stu-id="406ad-184">Figure 4-22 presents the back-end architecture.</span></span>

![容器上 eShop 的後端架構](./media/eshop-with-aggregators.png)

<span data-ttu-id="406ad-186">**圖 4-22**。</span><span class="sxs-lookup"><span data-stu-id="406ad-186">**Figure 4-22**.</span></span> <span data-ttu-id="406ad-187">容器上 eShop 的後端架構</span><span class="sxs-lookup"><span data-stu-id="406ad-187">Backend architecture for eShop on Containers</span></span>

<span data-ttu-id="406ad-188">在上圖中，請注意 eShop 如何藉由公開多個 API 閘道，來將 [前端模式的後端](/azure/architecture/patterns/backends-for-frontends) 帶 (BFF) 。</span><span class="sxs-lookup"><span data-stu-id="406ad-188">In the previous figure, note how eShop embraces the [Backend for Frontends pattern](/azure/architecture/patterns/backends-for-frontends) (BFF) by exposing multiple API gateways.</span></span> <span data-ttu-id="406ad-189">本章節稍早討論過 BFF 模式。</span><span class="sxs-lookup"><span data-stu-id="406ad-189">We discussed the BFF pattern earlier in this chapter.</span></span> <span data-ttu-id="406ad-190">請密切注意位於 Web 購物 API 閘道與後端購物微服務之間的灰色)  (。</span><span class="sxs-lookup"><span data-stu-id="406ad-190">Pay close attention to the Aggregator microservice (in gray) that sits between the Web-Shopping API Gateway and backend Shopping microservices.</span></span> <span data-ttu-id="406ad-191">匯總工具會接收來自用戶端的單一要求、將其分派至各種微服務、匯總結果，並將其傳回給提出要求的用戶端。</span><span class="sxs-lookup"><span data-stu-id="406ad-191">The Aggregator receives a single request from a client, dispatches it to various microservices, aggregates the results, and sends them back to the requesting client.</span></span> <span data-ttu-id="406ad-192">這類作業通常需要同步通訊，以產生立即回應。</span><span class="sxs-lookup"><span data-stu-id="406ad-192">Such operations typically require synchronous communication as to produce an immediate response.</span></span> <span data-ttu-id="406ad-193">在 eShop 中，會使用 gRPC 來執行來自匯總者的後端呼叫，如圖4-23 所示。</span><span class="sxs-lookup"><span data-stu-id="406ad-193">In eShop, backend calls from the Aggregator are performed using gRPC as shown in Figure 4-23.</span></span>

![容器上 eShop 中的 gRPC](./media/grpc-implementation.png)

<span data-ttu-id="406ad-195">**圖 4-23**：</span><span class="sxs-lookup"><span data-stu-id="406ad-195">**Figure 4-23**.</span></span> <span data-ttu-id="406ad-196">容器上 eShop 中的 gRPC</span><span class="sxs-lookup"><span data-stu-id="406ad-196">gRPC in eShop on Containers</span></span>

<span data-ttu-id="406ad-197">gRPC 通訊需要用戶端和伺服器元件。</span><span class="sxs-lookup"><span data-stu-id="406ad-197">gRPC communication requires both client and server components.</span></span> <span data-ttu-id="406ad-198">在上圖中，請注意購物匯總工具如何實行 gRPC 用戶端。</span><span class="sxs-lookup"><span data-stu-id="406ad-198">In the previous figure, note how the Shopping Aggregator implements a gRPC client.</span></span> <span data-ttu-id="406ad-199">用戶端會進行同步的 gRPC 呼叫， (以紅色) 至後端微服務，每個都會執行 gRPC 伺服器。</span><span class="sxs-lookup"><span data-stu-id="406ad-199">The client makes synchronous gRPC calls (in red) to backend microservices, each of which implement a gRPC server.</span></span> <span data-ttu-id="406ad-200">用戶端和伺服器都利用 .NET Core SDK 的內建 gRPC。</span><span class="sxs-lookup"><span data-stu-id="406ad-200">Both the client and server take advantage of the built-in gRPC plumbing from the .NET Core SDK.</span></span> <span data-ttu-id="406ad-201">用戶端 *存根* 提供可叫用遠端 gRPC 呼叫的管道。</span><span class="sxs-lookup"><span data-stu-id="406ad-201">Client-side *stubs* provide the plumbing to invoke remote gRPC calls.</span></span> <span data-ttu-id="406ad-202">伺服器端元件提供自訂服務類別可以繼承和使用的 gRPC 配管。</span><span class="sxs-lookup"><span data-stu-id="406ad-202">Server-side components provide gRPC plumbing that custom service classes can inherit and consume.</span></span>

<span data-ttu-id="406ad-203">公開 RESTful API 和 gRPC 通訊的微服務需要多個端點來管理流量。</span><span class="sxs-lookup"><span data-stu-id="406ad-203">Microservices that expose both a RESTful API and gRPC communication require multiple endpoints to manage traffic.</span></span> <span data-ttu-id="406ad-204">您會開啟一個端點，接聽 RESTful 呼叫的 HTTP 流量，另一個用於 gRPC 呼叫。</span><span class="sxs-lookup"><span data-stu-id="406ad-204">You would open an endpoint that listens for HTTP traffic for the RESTful calls and another for gRPC calls.</span></span> <span data-ttu-id="406ad-205">必須針對 gRPC 通訊所需的 HTTP/2 通訊協定設定 gRPC 端點。</span><span class="sxs-lookup"><span data-stu-id="406ad-205">The gRPC endpoint must be configured for the HTTP/2 protocol that is required for gRPC communication.</span></span>

<span data-ttu-id="406ad-206">雖然我們致力於將微服務與非同步通訊模式分離，但有些作業需要直接呼叫。</span><span class="sxs-lookup"><span data-stu-id="406ad-206">While we strive to decouple microservices with asynchronous communication patterns, some operations require direct calls.</span></span> <span data-ttu-id="406ad-207">gRPC 應該是微服務之間直接同步通訊的主要選擇。</span><span class="sxs-lookup"><span data-stu-id="406ad-207">gRPC should be the primary choice for direct synchronous communication between microservices.</span></span> <span data-ttu-id="406ad-208">它是以 HTTP/2 和通訊協定緩衝區為基礎的高效能通訊協定，讓它成為絕佳的選擇。</span><span class="sxs-lookup"><span data-stu-id="406ad-208">Its high-performance communication protocol, based on HTTP/2 and protocol buffers, make it a perfect choice.</span></span>

## <a name="looking-ahead"></a><span data-ttu-id="406ad-209">展望</span><span class="sxs-lookup"><span data-stu-id="406ad-209">Looking ahead</span></span>

<span data-ttu-id="406ad-210">GRPC 會繼續為雲端原生系統提供吸引力。</span><span class="sxs-lookup"><span data-stu-id="406ad-210">Looking ahead, gRPC will continue to gain traction for cloud-native systems.</span></span> <span data-ttu-id="406ad-211">效能優勢和開發的便利性很吸引人。</span><span class="sxs-lookup"><span data-stu-id="406ad-211">The performance benefits and ease of development are compelling.</span></span> <span data-ttu-id="406ad-212">不過，REST 可能會很長一段時間。</span><span class="sxs-lookup"><span data-stu-id="406ad-212">However, REST will likely be around for a long time.</span></span> <span data-ttu-id="406ad-213">它擅長公開的 Api，並基於回溯相容性的理由。</span><span class="sxs-lookup"><span data-stu-id="406ad-213">It excels for publicly exposed APIs and for backward compatibility reasons.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="406ad-214">[上一個](service-to-service-communication.md) 
>[下一步](service-mesh-communication-infrastructure.md)</span><span class="sxs-lookup"><span data-stu-id="406ad-214">[Previous](service-to-service-communication.md)
[Next](service-mesh-communication-infrastructure.md)</span></span>
