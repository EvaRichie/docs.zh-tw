---
title: 應用程式復原模式
description: 架構適用于 Azure 的雲端原生 .NET 應用程式 |應用程式復原模式
author: robvet
ms.date: 05/13/2020
ms.openlocfilehash: bb72e47704c833a2ce86f103a66b0414ce3a37ff
ms.sourcegitcommit: 27db07ffb26f76912feefba7b884313547410db5
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 05/19/2020
ms.locfileid: "83614316"
---
# <a name="application-resiliency-patterns"></a><span data-ttu-id="becf8-103">應用程式復原模式</span><span class="sxs-lookup"><span data-stu-id="becf8-103">Application resiliency patterns</span></span>

<span data-ttu-id="becf8-104">第一道防線是應用程式恢復功能。</span><span class="sxs-lookup"><span data-stu-id="becf8-104">The first line of defense is application resiliency.</span></span>

<span data-ttu-id="becf8-105">雖然您可以投入相當長的時間來撰寫自己的復原架構，但這類產品已經存在。</span><span class="sxs-lookup"><span data-stu-id="becf8-105">While you could invest considerable time writing your own resiliency framework, such products already exist.</span></span> <span data-ttu-id="becf8-106">[Polly](http://www.thepollyproject.org/)是完整的 .net 復原和暫時性錯誤處理程式庫，可讓開發人員以流暢且安全線程的方式來表示復原原則。</span><span class="sxs-lookup"><span data-stu-id="becf8-106">[Polly](http://www.thepollyproject.org/) is a comprehensive .NET resilience and transient-fault-handling library that allows developers to express resiliency policies in a fluent and thread-safe manner.</span></span> <span data-ttu-id="becf8-107">Polly 是以 .NET Framework 或 .NET Core 所建立的應用程式為目標。</span><span class="sxs-lookup"><span data-stu-id="becf8-107">Polly targets applications built with either the .NET Framework or .NET Core.</span></span> <span data-ttu-id="becf8-108">下表描述可在 Polly 程式庫中取得的復原功能（稱為 `policies` ）。</span><span class="sxs-lookup"><span data-stu-id="becf8-108">The following table describes the resiliency features, called `policies`, available in the Polly Library.</span></span> <span data-ttu-id="becf8-109">可以個別套用或群組在一起。</span><span class="sxs-lookup"><span data-stu-id="becf8-109">They can be applied individually or grouped together.</span></span>

| <span data-ttu-id="becf8-110">原則</span><span class="sxs-lookup"><span data-stu-id="becf8-110">Policy</span></span> | <span data-ttu-id="becf8-111">體驗</span><span class="sxs-lookup"><span data-stu-id="becf8-111">Experience</span></span> |
| :-------- | :-------- |
| <span data-ttu-id="becf8-112">重試</span><span class="sxs-lookup"><span data-stu-id="becf8-112">Retry</span></span> | <span data-ttu-id="becf8-113">設定指定作業的重試作業。</span><span class="sxs-lookup"><span data-stu-id="becf8-113">Configures retry operations on designated operations.</span></span> |
| <span data-ttu-id="becf8-114">斷路器</span><span class="sxs-lookup"><span data-stu-id="becf8-114">Circuit Breaker</span></span> | <span data-ttu-id="becf8-115">當錯誤超過設定的閾值時，封鎖要求的作業（預先定義的期間）</span><span class="sxs-lookup"><span data-stu-id="becf8-115">Blocks requested operations for a predefined period when faults exceed a configured threshold</span></span> |
| <span data-ttu-id="becf8-116">逾時</span><span class="sxs-lookup"><span data-stu-id="becf8-116">Timeout</span></span> | <span data-ttu-id="becf8-117">限制呼叫者可以等候回應的持續時間。</span><span class="sxs-lookup"><span data-stu-id="becf8-117">Places limit on the duration for which a caller can wait for a response.</span></span> |
| <span data-ttu-id="becf8-118">隔艙</span><span class="sxs-lookup"><span data-stu-id="becf8-118">Bulkhead</span></span> | <span data-ttu-id="becf8-119">將動作限制為固定大小的資源集區，以防止從淹沒資源失敗的呼叫。</span><span class="sxs-lookup"><span data-stu-id="becf8-119">Constrains actions to fixed-size resource pool to prevent failing calls from swamping a resource.</span></span> |
| <span data-ttu-id="becf8-120">快取</span><span class="sxs-lookup"><span data-stu-id="becf8-120">Cache</span></span> | <span data-ttu-id="becf8-121">會自動儲存回應。</span><span class="sxs-lookup"><span data-stu-id="becf8-121">Stores responses automatically.</span></span> |
| <span data-ttu-id="becf8-122">後援</span><span class="sxs-lookup"><span data-stu-id="becf8-122">Fallback</span></span> | <span data-ttu-id="becf8-123">定義失敗時的結構化行為。</span><span class="sxs-lookup"><span data-stu-id="becf8-123">Defines structured behavior upon a failure.</span></span> |

<span data-ttu-id="becf8-124">請注意，在上圖中，復原原則會套用至要求訊息，不論是來自外部用戶端還是後端服務。</span><span class="sxs-lookup"><span data-stu-id="becf8-124">Note how in the previous figure the resiliency policies apply to request messages, whether coming from an external client or back-end service.</span></span> <span data-ttu-id="becf8-125">其目標是要補償可能暫時無法使用之服務的要求。</span><span class="sxs-lookup"><span data-stu-id="becf8-125">The goal is to compensate the request for a service that might be momentarily unavailable.</span></span> <span data-ttu-id="becf8-126">這些短期的中斷通常會使用下表所示的 HTTP 狀態碼來進行資訊清單。</span><span class="sxs-lookup"><span data-stu-id="becf8-126">These short-lived interruptions typically manifest themselves with the HTTP status codes shown in the following table.</span></span>

| <span data-ttu-id="becf8-127">HTTP 狀態碼</span><span class="sxs-lookup"><span data-stu-id="becf8-127">HTTP Status Code</span></span>| <span data-ttu-id="becf8-128">原因</span><span class="sxs-lookup"><span data-stu-id="becf8-128">Cause</span></span> |
| :-------- | :-------- |
| <span data-ttu-id="becf8-129">404</span><span class="sxs-lookup"><span data-stu-id="becf8-129">404</span></span> | <span data-ttu-id="becf8-130">找不到</span><span class="sxs-lookup"><span data-stu-id="becf8-130">Not Found</span></span> |
| <span data-ttu-id="becf8-131">408</span><span class="sxs-lookup"><span data-stu-id="becf8-131">408</span></span> | <span data-ttu-id="becf8-132">要求逾時</span><span class="sxs-lookup"><span data-stu-id="becf8-132">Request timeout</span></span> |
| <span data-ttu-id="becf8-133">429</span><span class="sxs-lookup"><span data-stu-id="becf8-133">429</span></span> | <span data-ttu-id="becf8-134">太多要求（您很有可能已進行節流）</span><span class="sxs-lookup"><span data-stu-id="becf8-134">Too many requests (you've most likely been throttled)</span></span> |
| <span data-ttu-id="becf8-135">502</span><span class="sxs-lookup"><span data-stu-id="becf8-135">502</span></span> | <span data-ttu-id="becf8-136">閘道不正確</span><span class="sxs-lookup"><span data-stu-id="becf8-136">Bad gateway</span></span> |
| <span data-ttu-id="becf8-137">503</span><span class="sxs-lookup"><span data-stu-id="becf8-137">503</span></span> | <span data-ttu-id="becf8-138">服務無法使用</span><span class="sxs-lookup"><span data-stu-id="becf8-138">Service unavailable</span></span> |
| <span data-ttu-id="becf8-139">504</span><span class="sxs-lookup"><span data-stu-id="becf8-139">504</span></span> | <span data-ttu-id="becf8-140">閘道超時</span><span class="sxs-lookup"><span data-stu-id="becf8-140">Gateway timeout</span></span> |

<span data-ttu-id="becf8-141">問題：您是否要重試 HTTP 狀態碼 403-禁止？</span><span class="sxs-lookup"><span data-stu-id="becf8-141">Question: Would you retry an HTTP Status Code of 403 - Forbidden?</span></span> <span data-ttu-id="becf8-142">不可以。</span><span class="sxs-lookup"><span data-stu-id="becf8-142">No.</span></span> <span data-ttu-id="becf8-143">在這裡，系統會正常運作，但會通知呼叫者未獲授權執行要求的作業。</span><span class="sxs-lookup"><span data-stu-id="becf8-143">Here, the system is functioning properly, but informing the caller that they aren't authorized to perform the requested operation.</span></span> <span data-ttu-id="becf8-144">請務必小心，只重試失敗所造成的作業。</span><span class="sxs-lookup"><span data-stu-id="becf8-144">Care must be taken to retry only those operations caused by failures.</span></span>

<span data-ttu-id="becf8-145">如第1章所建議，建立雲端原生應用程式的 Microsoft 開發人員應該以 .NET Core 平臺為目標。</span><span class="sxs-lookup"><span data-stu-id="becf8-145">As recommended in Chapter 1, Microsoft developers constructing cloud-native applications should target the .NET Core platform.</span></span> <span data-ttu-id="becf8-146">2.1 版引進了[HTTPClientFactory](https://www.stevejgordon.co.uk/introduction-to-httpclientfactory-aspnetcore)程式庫，可用於建立與 URL 型資源互動的 HTTP 用戶端實例。</span><span class="sxs-lookup"><span data-stu-id="becf8-146">Version 2.1 introduced the [HTTPClientFactory](https://www.stevejgordon.co.uk/introduction-to-httpclientfactory-aspnetcore) library for creating HTTP Client instances for interacting with URL-based resources.</span></span> <span data-ttu-id="becf8-147">取代原始的 HTTPClient 類別，factory 類別支援許多增強功能，其中一個與 Polly 復原程式庫[緊密整合](../microservices/implement-resilient-applications/implement-http-call-retries-exponential-backoff-polly.md)。</span><span class="sxs-lookup"><span data-stu-id="becf8-147">Superseding the original HTTPClient class, the factory class supports many enhanced features, one of which is [tight integration](../microservices/implement-resilient-applications/implement-http-call-retries-exponential-backoff-polly.md) with the Polly resiliency library.</span></span> <span data-ttu-id="becf8-148">有了這項功能，您就可以在應用程式啟動類別中輕鬆定義復原原則，以處理部分失敗和連接問題。</span><span class="sxs-lookup"><span data-stu-id="becf8-148">With it, you can easily define resiliency policies in the application Startup class to handle partial failures and connectivity issues.</span></span>

<span data-ttu-id="becf8-149">接下來，讓我們展開重試和斷路器模式。</span><span class="sxs-lookup"><span data-stu-id="becf8-149">Next, let's expand on retry and circuit breaker patterns.</span></span>

### <a name="retry-pattern"></a><span data-ttu-id="becf8-150">重試模式</span><span class="sxs-lookup"><span data-stu-id="becf8-150">Retry pattern</span></span>

<span data-ttu-id="becf8-151">在分散式雲端原生環境中，服務和雲端資源的呼叫可能會因為暫時性（短期）失敗而失敗，這通常會在短時間後自行修正。</span><span class="sxs-lookup"><span data-stu-id="becf8-151">In a distributed cloud-native environment, calls to services and cloud resources can fail because of transient (short-lived) failures, which typically correct themselves after a brief period of time.</span></span> <span data-ttu-id="becf8-152">執行重試策略可協助雲端原生服務減輕這些案例的風險。</span><span class="sxs-lookup"><span data-stu-id="becf8-152">Implementing a retry strategy helps a cloud-native service mitigate these scenarios.</span></span>

<span data-ttu-id="becf8-153">[重試模式](https://docs.microsoft.com/azure/architecture/patterns/retry)可讓服務以指數方式增加等候時間，重試失敗的要求作業 a （可設定）的次數。</span><span class="sxs-lookup"><span data-stu-id="becf8-153">The [Retry pattern](https://docs.microsoft.com/azure/architecture/patterns/retry) enables a service to retry a failed request operation a (configurable) number of times with an exponentially increasing wait time.</span></span> <span data-ttu-id="becf8-154">圖6-2 顯示重試動作。</span><span class="sxs-lookup"><span data-stu-id="becf8-154">Figure 6-2 shows a retry in action.</span></span>

![動作中的重試模式](./media/retry-pattern.png)

<span data-ttu-id="becf8-156">**圖 6-2**。</span><span class="sxs-lookup"><span data-stu-id="becf8-156">**Figure 6-2**.</span></span> <span data-ttu-id="becf8-157">動作中的重試模式</span><span class="sxs-lookup"><span data-stu-id="becf8-157">Retry pattern in action</span></span>

<span data-ttu-id="becf8-158">在上圖中，已針對要求作業實作為重試模式。</span><span class="sxs-lookup"><span data-stu-id="becf8-158">In the previous figure, a retry pattern has been implemented for a request operation.</span></span> <span data-ttu-id="becf8-159">它會設定為在失敗後的輪詢間隔（等待時間）後最多允許四次重試，每次後續嘗試會以指數方式加倍。</span><span class="sxs-lookup"><span data-stu-id="becf8-159">It's configured to allow up to four retries before failing with a backoff interval (wait time) starting at two seconds, which exponentially doubles for each subsequent attempt.</span></span>

- <span data-ttu-id="becf8-160">第一個調用失敗，並傳回 HTTP 狀態碼500。</span><span class="sxs-lookup"><span data-stu-id="becf8-160">The first invocation fails and returns an HTTP status code of 500.</span></span> <span data-ttu-id="becf8-161">應用程式會等待兩秒，然後重試呼叫。</span><span class="sxs-lookup"><span data-stu-id="becf8-161">The application waits for two seconds and retries the call.</span></span>
- <span data-ttu-id="becf8-162">第二個調用也會失敗，並傳回 HTTP 狀態碼500。</span><span class="sxs-lookup"><span data-stu-id="becf8-162">The second invocation also fails and returns an HTTP status code of 500.</span></span> <span data-ttu-id="becf8-163">應用程式現在會將輪詢間隔加倍到四秒，然後重試呼叫。</span><span class="sxs-lookup"><span data-stu-id="becf8-163">The application now doubles the backoff interval to four seconds and retries the call.</span></span>
- <span data-ttu-id="becf8-164">最後，第三個呼叫會成功。</span><span class="sxs-lookup"><span data-stu-id="becf8-164">Finally, the third call succeeds.</span></span>
- <span data-ttu-id="becf8-165">在此案例中，重試作業最多會嘗試四次重試，同時將輪詢持續時間加倍，再使呼叫失敗。</span><span class="sxs-lookup"><span data-stu-id="becf8-165">In this scenario, the retry operation would have attempted up to four retries while doubling the backoff duration before failing the call.</span></span>
- <span data-ttu-id="becf8-166">第4次重試嘗試失敗，將會叫用回溯原則，以正常處理問題。</span><span class="sxs-lookup"><span data-stu-id="becf8-166">Had the 4th retry attempt failed, a fallback policy would be invoked to gracefully handle the problem.</span></span>

<span data-ttu-id="becf8-167">請務必增加輪詢期間，再重試呼叫以允許服務時間自行修正。</span><span class="sxs-lookup"><span data-stu-id="becf8-167">It's important to increase the backoff period before retrying the call to allow the service time to self-correct.</span></span> <span data-ttu-id="becf8-168">最佳做法是實施以指數方式增加的輪詢（每次重試的間隔加倍），以允許適當的更正時間。</span><span class="sxs-lookup"><span data-stu-id="becf8-168">It's a best practice to implement an exponentially increasing backoff (doubling the period on each retry) to allow adequate correction time.</span></span>

## <a name="circuit-breaker-pattern"></a><span data-ttu-id="becf8-169">斷路器模式</span><span class="sxs-lookup"><span data-stu-id="becf8-169">Circuit breaker pattern</span></span>

<span data-ttu-id="becf8-170">雖然重試模式可以協助搶救在部分失敗中光子的要求，但在某些情況下，失敗可能是因為無法預期的事件而需要較長的時間來解決。</span><span class="sxs-lookup"><span data-stu-id="becf8-170">While the retry pattern can help salvage a request entangled in a partial failure, there are situations where failures can be caused by unanticipated events that will require longer periods of time to resolve.</span></span> <span data-ttu-id="becf8-171">這些錯誤的嚴重性範圍包含失去部分連線到整個服務無法運作。</span><span class="sxs-lookup"><span data-stu-id="becf8-171">These faults can range in severity from a partial loss of connectivity to the complete failure of a service.</span></span> <span data-ttu-id="becf8-172">在這些情況下，應用程式會持續重試不太可能成功的作業，這是無意義的。</span><span class="sxs-lookup"><span data-stu-id="becf8-172">In these situations, it's pointless for an application to continually retry an operation that is unlikely to succeed.</span></span>

<span data-ttu-id="becf8-173">為了讓事情更糟，在未回應的服務上執行連續的重試作業，可以將您移至自我加入的阻絕服務案例，其中會持續呼叫耗盡資源（例如記憶體、執行緒和資料庫連接），導致系統中使用相同資源的不相關部分發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="becf8-173">To make things worse, executing continual retry operations on a non-responsive service can move you into a self-imposed denial of service scenario where you flood your service with continual calls exhausting resources such as memory, threads and database connections, causing failure in unrelated parts of the system that use the same resources.</span></span>

<span data-ttu-id="becf8-174">在這些情況下，最好是讓作業立即失敗，而且只有在可能成功時才嘗試叫用服務。</span><span class="sxs-lookup"><span data-stu-id="becf8-174">In these situations, it would be preferable for the operation to fail immediately and only attempt to invoke the service if it's likely to succeed.</span></span>

<span data-ttu-id="becf8-175">[斷路器模式](https://docs.microsoft.com/azure/architecture/patterns/circuit-breaker)可防止應用程式重複嘗試執行可能失敗的作業。</span><span class="sxs-lookup"><span data-stu-id="becf8-175">The [Circuit Breaker pattern](https://docs.microsoft.com/azure/architecture/patterns/circuit-breaker) can prevent an application from repeatedly trying to execute an operation that's likely to fail.</span></span> <span data-ttu-id="becf8-176">在預先定義的失敗呼叫次數之後，它會封鎖對服務的所有流量。</span><span class="sxs-lookup"><span data-stu-id="becf8-176">After a pre-defined number of failed calls, it blocks all traffic to the service.</span></span> <span data-ttu-id="becf8-177">它會定期允許試用版呼叫來判斷錯誤是否已解決。</span><span class="sxs-lookup"><span data-stu-id="becf8-177">Periodically, it will allow a trial call to determine whether the fault has resolved.</span></span> <span data-ttu-id="becf8-178">圖6-3 顯示作用中的斷路器模式。</span><span class="sxs-lookup"><span data-stu-id="becf8-178">Figure 6-3 shows the Circuit Breaker pattern in action.</span></span>

![動作中的斷路器模式](./media/circuit-breaker-pattern.png)

<span data-ttu-id="becf8-180">**圖 6-3**。</span><span class="sxs-lookup"><span data-stu-id="becf8-180">**Figure 6-3**.</span></span> <span data-ttu-id="becf8-181">動作中的斷路器模式</span><span class="sxs-lookup"><span data-stu-id="becf8-181">Circuit breaker pattern in action</span></span>

<span data-ttu-id="becf8-182">在上圖中，已將斷路器模式新增至原始的重試模式。</span><span class="sxs-lookup"><span data-stu-id="becf8-182">In the previous figure, a Circuit Breaker pattern has been added to the original retry pattern.</span></span> <span data-ttu-id="becf8-183">請注意，100失敗的要求之後，斷路器會開啟，不再允許呼叫服務。</span><span class="sxs-lookup"><span data-stu-id="becf8-183">Note how after 100 failed requests, the circuit breakers opens and no longer allows calls to the service.</span></span> <span data-ttu-id="becf8-184">設定為30秒的 CheckCircuit 值會指定程式庫允許一個要求繼續至服務的頻率。</span><span class="sxs-lookup"><span data-stu-id="becf8-184">The CheckCircuit value, set at 30 seconds, specifies how often the library allows one request to proceed to the service.</span></span> <span data-ttu-id="becf8-185">如果該呼叫成功，則電路會關閉，且服務會再次提供給流量。</span><span class="sxs-lookup"><span data-stu-id="becf8-185">If that call succeeds, the circuit closes and the service is once again available to traffic.</span></span>

<span data-ttu-id="becf8-186">請記住，斷路器模式的目的與重試模式*不同*。</span><span class="sxs-lookup"><span data-stu-id="becf8-186">Keep in mind that the intent of the Circuit Breaker pattern is *different* than that of the Retry pattern.</span></span> <span data-ttu-id="becf8-187">重試模式可讓應用程式在預期會成功的情況下重試操作。</span><span class="sxs-lookup"><span data-stu-id="becf8-187">The Retry pattern enables an application to retry an operation in the expectation that it will succeed.</span></span> <span data-ttu-id="becf8-188">斷路器模式可防止應用程式執行可能失敗的作業。</span><span class="sxs-lookup"><span data-stu-id="becf8-188">The Circuit Breaker pattern prevents an application from doing an operation that is likely to fail.</span></span> <span data-ttu-id="becf8-189">一般而言，應用程式會使用重試模式來透過斷路器叫用作業，以*結合*這兩種模式。</span><span class="sxs-lookup"><span data-stu-id="becf8-189">Typically, an application will *combine* these two patterns by using the Retry pattern to invoke an operation through a circuit breaker.</span></span>

## <a name="testing-for-resiliency"></a><span data-ttu-id="becf8-190">針對復原而測試</span><span class="sxs-lookup"><span data-stu-id="becf8-190">Testing for resiliency</span></span>

<span data-ttu-id="becf8-191">測試復原不一定是以測試應用程式功能（藉由執行單元測試、整合測試等等）的相同方式來完成。</span><span class="sxs-lookup"><span data-stu-id="becf8-191">Testing for resiliency cannot always be done the same way that you test application functionality (by running unit tests, integration tests and so on).</span></span> <span data-ttu-id="becf8-192">相反地，您必須測試端對端工作負載在失敗情況下的執行方式，這只會間歇性發生。</span><span class="sxs-lookup"><span data-stu-id="becf8-192">Instead, you must test how the end-to-end workload performs under failure conditions which only occur intermittently.</span></span> <span data-ttu-id="becf8-193">例如：藉由損毀進程、過期的憑證、使相依服務無法使用等方式插入失敗。[混亂-猴子](https://github.com/Netflix/chaosmonkey)之類的架構可以用於這類混亂測試。</span><span class="sxs-lookup"><span data-stu-id="becf8-193">For example: inject failures by crashing processes, expired certificates, make dependent services unavailable etc. Frameworks like [chaos-monkey](https://github.com/Netflix/chaosmonkey) can be used for such chaos testing.</span></span>

<span data-ttu-id="becf8-194">應用程式復原是處理有問題的要求作業時必須具備的。</span><span class="sxs-lookup"><span data-stu-id="becf8-194">Application resiliency is a must for handling problematic requested operations.</span></span> <span data-ttu-id="becf8-195">但是，這只是故事的一半而已。</span><span class="sxs-lookup"><span data-stu-id="becf8-195">But, it's only half of the story.</span></span> <span data-ttu-id="becf8-196">接下來，我們將討論 Azure 雲端中可用的復原功能。</span><span class="sxs-lookup"><span data-stu-id="becf8-196">Next, we cover resiliency features available in the Azure cloud.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="becf8-197">[上一個](resiliency.md) 
>[下一步](infrastructure-resiliency-azure.md)</span><span class="sxs-lookup"><span data-stu-id="becf8-197">[Previous](resiliency.md)
[Next](infrastructure-resiliency-azure.md)</span></span>
