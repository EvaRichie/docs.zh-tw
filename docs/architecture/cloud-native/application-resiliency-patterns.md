---
title: 應用程式復原模式
description: 設計適用于 Azure 的雲端原生 .NET 應用程式 |應用程式復原模式
author: robvet
ms.date: 05/13/2020
ms.openlocfilehash: e81d6e1d6b95cf0053de3ba557068ff458a59dc9
ms.sourcegitcommit: 5b475c1855b32cf78d2d1bbb4295e4c236f39464
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 09/24/2020
ms.locfileid: "91161148"
---
# <a name="application-resiliency-patterns"></a><span data-ttu-id="3c126-103">應用程式復原模式</span><span class="sxs-lookup"><span data-stu-id="3c126-103">Application resiliency patterns</span></span>

<span data-ttu-id="3c126-104">第一道防線是應用程式復原。</span><span class="sxs-lookup"><span data-stu-id="3c126-104">The first line of defense is application resiliency.</span></span>

<span data-ttu-id="3c126-105">雖然您可以投入相當長的時間來撰寫自己的復原架構，但這類產品已經存在。</span><span class="sxs-lookup"><span data-stu-id="3c126-105">While you could invest considerable time writing your own resiliency framework, such products already exist.</span></span> <span data-ttu-id="3c126-106">[Polly](http://www.thepollyproject.org/) 是完整的 .net 復原和暫時性錯誤處理程式庫，可讓開發人員以流暢且安全線程的方式來表達復原原則。</span><span class="sxs-lookup"><span data-stu-id="3c126-106">[Polly](http://www.thepollyproject.org/) is a comprehensive .NET resilience and transient-fault-handling library that allows developers to express resiliency policies in a fluent and thread-safe manner.</span></span> <span data-ttu-id="3c126-107">Polly 以 .NET Framework 或 .NET Core 為基礎的應用程式為目標。</span><span class="sxs-lookup"><span data-stu-id="3c126-107">Polly targets applications built with either the .NET Framework or .NET Core.</span></span> <span data-ttu-id="3c126-108">下表說明 Polly 程式庫中所提供的復原功能（稱為 `policies` ）。</span><span class="sxs-lookup"><span data-stu-id="3c126-108">The following table describes the resiliency features, called `policies`, available in the Polly Library.</span></span> <span data-ttu-id="3c126-109">它們可以個別套用或群組在一起。</span><span class="sxs-lookup"><span data-stu-id="3c126-109">They can be applied individually or grouped together.</span></span>

| <span data-ttu-id="3c126-110">原則</span><span class="sxs-lookup"><span data-stu-id="3c126-110">Policy</span></span> | <span data-ttu-id="3c126-111">體驗</span><span class="sxs-lookup"><span data-stu-id="3c126-111">Experience</span></span> |
| :-------- | :-------- |
| <span data-ttu-id="3c126-112">重試</span><span class="sxs-lookup"><span data-stu-id="3c126-112">Retry</span></span> | <span data-ttu-id="3c126-113">設定指定作業的重試作業。</span><span class="sxs-lookup"><span data-stu-id="3c126-113">Configures retry operations on designated operations.</span></span> |
| <span data-ttu-id="3c126-114">斷路器</span><span class="sxs-lookup"><span data-stu-id="3c126-114">Circuit Breaker</span></span> | <span data-ttu-id="3c126-115">當錯誤超過設定的臨界值時，封鎖預先定義期間的要求作業</span><span class="sxs-lookup"><span data-stu-id="3c126-115">Blocks requested operations for a predefined period when faults exceed a configured threshold</span></span> |
| <span data-ttu-id="3c126-116">逾時</span><span class="sxs-lookup"><span data-stu-id="3c126-116">Timeout</span></span> | <span data-ttu-id="3c126-117">限制呼叫端可以等候回應的持續時間限制。</span><span class="sxs-lookup"><span data-stu-id="3c126-117">Places limit on the duration for which a caller can wait for a response.</span></span> |
| <span data-ttu-id="3c126-118">隔艙</span><span class="sxs-lookup"><span data-stu-id="3c126-118">Bulkhead</span></span> | <span data-ttu-id="3c126-119">將動作限制為固定大小的資源集區，以防止呼叫淹沒資源。</span><span class="sxs-lookup"><span data-stu-id="3c126-119">Constrains actions to fixed-size resource pool to prevent failing calls from swamping a resource.</span></span> |
| <span data-ttu-id="3c126-120">快取</span><span class="sxs-lookup"><span data-stu-id="3c126-120">Cache</span></span> | <span data-ttu-id="3c126-121">自動儲存回應。</span><span class="sxs-lookup"><span data-stu-id="3c126-121">Stores responses automatically.</span></span> |
| <span data-ttu-id="3c126-122">後援</span><span class="sxs-lookup"><span data-stu-id="3c126-122">Fallback</span></span> | <span data-ttu-id="3c126-123">定義失敗時的結構化行為。</span><span class="sxs-lookup"><span data-stu-id="3c126-123">Defines structured behavior upon a failure.</span></span> |

<span data-ttu-id="3c126-124">請注意，在上圖中，復原原則會套用至要求訊息（不論是來自外部用戶端或後端服務）。</span><span class="sxs-lookup"><span data-stu-id="3c126-124">Note how in the previous figure the resiliency policies apply to request messages, whether coming from an external client or back-end service.</span></span> <span data-ttu-id="3c126-125">其目標是要補償可能會暫時無法使用之服務的要求。</span><span class="sxs-lookup"><span data-stu-id="3c126-125">The goal is to compensate the request for a service that might be momentarily unavailable.</span></span> <span data-ttu-id="3c126-126">這些短暫的中斷通常會以下表所示的 HTTP 狀態碼來資訊清單。</span><span class="sxs-lookup"><span data-stu-id="3c126-126">These short-lived interruptions typically manifest themselves with the HTTP status codes shown in the following table.</span></span>

| <span data-ttu-id="3c126-127">HTTP 狀態碼</span><span class="sxs-lookup"><span data-stu-id="3c126-127">HTTP Status Code</span></span>| <span data-ttu-id="3c126-128">原因</span><span class="sxs-lookup"><span data-stu-id="3c126-128">Cause</span></span> |
| :-------- | :-------- |
| <span data-ttu-id="3c126-129">404</span><span class="sxs-lookup"><span data-stu-id="3c126-129">404</span></span> | <span data-ttu-id="3c126-130">找不到</span><span class="sxs-lookup"><span data-stu-id="3c126-130">Not Found</span></span> |
| <span data-ttu-id="3c126-131">408</span><span class="sxs-lookup"><span data-stu-id="3c126-131">408</span></span> | <span data-ttu-id="3c126-132">要求逾時</span><span class="sxs-lookup"><span data-stu-id="3c126-132">Request timeout</span></span> |
| <span data-ttu-id="3c126-133">429</span><span class="sxs-lookup"><span data-stu-id="3c126-133">429</span></span> | <span data-ttu-id="3c126-134">太多要求 (您很可能已經過節流) </span><span class="sxs-lookup"><span data-stu-id="3c126-134">Too many requests (you've most likely been throttled)</span></span> |
| <span data-ttu-id="3c126-135">502</span><span class="sxs-lookup"><span data-stu-id="3c126-135">502</span></span> | <span data-ttu-id="3c126-136">閘道不正確</span><span class="sxs-lookup"><span data-stu-id="3c126-136">Bad gateway</span></span> |
| <span data-ttu-id="3c126-137">503</span><span class="sxs-lookup"><span data-stu-id="3c126-137">503</span></span> | <span data-ttu-id="3c126-138">服務無法使用</span><span class="sxs-lookup"><span data-stu-id="3c126-138">Service unavailable</span></span> |
| <span data-ttu-id="3c126-139">504</span><span class="sxs-lookup"><span data-stu-id="3c126-139">504</span></span> | <span data-ttu-id="3c126-140">閘道超時</span><span class="sxs-lookup"><span data-stu-id="3c126-140">Gateway timeout</span></span> |

<span data-ttu-id="3c126-141">問題：您是否要重試 HTTP 狀態碼 403-禁止？</span><span class="sxs-lookup"><span data-stu-id="3c126-141">Question: Would you retry an HTTP Status Code of 403 - Forbidden?</span></span> <span data-ttu-id="3c126-142">否。</span><span class="sxs-lookup"><span data-stu-id="3c126-142">No.</span></span> <span data-ttu-id="3c126-143">在這裡，系統會正常運作，但通知呼叫者未獲授權執行要求的操作。</span><span class="sxs-lookup"><span data-stu-id="3c126-143">Here, the system is functioning properly, but informing the caller that they aren't authorized to perform the requested operation.</span></span> <span data-ttu-id="3c126-144">務必務必只重試失敗所造成的作業。</span><span class="sxs-lookup"><span data-stu-id="3c126-144">Care must be taken to retry only those operations caused by failures.</span></span>

<span data-ttu-id="3c126-145">如第1章所述，Microsoft 開發人員應以 .NET Core 平臺為目標，來建立雲端原生應用程式。</span><span class="sxs-lookup"><span data-stu-id="3c126-145">As recommended in Chapter 1, Microsoft developers constructing cloud-native applications should target the .NET Core platform.</span></span> <span data-ttu-id="3c126-146">2.1 版引進了 [HTTPClientFactory](https://www.stevejgordon.co.uk/introduction-to-httpclientfactory-aspnetcore) 程式庫，可用於建立 HTTP 用戶端實例，以與 URL 型資源互動。</span><span class="sxs-lookup"><span data-stu-id="3c126-146">Version 2.1 introduced the [HTTPClientFactory](https://www.stevejgordon.co.uk/introduction-to-httpclientfactory-aspnetcore) library for creating HTTP Client instances for interacting with URL-based resources.</span></span> <span data-ttu-id="3c126-147">取代原始的 HTTPClient 類別，factory 類別支援許多增強功能，其中一個與 Polly 復原程式庫 [緊密整合](../microservices/implement-resilient-applications/implement-http-call-retries-exponential-backoff-polly.md) 。</span><span class="sxs-lookup"><span data-stu-id="3c126-147">Superseding the original HTTPClient class, the factory class supports many enhanced features, one of which is [tight integration](../microservices/implement-resilient-applications/implement-http-call-retries-exponential-backoff-polly.md) with the Polly resiliency library.</span></span> <span data-ttu-id="3c126-148">有了它，您就可以輕鬆地在應用程式啟動類別中定義復原原則，以處理部分失敗和連線問題。</span><span class="sxs-lookup"><span data-stu-id="3c126-148">With it, you can easily define resiliency policies in the application Startup class to handle partial failures and connectivity issues.</span></span>

<span data-ttu-id="3c126-149">接下來，讓我們展開重試和斷路器模式。</span><span class="sxs-lookup"><span data-stu-id="3c126-149">Next, let's expand on retry and circuit breaker patterns.</span></span>

### <a name="retry-pattern"></a><span data-ttu-id="3c126-150">重試模式</span><span class="sxs-lookup"><span data-stu-id="3c126-150">Retry pattern</span></span>

<span data-ttu-id="3c126-151">在分散式雲端原生環境中，服務和雲端資源的呼叫可能會因為暫時性 (短暫的) 失敗而失敗，這通常會在短暫的時間內自行修正。</span><span class="sxs-lookup"><span data-stu-id="3c126-151">In a distributed cloud-native environment, calls to services and cloud resources can fail because of transient (short-lived) failures, which typically correct themselves after a brief period of time.</span></span> <span data-ttu-id="3c126-152">執行重試策略可協助雲端原生服務減輕這些案例的風險。</span><span class="sxs-lookup"><span data-stu-id="3c126-152">Implementing a retry strategy helps a cloud-native service mitigate these scenarios.</span></span>

<span data-ttu-id="3c126-153">[重試模式](/azure/architecture/patterns/retry)可讓服務重試失敗的要求作業， (可設定的) 次數，並以指數方式增加等候時間。</span><span class="sxs-lookup"><span data-stu-id="3c126-153">The [Retry pattern](/azure/architecture/patterns/retry) enables a service to retry a failed request operation a (configurable) number of times with an exponentially increasing wait time.</span></span> <span data-ttu-id="3c126-154">圖6-2 顯示重試動作。</span><span class="sxs-lookup"><span data-stu-id="3c126-154">Figure 6-2 shows a retry in action.</span></span>

![作用中的重試模式](./media/retry-pattern.png)

<span data-ttu-id="3c126-156">**圖 6-2**。</span><span class="sxs-lookup"><span data-stu-id="3c126-156">**Figure 6-2**.</span></span> <span data-ttu-id="3c126-157">作用中的重試模式</span><span class="sxs-lookup"><span data-stu-id="3c126-157">Retry pattern in action</span></span>

<span data-ttu-id="3c126-158">在上圖中，已針對要求作業執行重試模式。</span><span class="sxs-lookup"><span data-stu-id="3c126-158">In the previous figure, a retry pattern has been implemented for a request operation.</span></span> <span data-ttu-id="3c126-159">它是設定為在失敗前最多有四次重試， (等候時間) 從兩秒開始，這會以指數方式為每次後續的嘗試進行雙精度浮點數。</span><span class="sxs-lookup"><span data-stu-id="3c126-159">It's configured to allow up to four retries before failing with a backoff interval (wait time) starting at two seconds, which exponentially doubles for each subsequent attempt.</span></span>

- <span data-ttu-id="3c126-160">第一個調用失敗，並傳回 HTTP 狀態碼500。</span><span class="sxs-lookup"><span data-stu-id="3c126-160">The first invocation fails and returns an HTTP status code of 500.</span></span> <span data-ttu-id="3c126-161">應用程式會等待兩秒，然後重試呼叫。</span><span class="sxs-lookup"><span data-stu-id="3c126-161">The application waits for two seconds and retries the call.</span></span>
- <span data-ttu-id="3c126-162">第二個調用也會失敗，並傳回 HTTP 狀態碼500。</span><span class="sxs-lookup"><span data-stu-id="3c126-162">The second invocation also fails and returns an HTTP status code of 500.</span></span> <span data-ttu-id="3c126-163">應用程式現在會將輪詢間隔加倍到四秒，然後重試呼叫。</span><span class="sxs-lookup"><span data-stu-id="3c126-163">The application now doubles the backoff interval to four seconds and retries the call.</span></span>
- <span data-ttu-id="3c126-164">最後，第三個呼叫會成功。</span><span class="sxs-lookup"><span data-stu-id="3c126-164">Finally, the third call succeeds.</span></span>
- <span data-ttu-id="3c126-165">在此案例中，重試作業最多會嘗試四次重試，但在呼叫失敗之前將輪詢持續時間加倍。</span><span class="sxs-lookup"><span data-stu-id="3c126-165">In this scenario, the retry operation would have attempted up to four retries while doubling the backoff duration before failing the call.</span></span>
- <span data-ttu-id="3c126-166">第四次重試嘗試失敗時，將會叫用回溯原則以正常處理問題。</span><span class="sxs-lookup"><span data-stu-id="3c126-166">Had the 4th retry attempt failed, a fallback policy would be invoked to gracefully handle the problem.</span></span>

<span data-ttu-id="3c126-167">請務必先增加輪詢期間，再重試呼叫，以允許服務時間自行修正。</span><span class="sxs-lookup"><span data-stu-id="3c126-167">It's important to increase the backoff period before retrying the call to allow the service time to self-correct.</span></span> <span data-ttu-id="3c126-168">最佳做法是以指數方式增加輪詢 (將每次重試) 的期間加倍，以允許適當的更正時間。</span><span class="sxs-lookup"><span data-stu-id="3c126-168">It's a best practice to implement an exponentially increasing backoff (doubling the period on each retry) to allow adequate correction time.</span></span>

## <a name="circuit-breaker-pattern"></a><span data-ttu-id="3c126-169">斷路器模式</span><span class="sxs-lookup"><span data-stu-id="3c126-169">Circuit breaker pattern</span></span>

<span data-ttu-id="3c126-170">雖然重試模式有助於在部分失敗中搶救要求纏結，但是在某些情況下，可能會因為未預期的事件需要較長的時間來解決問題而造成失敗。</span><span class="sxs-lookup"><span data-stu-id="3c126-170">While the retry pattern can help salvage a request entangled in a partial failure, there are situations where failures can be caused by unanticipated events that will require longer periods of time to resolve.</span></span> <span data-ttu-id="3c126-171">這些錯誤的嚴重性範圍包含失去部分連線到整個服務無法運作。</span><span class="sxs-lookup"><span data-stu-id="3c126-171">These faults can range in severity from a partial loss of connectivity to the complete failure of a service.</span></span> <span data-ttu-id="3c126-172">在這些情況下，應用程式會持續重試不太可能成功的作業，是無意義的。</span><span class="sxs-lookup"><span data-stu-id="3c126-172">In these situations, it's pointless for an application to continually retry an operation that is unlikely to succeed.</span></span>

<span data-ttu-id="3c126-173">為了讓事情更糟，在沒有回應的服務上執行連續的重試作業，可以將您移至自我設定的拒絕服務案例中，您會使用持續的呼叫耗盡資源（例如記憶體、執行緒和資料庫連接），導致使用相同資源的系統不相關部分失敗。</span><span class="sxs-lookup"><span data-stu-id="3c126-173">To make things worse, executing continual retry operations on a non-responsive service can move you into a self-imposed denial of service scenario where you flood your service with continual calls exhausting resources such as memory, threads and database connections, causing failure in unrelated parts of the system that use the same resources.</span></span>

<span data-ttu-id="3c126-174">在這些情況下，最好是讓作業立即失敗，而且只有在可能成功時才嘗試叫用服務。</span><span class="sxs-lookup"><span data-stu-id="3c126-174">In these situations, it would be preferable for the operation to fail immediately and only attempt to invoke the service if it's likely to succeed.</span></span>

<span data-ttu-id="3c126-175">[斷路器模式](/azure/architecture/patterns/circuit-breaker)可防止應用程式重複嘗試執行可能失敗的作業。</span><span class="sxs-lookup"><span data-stu-id="3c126-175">The [Circuit Breaker pattern](/azure/architecture/patterns/circuit-breaker) can prevent an application from repeatedly trying to execute an operation that's likely to fail.</span></span> <span data-ttu-id="3c126-176">在預先定義的失敗呼叫次數之後，它會封鎖對服務的所有流量。</span><span class="sxs-lookup"><span data-stu-id="3c126-176">After a pre-defined number of failed calls, it blocks all traffic to the service.</span></span> <span data-ttu-id="3c126-177">它會定期允許試用通話，以判斷錯誤是否已解決。</span><span class="sxs-lookup"><span data-stu-id="3c126-177">Periodically, it will allow a trial call to determine whether the fault has resolved.</span></span> <span data-ttu-id="3c126-178">圖6-3 顯示斷路器模式的作用。</span><span class="sxs-lookup"><span data-stu-id="3c126-178">Figure 6-3 shows the Circuit Breaker pattern in action.</span></span>

![作用中的斷路器模式](./media/circuit-breaker-pattern.png)

<span data-ttu-id="3c126-180">**圖 6-3**。</span><span class="sxs-lookup"><span data-stu-id="3c126-180">**Figure 6-3**.</span></span> <span data-ttu-id="3c126-181">作用中的斷路器模式</span><span class="sxs-lookup"><span data-stu-id="3c126-181">Circuit breaker pattern in action</span></span>

<span data-ttu-id="3c126-182">在上圖中，已將斷路器模式新增至原始重試模式。</span><span class="sxs-lookup"><span data-stu-id="3c126-182">In the previous figure, a Circuit Breaker pattern has been added to the original retry pattern.</span></span> <span data-ttu-id="3c126-183">請注意，在100次失敗的要求之後，斷路器會開啟，而且不會再允許服務的呼叫。</span><span class="sxs-lookup"><span data-stu-id="3c126-183">Note how after 100 failed requests, the circuit breakers opens and no longer allows calls to the service.</span></span> <span data-ttu-id="3c126-184">設定為30秒的 CheckCircuit 值，指定程式庫允許一個要求繼續服務的頻率。</span><span class="sxs-lookup"><span data-stu-id="3c126-184">The CheckCircuit value, set at 30 seconds, specifies how often the library allows one request to proceed to the service.</span></span> <span data-ttu-id="3c126-185">如果該呼叫成功，則電路會關閉，而且服務會再次提供給流量。</span><span class="sxs-lookup"><span data-stu-id="3c126-185">If that call succeeds, the circuit closes and the service is once again available to traffic.</span></span>

<span data-ttu-id="3c126-186">請記住，斷路器模式的目的與重試模式的意圖 *不同* 。</span><span class="sxs-lookup"><span data-stu-id="3c126-186">Keep in mind that the intent of the Circuit Breaker pattern is *different* than that of the Retry pattern.</span></span> <span data-ttu-id="3c126-187">重試模式可讓應用程式在預期會成功的情況下重試操作。</span><span class="sxs-lookup"><span data-stu-id="3c126-187">The Retry pattern enables an application to retry an operation in the expectation that it will succeed.</span></span> <span data-ttu-id="3c126-188">斷路器模式可防止應用程式執行可能失敗的作業。</span><span class="sxs-lookup"><span data-stu-id="3c126-188">The Circuit Breaker pattern prevents an application from doing an operation that is likely to fail.</span></span> <span data-ttu-id="3c126-189">一般而言，應用程式會使用重試模式，透過斷路器叫用作業來 *結合* 這兩種模式。</span><span class="sxs-lookup"><span data-stu-id="3c126-189">Typically, an application will *combine* these two patterns by using the Retry pattern to invoke an operation through a circuit breaker.</span></span>

## <a name="testing-for-resiliency"></a><span data-ttu-id="3c126-190">針對復原而測試</span><span class="sxs-lookup"><span data-stu-id="3c126-190">Testing for resiliency</span></span>

<span data-ttu-id="3c126-191">執行單元測試、整合測試等) ， (測試應用程式功能的方式，就不一定可以測試復原。</span><span class="sxs-lookup"><span data-stu-id="3c126-191">Testing for resiliency cannot always be done the same way that you test application functionality (by running unit tests, integration tests and so on).</span></span> <span data-ttu-id="3c126-192">相反地，您必須測試端對端工作負載在失敗情況下的執行方式，這只會間歇性發生。</span><span class="sxs-lookup"><span data-stu-id="3c126-192">Instead, you must test how the end-to-end workload performs under failure conditions which only occur intermittently.</span></span> <span data-ttu-id="3c126-193">例如：損毀進程、過期憑證、讓相依服務無法使用等插入失敗。 [混亂](https://github.com/Netflix/chaosmonkey) 等架構可用於這類混亂測試。</span><span class="sxs-lookup"><span data-stu-id="3c126-193">For example: inject failures by crashing processes, expired certificates, make dependent services unavailable etc. Frameworks like [chaos-monkey](https://github.com/Netflix/chaosmonkey) can be used for such chaos testing.</span></span>

<span data-ttu-id="3c126-194">應用程式復原是處理有問題的要求作業時必須具備的功能。</span><span class="sxs-lookup"><span data-stu-id="3c126-194">Application resiliency is a must for handling problematic requested operations.</span></span> <span data-ttu-id="3c126-195">但是，這只是故事的一半而已。</span><span class="sxs-lookup"><span data-stu-id="3c126-195">But, it's only half of the story.</span></span> <span data-ttu-id="3c126-196">接下來，我們會討論 Azure 雲端中可用的復原功能。</span><span class="sxs-lookup"><span data-stu-id="3c126-196">Next, we cover resiliency features available in the Azure cloud.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="3c126-197">[上一個](resiliency.md) 
>[下一步](infrastructure-resiliency-azure.md)</span><span class="sxs-lookup"><span data-stu-id="3c126-197">[Previous](resiliency.md)
[Next](infrastructure-resiliency-azure.md)</span></span>
