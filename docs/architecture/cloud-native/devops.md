---
title: DevOps
description: 雲端原生應用程式的 DevOps 考慮
ms.date: 05/13/2020
ms.openlocfilehash: e6e093a1847d3aec37ac5d4ca56f64e0091a9b6b
ms.sourcegitcommit: 5b475c1855b32cf78d2d1bbb4295e4c236f39464
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 09/24/2020
ms.locfileid: "91163995"
---
# <a name="devops"></a><span data-ttu-id="4d4a3-103">DevOps</span><span class="sxs-lookup"><span data-stu-id="4d4a3-103">DevOps</span></span>

<span data-ttu-id="4d4a3-104">我最愛的軟體顧問口號是回答「它相依于」任何問題。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-104">The favorite mantra of software consultants is to answer "It depends" to any question posed.</span></span> <span data-ttu-id="4d4a3-105">這並不是因為軟體顧問喜歡了，而不是採用某個位置。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-105">It isn't because software consultants are fond of not taking a position.</span></span> <span data-ttu-id="4d4a3-106">這是因為軟體中任何問題都沒有真正的答案。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-106">It's because there's no one true answer to any questions in software.</span></span> <span data-ttu-id="4d4a3-107">沒有絕對權利和錯誤，而是相反之間的平衡。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-107">There's no absolute right and wrong, but rather a balance between opposites.</span></span>

<span data-ttu-id="4d4a3-108">比方說，開發 web 應用程式的兩大學校：單一頁面應用程式 (Spa) 與伺服器端應用程式。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-108">Take, for instance, the two major schools of developing web applications: Single Page Applications (SPAs) versus server-side applications.</span></span> <span data-ttu-id="4d4a3-109">一方面，使用者體驗通常更適合 Spa，而 web 伺服器的流量也可以最小化，以便將其裝載于像是靜態裝載一樣簡單的東西上。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-109">On the one hand, the user experience tends to be better with SPAs and the amount of traffic to the web server can be minimized making it possible to host them on something as simple as static hosting.</span></span> <span data-ttu-id="4d4a3-110">另一方面，Spa 傾向于開發速度較慢，而且難以測試。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-110">On the other hand, SPAs tend to be slower to develop and more difficult to test.</span></span> <span data-ttu-id="4d4a3-111">哪一個是正確的選擇？</span><span class="sxs-lookup"><span data-stu-id="4d4a3-111">Which one is the right choice?</span></span> <span data-ttu-id="4d4a3-112">當然，這取決於您的情況。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-112">Well, it depends on your situation.</span></span>

<span data-ttu-id="4d4a3-113">雲端原生應用程式不會受到相同二分法的免疫。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-113">Cloud-native applications aren't immune to that same dichotomy.</span></span> <span data-ttu-id="4d4a3-114">它們在開發、穩定性和擴充性方面都有明顯的好處，但管理它們可能有點困難。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-114">They have clear advantages in terms of speed of development, stability, and scalability, but managing them can be quite a bit more difficult.</span></span>

<span data-ttu-id="4d4a3-115">多年前，將應用程式從開發移至生產環境以花一個月或更久的程式並不罕見。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-115">Years ago, it wasn't uncommon for the process of moving an application from development to production to take a month, or even more.</span></span> <span data-ttu-id="4d4a3-116">公司以6個月或甚至每年的步調發行軟體。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-116">Companies released software on a 6-month or even every year cadence.</span></span> <span data-ttu-id="4d4a3-117">除了 Microsoft Windows 之外，您還必須先看一下，以瞭解在 Windows 10 的環保天之前，可接受的發行步調。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-117">One needs to look no further than Microsoft Windows to get an idea for the cadence of releases that were acceptable before the ever-green days of Windows 10.</span></span> <span data-ttu-id="4d4a3-118">在 Windows XP 和 Vista 之間傳遞五年，Vista 與 Windows 7 之間有3個。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-118">Five years passed between Windows XP and Vista, a further 3 between Vista and Windows 7.</span></span>

<span data-ttu-id="4d4a3-119">現在就能輕鬆地發行軟體，讓快速移動的公司能夠以更 sloth 的競爭對手為一大市場優勢。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-119">It's now fairly well established that being able to release software rapidly gives fast-moving companies a huge market advantage over their more sloth-like competitors.</span></span> <span data-ttu-id="4d4a3-120">這是因為 Windows 10 的重大更新現在大約每六個月。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-120">It's for that reason that major updates to Windows 10 are now approximately every six months.</span></span>

<span data-ttu-id="4d4a3-121">可以更快速、更可靠的版本來提供價值給企業的模式和實務，統稱為 DevOps。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-121">The patterns and practices that enable faster, more reliable releases to deliver value to the business are collectively known as DevOps.</span></span> <span data-ttu-id="4d4a3-122">它們包含橫跨整個軟體發展生命週期的各種想法，從指定應用程式一直到傳遞和操作該應用程式都是如此。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-122">They consist of a wide range of ideas spanning the entire software development life cycle from specifying an application all the way up to delivering and operating that application.</span></span>

<span data-ttu-id="4d4a3-123">DevOps 會在微服務之前發生，而且可能會有較小的移動，而不需要 DevOps，就能在生產環境中釋出和操作許多應用程式。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-123">DevOps emerged before microservices and it's likely that the movement towards smaller, more fit to purpose services wouldn't have been possible without DevOps to make releasing and operating not just one but many applications in production easier.</span></span>

![[圖 10-1] 搜尋趨勢顯示微服務的成長，直到 DevOps 是相當知名的想法為止。](./media/microservices-vs-devops.png)

<span data-ttu-id="4d4a3-125">**圖 10-1** -DevOps 和微服務。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-125">**Figure 10-1** - DevOps and microservices.</span></span>

<span data-ttu-id="4d4a3-126">透過良好的 DevOps 實務，在實際操作應用程式的工作中，您可以實現雲端原生應用程式的優點，而不需要 suffocating。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-126">Through good DevOps practices, it's possible to realize the advantages of cloud-native applications without suffocating under a mountain of work actually operating the applications.</span></span>

<span data-ttu-id="4d4a3-127">DevOps 時，沒有黃金的鐵錘。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-127">There's no golden hammer when it comes to DevOps.</span></span> <span data-ttu-id="4d4a3-128">沒有人可以銷售完整且全方位的解決方案來發行和操作高品質的應用程式。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-128">Nobody can sell a complete and all-encompassing solution for releasing and operating high-quality applications.</span></span> <span data-ttu-id="4d4a3-129">這是因為每個應用程式與其他應用程式的差異很大。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-129">This is because each application is wildly different from all others.</span></span> <span data-ttu-id="4d4a3-130">不過，有一些工具可讓 DevOps 變得更不令人望而生畏。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-130">However, there are tools that can make DevOps a far less daunting proposition.</span></span> <span data-ttu-id="4d4a3-131">其中一項工具稱為 Azure DevOps。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-131">One of these tools is known as Azure DevOps.</span></span>

## <a name="azure-devops"></a><span data-ttu-id="4d4a3-132">Azure DevOps</span><span class="sxs-lookup"><span data-stu-id="4d4a3-132">Azure DevOps</span></span>

<span data-ttu-id="4d4a3-133">Azure DevOps 有很長的歷史。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-133">Azure DevOps has a long pedigree.</span></span> <span data-ttu-id="4d4a3-134">當 Team Foundation Server 第一次移至線上，以及透過不同的名稱變更時，它可以追蹤它的根目錄： Visual Studio Online 和 Visual Studio Team Services。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-134">It can trace its roots back to when Team Foundation Server first moved online and through the various name changes: Visual Studio Online and Visual Studio Team Services.</span></span> <span data-ttu-id="4d4a3-135">不過，多年來，它已經變得遠超過其前身。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-135">Through the years, however, it has become far more than its predecessors.</span></span>

<span data-ttu-id="4d4a3-136">Azure DevOps 分為五個主要元件：</span><span class="sxs-lookup"><span data-stu-id="4d4a3-136">Azure DevOps is divided into five major components:</span></span>

![圖 10-2 Azure DevOps 的五個主要區域](./media/devops-components.png)

<span data-ttu-id="4d4a3-138">**圖 10-2** -Azure DevOps。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-138">**Figure 10-2** - Azure DevOps.</span></span>

<span data-ttu-id="4d4a3-139">**Azure Repos** 原始程式碼管理，支援早期 TEAM FOUNDATION 版本控制 (TFVC) 和業界最愛的 [Git](https://en.wikipedia.org/wiki/Git)。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-139">**Azure Repos** - Source code management that supports the venerable Team Foundation Version Control (TFVC) and the industry favorite [Git](https://en.wikipedia.org/wiki/Git).</span></span> <span data-ttu-id="4d4a3-140">提取要求可讓您在進行變更時，藉由促進變更的討論來啟用社交編碼。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-140">Pull requests provide a way to enable social coding by fostering discussion of changes as they're made.</span></span>

<span data-ttu-id="4d4a3-141">**Azure Boards** -提供問題和工作專案追蹤工具，致力於讓使用者挑選最適合他們的工作流程。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-141">**Azure Boards** - Provides an issue and work item tracking tool that strives to allow users to pick the workflows that work best for them.</span></span> <span data-ttu-id="4d4a3-142">它隨附一些預先設定的範本，其中包括支援 SCRUM 和看板的開發樣式。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-142">It comes with a number of pre-configured templates including ones to support SCRUM and Kanban styles of development.</span></span>

<span data-ttu-id="4d4a3-143">**Azure Pipelines** -支援與 Azure 緊密整合的組建和發行管理系統。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-143">**Azure Pipelines** - A build and release management system that supports tight integration with Azure.</span></span> <span data-ttu-id="4d4a3-144">組建可在各種不同的平臺上執行，從 Windows 到 Linux 到 MacOS。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-144">Builds can be run on a variety of platforms from Windows to Linux to MacOS.</span></span> <span data-ttu-id="4d4a3-145">組建代理程式可以布建在雲端或內部部署中。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-145">Build agents may be provisioned in the cloud or on-premises.</span></span>

<span data-ttu-id="4d4a3-146">**Azure Test Plans** -Test Plans 功能提供的測試管理和探勘測試支援將不會留下任何 QA 人員。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-146">**Azure Test Plans** - No QA person will be left behind with the test management and exploratory testing support offered by the Test Plans feature.</span></span>

<span data-ttu-id="4d4a3-147">**Azure Artifacts** -可讓公司建立自己的 NuGet、npm 和其他版本的成品摘要。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-147">**Azure Artifacts** - An artifact feed that allows companies to create their own, internal, versions of NuGet, npm, and others.</span></span> <span data-ttu-id="4d4a3-148">如果集中式儲存機制失敗，則會以雙重目的作為上游套件的快取。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-148">It serves a double purpose of acting as a cache of upstream packages if there's a failure of a centralized repository.</span></span>

<span data-ttu-id="4d4a3-149">Azure DevOps 中的最上層組織單位稱為「專案」（Project）。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-149">The top-level organizational unit in Azure DevOps is known as a Project.</span></span> <span data-ttu-id="4d4a3-150">在每個專案中，可以開啟和關閉各種元件（例如 Azure Artifacts）。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-150">Within each project the various components, such as Azure Artifacts, can be turned on and off.</span></span> <span data-ttu-id="4d4a3-151">每個元件都提供雲端原生應用程式的不同優點。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-151">Each of these components provides different advantages for cloud-native applications.</span></span> <span data-ttu-id="4d4a3-152">最有用的三種是存放庫、面板和管線。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-152">The three most useful are repositories, boards, and pipelines.</span></span> <span data-ttu-id="4d4a3-153">如果使用者想要在另一個存放庫堆疊（例如 GitHub）中管理其原始程式碼，但仍可充分利用 Azure Pipelines 和其他元件，這是完全可行的。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-153">If users want to manage their source code in another repository stack, such as GitHub, but still take advantage of Azure Pipelines and other components, that's perfectly possible.</span></span>

<span data-ttu-id="4d4a3-154">幸運的是，開發團隊在選取存放庫時有許多選項。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-154">Fortunately, development teams have many options when selecting a repository.</span></span> <span data-ttu-id="4d4a3-155">其中一個是 GitHub。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-155">One of them is GitHub.</span></span>

## <a name="github-actions"></a><span data-ttu-id="4d4a3-156">GitHub 動作</span><span class="sxs-lookup"><span data-stu-id="4d4a3-156">GitHub Actions</span></span>

<span data-ttu-id="4d4a3-157">GitHub 建基於2009，是一種廣泛受歡迎的 web 架構存放庫，可用於裝載專案、檔和程式碼。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-157">Founded in 2009, GitHub is a widely popular web-based repository for hosting projects, documentation, and code.</span></span> <span data-ttu-id="4d4a3-158">許多大型技術公司，例如 Apple、Amazon、Google 和主流公司都使用 GitHub。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-158">Many large tech companies, such as Apple, Amazon, Google, and mainstream corporations use GitHub.</span></span> <span data-ttu-id="4d4a3-159">GitHub 會使用名為 Git 的開放原始碼分散式版本控制系統作為其基礎。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-159">GitHub uses the open-source, distributed version control system named Git as its foundation.</span></span> <span data-ttu-id="4d4a3-160">然後，它會針對每個程式碼基底加入自己的一組功能，包括缺失追蹤、功能和提取要求、工作管理和 wiki。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-160">On top, it then adds its own set of features, including defect tracking, feature and pull requests, tasks management, and wikis for each code base.</span></span>

<span data-ttu-id="4d4a3-161">當 GitHub 發展時，也會新增 DevOps 功能。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-161">As GitHub evolves, it too is adding DevOps features.</span></span> <span data-ttu-id="4d4a3-162">例如，GitHub 有自己的持續整合/持續傳遞 (CI/CD) 管線，稱為 `GitHub Actions` 。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-162">For example, GitHub has its own continuous integration/continuous delivery (CI/CD) pipeline, called `GitHub Actions`.</span></span> <span data-ttu-id="4d4a3-163">GitHub Actions 是以社區為技術的工作流程自動化工具。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-163">GitHub Actions is a community-powered workflow automation tool.</span></span> <span data-ttu-id="4d4a3-164">它可讓 DevOps 團隊與現有的工具整合、混合和比對新產品，並連結到其軟體生命週期，包括現有的 CI/CD 合作夥伴。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-164">It lets DevOps teams integrate with their existing tooling, mix and match new products, and hook into their software lifecycle, including existing CI/CD partners."</span></span>

<span data-ttu-id="4d4a3-165">GitHub 有超過40000000的使用者，使其成為世界上最大的原始程式碼主機。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-165">GitHub has over 40 million users, making it the largest host of source code in the world.</span></span> <span data-ttu-id="4d4a3-166">Microsoft 已于2018年10月購買 GitHub。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-166">In October of 2018, Microsoft purchased GitHub.</span></span> <span data-ttu-id="4d4a3-167">Microsoft 已 pledged GitHub 將維持 [開放平臺](https://techcrunch.com/2018/06/04/microsoft-promises-to-keep-github-independent-and-open/) ，讓任何開發人員都能插入及擴充。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-167">Microsoft has pledged that GitHub will remain an [open platform](https://techcrunch.com/2018/06/04/microsoft-promises-to-keep-github-independent-and-open/) that any developer can plug into and extend.</span></span> <span data-ttu-id="4d4a3-168">它會繼續以獨立公司的形式運作。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-168">It continues to operate as an independent company.</span></span> <span data-ttu-id="4d4a3-169">GitHub 提供 enterprise、team、professional 和免費帳戶的方案。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-169">GitHub offers plans for enterprise, team, professional, and free accounts.</span></span>

## <a name="source-control"></a><span data-ttu-id="4d4a3-170">原始檔控制</span><span class="sxs-lookup"><span data-stu-id="4d4a3-170">Source control</span></span>

<span data-ttu-id="4d4a3-171">組織雲端原生應用程式的程式碼可能是一項挑戰。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-171">Organizing the code for a cloud-native application can be challenging.</span></span> <span data-ttu-id="4d4a3-172">雲端原生應用程式通常是由較小的應用程式（彼此交談）所組成，而不是單一的大型應用程式。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-172">Instead of a single giant application, the cloud-native applications tend to be made up of a web of smaller applications that talk with one another.</span></span> <span data-ttu-id="4d4a3-173">如同運算中的所有專案，程式碼的最佳相片順序仍是開放式問題。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-173">As with all things in computing, the best arrangement of code remains an open question.</span></span> <span data-ttu-id="4d4a3-174">使用不同類型的版面配置的成功應用程式範例有很多，但兩個變體似乎最受歡迎。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-174">There are examples of successful applications using different kinds of layouts, but two variants seem to have the most popularity.</span></span>

<span data-ttu-id="4d4a3-175">在進入實際的原始檔控制本身之前，可能需要決定有多少個專案適用。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-175">Before getting down into the actual source control itself, it's probably worth deciding on how many projects are appropriate.</span></span> <span data-ttu-id="4d4a3-176">在單一專案中，支援多個存放庫和組建管線。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-176">Within a single project, there's support for multiple repositories, and build pipelines.</span></span> <span data-ttu-id="4d4a3-177">面板有點複雜，但也可以輕鬆地將工作指派給單一專案內的多個小組。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-177">Boards are a little more complicated, but there too, the tasks can easily be assigned to multiple teams within a single project.</span></span> <span data-ttu-id="4d4a3-178">有可能支援數百個以上的開發人員，但不只是一個 Azure DevOps 專案。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-178">It's possible to support hundreds, even thousands of developers, out of a single Azure DevOps project.</span></span> <span data-ttu-id="4d4a3-179">這樣做可能是最好的方法，因為它提供單一位置讓所有開發人員都能運作，並減少在開發人員不確定應用程式所在的專案時，發現該應用程式的混淆。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-179">Doing so is likely the best approach as it provides a single place for all developer to work out of and reduces the confusion of finding that one application when developers are unsure in which project in which it resides.</span></span>

<span data-ttu-id="4d4a3-180">在 Azure DevOps 專案內分割微服務程式代碼，可能會稍微更具挑戰性。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-180">Splitting up code for microservices within the Azure DevOps project can be slightly more challenging.</span></span>

![圖10-3 單一與多個存放庫](./media/single-repository-vs-multiple.png)

<span data-ttu-id="4d4a3-182">**圖 10-3** -一與許多存放庫。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-182">**Figure 10-3** - One vs. many repositories.</span></span>

### <a name="repository-per-microservice"></a><span data-ttu-id="4d4a3-183">每個微服務的儲存機制</span><span class="sxs-lookup"><span data-stu-id="4d4a3-183">Repository per microservice</span></span>

<span data-ttu-id="4d4a3-184">乍看之下，這似乎是最適合用來分割微服務原始程式碼的邏輯方法。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-184">At first glance, this seems like the most logical approach to splitting up the source code for microservices.</span></span> <span data-ttu-id="4d4a3-185">每個存放庫都可以包含建立一個微服務所需的程式碼。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-185">Each repository can contain the code needed to build the one microservice.</span></span> <span data-ttu-id="4d4a3-186">這種方法的優點很容易看見：</span><span class="sxs-lookup"><span data-stu-id="4d4a3-186">The advantages to this approach are readily visible:</span></span>

1. <span data-ttu-id="4d4a3-187">建立和維護應用程式的指示可以新增至每個存放庫根目錄中的讀我檔案。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-187">Instructions for building and maintaining the application can be added to a README file at the root of each repository.</span></span> <span data-ttu-id="4d4a3-188">當您在處理存放庫時，很容易就能找到這些指示，縮短開發人員的加速時間。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-188">When flipping through the repositories, it's easy to find these instructions, reducing spin-up time for developers.</span></span>
2. <span data-ttu-id="4d4a3-189">每個服務都位於邏輯位置，只要知道服務的名稱即可輕鬆找到。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-189">Every service is located in a logical place, easily found by knowing the name of the service.</span></span>
3. <span data-ttu-id="4d4a3-190">您可以輕鬆地設定組建，使其只在對擁有存放庫進行變更時才會觸發。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-190">Builds can easily be set up such that they're only triggered when a change is made to the owning repository.</span></span>
4. <span data-ttu-id="4d4a3-191">進入存放庫的變更數目僅限於處理專案的少數開發人員。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-191">The number of changes coming into a repository is limited to the small number of developers working on the project.</span></span>
5. <span data-ttu-id="4d4a3-192">藉由限制開發人員擁有讀取和寫入權限的存放庫，即可輕鬆地設定安全性。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-192">Security is easy to set up by restricting the repositories to which developers have read and write permissions.</span></span>
6. <span data-ttu-id="4d4a3-193">擁有小組可以變更存放庫層級的設定，並與其他人進行最少的討論。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-193">Repository level settings can be changed by the owning team with a minimum of discussion with others.</span></span>

<span data-ttu-id="4d4a3-194">微服務背後的其中一個重要概念是，服務應該彼此隔離，並彼此分開。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-194">One of the key ideas behind microservices is that services should be siloed and separated from each other.</span></span> <span data-ttu-id="4d4a3-195">使用網域導向設計來決定服務的界限時，服務會作為交易界限。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-195">When using Domain Driven Design to decide on the boundaries for services the services act as transactional boundaries.</span></span> <span data-ttu-id="4d4a3-196">資料庫更新不應該跨多個服務。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-196">Database updates shouldn't span multiple services.</span></span> <span data-ttu-id="4d4a3-197">此相關資料集合稱為系結內容。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-197">This collection of related data is referred to as a bounded context.</span></span>  <span data-ttu-id="4d4a3-198">這項構想的反映方式是將微服務資料隔離到個別的資料庫，並從其餘的服務自我自主。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-198">This idea is reflected by the isolation of microservice data to a database separate and autonomous from the rest of the services.</span></span> <span data-ttu-id="4d4a3-199">將這項構想全部帶到原始程式碼，會有很大的意義。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-199">It makes a great deal of sense to carry this idea all the way through to the source code.</span></span>

<span data-ttu-id="4d4a3-200">不過，這種方法不會有問題。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-200">However, this approach isn't without its issues.</span></span> <span data-ttu-id="4d4a3-201">我們時間的其中一個更複雜的開發問題是管理相依性。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-201">One of the more gnarly development problems of our time is managing dependencies.</span></span> <span data-ttu-id="4d4a3-202">請考慮組成平均目錄的檔案數目 `node_modules` 。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-202">Consider the number of files that make up the average `node_modules` directory.</span></span> <span data-ttu-id="4d4a3-203">像這樣的全新安裝 `create-react-app` 可能會攜帶數以千計的封裝。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-203">A fresh install of something like `create-react-app` is likely to bring with it thousands of packages.</span></span> <span data-ttu-id="4d4a3-204">如何管理這些相依性的問題是一項困難之處。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-204">The question of how to manage these dependencies is a difficult one.</span></span>

<span data-ttu-id="4d4a3-205">如果相依性已更新，則下游套件也必須更新此相依性。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-205">If a dependency is updated, then downstream packages must also update this dependency.</span></span> <span data-ttu-id="4d4a3-206">可惜的是，這會讓開發工作順利進行，而 `node_modules` 目錄最後會有單一套件的多個版本，每一個封裝的相依性是以稍有不同的頻率進行版本設定。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-206">Unfortunately, that takes development work so, invariably, the `node_modules` directory ends up with multiple versions of a single package, each one a dependency of some other package that is versioned at a slightly different cadence.</span></span> <span data-ttu-id="4d4a3-207">部署應用程式時，應該使用哪個版本的相依性？</span><span class="sxs-lookup"><span data-stu-id="4d4a3-207">When deploying an application, which version of a dependency should be used?</span></span> <span data-ttu-id="4d4a3-208">目前在生產環境中的版本為何？</span><span class="sxs-lookup"><span data-stu-id="4d4a3-208">The version that is currently in production?</span></span> <span data-ttu-id="4d4a3-209">目前在 Beta 版中，但在取用者進入生產環境時可能會在生產環境中的版本？</span><span class="sxs-lookup"><span data-stu-id="4d4a3-209">The version that is currently in Beta but is likely to be in production by the time the consumer makes it to production?</span></span> <span data-ttu-id="4d4a3-210">不只是使用微服務來解決的困難問題。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-210">Difficult problems that aren't resolved by just using microservices.</span></span>

<span data-ttu-id="4d4a3-211">有些程式庫相依于各種不同的專案。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-211">There are libraries that are depended upon by a wide variety of projects.</span></span> <span data-ttu-id="4d4a3-212">藉由將微服務與每個存放庫中的每個存放庫分割，就可以使用內部的儲存機制（Azure Artifacts）來解決內部相依性。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-212">By dividing the microservices up with one in each repository the internal dependencies can best be resolved by using the internal repository, Azure Artifacts.</span></span> <span data-ttu-id="4d4a3-213">程式庫的組建會將其最新版本推送至 Azure Artifacts 供內部使用。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-213">Builds for libraries will push their latest versions into Azure Artifacts for internal consumption.</span></span> <span data-ttu-id="4d4a3-214">下游專案仍必須手動更新，才能相依于新更新的封裝。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-214">The downstream project must still be manually updated to take a dependency on the newly updated packages.</span></span>

<span data-ttu-id="4d4a3-215">另一個缺點則是在服務之間移動程式碼時。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-215">Another disadvantage presents itself when moving code between services.</span></span> <span data-ttu-id="4d4a3-216">雖然認為應用程式的第一個部門的微服務是100% 正確，但其實很少會 prescient 為不會造成服務部門的錯誤。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-216">Although it would be nice to believe that the first division of an application into microservices is 100% correct, the reality is that rarely we're so prescient as to make no service division mistakes.</span></span> <span data-ttu-id="4d4a3-217">因此，功能和驅動它的程式碼將需要從服務移至服務：儲存機制到存放庫。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-217">Thus, functionality and the code that drives it will need to move from service to service: repository to repository.</span></span> <span data-ttu-id="4d4a3-218">從某個儲存機制 leaping 至另一個存放庫時，程式碼將會失去其歷程記錄。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-218">When leaping from one repository to another, the code loses its history.</span></span> <span data-ttu-id="4d4a3-219">在許多情況下，尤其是在發生審核事件的情況下，有一段程式碼的完整歷程記錄非常寶貴。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-219">There are many cases, especially in the event of an audit, where having full history on a piece of code is invaluable.</span></span>

<span data-ttu-id="4d4a3-220">最後一個最重要的缺點是協調變更。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-220">The final and most important disadvantage is coordinating changes.</span></span> <span data-ttu-id="4d4a3-221">在真正的微服務應用程式中，服務之間應該不會有部署相依性。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-221">In a true microservices application, there should be no deployment dependencies between services.</span></span> <span data-ttu-id="4d4a3-222">您應該能夠以任何順序部署服務 A、B 和 C，因為它們的結合鬆散。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-222">It should be possible to deploy services A, B, and C in any order as they have loose coupling.</span></span> <span data-ttu-id="4d4a3-223">但事實上，在某些情況下，您可能會想要進行一次跨越多個存放庫的變更。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-223">In reality, however, there are times when it's desirable to make a change that crosses multiple repositories at the same time.</span></span> <span data-ttu-id="4d4a3-224">其中一些範例包括更新程式庫以關閉安全性漏洞，或變更所有服務所使用的通訊協定。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-224">Some examples include updating a library to close a security hole or changing a communication protocol used by all services.</span></span>

<span data-ttu-id="4d4a3-225">若要進行跨存放庫變更，需要連續進行認可至每個存放庫。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-225">To do a cross-repository change requires a commit to each repository be made in succession.</span></span> <span data-ttu-id="4d4a3-226">每個存放庫中的每個變更都需要提取要求和個別檢查。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-226">Each change in each repository will need to be pull-requested and reviewed separately.</span></span> <span data-ttu-id="4d4a3-227">這可能很難進行協調。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-227">This can be difficult to coordinate.</span></span>

<span data-ttu-id="4d4a3-228">使用許多存放庫的另一種方式，是將所有的原始程式碼放在一個大型、所有已知的單一存放庫中。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-228">An alternative to using many repositories is to put all the source code together in a giant, all knowing, single repository.</span></span>

### <a name="single-repository"></a><span data-ttu-id="4d4a3-229">單一儲存機制</span><span class="sxs-lookup"><span data-stu-id="4d4a3-229">Single repository</span></span>

<span data-ttu-id="4d4a3-230">在這種方法中，有時稱為 [monorepository](https://danluu.com/monorepo/)，則每個服務的所有原始程式碼都放在相同的存放庫中。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-230">In this approach, sometimes referred to as a [monorepository](https://danluu.com/monorepo/), all the source code for every service is put into the same repository.</span></span> <span data-ttu-id="4d4a3-231">一開始，這似乎會讓您難以處理原始程式碼。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-231">At first, this seems like a terrible idea likely to make dealing with source code unwieldy.</span></span> <span data-ttu-id="4d4a3-232">不過，有一些標示的優點是以這種方式運作。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-232">There are, however, some marked advantages to working this way.</span></span>

<span data-ttu-id="4d4a3-233">第一個優點是可以更輕鬆地管理專案之間的相依性。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-233">The first advantage is that it's easier to manage dependencies between projects.</span></span> <span data-ttu-id="4d4a3-234">專案可以直接彼此匯入，而不是依賴某些外部成品摘要。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-234">Instead of relying on some external artifact feed, projects can directly import one another.</span></span> <span data-ttu-id="4d4a3-235">這表示更新會立即存在，而且可能會在開發人員工作站的編譯時期找到衝突的版本。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-235">This means that updates are instant, and conflicting versions are likely to be found at compile time on the developer's workstation.</span></span> <span data-ttu-id="4d4a3-236">實際上，將某些整合測試移至左方。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-236">In effect, shifting some of the integration testing left.</span></span>

<span data-ttu-id="4d4a3-237">在專案之間移動程式碼時，現在可以更輕鬆地保留歷程記錄，因為檔案將偵測為已移動而非重寫。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-237">When moving code between projects, it's now easier to preserve the history as the files will be detected as having been moved rather than being rewritten.</span></span>

<span data-ttu-id="4d4a3-238">另一個優點是，跨越服務界限的範圍變更可在單一認可中進行。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-238">Another advantage is that wide ranging changes that cross service boundaries can be made in a single commit.</span></span> <span data-ttu-id="4d4a3-239">這可減少個別檢查可能有數十項變更的額外負荷。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-239">This reduces the overhead of having potentially dozens of changes to review individually.</span></span>

<span data-ttu-id="4d4a3-240">有許多工具可執行程式碼的靜態分析，以偵測不安全的程式設計實務或 Api 的使用問題。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-240">There are many tools that can perform static analysis of code to detect insecure programming practices or problematic use of APIs.</span></span> <span data-ttu-id="4d4a3-241">在多存放庫的世界中，每個存放庫都必須逐一查看，以找出其中的問題。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-241">In a multi-repository world, each repository will need to be iterated over to find the problems in them.</span></span> <span data-ttu-id="4d4a3-242">單一存放庫允許在單一位置執行分析。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-242">The single repository allows running the analysis all in one place.</span></span>

<span data-ttu-id="4d4a3-243">單一儲存機制的方法也有許多缺點。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-243">There are also many disadvantages to the single repository approach.</span></span> <span data-ttu-id="4d4a3-244">其中一個最擔心的問題是，擁有單一存放庫會引發安全性問題。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-244">One of the most worrying ones is that having a single repository raises security concerns.</span></span> <span data-ttu-id="4d4a3-245">如果存放庫的內容在每個服務模型的儲存機制中流失，則程式碼遺失的數量會降至最低。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-245">If the contents of a repository are leaked in a repository per service model, the amount of code lost is minimal.</span></span> <span data-ttu-id="4d4a3-246">在單一存放庫中，公司擁有的所有專案都可能遺失。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-246">With a single repository, everything the company owns could be lost.</span></span> <span data-ttu-id="4d4a3-247">在這種情況下，有許多範例會 derailing 整個遊戲開發工作。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-247">There have been many examples in the past of this happening and derailing entire game development efforts.</span></span> <span data-ttu-id="4d4a3-248">有多個存放庫公開較少的介面區，這是大部分安全性作法的理想特性。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-248">Having multiple repositories exposes less surface area, which is a desirable trait in most security practices.</span></span>

<span data-ttu-id="4d4a3-249">單一儲存機制的大小可能很快就會變得難以管理。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-249">The size of the single repository is likely to become unmanageable rapidly.</span></span> <span data-ttu-id="4d4a3-250">這會帶來一些有趣的效能含意。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-250">This presents some interesting performance implications.</span></span> <span data-ttu-id="4d4a3-251">您可能會需要使用特定的工具，例如 [適用于 Git 的虛擬檔案系統](https://vfsforgit.org/)，其原本是設計來改善 Windows 小組開發人員的體驗。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-251">It may become necessary to use specialized tools such as [Virtual File System for Git](https://vfsforgit.org/), which was originally designed to improve the experience for developers on the Windows team.</span></span>

<span data-ttu-id="4d4a3-252">使用單一儲存機制的引數通常會細分為 Facebook 或 Google 將此方法用於原始程式碼安排的引數。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-252">Frequently the argument for using a single repository boils down to an argument that Facebook or Google use this method for source code arrangement.</span></span> <span data-ttu-id="4d4a3-253">如果此方法對這些公司來說夠好，則一定是所有公司都是正確的方法。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-253">If the approach is good enough for these companies, then, surely, it's the correct approach for all companies.</span></span> <span data-ttu-id="4d4a3-254">重要的是，少數公司的運作方式就像是 Facebook 或 Google 的規模。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-254">The truth of the matter is that few companies operate on anything like the scale of Facebook or Google.</span></span> <span data-ttu-id="4d4a3-255">這些規模所發生的問題與大部分開發人員都會面臨的問題不同。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-255">The problems that occur at those scales are different from those most developers will face.</span></span> <span data-ttu-id="4d4a3-256">Goose 適用于看的功能可能不適合。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-256">What is good for the goose may not be good for the gander.</span></span>

<span data-ttu-id="4d4a3-257">最後，您可以使用任一種解決方案來裝載微服務的原始程式碼。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-257">In the end, either solution can be used to host the source code for microservices.</span></span> <span data-ttu-id="4d4a3-258">不過，在大部分情況下，在單一存放庫中操作的管理和工程額外負荷，不值得 meager 的優點。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-258">However, in most cases, the management, and engineering overhead of operating in a single repository isn't worth the meager advantages.</span></span> <span data-ttu-id="4d4a3-259">將程式碼分割成多個存放庫，可促進更好的考慮，並促進開發小組之間的自主性。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-259">Splitting code up over multiple repositories encourages better separation of concerns and encourages autonomy among development teams.</span></span>  

### <a name="standard-directory-structure"></a><span data-ttu-id="4d4a3-260">標準目錄結構</span><span class="sxs-lookup"><span data-stu-id="4d4a3-260">Standard directory structure</span></span>

<span data-ttu-id="4d4a3-261">無論單一或多個存放庫都爭論，每個服務都會有自己的目錄。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-261">Regardless of the single versus multiple repositories debate each service will have its own directory.</span></span> <span data-ttu-id="4d4a3-262">讓開發人員快速跨越專案的最佳優化之一，就是維護標準的目錄結構。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-262">One of the best optimizations to allow developers to cross between projects quickly is to maintain a standard directory structure.</span></span>

![圖10-4 電子郵件和登入服務的標準目錄結構](./media/dir-struct.png)

<span data-ttu-id="4d4a3-264">**圖 10-4** -標準目錄結構。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-264">**Figure 10-4** - Standard directory structure.</span></span>

<span data-ttu-id="4d4a3-265">每次建立新專案時，都應該使用放置正確結構的範本。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-265">Whenever a new project is created, a template that puts in place the correct structure should be used.</span></span> <span data-ttu-id="4d4a3-266">此範本也可以將這類有用的專案包含為基本架構讀我檔案和 `azure-pipelines.yml` 。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-266">This template can also include such useful items as a skeleton README file and an `azure-pipelines.yml`.</span></span> <span data-ttu-id="4d4a3-267">在任何微服務架構中，專案之間的高度變異數會讓對服務進行大量作業變得更困難。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-267">In any microservice architecture, a high degree of variance between projects makes bulk operations against the services more difficult.</span></span>

<span data-ttu-id="4d4a3-268">有許多工具可為整個目錄提供範本，其中包含數個原始程式碼目錄。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-268">There are many tools that can provide templating for an entire directory, containing several source code directories.</span></span> <span data-ttu-id="4d4a3-269">[Yeoman](https://yeoman.io/) 在 JavaScript 世界中很受歡迎，GitHub 具有最新發行的 [儲存機制範本](https://github.blog/2019-06-06-generate-new-repositories-with-repository-templates/)，可提供許多相同的功能。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-269">[Yeoman](https://yeoman.io/) is popular in the JavaScript world and GitHub have recently released [Repository Templates](https://github.blog/2019-06-06-generate-new-repositories-with-repository-templates/), which provide much of the same functionality.</span></span>

## <a name="task-management"></a><span data-ttu-id="4d4a3-270">工作管理</span><span class="sxs-lookup"><span data-stu-id="4d4a3-270">Task management</span></span>

<span data-ttu-id="4d4a3-271">管理任何專案中的工作可能會很困難。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-271">Managing tasks in any project can be difficult.</span></span> <span data-ttu-id="4d4a3-272">之前，有許多關於要設定的工作流程，以確保開發人員生產力的相關問題。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-272">Up front there are countless questions to be answered about the sort of workflows to set up to ensure optimal developer productivity.</span></span>

<span data-ttu-id="4d4a3-273">雲端原生應用程式通常會比傳統的軟體產品小，或至少分成較小的服務。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-273">Cloud-native applications tend to be smaller than traditional software products or at least they're divided into smaller services.</span></span> <span data-ttu-id="4d4a3-274">追蹤與這些服務相關的問題或工作，與其他軟體專案一樣重要。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-274">Tracking of issues or tasks related to these services remains as important as with any other software project.</span></span> <span data-ttu-id="4d4a3-275">沒有人想要失去一些工作專案的追蹤，或向客戶說明其問題未正確記錄。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-275">Nobody wants to lose track of some work item or explain to a customer that their issue wasn't properly logged.</span></span> <span data-ttu-id="4d4a3-276">面板是在專案層級設定，但在每個專案中，可以定義區域。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-276">Boards are configured at the project level but within each project, areas can be defined.</span></span> <span data-ttu-id="4d4a3-277">這些可讓您在數個元件之間細分問題。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-277">These allow breaking down issues across several components.</span></span> <span data-ttu-id="4d4a3-278">將整個應用程式的所有工作都放在同一個位置的優點是，您可以輕鬆地將工作專案從一個小組移至另一個小組，因為它們的理解更好。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-278">The advantage to keeping all the work for the entire application in one place is that it's easy to move work items from one team to another as they're understood better.</span></span>

<span data-ttu-id="4d4a3-279">Azure DevOps 隨附一些預先設定的熱門範本。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-279">Azure DevOps comes with a number of popular templates pre-configured.</span></span> <span data-ttu-id="4d4a3-280">在最基本的設定中，需要知道的就是待處理專案、人們正在處理的專案，以及完成的工作。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-280">In the most basic configuration, all that is needed to know is what's in the backlog, what people are working on, and what's done.</span></span> <span data-ttu-id="4d4a3-281">請務必讓您瞭解建立軟體的程式，以便將工作的優先順序和完成的工作回報給客戶。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-281">It's important to have this visibility into the process of building software, so that work can be prioritized and completed tasks reported to the customer.</span></span> <span data-ttu-id="4d4a3-282">當然，有些軟體專案還是會像是、和一樣簡單地處理程式 `to do` `doing` `done` 。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-282">Of course, few software projects stick to a process as simple as `to do`, `doing`, and `done`.</span></span> <span data-ttu-id="4d4a3-283">人們不需要花太長的時間，就可以開始在程式中加入步驟 `QA` `Detailed Specification` 。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-283">It doesn't take long for people to start adding steps like `QA` or `Detailed Specification` to the process.</span></span>

<span data-ttu-id="4d4a3-284">敏捷式方法的其中一個較重要的部分，會以固定的間隔自行自我檢查。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-284">One of the more important parts of Agile methodologies is self-introspection at regular intervals.</span></span> <span data-ttu-id="4d4a3-285">這些評論旨在提供團隊所面臨的問題，以及如何改善這些問題的見解。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-285">These reviews are meant to provide insight into what problems the team is facing and how they can be improved.</span></span> <span data-ttu-id="4d4a3-286">這通常表示透過開發流程變更問題和功能的流程。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-286">Frequently, this means changing the flow of issues and features through the development process.</span></span> <span data-ttu-id="4d4a3-287">因此，將面板的版面配置與額外的階段展開，會是完美的狀況。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-287">So, it's perfectly healthy to expand the layouts of the boards with additional stages.</span></span>

<span data-ttu-id="4d4a3-288">面板中的階段不是唯一的組織工具。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-288">The stages in the boards aren't the only organizational tool.</span></span> <span data-ttu-id="4d4a3-289">視面板的設定而定，有一個工作專案階層。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-289">Depending on the configuration of the board, there's a hierarchy of work items.</span></span> <span data-ttu-id="4d4a3-290">可以出現在面板上的最細微專案是一項工作。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-290">The most granular item that can appear on a board is a task.</span></span> <span data-ttu-id="4d4a3-291">現成的工作包含標題、描述、優先順序、剩餘工作量的估計值，以及連結至其他工作專案或開發專案的功能， (分支、認可、提取要求、組建等) 。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-291">Out of the box a task contains fields for a title, description, a priority, an estimate of the amount of work remaining and the ability to link to other work items or development items (branches, commits, pull requests, builds, and so forth).</span></span> <span data-ttu-id="4d4a3-292">工作專案可分類為應用程式的不同區域， (短期衝刺的不同反復專案) ，以便更輕鬆地找到它們。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-292">Work items can be classified into different areas of the application and different iterations (sprints) to make finding them easier.</span></span>

![圖 10-5 Azure DevOps 中的範例工作](./media/task-details.png)

<span data-ttu-id="4d4a3-294">**圖 10-5** -Azure DevOps 中的工作。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-294">**Figure 10-5** - Task in Azure DevOps.</span></span>

<span data-ttu-id="4d4a3-295">[描述] 欄位支援您預期的一般樣式 (粗體、斜體底線和刪除線) ，以及插入影像的能力。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-295">The description field supports the normal styles you'd expect (bold, italic underscore and strike through) and the ability to insert images.</span></span> <span data-ttu-id="4d4a3-296">這讓它成為一個強大的工具，可在指定工作或錯誤時使用。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-296">This makes it a powerful tool for use when specifying work or bugs.</span></span>

<span data-ttu-id="4d4a3-297">工作可以匯總至功能，以定義較大的工作單位。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-297">Tasks can be rolled up into features, which define a larger unit of work.</span></span> <span data-ttu-id="4d4a3-298">然後，功能可以 [匯總到 epics](/azure/devops/boards/backlogs/define-features-epics?view=azure-devops)中。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-298">Features, in turn, can be [rolled up into epics](/azure/devops/boards/backlogs/define-features-epics?view=azure-devops).</span></span> <span data-ttu-id="4d4a3-299">將此階層中的工作分類，可讓您更容易瞭解大型功能的推出方式。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-299">Classifying tasks in this hierarchy makes it much easier to understand how close a large feature is to rolling out.</span></span>

![圖10-6 基本流程範本中預設設定的工作專案類型](./media/board-issue-types.png)

<span data-ttu-id="4d4a3-301">**圖 10-6** -Azure DevOps 中的工作專案。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-301">**Figure 10-6** - Work item in Azure DevOps.</span></span>

<span data-ttu-id="4d4a3-302">Azure Boards 的問題有不同種類的觀點。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-302">There are different kinds of views into the issues in Azure Boards.</span></span> <span data-ttu-id="4d4a3-303">尚未排程的專案會出現在待處理專案中。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-303">Items that aren't yet scheduled appear in the backlog.</span></span> <span data-ttu-id="4d4a3-304">您可以從該處將它們指派給短期衝刺。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-304">From there, they can be assigned to a sprint.</span></span> <span data-ttu-id="4d4a3-305">短期衝刺是一個時間方塊，在這段期間，預期會完成一些工作數量。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-305">A sprint is a time box during which it's expected some quantity of work will be completed.</span></span> <span data-ttu-id="4d4a3-306">這項工作可以包含工作，也可以包含票證的解決方式。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-306">This work can include tasks but also the resolution of tickets.</span></span> <span data-ttu-id="4d4a3-307">在那裡，您可以從衝刺（Sprint）面板區段管理整個短期衝刺。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-307">Once there, the entire sprint can be managed from the Sprint board section.</span></span> <span data-ttu-id="4d4a3-308">這個視圖會顯示工作的進度，並包含一個待處理的圖表，以便在短期衝刺成功時，提供更新的估計值。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-308">This view shows how work is progressing and includes a burn down chart to give an ever-updating estimate of if the sprint will be successful.</span></span>

![圖10-7 已定義短期衝刺的面板](./media/sprint-board.png)

<span data-ttu-id="4d4a3-310">**圖 10-7** -Azure DevOps 中的面板。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-310">**Figure 10-7** - Board in Azure DevOps.</span></span>

<span data-ttu-id="4d4a3-311">現在，您應該會發現 Azure DevOps 中的面板有很大的威力。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-311">By now, it should be apparent that there's a great deal of power in the Boards in Azure DevOps.</span></span> <span data-ttu-id="4d4a3-312">針對開發人員，您可以輕鬆地查看正在進行的工作。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-312">For developers, there are easy views of what is being worked on.</span></span> <span data-ttu-id="4d4a3-313">讓專案經理觀看即將推出的工作，以及現有工作的總覽。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-313">For project managers views into upcoming work as well as an overview of existing work.</span></span> <span data-ttu-id="4d4a3-314">對於管理員而言，有許多關於資源和容量的報告。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-314">For managers, there are plenty of reports about resourcing and capacity.</span></span> <span data-ttu-id="4d4a3-315">可惜的是，雲端原生應用程式沒有任何神奇，不需要追蹤工作。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-315">Unfortunately, there's nothing magical about cloud-native applications that eliminate the need to track work.</span></span> <span data-ttu-id="4d4a3-316">但是，如果您必須追蹤工作，則有幾個地方可獲得比 Azure DevOps 更好的體驗。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-316">But if you must track work, there are a few places where the experience is better than in Azure DevOps.</span></span>

## <a name="cicd-pipelines"></a><span data-ttu-id="4d4a3-317">CI/CD 管線</span><span class="sxs-lookup"><span data-stu-id="4d4a3-317">CI/CD pipelines</span></span>

<span data-ttu-id="4d4a3-318">軟體發展生命週期中幾乎沒有任何變更，因此在持續整合 (CI) 和持續傳遞 (CD) 中，幾乎沒有任何變更。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-318">Almost no change in the software development life cycle has been so revolutionary as the advent of continuous integration (CI) and continuous delivery (CD).</span></span> <span data-ttu-id="4d4a3-319">在發生變更時，針對專案的原始程式碼建立和執行自動化測試，這會提早捕捉錯誤。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-319">Building and running automated tests against the source code of a project as soon as a change is checked in catches mistakes early.</span></span> <span data-ttu-id="4d4a3-320">在持續整合組建的出現之前，從存放庫提取程式碼，併發現它未通過測試或甚至無法建立，是不常見的情況。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-320">Prior to the advent of continuous integration builds, it wouldn't be uncommon to pull code from the repository and find that it didn't pass tests or couldn't even be built.</span></span> <span data-ttu-id="4d4a3-321">這導致無法追蹤破壞的來源。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-321">This resulted in tracking down the source of the breakage.</span></span>

<span data-ttu-id="4d4a3-322">傳統上將軟體運送到生產環境時，需要廣泛的檔和步驟清單。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-322">Traditionally shipping software to the production environment required extensive documentation and a list of steps.</span></span> <span data-ttu-id="4d4a3-323">上述每一個步驟都需要以非常容易出錯的程式手動完成。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-323">Each one of these steps needed to be manually completed in a very error prone process.</span></span>

![圖10-8 檢查清單](./media/checklist.png)

<span data-ttu-id="4d4a3-325">**圖 10-8** -檢查清單。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-325">**Figure 10-8** - Checklist.</span></span>

<span data-ttu-id="4d4a3-326">持續整合的備用是持續傳遞，其中會將全新的封裝部署至環境。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-326">The sister of continuous integration is continuous delivery in which the freshly built packages are deployed to an environment.</span></span> <span data-ttu-id="4d4a3-327">手動程式無法調整以符合開發速度，因此自動化變得更重要。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-327">The manual process can't scale to match the speed of development so automation becomes more important.</span></span> <span data-ttu-id="4d4a3-328">檢查清單是由腳本所取代，這些腳本可以比任何人更快且更精確地執行相同的工作。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-328">Checklists are replaced by scripts that can execute the same tasks faster and more accurately than any human.</span></span>

<span data-ttu-id="4d4a3-329">持續傳遞所提供的環境可能是測試環境，也可能是由許多主要技術公司所完成的環境，可能是生產環境。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-329">The environment to which continuous delivery delivers might be a test environment or, as is being done by many major technology companies, it could be the production environment.</span></span> <span data-ttu-id="4d4a3-330">後者需要投資高品質的測試，讓您確信變更不會中斷使用者的生產環境。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-330">The latter requires an investment in high-quality tests that can give confidence that a change isn't going to break production for users.</span></span> <span data-ttu-id="4d4a3-331">同樣地，持續整合在程式碼早期持續傳遞中的問題，可及早捕捉部署程式中的問題。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-331">In the same way that continuous integration caught issues in the code early continuous delivery catches issues in the deployment process early.</span></span>

<span data-ttu-id="4d4a3-332">雲端原生應用程式會 accentuated 自動化組建和傳遞流程的重要性。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-332">The importance of automating the build and delivery process is accentuated by cloud-native applications.</span></span> <span data-ttu-id="4d4a3-333">部署會更頻繁且更多環境，因此在不可能的情況上手動部署框線。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-333">Deployments happen more frequently and to more environments so manually deploying borders on impossible.</span></span>

### <a name="azure-builds"></a><span data-ttu-id="4d4a3-334">Azure 組建</span><span class="sxs-lookup"><span data-stu-id="4d4a3-334">Azure Builds</span></span>

<span data-ttu-id="4d4a3-335">Azure DevOps 提供一組工具來比以往更輕鬆地進行持續整合和部署。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-335">Azure DevOps provides a set of tools to make continuous integration and deployment easier than ever.</span></span> <span data-ttu-id="4d4a3-336">這些工具位於 Azure Pipelines 下。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-336">These tools are located under Azure Pipelines.</span></span> <span data-ttu-id="4d4a3-337">第一個是 Azure 組建，也就是一種可大規模執行以 YAML 為基礎之組建定義的工具。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-337">The first of them is Azure Builds, which is a tool for running YAML-based build definitions at scale.</span></span> <span data-ttu-id="4d4a3-338">如果組建需要謹慎地設定環境) 或使用 Azure 託管虛擬機器的持續重新整理集區中的電腦，則使用者可以將自己的組建電腦帶入 (很好的選擇。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-338">Users can either bring their own build machines (great for if the build requires a meticulously set up environment) or use a machine from a constantly refreshed pool of Azure hosted virtual machines.</span></span> <span data-ttu-id="4d4a3-339">這些裝載的組建代理程式已預先安裝了各式各樣的開發工具，不僅適用于 .NET 開發，還包括從 JAVA 到 Python 到 iPhone 開發的所有專案。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-339">These hosted build agents come pre-installed with a wide range of development tools for not just .NET development but for everything from Java to Python to iPhone development.</span></span>

<span data-ttu-id="4d4a3-340">DevOps 包含各種現成的組建定義，可針對任何組建進行自訂。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-340">DevOps includes a wide range of out of the box build definitions that can be customized for any build.</span></span> <span data-ttu-id="4d4a3-341">組建定義會定義在名為 `azure-pipelines.yml` 的檔案中，並簽入存放庫，讓它們可以與原始程式碼一起建立版本。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-341">The build definitions are defined in a file called `azure-pipelines.yml` and checked into the repository so they can be versioned along with the source code.</span></span> <span data-ttu-id="4d4a3-342">這可讓您更輕鬆地在分支中變更組建管線，因為變更可以只簽入該分支。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-342">This makes it much easier to make changes to the build pipeline in a branch as the changes can be checked into just that branch.</span></span> <span data-ttu-id="4d4a3-343">`azure-pipelines.yml`圖10-9 顯示在完整架構上建立 ASP.NET web 應用程式的範例。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-343">An example `azure-pipelines.yml` for building an ASP.NET web application on full framework is show in Figure 10-9.</span></span>

```yml
name: $(rev:r)

variables:
  version: 9.2.0.$(Build.BuildNumber)
  solution: Portals.sln
  artifactName: drop
  buildPlatform: any cpu
  buildConfiguration: release
  
pool:
  name: Hosted VS2017
  demands:
  - msbuild
  - visualstudio
  - vstest

steps:
- task: NuGetToolInstaller@0
  displayName: 'Use NuGet 4.4.1'
  inputs:
    versionSpec: 4.4.1

- task: NuGetCommand@2
  displayName: 'NuGet restore'
  inputs:
    restoreSolution: '$(solution)'

- task: VSBuild@1
  displayName: 'Build solution'
  inputs:
    solution: '$(solution)'
    msbuildArgs: '-p:DeployOnBuild=true -p:WebPublishMethod=Package -p:PackageAsSingleFile=true -p:SkipInvalidConfigurations=true -p:PackageLocation="$(build.artifactstagingdirectory)\\"'
    platform: '$(buildPlatform)'
    configuration: '$(buildConfiguration)'

- task: VSTest@2
  displayName: 'Test Assemblies'
  inputs:
    testAssemblyVer2: |
     **\$(buildConfiguration)\**\*test*.dll
     !**\obj\**
     !**\*testadapter.dll
    platform: '$(buildPlatform)'
    configuration: '$(buildConfiguration)'

- task: CopyFiles@2
  displayName: 'Copy UI Test Files to: $(build.artifactstagingdirectory)'
  inputs:
    SourceFolder: UITests
    TargetFolder: '$(build.artifactstagingdirectory)/uitests'

- task: PublishBuildArtifacts@1
  displayName: 'Publish Artifact'
  inputs:
    PathtoPublish: '$(build.artifactstagingdirectory)'
    ArtifactName: '$(artifactName)'
  condition: succeededOrFailed()
```

<span data-ttu-id="4d4a3-344">**圖 10-9** -範例 >azure-pipelines.yml. yml</span><span class="sxs-lookup"><span data-stu-id="4d4a3-344">**Figure 10-9** - A sample azure-pipelines.yml</span></span>

<span data-ttu-id="4d4a3-345">此組建定義會使用一些內建的工作，這些工作會建立組建，就像建立組 (比大型的 Millennium Falcon) 簡單得多。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-345">This build definition uses a number of built-in tasks that make creating builds as simple as building a Lego set (simpler than the giant Millennium Falcon).</span></span> <span data-ttu-id="4d4a3-346">比方說，NuGet 工作會還原 NuGet 套件，而 VSBuild 工作則會呼叫 Visual Studio build 工具來執行實際的編譯。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-346">For instance, the NuGet task restores NuGet packages, while the VSBuild task calls the Visual Studio build tools to perform the actual compilation.</span></span> <span data-ttu-id="4d4a3-347">Azure DevOps 中有數百個不同的工作可供使用，其中有數千個由該社區維護。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-347">There are hundreds of different tasks available in Azure DevOps, with thousands more that are maintained by the community.</span></span> <span data-ttu-id="4d4a3-348">無論您想要執行的組建工作為何，有些人已經建立了。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-348">It's likely that no matter what build tasks you're looking to run, somebody has built one already.</span></span>

<span data-ttu-id="4d4a3-349">組建可以手動觸發、依排程簽入，或在另一個組建完成時觸發。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-349">Builds can be triggered manually, by a check-in, on a schedule, or by the completion of another build.</span></span> <span data-ttu-id="4d4a3-350">在大部分的情況下，都需要根據每次簽入進行建立。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-350">In most cases, building on every check-in is desirable.</span></span> <span data-ttu-id="4d4a3-351">您可以篩選組建，讓不同的組建針對存放庫的不同部分或不同的分支執行。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-351">Builds can be filtered so that different builds run against different parts of the repository or against different branches.</span></span> <span data-ttu-id="4d4a3-352">這可讓您執行快速組建的案例，例如，在提取要求上進行較少的測試，並在每夜針對主幹執行完整的回歸套件。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-352">This allows for scenarios like running fast builds with reduced testing on pull requests and running a full regression suite against the trunk on a nightly basis.</span></span>

<span data-ttu-id="4d4a3-353">組建的最終結果是稱為「組建成品」的檔案集合。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-353">The end result of a build is a collection of files known as build artifacts.</span></span> <span data-ttu-id="4d4a3-354">這些成品可以傳遞至組建程式中的下一個步驟，或新增至 Azure 成品摘要，以供其他組建使用。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-354">These artifacts can be passed along to the next step in the build process or added to an Azure Artifact feed, so they can be consumed by other builds.</span></span>

### <a name="azure-devops-releases"></a><span data-ttu-id="4d4a3-355">Azure DevOps 版本</span><span class="sxs-lookup"><span data-stu-id="4d4a3-355">Azure DevOps releases</span></span>

<span data-ttu-id="4d4a3-356">組建會負責將軟體編譯成可交付套件，但仍需要將構件推送至測試環境，以完成持續傳遞。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-356">Builds take care of compiling the software into a shippable package, but the artifacts still need to be pushed out to a testing environment to complete continuous delivery.</span></span> <span data-ttu-id="4d4a3-357">針對此，Azure DevOps 會使用稱為版本的個別工具。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-357">For this, Azure DevOps uses a separate tool called Releases.</span></span> <span data-ttu-id="4d4a3-358">發行工具會使用組建中可用的相同工作程式庫，但會引進「階段」的概念。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-358">The Releases tool makes use of the same tasks' library that were available to the Build but introduce a concept of "stages".</span></span> <span data-ttu-id="4d4a3-359">階段是安裝封裝的隔離環境。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-359">A stage is an isolated environment into which the package is installed.</span></span> <span data-ttu-id="4d4a3-360">例如，產品可能會利用開發、QA 和生產環境。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-360">For instance, a product might make use of a development, a QA, and a production environment.</span></span> <span data-ttu-id="4d4a3-361">程式碼會持續傳遞到開發環境中，讓您可以對其執行自動化測試。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-361">Code is continuously delivered into the development environment where automated tests can be run against it.</span></span> <span data-ttu-id="4d4a3-362">一旦這些測試通過，就會移至 QA 環境進行手動測試。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-362">Once those tests pass the release moves onto the QA environment for manual testing.</span></span> <span data-ttu-id="4d4a3-363">最後，程式碼會被推送至所有人都可以看見的生產環境。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-363">Finally, the code is pushed to production where it's visible to everybody.</span></span>

![圖10-10 包含開發、QA 和生產階段的範例發行管線](./media/release-pipeline.png)

<span data-ttu-id="4d4a3-365">**圖 10-10** -發行管線</span><span class="sxs-lookup"><span data-stu-id="4d4a3-365">**Figure 10-10** - Release pipeline</span></span>

<span data-ttu-id="4d4a3-366">組建中的每個階段都可以在前一個階段完成時自動觸發。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-366">Each stage in the build can be automatically triggered by the completion of the previous phase.</span></span> <span data-ttu-id="4d4a3-367">不過，在許多情況下，這並不理想。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-367">In many cases, however, this isn't desirable.</span></span> <span data-ttu-id="4d4a3-368">將程式碼移至生產環境時，可能需要有人核准。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-368">Moving code into production might require approval from somebody.</span></span> <span data-ttu-id="4d4a3-369">發行工具藉由允許發行管線每個步驟的核准者來支援此功能。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-369">The Releases tool supports this by allowing approvers at each step of the release pipeline.</span></span> <span data-ttu-id="4d4a3-370">您可以設定規則，讓特定人員或人員群組必須先簽出版本，才能進入生產環境。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-370">Rules can be set up such that a specific person or group of people must sign off on a release before it makes into production.</span></span> <span data-ttu-id="4d4a3-371">這些閘道可讓您進行手動品質檢查，也可以符合任何與控制進入生產環境相關的法規需求。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-371">These gates allow for manual quality checks and also for compliance with any regulatory requirements related to control what goes into production.</span></span>

### <a name="everybody-gets-a-build-pipeline"></a><span data-ttu-id="4d4a3-372">每個人都會取得組建管線</span><span class="sxs-lookup"><span data-stu-id="4d4a3-372">Everybody gets a build pipeline</span></span>

<span data-ttu-id="4d4a3-373">設定許多組建管線並不會產生任何費用，因此最好讓每個微服務至少有一個組建管線。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-373">There's no cost to configuring many build pipelines, so it's advantageous to have at least one build pipeline per microservice.</span></span> <span data-ttu-id="4d4a3-374">在理想的情況下，微服務可獨立部署至任何環境，讓每一個環境都能透過自己的管線發行，而不需要釋出不相關的程式碼。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-374">Ideally, microservices are independently deployable to any environment so having each one able to be released via its own pipeline without releasing a mass of unrelated code is perfect.</span></span> <span data-ttu-id="4d4a3-375">每個管線都可以有自己的一組核准，以允許每個服務的組建流程變化。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-375">Each pipeline can have its own set of approvals allowing for variations in build process for each service.</span></span>

### <a name="versioning-releases"></a><span data-ttu-id="4d4a3-376">版本控制版本</span><span class="sxs-lookup"><span data-stu-id="4d4a3-376">Versioning releases</span></span>

<span data-ttu-id="4d4a3-377">使用發行功能的一個缺點是，它無法在簽入的檔案中定義 `azure-pipelines.yml` 。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-377">One drawback to using the Releases functionality is that it can't be defined in a checked-in `azure-pipelines.yml` file.</span></span> <span data-ttu-id="4d4a3-378">有許多原因您可能想要從每個分支的發行定義中，將發行基本架構包含在專案範本中。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-378">There are many reasons you might want to do that from having per-branch release definitions to including a release skeleton in your project template.</span></span> <span data-ttu-id="4d4a3-379">幸運的是，工作正在將某些階段支援轉移到組建元件中。</span><span class="sxs-lookup"><span data-stu-id="4d4a3-379">Fortunately, work is ongoing to shift some of the stages support into the Build component.</span></span> <span data-ttu-id="4d4a3-380">這就是所謂的多階段組建，而 [第一個版本現在已可供使用](https://devblogs.microsoft.com/devops/whats-new-with-azure-pipelines/)！</span><span class="sxs-lookup"><span data-stu-id="4d4a3-380">This will be known as multi-stage build and the [first version is available now](https://devblogs.microsoft.com/devops/whats-new-with-azure-pipelines/)!</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="4d4a3-381">[上一個](azure-security.md) 
>[下一步](feature-flags.md)</span><span class="sxs-lookup"><span data-stu-id="4d4a3-381">[Previous](azure-security.md)
[Next](feature-flags.md)</span></span>
