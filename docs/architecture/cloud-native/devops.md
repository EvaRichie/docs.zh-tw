---
title: DevOps
description: 雲端原生應用程式的 DevOps 考慮
ms.date: 05/13/2020
ms.openlocfilehash: 1a04f5178877f3fdde707753e94718ce0f0bb49d
ms.sourcegitcommit: 635a0ff775d2447a81ef7233a599b8f88b162e5d
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 12/17/2020
ms.locfileid: "97633711"
---
# <a name="devops"></a>DevOps

我最愛的軟體顧問口號是回答「它相依于」任何問題。 這並不是因為軟體顧問喜歡了，而不是採用某個位置。 這是因為軟體中任何問題都沒有真正的答案。 沒有絕對權利和錯誤，而是相反之間的平衡。

比方說，開發 web 應用程式的兩大學校：單一頁面應用程式 (Spa) 與伺服器端應用程式。 一方面，使用者體驗通常更適合 Spa，而 web 伺服器的流量也可以最小化，以便將其裝載于像是靜態裝載一樣簡單的東西上。 另一方面，Spa 傾向于開發速度較慢，而且難以測試。 哪一個是正確的選擇？ 當然，這取決於您的情況。

雲端原生應用程式不會受到相同二分法的免疫。 它們在開發、穩定性和擴充性方面都有明顯的好處，但管理它們可能有點困難。

多年前，將應用程式從開發移至生產環境以花一個月或更久的程式並不罕見。 公司以6個月或甚至每年的步調發行軟體。 除了 Microsoft Windows 之外，您還必須先看一下，以瞭解在 Windows 10 的環保天之前，可接受的發行步調。 在 Windows XP 和 Vista 之間傳遞五年，Vista 與 Windows 7 之間有3個。

現在就能輕鬆地發行軟體，讓快速移動的公司能夠以更 sloth 的競爭對手為一大市場優勢。 這是因為 Windows 10 的重大更新現在大約每六個月。

可以更快速、更可靠的版本來提供價值給企業的模式和實務，統稱為 DevOps。 它們包含橫跨整個軟體發展生命週期的各種想法，從指定應用程式一直到傳遞和操作該應用程式都是如此。

DevOps 會在微服務之前發生，而且可能會有較小的移動，而不需要 DevOps，就能在生產環境中釋出和操作許多應用程式。

![[圖 10-1] 搜尋趨勢顯示微服務的成長，直到 DevOps 是相當知名的想法為止。](./media/microservices-vs-devops.png)

**圖 10-1** -DevOps 和微服務。

透過良好的 DevOps 實務，在實際操作應用程式的工作中，您可以實現雲端原生應用程式的優點，而不需要 suffocating。

DevOps 時，沒有黃金的鐵錘。 沒有人可以銷售完整且全方位的解決方案來發行和操作高品質的應用程式。 這是因為每個應用程式與其他應用程式的差異很大。 不過，有一些工具可讓 DevOps 變得更不令人望而生畏。 其中一項工具稱為 Azure DevOps。

## <a name="azure-devops"></a>Azure DevOps

Azure DevOps 有很長的歷史。 當 Team Foundation Server 第一次移至線上，以及透過不同的名稱變更時，它可以追蹤它的根目錄： Visual Studio Online 和 Visual Studio Team Services。 不過，多年來，它已經變得遠超過其前身。

Azure DevOps 分為五個主要元件：

![圖 10-2 Azure DevOps 的五個主要區域](./media/devops-components.png)

**圖 10-2** -Azure DevOps。

**Azure Repos** 原始程式碼管理，支援早期 TEAM FOUNDATION 版本控制 (TFVC) 和業界最愛的 [Git](https://en.wikipedia.org/wiki/Git)。 提取要求可讓您在進行變更時，藉由促進變更的討論來啟用社交編碼。

**Azure Boards** -提供問題和工作專案追蹤工具，致力於讓使用者挑選最適合他們的工作流程。 它隨附一些預先設定的範本，其中包括支援 SCRUM 和看板的開發樣式。

**Azure Pipelines** -支援與 Azure 緊密整合的組建和發行管理系統。 組建可在各種不同的平臺上執行，從 Windows 到 Linux 到 MacOS。 組建代理程式可以布建在雲端或內部部署中。

**Azure Test Plans** -Test Plans 功能提供的測試管理和探勘測試支援將不會留下任何 QA 人員。

**Azure Artifacts** -可讓公司建立自己的 NuGet、npm 和其他版本的成品摘要。 如果集中式儲存機制失敗，則會以雙重目的作為上游套件的快取。

Azure DevOps 中的最上層組織單位稱為「專案」（Project）。 在每個專案中，可以開啟和關閉各種元件（例如 Azure Artifacts）。 每個元件都提供雲端原生應用程式的不同優點。 最有用的三種是存放庫、面板和管線。 如果使用者想要在另一個存放庫堆疊（例如 GitHub）中管理其原始程式碼，但仍可充分利用 Azure Pipelines 和其他元件，這是完全可行的。

幸運的是，開發團隊在選取存放庫時有許多選項。 其中一個是 GitHub。

## <a name="github-actions"></a>GitHub 動作

GitHub 建基於2009，是一種廣泛受歡迎的 web 架構存放庫，可用於裝載專案、檔和程式碼。 許多大型技術公司，例如 Apple、Amazon、Google 和主流公司都使用 GitHub。 GitHub 會使用名為 Git 的開放原始碼分散式版本控制系統作為其基礎。 然後，它會針對每個程式碼基底加入自己的一組功能，包括缺失追蹤、功能和提取要求、工作管理和 wiki。

當 GitHub 發展時，也會新增 DevOps 功能。 例如，GitHub 有自己的持續整合/持續傳遞 (CI/CD) 管線，稱為 `GitHub Actions` 。 GitHub Actions 是以社區為技術的工作流程自動化工具。 它可讓 DevOps 團隊與現有的工具整合、混合和比對新產品，並連結到其軟體生命週期，包括現有的 CI/CD 合作夥伴。

GitHub 有超過40000000的使用者，使其成為世界上最大的原始程式碼主機。 Microsoft 已于2018年10月購買 GitHub。 Microsoft 已 pledged GitHub 將維持 [開放平臺](https://techcrunch.com/2018/06/04/microsoft-promises-to-keep-github-independent-and-open/) ，讓任何開發人員都能插入及擴充。 它會繼續以獨立公司的形式運作。 GitHub 提供 enterprise、team、professional 和免費帳戶的方案。

## <a name="source-control"></a>原始檔控制

組織雲端原生應用程式的程式碼可能是一項挑戰。 雲端原生應用程式通常是由較小的應用程式（彼此交談）所組成，而不是單一的大型應用程式。 如同運算中的所有專案，程式碼的最佳相片順序仍是開放式問題。 使用不同類型的版面配置的成功應用程式範例有很多，但兩個變體似乎最受歡迎。

在進入實際的原始檔控制本身之前，可能需要決定有多少個專案適用。 在單一專案中，支援多個存放庫和組建管線。 面板有點複雜，但也可以輕鬆地將工作指派給單一專案內的多個小組。 有可能支援數百個以上的開發人員，但不只是一個 Azure DevOps 專案。 這樣做可能是最好的方法，因為它提供單一位置讓所有開發人員都能運作，並減少在開發人員不確定應用程式所在的專案時，發現該應用程式的混淆。

在 Azure DevOps 專案內分割微服務程式代碼，可能會稍微更具挑戰性。

![圖10-3 單一與多個存放庫](./media/single-repository-vs-multiple.png)

**圖 10-3** -一與許多存放庫。

### <a name="repository-per-microservice"></a>每個微服務的儲存機制

乍看之下，這似乎是最適合用來分割微服務原始程式碼的邏輯方法。 每個存放庫都可以包含建立一個微服務所需的程式碼。 這種方法的優點很容易看見：

1. 建立和維護應用程式的指示可以新增至每個存放庫根目錄中的讀我檔案。 當您在處理存放庫時，很容易就能找到這些指示，縮短開發人員的加速時間。
2. 每個服務都位於邏輯位置，只要知道服務的名稱即可輕鬆找到。
3. 您可以輕鬆地設定組建，使其只在對擁有存放庫進行變更時才會觸發。
4. 進入存放庫的變更數目僅限於處理專案的少數開發人員。
5. 藉由限制開發人員擁有讀取和寫入權限的存放庫，即可輕鬆地設定安全性。
6. 擁有小組可以變更存放庫層級的設定，並與其他人進行最少的討論。

微服務背後的其中一個重要概念是，服務應該彼此隔離，並彼此分開。 使用網域導向設計來決定服務的界限時，服務會作為交易界限。 資料庫更新不應該跨多個服務。 此相關資料集合稱為系結內容。  這項構想的反映方式是將微服務資料隔離到個別的資料庫，並從其餘的服務自我自主。 將這項構想全部帶到原始程式碼，會有很大的意義。

不過，這種方法不會有問題。 我們時間的其中一個更複雜的開發問題是管理相依性。 請考慮組成平均目錄的檔案數目 `node_modules` 。 像這樣的全新安裝 `create-react-app` 可能會攜帶數以千計的封裝。 如何管理這些相依性的問題是一項困難之處。

如果相依性已更新，則下游套件也必須更新此相依性。 可惜的是，這會讓開發工作順利進行，而 `node_modules` 目錄最後會有單一套件的多個版本，每一個封裝的相依性是以稍有不同的頻率進行版本設定。 部署應用程式時，應該使用哪個版本的相依性？ 目前在生產環境中的版本為何？ 目前在 Beta 版中，但在取用者進入生產環境時可能會在生產環境中的版本？ 不只是使用微服務來解決的困難問題。

有些程式庫相依于各種不同的專案。 藉由將微服務與每個存放庫中的每個存放庫分割，就可以使用內部的儲存機制（Azure Artifacts）來解決內部相依性。 程式庫的組建會將其最新版本推送至 Azure Artifacts 供內部使用。 下游專案仍必須手動更新，才能相依于新更新的封裝。

另一個缺點則是在服務之間移動程式碼時。 雖然認為應用程式的第一個部門的微服務是100% 正確，但其實很少會 prescient 為不會造成服務部門的錯誤。 因此，功能和驅動它的程式碼將需要從服務移至服務：儲存機制到存放庫。 從某個儲存機制 leaping 至另一個存放庫時，程式碼將會失去其歷程記錄。 在許多情況下，尤其是在發生審核事件的情況下，有一段程式碼的完整歷程記錄非常寶貴。

最後一個最重要的缺點是協調變更。 在真正的微服務應用程式中，服務之間應該不會有部署相依性。 您應該能夠以任何順序部署服務 A、B 和 C，因為它們的結合鬆散。 但事實上，在某些情況下，您可能會想要進行一次跨越多個存放庫的變更。 其中一些範例包括更新程式庫以關閉安全性漏洞，或變更所有服務所使用的通訊協定。

若要進行跨存放庫變更，需要連續進行認可至每個存放庫。 每個存放庫中的每個變更都需要提取要求和個別檢查。 這可能很難進行協調。

使用許多存放庫的另一種方式，是將所有的原始程式碼放在一個大型、所有已知的單一存放庫中。

### <a name="single-repository"></a>單一儲存機制

在這種方法中，有時稱為 [monorepository](https://danluu.com/monorepo/)，則每個服務的所有原始程式碼都放在相同的存放庫中。 一開始，這似乎會讓您難以處理原始程式碼。 不過，有一些標示的優點是以這種方式運作。

第一個優點是可以更輕鬆地管理專案之間的相依性。 專案可以直接彼此匯入，而不是依賴某些外部成品摘要。 這表示更新會立即存在，而且可能會在開發人員工作站的編譯時期找到衝突的版本。 實際上，將某些整合測試移至左方。

在專案之間移動程式碼時，現在可以更輕鬆地保留歷程記錄，因為檔案將偵測為已移動而非重寫。

另一個優點是，跨越服務界限的範圍變更可在單一認可中進行。 這可減少個別檢查可能有數十項變更的額外負荷。

有許多工具可執行程式碼的靜態分析，以偵測不安全的程式設計實務或 Api 的使用問題。 在多存放庫的世界中，每個存放庫都必須逐一查看，以找出其中的問題。 單一存放庫允許在單一位置執行分析。

單一儲存機制的方法也有許多缺點。 其中一個最擔心的問題是，擁有單一存放庫會引發安全性問題。 如果存放庫的內容在每個服務模型的儲存機制中流失，則程式碼遺失的數量會降至最低。 在單一存放庫中，公司擁有的所有專案都可能遺失。 在這種情況下，有許多範例會 derailing 整個遊戲開發工作。 有多個存放庫公開較少的介面區，這是大部分安全性作法的理想特性。

單一儲存機制的大小可能很快就會變得難以管理。 這會帶來一些有趣的效能含意。 您可能會需要使用特定的工具，例如 [適用于 Git 的虛擬檔案系統](https://github.com/Microsoft/VFSForGit)，其原本是設計來改善 Windows 小組開發人員的體驗。

使用單一儲存機制的引數通常會細分為 Facebook 或 Google 將此方法用於原始程式碼安排的引數。 如果此方法對這些公司來說夠好，則一定是所有公司都是正確的方法。 重要的是，少數公司的運作方式就像是 Facebook 或 Google 的規模。 這些規模所發生的問題與大部分開發人員都會面臨的問題不同。 Goose 適用于看的功能可能不適合。

最後，您可以使用任一種解決方案來裝載微服務的原始程式碼。 不過，在大部分情況下，在單一存放庫中操作的管理和工程額外負荷，不值得 meager 的優點。 將程式碼分割成多個存放庫，可促進更好的考慮，並促進開發小組之間的自主性。

### <a name="standard-directory-structure"></a>標準目錄結構

無論單一或多個存放庫都爭論，每個服務都會有自己的目錄。 讓開發人員快速跨越專案的最佳優化之一，就是維護標準的目錄結構。

![圖10-4 電子郵件和登入服務的標準目錄結構](./media/dir-struct.png)

**圖 10-4** -標準目錄結構。

每次建立新專案時，都應該使用放置正確結構的範本。 此範本也可以將這類有用的專案包含為基本架構讀我檔案和 `azure-pipelines.yml` 。 在任何微服務架構中，專案之間的高度變異數會讓對服務進行大量作業變得更困難。

有許多工具可為整個目錄提供範本，其中包含數個原始程式碼目錄。 [Yeoman](https://yeoman.io/) 在 JavaScript 世界中很受歡迎，GitHub 具有最新發行的 [儲存機制範本](https://github.blog/2019-06-06-generate-new-repositories-with-repository-templates/)，可提供許多相同的功能。

## <a name="task-management"></a>工作管理

管理任何專案中的工作可能會很困難。 之前，有許多關於要設定的工作流程，以確保開發人員生產力的相關問題。

雲端原生應用程式通常會比傳統的軟體產品小，或至少分成較小的服務。 追蹤與這些服務相關的問題或工作，與其他軟體專案一樣重要。 沒有人想要失去一些工作專案的追蹤，或向客戶說明其問題未正確記錄。 面板是在專案層級設定，但在每個專案中，可以定義區域。 這些可讓您在數個元件之間細分問題。 將整個應用程式的所有工作都放在同一個位置的優點是，您可以輕鬆地將工作專案從一個小組移至另一個小組，因為它們的理解更好。

Azure DevOps 隨附一些預先設定的熱門範本。 在最基本的設定中，需要知道的就是待處理專案、人們正在處理的專案，以及完成的工作。 請務必讓您瞭解建立軟體的程式，以便將工作的優先順序和完成的工作回報給客戶。 當然，有些軟體專案還是會像是、和一樣簡單地處理程式 `to do` `doing` `done` 。 人們不需要花太長的時間，就可以開始在程式中加入步驟 `QA` `Detailed Specification` 。

敏捷式方法的其中一個較重要的部分，會以固定的間隔自行自我檢查。 這些評論旨在提供團隊所面臨的問題，以及如何改善這些問題的見解。 這通常表示透過開發流程變更問題和功能的流程。 因此，將面板的版面配置與額外的階段展開，會是完美的狀況。

面板中的階段不是唯一的組織工具。 視面板的設定而定，有一個工作專案階層。 可以出現在面板上的最細微專案是一項工作。 現成的工作包含標題、描述、優先順序、剩餘工作量的估計值，以及連結至其他工作專案或開發專案的功能， (分支、認可、提取要求、組建等) 。 工作專案可分類為應用程式的不同區域， (短期衝刺的不同反復專案) ，以便更輕鬆地找到它們。

![圖 10-5 Azure DevOps 中的範例工作](./media/task-details.png)

**圖 10-5** -Azure DevOps 中的工作。

[描述] 欄位支援您預期的一般樣式 (粗體、斜體底線和刪除線) ，以及插入影像的能力。 這讓它成為一個強大的工具，可在指定工作或錯誤時使用。

工作可以匯總至功能，以定義較大的工作單位。 然後，功能可以 [匯總到 epics](/azure/devops/boards/backlogs/define-features-epics?view=azure-devops)中。 將此階層中的工作分類，可讓您更容易瞭解大型功能的推出方式。

![圖10-6 基本流程範本中預設設定的工作專案類型](./media/board-issue-types.png)

**圖 10-6** -Azure DevOps 中的工作專案。

Azure Boards 的問題有不同種類的觀點。 尚未排程的專案會出現在待處理專案中。 您可以從該處將它們指派給短期衝刺。 短期衝刺是一個時間方塊，在這段期間，預期會完成一些工作數量。 這項工作可以包含工作，也可以包含票證的解決方式。 在那裡，您可以從衝刺（Sprint）面板區段管理整個短期衝刺。 這個視圖會顯示工作的進度，並包含一個待處理的圖表，以便在短期衝刺成功時，提供更新的估計值。

![圖10-7 已定義短期衝刺的面板](./media/sprint-board.png)

**圖 10-7** -Azure DevOps 中的面板。

現在，您應該會發現 Azure DevOps 中的面板有很大的威力。 針對開發人員，您可以輕鬆地查看正在進行的工作。 讓專案經理觀看即將推出的工作，以及現有工作的總覽。 對於管理員而言，有許多關於資源和容量的報告。 可惜的是，雲端原生應用程式沒有任何神奇，不需要追蹤工作。 但是，如果您必須追蹤工作，則有幾個地方可獲得比 Azure DevOps 更好的體驗。

## <a name="cicd-pipelines"></a>CI/CD 管線

軟體發展生命週期中幾乎沒有任何變更，因此在持續整合 (CI) 和持續傳遞 (CD) 中，幾乎沒有任何變更。 在發生變更時，針對專案的原始程式碼建立和執行自動化測試，這會提早捕捉錯誤。 在持續整合組建的出現之前，從存放庫提取程式碼，併發現它未通過測試或甚至無法建立，是不常見的情況。 這導致無法追蹤破壞的來源。

傳統上將軟體運送到生產環境時，需要廣泛的檔和步驟清單。 上述每一個步驟都需要以非常容易出錯的程式手動完成。

![圖10-8 檢查清單](./media/checklist.png)

**圖 10-8** -檢查清單。

持續整合的備用是持續傳遞，其中會將全新的封裝部署至環境。 手動程式無法調整以符合開發速度，因此自動化變得更重要。 檢查清單是由腳本所取代，這些腳本可以比任何人更快且更精確地執行相同的工作。

持續傳遞所提供的環境可能是測試環境，也可能是由許多主要技術公司所完成的環境，可能是生產環境。 後者需要投資高品質的測試，讓您確信變更不會中斷使用者的生產環境。 同樣地，持續整合在程式碼早期持續傳遞中的問題，可及早捕捉部署程式中的問題。

雲端原生應用程式會 accentuated 自動化組建和傳遞流程的重要性。 部署會更頻繁且更多環境，因此在不可能的情況上手動部署框線。

### <a name="azure-builds"></a>Azure 組建

Azure DevOps 提供一組工具來比以往更輕鬆地進行持續整合和部署。 這些工具位於 Azure Pipelines 下。 第一個是 Azure 組建，也就是一種可大規模執行以 YAML 為基礎之組建定義的工具。 如果組建需要謹慎地設定環境) 或使用 Azure 託管虛擬機器的持續重新整理集區中的電腦，則使用者可以將自己的組建電腦帶入 (很好的選擇。 這些裝載的組建代理程式已預先安裝了各式各樣的開發工具，不僅適用于 .NET 開發，還包括從 JAVA 到 Python 到 iPhone 開發的所有專案。

DevOps 包含各種現成的組建定義，可針對任何組建進行自訂。 組建定義會定義在名為 `azure-pipelines.yml` 的檔案中，並簽入存放庫，讓它們可以與原始程式碼一起建立版本。 這可讓您更輕鬆地在分支中變更組建管線，因為變更可以只簽入該分支。 `azure-pipelines.yml`圖10-9 顯示在完整架構上建立 ASP.NET web 應用程式的範例。

```yml
name: $(rev:r)

variables:
  version: 9.2.0.$(Build.BuildNumber)
  solution: Portals.sln
  artifactName: drop
  buildPlatform: any cpu
  buildConfiguration: release

pool:
  name: Hosted VS2017
  demands:
  - msbuild
  - visualstudio
  - vstest

steps:
- task: NuGetToolInstaller@0
  displayName: 'Use NuGet 4.4.1'
  inputs:
    versionSpec: 4.4.1

- task: NuGetCommand@2
  displayName: 'NuGet restore'
  inputs:
    restoreSolution: '$(solution)'

- task: VSBuild@1
  displayName: 'Build solution'
  inputs:
    solution: '$(solution)'
    msbuildArgs: '-p:DeployOnBuild=true -p:WebPublishMethod=Package -p:PackageAsSingleFile=true -p:SkipInvalidConfigurations=true -p:PackageLocation="$(build.artifactstagingdirectory)\\"'
    platform: '$(buildPlatform)'
    configuration: '$(buildConfiguration)'

- task: VSTest@2
  displayName: 'Test Assemblies'
  inputs:
    testAssemblyVer2: |
     **\$(buildConfiguration)\**\*test*.dll
     !**\obj\**
     !**\*testadapter.dll
    platform: '$(buildPlatform)'
    configuration: '$(buildConfiguration)'

- task: CopyFiles@2
  displayName: 'Copy UI Test Files to: $(build.artifactstagingdirectory)'
  inputs:
    SourceFolder: UITests
    TargetFolder: '$(build.artifactstagingdirectory)/uitests'

- task: PublishBuildArtifacts@1
  displayName: 'Publish Artifact'
  inputs:
    PathtoPublish: '$(build.artifactstagingdirectory)'
    ArtifactName: '$(artifactName)'
  condition: succeededOrFailed()
```

**圖 10-9** -範例 >azure-pipelines.yml. yml

此組建定義會使用一些內建的工作，這些工作會建立組建，就像建立組 (比大型的 Millennium Falcon) 簡單得多。 比方說，NuGet 工作會還原 NuGet 套件，而 VSBuild 工作則會呼叫 Visual Studio build 工具來執行實際的編譯。 Azure DevOps 中有數百個不同的工作可供使用，其中有數千個由該社區維護。 無論您想要執行的組建工作為何，有些人已經建立了。

組建可以手動觸發、依排程簽入，或在另一個組建完成時觸發。 在大部分的情況下，都需要根據每次簽入進行建立。 您可以篩選組建，讓不同的組建針對存放庫的不同部分或不同的分支執行。 這可讓您執行快速組建的案例，例如，在提取要求上進行較少的測試，並在每夜針對主幹執行完整的回歸套件。

組建的最終結果是稱為「組建成品」的檔案集合。 這些成品可以傳遞至組建程式中的下一個步驟，或新增至 Azure 成品摘要，以供其他組建使用。

### <a name="azure-devops-releases"></a>Azure DevOps 版本

組建會負責將軟體編譯成可交付套件，但仍需要將構件推送至測試環境，以完成持續傳遞。 針對此，Azure DevOps 會使用稱為版本的個別工具。 發行工具會使用組建中可用的相同工作程式庫，但會引進「階段」的概念。 階段是安裝封裝的隔離環境。 例如，產品可能會利用開發、QA 和生產環境。 程式碼會持續傳遞到開發環境中，讓您可以對其執行自動化測試。 一旦這些測試通過，就會移至 QA 環境進行手動測試。 最後，程式碼會被推送至所有人都可以看見的生產環境。

![圖10-10 包含開發、QA 和生產階段的範例發行管線](./media/release-pipeline.png)

**圖 10-10** -發行管線

組建中的每個階段都可以在前一個階段完成時自動觸發。 不過，在許多情況下，這並不理想。 將程式碼移至生產環境時，可能需要有人核准。 發行工具藉由允許發行管線每個步驟的核准者來支援此功能。 您可以設定規則，讓特定人員或人員群組必須先簽出版本，才能進入生產環境。 這些閘道可讓您進行手動品質檢查，也可以符合任何與控制進入生產環境相關的法規需求。

### <a name="everybody-gets-a-build-pipeline"></a>每個人都會取得組建管線

設定許多組建管線並不會產生任何費用，因此最好讓每個微服務至少有一個組建管線。 在理想的情況下，微服務可獨立部署至任何環境，讓每一個環境都能透過自己的管線發行，而不需要釋出不相關的程式碼。 每個管線都可以有自己的一組核准，以允許每個服務的組建流程變化。

### <a name="versioning-releases"></a>版本控制版本

使用發行功能的一個缺點是，它無法在簽入的檔案中定義 `azure-pipelines.yml` 。 有許多原因您可能想要從每個分支的發行定義中，將發行基本架構包含在專案範本中。 幸運的是，工作正在將某些階段支援轉移到組建元件中。 這就是所謂的多階段組建，而 [第一個版本現在已可供使用](https://devblogs.microsoft.com/devops/whats-new-with-azure-pipelines/)！

>[!div class="step-by-step"]
>[上一個](azure-security.md) 
>[下一步](feature-flags.md)
