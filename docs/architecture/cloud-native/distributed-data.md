---
title: 分散式資料
description: 對比整合型和雲端原生應用程式中的資料儲存。
author: robvet
ms.date: 05/13/2020
ms.openlocfilehash: 28513f8691c06cf58ed14d57bf7830bb35d94852
ms.sourcegitcommit: ee5b798427f81237a3c23d1fd81fff7fdc21e8d3
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 05/28/2020
ms.locfileid: "84144392"
---
# <a name="distributed-data"></a><span data-ttu-id="6b4ba-103">分散式資料</span><span class="sxs-lookup"><span data-stu-id="6b4ba-103">Distributed data</span></span>

<span data-ttu-id="6b4ba-104">如我們在本書中所見，雲端原生方法會改變您設計、部署和管理應用程式的方式。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-104">As we've seen throughout this book, a cloud-native approach changes the way you design, deploy, and manage applications.</span></span> <span data-ttu-id="6b4ba-105">它也會變更您管理和儲存資料的方式。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-105">It also changes the way you manage and store data.</span></span>

<span data-ttu-id="6b4ba-106">圖5-1 對比差異。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-106">Figure 5-1 contrasts the differences.</span></span>

![雲端原生應用程式中的資料儲存](./media/distributed-data.png)

<span data-ttu-id="6b4ba-108">**圖 5-1**。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-108">**Figure 5-1**.</span></span> <span data-ttu-id="6b4ba-109">雲端原生應用程式中的資料管理</span><span class="sxs-lookup"><span data-stu-id="6b4ba-109">Data management in cloud-native applications</span></span>

<span data-ttu-id="6b4ba-110">有經驗的開發人員很容易就能辨識圖5-1 左邊的架構。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-110">Experienced developers will easily recognize the architecture on the left-side of figure 5-1.</span></span> <span data-ttu-id="6b4ba-111">在此整合型*應用程式*中，商務服務元件會在共用服務層級中共置，並從單一關係資料庫共用資料。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-111">In this *monolithic application*, business service components collocate together in a shared services tier, sharing data from a single relational database.</span></span>

<span data-ttu-id="6b4ba-112">在許多方面，單一資料庫會讓資料管理變得簡單。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-112">In many ways, a single database keeps data management simple.</span></span> <span data-ttu-id="6b4ba-113">查詢多個資料表中的資料很簡單。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-113">Querying data across multiple tables is straightforward.</span></span> <span data-ttu-id="6b4ba-114">對資料更新的變更，或全部回復。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-114">Changes to data update together or they all rollback.</span></span> <span data-ttu-id="6b4ba-115">[ACID 交易](https://docs.microsoft.com/windows/desktop/cossdk/acid-properties)保證強式和立即一致性。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-115">[ACID transactions](https://docs.microsoft.com/windows/desktop/cossdk/acid-properties) guarantee strong and immediate consistency.</span></span>

<span data-ttu-id="6b4ba-116">針對雲端原生設計，我們採用不同的方法。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-116">Designing for cloud-native, we take a different approach.</span></span> <span data-ttu-id="6b4ba-117">在 [圖 5-1] 的右側，請注意商務功能如何都會隔離為小型、獨立的微服務。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-117">On the right-side of Figure 5-1, note how business functionality segregates into small, independent microservices.</span></span> <span data-ttu-id="6b4ba-118">每個微服務都會封裝特定的商務功能和自己的資料。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-118">Each microservice encapsulates a specific business capability and its own data.</span></span> <span data-ttu-id="6b4ba-119">整合型資料庫會 decompose 到具有許多較小資料庫的分散式資料模型中，每個都與一個微服務對齊。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-119">The monolithic database decomposes into a distributed data model with many smaller databases, each aligning with a microservice.</span></span> <span data-ttu-id="6b4ba-120">當冒煙清除時，我們會形成一個設計，*每個微服務*都會公開一個資料庫。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-120">When the smoke clears, we emerge with a design that exposes a *database per microservice*.</span></span>

## <a name="database-per-microservice-why"></a><span data-ttu-id="6b4ba-121">每個微服務的資料庫，原因為何？</span><span class="sxs-lookup"><span data-stu-id="6b4ba-121">Database-per-microservice, why?</span></span>

<span data-ttu-id="6b4ba-122">每個微服務的這個資料庫提供許多優點，特別是針對必須快速發展並支援大規模的系統。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-122">This database per microservice provides many benefits, especially for systems that must evolve rapidly and support massive scale.</span></span> <span data-ttu-id="6b4ba-123">使用此模型 .。。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-123">With this model...</span></span>

- <span data-ttu-id="6b4ba-124">網域資料封裝在服務內</span><span class="sxs-lookup"><span data-stu-id="6b4ba-124">Domain data is encapsulated within the service</span></span>
- <span data-ttu-id="6b4ba-125">資料架構可以進化，而不會直接影響其他服務</span><span class="sxs-lookup"><span data-stu-id="6b4ba-125">Data schema can evolve without directly impacting other services</span></span>
- <span data-ttu-id="6b4ba-126">每個資料存放區都可以獨立調整</span><span class="sxs-lookup"><span data-stu-id="6b4ba-126">Each data store can independently scale</span></span>
- <span data-ttu-id="6b4ba-127">某個服務中的資料存放區失敗不會直接影響其他服務</span><span class="sxs-lookup"><span data-stu-id="6b4ba-127">A data store failure in one service won't directly impact other services</span></span>

<span data-ttu-id="6b4ba-128">分隔資料也可讓每個微服務執行最適合其工作負載、儲存體需求和讀寫模式的資料存放區類型。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-128">Segregating data also enables each microservice to implement the data store type that is best optimized for its workload, storage needs, and read/write patterns.</span></span> <span data-ttu-id="6b4ba-129">選擇包括關聯式、檔、索引鍵/值，甚至是以圖表為基礎的資料存放區。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-129">Choices include relational, document, key-value, and even graph-based data stores.</span></span>

<span data-ttu-id="6b4ba-130">圖5-2 顯示在雲端原生系統中多語言持續性的原則。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-130">Figure 5-2 presents the principle of polyglot persistence in a cloud-native system.</span></span>

![多語言資料持續性](./media/polyglot-data-persistence.png)

<span data-ttu-id="6b4ba-132">**圖 5-2**。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-132">**Figure 5-2**.</span></span> <span data-ttu-id="6b4ba-133">多語言資料持續性</span><span class="sxs-lookup"><span data-stu-id="6b4ba-133">Polyglot data persistence</span></span>

<span data-ttu-id="6b4ba-134">請注意，上圖中的每個微服務如何支援不同類型的資料存放區。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-134">Note in the previous figure how each microservice supports a different type of data store.</span></span>

- <span data-ttu-id="6b4ba-135">產品目錄微服務會使用關係資料庫來容納其基礎資料的豐富關聯式結構。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-135">The product catalog microservice consumes a relational database to accommodate the rich relational structure of its underlying data.</span></span>
- <span data-ttu-id="6b4ba-136">[購物車] 微服務會使用支援其簡單的索引鍵/值資料存放區的分散式快取。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-136">The shopping cart microservice consumes a distributed cache that supports its simple, key-value data store.</span></span>
- <span data-ttu-id="6b4ba-137">訂購微服務會同時使用 NoSql 檔資料庫進行寫入作業以及高度反正規化的索引鍵/值存放區，以容納大量的讀取作業。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-137">The ordering microservice consumes both a NoSql document database for write operations along with a highly denormalized key/value store to accommodate high-volumes of read operations.</span></span>
  
<span data-ttu-id="6b4ba-138">雖然關係資料庫與複雜資料的微服務保持相關，但 NoSQL 資料庫已獲得相當大的普及。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-138">While relational databases remain relevant for microservices with complex data, NoSQL databases have gained considerable popularity.</span></span> <span data-ttu-id="6b4ba-139">它們提供大規模和高可用性。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-139">They provide massive scale and high availability.</span></span> <span data-ttu-id="6b4ba-140">其無架構的本質可讓開發人員從具類型的資料類別和 Orm 的架構中移出，這會使變更成本高昂且耗時。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-140">Their schemaless nature allows developers to move away from an architecture of typed data classes and ORMs that make change expensive and time-consuming.</span></span> <span data-ttu-id="6b4ba-141">我們將在本章稍後討論 NoSQL 資料庫。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-141">We cover NoSQL databases later in this chapter.</span></span>

 <span data-ttu-id="6b4ba-142">雖然將資料封裝成不同的微服務可以增加靈活性、效能和擴充性，但也會帶來許多挑戰。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-142">While encapsulating  data into separate microservices can increase agility, performance, and scalability, it also presents many challenges.</span></span> <span data-ttu-id="6b4ba-143">在下一節中，我們將討論這些挑戰以及模式和實務，以協助克服這些難題。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-143">In the next section, we discuss these challenges along with patterns and practices to help overcome them.</span></span>  

## <a name="cross-service-queries"></a><span data-ttu-id="6b4ba-144">跨服務查詢</span><span class="sxs-lookup"><span data-stu-id="6b4ba-144">Cross-service queries</span></span>

<span data-ttu-id="6b4ba-145">雖然微服務是獨立的，而且專注于特定的功能功能，例如清查、出貨或訂購，但它們經常需要與其他微服務整合。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-145">While microservices are independent and focus on specific functional capabilities, like inventory, shipping, or ordering, they frequently require integration with other microservices.</span></span> <span data-ttu-id="6b4ba-146">整合通常牽涉到一個微服務*查詢*資料的另一個。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-146">Often the integration involves one microservice *querying* another for data.</span></span> <span data-ttu-id="6b4ba-147">圖5-3 顯示案例。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-147">Figure 5-3 shows the scenario.</span></span>

![跨微服務查詢](./media/cross-service-query.png)

<span data-ttu-id="6b4ba-149">**圖 5-3**。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-149">**Figure 5-3**.</span></span> <span data-ttu-id="6b4ba-150">跨微服務查詢</span><span class="sxs-lookup"><span data-stu-id="6b4ba-150">Querying across microservices</span></span>

<span data-ttu-id="6b4ba-151">在上圖中，我們看到 [購物籃] 微服務，可將專案新增至使用者的購物籃。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-151">In the preceding figure, we see a shopping basket microservice that adds an item to a user's shopping basket.</span></span> <span data-ttu-id="6b4ba-152">雖然此微服務的資料存放區包含購物籃和明細專案資料，但它不會維護產品或定價資料。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-152">While the data store for this microservice contains basket and line item data, it doesn't maintain product or pricing data.</span></span> <span data-ttu-id="6b4ba-153">而是由 [目錄] 和 [定價] 微服務所擁有的這些資料項目。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-153">Instead, those data items are owned by the catalog and pricing microservices.</span></span> <span data-ttu-id="6b4ba-154">這會造成問題。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-154">This presents a problem.</span></span> <span data-ttu-id="6b4ba-155">當購物籃在其資料庫中沒有產品或定價資料時，如何微服務將產品新增至使用者的購物籃？</span><span class="sxs-lookup"><span data-stu-id="6b4ba-155">How can the shopping basket microservice add a product to the user's shopping basket when it doesn't have product nor pricing data in its database?</span></span>

<span data-ttu-id="6b4ba-156">第4章所討論的一個選項是從購物籃到目錄和定價微服務的[直接 HTTP 呼叫](service-to-service-communication.md#queries)。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-156">One option discussed in Chapter 4 is a [direct HTTP call](service-to-service-communication.md#queries) from the shopping basket to the catalog and pricing microservices.</span></span> <span data-ttu-id="6b4ba-157">不過，在第4章中，我們說過同步的*HTTP 呼叫數*個微服務，減少了其自我的自我整合，並降低了架構的優點。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-157">However, in chapter 4, we said synchronous HTTP calls *couple* microservices together, reducing their autonomy and diminishing their architectural benefits.</span></span>

<span data-ttu-id="6b4ba-158">我們也可以針對每個服務，使用個別的輸入和輸出佇列來執行要求-回復模式。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-158">We could also implement a request-reply pattern with separate inbound and outbound queues for each service.</span></span> <span data-ttu-id="6b4ba-159">不過，此模式很複雜，而且需要進行管線以關聯要求和回應訊息。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-159">However, this pattern is complicated and requires plumbing to correlate request and response messages.</span></span>
<span data-ttu-id="6b4ba-160">雖然它會分離後端微服務呼叫，但呼叫服務仍必須同步等候呼叫完成。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-160">While it does decouple the backend microservice calls, the calling service must still synchronously wait for the call to complete.</span></span> <span data-ttu-id="6b4ba-161">網路擁塞、暫時性錯誤或多載微服務，可能會導致長時間執行甚至失敗的作業。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-161">Network congestion, transient faults, or an overloaded microservice and can result in long-running and even failed operations.</span></span>

<span data-ttu-id="6b4ba-162">相反地，移除跨服務相依性的廣泛接受模式就是[具體化視圖模式](https://docs.microsoft.com/azure/architecture/patterns/materialized-view)，如圖5-4 所示。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-162">Instead, a widely accepted pattern for removing cross-service dependencies is the [Materialized View Pattern](https://docs.microsoft.com/azure/architecture/patterns/materialized-view), shown in Figure 5-4.</span></span>

![具體化視圖模式](./media/materialized-view-pattern.png)

<span data-ttu-id="6b4ba-164">**圖 5-4**。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-164">**Figure 5-4**.</span></span> <span data-ttu-id="6b4ba-165">具體化視圖模式</span><span class="sxs-lookup"><span data-stu-id="6b4ba-165">Materialized View Pattern</span></span>

<span data-ttu-id="6b4ba-166">使用此模式時，您會將本機資料表（稱為「*讀取模型*」）放在「購物籃」服務中。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-166">With this pattern, you place a local data table (known as a *read model*) in the shopping basket service.</span></span> <span data-ttu-id="6b4ba-167">此資料表包含產品和定價微服務所需之資料的反正規化複本。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-167">This table contains a denormalized copy of the data needed from the product and pricing microservices.</span></span> <span data-ttu-id="6b4ba-168">將資料直接複製到 [購物籃] 微服務，就不需要昂貴的跨服務呼叫。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-168">Copying the data directly into the shopping basket microservice eliminates the need for expensive cross-service calls.</span></span> <span data-ttu-id="6b4ba-169">在服務的本機資料中，您可以改善服務的回應時間和可靠性。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-169">With the data local to the service, you improve the service's response time and reliability.</span></span> <span data-ttu-id="6b4ba-170">此外，擁有自己的資料複本，可以提高購物籃服務的彈性。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-170">Additionally, having its own copy of the data makes the shopping basket service more resilient.</span></span> <span data-ttu-id="6b4ba-171">如果目錄服務應該變成無法使用，它不會直接影響購物籃服務。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-171">If the catalog service should become unavailable, it wouldn't directly impact the shopping basket service.</span></span> <span data-ttu-id="6b4ba-172">購物籃可以繼續使用自己的存放區中的資料來操作。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-172">The shopping basket can continue operating with the data from its own store.</span></span>

<span data-ttu-id="6b4ba-173">這種方法的 catch 在於您的系統中現在有重複的資料。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-173">The catch with this approach is that you now have duplicate data in your system.</span></span> <span data-ttu-id="6b4ba-174">不過，在雲端原生系統中，*策略性*地複製資料是已建立的實務，並不會被視為反模式或不正確的作法。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-174">However, *strategically* duplicating data in cloud-native systems is an established practice and not considered an anti-pattern, or bad practice.</span></span> <span data-ttu-id="6b4ba-175">請記住，*只有一個服務*可以擁有一個資料集，並具有其授權。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-175">Keep in mind that *one and only one service* can own a data set and have authority over it.</span></span> <span data-ttu-id="6b4ba-176">當記錄的系統更新時，您必須同步處理讀取模型。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-176">You'll need to synchronize the read models when the system of record is updated.</span></span> <span data-ttu-id="6b4ba-177">同步處理通常是透過使用[發佈/訂閱模式](service-to-service-communication.md#events)的非同步訊息來執行，如圖5.4 所示。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-177">Synchronization is typically implemented via asynchronous messaging with a [publish/subscribe pattern](service-to-service-communication.md#events), as shown in Figure 5.4.</span></span>

## <a name="distributed-transactions"></a><span data-ttu-id="6b4ba-178">分散式交易</span><span class="sxs-lookup"><span data-stu-id="6b4ba-178">Distributed transactions</span></span>

<span data-ttu-id="6b4ba-179">查詢跨微服務的資料很艱難，在數個微服務之間執行交易更為複雜。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-179">While querying data across microservices is difficult, implementing a transaction across several microservices is even more complex.</span></span> <span data-ttu-id="6b4ba-180">在不同微服務的獨立資料來源之間維護資料一致性的固有挑戰，無法 understated。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-180">The inherent challenge of maintaining data consistency across independent data sources in different microservices can't be understated.</span></span> <span data-ttu-id="6b4ba-181">在雲端原生應用程式中缺少分散式交易，表示您必須以程式設計方式管理分散式交易。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-181">The lack of distributed transactions in cloud-native applications means that you must manage distributed transactions programmatically.</span></span> <span data-ttu-id="6b4ba-182">您可以從*立即一致性*的世界轉移到*最終一致性*。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-182">You move from a world of *immediate consistency* to that of *eventual consistency*.</span></span>

<span data-ttu-id="6b4ba-183">圖5-5 顯示問題。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-183">Figure 5-5 shows the problem.</span></span>

![Saga 模式中的交易](./media/saga-transaction-operation.png)

<span data-ttu-id="6b4ba-185">**圖 5-5**。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-185">**Figure 5-5**.</span></span> <span data-ttu-id="6b4ba-186">跨微服務執行交易</span><span class="sxs-lookup"><span data-stu-id="6b4ba-186">Implementing a transaction across microservices</span></span>

<span data-ttu-id="6b4ba-187">在上圖中，五個獨立的微服務會參與建立訂單的分散式交易。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-187">In the preceding figure, five independent microservices participate in a distributed transaction that creates an order.</span></span> <span data-ttu-id="6b4ba-188">每個微服務都會維護它自己的資料存放區，並為其存放區執行本機交易。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-188">Each microservice maintains its own data store and implements a local transaction for its store.</span></span> <span data-ttu-id="6b4ba-189">若要建立訂單，*每個*個別微服務的本機交易必須成功，或*全部都*必須中止並復原作業。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-189">To create the order, the local transaction for *each* individual microservice must succeed, or *all* must abort and roll back the operation.</span></span> <span data-ttu-id="6b4ba-190">雖然內建交易支援可在每個微服務中使用，但不支援橫跨所有五個服務的分散式交易，以保持資料的一致性。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-190">While built-in transactional support is available inside each of the microservices, there's no support for a distributed transaction that would span across all five services to keep data consistent.</span></span>

<span data-ttu-id="6b4ba-191">相反地，您必須以程式設計*方式*來結構化此分散式交易。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-191">Instead, you must construct this distributed transaction *programmatically*.</span></span>

<span data-ttu-id="6b4ba-192">加入分散式交易支援的常見模式是 Saga 模式。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-192">A popular pattern for adding distributed transactional support is the Saga pattern.</span></span> <span data-ttu-id="6b4ba-193">它是藉由以程式設計方式將本機交易群組在一起，並依序叫用每一個。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-193">It's implemented by grouping local transactions together programmatically and sequentially invoking each one.</span></span> <span data-ttu-id="6b4ba-194">如果任何本機交易失敗，Saga 會中止作業並叫用一組[補償交易](https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction)。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-194">If any of the local transactions fail, the Saga aborts the operation and invokes a set of [compensating transactions](https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction).</span></span> <span data-ttu-id="6b4ba-195">補償交易會復原先前的本機交易所做的變更，並還原資料的一致性。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-195">The compensating transactions undo the changes made by the preceding local transactions and restore data consistency.</span></span> <span data-ttu-id="6b4ba-196">圖5-6 顯示具有 Saga 模式的失敗交易。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-196">Figure 5-6 shows a failed transaction with the Saga pattern.</span></span>

![在 saga 模式中復原](./media/saga-rollback-operation.png)

<span data-ttu-id="6b4ba-198">**圖 5-6**。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-198">**Figure 5-6**.</span></span> <span data-ttu-id="6b4ba-199">復原交易</span><span class="sxs-lookup"><span data-stu-id="6b4ba-199">Rolling back a transaction</span></span>

<span data-ttu-id="6b4ba-200">在上圖中，清查微服務中的*更新清查*操作失敗。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-200">In the previous figure, the *Update Inventory* operation has failed in the Inventory microservice.</span></span> <span data-ttu-id="6b4ba-201">Saga 會叫用一組補償交易（以紅色表示）來調整清查計數、取消付款和訂單，然後將每個微服務的資料傳回一致的狀態。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-201">The Saga invokes a set of compensating transactions (in red) to adjust the inventory counts, cancel the payment and the order, and return the data for each microservice back to a consistent state.</span></span>

<span data-ttu-id="6b4ba-202">Saga 模式通常會單純為一系列相關的事件，或協調成一組相關的命令。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-202">Saga patterns are typically choreographed as a series of related events, or orchestrated as a set of related commands.</span></span> <span data-ttu-id="6b4ba-203">在第4章中，我們討論了「服務匯總工具」模式，這是協調的 saga 實作為基礎。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-203">In Chapter 4, we discussed the service aggregator pattern that would be the foundation for an orchestrated saga implementation.</span></span> <span data-ttu-id="6b4ba-204">我們也討論了事件，以及 Azure 服務匯流排和 Azure Event Grid 主題，這是單純 saga 的基礎。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-204">We also discussed eventing along with Azure Service Bus and Azure Event Grid topics that would be a foundation for a choreographed saga implementation.</span></span>

## <a name="high-volume-data"></a><span data-ttu-id="6b4ba-205">大量資料</span><span class="sxs-lookup"><span data-stu-id="6b4ba-205">High volume data</span></span>

<span data-ttu-id="6b4ba-206">大型雲端原生應用程式通常支援高容量的資料需求。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-206">Large cloud-native applications often support high-volume data requirements.</span></span> <span data-ttu-id="6b4ba-207">在這些案例中，傳統的資料儲存技術可能會造成瓶頸。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-207">In these scenarios, traditional data storage techniques can cause bottlenecks.</span></span> <span data-ttu-id="6b4ba-208">對於大規模部署的複雜系統，命令與查詢責任隔離（CQRS）和事件來源都可以改善應用程式效能。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-208">For complex systems that deploy on a large scale, both Command and Query Responsibility Segregation (CQRS) and Event Sourcing may improve application performance.</span></span>  

### <a name="cqrs"></a><span data-ttu-id="6b4ba-209">CQRS</span><span class="sxs-lookup"><span data-stu-id="6b4ba-209">CQRS</span></span>

<span data-ttu-id="6b4ba-210">[CQRS](https://docs.microsoft.com/azure/architecture/patterns/cqrs)是一種架構模式，可協助最大化效能、擴充性和安全性。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-210">[CQRS](https://docs.microsoft.com/azure/architecture/patterns/cqrs), is an architectural pattern that can help maximize performance, scalability, and security.</span></span> <span data-ttu-id="6b4ba-211">此模式會分隔從寫入資料的作業讀取資料的作業。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-211">The pattern separates operations that read data from those operations that write data.</span></span>

<span data-ttu-id="6b4ba-212">在一般情況下 *，讀取和寫入作業都會使用*相同的實體模型和資料存放庫物件。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-212">For normal scenarios, the same entity model and data repository object are used for *both* read and write operations.</span></span>

<span data-ttu-id="6b4ba-213">不過，大量資料的案例可受益于個別的模型和資料表，以進行讀取和寫入。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-213">However, a high volume data scenario can benefit from separate models and data tables for reads and writes.</span></span> <span data-ttu-id="6b4ba-214">為了改善效能，讀取作業可以針對資料的高度反正規化標記法進行查詢，以避免昂貴的重複性資料表聯結和表鎖。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-214">To improve performance, the read operation could query against a highly denormalized representation of the data to avoid expensive repetitive table joins and table locks.</span></span> <span data-ttu-id="6b4ba-215">*寫入*作業（稱為*命令*）會針對會確保一致性的資料，以完全正規化的標記法來進行更新。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-215">The *write* operation, known as a *command*, would update against a fully normalized representation of the data that would guarantee consistency.</span></span> <span data-ttu-id="6b4ba-216">接著，您必須執行機制，讓這兩種標記法保持同步。一般來說，每當修改寫入資料表時，就會發行一個事件，將修改複寫到讀取資料表。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-216">You then need to implement a mechanism to keep both representations in sync. Typically, whenever the write table is modified, it publishes an event that replicates the modification to the read table.</span></span>

<span data-ttu-id="6b4ba-217">圖5-7 顯示 CQRS 模式的執行。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-217">Figure 5-7 shows an implementation of the CQRS pattern.</span></span>

![命令與查詢責任隔離](./media/cqrs-implementation.png)

<span data-ttu-id="6b4ba-219">**圖 5-7**。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-219">**Figure 5-7**.</span></span> <span data-ttu-id="6b4ba-220">CQRS 執行</span><span class="sxs-lookup"><span data-stu-id="6b4ba-220">CQRS implementation</span></span>

<span data-ttu-id="6b4ba-221">在上圖中，會執行個別的命令和查詢模型。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-221">In the previous figure, separate command and query models are implemented.</span></span> <span data-ttu-id="6b4ba-222">每個資料寫入作業都會儲存到寫入存放區，然後傳播到讀取存放區。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-222">Each data write operation is saved to the write store and then propagated to the read store.</span></span> <span data-ttu-id="6b4ba-223">請密切注意資料傳播程式如何在[最終一致性](https://www.cloudcomputingpatterns.org/eventual_consistency/)原則上運作。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-223">Pay close attention to how the data propagation process operates on the principle of [eventual consistency](https://www.cloudcomputingpatterns.org/eventual_consistency/).</span></span> <span data-ttu-id="6b4ba-224">讀取模型最後會與寫入模型進行同步處理，但進程中可能會有一些延遲。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-224">The read model eventually synchronizes with the write model, but there may be some lag in the process.</span></span> <span data-ttu-id="6b4ba-225">我們將在下一節中討論最終一致性。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-225">We discuss eventual consistency in the next section.</span></span>

<span data-ttu-id="6b4ba-226">這種區隔可讓讀取和寫入獨立進行調整。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-226">This separation enables reads and writes to scale independently.</span></span> <span data-ttu-id="6b4ba-227">讀取作業會使用針對查詢優化的架構，而寫入會使用針對更新優化的架構。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-227">Read operations use a schema optimized for queries, while the writes use a schema optimized for updates.</span></span> <span data-ttu-id="6b4ba-228">讀取查詢會針對不正規化的資料進行，而複雜的商務邏輯則可以套用至寫入模型。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-228">Read queries go against denormalized data, while complex business logic can be applied to the write model.</span></span> <span data-ttu-id="6b4ba-229">同樣地，您可能會對寫入作業施加更緊密的安全性，而不是公開讀取。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-229">As well, you might impose tighter security on write operations than those exposing reads.</span></span>

<span data-ttu-id="6b4ba-230">執行 CQRS 可以改善雲端原生服務的應用程式效能。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-230">Implementing CQRS can improve application performance for cloud-native services.</span></span> <span data-ttu-id="6b4ba-231">不過，它會產生更複雜的設計。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-231">However, it does result in a more complex design.</span></span> <span data-ttu-id="6b4ba-232">請仔細且策略性地將此原則套用至雲端原生應用程式的那些區段，以從中獲益。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-232">Apply this principle carefully and strategically to those sections of your cloud-native application that will benefit from it.</span></span> <span data-ttu-id="6b4ba-233">如需 CQRS 的詳細資訊，請參閱 Microsoft book [.Net 微服務：容器化 .Net 應用程式的架構](https://docs.microsoft.com/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/apply-simplified-microservice-cqrs-ddd-patterns)。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-233">For more on CQRS, see the Microsoft book [.NET Microservices: Architecture for Containerized .NET Applications](https://docs.microsoft.com/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/apply-simplified-microservice-cqrs-ddd-patterns).</span></span>

### <a name="event-sourcing"></a><span data-ttu-id="6b4ba-234">事件來源</span><span class="sxs-lookup"><span data-stu-id="6b4ba-234">Event sourcing</span></span>

<span data-ttu-id="6b4ba-235">優化大量資料案例的另一種方法牽涉到[事件來源](https://docs.microsoft.com/azure/architecture/patterns/event-sourcing)。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-235">Another approach to optimizing high volume data scenarios involves [Event Sourcing](https://docs.microsoft.com/azure/architecture/patterns/event-sourcing).</span></span>

<span data-ttu-id="6b4ba-236">系統通常會儲存資料實體的目前狀態。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-236">A system typically stores the current state of a data entity.</span></span> <span data-ttu-id="6b4ba-237">例如，如果使用者變更電話號碼，就會以新的號碼更新客戶記錄。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-237">If a user changes their phone number, for example, the customer record is updated with the new number.</span></span> <span data-ttu-id="6b4ba-238">我們一律知道資料實體的目前狀態，但每個更新都會覆寫先前的狀態。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-238">We always know the current state of a data entity, but each update overwrites the previous state.</span></span>

<span data-ttu-id="6b4ba-239">在大部分情況下，此模型會正常運作。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-239">In most cases, this model works fine.</span></span> <span data-ttu-id="6b4ba-240">不過，在大量系統中，交易式鎖定和頻繁更新作業的額外負荷可能會影響資料庫效能、回應能力和限制擴充性。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-240">In high volume systems, however, overhead from transactional locking and frequent update operations can impact database performance, responsiveness, and limit scalability.</span></span>

<span data-ttu-id="6b4ba-241">事件來源會採用不同的方法來捕獲資料。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-241">Event Sourcing takes a different approach to capturing data.</span></span> <span data-ttu-id="6b4ba-242">會影響資料的每項作業都會保存到事件存放區。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-242">Each operation that affects data is persisted to an event store.</span></span> <span data-ttu-id="6b4ba-243">我們不會更新資料記錄的狀態，而是將每個變更附加至過去事件的連續清單，類似于會計的總帳。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-243">Instead of updating the state of a data record, we append each change to a sequential list of past events - similar to an accountant's ledger.</span></span> <span data-ttu-id="6b4ba-244">事件存放區會成為資料的記錄系統。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-244">The Event Store becomes the system of record for the data.</span></span> <span data-ttu-id="6b4ba-245">它是用來在微服務的限定內容中傳播各種具體化的視圖。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-245">It's used to propagate various materialized views within the bounded context of a microservice.</span></span> <span data-ttu-id="6b4ba-246">圖5.8 顯示模式。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-246">Figure 5.8 shows the pattern.</span></span>

![事件來源](./media/event-sourcing.png)

<span data-ttu-id="6b4ba-248">**圖 5-8**。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-248">**Figure 5-8**.</span></span> <span data-ttu-id="6b4ba-249">事件來源</span><span class="sxs-lookup"><span data-stu-id="6b4ba-249">Event Sourcing</span></span>

<span data-ttu-id="6b4ba-250">在上圖中，請注意如何將使用者購物車的每個專案（藍色）附加至基礎事件存放區。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-250">In the previous figure, note how each entry (in blue) for a user's shopping cart is appended to an underlying event store.</span></span> <span data-ttu-id="6b4ba-251">在連續的具體化視圖中，系統會重新執行與每個購物車相關聯的所有事件，以投射目前的狀態。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-251">In the adjoining materialized view, the system projects the current state by replaying all the events associated with each shopping cart.</span></span> <span data-ttu-id="6b4ba-252">這個視圖或讀取模型接著會公開回到 UI。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-252">This view, or read model, is then exposed back to the UI.</span></span> <span data-ttu-id="6b4ba-253">事件也可以與外部系統和應用程式整合，或進行查詢以判斷實體的目前狀態。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-253">Events can also be integrated with external systems and applications or queried to determine the current state of an entity.</span></span> <span data-ttu-id="6b4ba-254">透過這種方法，您可以維護歷程記錄。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-254">With this approach, you maintain history.</span></span> <span data-ttu-id="6b4ba-255">您不僅可以得知實體的目前狀態，也知道如何達到此狀態。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-255">You know not only the current state of an entity, but also how you reached this state.</span></span>

<span data-ttu-id="6b4ba-256">就說，事件來源會簡化寫入模型。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-256">Mechanically speaking, event sourcing simplifies the write model.</span></span> <span data-ttu-id="6b4ba-257">沒有更新或刪除。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-257">There are no updates or deletes.</span></span> <span data-ttu-id="6b4ba-258">將每個資料項目附加為不可變事件會將與關係資料庫相關聯的爭用、鎖定和並行衝突降到最低。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-258">Appending each data entry as an immutable event minimizes contention, locking, and concurrency conflicts associated with relational databases.</span></span> <span data-ttu-id="6b4ba-259">使用具體化視圖模式建立讀取模型，可讓您將此視圖與寫入模型分離，並選擇最佳的資料存放區，以將應用程式 UI 的需求優化。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-259">Building read models with the materialized view pattern enables you to decouple the view from the write model and choose the best data store to optimize the needs of your application UI.</span></span>

<span data-ttu-id="6b4ba-260">在此模式中，請考慮直接支援事件來源的資料存放區。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-260">For this pattern, consider a data store that directly supports event sourcing.</span></span> <span data-ttu-id="6b4ba-261">Azure Cosmos DB、MongoDB、Cassandra、CouchDB 和 RavenDB 都是不錯的候選項目。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-261">Azure Cosmos DB, MongoDB, Cassandra, CouchDB, and RavenDB are good candidates.</span></span>

<span data-ttu-id="6b4ba-262">就像所有模式和技術一樣，在必要時進行策略性的實行。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-262">As with all patterns and technologies, implement strategically and when needed.</span></span> <span data-ttu-id="6b4ba-263">雖然事件來源可以提供更高的效能和擴充性，但代價是複雜性和學習曲線。</span><span class="sxs-lookup"><span data-stu-id="6b4ba-263">While event sourcing can provide increased performance and scalability, it comes at the expense of complexity and a learning curve.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="6b4ba-264">[上一個](service-mesh-communication-infrastructure.md) 
>[下一步](relational-vs-nosql-data.md)</span><span class="sxs-lookup"><span data-stu-id="6b4ba-264">[Previous](service-mesh-communication-infrastructure.md)
[Next](relational-vs-nosql-data.md)</span></span>
