---
title: 服務對服務通訊
description: 瞭解後端雲端原生微服務與其他後端微服務的通訊方式。
author: robvet
ms.date: 05/13/2020
ms.openlocfilehash: 88d7dfabee14419978889f5d9ea30b12f36837de
ms.sourcegitcommit: 27a15a55019f6b5f2733961738babe94aec0def3
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 09/15/2020
ms.locfileid: "90539799"
---
# <a name="service-to-service-communication"></a>服務對服務通訊

從前端用戶端移動時，我們現在會解決後端微服務彼此通訊的情形。

當您建立雲端原生應用程式時，您會想要對後端服務彼此通訊的方式有所敏感性。 在理想情況下，服務間通訊越少越好。 不過，因為後端服務通常會依賴另一個來完成作業，所以不一定可以避免使用。

有幾種廣泛接受的方法可以實現跨服務通訊。 *通訊互動的類型*通常會決定最佳的方法。

請考慮下列互動類型：

- *查詢* ：當呼叫微服務需要來自呼叫微服務的回應時，例如「嘿，請給我指定客戶識別碼的買方資訊」。

- *命令* –當呼叫微服務需要另一個微服務來執行動作，但不需要回應時（例如「嘿，只要寄出此訂單）。

- *事件* –當微服務（稱為「發行者」）引發狀態已變更或已發生動作的事件時。 其他感興趣的微服務（稱為「訂閱者」）可以適當地回應事件。 「發行者」和「訂閱者」都不知道彼此。

微服務系統通常會在執行需要跨服務互動的作業時，使用這些互動類型的組合。 讓我們仔細看看每個方法，以及您可能會如何實行。

## <a name="queries"></a>查詢

許多時候，一個微服務可能需要 *查詢* 另一個，需要立即回應才能完成作業。 購物籃微服務可能需要產品資訊，以及將專案新增至購物籃的價格。 有幾種方法可以執行查詢作業。

### <a name="requestresponse-messaging"></a>要求/回應傳訊

執行此案例的其中一個選項是針對呼叫後端微服務，對需要查詢的微服務提出直接的 HTTP 要求，如圖4-8 所示。

![直接 HTTP 通訊](./media/direct-http-communication.png)

**圖 4-8**。 直接 HTTP 通訊

雖然微服務之間的直接 HTTP 呼叫在執行時相當簡單，但應該小心將這種作法降至最低。 若要開始，這些呼叫一律為 *同步* ，並會封鎖作業，直到傳回結果或要求超時為止。 獨立且獨立的服務可以獨立進行或經常部署，現在會彼此結合。 隨著微服務增加，其架構優點也會降低。

對某些系統而言，執行對另一個微服務進行單一直接 HTTP 呼叫的罕見要求可能是可接受的。 但是，不建議對多個微服務叫用直接 HTTP 呼叫的大量呼叫。 它們可能會增加延遲，並對系統的效能、擴充性和可用性造成負面影響。 更糟的是，一長串的直接 HTTP 通訊可能會導致同步微服務呼叫的深層和複雜鏈，如圖4-9 所示：

![連結 HTTP 查詢](./media/chaining-http-queries.png)

**圖 4-9**。 連結 HTTP 查詢

您當然可以想像出設計上圖所示的風險。 如果步驟3失敗，會發生什麼事 \# ？ 或步驟 \# 8 失敗？ 如何復原？ 如果步驟 \# 6 很慢，因為基礎服務忙碌中？ 您要如何繼續？ 即使一切正常運作，但請考慮此呼叫會產生的延遲，也就是每個步驟的延遲總和。

上圖中的大量結合，建議服務無法以最佳模式進行模型化。 它會 behoove 小組來重新審視其設計。

### <a name="materialized-view-pattern"></a>具體化檢視模式

移除微服務結合的常用選項是 [具體化視圖模式](https://docs.microsoft.com/azure/architecture/patterns/materialized-view)。 使用這個模式時，微服務會儲存自己的本機反正規化資料複本，而這些資料是由其他服務所擁有。 除了購物籃微服務查詢產品類別目錄和定價微服務以外，它還會維護自己的本機資料複本。 此模式可消除不必要的結合，並改善可靠性和回應時間。 整個作業會在單一進程中執行。 我們會在第5章中探索此模式和其他資料考慮。

### <a name="service-aggregator-pattern"></a>服務匯總工具模式

消除微服務對微服務結合的另一個選項是匯總工具 [微服務](https://devblogs.microsoft.com/cesardelatorre/designing-and-implementing-api-gateways-with-ocelot-in-a-microservices-and-container-based-architecture/)，在圖4-10 中以紫色顯示。

![匯總工具服務](./media/aggregator-service.png)

**圖 4-10**： 匯總工具微服務

此模式會隔離呼叫多個後端微服務的作業，並將其邏輯集中至特製化的微服務。  上圖中的紫色結帳匯總工具微服務會協調簽出作業的工作流程。 它包含依順序排列的數個後端微服務呼叫。 工作流程中的資料會進行匯總，並傳回給呼叫端。 雖然它仍會執行直接 HTTP 呼叫，但匯總工具微服務可減少後端微服務之間的直接相依性。

### <a name="requestreply-pattern"></a>要求/回復模式

將同步 HTTP 訊息分離的另一種方法是使用佇列通訊的 [要求-回復模式](https://www.enterpriseintegrationpatterns.com/patterns/messaging/RequestReply.html)。 使用佇列的通訊一律是單向通道，其中生產者傳送訊息和取用者。 使用此模式時，會同時執行要求佇列和回應佇列，如圖4-11 所示。

![要求-回復模式](./media/request-reply-pattern.png)

**圖 4-11**： 要求-回復模式

在這裡，訊息產生者會建立包含唯一相互關聯識別碼的查詢型訊息，並將它放入要求佇列中。 取用服務會清除訊息、處理訊息，並將回應放入具有相同相互關聯識別碼的回應佇列。 生產者服務會清除訊息、與相互關聯識別碼進行比對，然後繼續處理。 在下一節中，我們將詳細討論佇列。

## <a name="commands"></a>命令

另一種類型的通訊互動是 *命令*。 微服務可能需要另一個微服務來執行動作。 訂購微服務可能需要運送微服務，才能建立核准訂單的出貨。 在圖4-12 中，一個稱為生產者的微服務會將訊息傳送給另一個微服務，也就是取用者，命令以進行某些動作。

![命令與佇列的互動](./media/command-interaction-with-queue.png)

**圖 4-12**. 命令與佇列的互動

最常見的情況是，生產者不需要回應，而且可能會 *引發* 訊息。 如果需要回復，取用者會在另一個通道上將個別訊息傳回給生產者。 命令訊息最好使用訊息佇列以非同步方式傳送。 由輕量訊息代理程式支援。 在上圖中，請注意佇列如何分隔和分隔這兩個服務。

訊息佇列是一種中繼結構，由生產者和取用者傳遞訊息。 佇列會執行非同步點對點訊息模式。 生產者知道需要適當傳送和路由傳送命令的位置。 佇列可保證訊息只由一個從通道讀取的取用者實例所處理。 在此案例中，生產者或取用者服務可以相應放大，而不會影響另一個。 同樣地，各方面的技術都可能不同，這表示我們可能會有 JAVA 微服務呼叫 [Golang](https://golang.org) 微服務。

在第1章中，我們討論了如何 *支援服務*。 備份服務是雲端原生系統所依存的輔助資源。 訊息佇列是支援服務。 Azure 雲端支援兩種類型的訊息佇列，您的雲端原生系統可使用這些佇列來執行命令訊息： Azure 儲存體佇列和 Azure 服務匯流排佇列。

### <a name="azure-storage-queues"></a>Azure 儲存體佇列

Azure 儲存體佇列提供簡單、經濟實惠且受 Azure 儲存體帳戶支援的簡單佇列基礎結構。

[Azure 儲存體佇列](https://docs.microsoft.com/azure/storage/queues/storage-queues-introduction) 是以 REST 為基礎的佇列機制，提供可靠且持續性的訊息。 它們提供基本的功能集，但價格低廉且儲存數百萬則訊息。 其容量範圍最高可達 500 TB。 單一訊息的大小最高可達 64 KB。

您可以使用 HTTP 或 HTTPS，透過經過驗證的呼叫來存取來自世界各地的訊息。 儲存體佇列可以擴充至大量的並行用戶端，以處理流量尖峰。

話雖如此，服務也有一些限制：

- 不保證訊息順序。

- 訊息在自動移除之前，只能保存七天。

- 無法支援狀態管理、重複偵測或交易。

圖4-13 顯示 Azure 儲存體佇列的階層。

![儲存體佇列階層](./media/storage-queue-hierarchy.png)

**圖 4-13**. 儲存體佇列階層

在上圖中，請注意儲存體佇列如何將其訊息儲存在基礎 Azure 儲存體帳戶中。

針對開發人員，Microsoft 提供數個用戶端和伺服器端程式庫來處理儲存體佇列。 支援大部分的主要平臺，包括 .NET、JAVA、JavaScript、Ruby、Python 和 Go。 開發人員永遠不應該直接與這些程式庫通訊。 這麼做會將您的微服務程式代碼緊密地結合到 Azure 儲存體佇列服務。 更好的作法是避免 API 的執行詳細資料。 引進 intermediation 層或中繼 API，其會公開一般作業並封裝具體的程式庫。 這個鬆散結合可讓您將一個佇列服務換成另一個，而不需要變更主線服務程式代碼。

Azure 儲存體佇列是在您的雲端原生應用程式中執行命令訊息的經濟實惠選項。 尤其是當佇列大小超過 80 GB，或可接受簡單的功能集時。 您只需支付訊息儲存的費用;沒有固定的每小時費用。

### <a name="azure-service-bus-queues"></a>Azure 服務匯流排佇列

如需更複雜的訊息需求，請考慮 Azure 服務匯流排佇列。

在穩固的訊息基礎結構上， [Azure 服務匯流排](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-messaging-overview) 支援代理 *訊息模型*。 訊息會可靠地儲存在訊息代理程式中， (佇列) 到取用者收到為止。 佇列可保證先進先出或先出 (FIFO) 訊息傳遞，遵守訊息新增至佇列的順序。

訊息的大小可能會大很多，最高可達 256 KB。 訊息會保留在佇列中一段無限制的時間。 服務匯流排不僅支援以 HTTP 為基礎的呼叫，還可提供 [AMQP 通訊協定](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-amqp-overview)的完整支援。 AMQP 是跨廠商提供的開放式標準，可支援二進位通訊協定和更高程度的可靠性。

服務匯流排提供一組豐富的功能，包括 [交易支援](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-transactions) 和 [重複的偵測功能](https://docs.microsoft.com/azure/service-bus-messaging/duplicate-detection)。 佇列可保證每則訊息「最多傳遞一次」。 它會自動捨棄已傳送的訊息。 如果生產者不確定，它可以重新傳送相同的訊息，而服務匯流排保證只會處理一個複本。 重複偵測可讓您不必建立額外的基礎結構配管。

另外還有兩個企業功能：資料分割和會話。 傳統的服務匯流排佇列是由單一訊息代理程式處理，並儲存在單一訊息存放區中。 但是， [服務匯流排資料分割](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-partitioning) 會將佇列分散到多個訊息代理程式和訊息存放區。 整體輸送量不會再受到單一訊息代理程式或訊息存放區的效能所限制。 訊息存放區暫時中斷時，不會轉譯資料分割佇列無法使用。

[服務匯流排會話](https://codingcanvas.com/azure-service-bus-sessions/) 可提供群組相關訊息的方式。 想像一種工作流程案例，其中的訊息必須一起處理，並在結束時完成操作。 若要充分利用，必須明確啟用佇列的會話，而且每個相關的 messaged 都必須包含相同的會話識別碼。

不過，有一些重要的注意事項：服務匯流排佇列大小限制為 80 GB，這遠小於存放區佇列中的可用空間。 此外，服務匯流排佇列會產生每個作業的基本成本和費用。

圖4-14 概述服務匯流排佇列的高階架構。

![服務匯流排佇列](./media/service-bus-queue.png)

**圖 4-14**. 服務匯流排佇列

在上圖中，請注意點對點關係。 相同提供者的兩個實例會將訊息佇列至單一服務匯流排佇列。 每則訊息只會由右邊的三個取用者實例的其中一個取用。 接下來，我們會討論如何執行訊息，讓不同的取用者都可能對相同的訊息感興趣。

## <a name="events"></a>事件

訊息佇列是一種有效的方法，可讓生產者以非同步方式傳送訊息給取用者。 不過，當 *有許多不同* 的取用者對相同的訊息有興趣時，會發生什麼事？ 每個取用者的專用訊息佇列無法妥善調整，而且會變得難以管理。

為了解決這種情況，我們將移至第三種類型的訊息互動，也就是 *活動*。 其中一個微服務宣佈已發生動作。 其他微服務，如果有興趣，請回應動作或事件。

事件是兩個步驟的程式。 針對指定的狀態變更，微服務會將事件發佈至訊息代理程式，使其可供任何其他感興趣的微服務使用。 有興趣的微服務會透過訂閱訊息代理程式中的事件來通知。 您可以使用 [發佈/訂閱](https://docs.microsoft.com/azure/architecture/patterns/publisher-subscriber) 模式來執行以 [事件為基礎的通訊](https://docs.microsoft.com/dotnet/standard/microservices-architecture/multi-container-microservice-net-applications/integration-event-based-microservice-communications)。

圖4-15 顯示購物籃微服務發佈事件與另外兩個微服務訂閱。

![事件驅動的訊息](./media/event-driven-messaging.png)

**圖 4-15**： 事件驅動的訊息

請注意位於通道中間的 *事件匯流排* 元件。 它是一個自訂類別，它會封裝訊息代理程式，並將它與基礎應用程式分離。 訂購和清查微服務會獨立操作事件，而不知道彼此，也不會有購物籃微服務。 當註冊的事件發佈至事件匯流排時，它們會在其上採取動作。

使用事件時，我們會從佇列技術移至 *主題*。 [主題](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions)與佇列類似，但支援一對多訊息模式。 其中一個微服務會發佈訊息。 多個訂閱微服務可以選擇接收和處理該訊息。 圖4-16 顯示主題架構。

![主題架構](./media/topic-architecture.png)

**圖 4-16**： 主題架構

在上圖中，發行者會將訊息傳送至主題。 最後，訂閱者會從訂用帳戶接收訊息。 在中間，此主題會根據一組規則將訊息轉送至訂用帳戶，顯示在深藍色方塊中。 規則會作為將特定訊息轉送至訂用帳戶的篩選準則。 在這裡，會將 "GetPrice" 事件傳送到價格和記錄訂閱，因為記錄訂閱已選擇接收所有訊息。  將會傳送 "GetInformation" 事件至資訊和記錄訂閱。

Azure 雲端支援兩種不同的主題服務： Azure 服務匯流排主題和 Azure EventGrid。

### <a name="azure-service-bus-topics"></a>Azure 服務匯流排主題

在 Azure 服務匯流排佇列的相同健全的代理訊息模型上， [Azure 服務匯流排主題](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions)。 主題可以接收來自多個獨立發行者的訊息，並將訊息傳送至最多2000的訂閱者。 您可以在執行時間動態新增或移除訂閱，而不需要停止系統或重新建立主題。

Azure 服務匯流排佇列的許多先進功能也可用於主題，包括 [重複的偵測](https://docs.microsoft.com/azure/service-bus-messaging/duplicate-detection) 和 [交易支援](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-transactions)。 根據預設，服務匯流排主題是由單一訊息代理程式處理，並儲存在單一訊息存放區中。 但是， [服務匯流排資料分割](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-partitioning) 會將某個主題分散到許多訊息代理程式和訊息存放區，以進行調整。

[排定的訊息傳遞](https://docs.microsoft.com/azure/service-bus-messaging/message-sequencing) 會標記具有特定時間來處理的訊息。 訊息在這段時間之前不會出現在主題中。 [訊息延遲](https://docs.microsoft.com/azure/service-bus-messaging/message-deferral) 可讓您延後將訊息抓取到較晚的時間。 兩者通常用於以特定連續處理作業的工作流程處理案例中。 您可以延後處理已接收的訊息，直到之前的工作完成為止。

服務匯流排主題是一種功能強大且經過證實的技術，可在您的雲端原生系統中啟用發佈/訂閱通訊。

### <a name="azure-event-grid"></a>Azure Event Grid

雖然 Azure 服務匯流排是經過大量測試的訊息代理程式，其中包含一組完整的企業功能，但 [Azure 事件方格](https://docs.microsoft.com/azure/event-grid/overview) 是此區塊的新小孩。

乍看之下，事件方格看起來可能就像是另一個以主題為基礎的訊息系統。 不過，它在許多方面都是不同的。 它著重于事件驅動的工作負載，可讓您在無伺服器基礎結構上進行即時事件處理、深層 Azure 整合和開放式平臺。 它是專為現代的雲端原生和無伺服器應用程式所設計

事件方格是 *集中式的事件後*擋板（或管道），可回應 Azure 資源內和您自己的服務中的事件。

事件通知會發佈到事件方格主題，然後將每個事件路由傳送至訂用帳戶。 訂閱者會對應至訂用帳戶並取用事件。 就像服務匯流排一樣，事件方格還支援 *篩選的訂閱者模型* ，其中訂用帳戶會為它想要接收的事件設定規則。 事件方格可提供快速的輸送量，並保證每秒10000000個事件，讓幾乎即時傳遞遠超過 Azure 服務匯流排可以產生的內容。

事件方格的最佳位置是其與 Azure 基礎結構網狀架構的深入整合。 Azure 資源（例如 Cosmos DB）可以將內建事件直接發佈到其他感興趣的 Azure 資源，而不需要自訂程式碼。 事件方格可以從 Azure 訂用帳戶、資源群組或服務發佈事件，讓開發人員可以更精細地控制雲端資源的生命週期。 不過，事件方格不限於 Azure。 它是一個開放式平臺，可以取用從應用程式或協力廠商服務發佈的自訂 HTTP 事件，並將事件路由傳送給外部訂閱者。

從 Azure 資源發佈和訂閱原生事件時，不需要撰寫程式碼。 透過簡單的設定，您可以將事件從一個 Azure 資源整合到另一個，利用主題和訂用帳戶的內建管道。 圖4-17 顯示事件方格的剖析。

![事件方格剖析](./media/event-grid-anatomy.png)

**圖 4-17**： 事件方格剖析

EventGrid 和服務匯流排之間的主要差異在於基礎 *訊息交換模式*。

服務匯流排會執行舊版的樣式 *提取模型* ，下游訂閱者會主動輪詢主題訂閱中的新訊息。 這種方法的優點是，訂閱者可以完全掌控它處理訊息的步調。 它會控制在任何指定時間處理多少訊息。 未讀取的訊息會保留在訂閱中，直到處理為止。 嚴重的缺點是產生事件的時間與將該訊息提取至訂閱者進行處理的輪詢作業之間的延遲。 此外，針對下一個事件進行持續輪詢的額外負荷會耗用資源和金錢。

但是 EventGrid 並不相同。 它會執行 *推播模型* ，在此模型中會將事件傳送至 EventHandlers （如已接收），提供近乎即時的事件傳遞。 它也可降低成本，因為服務只會在需要取用事件（而不是隨著輪詢）時觸發。 話雖如此，事件處理常式必須處理傳入的負載，並提供節流機制來防止本身變得更不知所措。 許多使用這些事件的 Azure 服務（例如 Azure Functions 和 Logic Apps）都會提供自動調整功能，以處理增加的負載。  

事件方格是完全受控的無伺服器雲端服務。 它會根據您的流量動態調整，並只針對實際使用量（而非預先購買的容量）收費。 每個月的前100000項作業都是免費的，也就是將作業定義為事件輸入 (內送事件通知) 、訂用帳戶傳遞嘗試、管理呼叫，以及依主旨進行篩選。 使用99.99% 的可用性，EventGrid 可保證在24小時期間內傳遞事件，內建的重試功能可提供不成功的傳遞。 無法傳遞的訊息可移至「寄不出的信件」佇列以供解析。  不同于 Azure 服務匯流排，事件方格會針對快速效能進行調整，且不支援排序的訊息、交易和會話等功能。

### <a name="streaming-messages-in-the-azure-cloud"></a>在 Azure 雲端中串流處理訊息

Azure 服務匯流排和 Event Grid 為公開單一、離散事件的應用程式提供絕佳的支援，例如已將新檔插入 Cosmos DB。 但是，如果您的雲端原生系統需要處理 *相關事件的資料流程*，該怎麼辦？ [事件資料流程](https://docs.microsoft.com/archive/msdn-magazine/2015/february/microsoft-azure-the-rise-of-event-stream-oriented-systems) 更為複雜。 它們通常是經過時間排序、相互關聯，而且必須以群組的方式處理。

[Azure 事件中樞](https://azure.microsoft.com/services/event-hubs/) 是一種資料串流平臺和事件內嵌服務，可收集、轉換和儲存事件。 它可以微調來捕捉串流資料，例如從遙測內容發出的連續事件通知。 這項服務可高度擴充，而且每秒可以儲存和 [處理數百萬個事件](https://docs.microsoft.com/azure/event-hubs/event-hubs-about)。 如圖4-18 所示，這通常是事件管線的大門，可將內嵌串流與事件耗用量分離。

![Azure 事件中樞](./media/azure-event-hub.png)

**圖 4-18**. Azure 事件中樞

事件中樞支援低延遲和可設定的保留時間。 不同于佇列和主題，事件中樞會在取用者讀取事件資料後保留事件資料。 這項功能可讓其他資料分析服務（內部和外部）重新執行資料，以供進一步分析。 只有在保留期限到期時，才會刪除儲存在事件中樞的事件（預設為一天，但可進行設定）。

事件中樞支援常見的事件發佈通訊協定，包括 HTTPS 和 AMQP。 它也支援 Kafka 1.0。 [現有的 Kafka 應用程式可以使用 Kafka 通訊協定與事件中樞通訊，](https://docs.microsoft.com/azure/event-hubs/event-hubs-for-kafka-ecosystem-overview) 提供管理大型 Kafka 叢集的替代方案。 許多開放原始碼的雲端原生系統都採用 Kafka。

事件中樞會透過資料分割取用 [者模型](https://docs.microsoft.com/azure/event-hubs/event-hubs-features) 來執行訊息串流，而每個取用者只會讀取訊息資料流程的特定子集或資料分割。 此模式支援大幅的水平擴充來處理事件，並提供佇列和主題所沒有的其他串流功能。 資料分割是經過排序且保存在事件中樞內的事件序列。 當較新的事件送達時，系統會將其新增至序列的結尾。圖4-19 顯示事件中樞內的資料分割。

![事件中樞資料分割](./media/event-hub-partitioning.png)

**圖 4-19**. 事件中樞資料分割

每個取用者群組會讀取訊息資料流程的子集或資料分割，而不是讀取相同的資源。

對於必須串流大量事件的雲端原生應用程式，Azure 事件中樞可以是穩固且經濟實惠的解決方案。

>[!div class="step-by-step"]
>[上一個](front-end-communication.md) 
>[下一步](grpc.md)
