---
title: 利用容器和協調器
description: 利用 Azure 中的 Docker 容器和 Kubernetes 協調器
ms.date: 05/31/2020
ms.openlocfilehash: 4d1dfa17fe9b4a683ab71ef2c9f97373579197af
ms.sourcegitcommit: 5b475c1855b32cf78d2d1bbb4295e4c236f39464
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 09/24/2020
ms.locfileid: "91155545"
---
# <a name="leveraging-containers-and-orchestrators"></a><span data-ttu-id="a4ea3-103">利用容器和協調器</span><span class="sxs-lookup"><span data-stu-id="a4ea3-103">Leveraging containers and orchestrators</span></span>

<span data-ttu-id="a4ea3-104">容器和協調器的設計目的是要解決整合型部署方法常見的問題。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-104">Containers and orchestrators are designed to solve problems common to monolithic deployment approaches.</span></span>

## <a name="challenges-with-monolithic-deployments"></a><span data-ttu-id="a4ea3-105">整合型部署的挑戰</span><span class="sxs-lookup"><span data-stu-id="a4ea3-105">Challenges with monolithic deployments</span></span>

<span data-ttu-id="a4ea3-106">傳統上，大部分的應用程式都已部署為單一單位。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-106">Traditionally, most applications have been deployed as a single unit.</span></span> <span data-ttu-id="a4ea3-107">這類應用程式稱為單體。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-107">Such applications are referred to as a monolith.</span></span> <span data-ttu-id="a4ea3-108">這是將應用程式部署為單一單位的一般方法，即使它們是由多個模組或元件所組成，如圖3-1 所示。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-108">This general approach of deploying applications as single units even if they're composed of multiple modules or assemblies is known as monolithic architecture, as shown in Figure 3-1.</span></span>

![整合型架構。](./media/monolithic-design.png)

<span data-ttu-id="a4ea3-110">**圖 3-1**。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-110">**Figure 3-1**.</span></span> <span data-ttu-id="a4ea3-111">整合型架構。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-111">Monolithic architecture.</span></span>

<span data-ttu-id="a4ea3-112">雖然它們具有簡單的優點，但整合型架構卻面臨一些挑戰：</span><span class="sxs-lookup"><span data-stu-id="a4ea3-112">Although they have the benefit of simplicity, monolithic architectures face a number of challenges:</span></span>

### <a name="deployment"></a><span data-ttu-id="a4ea3-113">部署</span><span class="sxs-lookup"><span data-stu-id="a4ea3-113">Deployment</span></span>

<span data-ttu-id="a4ea3-114">整合型應用程式需要整個應用程式的完整部署，即使只進行了少許變更。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-114">Monolithic applications require a full deployment of the entire application, even if only a small change has been made.</span></span> <span data-ttu-id="a4ea3-115">完整部署可能很昂貴，而且容易出錯。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-115">Full deployments can be expensive and error prone.</span></span> <span data-ttu-id="a4ea3-116">此外，它們需要重新開機應用程式，這會暫時影響無法使用的情況。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-116">Additionally, they require a restart of the application, which temporarily impacts unavailability.</span></span>

### <a name="scaling"></a><span data-ttu-id="a4ea3-117">調整大小</span><span class="sxs-lookup"><span data-stu-id="a4ea3-117">Scaling</span></span>

<span data-ttu-id="a4ea3-118">整合型應用程式完全裝載在單一電腦實例上，通常需要高功能硬體。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-118">A monolithic application is hosted entirely on a single machine instance, often requiring high-capability hardware.</span></span> <span data-ttu-id="a4ea3-119">如果單體的任何部分需要調整，則必須將整個應用程式的另一個複本部署到另一部電腦。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-119">If any part of the monolith requires scaling, another copy of the entire application must be deployed to another machine.</span></span> <span data-ttu-id="a4ea3-120">有了單體，您就無法個別調整應用程式元件，而是全部或無。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-120">With a monolith, you can't scale application components individually - it's all or nothing.</span></span> <span data-ttu-id="a4ea3-121">調整不需要調整的元件會導致效率不佳和成本高昂的資源使用量。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-121">Scaling components that don't require scaling results in inefficient and costly resource usage.</span></span>

### <a name="environment"></a><span data-ttu-id="a4ea3-122">環境</span><span class="sxs-lookup"><span data-stu-id="a4ea3-122">Environment</span></span>

<span data-ttu-id="a4ea3-123">整合型應用程式通常會部署到裝載環境，其中包含預先安裝的作業系統、執行時間和程式庫相依性。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-123">Monolithic applications are typically deployed to a hosting environment with a pre-installed operating system, runtime, and library dependencies.</span></span> <span data-ttu-id="a4ea3-124">此環境可能不符合開發或測試應用程式的環境。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-124">This environment may not match that upon which the application was developed or tested.</span></span> <span data-ttu-id="a4ea3-125">應用程式環境之間的不一致是整合型部署問題的常見來源。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-125">Inconsistencies across application environments are a common source of problems for monolithic deployments.</span></span>

### <a name="coupling"></a><span data-ttu-id="a4ea3-126">耦合</span><span class="sxs-lookup"><span data-stu-id="a4ea3-126">Coupling</span></span>

<span data-ttu-id="a4ea3-127">整合型應用程式可能會在其功能元件之間經歷高結合性。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-127">A monolithic application is likely to experience high coupling across its functional components.</span></span> <span data-ttu-id="a4ea3-128">如果沒有固定界限，系統變更通常會導致非預期且高成本的副作用。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-128">Without hard boundaries, system changes often result in unintended and costly side effects.</span></span> <span data-ttu-id="a4ea3-129">新功能/修正變得很難處理、耗時且昂貴。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-129">New features/fixes become tricky, time-consuming, and expensive to implement.</span></span> <span data-ttu-id="a4ea3-130">更新需要廣泛的測試。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-130">Updates require extensive testing.</span></span> <span data-ttu-id="a4ea3-131">結合也會讓您難以重構元件或在替代的執行中交換。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-131">Coupling also makes it difficult to refactor components or swap in alternative implementations.</span></span> <span data-ttu-id="a4ea3-132">即使是以嚴格的考慮分隔來建造，架構削弱還是會將 in 作為整合型程式碼基底降低，並使用永不結束的「特殊案例」。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-132">Even when constructed with a strict separation of concerns, architectural erosion sets in as the monolithic code base deteriorates with never-ending "special cases."</span></span>

### <a name="platform-lock-in"></a><span data-ttu-id="a4ea3-133">平臺鎖定</span><span class="sxs-lookup"><span data-stu-id="a4ea3-133">Platform lock-in</span></span>

<span data-ttu-id="a4ea3-134">整合型應用程式是以單一技術堆疊來建立。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-134">A monolithic application is constructed with a single technology stack.</span></span> <span data-ttu-id="a4ea3-135">雖然提供一致性，但這種承諾會成為創新的障礙。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-135">While offering uniformity, this commitment can become a barrier to innovation.</span></span> <span data-ttu-id="a4ea3-136">新的功能和元件將會使用應用程式的目前堆疊來建立，即使更多新式技術可能是更好的選擇。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-136">New features and components will be built using the application's current stack - even when more modern technologies may be a better choice.</span></span> <span data-ttu-id="a4ea3-137">長期的風險是您的技術堆疊變成過期和淘汰。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-137">A longer-term risk is your technology stack becoming outdated and obsolete.</span></span> <span data-ttu-id="a4ea3-138">將整個應用程式重新架構到全新、更新式的平臺，成本最高且有風險。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-138">Rearchitecting an entire application to a new, more modern platform is at best expensive and risky.</span></span>

## <a name="what-are-the-benefits-of-containers-and-orchestrators"></a><span data-ttu-id="a4ea3-139">容器和協調器的優點為何？</span><span class="sxs-lookup"><span data-stu-id="a4ea3-139">What are the benefits of containers and orchestrators?</span></span>

<span data-ttu-id="a4ea3-140">我們在第1章推出了容器。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-140">We introduced containers in Chapter 1.</span></span> <span data-ttu-id="a4ea3-141">我們強調了雲端原生運算基礎 (CNCF) 排名容器化如何成為其 [雲端原生線索對應](https://raw.githubusercontent.com/cncf/trailmap/master/CNCF_TrailMap_latest.png) 的第一步，也就是開始其雲端原生旅程的企業。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-141">We highlighted how the Cloud Native Computing Foundation (CNCF) ranks containerization as the first step in their [Cloud-Native Trail Map](https://raw.githubusercontent.com/cncf/trailmap/master/CNCF_TrailMap_latest.png) - guidance for enterprises beginning their cloud-native journey.</span></span> <span data-ttu-id="a4ea3-142">在本節中，我們會討論容器的優點。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-142">In this section, we discuss the benefits of containers.</span></span>

<span data-ttu-id="a4ea3-143">Docker 是最受歡迎的容器管理平臺。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-143">Docker is the most popular container management platform.</span></span> <span data-ttu-id="a4ea3-144">它適用于 Linux 或 Windows 上的容器。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-144">It works with containers on both Linux or Windows.</span></span> <span data-ttu-id="a4ea3-145">容器提供個別但可重現的應用程式環境，以相同的方式在任何系統上執行。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-145">Containers provide separate but reproducible application environments that run the same way on any system.</span></span> <span data-ttu-id="a4ea3-146">此層面讓它們非常適合用來開發和裝載雲端原生服務。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-146">This aspect makes them perfect for developing and hosting cloud-native services.</span></span> <span data-ttu-id="a4ea3-147">容器互相隔離。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-147">Containers are isolated from one another.</span></span> <span data-ttu-id="a4ea3-148">相同主機硬體上的兩個容器可以有不同版本的軟體，而不會造成衝突。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-148">Two containers on the same host hardware can have different versions of software, without causing conflicts.</span></span>

<span data-ttu-id="a4ea3-149">容器是由成為專案成品並簽入原始檔控制的簡單文字型檔案所定義。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-149">Containers are defined by simple text-based files that become project artifacts and are checked into source control.</span></span> <span data-ttu-id="a4ea3-150">雖然完整的伺服器和虛擬機器需要手動進行更新，但容器很容易受到版本控制。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-150">While full servers and virtual machines require manual effort to update, containers are easily version-controlled.</span></span> <span data-ttu-id="a4ea3-151">您可以使用自動化工具作為組建管線的一部分，來開發、測試和部署在容器中執行的應用程式。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-151">Apps built to run in containers can be developed, tested, and deployed using automated tools as part of a build pipeline.</span></span>

<span data-ttu-id="a4ea3-152">容器是不可變的。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-152">Containers are immutable.</span></span> <span data-ttu-id="a4ea3-153">定義容器之後，您可以用完全相同的方式重新建立並執行容器。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-153">Once you define a container, you can recreate and run it exactly the same way.</span></span> <span data-ttu-id="a4ea3-154">這種永久性也適合以元件為基礎的設計。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-154">This immutability lends itself to component-based design.</span></span> <span data-ttu-id="a4ea3-155">如果應用程式的某些部分與其他部分的發展方式不同，當您只部署最常變更的元件時，為什麼要重新部署整個應用程式？</span><span class="sxs-lookup"><span data-stu-id="a4ea3-155">If some parts of an application evolve differently than others, why redeploy the entire app when you can just deploy the parts that change most frequently?</span></span> <span data-ttu-id="a4ea3-156">應用程式的不同功能和跨領域考慮可以分成不同的單位。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-156">Different features and cross-cutting concerns of an app can be broken up into separate units.</span></span> <span data-ttu-id="a4ea3-157">圖3-2 顯示整合型應用程式如何藉由委派特定功能或功能來利用容器和微服務。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-157">Figure 3-2 shows how a monolithic app can take advantage of containers and microservices by delegating certain features or functionality.</span></span> <span data-ttu-id="a4ea3-158">應用程式本身的其餘功能也已經過容器化。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-158">The remaining functionality in the app itself has also been containerized.</span></span>

![將整合型應用程式分解成在後端使用微服務。](./media/cloud-native-design.png)

<span data-ttu-id="a4ea3-160">**圖 3-2**。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-160">**Figure 3-2**.</span></span> <span data-ttu-id="a4ea3-161">分解整合型應用程式以採用微服務。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-161">Decomposing a monolithic app to embrace microservices.</span></span>

<span data-ttu-id="a4ea3-162">每個雲端原生服務都是在個別的容器中建立和部署。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-162">Each cloud-native service is built and deployed in a separate container.</span></span> <span data-ttu-id="a4ea3-163">每個都可以視需要進行更新。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-163">Each can update as needed.</span></span> <span data-ttu-id="a4ea3-164">個別服務可以裝載在具有適用于每個服務之資源的節點上。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-164">Individual services can be hosted on nodes with resources appropriate to each service.</span></span> <span data-ttu-id="a4ea3-165">每個服務執行所在的環境都是不可變的，在開發、測試和生產環境之間共用，而且可以輕鬆地建立版本。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-165">The environment each service runs in is immutable, shared across dev, test, and production environments, and easily versioned.</span></span> <span data-ttu-id="a4ea3-166">應用程式不同區域之間的結合會明確地做為服務之間的呼叫或訊息，而不是單體內的編譯時間相依性。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-166">Coupling between different areas of the application occurs explicitly as calls or messages between services, not compile-time dependencies within the monolith.</span></span> <span data-ttu-id="a4ea3-167">您也可以選擇最適合指定功能的技術，而不需要變更應用程式的其餘部分。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-167">You can also choose the technology that best suites a given capability without requiring changes to the rest of the app.</span></span>

<span data-ttu-id="a4ea3-168">容器化服務需要自動化管理。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-168">Containerized services require automated management.</span></span> <span data-ttu-id="a4ea3-169">手動管理一組大量獨立部署的容器是不可行的。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-169">It wouldn't be feasible to manually administer a large set of independently deployed containers.</span></span> <span data-ttu-id="a4ea3-170">例如，請考慮下列工作：</span><span class="sxs-lookup"><span data-stu-id="a4ea3-170">For example, consider the following tasks:</span></span>

- <span data-ttu-id="a4ea3-171">如何在多部電腦的叢集中布建容器實例？</span><span class="sxs-lookup"><span data-stu-id="a4ea3-171">How will container instances be provisioned across a cluster of many machines?</span></span>
- <span data-ttu-id="a4ea3-172">一旦部署之後，容器會如何探索和彼此通訊？</span><span class="sxs-lookup"><span data-stu-id="a4ea3-172">Once deployed, how will containers discover and communicate with each other?</span></span>
- <span data-ttu-id="a4ea3-173">容器如何隨選相應放大或縮小？</span><span class="sxs-lookup"><span data-stu-id="a4ea3-173">How can containers scale in or out on-demand?</span></span>
- <span data-ttu-id="a4ea3-174">如何監視每個容器的健全狀況？</span><span class="sxs-lookup"><span data-stu-id="a4ea3-174">How do you monitor the health of each container?</span></span>
- <span data-ttu-id="a4ea3-175">如何保護容器以防止硬體和軟體失敗？</span><span class="sxs-lookup"><span data-stu-id="a4ea3-175">How do you protect a container against hardware and software failures?</span></span>
- <span data-ttu-id="a4ea3-176">如何升級即時應用程式的容器，而不會有停機時間？</span><span class="sxs-lookup"><span data-stu-id="a4ea3-176">How do upgrade containers for a live application with zero downtime?</span></span>

<span data-ttu-id="a4ea3-177">容器協調器會解決這些問題，並將其自動化。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-177">Container orchestrators address and automate these and other concerns.</span></span>

<span data-ttu-id="a4ea3-178">在雲端原生的生態系統中，Kubernetes 已成為實際的容器協調器。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-178">In the cloud-native eco-system, Kubernetes has become the de facto container orchestrator.</span></span> <span data-ttu-id="a4ea3-179">它是由雲端原生運算基礎管理的開放原始碼平臺 (CNCF) 。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-179">It's an open-source platform managed by the Cloud Native Computing Foundation (CNCF).</span></span> <span data-ttu-id="a4ea3-180">Kubernetes 可將容器化工作負載在電腦叢集中的部署、規模調整和操作考慮自動化。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-180">Kubernetes automates the deployment, scaling, and operational concerns of containerized workloads across a machine cluster.</span></span> <span data-ttu-id="a4ea3-181">但是，安裝和管理 Kubernetes 相當複雜。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-181">However, installing and managing Kubernetes is notoriously complex.</span></span>

<span data-ttu-id="a4ea3-182">更好的方法是使用 Kubernetes 作為雲端廠商的受控服務。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-182">A much better approach is to leverage Kubernetes as a managed service from a cloud vendor.</span></span> <span data-ttu-id="a4ea3-183">Azure 雲端具備 [Azure Kubernetes Service (AKS) ](https://azure.microsoft.com/services/kubernetes-service/)的完全受控 Kubernetes 平臺。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-183">The Azure cloud features a fully managed Kubernetes platform entitled [Azure Kubernetes Service (AKS)](https://azure.microsoft.com/services/kubernetes-service/).</span></span> <span data-ttu-id="a4ea3-184">AKS 可抽象化管理 Kubernetes 的複雜性和操作額外負荷。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-184">AKS abstracts the complexity and operational overhead of managing Kubernetes.</span></span> <span data-ttu-id="a4ea3-185">您可以使用 Kubernetes 作為雲端服務;Microsoft 負責管理和支援。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-185">You consume Kubernetes as a cloud service; Microsoft takes responsibility for managing and supporting it.</span></span> <span data-ttu-id="a4ea3-186">AKS 也會與其他 Azure 服務和開發工具緊密整合。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-186">AKS also tightly integrates with other Azure services and dev tools.</span></span>

<span data-ttu-id="a4ea3-187">AKS 是以叢集為基礎的技術。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-187">AKS is a cluster-based technology.</span></span> <span data-ttu-id="a4ea3-188">同盟虛擬機器或節點的集區會部署至 Azure 雲端。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-188">A pool of federated virtual machines, or nodes, is deployed to the Azure cloud.</span></span> <span data-ttu-id="a4ea3-189">它們會形成高可用性環境或叢集。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-189">Together they form a highly available environment, or cluster.</span></span> <span data-ttu-id="a4ea3-190">叢集會顯示為您雲端原生應用程式的無縫單一實體。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-190">The cluster appears as a seamless, single entity to your cloud-native application.</span></span> <span data-ttu-id="a4ea3-191">在幕後，AKS 會在這些節點上部署您的容器化服務，並遵循可平均分配負載的預先定義策略。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-191">Under the hood, AKS deploys your containerized services across these nodes following a predefined strategy that evenly distributes the load.</span></span>

## <a name="what-are-the-scaling-benefits"></a><span data-ttu-id="a4ea3-192">調整的優點為何？</span><span class="sxs-lookup"><span data-stu-id="a4ea3-192">What are the scaling benefits?</span></span>

<span data-ttu-id="a4ea3-193">以容器為基礎的服務可利用協調流程工具（例如 Kubernetes）所提供的調整優勢。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-193">Services built on containers can leverage scaling benefits provided by orchestration tools like Kubernetes.</span></span> <span data-ttu-id="a4ea3-194">設計容器只知道自己的身分。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-194">By design containers only know about themselves.</span></span> <span data-ttu-id="a4ea3-195">當您有多個需要一起運作的容器時，您應該將它們組織在較高層級。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-195">Once you have multiple containers that need to work together, you should organize them at a higher level.</span></span> <span data-ttu-id="a4ea3-196">組織大量的容器及其共用的相依性（例如網路設定），就是協調流程工具在每天儲存的地方！</span><span class="sxs-lookup"><span data-stu-id="a4ea3-196">Organizing large numbers of containers and their shared dependencies, such as network configuration, is where orchestration tools come in to save the day!</span></span> <span data-ttu-id="a4ea3-197">Kubernetes 會在容器群組之間建立抽象層，並將其 *組織成 pod*。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-197">Kubernetes creates an abstraction layer over groups of containers and organizes them into *pods*.</span></span> <span data-ttu-id="a4ea3-198">Pod 會在稱為 *節點*的背景工作電腦上執行。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-198">Pods run on worker machines referred to as *nodes*.</span></span> <span data-ttu-id="a4ea3-199">此組織結構稱為「叢集」（ *cluster*）。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-199">This organized structure is referred to as a *cluster*.</span></span> <span data-ttu-id="a4ea3-200">圖3-3 顯示 Kubernetes 群集的不同元件。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-200">Figure 3-3 shows the different components of a Kubernetes cluster.</span></span>

<span data-ttu-id="a4ea3-201">![Kubernetes 叢集元件。 ](./media/kubernetes-cluster-components.png)
**圖 3-3**。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-201">![Kubernetes cluster components.](./media/kubernetes-cluster-components.png)
**Figure 3-3**.</span></span> <span data-ttu-id="a4ea3-202">Kubernetes 叢集元件。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-202">Kubernetes cluster components.</span></span>

<span data-ttu-id="a4ea3-203">調整容器化工作負載是容器協調器的重要功能。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-203">Scaling containerized workloads is a key feature of container orchestrators.</span></span> <span data-ttu-id="a4ea3-204">AKS 支援在兩個維度之間進行自動調整：容器實例和計算節點。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-204">AKS supports automatic scaling across two dimensions: Container instances and compute nodes.</span></span> <span data-ttu-id="a4ea3-205">它們一起讓 AKS 能夠快速且有效率地回應尖峰需求，並新增其他資源。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-205">Together they give AKS the ability to quickly and efficiently respond to spikes in demand and add additional resources.</span></span> <span data-ttu-id="a4ea3-206">我們將在本章稍後討論調整 AKS。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-206">We discuss scaling in AKS later in this chapter.</span></span>

### <a name="declarative-versus-imperative"></a><span data-ttu-id="a4ea3-207">宣告式和命令式</span><span class="sxs-lookup"><span data-stu-id="a4ea3-207">Declarative versus imperative</span></span>

<span data-ttu-id="a4ea3-208">Kubernetes 同時支援宣告式和命令式設定。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-208">Kubernetes supports both declarative and imperative configuration.</span></span> <span data-ttu-id="a4ea3-209">命令式方法牽涉到執行各種命令，告訴 Kubernetes 該怎麼做的每個步驟。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-209">The imperative approach involves running various commands that tell Kubernetes what to do each step of the way.</span></span> <span data-ttu-id="a4ea3-210">執行此映射。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-210">Run this image.</span></span> <span data-ttu-id="a4ea3-211">刪除此 pod。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-211">Delete this pod.</span></span> <span data-ttu-id="a4ea3-212">公開此埠。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-212">Expose this port.</span></span> <span data-ttu-id="a4ea3-213">使用宣告式方法時，您會建立稱為資訊清單的設定檔，以描述您想要的內容，而不是要做什麼。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-213">With the declarative approach, you create a configuration file, called a manifest, to describe what you want instead of what to do.</span></span> <span data-ttu-id="a4ea3-214">Kubernetes 會讀取資訊清單，並將您想要的結束狀態轉換成實際的結束狀態。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-214">Kubernetes reads the manifest and transforms your desired end state into actual end state.</span></span>

<span data-ttu-id="a4ea3-215">命令式命令很適合用於學習和互動式實驗。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-215">Imperative commands are great for learning and interactive experimentation.</span></span> <span data-ttu-id="a4ea3-216">不過，您會想要以宣告方式建立 Kubernetes 資訊清單檔，以採用基礎結構即程式碼方法，提供可靠且可重複的部署。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-216">However, you'll want to declaratively create Kubernetes manifest files to embrace an infrastructure as code approach, providing for reliable and repeatable deployments.</span></span> <span data-ttu-id="a4ea3-217">資訊清單檔案會變成專案成品，並用於您的 CI/CD 管線，以自動化 Kubernetes 部署。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-217">The manifest file becomes a project artifact and is used in your CI/CD pipeline for automating Kubernetes deployments.</span></span>

<span data-ttu-id="a4ea3-218">如果您已經使用命令式命令設定您的叢集，您可以使用匯出宣告式資訊清單 `kubectl get svc SERVICENAME -o yaml > service.yaml` 。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-218">If you've already configured your cluster using imperative commands, you can export a declarative manifest by using `kubectl get svc SERVICENAME -o yaml > service.yaml`.</span></span> <span data-ttu-id="a4ea3-219">此命令會產生類似下面所示的資訊清單：</span><span class="sxs-lookup"><span data-stu-id="a4ea3-219">This command produces a manifest similar to one shown below:</span></span>

```yaml
apiVersion: v1
kind: Service
metadata:
  creationTimestamp: "2019-09-13T13:58:47Z"
  labels:
    component: apiserver
    provider: kubernetes
  name: kubernetes
  namespace: default
  resourceVersion: "153"
  selfLink: /api/v1/namespaces/default/services/kubernetes
  uid: 9b1fac62-d62e-11e9-8968-00155d38010d
spec:
  clusterIP: 10.96.0.1
  ports:
  - name: https
    port: 443
    protocol: TCP
    targetPort: 6443
  sessionAffinity: None
  type: ClusterIP
status:
  loadBalancer: {}
```

<span data-ttu-id="a4ea3-220">使用宣告式設定時，您可以 `kubectl diff -f FOLDERNAME` 針對設定檔所在的資料夾使用，在認可之前，先預覽將進行的變更。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-220">When using declarative configuration, you can preview the changes that will be made before committing them by using `kubectl diff -f FOLDERNAME` against the folder where your configuration files are located.</span></span> <span data-ttu-id="a4ea3-221">一旦您確定要套用變更，請執行 `kubectl apply -f FOLDERNAME` 。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-221">Once you're sure you want to apply the changes, run `kubectl apply -f FOLDERNAME`.</span></span> <span data-ttu-id="a4ea3-222">加入 `-R` 以遞迴方式處理資料夾階層。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-222">Add `-R` to recursively process a folder hierarchy.</span></span>

<span data-ttu-id="a4ea3-223">您也可以使用宣告式設定搭配其他 Kubernetes 功能，也就是部署的其中一個。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-223">You can also use declarative configuration with other Kubernetes features, one of which being deployments.</span></span> <span data-ttu-id="a4ea3-224">宣告式部署有助於管理版本、更新和調整。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-224">Declarative deployments help manage releases, updates, and scaling.</span></span> <span data-ttu-id="a4ea3-225">他們會指示 Kubernetes 部署控制器如何部署新的變更、向外延展負載，或回復為先前的修訂。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-225">They instruct the Kubernetes deployment controller on how to deploy new changes, scale out load, or roll back to a previous revision.</span></span> <span data-ttu-id="a4ea3-226">如果叢集不穩定，宣告式部署會自動將叢集傳回所需的狀態。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-226">If a cluster is unstable, a declarative deployment will automatically return the cluster back to a desired state.</span></span> <span data-ttu-id="a4ea3-227">例如，如果節點應損毀，部署機制將會重新部署取代以達成您所要的狀態</span><span class="sxs-lookup"><span data-stu-id="a4ea3-227">For example, if a node should crash, the deployment mechanism will redeploy a replacement to achieve your desired state</span></span>

<span data-ttu-id="a4ea3-228">使用宣告式設定可讓基礎結構以程式碼的形式來表示，該程式碼可與應用程式程式碼一起簽入和建立版本。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-228">Using declarative configuration allows infrastructure to be represented as code that can be checked in and versioned alongside the application code.</span></span> <span data-ttu-id="a4ea3-229">它針對使用組建和部署管線的持續部署提供改良的變更控制及更好的支援。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-229">It provides improved change control and better support for continuous deployment using a build and deploy pipeline.</span></span>

## <a name="what-scenarios-are-ideal-for-containers-and-orchestrators"></a><span data-ttu-id="a4ea3-230">哪些案例適用于容器和協調器？</span><span class="sxs-lookup"><span data-stu-id="a4ea3-230">What scenarios are ideal for containers and orchestrators?</span></span>

<span data-ttu-id="a4ea3-231">下列案例適用于使用容器和協調器。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-231">The following scenarios are ideal for using containers and orchestrators.</span></span>

### <a name="applications-requiring-high-uptime-and-scalability"></a><span data-ttu-id="a4ea3-232">需要高執行時間和擴充性的應用程式</span><span class="sxs-lookup"><span data-stu-id="a4ea3-232">Applications requiring high uptime and scalability</span></span>

<span data-ttu-id="a4ea3-233">具有高執行時間和擴充性需求的個別應用程式，是使用微服務、容器和協調器的雲端原生架構的絕佳候選項目。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-233">Individual applications that have high uptime and scalability requirements are ideal candidates for cloud-native architectures using microservices, containers, and orchestrators.</span></span> <span data-ttu-id="a4ea3-234">它們可以在容器中開發、在已建立版本的環境中進行測試，並部署到生產環境中，而不需要停機。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-234">They can be developed in containers, tested across versioned environments, and deployed into production with zero downtime.</span></span> <span data-ttu-id="a4ea3-235">使用 Kubernetes 叢集可確保這類應用程式也可以視需要進行調整，並自動從節點失敗中復原。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-235">The use of Kubernetes clusters ensures such apps can also scale on demand and recover automatically from node failures.</span></span>

### <a name="large-numbers-of-applications"></a><span data-ttu-id="a4ea3-236">大量的應用程式</span><span class="sxs-lookup"><span data-stu-id="a4ea3-236">Large numbers of applications</span></span>

<span data-ttu-id="a4ea3-237">部署和維護大量應用程式的組織可從容器和協調器獲益。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-237">Organizations that deploy and maintain large numbers of applications benefit from containers and orchestrators.</span></span> <span data-ttu-id="a4ea3-238">設定容器化環境和 Kubernetes 叢集的前一項工作，主要是固定成本。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-238">The up front effort of setting up containerized environments and Kubernetes clusters is primarily a fixed cost.</span></span> <span data-ttu-id="a4ea3-239">部署、維護和更新個別應用程式的成本會隨著應用程式數目而異。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-239">Deploying, maintaining, and updating individual applications has a cost that varies with the number of applications.</span></span> <span data-ttu-id="a4ea3-240">除了少數的應用程式之外，手動維護自訂應用程式的複雜度會超過使用容器和協調器來執行解決方案的成本。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-240">Beyond a small number of applications, the complexity of maintaining custom applications manually exceeds the cost of implementing a solution using containers and orchestrators.</span></span>

## <a name="when-should-you-avoid-using-containers-and-orchestrators"></a><span data-ttu-id="a4ea3-241">您應該避免使用容器和協調器？</span><span class="sxs-lookup"><span data-stu-id="a4ea3-241">When should you avoid using containers and orchestrators?</span></span>

<span data-ttu-id="a4ea3-242">如果您無法依照12要素應用程式原則來建立應用程式，您應該考慮避免容器和協調器。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-242">If you're unable to build your application following the Twelve-Factor App principles, you should consider avoiding containers and orchestrators.</span></span> <span data-ttu-id="a4ea3-243">在這些情況下，請考慮以 VM 為基礎的裝載平臺，或可能的混合式系統。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-243">In these cases, consider a VM-based hosting platform, or possibly some hybrid system.</span></span> <span data-ttu-id="a4ea3-244">有了這項功能，您就可以隨時將某些功能關閉到個別的容器或甚至無伺服器功能。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-244">With it, you can always spin off certain pieces of functionality into separate containers or even serverless functions.</span></span>

## <a name="development-resources"></a><span data-ttu-id="a4ea3-245">開發資源</span><span class="sxs-lookup"><span data-stu-id="a4ea3-245">Development resources</span></span>

<span data-ttu-id="a4ea3-246">本節說明可協助您開始針對下一個應用程式使用容器和協調器的開發資源的簡短清單。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-246">This section shows a short list of development resources that may help you get started using containers and orchestrators for your next application.</span></span> <span data-ttu-id="a4ea3-247">如果您要尋找有關如何設計您的雲端原生微服務架構應用程式的指引，請閱讀這本書隨附的 [.Net 微服務：容器化 .Net 應用程式的架構](https://dotnet.microsoft.com/download/thank-you/microservices-architecture-ebook)。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-247">If you're looking for guidance on how to design your cloud-native microservices architecture app, read this book's companion, [.NET Microservices: Architecture for Containerized .NET Applications](https://dotnet.microsoft.com/download/thank-you/microservices-architecture-ebook).</span></span>

### <a name="local-kubernetes-development"></a><span data-ttu-id="a4ea3-248">本機 Kubernetes 開發</span><span class="sxs-lookup"><span data-stu-id="a4ea3-248">Local Kubernetes Development</span></span>

<span data-ttu-id="a4ea3-249">Kubernetes 部署在生產環境中提供絕佳的價值，但也可以在您的開發機器本機上執行。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-249">Kubernetes deployments provide great value in production environments, but can also run locally on your development machine.</span></span> <span data-ttu-id="a4ea3-250">雖然您可以獨立處理個別的微服務，但有時您可能需要在本機執行整個系統，就像是在部署到生產環境時執行一樣。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-250">While you may work on individual microservices independently, there may be times when you'll need to run the entire system locally - just as it will run when deployed to production.</span></span> <span data-ttu-id="a4ea3-251">有幾個工具可協助： Minikube 和 Docker Desktop。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-251">There are several tools that can help: Minikube and Docker Desktop.</span></span> <span data-ttu-id="a4ea3-252">Visual Studio 也提供 Docker 開發的工具。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-252">Visual Studio also provides tooling for Docker development.</span></span>

### <a name="minikube"></a><span data-ttu-id="a4ea3-253">Minikube</span><span class="sxs-lookup"><span data-stu-id="a4ea3-253">Minikube</span></span>

<span data-ttu-id="a4ea3-254">什麼是 Minikube？</span><span class="sxs-lookup"><span data-stu-id="a4ea3-254">What is Minikube?</span></span> <span data-ttu-id="a4ea3-255">Minikube 專案會顯示「Minikube 在 macOS、Linux 和 Windows 上實行本機 Kubernetes 叢集」。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-255">The Minikube project says "Minikube implements a local Kubernetes cluster on macOS, Linux, and Windows."</span></span> <span data-ttu-id="a4ea3-256">其主要目標是「最適合用來進行本機 Kubernetes 應用程式開發的工具，並支援所有符合的 Kubernetes 功能」。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-256">Its primary goals are "to be the best tool for local Kubernetes application development and to support all Kubernetes features that fit."</span></span> <span data-ttu-id="a4ea3-257">安裝 Minikube 與 Docker 不同，但 Minikube 支援的虛擬器與 Docker Desktop 所支援的不同。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-257">Installing Minikube is separate from Docker, but Minikube supports different hypervisors than Docker Desktop supports.</span></span> <span data-ttu-id="a4ea3-258">Minikube 目前支援下列 Kubernetes 功能：</span><span class="sxs-lookup"><span data-stu-id="a4ea3-258">The following Kubernetes features are currently supported by Minikube:</span></span>

- <span data-ttu-id="a4ea3-259">DNS</span><span class="sxs-lookup"><span data-stu-id="a4ea3-259">DNS</span></span>
- <span data-ttu-id="a4ea3-260">NodePorts</span><span class="sxs-lookup"><span data-stu-id="a4ea3-260">NodePorts</span></span>
- <span data-ttu-id="a4ea3-261">ConfigMaps 和秘密</span><span class="sxs-lookup"><span data-stu-id="a4ea3-261">ConfigMaps and secrets</span></span>
- <span data-ttu-id="a4ea3-262">儀表板</span><span class="sxs-lookup"><span data-stu-id="a4ea3-262">Dashboards</span></span>
- <span data-ttu-id="a4ea3-263">容器執行時間： Docker、>rkt、CRI-O 和 containerd</span><span class="sxs-lookup"><span data-stu-id="a4ea3-263">Container runtimes: Docker, rkt, CRI-O, and containerd</span></span>
- <span data-ttu-id="a4ea3-264"> (CNI) 啟用容器網路介面</span><span class="sxs-lookup"><span data-stu-id="a4ea3-264">Enabling Container Network Interface (CNI)</span></span>
- <span data-ttu-id="a4ea3-265">輸入</span><span class="sxs-lookup"><span data-stu-id="a4ea3-265">Ingress</span></span>

<span data-ttu-id="a4ea3-266">安裝 Minikube 之後，您可以藉由執行命令來快速開始使用 `minikube start` ，此命令會下載映射並啟動本機 Kubernetes 叢集。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-266">After installing Minikube, you can quickly start using it by running the `minikube start` command, which downloads an image and start the local Kubernetes cluster.</span></span> <span data-ttu-id="a4ea3-267">啟動叢集之後，您可以使用標準 Kubernetes 命令與其互動 `kubectl` 。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-267">Once the cluster is started, you interact with it using the standard Kubernetes `kubectl` commands.</span></span>

### <a name="docker-desktop"></a><span data-ttu-id="a4ea3-268">Docker Desktop</span><span class="sxs-lookup"><span data-stu-id="a4ea3-268">Docker Desktop</span></span>

<span data-ttu-id="a4ea3-269">您也可以直接從 Windows 上的 Docker Desktop 使用 Kubernetes。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-269">You can also work with Kubernetes directly from Docker Desktop on Windows.</span></span> <span data-ttu-id="a4ea3-270">如果您是使用 Windows 容器，這是您唯一的選項，而且也是非 Windows 容器的絕佳選擇。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-270">It is your only option if you're using Windows Containers, and is a great choice for non-Windows containers as well.</span></span> <span data-ttu-id="a4ea3-271">圖3-4 顯示如何在執行 Docker Desktop 時啟用本機 Kubernetes 支援。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-271">Figure 3-4 shows how to enable local Kubernetes support when running Docker Desktop.</span></span>

![在 Docker Desktop 中設定 Kubernetes](./media/docker-desktop-kubernetes.png)

<span data-ttu-id="a4ea3-273">**圖 3-4**。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-273">**Figure 3-4**.</span></span> <span data-ttu-id="a4ea3-274">在 Docker Desktop 中設定 Kubernetes。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-274">Configuring Kubernetes in Docker Desktop.</span></span>

<span data-ttu-id="a4ea3-275">Docker Desktop 是最受歡迎的工具，可在本機設定和執行容器化應用程式。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-275">Docker Desktop is the most popular tool for configuring and running containerized apps locally.</span></span> <span data-ttu-id="a4ea3-276">當您使用 Docker Desktop 時，您可以在本機針對您將部署到生產環境的相同 Docker 容器映射集進行本機開發。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-276">When you work with Docker Desktop, you can develop locally against the exact same set of Docker container images that you'll deploy to production.</span></span> <span data-ttu-id="a4ea3-277">Docker Desktop 的設計目的是在本機「建立、測試和傳送」容器化應用程式。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-277">Docker Desktop is designed to "build, test, and ship" containerized apps locally.</span></span> <span data-ttu-id="a4ea3-278">它同時支援 Linux 和 Windows 容器。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-278">It supports both Linux and Windows containers.</span></span> <span data-ttu-id="a4ea3-279">將映射推送至映射登錄（例如 Azure Container Registry 或 Docker Hub）後，AKS 可以將其提取並部署到生產環境。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-279">Once you push your images to an image registry, like Azure Container Registry or Docker Hub, AKS can pull and deploy them to production.</span></span>

### <a name="visual-studio-docker-tooling"></a><span data-ttu-id="a4ea3-280">Visual Studio Docker 工具</span><span class="sxs-lookup"><span data-stu-id="a4ea3-280">Visual Studio Docker Tooling</span></span>

<span data-ttu-id="a4ea3-281">Visual Studio 支援 web 應用程式的 Docker 開發。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-281">Visual Studio supports Docker development for web-based applications.</span></span> <span data-ttu-id="a4ea3-282">當您建立新的 ASP.NET Core 應用程式時，您可以選擇使用 Docker 支援進行設定，如 [圖 3-5] 所示。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-282">When you create a new ASP.NET Core application, you have an option to configure it with Docker support, as shown in Figure 3-5.</span></span>

![Visual Studio 啟用 Docker 支援](./media/visual-studio-enable-docker-support.png)

<span data-ttu-id="a4ea3-284">**圖 3-5**。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-284">**Figure 3-5**.</span></span> <span data-ttu-id="a4ea3-285">Visual Studio 啟用 Docker 支援</span><span class="sxs-lookup"><span data-stu-id="a4ea3-285">Visual Studio Enable Docker Support</span></span>

<span data-ttu-id="a4ea3-286">選取此選項時，會 `Dockerfile` 在其根目錄中建立專案，此專案可以用來在 Docker 容器中建立和裝載應用程式。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-286">When this option is selected, the project is created with a `Dockerfile` in its root, which can be used to build and host the app in a Docker container.</span></span> <span data-ttu-id="a4ea3-287">圖 3-6 中顯示的範例 Dockerfile</span><span class="sxs-lookup"><span data-stu-id="a4ea3-287">An example Dockerfile is shown in Figure 3-6.git</span></span>

```dockerfile
FROM mcr.microsoft.com/dotnet/core/aspnet:3.1-buster-slim AS base
WORKDIR /app
EXPOSE 80
EXPOSE 443

FROM mcr.microsoft.com/dotnet/core/sdk:3.1-buster AS build
WORKDIR /src
COPY ["eShopWeb/eShopWeb.csproj", "eShopWeb/"]
RUN dotnet restore "eShopWeb/eShopWeb.csproj"
COPY . .
WORKDIR "/src/eShopWeb"
RUN dotnet build "eShopWeb.csproj" -c Release -o /app/build

FROM build AS publish
RUN dotnet publish "eShopWeb.csproj" -c Release -o /app/publish

FROM base AS final
WORKDIR /app
COPY --from=publish /app/publish .
ENTRYPOINT ["dotnet", "eShopWeb.dll"]
```

<span data-ttu-id="a4ea3-288">**圖 3-6**。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-288">**Figure 3-6**.</span></span> <span data-ttu-id="a4ea3-289">Visual Studio 產生的 Dockerfile</span><span class="sxs-lookup"><span data-stu-id="a4ea3-289">Visual Studio generated Dockerfile</span></span>

<span data-ttu-id="a4ea3-290">當應用程式執行時，預設行為也會設定為使用 Docker。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-290">The default behavior when the app runs is configured to use Docker as well.</span></span> <span data-ttu-id="a4ea3-291">[圖 3-7] 顯示新的 ASP.NET Core 專案中可用的不同回合選項，這些選項是在已新增 Docker 支援的情況中建立</span><span class="sxs-lookup"><span data-stu-id="a4ea3-291">Figure 3-7 shows the different run options available from a new ASP.NET Core project created with Docker support added.</span></span>

![Visual Studio Docker 執行選項](./media/visual-studio-docker-run-options.png)

<span data-ttu-id="a4ea3-293">**圖 3-7**。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-293">**Figure 3-7**.</span></span> <span data-ttu-id="a4ea3-294">Visual Studio Docker 執行選項</span><span class="sxs-lookup"><span data-stu-id="a4ea3-294">Visual Studio Docker Run Options</span></span>

<span data-ttu-id="a4ea3-295">除了本機開發之外， [Azure Dev Spaces](/azure/dev-spaces/) 也提供便利的方法，讓多個開發人員在 Azure 中使用自己的 Kubernetes 設定。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-295">In addition to local development, [Azure Dev Spaces](/azure/dev-spaces/) provides a convenient way for multiple developers to work with their own Kubernetes configurations within Azure.</span></span> <span data-ttu-id="a4ea3-296">如圖3-7 中所示，您也可以在 Azure Dev Spaces 中執行應用程式。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-296">As you can see in Figure 3-7, you can also run the application in Azure Dev Spaces.</span></span>

<span data-ttu-id="a4ea3-297">此外，您隨時都可以將 Docker 支援新增至現有的 ASP.NET Core 應用程式。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-297">Also, at any time you can add Docker support to an existing ASP.NET Core application.</span></span> <span data-ttu-id="a4ea3-298">在 [Visual Studio] 方案總管中，以滑鼠右鍵按一下專案並**新增**  >  **Docker 支援**，如圖3-8 所示。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-298">From the Visual Studio Solution Explorer, right click on the project and **Add** > **Docker Support**, as shown in Figure 3-8.</span></span>

![Visual Studio 新增 Docker 支援](./media/visual-studio-add-docker-support.png)

<span data-ttu-id="a4ea3-300">**圖 3-8**。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-300">**Figure 3-8**.</span></span> <span data-ttu-id="a4ea3-301">將 Docker 支援新增至 Visual Studio</span><span class="sxs-lookup"><span data-stu-id="a4ea3-301">Adding Docker support to Visual Studio</span></span>

<span data-ttu-id="a4ea3-302">您也可以新增容器協調流程支援，也會顯示在圖3-8 中。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-302">You can also add Container Orchestration Support, also shown in Figure 3-8.</span></span> <span data-ttu-id="a4ea3-303">根據預設，orchestrator 會使用 Kubernetes 和 Helm。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-303">By default, the orchestrator uses Kubernetes and Helm.</span></span> <span data-ttu-id="a4ea3-304">選擇協調器之後，會將檔案 `azds.yaml` 新增至專案根目錄，並 `charts` 新增包含用來設定和部署應用程式至 Kubernetes 之 Helm 圖表的資料夾。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-304">Once you've chosen the orchestrator, a `azds.yaml` file is added to the project root and a `charts` folder is added containing the Helm charts used to configure and deploy the application to Kubernetes.</span></span> <span data-ttu-id="a4ea3-305">圖3-9 顯示新專案中產生的檔案。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-305">Figure 3-9 shows the resulting files in a new project.</span></span>

![Visual Studio 新增協調器支援](./media/visual-studio-add-orchestrator-support.png)

<span data-ttu-id="a4ea3-307">**圖 3-9**。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-307">**Figure 3-9**.</span></span> <span data-ttu-id="a4ea3-308">將協調流程支援新增至 Visual Studio</span><span class="sxs-lookup"><span data-stu-id="a4ea3-308">Adding orchestration support to Visual Studio</span></span>

### <a name="visual-studio-code-docker-tooling"></a><span data-ttu-id="a4ea3-309">Visual Studio Code Docker 工具</span><span class="sxs-lookup"><span data-stu-id="a4ea3-309">Visual Studio Code Docker Tooling</span></span>

<span data-ttu-id="a4ea3-310">有一些延伸模組可用於支援 Docker 開發的 Visual Studio Code。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-310">There are a number of extensions available for Visual Studio Code that support Docker development.</span></span>

<span data-ttu-id="a4ea3-311">Microsoft [為 Visual Studio Code 擴充](https://marketplace.visualstudio.com/items?itemName=ms-azuretools.vscode-docker)功能提供 Docker。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-311">Microsoft provides the [Docker for Visual Studio Code extension](https://marketplace.visualstudio.com/items?itemName=ms-azuretools.vscode-docker).</span></span> <span data-ttu-id="a4ea3-312">此延伸模組可簡化將容器支援新增至應用程式的程式。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-312">This extension simplifies the process of adding container support to applications.</span></span> <span data-ttu-id="a4ea3-313">它 scaffold 必要的檔案、建立 Docker 映射，並可讓您在容器內進行應用程式的偵錯工具。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-313">It scaffolds required files, builds Docker images, and enables you to debug your app inside a container.</span></span> <span data-ttu-id="a4ea3-314">擴充功能可讓您輕鬆地在容器和影像（例如啟動、停止、檢查、移除等）上採取動作。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-314">The extension features a visual explorer that makes it easy to take actions on containers and images such as start, stop, inspect, remove, and more.</span></span> <span data-ttu-id="a4ea3-315">延伸模組也支援 Docker Compose，可讓您將多個執行中的容器當作單一單位來管理。</span><span class="sxs-lookup"><span data-stu-id="a4ea3-315">The extension also supports Docker Compose enabling you to manage multiple running containers as a single unit.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="a4ea3-316">[上一個](scale-applications.md) 
>[下一步](leverage-serverless-functions.md)</span><span class="sxs-lookup"><span data-stu-id="a4ea3-316">[Previous](scale-applications.md)
[Next](leverage-serverless-functions.md)</span></span>
