---
title: 利用容器和協調器
description: 在 Azure 中利用 Docker 容器和 Kubernetes 協調器
ms.date: 04/13/2020
ms.openlocfilehash: 64c6c0666398d9ccbc87efad18017bf278568fc4
ms.sourcegitcommit: 957c49696eaf048c284ef8f9f8ffeb562357ad95
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 05/07/2020
ms.locfileid: "82895556"
---
# <a name="leveraging-containers-and-orchestrators"></a><span data-ttu-id="7fa81-103">利用容器和協調器</span><span class="sxs-lookup"><span data-stu-id="7fa81-103">Leveraging containers and orchestrators</span></span>

[!INCLUDE [book-preview](../../../includes/book-preview.md)]

<span data-ttu-id="7fa81-104">容器和協調器的設計是為了解決整合型部署方法常見的問題。</span><span class="sxs-lookup"><span data-stu-id="7fa81-104">Containers and orchestrators are designed to solve problems common to monolithic deployment approaches.</span></span>

## <a name="challenges-with-monolithic-deployments"></a><span data-ttu-id="7fa81-105">整合型部署的挑戰</span><span class="sxs-lookup"><span data-stu-id="7fa81-105">Challenges with monolithic deployments</span></span>

<span data-ttu-id="7fa81-106">傳統上，大部分的應用程式都已部署為單一單位。</span><span class="sxs-lookup"><span data-stu-id="7fa81-106">Traditionally, most applications have been deployed as a single unit.</span></span> <span data-ttu-id="7fa81-107">這類應用程式稱為單體。</span><span class="sxs-lookup"><span data-stu-id="7fa81-107">Such applications are referred to as a monolith.</span></span> <span data-ttu-id="7fa81-108">這種將應用程式部署為單一單位的一般方法，即使它們是由多個模組或元件所組成，也稱為整合型架構，如圖3-1 所示。</span><span class="sxs-lookup"><span data-stu-id="7fa81-108">This general approach of deploying applications as single units even if they're composed of multiple modules or assemblies is known as monolithic architecture, as shown in Figure 3-1.</span></span>

![整合型架構。](./media/monolithic-architecture.png)

<span data-ttu-id="7fa81-110">**圖 3-1**。</span><span class="sxs-lookup"><span data-stu-id="7fa81-110">**Figure 3-1**.</span></span> <span data-ttu-id="7fa81-111">整合型架構。</span><span class="sxs-lookup"><span data-stu-id="7fa81-111">Monolithic architecture.</span></span>

<span data-ttu-id="7fa81-112">雖然它們具有簡單的優點，但是整合型架構也面臨一些挑戰：</span><span class="sxs-lookup"><span data-stu-id="7fa81-112">Although they have the benefit of simplicity, monolithic architectures face a number of challenges:</span></span>

### <a name="deployment"></a><span data-ttu-id="7fa81-113">部署</span><span class="sxs-lookup"><span data-stu-id="7fa81-113">Deployment</span></span>

<span data-ttu-id="7fa81-114">整合型應用程式需要整個應用程式的完整部署，即使只進行一項小變更也一樣。</span><span class="sxs-lookup"><span data-stu-id="7fa81-114">Monolithic applications require a full deployment of the entire application, even if only a small change has been made.</span></span> <span data-ttu-id="7fa81-115">完整部署可能相當昂貴，而且容易出錯。</span><span class="sxs-lookup"><span data-stu-id="7fa81-115">Full deployments can be expensive and error prone.</span></span> <span data-ttu-id="7fa81-116">此外，它們需要重新開機應用程式，這會暫時影響無法使用。</span><span class="sxs-lookup"><span data-stu-id="7fa81-116">Additionally, they require a restart of the application, which temporarily impacts unavailability.</span></span>

### <a name="scaling"></a><span data-ttu-id="7fa81-117">調整大小</span><span class="sxs-lookup"><span data-stu-id="7fa81-117">Scaling</span></span>

<span data-ttu-id="7fa81-118">整合型應用程式完全裝載于單一機器實例上，通常需要高功能的硬體。</span><span class="sxs-lookup"><span data-stu-id="7fa81-118">A monolithic application is hosted entirely on a single machine instance, often requiring high-capability hardware.</span></span> <span data-ttu-id="7fa81-119">如果單體的任何部分需要調整，則整個應用程式的另一個複本必須部署到另一部電腦。</span><span class="sxs-lookup"><span data-stu-id="7fa81-119">If any part of the monolith requires scaling, another copy of the entire application must be deployed to another machine.</span></span> <span data-ttu-id="7fa81-120">有了單體，您就無法個別擴充應用程式元件，而是全部或無。</span><span class="sxs-lookup"><span data-stu-id="7fa81-120">With a monolith, you can't scale application components individually - it's all or nothing.</span></span> <span data-ttu-id="7fa81-121">調整不需要調整的元件會導致效率不佳且資源使用量昂貴。</span><span class="sxs-lookup"><span data-stu-id="7fa81-121">Scaling components that don't require scaling results in inefficient and costly resource usage.</span></span>

### <a name="environment"></a><span data-ttu-id="7fa81-122">環境</span><span class="sxs-lookup"><span data-stu-id="7fa81-122">Environment</span></span>

<span data-ttu-id="7fa81-123">整合型應用程式通常會部署到裝載環境，並具有預先安裝的作業系統、執行時間和程式庫相依性。</span><span class="sxs-lookup"><span data-stu-id="7fa81-123">Monolithic applications are typically deployed to a hosting environment with a pre-installed operating system, runtime, and library dependencies.</span></span> <span data-ttu-id="7fa81-124">此環境可能不符合應用程式的開發或測試目標。</span><span class="sxs-lookup"><span data-stu-id="7fa81-124">This environment may not match that upon which the application was developed or tested.</span></span> <span data-ttu-id="7fa81-125">跨應用程式環境的不一致是整合型部署問題的常見來源。</span><span class="sxs-lookup"><span data-stu-id="7fa81-125">Inconsistencies across application environments are a common source of problems for monolithic deployments.</span></span>

### <a name="coupling"></a><span data-ttu-id="7fa81-126">緊密</span><span class="sxs-lookup"><span data-stu-id="7fa81-126">Coupling</span></span>

<span data-ttu-id="7fa81-127">整合型應用程式可能會在其功能元件之間遇到高結合性。</span><span class="sxs-lookup"><span data-stu-id="7fa81-127">A monolithic application is likely to experience high coupling across its functional components.</span></span> <span data-ttu-id="7fa81-128">如果沒有固定界限，系統變更通常會導致非預期且成本高昂的副作用。</span><span class="sxs-lookup"><span data-stu-id="7fa81-128">Without hard boundaries, system changes often result in unintended and costly side effects.</span></span> <span data-ttu-id="7fa81-129">新功能/修正程式會變得很困難、耗時，而且需要耗費大量的時間。</span><span class="sxs-lookup"><span data-stu-id="7fa81-129">New features/fixes become tricky, time-consuming, and expensive to implement.</span></span> <span data-ttu-id="7fa81-130">更新需要大量測試。</span><span class="sxs-lookup"><span data-stu-id="7fa81-130">Updates require extensive testing.</span></span> <span data-ttu-id="7fa81-131">結合也會使得重構元件或交換替代的執行變得很容易。</span><span class="sxs-lookup"><span data-stu-id="7fa81-131">Coupling also makes it difficult to refactor components or swap in alternative implementations.</span></span> <span data-ttu-id="7fa81-132">即使是以嚴格的顧慮分離來建造，架構削弱還是會在中將設定為整合式程式碼基底 deteriorates，且不會結束「特殊案例」。</span><span class="sxs-lookup"><span data-stu-id="7fa81-132">Even when constructed with a strict separation of concerns, architectural erosion sets in as the monolithic code base deteriorates with never-ending "special cases."</span></span>

### <a name="platform-lock-in"></a><span data-ttu-id="7fa81-133">平臺鎖定</span><span class="sxs-lookup"><span data-stu-id="7fa81-133">Platform lock-in</span></span>

<span data-ttu-id="7fa81-134">整合型應用程式是以單一技術堆疊來建立。</span><span class="sxs-lookup"><span data-stu-id="7fa81-134">A monolithic application is constructed with a single technology stack.</span></span> <span data-ttu-id="7fa81-135">雖然提供一致性，但這種承諾可能會成為創新的障礙。</span><span class="sxs-lookup"><span data-stu-id="7fa81-135">While offering uniformity, this commitment can become a barrier to innovation.</span></span> <span data-ttu-id="7fa81-136">新的功能和元件將使用應用程式的目前堆疊來建立，即使是更現代化的技術也是較佳的選擇。</span><span class="sxs-lookup"><span data-stu-id="7fa81-136">New features and components will be built using the application's current stack - even when more modern technologies may be a better choice.</span></span> <span data-ttu-id="7fa81-137">較長期的風險是您的技術堆疊已過時且已過時。</span><span class="sxs-lookup"><span data-stu-id="7fa81-137">A longer-term risk is your technology stack becoming outdated and obsolete.</span></span> <span data-ttu-id="7fa81-138">將整個應用程式重新架構到新的、更現代化的平臺，其成本最高，而且有風險。</span><span class="sxs-lookup"><span data-stu-id="7fa81-138">Rearchitecting an entire application to a new, more modern platform is at best expensive and risky.</span></span>

## <a name="what-are-the-benefits-of-containers-and-orchestrators"></a><span data-ttu-id="7fa81-139">容器和協調器的優點為何？</span><span class="sxs-lookup"><span data-stu-id="7fa81-139">What are the benefits of containers and orchestrators?</span></span>

<span data-ttu-id="7fa81-140">我們在第1章引進了容器。</span><span class="sxs-lookup"><span data-stu-id="7fa81-140">We introduced containers in Chapter 1.</span></span> <span data-ttu-id="7fa81-141">我們強調了雲端原生運算基礎（由 CNCF）排名容器化如何作為其雲端原生[線索對應](https://raw.githubusercontent.com/cncf/trailmap/master/CNCF_TrailMap_latest.png)的第一個步驟-開始雲端原生旅程的企業指導方針。</span><span class="sxs-lookup"><span data-stu-id="7fa81-141">We highlighted how the Cloud Native Computing Foundation (CNCF) ranks containerization as the first step in their [Cloud-Native Trail Map](https://raw.githubusercontent.com/cncf/trailmap/master/CNCF_TrailMap_latest.png) - guidance for enterprises beginning their cloud-native journey.</span></span> <span data-ttu-id="7fa81-142">在本節中，我們將討論容器的優點。</span><span class="sxs-lookup"><span data-stu-id="7fa81-142">In this section, we discuss the benefits of containers.</span></span>

<span data-ttu-id="7fa81-143">Docker 是最受歡迎的容器管理平臺。</span><span class="sxs-lookup"><span data-stu-id="7fa81-143">Docker is the most popular container management platform.</span></span> <span data-ttu-id="7fa81-144">其適用于 Linux 或 Windows 上的容器。</span><span class="sxs-lookup"><span data-stu-id="7fa81-144">It works with containers on both Linux or Windows.</span></span> <span data-ttu-id="7fa81-145">容器提供不同但可重現的應用程式環境，在任何系統上執行相同的方式。</span><span class="sxs-lookup"><span data-stu-id="7fa81-145">Containers provide separate but reproducible application environments that run the same way on any system.</span></span> <span data-ttu-id="7fa81-146">這個層面讓它們適合用來開發和裝載雲端原生服務。</span><span class="sxs-lookup"><span data-stu-id="7fa81-146">This aspect makes them perfect for developing and hosting cloud-native services.</span></span> <span data-ttu-id="7fa81-147">容器會互相隔離。</span><span class="sxs-lookup"><span data-stu-id="7fa81-147">Containers are isolated from one another.</span></span> <span data-ttu-id="7fa81-148">相同主機硬體上的兩個容器可以有不同版本的軟體，而不會造成衝突。</span><span class="sxs-lookup"><span data-stu-id="7fa81-148">Two containers on the same host hardware can have different versions of software, without causing conflicts.</span></span>

<span data-ttu-id="7fa81-149">容器是由變成專案成品並簽入原始檔控制的簡單文字型檔案所定義。</span><span class="sxs-lookup"><span data-stu-id="7fa81-149">Containers are defined by simple text-based files that become project artifacts and are checked into source control.</span></span> <span data-ttu-id="7fa81-150">雖然完整伺服器和虛擬機器需要手動進行更新，但容器是可輕鬆控制版本的。</span><span class="sxs-lookup"><span data-stu-id="7fa81-150">While full servers and virtual machines require manual effort to update, containers are easily version-controlled.</span></span> <span data-ttu-id="7fa81-151">建立在容器中執行的應用程式可以使用自動化工具來進行開發、測試及部署，以作為組建管線的一部分。</span><span class="sxs-lookup"><span data-stu-id="7fa81-151">Apps built to run in containers can be developed, tested, and deployed using automated tools as part of a build pipeline.</span></span>

<span data-ttu-id="7fa81-152">容器是不可變的。</span><span class="sxs-lookup"><span data-stu-id="7fa81-152">Containers are immutable.</span></span> <span data-ttu-id="7fa81-153">定義容器之後，您可以用完全相同的方式重新建立並執行它。</span><span class="sxs-lookup"><span data-stu-id="7fa81-153">Once you define a container, you can recreate and run it exactly the same way.</span></span> <span data-ttu-id="7fa81-154">這種不會將其本身用於以元件為基礎的設計。</span><span class="sxs-lookup"><span data-stu-id="7fa81-154">This immutability lends itself to component-based design.</span></span> <span data-ttu-id="7fa81-155">如果應用程式的某些部分的發展方式不同，當您可以直接部署最常變更的元件時，為何要重新部署整個應用程式？</span><span class="sxs-lookup"><span data-stu-id="7fa81-155">If some parts of an application evolve differently than others, why redeploy the entire app when you can just deploy the parts that change most frequently?</span></span> <span data-ttu-id="7fa81-156">應用程式的不同功能和跨領域考慮可能會分成不同的單位。</span><span class="sxs-lookup"><span data-stu-id="7fa81-156">Different features and cross-cutting concerns of an app can be broken up into separate units.</span></span> <span data-ttu-id="7fa81-157">圖3-2 顯示單一應用程式如何藉由委派特定的功能來利用容器和微服務。</span><span class="sxs-lookup"><span data-stu-id="7fa81-157">Figure 3-2 shows how a monolithic app can take advantage of containers and microservices by delegating certain features or functionality.</span></span> <span data-ttu-id="7fa81-158">應用程式本身的其餘功能也已容器化。</span><span class="sxs-lookup"><span data-stu-id="7fa81-158">The remaining functionality in the app itself has also been containerized.</span></span>

<span data-ttu-id="7fa81-159">容器是不可變的。</span><span class="sxs-lookup"><span data-stu-id="7fa81-159">Containers are immutable.</span></span> <span data-ttu-id="7fa81-160">定義容器之後，您可以用完全相同的方式重新建立並執行它。</span><span class="sxs-lookup"><span data-stu-id="7fa81-160">Once you define a container, you can recreate and run it exactly the same way.</span></span> <span data-ttu-id="7fa81-161">這種不會將其本身用於以元件為基礎的設計。</span><span class="sxs-lookup"><span data-stu-id="7fa81-161">This immutability lends itself to component-based design.</span></span> <span data-ttu-id="7fa81-162">如果應用程式的某些部分的發展方式不同，當您可以直接部署最常變更的元件時，為何要重新部署整個應用程式？</span><span class="sxs-lookup"><span data-stu-id="7fa81-162">If some parts of an application evolve differently than others, why redeploy the entire app when you can just deploy the parts that change most frequently?</span></span> <span data-ttu-id="7fa81-163">應用程式的不同功能和跨領域考慮可能會分成不同的單位。</span><span class="sxs-lookup"><span data-stu-id="7fa81-163">Different features and cross-cutting concerns of an app can be broken up into separate units.</span></span> <span data-ttu-id="7fa81-164">圖3-2 顯示單一應用程式如何藉由委派特定的功能來利用容器和微服務。</span><span class="sxs-lookup"><span data-stu-id="7fa81-164">Figure 3-2 shows how a monolithic app can take advantage of containers and microservices by delegating certain features or functionality.</span></span> <span data-ttu-id="7fa81-165">應用程式本身的其餘功能也已容器化。</span><span class="sxs-lookup"><span data-stu-id="7fa81-165">The remaining functionality in the app itself has also been containerized.</span></span>

<span data-ttu-id="7fa81-166">![將整合型應用程式分解成在後端使用微服務。](./media/breaking-up-monolith-with-backend-microservices.png)
**圖 3-2**。</span><span class="sxs-lookup"><span data-stu-id="7fa81-166">![Breaking up a monolithic app to use microservices in the back end.](./media/breaking-up-monolith-with-backend-microservices.png)
**Figure 3-2**.</span></span> <span data-ttu-id="7fa81-167">將整合型應用程式分解成在後端使用微服務。</span><span class="sxs-lookup"><span data-stu-id="7fa81-167">Breaking up a monolithic app to use microservices in the back end.</span></span>

<span data-ttu-id="7fa81-168">每個雲端原生服務都會在個別的容器中建立及部署。</span><span class="sxs-lookup"><span data-stu-id="7fa81-168">Each cloud-native service is built and deployed in a separate container.</span></span> <span data-ttu-id="7fa81-169">每個都可以視需要進行更新。</span><span class="sxs-lookup"><span data-stu-id="7fa81-169">Each can update as needed.</span></span> <span data-ttu-id="7fa81-170">個別服務可以裝載于節點上，並具有適用于每個服務的資源。</span><span class="sxs-lookup"><span data-stu-id="7fa81-170">Individual services can be hosted on nodes with resources appropriate to each service.</span></span> <span data-ttu-id="7fa81-171">在中執行的每個服務都不變、在開發、測試和生產環境之間共用，而且可以輕鬆建立版本。</span><span class="sxs-lookup"><span data-stu-id="7fa81-171">The environment each service runs in is immutable, shared across dev, test, and production environments, and easily versioned.</span></span> <span data-ttu-id="7fa81-172">應用程式的不同區域之間的結合，會明確成為服務之間的呼叫或訊息，而不是單體內的編譯時間相依性。</span><span class="sxs-lookup"><span data-stu-id="7fa81-172">Coupling between different areas of the application occurs explicitly as calls or messages between services, not compile-time dependencies within the monolith.</span></span> <span data-ttu-id="7fa81-173">您也可以選擇最符合指定功能的技術，而不需要變更應用程式的其餘部分。</span><span class="sxs-lookup"><span data-stu-id="7fa81-173">You can also choose the technology that best suites a given capability without requiring changes to the rest of the app.</span></span>

<span data-ttu-id="7fa81-174">容器化服務需要自動化管理。</span><span class="sxs-lookup"><span data-stu-id="7fa81-174">Containerized services require automated management.</span></span> <span data-ttu-id="7fa81-175">手動管理一大組獨立部署的容器並不可行。</span><span class="sxs-lookup"><span data-stu-id="7fa81-175">It wouldn't be feasible to manually administer a large set of independently deployed containers.</span></span> <span data-ttu-id="7fa81-176">例如，請考慮下列工作：</span><span class="sxs-lookup"><span data-stu-id="7fa81-176">For example, consider the following tasks:</span></span>

- <span data-ttu-id="7fa81-177">如何在多部電腦的叢集上布建容器實例？</span><span class="sxs-lookup"><span data-stu-id="7fa81-177">How will container instances be provisioned across a cluster of many machines?</span></span>
- <span data-ttu-id="7fa81-178">一旦部署之後，容器會如何探索並彼此通訊？</span><span class="sxs-lookup"><span data-stu-id="7fa81-178">Once deployed, how will containers discover and communicate with each other?</span></span>
- <span data-ttu-id="7fa81-179">容器如何依需求相應縮小或放大？</span><span class="sxs-lookup"><span data-stu-id="7fa81-179">How can containers scale in or out on-demand?</span></span>
- <span data-ttu-id="7fa81-180">如何監視每個容器的健全狀況？</span><span class="sxs-lookup"><span data-stu-id="7fa81-180">How do you monitor the health of each container?</span></span>
- <span data-ttu-id="7fa81-181">如何保護容器免于硬體和軟體失敗？</span><span class="sxs-lookup"><span data-stu-id="7fa81-181">How do you protect a container against hardware and software failures?</span></span>
- <span data-ttu-id="7fa81-182">如何將即時應用程式的容器升級為零停機時間？</span><span class="sxs-lookup"><span data-stu-id="7fa81-182">How do upgrade containers for a live application with zero downtime?</span></span>

<span data-ttu-id="7fa81-183">容器協調器會解決這些問題，並將這些考慮自動化。</span><span class="sxs-lookup"><span data-stu-id="7fa81-183">Container orchestrators address and automate these and other concerns.</span></span>

<span data-ttu-id="7fa81-184">在雲端原生的生態系統中，Kubernetes 已成為事實上的容器協調器。</span><span class="sxs-lookup"><span data-stu-id="7fa81-184">In the cloud-native eco-system, Kubernetes has become the de facto container orchestrator.</span></span> <span data-ttu-id="7fa81-185">這是由雲端原生運算基礎（由 CNCF）所管理的開放原始碼平臺。</span><span class="sxs-lookup"><span data-stu-id="7fa81-185">It's an open-source platform managed by the Cloud Native Computing Foundation (CNCF).</span></span> <span data-ttu-id="7fa81-186">Kubernetes 會將容器化工作負載的部署、調整和操作方面的顧慮自動化到機器叢集上。</span><span class="sxs-lookup"><span data-stu-id="7fa81-186">Kubernetes automates the deployment, scaling, and operational concerns of containerized workloads across a machine cluster.</span></span> <span data-ttu-id="7fa81-187">不過，安裝和管理 Kubernetes 非常複雜。</span><span class="sxs-lookup"><span data-stu-id="7fa81-187">However, installing and managing Kubernetes is notoriously complex.</span></span>

<span data-ttu-id="7fa81-188">更好的方法是利用 Kubernetes 作為雲端廠商的受控服務。</span><span class="sxs-lookup"><span data-stu-id="7fa81-188">A much better approach is to leverage Kubernetes as a managed service from a cloud vendor.</span></span> <span data-ttu-id="7fa81-189">Azure 雲端具備一個完全受控的 Kubernetes 平臺，並[Azure Kubernetes Service （AKS）](https://azure.microsoft.com/services/kubernetes-service/)。</span><span class="sxs-lookup"><span data-stu-id="7fa81-189">The Azure cloud features a fully managed Kubernetes platform entitled [Azure Kubernetes Service (AKS)](https://azure.microsoft.com/services/kubernetes-service/).</span></span> <span data-ttu-id="7fa81-190">AKS 會將管理 Kubernetes 的複雜性和操作負擔抽象化。</span><span class="sxs-lookup"><span data-stu-id="7fa81-190">AKS abstracts the complexity and operational overhead of managing Kubernetes.</span></span> <span data-ttu-id="7fa81-191">您會使用 Kubernetes 作為雲端服務;Microsoft 會負責管理和支援它。</span><span class="sxs-lookup"><span data-stu-id="7fa81-191">You consume Kubernetes as a cloud service; Microsoft takes responsibility for managing and supporting it.</span></span> <span data-ttu-id="7fa81-192">AKS 也與其他 Azure 服務和開發工具緊密整合。</span><span class="sxs-lookup"><span data-stu-id="7fa81-192">AKS also tightly integrates with other Azure services and dev tools.</span></span>

<span data-ttu-id="7fa81-193">AKS 是以叢集為基礎的技術。</span><span class="sxs-lookup"><span data-stu-id="7fa81-193">AKS is a cluster-based technology.</span></span> <span data-ttu-id="7fa81-194">同盟虛擬機器或節點的集區會部署到 Azure 雲端。</span><span class="sxs-lookup"><span data-stu-id="7fa81-194">A pool of federated virtual machines, or nodes, is deployed to the Azure cloud.</span></span> <span data-ttu-id="7fa81-195">它們會構成高可用性環境或叢集。</span><span class="sxs-lookup"><span data-stu-id="7fa81-195">Together they form a highly available environment, or cluster.</span></span> <span data-ttu-id="7fa81-196">叢集會以流暢的單一實體形式呈現給您的雲端原生應用程式。</span><span class="sxs-lookup"><span data-stu-id="7fa81-196">The cluster appears as a seamless, single entity to your cloud-native application.</span></span> <span data-ttu-id="7fa81-197">實際上，AKS 會依照預先定義的策略，將您的容器化服務部署在這些節點上，以平均分配負載。</span><span class="sxs-lookup"><span data-stu-id="7fa81-197">Under the hood, AKS deploys your containerized services across these nodes following a predefined strategy that evenly distributes the load.</span></span>

<span data-ttu-id="7fa81-198">容器化服務需要自動化管理。</span><span class="sxs-lookup"><span data-stu-id="7fa81-198">Containerized services require automated management.</span></span> <span data-ttu-id="7fa81-199">手動管理一大組獨立部署的容器並不可行。</span><span class="sxs-lookup"><span data-stu-id="7fa81-199">It wouldn't be feasible to manually administer a large set of independently deployed containers.</span></span> <span data-ttu-id="7fa81-200">例如，請考慮下列工作：</span><span class="sxs-lookup"><span data-stu-id="7fa81-200">For example, consider the following tasks:</span></span>

- <span data-ttu-id="7fa81-201">如何在多部電腦的叢集上布建容器實例？</span><span class="sxs-lookup"><span data-stu-id="7fa81-201">How will container instances be provisioned across a cluster of many machines?</span></span>
- <span data-ttu-id="7fa81-202">一旦部署之後，容器會如何探索並彼此通訊？</span><span class="sxs-lookup"><span data-stu-id="7fa81-202">Once deployed, how will containers discover and communicate with each other?</span></span>
- <span data-ttu-id="7fa81-203">容器如何依需求相應縮小或放大？</span><span class="sxs-lookup"><span data-stu-id="7fa81-203">How can containers scale in or out on-demand?</span></span>
- <span data-ttu-id="7fa81-204">如何監視每個容器的健全狀況？</span><span class="sxs-lookup"><span data-stu-id="7fa81-204">How do you monitor the health of each container?</span></span>
- <span data-ttu-id="7fa81-205">如何保護容器免于硬體和軟體失敗？</span><span class="sxs-lookup"><span data-stu-id="7fa81-205">How do you protect a container against hardware and software failures?</span></span>
- <span data-ttu-id="7fa81-206">如何將即時應用程式的容器升級為零停機時間？</span><span class="sxs-lookup"><span data-stu-id="7fa81-206">How do upgrade containers for a live application with zero downtime?</span></span>

<span data-ttu-id="7fa81-207">容器協調器會解決這些問題，並將這些考慮自動化。</span><span class="sxs-lookup"><span data-stu-id="7fa81-207">Container orchestrators address and automate these and other concerns.</span></span>

<span data-ttu-id="7fa81-208">在雲端原生的生態系統中，Kubernetes 已成為事實上的容器協調器。</span><span class="sxs-lookup"><span data-stu-id="7fa81-208">In the cloud-native eco-system, Kubernetes has become the de facto container orchestrator.</span></span> <span data-ttu-id="7fa81-209">這是由雲端原生運算基礎（由 CNCF）所管理的開放原始碼平臺。</span><span class="sxs-lookup"><span data-stu-id="7fa81-209">It's an open-source platform managed by the Cloud Native Computing Foundation (CNCF).</span></span> <span data-ttu-id="7fa81-210">Kubernetes 會將容器化工作負載的部署、調整和操作方面的顧慮自動化到機器叢集上。</span><span class="sxs-lookup"><span data-stu-id="7fa81-210">Kubernetes automates the deployment, scaling, and operational concerns of containerized workloads across a machine cluster.</span></span> <span data-ttu-id="7fa81-211">不過，安裝和管理 Kubernetes 非常複雜。</span><span class="sxs-lookup"><span data-stu-id="7fa81-211">However, installing and managing Kubernetes is notoriously complex.</span></span>

<span data-ttu-id="7fa81-212">更好的方法是利用 Kubernetes 作為雲端廠商的受控服務。</span><span class="sxs-lookup"><span data-stu-id="7fa81-212">A much better approach is to leverage Kubernetes as a managed service from a cloud vendor.</span></span> <span data-ttu-id="7fa81-213">Azure 雲端具備一個完全受控的 Kubernetes 平臺，並[Azure Kubernetes Service （AKS）](https://azure.microsoft.com/services/kubernetes-service/)。</span><span class="sxs-lookup"><span data-stu-id="7fa81-213">The Azure cloud features a fully managed Kubernetes platform entitled [Azure Kubernetes Service (AKS)](https://azure.microsoft.com/services/kubernetes-service/).</span></span> <span data-ttu-id="7fa81-214">AKS 會將管理 Kubernetes 的複雜性和操作負擔抽象化。</span><span class="sxs-lookup"><span data-stu-id="7fa81-214">AKS abstracts the complexity and operational overhead of managing Kubernetes.</span></span> <span data-ttu-id="7fa81-215">您會使用 Kubernetes 作為雲端服務;Microsoft 會負責管理和支援它。</span><span class="sxs-lookup"><span data-stu-id="7fa81-215">You consume Kubernetes as a cloud service; Microsoft takes responsibility for managing and supporting it.</span></span> <span data-ttu-id="7fa81-216">AKS 也與其他 Azure 服務和開發工具緊密整合。</span><span class="sxs-lookup"><span data-stu-id="7fa81-216">AKS also tightly integrates with other Azure services and dev tools.</span></span>

<span data-ttu-id="7fa81-217">AKS 是以叢集為基礎的技術。</span><span class="sxs-lookup"><span data-stu-id="7fa81-217">AKS is a cluster-based technology.</span></span> <span data-ttu-id="7fa81-218">同盟虛擬機器或節點的集區會部署到 Azure 雲端。</span><span class="sxs-lookup"><span data-stu-id="7fa81-218">A pool of federated virtual machines, or nodes, is deployed to the Azure cloud.</span></span> <span data-ttu-id="7fa81-219">它們會構成高可用性環境或叢集。</span><span class="sxs-lookup"><span data-stu-id="7fa81-219">Together they form a highly available environment, or cluster.</span></span> <span data-ttu-id="7fa81-220">叢集會以流暢的單一實體形式呈現給您的雲端原生應用程式。</span><span class="sxs-lookup"><span data-stu-id="7fa81-220">The cluster appears as a seamless, single entity to your cloud-native application.</span></span> <span data-ttu-id="7fa81-221">實際上，AKS 會依照預先定義的策略，將您的容器化服務部署在這些節點上，以平均分配負載。</span><span class="sxs-lookup"><span data-stu-id="7fa81-221">Under the hood, AKS deploys your containerized services across these nodes following a predefined strategy that evenly distributes the load.</span></span>

## <a name="what-are-the-scaling-benefits"></a><span data-ttu-id="7fa81-222">什麼是調整優點？</span><span class="sxs-lookup"><span data-stu-id="7fa81-222">What are the scaling benefits?</span></span>

<span data-ttu-id="7fa81-223">以容器為基礎的服務可以利用協調流程工具（例如 Kubernetes）所提供的調整優勢。</span><span class="sxs-lookup"><span data-stu-id="7fa81-223">Services built on containers can leverage scaling benefits provided by orchestration tools like Kubernetes.</span></span> <span data-ttu-id="7fa81-224">根據設計，容器只知道自己的關係。</span><span class="sxs-lookup"><span data-stu-id="7fa81-224">By design containers only know about themselves.</span></span> <span data-ttu-id="7fa81-225">當您有多個需要共同作業的容器時，您應該以較高的層級來組織它們。</span><span class="sxs-lookup"><span data-stu-id="7fa81-225">Once you have multiple containers that need to work together, you should organize them at a higher level.</span></span> <span data-ttu-id="7fa81-226">組織大量的容器及其共用的相依性（例如網路設定）就是協調流程工具的儲存時間！</span><span class="sxs-lookup"><span data-stu-id="7fa81-226">Organizing large numbers of containers and their shared dependencies, such as network configuration, is where orchestration tools come in to save the day!</span></span> <span data-ttu-id="7fa81-227">Kubernetes 會透過容器群組建立抽象層，並將其組織*成 pod*。</span><span class="sxs-lookup"><span data-stu-id="7fa81-227">Kubernetes creates an abstraction layer over groups of containers and organizes them into *pods*.</span></span> <span data-ttu-id="7fa81-228">Pod 會在稱為*節點*的工作者機器上執行。</span><span class="sxs-lookup"><span data-stu-id="7fa81-228">Pods run on worker machines referred to as *nodes*.</span></span> <span data-ttu-id="7fa81-229">此組織結構稱為「叢集」（ *cluster*）。</span><span class="sxs-lookup"><span data-stu-id="7fa81-229">This organized structure is referred to as a *cluster*.</span></span> <span data-ttu-id="7fa81-230">圖3-3 顯示 Kubernetes 叢集的不同元件。</span><span class="sxs-lookup"><span data-stu-id="7fa81-230">Figure 3-3 shows the different components of a Kubernetes cluster.</span></span>

<span data-ttu-id="7fa81-231">![Kubernetes 叢集元件。](./media/kubernetes-cluster-components.png)
**圖 3-3**。</span><span class="sxs-lookup"><span data-stu-id="7fa81-231">![Kubernetes cluster components.](./media/kubernetes-cluster-components.png)
**Figure 3-3**.</span></span> <span data-ttu-id="7fa81-232">Kubernetes 叢集元件。</span><span class="sxs-lookup"><span data-stu-id="7fa81-232">Kubernetes cluster components.</span></span>

<span data-ttu-id="7fa81-233">調整容器化工作負載是 container 協調器的一項重要功能。</span><span class="sxs-lookup"><span data-stu-id="7fa81-233">Scaling containerized workloads is a key feature of container orchestrators.</span></span> <span data-ttu-id="7fa81-234">AKS 支援跨兩個維度進行自動調整：容器實例和計算節點。</span><span class="sxs-lookup"><span data-stu-id="7fa81-234">AKS supports automatic scaling across two dimensions: Container instances and compute nodes.</span></span> <span data-ttu-id="7fa81-235">它們一起讓 AKS 能夠快速且有效率地回應需求尖峰，並新增額外的資源。</span><span class="sxs-lookup"><span data-stu-id="7fa81-235">Together they give AKS the ability to quickly and efficiently respond to spikes in demand and add additional resources.</span></span> <span data-ttu-id="7fa81-236">我們將在本章稍後討論 AKS 的調整。</span><span class="sxs-lookup"><span data-stu-id="7fa81-236">We discuss scaling in AKS later in this chapter.</span></span>

### <a name="declarative-versus-imperative"></a><span data-ttu-id="7fa81-237">宣告式與命令式</span><span class="sxs-lookup"><span data-stu-id="7fa81-237">Declarative versus imperative</span></span>

<span data-ttu-id="7fa81-238">Kubernetes 支援宣告式和命令式設定。</span><span class="sxs-lookup"><span data-stu-id="7fa81-238">Kubernetes supports both declarative and imperative configuration.</span></span> <span data-ttu-id="7fa81-239">命令式方法牽涉到執行各種命令，告訴 Kubernetes 該怎麼做的每個步驟。</span><span class="sxs-lookup"><span data-stu-id="7fa81-239">The imperative approach involves running various commands that tell Kubernetes what to do each step of the way.</span></span> <span data-ttu-id="7fa81-240">執行此映射。</span><span class="sxs-lookup"><span data-stu-id="7fa81-240">Run this image.</span></span> <span data-ttu-id="7fa81-241">刪除此 pod。</span><span class="sxs-lookup"><span data-stu-id="7fa81-241">Delete this pod.</span></span> <span data-ttu-id="7fa81-242">公開此埠。</span><span class="sxs-lookup"><span data-stu-id="7fa81-242">Expose this port.</span></span> <span data-ttu-id="7fa81-243">使用宣告式方法時，您可以建立稱為資訊清單的設定檔，以描述您想要的內容，而不是要執行的動作。</span><span class="sxs-lookup"><span data-stu-id="7fa81-243">With the declarative approach, you create a configuration file, called a manifest, to describe what you want instead of what to do.</span></span> <span data-ttu-id="7fa81-244">Kubernetes 會讀取資訊清單，並將您想要的結束狀態轉換成實際的結束狀態。</span><span class="sxs-lookup"><span data-stu-id="7fa81-244">Kubernetes reads the manifest and transforms your desired end state into actual end state.</span></span>

<span data-ttu-id="7fa81-245">命令式命令非常適合用於學習和互動式實驗。</span><span class="sxs-lookup"><span data-stu-id="7fa81-245">Imperative commands are great for learning and interactive experimentation.</span></span> <span data-ttu-id="7fa81-246">不過，您會想要以宣告方式建立 Kubernetes 資訊清單檔，以將基礎結構作為程式碼方法，以提供可靠且可重複的部署。</span><span class="sxs-lookup"><span data-stu-id="7fa81-246">However, you'll want to declaratively create Kubernetes manifest files to embrace an infrastructure as code approach, providing for reliable and repeatable deployments.</span></span> <span data-ttu-id="7fa81-247">資訊清單檔案會變成專案成品，並用於您的 CI/CD 管線，以自動化 Kubernetes 部署。</span><span class="sxs-lookup"><span data-stu-id="7fa81-247">The manifest file becomes a project artifact and is used in your CI/CD pipeline for automating Kubernetes deployments.</span></span>

<span data-ttu-id="7fa81-248">如果您已經使用命令式命令來設定您的叢集，您可以使用`kubectl get svc SERVICENAME -o yaml > service.yaml`來匯出宣告式資訊清單。</span><span class="sxs-lookup"><span data-stu-id="7fa81-248">If you've already configured your cluster using imperative commands, you can export a declarative manifest by using `kubectl get svc SERVICENAME -o yaml > service.yaml`.</span></span> <span data-ttu-id="7fa81-249">此命令會產生類似下面所示的資訊清單：</span><span class="sxs-lookup"><span data-stu-id="7fa81-249">This command produces a manifest similar to one shown below:</span></span>

```yaml
apiVersion: v1
kind: Service
metadata:
  creationTimestamp: "2019-09-13T13:58:47Z"
  labels:
    component: apiserver
    provider: kubernetes
  name: kubernetes
  namespace: default
  resourceVersion: "153"
  selfLink: /api/v1/namespaces/default/services/kubernetes
  uid: 9b1fac62-d62e-11e9-8968-00155d38010d
spec:
  clusterIP: 10.96.0.1
  ports:
  - name: https
    port: 443
    protocol: TCP
    targetPort: 6443
  sessionAffinity: None
  type: ClusterIP
status:
  loadBalancer: {}
```

<span data-ttu-id="7fa81-250">使用宣告式設定時，您可以使用`kubectl diff -f FOLDERNAME` ，針對設定檔所在的資料夾，先預覽將進行的變更。</span><span class="sxs-lookup"><span data-stu-id="7fa81-250">When using declarative configuration, you can preview the changes that will be made before committing them by using `kubectl diff -f FOLDERNAME` against the folder where your configuration files are located.</span></span> <span data-ttu-id="7fa81-251">一旦您確定要套用變更，請執行`kubectl apply -f FOLDERNAME`。</span><span class="sxs-lookup"><span data-stu-id="7fa81-251">Once you're sure you want to apply the changes, run `kubectl apply -f FOLDERNAME`.</span></span> <span data-ttu-id="7fa81-252">新增`-R`以遞迴方式處理資料夾階層。</span><span class="sxs-lookup"><span data-stu-id="7fa81-252">Add `-R` to recursively process a folder hierarchy.</span></span>

<span data-ttu-id="7fa81-253">您也可以搭配其他 Kubernetes 功能使用宣告式設定，其中一個是部署。</span><span class="sxs-lookup"><span data-stu-id="7fa81-253">You can also use declarative configuration with other Kubernetes features, one of which being deployments.</span></span> <span data-ttu-id="7fa81-254">宣告式部署有助於管理發行、更新和調整。</span><span class="sxs-lookup"><span data-stu-id="7fa81-254">Declarative deployments help manage releases, updates, and scaling.</span></span> <span data-ttu-id="7fa81-255">他們會指示 Kubernetes 部署控制器如何部署新的變更、向外延展負載，或復原到先前的修訂。</span><span class="sxs-lookup"><span data-stu-id="7fa81-255">They instruct the Kubernetes deployment controller on how to deploy new changes, scale out load, or roll back to a previous revision.</span></span> <span data-ttu-id="7fa81-256">如果叢集不穩定，宣告式部署會自動將叢集恢復為所需的狀態。</span><span class="sxs-lookup"><span data-stu-id="7fa81-256">If a cluster is unstable, a declarative deployment will automatically return the cluster back to a desired state.</span></span> <span data-ttu-id="7fa81-257">例如，如果節點應該當機，部署機制會重新部署取代以達到您想要的狀態</span><span class="sxs-lookup"><span data-stu-id="7fa81-257">For example, if a node should crash, the deployment mechanism will redeploy a replacement to achieve your desired state</span></span>

<span data-ttu-id="7fa81-258">使用宣告式設定可讓基礎結構以程式碼的形式來表示，並可簽入和設定版本。</span><span class="sxs-lookup"><span data-stu-id="7fa81-258">Using declarative configuration allows infrastructure to be represented as code that can be checked in and versioned alongside the application code.</span></span> <span data-ttu-id="7fa81-259">它針對使用組建和部署管線的持續部署提供改良的變更控制和更好的支援。</span><span class="sxs-lookup"><span data-stu-id="7fa81-259">It provides improved change control and better support for continuous deployment using a build and deploy pipeline.</span></span>

## <a name="what-scenarios-are-ideal-for-containers-and-orchestrators"></a><span data-ttu-id="7fa81-260">什麼是適用于容器和協調器的案例？</span><span class="sxs-lookup"><span data-stu-id="7fa81-260">What scenarios are ideal for containers and orchestrators?</span></span>

<span data-ttu-id="7fa81-261">下列案例適用于使用容器和協調器。</span><span class="sxs-lookup"><span data-stu-id="7fa81-261">The following scenarios are ideal for using containers and orchestrators.</span></span>

### <a name="applications-requiring-high-uptime-and-scalability"></a><span data-ttu-id="7fa81-262">需要高執行時間和擴充性的應用程式</span><span class="sxs-lookup"><span data-stu-id="7fa81-262">Applications requiring high uptime and scalability</span></span>

<span data-ttu-id="7fa81-263">具有高執行時間和擴充性需求的個別應用程式，是使用微服務、容器和協調器之雲端原生架構的理想候選項目。</span><span class="sxs-lookup"><span data-stu-id="7fa81-263">Individual applications that have high uptime and scalability requirements are ideal candidates for cloud-native architectures using microservices, containers, and orchestrators.</span></span> <span data-ttu-id="7fa81-264">它們可以在容器中開發、在已建立版本的環境中進行測試，以及部署到生產環境中零停機時間。</span><span class="sxs-lookup"><span data-stu-id="7fa81-264">They can be developed in containers, tested across versioned environments, and deployed into production with zero downtime.</span></span> <span data-ttu-id="7fa81-265">使用 Kubernetes 叢集可確保這類應用程式也可以根據需求進行調整，並自動從節點失敗中復原。</span><span class="sxs-lookup"><span data-stu-id="7fa81-265">The use of Kubernetes clusters ensures such apps can also scale on demand and recover automatically from node failures.</span></span>

### <a name="large-numbers-of-applications"></a><span data-ttu-id="7fa81-266">大量應用程式</span><span class="sxs-lookup"><span data-stu-id="7fa81-266">Large numbers of applications</span></span>

<span data-ttu-id="7fa81-267">部署和維護大量應用程式的組織會從容器和協調器獲益。</span><span class="sxs-lookup"><span data-stu-id="7fa81-267">Organizations that deploy and maintain large numbers of applications benefit from containers and orchestrators.</span></span> <span data-ttu-id="7fa81-268">設定容器化環境和 Kubernetes 叢集的前期工作，主要是固定成本。</span><span class="sxs-lookup"><span data-stu-id="7fa81-268">The up front effort of setting up containerized environments and Kubernetes clusters is primarily a fixed cost.</span></span> <span data-ttu-id="7fa81-269">部署、維護和更新個別應用程式的成本會因應用程式數目而異。</span><span class="sxs-lookup"><span data-stu-id="7fa81-269">Deploying, maintaining, and updating individual applications has a cost that varies with the number of applications.</span></span> <span data-ttu-id="7fa81-270">除了少數的應用程式之外，手動維護自訂應用程式的複雜性會超過使用容器和協調器來執行解決方案的成本。</span><span class="sxs-lookup"><span data-stu-id="7fa81-270">Beyond a small number of applications, the complexity of maintaining custom applications manually exceeds the cost of implementing a solution using containers and orchestrators.</span></span>

## <a name="when-should-you-avoid-using-containers-and-orchestrators"></a><span data-ttu-id="7fa81-271">何時應避免使用容器和協調器？</span><span class="sxs-lookup"><span data-stu-id="7fa81-271">When should you avoid using containers and orchestrators?</span></span>

<span data-ttu-id="7fa81-272">如果您無法遵循12個要素的應用程式原則來建立應用程式，您應該考慮避免容器和協調器。</span><span class="sxs-lookup"><span data-stu-id="7fa81-272">If you're unable to build your application following the Twelve-Factor App principles, you should consider avoiding containers and orchestrators.</span></span> <span data-ttu-id="7fa81-273">在這些情況下，請考慮以 VM 為基礎的裝載平臺，或可能是某些混合式系統。</span><span class="sxs-lookup"><span data-stu-id="7fa81-273">In these cases, consider a VM-based hosting platform, or possibly some hybrid system.</span></span> <span data-ttu-id="7fa81-274">有了這項功能，您就可以在不同的容器或甚至無伺服器的函式中，隨時關閉特定的功能。</span><span class="sxs-lookup"><span data-stu-id="7fa81-274">With it, you can always spin off certain pieces of functionality into separate containers or even serverless functions.</span></span>

## <a name="development-resources"></a><span data-ttu-id="7fa81-275">開發資源</span><span class="sxs-lookup"><span data-stu-id="7fa81-275">Development resources</span></span>

<span data-ttu-id="7fa81-276">本節顯示的開發資源簡短清單，可協助您開始使用容器和協調器來進行下一個應用程式。</span><span class="sxs-lookup"><span data-stu-id="7fa81-276">This section shows a short list of development resources that may help you get started using containers and orchestrators for your next application.</span></span> <span data-ttu-id="7fa81-277">如果您要尋找如何設計雲端原生微服務架構應用程式的指引，請閱讀這本書隨附的[.Net 微服務：容器化 .Net 應用程式的架構](https://dotnet.microsoft.com/download/thank-you/microservices-architecture-ebook)。</span><span class="sxs-lookup"><span data-stu-id="7fa81-277">If you're looking for guidance on how to design your cloud-native microservices architecture app, read this book's companion, [.NET Microservices: Architecture for Containerized .NET Applications](https://dotnet.microsoft.com/download/thank-you/microservices-architecture-ebook).</span></span>

### <a name="local-kubernetes-development"></a><span data-ttu-id="7fa81-278">本機 Kubernetes 開發</span><span class="sxs-lookup"><span data-stu-id="7fa81-278">Local Kubernetes Development</span></span>

<span data-ttu-id="7fa81-279">Kubernetes 部署在生產環境中提供絕佳價值，但也可以在您的開發電腦本機上執行。</span><span class="sxs-lookup"><span data-stu-id="7fa81-279">Kubernetes deployments provide great value in production environments, but can also run locally on your development machine.</span></span> <span data-ttu-id="7fa81-280">雖然您可以獨立處理個別的微服務，但有時您可能需要在本機執行整個系統，就像是在部署到生產環境時執行一樣。</span><span class="sxs-lookup"><span data-stu-id="7fa81-280">While you may work on individual microservices independently, there may be times when you'll need to run the entire system locally - just as it will run when deployed to production.</span></span> <span data-ttu-id="7fa81-281">有數個工具可以協助： Minikube 和 Docker Desktop。</span><span class="sxs-lookup"><span data-stu-id="7fa81-281">There are several tools that can help: Minikube and Docker Desktop.</span></span> <span data-ttu-id="7fa81-282">Visual Studio 也提供 Docker 開發的工具。</span><span class="sxs-lookup"><span data-stu-id="7fa81-282">Visual Studio also provides tooling for Docker development.</span></span>

### <a name="minikube"></a><span data-ttu-id="7fa81-283">Minikube</span><span class="sxs-lookup"><span data-stu-id="7fa81-283">Minikube</span></span>

<span data-ttu-id="7fa81-284">什麼是 Minikube？</span><span class="sxs-lookup"><span data-stu-id="7fa81-284">What is Minikube?</span></span> <span data-ttu-id="7fa81-285">Minikube 專案指出「Minikube 在 macOS、Linux 和 Windows 上執行本機 Kubernetes 叢集」。</span><span class="sxs-lookup"><span data-stu-id="7fa81-285">The Minikube project says "Minikube implements a local Kubernetes cluster on macOS, Linux, and Windows."</span></span> <span data-ttu-id="7fa81-286">其主要目標是「作為本機 Kubernetes 應用程式開發的最佳工具，並支援所有符合的 Kubernetes 功能」。</span><span class="sxs-lookup"><span data-stu-id="7fa81-286">Its primary goals are "to be the best tool for local Kubernetes application development and to support all Kubernetes features that fit."</span></span> <span data-ttu-id="7fa81-287">安裝 Minikube 與 Docker 分開，但是 Minikube 支援不同于 Docker Desktop 支援的虛擬機器。</span><span class="sxs-lookup"><span data-stu-id="7fa81-287">Installing Minikube is separate from Docker, but Minikube supports different hypervisors than Docker Desktop supports.</span></span> <span data-ttu-id="7fa81-288">Minikube 目前支援下列 Kubernetes 功能：</span><span class="sxs-lookup"><span data-stu-id="7fa81-288">The following Kubernetes features are currently supported by Minikube:</span></span>

- <span data-ttu-id="7fa81-289">DNS</span><span class="sxs-lookup"><span data-stu-id="7fa81-289">DNS</span></span>
- <span data-ttu-id="7fa81-290">NodePorts</span><span class="sxs-lookup"><span data-stu-id="7fa81-290">NodePorts</span></span>
- <span data-ttu-id="7fa81-291">ConfigMaps 和秘密</span><span class="sxs-lookup"><span data-stu-id="7fa81-291">ConfigMaps and secrets</span></span>
- <span data-ttu-id="7fa81-292">儀表板</span><span class="sxs-lookup"><span data-stu-id="7fa81-292">Dashboards</span></span>
- <span data-ttu-id="7fa81-293">容器執行時間： Docker、rkt、CRI-O 和 containerd</span><span class="sxs-lookup"><span data-stu-id="7fa81-293">Container runtimes: Docker, rkt, CRI-O, and containerd</span></span>
- <span data-ttu-id="7fa81-294">啟用容器網路介面（CNI）</span><span class="sxs-lookup"><span data-stu-id="7fa81-294">Enabling Container Network Interface (CNI)</span></span>
- <span data-ttu-id="7fa81-295">輸入</span><span class="sxs-lookup"><span data-stu-id="7fa81-295">Ingress</span></span>

<span data-ttu-id="7fa81-296">安裝 Minikube 之後，您可以執行`minikube start`命令快速開始使用它，這會下載映射並啟動本機 Kubernetes 叢集。</span><span class="sxs-lookup"><span data-stu-id="7fa81-296">After installing Minikube, you can quickly start using it by running the `minikube start` command, which downloads an image and start the local Kubernetes cluster.</span></span> <span data-ttu-id="7fa81-297">啟動叢集之後，您可以使用標準 Kubernetes `kubectl`命令與它互動。</span><span class="sxs-lookup"><span data-stu-id="7fa81-297">Once the cluster is started, you interact with it using the standard Kubernetes `kubectl` commands.</span></span>

### <a name="docker-desktop"></a><span data-ttu-id="7fa81-298">Docker Desktop</span><span class="sxs-lookup"><span data-stu-id="7fa81-298">Docker Desktop</span></span>

<span data-ttu-id="7fa81-299">您也可以直接從 Windows 上的 Docker Desktop 使用 Kubernetes。</span><span class="sxs-lookup"><span data-stu-id="7fa81-299">You can also work with Kubernetes directly from Docker Desktop on Windows.</span></span> <span data-ttu-id="7fa81-300">如果您使用的是 Windows 容器，這是您唯一的選擇，而且也是非 Windows 容器的絕佳選擇。</span><span class="sxs-lookup"><span data-stu-id="7fa81-300">It is your only option if you're using Windows Containers, and is a great choice for non-Windows containers as well.</span></span> <span data-ttu-id="7fa81-301">圖3-4 顯示如何在執行 Docker Desktop 時啟用本機 Kubernetes 支援。</span><span class="sxs-lookup"><span data-stu-id="7fa81-301">Figure 3-4 shows how to enable local Kubernetes support when running Docker Desktop.</span></span>

![在 Docker Desktop 中設定 Kubernetes](./media/docker-desktop-kubernetes.png)

<span data-ttu-id="7fa81-303">**圖 3-4**。</span><span class="sxs-lookup"><span data-stu-id="7fa81-303">**Figure 3-4**.</span></span> <span data-ttu-id="7fa81-304">在 Docker Desktop 中設定 Kubernetes。</span><span class="sxs-lookup"><span data-stu-id="7fa81-304">Configuring Kubernetes in Docker Desktop.</span></span>

<span data-ttu-id="7fa81-305">Docker Desktop 是最受歡迎的工具，可在本機設定和執行容器化應用程式。</span><span class="sxs-lookup"><span data-stu-id="7fa81-305">Docker Desktop is the most popular tool for configuring and running containerized apps locally.</span></span> <span data-ttu-id="7fa81-306">當您使用 Docker Desktop 時，可以針對您要部署到生產環境的完全相同 Docker 容器映射，在本機進行開發。</span><span class="sxs-lookup"><span data-stu-id="7fa81-306">When you work with Docker Desktop, you can develop locally against the exact same set of Docker container images that you'll deploy to production.</span></span> <span data-ttu-id="7fa81-307">Docker Desktop 是設計成在本機「建立、測試及傳送」容器化應用程式。</span><span class="sxs-lookup"><span data-stu-id="7fa81-307">Docker Desktop is designed to "build, test, and ship" containerized apps locally.</span></span> <span data-ttu-id="7fa81-308">它同時支援 Linux 和 Windows 容器。</span><span class="sxs-lookup"><span data-stu-id="7fa81-308">It supports both Linux and Windows containers.</span></span> <span data-ttu-id="7fa81-309">一旦您將映射推送至映射登錄（例如 Azure Container Registry 或 Docker Hub），AKS 就可以提取並部署到生產環境。</span><span class="sxs-lookup"><span data-stu-id="7fa81-309">Once you push your images to an image registry, like Azure Container Registry or Docker Hub, AKS can pull and deploy them to production.</span></span>

### <a name="visual-studio-docker-tooling"></a><span data-ttu-id="7fa81-310">Visual Studio Docker 工具</span><span class="sxs-lookup"><span data-stu-id="7fa81-310">Visual Studio Docker Tooling</span></span>

<span data-ttu-id="7fa81-311">Visual Studio 支援以 web 應用程式為基礎的 Docker 開發。</span><span class="sxs-lookup"><span data-stu-id="7fa81-311">Visual Studio supports Docker development for web-based applications.</span></span> <span data-ttu-id="7fa81-312">當您建立新的 ASP.NET Core 應用程式時，您可以選擇使用 Docker 支援來設定它，如圖3-5 所示。</span><span class="sxs-lookup"><span data-stu-id="7fa81-312">When you create a new ASP.NET Core application, you have an option to configure it with Docker support, as shown in Figure 3-5.</span></span>

![Visual Studio 啟用 Docker 支援](./media/visual-studio-enable-docker-support.png)

<span data-ttu-id="7fa81-314">**圖 3-5**。</span><span class="sxs-lookup"><span data-stu-id="7fa81-314">**Figure 3-5**.</span></span> <span data-ttu-id="7fa81-315">Visual Studio 啟用 Docker 支援</span><span class="sxs-lookup"><span data-stu-id="7fa81-315">Visual Studio Enable Docker Support</span></span>

<span data-ttu-id="7fa81-316">選取此選項時，會使用其根目錄`Dockerfile`中的建立專案，這可用來在 Docker 容器中建立和裝載應用程式。</span><span class="sxs-lookup"><span data-stu-id="7fa81-316">When this option is selected, the project is created with a `Dockerfile` in its root, which can be used to build and host the app in a Docker container.</span></span> <span data-ttu-id="7fa81-317">範例 Dockerfile 如 [圖 3]-6 所示。</span><span class="sxs-lookup"><span data-stu-id="7fa81-317">An example Dockerfile is shown in Figure 3-6.git</span></span>

```docker
FROM mcr.microsoft.com/dotnet/core/aspnet:3.0-stretch-slim AS base
WORKDIR /app
EXPOSE 80
EXPOSE 443

FROM mcr.microsoft.com/dotnet/core/sdk:3.0-stretch AS build
WORKDIR /src
COPY ["WebApplication3/WebApplication3.csproj", "WebApplication3/"]
RUN dotnet restore "WebApplication3/WebApplication3.csproj"
COPY . .
WORKDIR "/src/WebApplication3"
RUN dotnet build "WebApplication3.csproj" -c Release -o /app

FROM build AS publish
RUN dotnet publish "WebApplication3.csproj" -c Release -o /app

FROM base AS final
WORKDIR /app
COPY --from=publish /app .
ENTRYPOINT ["dotnet", "WebApplication3.dll"]
```

<span data-ttu-id="7fa81-318">**圖 3-6**。</span><span class="sxs-lookup"><span data-stu-id="7fa81-318">**Figure 3-6**.</span></span> <span data-ttu-id="7fa81-319">Visual Studio 產生的 Dockerfile</span><span class="sxs-lookup"><span data-stu-id="7fa81-319">Visual Studio generated Dockerfile</span></span>

<span data-ttu-id="7fa81-320">應用程式執行時的預設行為也會設定為使用 Docker。</span><span class="sxs-lookup"><span data-stu-id="7fa81-320">The default behavior when the app runs is configured to use Docker as well.</span></span> <span data-ttu-id="7fa81-321">圖3-7 顯示新的 ASP.NET Core 專案提供的不同執行選項，並已新增 Docker 支援。</span><span class="sxs-lookup"><span data-stu-id="7fa81-321">Figure 3-7 shows the different run options available from a new ASP.NET Core project created with Docker support added.</span></span>

![Visual Studio Docker 執行選項](./media/visual-studio-docker-run-options.png)

<span data-ttu-id="7fa81-323">**圖 3-7**。</span><span class="sxs-lookup"><span data-stu-id="7fa81-323">**Figure 3-7**.</span></span> <span data-ttu-id="7fa81-324">Visual Studio Docker 執行選項</span><span class="sxs-lookup"><span data-stu-id="7fa81-324">Visual Studio Docker Run Options</span></span>

<span data-ttu-id="7fa81-325">除了本機開發以外， [Azure Dev Spaces](https://docs.microsoft.com/azure/dev-spaces/)提供便利的方式讓多個開發人員在 Azure 內使用自己的 Kubernetes 設定。</span><span class="sxs-lookup"><span data-stu-id="7fa81-325">In addition to local development, [Azure Dev Spaces](https://docs.microsoft.com/azure/dev-spaces/) provides a convenient way for multiple developers to work with their own Kubernetes configurations within Azure.</span></span> <span data-ttu-id="7fa81-326">如 [圖 3-7] 所示，您也可以在 Azure Dev Spaces 中執行應用程式。</span><span class="sxs-lookup"><span data-stu-id="7fa81-326">As you can see in Figure 3-7, you can also run the application in Azure Dev Spaces.</span></span>

<span data-ttu-id="7fa81-327">此外，您隨時都可以將 Docker 支援新增至現有的 ASP.NET Core 應用程式。</span><span class="sxs-lookup"><span data-stu-id="7fa81-327">Also, at any time you can add Docker support to an existing ASP.NET Core application.</span></span> <span data-ttu-id="7fa81-328">在 [Visual Studio 方案總管中，以滑鼠右鍵按一下專案並**新增** > **Docker 支援**，如圖3-8 所示。</span><span class="sxs-lookup"><span data-stu-id="7fa81-328">From the Visual Studio Solution Explorer, right click on the project and **Add** > **Docker Support**, as shown in Figure 3-8.</span></span>

<span data-ttu-id="7fa81-329">**圖 3-8**。</span><span class="sxs-lookup"><span data-stu-id="7fa81-329">**Figure 3-8**.</span></span> <span data-ttu-id="7fa81-330">將 Docker 支援新增至 Visual Studio</span><span class="sxs-lookup"><span data-stu-id="7fa81-330">Adding Docker support to Visual Studio</span></span>

<span data-ttu-id="7fa81-331">您也可以新增容器協調流程支援，如圖3-8 所示。</span><span class="sxs-lookup"><span data-stu-id="7fa81-331">You can also add Container Orchestration Support, also shown in Figure 3-8.</span></span> <span data-ttu-id="7fa81-332">根據預設，orchestrator 會使用 Kubernetes 和 Helm。</span><span class="sxs-lookup"><span data-stu-id="7fa81-332">By default, the orchestrator uses Kubernetes and Helm.</span></span> <span data-ttu-id="7fa81-333">一旦您選擇協調器， `azds.yaml`檔案就會新增至專案根目錄，並加入一個`charts`資料夾，其中包含用來設定和部署應用程式至 Kubernetes 的 Helm 圖表。</span><span class="sxs-lookup"><span data-stu-id="7fa81-333">Once you've chosen the orchestrator, a `azds.yaml` file is added to the project root and a `charts` folder is added containing the Helm charts used to configure and deploy the application to Kubernetes.</span></span> <span data-ttu-id="7fa81-334">圖3-9 顯示新專案中產生的檔案。</span><span class="sxs-lookup"><span data-stu-id="7fa81-334">Figure 3-9 shows the resulting files in a new project.</span></span>

<span data-ttu-id="7fa81-335">您也可以新增容器協調流程支援，如圖3-8 所示。</span><span class="sxs-lookup"><span data-stu-id="7fa81-335">You can also add Container Orchestration Support, also shown in Figure 3-8.</span></span> <span data-ttu-id="7fa81-336">根據預設，orchestrator 會使用 Kubernetes 和 Helm。</span><span class="sxs-lookup"><span data-stu-id="7fa81-336">By default, the orchestrator uses Kubernetes and Helm.</span></span> <span data-ttu-id="7fa81-337">一旦您選擇協調器， `azds.yaml`檔案就會新增至專案根目錄，並加入一個`charts`資料夾，其中包含用來設定和部署應用程式至 Kubernetes 的 Helm 圖表。</span><span class="sxs-lookup"><span data-stu-id="7fa81-337">Once you've chosen the orchestrator, a `azds.yaml` file is added to the project root and a `charts` folder is added containing the Helm charts used to configure and deploy the application to Kubernetes.</span></span> <span data-ttu-id="7fa81-338">圖3-9 顯示新專案中產生的檔案。</span><span class="sxs-lookup"><span data-stu-id="7fa81-338">Figure 3-9 shows the resulting files in a new project.</span></span>

<span data-ttu-id="7fa81-339">**圖 3-9**。</span><span class="sxs-lookup"><span data-stu-id="7fa81-339">**Figure 3-9**.</span></span> <span data-ttu-id="7fa81-340">將協調流程支援新增至 Visual Studio</span><span class="sxs-lookup"><span data-stu-id="7fa81-340">Adding orchestration support to Visual Studio</span></span>

### <a name="visual-studio-code-docker-tooling"></a><span data-ttu-id="7fa81-341">Visual Studio Code Docker 工具</span><span class="sxs-lookup"><span data-stu-id="7fa81-341">Visual Studio Code Docker Tooling</span></span>

<span data-ttu-id="7fa81-342">有一些擴充功能可用於支援 Docker 開發的 Visual Studio Code。</span><span class="sxs-lookup"><span data-stu-id="7fa81-342">There are a number of extensions available for Visual Studio Code that support Docker development.</span></span>

<span data-ttu-id="7fa81-343">Microsoft 提供[Docker for Visual Studio Code 延伸](https://marketplace.visualstudio.com/items?itemName=ms-azuretools.vscode-docker)模組。</span><span class="sxs-lookup"><span data-stu-id="7fa81-343">Microsoft provides the [Docker for Visual Studio Code extension](https://marketplace.visualstudio.com/items?itemName=ms-azuretools.vscode-docker).</span></span> <span data-ttu-id="7fa81-344">此延伸模組可簡化將容器支援新增至應用程式的過程。</span><span class="sxs-lookup"><span data-stu-id="7fa81-344">This extension simplifies the process of adding container support to applications.</span></span> <span data-ttu-id="7fa81-345">它會 scaffold 所需的檔案、建立 Docker 映射，並可讓您在容器內對應用程式進行調試。</span><span class="sxs-lookup"><span data-stu-id="7fa81-345">It scaffolds required files, builds Docker images, and enables you to debug your app inside a container.</span></span> <span data-ttu-id="7fa81-346">延伸模組具備視覺化瀏覽器的功能，可讓您輕鬆地對容器和映射採取動作，例如啟動、停止、檢查、移除等等。</span><span class="sxs-lookup"><span data-stu-id="7fa81-346">The extension features a visual explorer that makes it easy to take actions on containers and images such as start, stop, inspect, remove, and more.</span></span> <span data-ttu-id="7fa81-347">延伸模組也支援 Docker Compose 可讓您將多個執行中的容器當做單一單位來管理。</span><span class="sxs-lookup"><span data-stu-id="7fa81-347">The extension also supports Docker Compose enabling you to manage multiple running containers as a single unit.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="7fa81-348">[上一頁](scale-applications.md)
>[下一頁](leverage-serverless-functions.md)</span><span class="sxs-lookup"><span data-stu-id="7fa81-348">[Previous](scale-applications.md)
[Next](leverage-serverless-functions.md)</span></span>
