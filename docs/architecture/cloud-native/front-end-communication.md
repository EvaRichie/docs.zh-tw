---
title: 前端用戶端通訊
description: 瞭解前端用戶端如何與雲端原生系統通訊
author: robvet
ms.date: 09/08/2019
ms.openlocfilehash: 89f13ea1c9ecbe92e959ae63a4c21bf7775f8943
ms.sourcegitcommit: 957c49696eaf048c284ef8f9f8ffeb562357ad95
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 05/07/2020
ms.locfileid: "82895579"
---
# <a name="front-end-client-communication"></a><span data-ttu-id="0ff4f-103">前端用戶端通訊</span><span class="sxs-lookup"><span data-stu-id="0ff4f-103">Front-end client communication</span></span>

[!INCLUDE [book-preview](../../../includes/book-preview.md)]

<span data-ttu-id="0ff4f-104">在雲端原生系統中，前端用戶端（行動裝置、web 和桌面應用程式）需要通道，才能與獨立的後端微服務互動。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-104">In a cloud-native system, front-end clients (mobile, web, and desktop applications) require a communication channel to interact with independent back-end microservices.</span></span>  

<span data-ttu-id="0ff4f-105">選項有哪些？</span><span class="sxs-lookup"><span data-stu-id="0ff4f-105">What are the options?</span></span>

<span data-ttu-id="0ff4f-106">為了簡單起見，前端用戶端可以直接與後端微服務*通訊*，如圖4-2 所示。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-106">To keep things simple, a front-end client could *directly communicate* with the back-end microservices, shown in Figure 4-2.</span></span>

![直接用戶端對服務的通訊](./media/direct-client-to-service-communication.png)

<span data-ttu-id="0ff4f-108">**圖4-2。**</span><span class="sxs-lookup"><span data-stu-id="0ff4f-108">**Figure 4-2.**</span></span> <span data-ttu-id="0ff4f-109">直接用戶端對服務的通訊</span><span class="sxs-lookup"><span data-stu-id="0ff4f-109">Direct client to service communication</span></span>

<span data-ttu-id="0ff4f-110">使用此方法時，每個微服務都有一個可由前端用戶端存取的公用端點。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-110">With this approach, each microservice has a public endpoint that is accessible by front-end clients.</span></span> <span data-ttu-id="0ff4f-111">在生產環境中，您會將負載平衡器放在微服務的前方，以按比例路由傳送流量。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-111">In a production environment, you'd place a load balancer in front of the microservices, routing traffic proportionately.</span></span>

<span data-ttu-id="0ff4f-112">雖然簡單的執行，但只有簡單的微服務應用程式可接受直接用戶端通訊。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-112">While simple to implement, direct client communication would be acceptable only for simple microservice applications.</span></span> <span data-ttu-id="0ff4f-113">此模式會將前端用戶端與核心後端服務緊密結合，針對許多問題開啟門，包括：</span><span class="sxs-lookup"><span data-stu-id="0ff4f-113">This pattern tightly couples front-end clients to core back-end services, opening the door for a number of problems, including:</span></span>

- <span data-ttu-id="0ff4f-114">用戶端對後端服務重構的敏感程度。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-114">Client susceptibility to back-end service refactoring.</span></span>
- <span data-ttu-id="0ff4f-115">隨著核心後端服務直接公開，會有更大的受攻擊面。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-115">A wider attack surface as core back-end services are directly exposed.</span></span>
- <span data-ttu-id="0ff4f-116">每個微服務的跨領域考慮重複。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-116">Duplication of cross-cutting concerns across each microservice.</span></span>
- <span data-ttu-id="0ff4f-117">過於複雜的用戶端程式代碼-用戶端必須追蹤多個端點，並以彈性的方式處理失敗。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-117">Overly complex client code - clients must keep track of multiple endpoints and handle failures in a resilient way.</span></span>

<span data-ttu-id="0ff4f-118">相反地，廣為接受的雲端設計模式是在前端應用程式與後端服務之間執行[API 閘道服務](../microservices/architect-microservice-container-applications/direct-client-to-microservice-communication-versus-the-api-gateway-pattern.md)。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-118">Instead, a widely accepted cloud design pattern is to implement an [API Gateway Service](../microservices/architect-microservice-container-applications/direct-client-to-microservice-communication-versus-the-api-gateway-pattern.md) between the front-end applications and back-end services.</span></span> <span data-ttu-id="0ff4f-119">模式如圖4-3 所示。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-119">The pattern is shown in Figure 4-3.</span></span>

![API 閘道模式](./media/api-gateway-pattern.png)

<span data-ttu-id="0ff4f-121">**圖4-3。**</span><span class="sxs-lookup"><span data-stu-id="0ff4f-121">**Figure 4-3.**</span></span> <span data-ttu-id="0ff4f-122">API 閘道模式</span><span class="sxs-lookup"><span data-stu-id="0ff4f-122">API gateway pattern</span></span>

<span data-ttu-id="0ff4f-123">在上圖中，請注意 API 閘道服務如何抽象化後端核心微服務。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-123">In the previous figure, note how the API Gateway service abstracts the back-end core microservices.</span></span> <span data-ttu-id="0ff4f-124">實作為 Web API，它會作為*反向 proxy*，將連入流量路由傳送至內部微服務。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-124">Implemented as a web API, it acts as a *reverse proxy*, routing incoming traffic to the internal microservices.</span></span>

<span data-ttu-id="0ff4f-125">閘道會將用戶端與內部服務分割和重構隔離。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-125">The gateway insulates the client from internal service partitioning and refactoring.</span></span> <span data-ttu-id="0ff4f-126">如果您變更後端服務，您可以在閘道上容納它，而不會中斷用戶端。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-126">If you change a back-end service, you accommodate for it in the gateway without breaking the client.</span></span> <span data-ttu-id="0ff4f-127">這也是您跨領域考慮的第一道防線，例如身分識別、快取、復原、計量和節流。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-127">It's also your first line of defense for cross-cutting concerns, such as identity, caching, resiliency, metering, and throttling.</span></span> <span data-ttu-id="0ff4f-128">許多跨領域關注都可以從後端核心服務關閉到閘道，簡化後端服務。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-128">Many of these cross-cutting concerns can be off-loaded from the back-end core services to the gateway, simplifying the back-end services.</span></span>

<span data-ttu-id="0ff4f-129">請務必小心，讓 API 閘道保持簡單且快速。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-129">Care must be taken to keep the API Gateway simple and fast.</span></span> <span data-ttu-id="0ff4f-130">一般而言，商務邏輯會保留在閘道外。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-130">Typically, business logic is kept out of the gateway.</span></span> <span data-ttu-id="0ff4f-131">複雜的閘道風險成為瓶頸，最後是單體本身。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-131">A complex gateway risks becoming a bottleneck and eventually a monolith itself.</span></span> <span data-ttu-id="0ff4f-132">較大的系統通常會公開多個以用戶端類型（行動、web、桌面）或後端功能分割的 API 閘道。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-132">Larger systems often expose multiple API Gateways segmented by client type (mobile, web, desktop) or back-end functionality.</span></span> <span data-ttu-id="0ff4f-133">前端模式的[後端](https://docs.microsoft.com/azure/architecture/patterns/backends-for-frontends)提供了執行多個閘道的方向。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-133">The [Backend for Frontends](https://docs.microsoft.com/azure/architecture/patterns/backends-for-frontends) pattern provides direction for implementing multiple gateways.</span></span> <span data-ttu-id="0ff4f-134">模式如圖4-4 所示。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-134">The pattern is shown in Figure 4-4.</span></span>

![API 閘道模式](./media/backend-for-frontend-pattern.png)

<span data-ttu-id="0ff4f-136">**圖4-4。**</span><span class="sxs-lookup"><span data-stu-id="0ff4f-136">**Figure 4-4.**</span></span> <span data-ttu-id="0ff4f-137">前端模式的後端</span><span class="sxs-lookup"><span data-stu-id="0ff4f-137">Backend for frontend pattern</span></span>

<span data-ttu-id="0ff4f-138">請注意，上圖中的連入流量如何根據用戶端類型（web、行動或桌面應用程式）傳送至特定 API 閘道。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-138">Note in the previous figure how incoming traffic is sent to a specific API gateway - based upon client type: web, mobile, or desktop app.</span></span> <span data-ttu-id="0ff4f-139">這種方法很合理，因為每個裝置的功能在外型規格、效能和顯示限制方面都有顯著的差異。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-139">This approach makes sense as the capabilities of each device differ significantly across form factor, performance, and display limitations.</span></span> <span data-ttu-id="0ff4f-140">行動應用程式通常會比瀏覽器或桌面應用程式公開較少的功能。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-140">Typically mobile applications expose less functionality than a browser or desktop applications.</span></span> <span data-ttu-id="0ff4f-141">每個閘道都可以進行優化，以符合對應裝置的功能和功能。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-141">Each gateway can be optimized to match the capabilities and functionality of the corresponding device.</span></span>

<span data-ttu-id="0ff4f-142">若要開始，您可以建立自己的 API 閘道服務。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-142">To start, you could build your own API Gateway service.</span></span> <span data-ttu-id="0ff4f-143">GitHub 的快速搜尋將提供許多範例。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-143">A quick search of GitHub will provide many examples.</span></span> <span data-ttu-id="0ff4f-144">不過，有數個架構和商業網關產品可供使用。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-144">However, there are several frameworks and commercial gateway products available.</span></span>

## <a name="ocelot-gateway"></a><span data-ttu-id="0ff4f-145">Ocelot 閘道</span><span class="sxs-lookup"><span data-stu-id="0ff4f-145">Ocelot Gateway</span></span>

<span data-ttu-id="0ff4f-146">針對簡單的 .NET 雲端原生應用程式，您可以考慮[Ocelot 閘道](https://github.com/ThreeMammals/Ocelot)。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-146">For simple .NET cloud-native applications, you might consider the [Ocelot Gateway](https://github.com/ThreeMammals/Ocelot).</span></span> <span data-ttu-id="0ff4f-147">Ocelot 是針對 .NET 微服務所建立的開放原始碼 API 閘道，需要在其系統中整合進入點。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-147">Ocelot is an Open Source API Gateway created for .NET microservices that require a unified point of entry into their system.</span></span> <span data-ttu-id="0ff4f-148">它是輕量、快速、可調整的。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-148">It's lightweight, fast, scalable.</span></span>

<span data-ttu-id="0ff4f-149">就像任何 API 閘道，其主要功能是將傳入的 HTTP 要求轉送到下游服務。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-149">Like any API Gateway, its primary functionality is to forward incoming HTTP requests to downstream services.</span></span> <span data-ttu-id="0ff4f-150">此外，它也支援可在 .NET Core 中介軟體管線中設定的各種功能。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-150">Additionally, it supports a wide variety of capabilities that are configurable in a .NET Core middleware pipeline.</span></span> <span data-ttu-id="0ff4f-151">下表提供其功能集。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-151">Its feature set is presented in following table.</span></span>

|<span data-ttu-id="0ff4f-152">Ocelot 功能</span><span class="sxs-lookup"><span data-stu-id="0ff4f-152">Ocelot Features</span></span>  | |
| :-------- | :-------- |
| <span data-ttu-id="0ff4f-153">路由</span><span class="sxs-lookup"><span data-stu-id="0ff4f-153">Routing</span></span> | <span data-ttu-id="0ff4f-154">驗證</span><span class="sxs-lookup"><span data-stu-id="0ff4f-154">Authentication</span></span> |
| <span data-ttu-id="0ff4f-155">要求匯總</span><span class="sxs-lookup"><span data-stu-id="0ff4f-155">Request Aggregation</span></span> | <span data-ttu-id="0ff4f-156">授權</span><span class="sxs-lookup"><span data-stu-id="0ff4f-156">Authorization</span></span> |
| <span data-ttu-id="0ff4f-157">服務探索（使用 Consul 和 Eureka）</span><span class="sxs-lookup"><span data-stu-id="0ff4f-157">Service Discovery (with Consul and Eureka)</span></span> | <span data-ttu-id="0ff4f-158">節流</span><span class="sxs-lookup"><span data-stu-id="0ff4f-158">Throttling</span></span> |
| <span data-ttu-id="0ff4f-159">負載平衡</span><span class="sxs-lookup"><span data-stu-id="0ff4f-159">Load Balancing</span></span> | <span data-ttu-id="0ff4f-160">記錄，追蹤</span><span class="sxs-lookup"><span data-stu-id="0ff4f-160">Logging, Tracing</span></span> |
| <span data-ttu-id="0ff4f-161">Caching</span><span class="sxs-lookup"><span data-stu-id="0ff4f-161">Caching</span></span> | <span data-ttu-id="0ff4f-162">標頭/查詢字串轉換</span><span class="sxs-lookup"><span data-stu-id="0ff4f-162">Headers/Query String Transformation</span></span> |
| <span data-ttu-id="0ff4f-163">相互關聯傳遞</span><span class="sxs-lookup"><span data-stu-id="0ff4f-163">Correlation Pass-Through</span></span> | <span data-ttu-id="0ff4f-164">自訂中介軟體</span><span class="sxs-lookup"><span data-stu-id="0ff4f-164">Custom Middleware</span></span> |
| <span data-ttu-id="0ff4f-165">服務品質</span><span class="sxs-lookup"><span data-stu-id="0ff4f-165">Quality of Service</span></span> | <span data-ttu-id="0ff4f-166">重試原則</span><span class="sxs-lookup"><span data-stu-id="0ff4f-166">Retry Policies</span></span> |

<span data-ttu-id="0ff4f-167">每個 Ocelot 閘道都會在 JSON 設定檔中指定上游和下游位址，以及可設定的功能。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-167">Each Ocelot gateway specifies the upstream and downstream addresses and configurable features in a JSON configuration file.</span></span> <span data-ttu-id="0ff4f-168">用戶端會將 HTTP 要求傳送至 Ocelot 閘道。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-168">The client sends an HTTP request to the Ocelot gateway.</span></span> <span data-ttu-id="0ff4f-169">一旦收到，Ocelot 會透過其管線將 HttpRequest 物件傳遞至其設定所指定的狀態。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-169">Once received, Ocelot passes the HttpRequest object through its pipeline manipulating it into the state specified by its configuration.</span></span> <span data-ttu-id="0ff4f-170">在管線的結尾，Ocelot 會建立新的 HTTPResponseObject，並將它傳遞至下游服務。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-170">At the end of pipeline, Ocelot creates a new HTTPResponseObject and passes it to the downstream service.</span></span> <span data-ttu-id="0ff4f-171">針對回應，Ocelot 會反轉管線，並將回應傳回給用戶端。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-171">For the response, Ocelot reverses the pipeline, sending the response back to client.</span></span>

<span data-ttu-id="0ff4f-172">Ocelot 是以 NuGet 套件的形式提供。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-172">Ocelot is available as a NuGet package.</span></span> <span data-ttu-id="0ff4f-173">其以 NET Standard 2.0 為目標，使其與 .NET Core 2.0 + 和 .NET Framework 4.6.1 + 執行時間相容。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-173">It targets the NET Standard 2.0, making it compatible with both .NET Core 2.0+ and .NET Framework 4.6.1+ runtimes.</span></span> <span data-ttu-id="0ff4f-174">Ocelot 與在 .NET Core 支援的平臺（Linux、macOS 和 Windows）上說 HTTP 並執行的任何專案整合。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-174">Ocelot integrates with anything that speaks HTTP and runs on the platforms which .NET Core supports: Linux, macOS, and Windows.</span></span> <span data-ttu-id="0ff4f-175">Ocelot 是可擴充的，可支援許多現代化平臺，包括 Docker 容器、Azure Kubernetes Services 或其他公用雲端。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-175">Ocelot is extensible and supports many modern platforms, including Docker containers, Azure Kubernetes Services, or other public clouds.</span></span>  <span data-ttu-id="0ff4f-176">Ocelot 整合了開放原始碼套件，例如[Consul](https://www.consul.io)、 [GraphQL](https://graphql.org)和 Netflix 的[Eureka](https://github.com/Netflix/eureka)。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-176">Ocelot integrates with open-source packages like [Consul](https://www.consul.io), [GraphQL](https://graphql.org), and Netflix's [Eureka](https://github.com/Netflix/eureka).</span></span>

<span data-ttu-id="0ff4f-177">針對不需要商用 API 閘道豐富功能集的簡單雲端原生應用程式，請考慮使用 Ocelot。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-177">Consider Ocelot for simple cloud-native applications that don't require the rich feature-set of a commercial API gateway.</span></span>

## <a name="azure-application-gateway"></a><span data-ttu-id="0ff4f-178">Azure 應用程式閘道</span><span class="sxs-lookup"><span data-stu-id="0ff4f-178">Azure Application Gateway</span></span>

<span data-ttu-id="0ff4f-179">針對簡單的閘道需求，您可以考慮[Azure 應用程式閘道](https://docs.microsoft.com/azure/application-gateway/overview)。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-179">For simple gateway requirements, you may consider [Azure Application Gateway](https://docs.microsoft.com/azure/application-gateway/overview).</span></span> <span data-ttu-id="0ff4f-180">以 Azure [PaaS 服務](https://azure.microsoft.com/overview/what-is-paas/)的形式提供，其中包含基本的閘道功能，例如 URL 路由、SSL 終止和 Web 應用程式防火牆。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-180">Available as an Azure [PaaS service](https://azure.microsoft.com/overview/what-is-paas/), it includes basic gateway features such as URL routing, SSL termination, and a Web Application Firewall.</span></span> <span data-ttu-id="0ff4f-181">此服務支援[第7層負載平衡](https://www.nginx.com/resources/glossary/layer-7-load-balancing/)功能。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-181">The service supports [Layer-7 load balancing](https://www.nginx.com/resources/glossary/layer-7-load-balancing/) capabilities.</span></span> <span data-ttu-id="0ff4f-182">有了第7層，您可以根據 HTTP 訊息的實際內容來路由傳送要求，而不只是低層級的 TCP 網路封包。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-182">With Layer 7, you can route requests based on the actual content of an HTTP message, not just low-level TCP network packets.</span></span>

<span data-ttu-id="0ff4f-183">在本書中，我們宣導了在[Kubernetes](https://www.infoworld.com/article/3268073/what-is-kubernetes-your-next-application-platform.html)中裝載雲端原生系統的功能。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-183">Throughout this book, we evangelize hosting cloud-native systems in [Kubernetes](https://www.infoworld.com/article/3268073/what-is-kubernetes-your-next-application-platform.html).</span></span> <span data-ttu-id="0ff4f-184">容器協調器，Kubernetes 會將容器化工作負載的部署、調整和操作方面的顧慮自動化。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-184">A container orchestrator, Kubernetes automates the deployment, scaling, and operational concerns of containerized workloads.</span></span> <span data-ttu-id="0ff4f-185">Azure 應用程式閘道可以設定為[Azure Kubernetes Service](https://azure.microsoft.com/services/kubernetes-service/)叢集的 API 閘道。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-185">Azure Application Gateway can be configured as an API gateway for [Azure Kubernetes Service](https://azure.microsoft.com/services/kubernetes-service/) cluster.</span></span>

<span data-ttu-id="0ff4f-186">[應用程式閘道輸入控制器](https://azure.github.io/application-gateway-kubernetes-ingress/)可讓 Azure 應用程式閘道直接與[Azure Kubernetes Service](https://azure.microsoft.com/services/kubernetes-service/)搭配使用。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-186">The [Application Gateway Ingress Controller](https://azure.github.io/application-gateway-kubernetes-ingress/) enables Azure Application Gateway to work directly with [Azure Kubernetes Service](https://azure.microsoft.com/services/kubernetes-service/).</span></span> <span data-ttu-id="0ff4f-187">圖4.5 顯示架構。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-187">Figure 4.5 shows the architecture.</span></span>

![應用程式閘道輸入控制器](./media/application-gateway-ingress-controller.png)

<span data-ttu-id="0ff4f-189">**圖4-5。**</span><span class="sxs-lookup"><span data-stu-id="0ff4f-189">**Figure 4-5.**</span></span> <span data-ttu-id="0ff4f-190">應用程式閘道輸入控制器</span><span class="sxs-lookup"><span data-stu-id="0ff4f-190">Application Gateway Ingress Controller</span></span>

<span data-ttu-id="0ff4f-191">Kubernetes 包含支援 HTTP （層級7）負載平衡的內建功能[，稱為「](https://kubernetes.io/docs/concepts/services-networking/ingress/)輸入」。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-191">Kubernetes includes a built-in feature that supports HTTP (Level 7) load balancing, called [Ingress](https://kubernetes.io/docs/concepts/services-networking/ingress/).</span></span> <span data-ttu-id="0ff4f-192">輸入會定義一組規則，以說明如何將 AKS 內的微服務實例公開給外部世界。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-192">Ingress defines a set of rules for how microservice instances inside AKS can be exposed to the outside world.</span></span> <span data-ttu-id="0ff4f-193">在上一個映射中，輸入控制器會解讀為叢集設定的輸入規則，並自動設定 Azure 應用程式閘道。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-193">In the previous image, the ingress controller interprets the ingress rules configured for the cluster and automatically configures the Azure Application Gateway.</span></span> <span data-ttu-id="0ff4f-194">根據這些規則，應用程式閘道會將流量路由傳送至在 AKS 內執行的微服務。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-194">Based on those rules, the Application Gateway routes traffic to microservices running inside AKS.</span></span> <span data-ttu-id="0ff4f-195">輸入控制器會接聽輸入規則的變更，並對 Azure 應用程式閘道進行適當的變更。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-195">The ingress controller listens for changes to ingress rules and makes the appropriate changes to the Azure Application Gateway.</span></span>

## <a name="azure-api-management"></a><span data-ttu-id="0ff4f-196">Azure API 管理</span><span class="sxs-lookup"><span data-stu-id="0ff4f-196">Azure API Management</span></span>

<span data-ttu-id="0ff4f-197">針對適中到大規模的雲端原生系統，您可以考慮[AZURE API 管理](https://azure.microsoft.com/services/api-management/)。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-197">For moderate to large-scale cloud-native systems, you may consider [Azure API Management](https://azure.microsoft.com/services/api-management/).</span></span> <span data-ttu-id="0ff4f-198">這是一種雲端式服務，不僅能解決您的 API 閘道需求，還提供功能完整的開發人員和系統管理體驗。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-198">It's a cloud-based service that not only solves your API Gateway needs, but provides a full-featured developer and administrative experience.</span></span> <span data-ttu-id="0ff4f-199">API 管理如圖4-6 所示。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-199">API Management is shown in Figure 4-6.</span></span>

![Azure API 管理](./media/azure-api-management.png)

<span data-ttu-id="0ff4f-201">**圖4-6。**</span><span class="sxs-lookup"><span data-stu-id="0ff4f-201">**Figure 4-6.**</span></span> <span data-ttu-id="0ff4f-202">Azure API 管理</span><span class="sxs-lookup"><span data-stu-id="0ff4f-202">Azure API Management</span></span>

<span data-ttu-id="0ff4f-203">若要開始，API 管理會公開閘道伺服器，讓您可以根據可設定的規則和原則來控制後端服務的存取權。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-203">To start, API Management exposes a gateway server that allows controlled access to back-end services based upon configurable rules and policies.</span></span> <span data-ttu-id="0ff4f-204">這些服務可以在 Azure 雲端、您的內部內部部署資料中心或其他公用雲端中。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-204">These services can be in the Azure cloud, your on-prem data center, or other public clouds.</span></span> <span data-ttu-id="0ff4f-205">API 金鑰和 JWT 權杖會決定誰可以執行哪些動作。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-205">API keys and JWT tokens determine who can do what.</span></span> <span data-ttu-id="0ff4f-206">記錄所有流量以供分析之用。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-206">All traffic is logged for analytical purposes.</span></span>

<span data-ttu-id="0ff4f-207">對於開發人員而言，API 管理提供開發人員入口網站，可讓您存取服務、檔和用來叫用它們的範例程式碼。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-207">For developers, API Management offers a developer portal that provides access to services, documentation, and sample code for invoking them.</span></span> <span data-ttu-id="0ff4f-208">開發人員可以使用 Swagger/Open API 來檢查服務端點，並分析其使用方式。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-208">Developers can use Swagger/Open API to inspect service endpoints and analyze their usage.</span></span> <span data-ttu-id="0ff4f-209">此服務可跨主要開發平臺運作： .NET、JAVA、Golang 等等。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-209">The service works across the major development platforms: .NET, Java, Golang, and more.</span></span>

<span data-ttu-id="0ff4f-210">發行者入口網站會公開管理儀表板，其中系統管理員會公開 Api 並管理其行為。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-210">The publisher portal exposes a management dashboard where administrators expose APIs and manage their behavior.</span></span> <span data-ttu-id="0ff4f-211">可以授與服務存取權、監視服務健全狀況，以及收集服務遙測。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-211">Service access can be granted, service health monitored, and service telemetry gathered.</span></span> <span data-ttu-id="0ff4f-212">系統管理員會將*原則*套用至每個端點，以影響行為。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-212">Administrators apply *policies* to each endpoint to affect behavior.</span></span> <span data-ttu-id="0ff4f-213">[原則](https://docs.microsoft.com/azure/api-management/api-management-howto-policies)是預先建立的語句，會針對每個服務呼叫循序執行。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-213">[Policies](https://docs.microsoft.com/azure/api-management/api-management-howto-policies) are pre-built statements that execute sequentially for each service call.</span></span>  <span data-ttu-id="0ff4f-214">原則會針對輸入呼叫、輸出呼叫或在發生錯誤時叫用。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-214">Policies are configured for an inbound call, outbound call, or invoked upon an error.</span></span> <span data-ttu-id="0ff4f-215">原則可以套用至不同的服務範圍，以在結合原則時啟用決定性順序。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-215">Policies can be applied at different service scopes as to enable deterministic ordering when combining policies.</span></span> <span data-ttu-id="0ff4f-216">產品隨附許多預先建立的[原則](https://docs.microsoft.com/azure/api-management/api-management-policies)。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-216">The product ships with a large number of prebuilt [policies](https://docs.microsoft.com/azure/api-management/api-management-policies).</span></span>

<span data-ttu-id="0ff4f-217">以下範例說明原則會如何影響您的雲端原生服務的行為：</span><span class="sxs-lookup"><span data-stu-id="0ff4f-217">Here are examples of how policies can affect the behavior of your cloud-native services:</span></span>  

- <span data-ttu-id="0ff4f-218">限制服務存取。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-218">Restrict service access.</span></span>
- <span data-ttu-id="0ff4f-219">強制執行驗證。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-219">Enforce authentication.</span></span>  
- <span data-ttu-id="0ff4f-220">視需要從單一來源節流呼叫。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-220">Throttle calls from a single source, if necessary.</span></span>
- <span data-ttu-id="0ff4f-221">啟用快取。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-221">Enable caching.</span></span>
- <span data-ttu-id="0ff4f-222">封鎖來自特定 IP 位址的呼叫。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-222">Block calls from specific IP addresses.</span></span>
- <span data-ttu-id="0ff4f-223">控制服務的流程。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-223">Control the flow of the service.</span></span>
- <span data-ttu-id="0ff4f-224">將要求從 SOAP 轉換成 REST，或在不同的資料格式之間（例如從 XML 到 JSON）。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-224">Convert requests from SOAP to REST or between different data formats, such as from XML to JSON.</span></span>

<span data-ttu-id="0ff4f-225">Azure API 管理可以公開裝載于任何位置的後端服務–在雲端或您的資料中心。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-225">Azure API Management can expose back-end services that are hosted anywhere – in the cloud or your data center.</span></span> <span data-ttu-id="0ff4f-226">針對您可能會在雲端原生系統中公開的舊版服務，它同時支援 REST 和 SOAP Api。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-226">For legacy services that you may expose in your cloud-native systems, it supports both REST and SOAP APIs.</span></span> <span data-ttu-id="0ff4f-227">即使是其他 Azure 服務也可以透過 API 管理來公開。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-227">Even other Azure services can be exposed through API Management.</span></span> <span data-ttu-id="0ff4f-228">您可以將受控 API 放在 Azure 支援服務上，例如[Azure 服務匯流排](https://azure.microsoft.com/services/service-bus/)或[Azure Logic Apps](https://azure.microsoft.com/services/logic-apps/)。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-228">You could place a managed API on top of an Azure backing service like [Azure Service Bus](https://azure.microsoft.com/services/service-bus/) or [Azure Logic Apps](https://azure.microsoft.com/services/logic-apps/).</span></span> <span data-ttu-id="0ff4f-229">Azure API 管理不包含內建的負載平衡支援，應與負載平衡服務搭配使用。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-229">Azure API Management doesn't include built-in load-balancing support and should be used in conjunction with a load-balancing service.</span></span>

<span data-ttu-id="0ff4f-230">Azure API 管理可跨[四個不同層級](https://azure.microsoft.com/pricing/details/api-management/)提供：</span><span class="sxs-lookup"><span data-stu-id="0ff4f-230">Azure API Management is available across [four different tiers](https://azure.microsoft.com/pricing/details/api-management/):</span></span>

- <span data-ttu-id="0ff4f-231">開發人員</span><span class="sxs-lookup"><span data-stu-id="0ff4f-231">Developer</span></span>
- <span data-ttu-id="0ff4f-232">基本</span><span class="sxs-lookup"><span data-stu-id="0ff4f-232">Basic</span></span>
- <span data-ttu-id="0ff4f-233">標準</span><span class="sxs-lookup"><span data-stu-id="0ff4f-233">Standard</span></span>
- <span data-ttu-id="0ff4f-234">Premium</span><span class="sxs-lookup"><span data-stu-id="0ff4f-234">Premium</span></span>

<span data-ttu-id="0ff4f-235">開發人員層適用于非生產工作負載和評估。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-235">The Developer tier is meant for non-production workloads and evaluation.</span></span> <span data-ttu-id="0ff4f-236">另一層則提供更多的電源、功能和更高的服務等級協定（Sla）。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-236">The other tiers offer progressively more power, features, and higher service level agreements (SLAs).</span></span> <span data-ttu-id="0ff4f-237">高階層提供[Azure 虛擬網路](https://docs.microsoft.com/azure/virtual-network/virtual-networks-overview)和[多區域支援](https://docs.microsoft.com/azure/api-management/api-management-howto-deploy-multi-region)。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-237">The Premium tier provides [Azure Virtual Network](https://docs.microsoft.com/azure/virtual-network/virtual-networks-overview) and [multi-region support](https://docs.microsoft.com/azure/api-management/api-management-howto-deploy-multi-region).</span></span> <span data-ttu-id="0ff4f-238">所有層都有每小時固定的價格。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-238">All tiers have a fixed price per hour.</span></span>

<span data-ttu-id="0ff4f-239">Azure 雲端也提供 Azure API 管理的[無伺服器層](https://azure.microsoft.com/blog/announcing-azure-api-management-for-serverless-architectures/)。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-239">The Azure cloud also offers a [serverless tier](https://azure.microsoft.com/blog/announcing-azure-api-management-for-serverless-architectures/) for Azure API Management.</span></span> <span data-ttu-id="0ff4f-240">所謂的「取用」*定價層*，服務是以無伺服器運算模型為中心設計之 API 管理的變異。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-240">Referred to as the *consumption pricing tier*, the service is a variant of API Management designed around the serverless computing model.</span></span> <span data-ttu-id="0ff4f-241">不同于先前所顯示的「預先配置」定價層，取用層提供立即布建和按動作付費的定價。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-241">Unlike the "pre-allocated" pricing tiers previously shown, the consumption tier provides  instant provisioning and pay-per-action pricing.</span></span>

<span data-ttu-id="0ff4f-242">它會啟用下列使用案例的 API 閘道功能：</span><span class="sxs-lookup"><span data-stu-id="0ff4f-242">It enables API Gateway features for the following use cases:</span></span>

- <span data-ttu-id="0ff4f-243">微服務使用無伺服器技術（例如[Azure Functions](https://docs.microsoft.com/azure/azure-functions/functions-overview)和[Azure Logic Apps](https://azure.microsoft.com/services/logic-apps/)）來實行。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-243">Microservices implemented using serverless technologies such as [Azure Functions](https://docs.microsoft.com/azure/azure-functions/functions-overview) and [Azure Logic Apps](https://azure.microsoft.com/services/logic-apps/).</span></span>
- <span data-ttu-id="0ff4f-244">Azure 支援的服務資源，例如服務匯流排佇列和主題、Azure 儲存體等。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-244">Azure backing service resources such as Service Bus queues and topics, Azure storage, and others.</span></span>
- <span data-ttu-id="0ff4f-245">微服務，其中的流量偶爾會發生大量的尖峰，但大部分的時間都保持不變。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-245">Microservices where traffic has occasional large spikes but remains low the majority of the time.</span></span>

<span data-ttu-id="0ff4f-246">取用層會使用相同的基礎服務 API 管理元件，但是會根據動態配置的資源來採用完全不同的架構。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-246">The consumption tier uses the same underlying service API Management components, but employs an entirely different architecture based on dynamically allocated resources.</span></span> <span data-ttu-id="0ff4f-247">它完美地配合無伺服器運算模型：</span><span class="sxs-lookup"><span data-stu-id="0ff4f-247">It aligns perfectly with the serverless computing model:</span></span>

- <span data-ttu-id="0ff4f-248">沒有可管理的基礎結構。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-248">No infrastructure to manage.</span></span>
- <span data-ttu-id="0ff4f-249">沒有閒置容量。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-249">No idle capacity.</span></span>
- <span data-ttu-id="0ff4f-250">高可用性。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-250">High-availability.</span></span>
- <span data-ttu-id="0ff4f-251">自動調整。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-251">Automatic scaling.</span></span>
- <span data-ttu-id="0ff4f-252">成本是以實際使用量為基礎。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-252">Cost is based on actual usage.</span></span>
  
<span data-ttu-id="0ff4f-253">新的耗用量層是雲端原生系統的絕佳選擇，會將無伺服器資源公開為 Api。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-253">The new consumption tier is a great choice for cloud-native systems that expose serverless resources as APIs.</span></span>

## <a name="real-time-communication"></a><span data-ttu-id="0ff4f-254">即時通訊</span><span class="sxs-lookup"><span data-stu-id="0ff4f-254">Real-time communication</span></span>

<span data-ttu-id="0ff4f-255">對於透過 HTTP 與後端雲端原生系統進行通訊的前端應用程式，即時或推播是另一個選項。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-255">Real-time, or push, communication is another option for front-end applications that communicate with back-end cloud-native systems over HTTP.</span></span> <span data-ttu-id="0ff4f-256">應用程式（例如，金融部門、線上教育、遊戲和作業進度更新）需要來自後端的瞬間、即時回應。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-256">Applications, such as financial-tickers, online education, gaming, and job-progress updates, require instantaneous, real-time responses from the back-end.</span></span> <span data-ttu-id="0ff4f-257">使用一般 HTTP 通訊時，用戶端無法得知何時可以使用新資料。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-257">With normal HTTP communication, there's no way for the client to know when new data is available.</span></span> <span data-ttu-id="0ff4f-258">用戶端必須持續*輪詢*或傳送要求到伺服器。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-258">The client must continually *poll* or send requests to the server.</span></span> <span data-ttu-id="0ff4f-259">使用*即時*通訊時，伺服器可以隨時將新資料推送至用戶端。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-259">With *real-time* communication, the server can push new data to the client at any time.</span></span>

<span data-ttu-id="0ff4f-260">即時系統通常是以高頻率的資料流程和大量的並行用戶端連線為特色。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-260">Real-time systems are often characterized by high-frequency data flows and large numbers of concurrent client connections.</span></span> <span data-ttu-id="0ff4f-261">手動執行即時連線可能很快就會變得複雜，而需要非一般的基礎結構，以確保連線用戶端的擴充性和可靠的訊息。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-261">Manually implementing real-time connectivity can quickly become complex, requiring non-trivial infrastructure to ensure scalability and reliable messaging to connected clients.</span></span> <span data-ttu-id="0ff4f-262">您可以自行管理 Azure Redis 快取的實例，以及一組以用戶端親和性的粘滯會話設定的負載平衡器。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-262">You could find yourself managing an  instance of Azure Redis Cache and a set of load balancers configured with sticky sessions for client affinity.</span></span>

<span data-ttu-id="0ff4f-263">[Azure SignalR Service](https://azure.microsoft.com/services/signalr-service/)是完全受控的 Azure 服務，可為您的雲端原生應用程式簡化即時通訊。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-263">[Azure SignalR Service](https://azure.microsoft.com/services/signalr-service/) is a fully managed Azure service that simplifies real-time communication for your cloud-native applications.</span></span> <span data-ttu-id="0ff4f-264">如容量布建、調整和持續連線等技術執行詳細資料，將會被抽象化。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-264">Technical implementation details like capacity provisioning, scaling, and persistent connections are abstracted away.</span></span> <span data-ttu-id="0ff4f-265">系統會為您處理99.9% 服務等級協定。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-265">They're handled for you with a 99.9% service-level agreement.</span></span> <span data-ttu-id="0ff4f-266">您將焦點放在應用程式功能，而不是基礎結構的管道。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-266">You focus on application features, not infrastructure plumbing.</span></span>

<span data-ttu-id="0ff4f-267">啟用之後，雲端式 HTTP 服務就可以直接將內容更新推送至連線的用戶端，包括瀏覽器、行動和桌面應用程式。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-267">Once enabled, a cloud-based HTTP service can push content updates directly to connected clients, including browser, mobile and desktop applications.</span></span> <span data-ttu-id="0ff4f-268">用戶端會在不需要輪詢伺服器的情況下進行更新。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-268">Clients are updated without the need to poll the server.</span></span> <span data-ttu-id="0ff4f-269">Azure SignalR 會將建立即時連線的傳輸技術抽象化，包括 Websocket、伺服器端事件和長時間輪詢。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-269">Azure SignalR abstracts the transport technologies that create real-time connectivity, including WebSockets, Server-Side Events, and Long Polling.</span></span> <span data-ttu-id="0ff4f-270">開發人員著重于將訊息傳送至已連線用戶端的所有或特定子集。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-270">Developers focus on sending messages to all or specific subsets of connected clients.</span></span>

<span data-ttu-id="0ff4f-271">圖4-7 顯示一組 HTTP 用戶端，其連線至已啟用 Azure SignalR 的雲端原生應用程式。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-271">Figure 4-7 shows a set of HTTP Clients connecting to a Cloud-native application with Azure SignalR enabled.</span></span>

![Azure SignalR](./media/azure-signalr-service.png)

<span data-ttu-id="0ff4f-273">**圖4-7。**</span><span class="sxs-lookup"><span data-stu-id="0ff4f-273">**Figure 4-7.**</span></span> <span data-ttu-id="0ff4f-274">Azure SignalR</span><span class="sxs-lookup"><span data-stu-id="0ff4f-274">Azure SignalR</span></span>

<span data-ttu-id="0ff4f-275">Azure SignalR Service 的另一個優點是執行無伺服器雲端原生服務。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-275">Another advantage of Azure SignalR Service comes with implementing Serverless cloud-native services.</span></span> <span data-ttu-id="0ff4f-276">您的程式碼可能會隨 Azure Functions 的觸發程式隨選執行。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-276">Perhaps your code is executed on demand with Azure Functions triggers.</span></span> <span data-ttu-id="0ff4f-277">此案例可能會很棘手，因為您的程式碼不會維護與用戶端的長時間連接。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-277">This scenario can be tricky because your code doesn't maintain long connections with clients.</span></span> <span data-ttu-id="0ff4f-278">Azure SignalR 服務可以處理這種情況，因為該服務已經為您管理連線。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-278">Azure SignalR Service can handle this situation since the service already manages connections for you.</span></span>

<span data-ttu-id="0ff4f-279">Azure SignalR Service 與其他 Azure 服務（例如 Azure SQL Database、服務匯流排或 Redis 快取）緊密整合，為您的雲端原生應用程式開啟許多可能性。</span><span class="sxs-lookup"><span data-stu-id="0ff4f-279">Azure SignalR Service closely integrates with other Azure services, such as Azure SQL Database, Service Bus, or Redis Cache, opening up many possibilities for your cloud-native applications.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="0ff4f-280">[上一頁](communication-patterns.md)
>[下一頁](service-to-service-communication.md)</span><span class="sxs-lookup"><span data-stu-id="0ff4f-280">[Previous](communication-patterns.md)
[Next](service-to-service-communication.md)</span></span>
