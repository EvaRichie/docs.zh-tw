---
title: 雲端原生的定義
description: 瞭解為雲端原生系統提供探源的基本要素
author: robvet
ms.date: 05/13/2020
ms.openlocfilehash: 1f0d842a2369ae04ffc1c634f9de60398a88e86f
ms.sourcegitcommit: 4d45bda8cd9558ea8af4be591e3d5a29360c1ece
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 10/02/2020
ms.locfileid: "91654688"
---
# <a name="defining-cloud-native"></a><span data-ttu-id="d4277-103">定義雲端原生</span><span class="sxs-lookup"><span data-stu-id="d4277-103">Defining cloud native</span></span>

<span data-ttu-id="d4277-104">停止您正在執行的工作，以及您同事的文字10。</span><span class="sxs-lookup"><span data-stu-id="d4277-104">Stop what you're doing and text ten of your colleagues.</span></span> <span data-ttu-id="d4277-105">要求他們定義「雲端原生」一詞。</span><span class="sxs-lookup"><span data-stu-id="d4277-105">Ask them to define the term "Cloud Native".</span></span> <span data-ttu-id="d4277-106">您很有可能得到十個不同的答案。</span><span class="sxs-lookup"><span data-stu-id="d4277-106">Good chance you'll get ten different answers.</span></span>

<span data-ttu-id="d4277-107">雲端原生的重點，是要改變您對於建立重要商務系統的方式。</span><span class="sxs-lookup"><span data-stu-id="d4277-107">Cloud native is all about changing the way you think about constructing critical business systems.</span></span>

<span data-ttu-id="d4277-108">雲端原生系統的設計是為了採用快速變更、大規模和彈性。</span><span class="sxs-lookup"><span data-stu-id="d4277-108">Cloud-native systems are designed to embrace rapid change, large scale, and resilience.</span></span>

<span data-ttu-id="d4277-109">雲端原生運算基礎提供 [正式的定義](https://github.com/cncf/foundation/blob/master/charter.md)：</span><span class="sxs-lookup"><span data-stu-id="d4277-109">The Cloud Native Computing Foundation provides an [official definition](https://github.com/cncf/foundation/blob/master/charter.md):</span></span>

> <span data-ttu-id="d4277-110">*雲端原生技術可讓組織在新式動態環境（例如公用、私人和混合式雲端）中建立並執行可調整的應用程式。容器、服務網格、微服務、不可變的基礎結構和宣告式 Api 都會說明點這種方法。*</span><span class="sxs-lookup"><span data-stu-id="d4277-110">*Cloud-native technologies empower organizations to build and run scalable applications in modern, dynamic environments such as public, private, and hybrid clouds. Containers, service meshes, microservices, immutable infrastructure, and declarative APIs exemplify this approach.*</span></span>

> <span data-ttu-id="d4277-111">*這些技術可讓您以鬆散耦合的系統提供復原性、可管理且可觀察的系統。它們結合了強大的自動化功能，可讓工程師以最少的辛勞，以頻繁且可預測的方式進行高度影響的變更。*</span><span class="sxs-lookup"><span data-stu-id="d4277-111">*These techniques enable loosely coupled systems that are resilient, manageable, and observable. Combined with robust automation, they allow engineers to make high-impact changes frequently and predictably with minimal toil.*</span></span>

<span data-ttu-id="d4277-112">應用程式越來越複雜，使用者需要更多更多。</span><span class="sxs-lookup"><span data-stu-id="d4277-112">Applications have become increasingly complex with users demanding more and more.</span></span> <span data-ttu-id="d4277-113">使用者預期快速回應性、創新功能和零停機時間。</span><span class="sxs-lookup"><span data-stu-id="d4277-113">Users expect rapid responsiveness, innovative features, and zero downtime.</span></span> <span data-ttu-id="d4277-114">無法再接受效能問題、週期性錯誤和無法快速移動。</span><span class="sxs-lookup"><span data-stu-id="d4277-114">Performance problems, recurring errors, and the inability to move fast are no longer acceptable.</span></span> <span data-ttu-id="d4277-115">他們將可輕鬆地移至您的競爭對手。</span><span class="sxs-lookup"><span data-stu-id="d4277-115">They'll easily move to your competitor.</span></span>

<span data-ttu-id="d4277-116">雲端原生的 *速度* 和 *靈活性*。</span><span class="sxs-lookup"><span data-stu-id="d4277-116">Cloud native is about *speed* and *agility*.</span></span> <span data-ttu-id="d4277-117">商務系統不斷演進，使商務功能成為策略性轉型的武器，以加速業務速度和成長。</span><span class="sxs-lookup"><span data-stu-id="d4277-117">Business systems are evolving from enabling business capabilities to being weapons of strategic transformation that accelerate business velocity and growth.</span></span> <span data-ttu-id="d4277-118">請務必立即將構想推向市場。</span><span class="sxs-lookup"><span data-stu-id="d4277-118">It's imperative to get ideas to market immediately.</span></span>

<span data-ttu-id="d4277-119">以下是一些已實行這些技術的公司。</span><span class="sxs-lookup"><span data-stu-id="d4277-119">Here are some companies who have implemented these techniques.</span></span> <span data-ttu-id="d4277-120">思考它們所達成的速度、靈活性和擴充性。</span><span class="sxs-lookup"><span data-stu-id="d4277-120">Think about the speed, agility, and scalability they've achieved.</span></span>

| <span data-ttu-id="d4277-121">公司</span><span class="sxs-lookup"><span data-stu-id="d4277-121">Company</span></span> | <span data-ttu-id="d4277-122">體驗</span><span class="sxs-lookup"><span data-stu-id="d4277-122">Experience</span></span> |
| :-------- | :-------- |
| [<span data-ttu-id="d4277-123">Netflix</span><span class="sxs-lookup"><span data-stu-id="d4277-123">Netflix</span></span>](https://www.infoq.com/news/2013/06/netflix/) | <span data-ttu-id="d4277-124">在生產環境中有600項以上的服務。</span><span class="sxs-lookup"><span data-stu-id="d4277-124">Has 600+ services in production.</span></span> <span data-ttu-id="d4277-125">每天部署數百次。</span><span class="sxs-lookup"><span data-stu-id="d4277-125">Deploys hundred times per day.</span></span> |
| [<span data-ttu-id="d4277-126">Uber</span><span class="sxs-lookup"><span data-stu-id="d4277-126">Uber</span></span>](https://eng.uber.com/micro-deploy/) | <span data-ttu-id="d4277-127">在生產環境中有1000項以上的服務。</span><span class="sxs-lookup"><span data-stu-id="d4277-127">Has 1,000+ services in production.</span></span> <span data-ttu-id="d4277-128">每週部署數千次。</span><span class="sxs-lookup"><span data-stu-id="d4277-128">Deploys several thousand times each week.</span></span> |
| [<span data-ttu-id="d4277-129">微信</span><span class="sxs-lookup"><span data-stu-id="d4277-129">WeChat</span></span>](https://www.cs.columbia.edu/~ruigu/papers/socc18-final100.pdf) | <span data-ttu-id="d4277-130">生產環境中有3000項以上的服務。</span><span class="sxs-lookup"><span data-stu-id="d4277-130">Has 3,000+ services in production.</span></span> <span data-ttu-id="d4277-131">一天部署1000次。</span><span class="sxs-lookup"><span data-stu-id="d4277-131">Deploys 1,000 times a day.</span></span> |

<span data-ttu-id="d4277-132">如您所見，Netflix、Uber 和 WeChat 會公開由數百個獨立微服務組成的系統。</span><span class="sxs-lookup"><span data-stu-id="d4277-132">As you can see, Netflix, Uber, and WeChat expose systems that consist of hundreds of independent microservices.</span></span> <span data-ttu-id="d4277-133">此架構樣式可讓它們快速回應市場狀況。</span><span class="sxs-lookup"><span data-stu-id="d4277-133">This architectural style enables them to rapidly respond to market conditions.</span></span> <span data-ttu-id="d4277-134">他們可以立即更新即時複雜應用程式的小型區域，並視需要個別調整這些區域。</span><span class="sxs-lookup"><span data-stu-id="d4277-134">They can instantaneously update small areas of a live, complex application, and individually scale those areas as needed.</span></span>

<span data-ttu-id="d4277-135">雲端原生的速度和靈活性來自許多因素。</span><span class="sxs-lookup"><span data-stu-id="d4277-135">The speed and agility of cloud native come about from a number of factors.</span></span> <span data-ttu-id="d4277-136">最重要的是雲端基礎結構。</span><span class="sxs-lookup"><span data-stu-id="d4277-136">Foremost is cloud infrastructure.</span></span> <span data-ttu-id="d4277-137">圖1-3 中所示的五個額外基本要素也提供雲端原生系統的探源。</span><span class="sxs-lookup"><span data-stu-id="d4277-137">Five additional foundational pillars shown in Figure 1-3 also provide the bedrock for cloud-native systems.</span></span>

![雲端原生基本要素](./media/cloud-native-foundational-pillars.png)

<span data-ttu-id="d4277-139">**圖 1-3**。</span><span class="sxs-lookup"><span data-stu-id="d4277-139">**Figure 1-3**.</span></span> <span data-ttu-id="d4277-140">雲端原生基本要素</span><span class="sxs-lookup"><span data-stu-id="d4277-140">Cloud-native foundational pillars</span></span>

<span data-ttu-id="d4277-141">讓我們花點時間進一步瞭解每個要件的重要性。</span><span class="sxs-lookup"><span data-stu-id="d4277-141">Let's take some time to better understand the significance of each pillar.</span></span>

## <a name="the-cloud"></a><span data-ttu-id="d4277-142">雲端 .。。</span><span class="sxs-lookup"><span data-stu-id="d4277-142">The cloud…</span></span>

<span data-ttu-id="d4277-143">雲端原生系統充分利用雲端服務模型。</span><span class="sxs-lookup"><span data-stu-id="d4277-143">Cloud-native systems take full advantage of the cloud service model.</span></span>

<span data-ttu-id="d4277-144">這些系統設計成在動態、虛擬化的雲端環境中，廣泛使用 [平臺即服務， (PaaS) ](https://azure.microsoft.com/overview/what-is-paas/) 計算基礎結構和受控服務。</span><span class="sxs-lookup"><span data-stu-id="d4277-144">Designed to thrive in a dynamic, virtualized cloud environment, these systems make extensive use of [Platform as a Service (PaaS)](https://azure.microsoft.com/overview/what-is-paas/) compute infrastructure and managed services.</span></span> <span data-ttu-id="d4277-145">它們會在幾分鐘內將基礎結構視為可 *處置* 的布建，並透過自動化來調整大小、調整、移動或損毀。</span><span class="sxs-lookup"><span data-stu-id="d4277-145">They treat the underlying infrastructure as *disposable* - provisioned in minutes and resized, scaled, moved, or destroyed on demand – via automation.</span></span>

<span data-ttu-id="d4277-146">請考慮採用廣泛接受的 DevOps 概念 [與牛群](https://medium.com/@Joachim8675309/devops-concepts-pets-vs-cattle-2380b5aab313)。</span><span class="sxs-lookup"><span data-stu-id="d4277-146">Consider the widely accepted DevOps concept of [Pets vs. Cattle](https://medium.com/@Joachim8675309/devops-concepts-pets-vs-cattle-2380b5aab313).</span></span> <span data-ttu-id="d4277-147">在傳統的資料中心內，會將伺服器視為 *寵物*：實體機器、指定有意義的名稱，以及關懷。</span><span class="sxs-lookup"><span data-stu-id="d4277-147">In a traditional data center, servers are treated as *Pets*: a physical machine, given a meaningful name, and cared for.</span></span> <span data-ttu-id="d4277-148">您可以藉由將更多資源新增到同一部電腦， (相應增加) 來進行調整。</span><span class="sxs-lookup"><span data-stu-id="d4277-148">You scale by adding more resources to the same machine (scaling up).</span></span> <span data-ttu-id="d4277-149">如果伺服器變成病假，您會將它傳回健康狀態。</span><span class="sxs-lookup"><span data-stu-id="d4277-149">If the server becomes sick, you nurse it back to health.</span></span> <span data-ttu-id="d4277-150">如果伺服器無法使用，每個人都會注意到。</span><span class="sxs-lookup"><span data-stu-id="d4277-150">Should the server become unavailable, everyone notices.</span></span>

<span data-ttu-id="d4277-151">*牛群*服務模型不同。</span><span class="sxs-lookup"><span data-stu-id="d4277-151">The *Cattle* service model is different.</span></span> <span data-ttu-id="d4277-152">您可以將每個實例布建為虛擬機器或容器。</span><span class="sxs-lookup"><span data-stu-id="d4277-152">You provision each instance as a virtual machine or container.</span></span> <span data-ttu-id="d4277-153">它們是相同的，而且會指派系統識別碼，例如服務-01、Service-02 等等。</span><span class="sxs-lookup"><span data-stu-id="d4277-153">They're identical and assigned a system identifier such as Service-01, Service-02, and so on.</span></span> <span data-ttu-id="d4277-154">您可以藉由 (相應放大) 來調整規模。</span><span class="sxs-lookup"><span data-stu-id="d4277-154">You scale by creating more of them (scaling out).</span></span> <span data-ttu-id="d4277-155">當某個人無法使用時，沒有人會注意到。</span><span class="sxs-lookup"><span data-stu-id="d4277-155">When one becomes unavailable, nobody notices.</span></span>

<span data-ttu-id="d4277-156">牛群模型採用 *不可變的基礎結構*。</span><span class="sxs-lookup"><span data-stu-id="d4277-156">The cattle model embraces *immutable infrastructure*.</span></span> <span data-ttu-id="d4277-157">伺服器不會修復或修改。</span><span class="sxs-lookup"><span data-stu-id="d4277-157">Servers aren't repaired or modified.</span></span> <span data-ttu-id="d4277-158">如果其中一個失敗或需要更新，則會將它終結並布建新的（透過自動化完成）。</span><span class="sxs-lookup"><span data-stu-id="d4277-158">If one fails or requires updating, it's destroyed and a new one is provisioned – all done via automation.</span></span>

<span data-ttu-id="d4277-159">雲端原生系統採用牛群服務模型。</span><span class="sxs-lookup"><span data-stu-id="d4277-159">Cloud-native systems embrace the Cattle service model.</span></span> <span data-ttu-id="d4277-160">當基礎結構相應縮小或相應放大時，它們會繼續執行，而不考慮其執行所在的機器。</span><span class="sxs-lookup"><span data-stu-id="d4277-160">They continue to run as the infrastructure scales in or out with no regard to the machines upon which they're running.</span></span>

<span data-ttu-id="d4277-161">Azure 雲端平臺支援這類高度彈性的基礎結構，具有自動調整、自我修復和監視功能。</span><span class="sxs-lookup"><span data-stu-id="d4277-161">The Azure cloud platform supports this type of highly elastic infrastructure with automatic scaling, self-healing, and monitoring capabilities.</span></span>

## <a name="modern-design"></a><span data-ttu-id="d4277-162">新式設計</span><span class="sxs-lookup"><span data-stu-id="d4277-162">Modern design</span></span>

<span data-ttu-id="d4277-163">如何設計雲端原生應用程式？</span><span class="sxs-lookup"><span data-stu-id="d4277-163">How would you design a cloud-native app?</span></span> <span data-ttu-id="d4277-164">您的架構看起來像什麼？</span><span class="sxs-lookup"><span data-stu-id="d4277-164">What would your architecture look like?</span></span> <span data-ttu-id="d4277-165">您會遵守哪些原則、模式和最佳做法？</span><span class="sxs-lookup"><span data-stu-id="d4277-165">To what principles, patterns, and best practices would you adhere?</span></span> <span data-ttu-id="d4277-166">有哪些基礎結構和操作考慮會很重要？</span><span class="sxs-lookup"><span data-stu-id="d4277-166">What infrastructure and operational concerns would be important?</span></span>

### <a name="the-twelve-factor-application"></a><span data-ttu-id="d4277-167">十二要素應用程式</span><span class="sxs-lookup"><span data-stu-id="d4277-167">The Twelve-Factor Application</span></span>

<span data-ttu-id="d4277-168">建立雲端架構應用程式的廣泛接受方法是 [十二個因素的應用程式](https://12factor.net/)。</span><span class="sxs-lookup"><span data-stu-id="d4277-168">A widely accepted methodology for constructing cloud-based applications is the [Twelve-Factor Application](https://12factor.net/).</span></span> <span data-ttu-id="d4277-169">其中說明一組準則和作法，開發人員會遵循這些原則和實務來建立針對新式雲端環境優化的應用程式。</span><span class="sxs-lookup"><span data-stu-id="d4277-169">It describes a set of principles and practices that developers follow to construct applications optimized for modern cloud environments.</span></span> <span data-ttu-id="d4277-170">特別注意是跨環境和宣告式自動化提供可攜性。</span><span class="sxs-lookup"><span data-stu-id="d4277-170">Special attention is given to portability across environments and declarative automation.</span></span>

<span data-ttu-id="d4277-171">雖然適用于任何 web 應用程式，但許多開發人員會將十二個因素視為建立雲端原生應用程式的穩固基礎。</span><span class="sxs-lookup"><span data-stu-id="d4277-171">While applicable to any web-based application, many practitioners consider Twelve-Factor as a solid foundation for building cloud-native apps.</span></span> <span data-ttu-id="d4277-172">根據這些準則建立的系統可以快速部署及調整規模，並新增功能，以快速回應市場變更。</span><span class="sxs-lookup"><span data-stu-id="d4277-172">Systems built upon these principles can deploy and scale rapidly and add features to react quickly to market changes.</span></span>

<span data-ttu-id="d4277-173">下表強調十二因數方法：</span><span class="sxs-lookup"><span data-stu-id="d4277-173">The following table highlights the Twelve-Factor methodology:</span></span>

|    |  <span data-ttu-id="d4277-174">因素</span><span class="sxs-lookup"><span data-stu-id="d4277-174">Factor</span></span> | <span data-ttu-id="d4277-175">說明</span><span class="sxs-lookup"><span data-stu-id="d4277-175">Explanation</span></span>  |
| :-------- | :-------- | :-------- |
| <span data-ttu-id="d4277-176">1</span><span class="sxs-lookup"><span data-stu-id="d4277-176">1</span></span> | <span data-ttu-id="d4277-177">程式碼基底</span><span class="sxs-lookup"><span data-stu-id="d4277-177">Code Base</span></span> | <span data-ttu-id="d4277-178">每個微服務的單一程式碼基底，儲存在它自己的儲存機制中。</span><span class="sxs-lookup"><span data-stu-id="d4277-178">A single code base for each microservice, stored in its own repository.</span></span> <span data-ttu-id="d4277-179">使用版本控制進行追蹤，它可以部署到多個環境 (QA、預備、生產) 。</span><span class="sxs-lookup"><span data-stu-id="d4277-179">Tracked with version control, it can deploy to multiple environments (QA, Staging, Production).</span></span> |
| <span data-ttu-id="d4277-180">2</span><span class="sxs-lookup"><span data-stu-id="d4277-180">2</span></span> | <span data-ttu-id="d4277-181">相依性</span><span class="sxs-lookup"><span data-stu-id="d4277-181">Dependencies</span></span> | <span data-ttu-id="d4277-182">每個微服務會隔離並封裝本身的相依性，並在不影響整個系統的情況下進行變更。</span><span class="sxs-lookup"><span data-stu-id="d4277-182">Each microservice isolates and packages its own dependencies, embracing changes without impacting the entire system.</span></span> |
| <span data-ttu-id="d4277-183">3</span><span class="sxs-lookup"><span data-stu-id="d4277-183">3</span></span> | <span data-ttu-id="d4277-184">組態</span><span class="sxs-lookup"><span data-stu-id="d4277-184">Configurations</span></span>  | <span data-ttu-id="d4277-185">設定資訊會透過程式碼外的設定管理工具移出微服務和外部化。</span><span class="sxs-lookup"><span data-stu-id="d4277-185">Configuration information is moved out of the microservice and externalized through a configuration management tool outside of the code.</span></span> <span data-ttu-id="d4277-186">相同的部署可以跨環境傳播，並套用正確的設定。</span><span class="sxs-lookup"><span data-stu-id="d4277-186">The same deployment can propagate across environments with the correct configuration applied.</span></span>  |
| <span data-ttu-id="d4277-187">4</span><span class="sxs-lookup"><span data-stu-id="d4277-187">4</span></span> | <span data-ttu-id="d4277-188">支援服務</span><span class="sxs-lookup"><span data-stu-id="d4277-188">Backing Services</span></span> | <span data-ttu-id="d4277-189"> (資料存放區、快取、訊息代理程式) 的輔助資源，應該透過可定址的 URL 來公開。</span><span class="sxs-lookup"><span data-stu-id="d4277-189">Ancillary resources (data stores, caches, message brokers) should be exposed via an addressable URL.</span></span> <span data-ttu-id="d4277-190">這樣做會將資源與應用程式分離，讓它能夠互換。</span><span class="sxs-lookup"><span data-stu-id="d4277-190">Doing so decouples the resource from the application, enabling it to be interchangeable.</span></span>  |
| <span data-ttu-id="d4277-191">5</span><span class="sxs-lookup"><span data-stu-id="d4277-191">5</span></span> | <span data-ttu-id="d4277-192">組建、發行、執行</span><span class="sxs-lookup"><span data-stu-id="d4277-192">Build, Release, Run</span></span> | <span data-ttu-id="d4277-193">每個版本都必須在組建、發行和執行階段之間強制執行嚴格的分隔。</span><span class="sxs-lookup"><span data-stu-id="d4277-193">Each release must enforce a strict separation across the build, release, and run stages.</span></span> <span data-ttu-id="d4277-194">每個都應該使用唯一識別碼來標記，並支援復原的能力。</span><span class="sxs-lookup"><span data-stu-id="d4277-194">Each should be tagged with a unique ID and support the ability to roll back.</span></span> <span data-ttu-id="d4277-195">新式 CI/CD 系統可協助滿足此原則。</span><span class="sxs-lookup"><span data-stu-id="d4277-195">Modern CI/CD systems help fulfill this principle.</span></span> |
| <span data-ttu-id="d4277-196">6</span><span class="sxs-lookup"><span data-stu-id="d4277-196">6</span></span> | <span data-ttu-id="d4277-197">處理序</span><span class="sxs-lookup"><span data-stu-id="d4277-197">Processes</span></span> | <span data-ttu-id="d4277-198">每個微服務都應該在其本身的進程中執行，並與其他正在執行的服務隔離。</span><span class="sxs-lookup"><span data-stu-id="d4277-198">Each microservice should execute in its own process,  isolated from other running services.</span></span> <span data-ttu-id="d4277-199">具體化支援服務的必要狀態，例如分散式快取或資料存放區。</span><span class="sxs-lookup"><span data-stu-id="d4277-199">Externalize required state to a backing service such as a distributed cache or data store.</span></span> |
| <span data-ttu-id="d4277-200">7</span><span class="sxs-lookup"><span data-stu-id="d4277-200">7</span></span> | <span data-ttu-id="d4277-201">連接埠繫結</span><span class="sxs-lookup"><span data-stu-id="d4277-201">Port Binding</span></span> | <span data-ttu-id="d4277-202">每個微服務都應該獨立于其本身的埠上公開的介面和功能。</span><span class="sxs-lookup"><span data-stu-id="d4277-202">Each microservice should be self-contained with its interfaces and functionality exposed on its own port.</span></span> <span data-ttu-id="d4277-203">這樣做會提供與其他微服務的隔離。</span><span class="sxs-lookup"><span data-stu-id="d4277-203">Doing so provides isolation from other microservices.</span></span> |
| <span data-ttu-id="d4277-204">8</span><span class="sxs-lookup"><span data-stu-id="d4277-204">8</span></span> | <span data-ttu-id="d4277-205">並行</span><span class="sxs-lookup"><span data-stu-id="d4277-205">Concurrency</span></span> | <span data-ttu-id="d4277-206">服務會在大量的小型相同程式之間相應放大 (複製) ，而不是在最強大的電腦上相應增加單一大型實例。</span><span class="sxs-lookup"><span data-stu-id="d4277-206">Services scale out across a large number of small identical processes (copies) as opposed to scaling-up a single large instance on the most powerful machine available.</span></span> |
| <span data-ttu-id="d4277-207">9</span><span class="sxs-lookup"><span data-stu-id="d4277-207">9</span></span> | <span data-ttu-id="d4277-208">Disposability</span><span class="sxs-lookup"><span data-stu-id="d4277-208">Disposability</span></span> | <span data-ttu-id="d4277-209">服務實例應該是可處置的 favoring 快速新創公司，以增加擴充性機會和正常關機，讓系統保持在正確的狀態。</span><span class="sxs-lookup"><span data-stu-id="d4277-209">Service instances should be disposable, favoring fast startups to increase scalability opportunities and graceful shutdowns to leave the system in a correct state.</span></span> <span data-ttu-id="d4277-210">Docker 容器和協調器本身就能滿足這項需求。</span><span class="sxs-lookup"><span data-stu-id="d4277-210">Docker containers along with an orchestrator inherently satisfy this requirement.</span></span> |
| <span data-ttu-id="d4277-211">10</span><span class="sxs-lookup"><span data-stu-id="d4277-211">10</span></span> | <span data-ttu-id="d4277-212">開發/生產同位</span><span class="sxs-lookup"><span data-stu-id="d4277-212">Dev/Prod Parity</span></span> | <span data-ttu-id="d4277-213">盡可能將環境維持在應用程式生命週期的盡可能處，以避免昂貴的快捷方式。</span><span class="sxs-lookup"><span data-stu-id="d4277-213">Keep environments across the application lifecycle as similar as possible, avoiding costly shortcuts.</span></span> <span data-ttu-id="d4277-214">在這裡，您可以藉由升級相同的執行環境，大幅貢獻容器的採用。</span><span class="sxs-lookup"><span data-stu-id="d4277-214">Here, the adoption of containers can greatly contribute by promoting the same execution environment.</span></span> |
| <span data-ttu-id="d4277-215">11</span><span class="sxs-lookup"><span data-stu-id="d4277-215">11</span></span> | <span data-ttu-id="d4277-216">記錄</span><span class="sxs-lookup"><span data-stu-id="d4277-216">Logging</span></span> | <span data-ttu-id="d4277-217">將微服務所產生的記錄視為事件資料流程。</span><span class="sxs-lookup"><span data-stu-id="d4277-217">Treat logs generated by microservices as event streams.</span></span> <span data-ttu-id="d4277-218">使用事件匯總工具進行處理，並將資料傳播至資料採礦/記錄管理工具，例如 Azure 監視器或 Splunk，最後長期保存。</span><span class="sxs-lookup"><span data-stu-id="d4277-218">Process them with an event aggregator and propagate the data to data-mining/log management tools like Azure Monitor or Splunk and eventually long-term archival.</span></span> |
| <span data-ttu-id="d4277-219">12</span><span class="sxs-lookup"><span data-stu-id="d4277-219">12</span></span> | <span data-ttu-id="d4277-220">管理進程</span><span class="sxs-lookup"><span data-stu-id="d4277-220">Admin Processes</span></span> | <span data-ttu-id="d4277-221">以一次性進程的形式執行管理/管理工作。</span><span class="sxs-lookup"><span data-stu-id="d4277-221">Run administrative/management tasks as one-off processes.</span></span> <span data-ttu-id="d4277-222">工作可包含資料清除和提取報表的分析。</span><span class="sxs-lookup"><span data-stu-id="d4277-222">Tasks can include data cleanup and pulling analytics for a report.</span></span> <span data-ttu-id="d4277-223">執行這些工作的工具應該從生產環境中叫用，但會與應用程式分開。</span><span class="sxs-lookup"><span data-stu-id="d4277-223">Tools executing these tasks should be  invoked from the production environment, but separately from the application.</span></span> |

<span data-ttu-id="d4277-224">在這本書中， [除了12個要素的應用程式外](https://content.pivotal.io/blog/beyond-the-twelve-factor-app)，撰寫了一份 Hoffman 詳細說明 (以 2011) 撰寫的原始12個因素。</span><span class="sxs-lookup"><span data-stu-id="d4277-224">In the book, [Beyond the Twelve-Factor App](https://content.pivotal.io/blog/beyond-the-twelve-factor-app), author Kevin Hoffman details each of the original 12 factors (written in 2011).</span></span> <span data-ttu-id="d4277-225">此外，他還討論三個其他因素，以反映現今的新式雲端應用程式設計。</span><span class="sxs-lookup"><span data-stu-id="d4277-225">Additionally, he discusses three additional factors that reflect today's modern cloud application design.</span></span>

|    |  <span data-ttu-id="d4277-226">新因素</span><span class="sxs-lookup"><span data-stu-id="d4277-226">New Factor</span></span> | <span data-ttu-id="d4277-227">說明</span><span class="sxs-lookup"><span data-stu-id="d4277-227">Explanation</span></span>  |
| :-------- | :-------- | :-------- |
| <span data-ttu-id="d4277-228">13</span><span class="sxs-lookup"><span data-stu-id="d4277-228">13</span></span> | <span data-ttu-id="d4277-229">API 優先</span><span class="sxs-lookup"><span data-stu-id="d4277-229">API First</span></span> | <span data-ttu-id="d4277-230">將所有專案設為服務。</span><span class="sxs-lookup"><span data-stu-id="d4277-230">Make everything a service.</span></span> <span data-ttu-id="d4277-231">假設您的程式碼將由前端用戶端、閘道或其他服務使用。</span><span class="sxs-lookup"><span data-stu-id="d4277-231">Assume your code will be consumed by a front-end client, gateway, or another service.</span></span> |
| <span data-ttu-id="d4277-232">14</span><span class="sxs-lookup"><span data-stu-id="d4277-232">14</span></span> | <span data-ttu-id="d4277-233">遙測</span><span class="sxs-lookup"><span data-stu-id="d4277-233">Telemetry</span></span> | <span data-ttu-id="d4277-234">在工作站上，您可以深入瞭解您的應用程式及其行為。</span><span class="sxs-lookup"><span data-stu-id="d4277-234">On a workstation, you have deep visibility into your application and its behavior.</span></span> <span data-ttu-id="d4277-235">在雲端中，您不需要這麼做。</span><span class="sxs-lookup"><span data-stu-id="d4277-235">In the cloud, you don't.</span></span> <span data-ttu-id="d4277-236">確定您的設計包含監視、網域特定和健全/系統資料的集合。</span><span class="sxs-lookup"><span data-stu-id="d4277-236">Make sure your design includes the collection of monitoring, domain-specific, and health/system data.</span></span> |
| <span data-ttu-id="d4277-237">15</span><span class="sxs-lookup"><span data-stu-id="d4277-237">15</span></span> | <span data-ttu-id="d4277-238">驗證/授權</span><span class="sxs-lookup"><span data-stu-id="d4277-238">Authentication/ Authorization</span></span>  | <span data-ttu-id="d4277-239">從一開始就執行身分識別。</span><span class="sxs-lookup"><span data-stu-id="d4277-239">Implement identity from the start.</span></span> <span data-ttu-id="d4277-240">請考慮 [RBAC (角色型存取控制) ](/azure/role-based-access-control/overview) 公用雲端中可用的功能。</span><span class="sxs-lookup"><span data-stu-id="d4277-240">Consider [RBAC (role-based access control)](/azure/role-based-access-control/overview) features available in public clouds.</span></span>  |

<span data-ttu-id="d4277-241">我們將在本章節和整個書籍中參考許多12個以上的因素。</span><span class="sxs-lookup"><span data-stu-id="d4277-241">We'll refer to many of the 12+ factors in this chapter and throughout the book.</span></span>

### <a name="critical-design-considerations"></a><span data-ttu-id="d4277-242">重大設計考慮</span><span class="sxs-lookup"><span data-stu-id="d4277-242">Critical Design Considerations</span></span>

<span data-ttu-id="d4277-243">除了12因數方法所提供的指引之外，您還必須在設計分散式系統時進行幾項重要的設計決策。</span><span class="sxs-lookup"><span data-stu-id="d4277-243">Beyond the guidance provided from the twelve-factor methodology, there are several critical design decisions you must make when constructing distributed systems.</span></span>

<span data-ttu-id="d4277-244">*通訊*</span><span class="sxs-lookup"><span data-stu-id="d4277-244">*Communication*</span></span>

<span data-ttu-id="d4277-245">前端用戶端應用程式會如何與已備份的終端核心服務進行通訊？</span><span class="sxs-lookup"><span data-stu-id="d4277-245">How will front-end client applications communicate with backed-end core services?</span></span> <span data-ttu-id="d4277-246">您是否允許直接通訊？</span><span class="sxs-lookup"><span data-stu-id="d4277-246">Will you allow direct communication?</span></span> <span data-ttu-id="d4277-247">或者，您是否可以使用提供彈性、控制和安全性的閘道外觀，將後端服務抽象化？</span><span class="sxs-lookup"><span data-stu-id="d4277-247">Or, might you abstract the back-end services with a gateway façade that provides  flexibility, control, and security?</span></span>

<span data-ttu-id="d4277-248">後端核心服務會如何彼此通訊？</span><span class="sxs-lookup"><span data-stu-id="d4277-248">How will back-end core services communicate with each other?</span></span> <span data-ttu-id="d4277-249">您是否允許直接 HTTP 呼叫，使其結合並影響效能和靈活性？</span><span class="sxs-lookup"><span data-stu-id="d4277-249">Will you allow direct HTTP calls that lead to coupling and impact performance and agility?</span></span> <span data-ttu-id="d4277-250">或者，您可以考慮使用佇列和主題技術來分離訊息嗎？</span><span class="sxs-lookup"><span data-stu-id="d4277-250">Or might you consider decoupled messaging with queue and topic technologies?</span></span>

<span data-ttu-id="d4277-251">詳細說明第4章： *雲端原生通訊模式*的通訊。</span><span class="sxs-lookup"><span data-stu-id="d4277-251">Communication is covered in detail Chapter 4, *Cloud-Native Communication Patterns*.</span></span>

<span data-ttu-id="d4277-252">*復原*</span><span class="sxs-lookup"><span data-stu-id="d4277-252">*Resiliency*</span></span>

<span data-ttu-id="d4277-253">微服務架構會將您的系統從同進程移至跨進程的網路通訊。</span><span class="sxs-lookup"><span data-stu-id="d4277-253">A microservices architecture moves your system from in-process to out-of-process network communication.</span></span> <span data-ttu-id="d4277-254">在分散式架構中，當服務 B 沒有回應服務 A 的網路呼叫時，會發生什麼事？</span><span class="sxs-lookup"><span data-stu-id="d4277-254">In a distributed architecture, what happens when Service B isn't responding to a network call from Service A?</span></span> <span data-ttu-id="d4277-255">或者，當服務 C 暫時無法使用時，以及其他呼叫它的服務會遭到封鎖時，會發生什麼事？</span><span class="sxs-lookup"><span data-stu-id="d4277-255">Or, what happens when Service C becomes temporarily unavailable and other services calling it are blocked?</span></span>

<span data-ttu-id="d4277-256">復原的詳細資訊請見第6章： *雲端原生復原*。</span><span class="sxs-lookup"><span data-stu-id="d4277-256">Resiliency is covered in detail Chapter 6, *Cloud-Native Resiliency*.</span></span>

<span data-ttu-id="d4277-257">*分散式資料*</span><span class="sxs-lookup"><span data-stu-id="d4277-257">*Distributed Data*</span></span>

<span data-ttu-id="d4277-258">根據設計，每個微服務都會封裝自己的資料，透過其公用介面公開作業。</span><span class="sxs-lookup"><span data-stu-id="d4277-258">By design, each microservice encapsulates its own data, exposing operations via its public interface.</span></span> <span data-ttu-id="d4277-259">如果是，您要如何查詢資料或跨多個服務執行交易？</span><span class="sxs-lookup"><span data-stu-id="d4277-259">If so, how do you query data or implement a transaction across multiple services?</span></span>

<span data-ttu-id="d4277-260">分散式資料詳細說明第5章： *雲端原生資料模式*。</span><span class="sxs-lookup"><span data-stu-id="d4277-260">Distributed data is covered in detail Chapter 5, *Cloud-Native Data Patterns*.</span></span>

<span data-ttu-id="d4277-261">*身分識別*</span><span class="sxs-lookup"><span data-stu-id="d4277-261">*Identity*</span></span>

<span data-ttu-id="d4277-262">您的服務會如何識別正在存取的使用者，以及他們擁有的許可權為何？</span><span class="sxs-lookup"><span data-stu-id="d4277-262">How will your service identify who is accessing it and what permissions they have?</span></span>

<span data-ttu-id="d4277-263">身分識別會詳細說明第8章，也就是身分 *識別*。</span><span class="sxs-lookup"><span data-stu-id="d4277-263">Identity is covered in detail Chapter 8, *Identity*.</span></span>

## <a name="microservices"></a><span data-ttu-id="d4277-264">微服務</span><span class="sxs-lookup"><span data-stu-id="d4277-264">Microservices</span></span>

<span data-ttu-id="d4277-265">雲端原生系統採用了微服務，這是用來建立新式應用程式的熱門架構樣式。</span><span class="sxs-lookup"><span data-stu-id="d4277-265">Cloud-native systems embrace microservices, a popular architectural style for constructing modern applications.</span></span>

<span data-ttu-id="d4277-266">以一組分散式小型獨立服務的形式建立，可透過共用網狀架構進行互動，微服務共用下列特性：</span><span class="sxs-lookup"><span data-stu-id="d4277-266">Built as a distributed set of small, independent services that interact through a shared fabric, microservices share the following characteristics:</span></span>

- <span data-ttu-id="d4277-267">每個都會在較大的網域內容中執行特定的商務功能。</span><span class="sxs-lookup"><span data-stu-id="d4277-267">Each implements a specific business capability within a larger domain context.</span></span>

- <span data-ttu-id="d4277-268">每個都是自主開發，而且可以獨立部署。</span><span class="sxs-lookup"><span data-stu-id="d4277-268">Each is developed autonomously and can be deployed independently.</span></span>

- <span data-ttu-id="d4277-269">每個都是自我自主封裝的資料儲存技術， (SQL、NoSQL) 和程式設計平臺。</span><span class="sxs-lookup"><span data-stu-id="d4277-269">Each is self-contained encapsulating its own data storage technology (SQL, NoSQL) and programming platform.</span></span>

- <span data-ttu-id="d4277-270">每個都在自己的進程中執行，並使用標準通訊協定（例如 HTTP/HTTPS、Websocket 或 [AMQP](https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol)）與其他人通訊。</span><span class="sxs-lookup"><span data-stu-id="d4277-270">Each runs in its own process and communicates with others using standard communication protocols such as HTTP/HTTPS, WebSockets, or [AMQP](https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol).</span></span>

- <span data-ttu-id="d4277-271">它們組合在一起，以構成應用程式。</span><span class="sxs-lookup"><span data-stu-id="d4277-271">They compose together to form an application.</span></span>

<span data-ttu-id="d4277-272">圖1-4 以微服務方法來對比整合型應用程式方法。</span><span class="sxs-lookup"><span data-stu-id="d4277-272">Figure 1-4 contrasts a monolithic application approach with a microservices approach.</span></span> <span data-ttu-id="d4277-273">請注意，單體是由在單一進程中執行的多層式架構所組成。</span><span class="sxs-lookup"><span data-stu-id="d4277-273">Note how the monolith is composed of a layered architecture, which executes in a single process.</span></span> <span data-ttu-id="d4277-274">它通常會使用關係資料庫。</span><span class="sxs-lookup"><span data-stu-id="d4277-274">It typically consumes a relational database.</span></span> <span data-ttu-id="d4277-275">但是，微服務方法會將功能隔離到包含邏輯和資料的獨立服務中。</span><span class="sxs-lookup"><span data-stu-id="d4277-275">The microservice approach, however, segregates functionality into independent services that include logic and data.</span></span> <span data-ttu-id="d4277-276">每個微服務都會裝載自己的資料存放區。</span><span class="sxs-lookup"><span data-stu-id="d4277-276">Each microservice hosts its own datastore.</span></span>

![整合型部署與微服務](./media/monolithic-vs-microservices.png)

<span data-ttu-id="d4277-278">**圖1-4。**</span><span class="sxs-lookup"><span data-stu-id="d4277-278">**Figure 1-4.**</span></span> <span data-ttu-id="d4277-279">整合型部署與微服務</span><span class="sxs-lookup"><span data-stu-id="d4277-279">Monolithic deployment versus microservices</span></span>

<span data-ttu-id="d4277-280">請注意，微服務如何從 [12 個因素的應用程式](https://12factor.net/)升級「一個程式碼基底，一個應用程式」的原則，如稍早的章節中所述。</span><span class="sxs-lookup"><span data-stu-id="d4277-280">Note how microservices promote the "One Codebase, One Application" principle from the [Twelve-Factor Application](https://12factor.net/), discussed earlier in the chapter.</span></span>

> <span data-ttu-id="d4277-281">*因數 \# 1 指定每個微服務的單一程式碼基底，儲存在其自己的儲存機制中。使用版本控制進行追蹤，可以部署到多個環境。」*</span><span class="sxs-lookup"><span data-stu-id="d4277-281">*Factor \#1  specifies "A single codebase for each microservice, stored in its own repository. Tracked with version control, it can deploy to multiple environments."*</span></span>

### <a name="why-microservices"></a><span data-ttu-id="d4277-282">使用微服務的理由？</span><span class="sxs-lookup"><span data-stu-id="d4277-282">Why microservices?</span></span>

<span data-ttu-id="d4277-283">微服務提供靈活性。</span><span class="sxs-lookup"><span data-stu-id="d4277-283">Microservices provide agility.</span></span>

<span data-ttu-id="d4277-284">稍早在本章中，我們比較了以單體建立的電子商務應用程式與微服務。</span><span class="sxs-lookup"><span data-stu-id="d4277-284">Earlier in the chapter, we compared an eCommerce application built as a monolith to that with microservices.</span></span> <span data-ttu-id="d4277-285">在此範例中，我們看到一些清楚的優點：</span><span class="sxs-lookup"><span data-stu-id="d4277-285">In the example, we saw some clear benefits:</span></span>

- <span data-ttu-id="d4277-286">每個微服務都有一個自發的生命週期，並且可以獨立且經常地進行部署。</span><span class="sxs-lookup"><span data-stu-id="d4277-286">Each microservice has an autonomous lifecycle and can evolve independently and deploy frequently.</span></span> <span data-ttu-id="d4277-287">您不必等候每季發行來部署新功能或更新。</span><span class="sxs-lookup"><span data-stu-id="d4277-287">You don't have to wait for a quarterly release to deploy a new features or update.</span></span> <span data-ttu-id="d4277-288">您可以更新複雜應用程式的小型區域，但降低整個系統中斷的風險。</span><span class="sxs-lookup"><span data-stu-id="d4277-288">You can update a small area of a complex application with less risk of disrupting the entire system.</span></span>

- <span data-ttu-id="d4277-289">每個微服務都可以獨立調整。</span><span class="sxs-lookup"><span data-stu-id="d4277-289">Each microservice can scale independently.</span></span> <span data-ttu-id="d4277-290">您不需將整個應用程式以單一單位的形式調整，而是只向外擴充需要更多處理能力或網路頻寬的服務。</span><span class="sxs-lookup"><span data-stu-id="d4277-290">Instead of scaling the entire application as a single unit, you scale out only those services that require more processing power or network bandwidth.</span></span> <span data-ttu-id="d4277-291">這種精細的調整方法可讓您更有效地控制系統，並在您調整系統的部分（而非所有）時，協助降低整體成本。</span><span class="sxs-lookup"><span data-stu-id="d4277-291">This  fine-grained approach to scaling provides for greater control of your system and helps to reduce overall costs as you scale portions of your system, not everything.</span></span>

<span data-ttu-id="d4277-292">[.Net 微服務：容器化 .Net 應用程式的架構](https://dotnet.microsoft.com/download/thank-you/microservices-architecture-ebook)是瞭解微服務的絕佳參考指南。</span><span class="sxs-lookup"><span data-stu-id="d4277-292">An excellent reference guide for understanding microservices is [.NET Microservices: Architecture for Containerized .NET Applications](https://dotnet.microsoft.com/download/thank-you/microservices-architecture-ebook).</span></span> <span data-ttu-id="d4277-293">這本書深入探討微服務的設計和架構。</span><span class="sxs-lookup"><span data-stu-id="d4277-293">The book deep dives into microservices design and architecture.</span></span> <span data-ttu-id="d4277-294">它隨附于可從 Microsoft 免費下載的 [完整堆疊微服務參考架構](https://github.com/dotnet-architecture/eShopOnContainers) 。</span><span class="sxs-lookup"><span data-stu-id="d4277-294">It's a companion for a [full-stack microservice reference architecture](https://github.com/dotnet-architecture/eShopOnContainers) available as a free download from Microsoft.</span></span>

### <a name="developing-microservices"></a><span data-ttu-id="d4277-295">開發微服務</span><span class="sxs-lookup"><span data-stu-id="d4277-295">Developing microservices</span></span>

<span data-ttu-id="d4277-296">您可以使用任何新式開發平臺來建立微服務。</span><span class="sxs-lookup"><span data-stu-id="d4277-296">Microservices can be created with any modern development platform.</span></span>

<span data-ttu-id="d4277-297">Microsoft .NET Core 平臺是絕佳的選擇。</span><span class="sxs-lookup"><span data-stu-id="d4277-297">The Microsoft .NET Core platform is an excellent choice.</span></span> <span data-ttu-id="d4277-298">免費且開放的原始碼，它有許多內建功能可簡化微服務的開發。</span><span class="sxs-lookup"><span data-stu-id="d4277-298">Free and open source, it has many built-in features to simplify microservice development.</span></span> <span data-ttu-id="d4277-299">.NET Core 是跨平臺。</span><span class="sxs-lookup"><span data-stu-id="d4277-299">.NET Core is cross-platform.</span></span> <span data-ttu-id="d4277-300">您可以在 Windows、macOS 和大部分的 Linux 類別上建立並執行應用程式。</span><span class="sxs-lookup"><span data-stu-id="d4277-300">Applications can be built and run on Windows, macOS, and most flavors of Linux.</span></span>

<span data-ttu-id="d4277-301">.NET Core 的效能非常高，且相較于 Node.js 和其他競爭平臺，也有相當程度的評分。</span><span class="sxs-lookup"><span data-stu-id="d4277-301">.NET Core is highly performant and has scored well in comparison to Node.js and other competing platforms.</span></span> <span data-ttu-id="d4277-302">有趣的是， [TechEmpower](https://www.techempower.com/) 在許多 web 應用程式平臺和架構之間進行了一組廣泛的 [效能基準](https://www.techempower.com/benchmarks/#section=data-r17&hw=ph&test=plaintext) 檢驗。</span><span class="sxs-lookup"><span data-stu-id="d4277-302">Interestingly, [TechEmpower](https://www.techempower.com/) conducted an extensive set of [performance benchmarks](https://www.techempower.com/benchmarks/#section=data-r17&hw=ph&test=plaintext) across many web application platforms and frameworks.</span></span> <span data-ttu-id="d4277-303">.NET Core 在上方 10-以上的 Node.js 和其他競爭平臺上進行評分。</span><span class="sxs-lookup"><span data-stu-id="d4277-303">.NET Core scored in the top 10 - well above Node.js and other competing platforms.</span></span>

<span data-ttu-id="d4277-304">.NET Core 是由 Microsoft 和 GitHub 上的 .NET 社區所維護。</span><span class="sxs-lookup"><span data-stu-id="d4277-304">.NET Core is maintained by Microsoft and the .NET community on GitHub.</span></span>

## <a name="containers"></a><span data-ttu-id="d4277-305">容器</span><span class="sxs-lookup"><span data-stu-id="d4277-305">Containers</span></span>

<span data-ttu-id="d4277-306">現今，您可以很自然地聆聽任何與*雲端原生*相關的交談中所述的「*容器*」一詞。</span><span class="sxs-lookup"><span data-stu-id="d4277-306">Nowadays, it's natural to hear the term *container* mentioned in any conversation concerning *cloud native*.</span></span> <span data-ttu-id="d4277-307">在《 [雲端原生模式](https://www.manning.com/books/cloud-native-patterns)，作者 Cornelia Davis 》中，會觀察「容器是雲端原生軟體的絕佳促成者」。</span><span class="sxs-lookup"><span data-stu-id="d4277-307">In the book, [Cloud Native Patterns](https://www.manning.com/books/cloud-native-patterns), author Cornelia Davis observes that, "Containers are a great enabler of cloud-native software."</span></span> <span data-ttu-id="d4277-308">雲端原生運算基礎將微服務容器化作為其 [雲端原生線索對應](https://raw.githubusercontent.com/cncf/trailmap/master/CNCF_TrailMap_latest.png) 的第一個步驟，也就是開始其雲端原生旅程的企業的指導方針。</span><span class="sxs-lookup"><span data-stu-id="d4277-308">The Cloud Native Computing Foundation places microservice containerization as the first step in their [Cloud-Native Trail Map](https://raw.githubusercontent.com/cncf/trailmap/master/CNCF_TrailMap_latest.png) - guidance for enterprises beginning their cloud-native journey.</span></span>

<span data-ttu-id="d4277-309">容器化微服務很簡單明瞭。</span><span class="sxs-lookup"><span data-stu-id="d4277-309">Containerizing a microservice is simple and straightforward.</span></span> <span data-ttu-id="d4277-310">程式碼、其相依性和執行時間會封裝到稱為 [容器映射](https://docs.docker.com/glossary/?term=image)的二進位檔中。</span><span class="sxs-lookup"><span data-stu-id="d4277-310">The code, its dependencies, and runtime are packaged into a binary called a [container image](https://docs.docker.com/glossary/?term=image).</span></span> <span data-ttu-id="d4277-311">映射會儲存在 [容器](https://caylent.com/container-registries/)登錄中，作為映射的儲存機制或程式庫。</span><span class="sxs-lookup"><span data-stu-id="d4277-311">Images are stored in a [container registry](https://caylent.com/container-registries/), which acts as a repository or library for images.</span></span> <span data-ttu-id="d4277-312">登錄可以位於您的開發電腦、資料中心或公用雲端中。</span><span class="sxs-lookup"><span data-stu-id="d4277-312">A registry can be located on your development computer, in your data center, or in a public cloud.</span></span> <span data-ttu-id="d4277-313">Docker 本身會透過 [Docker Hub](https://hub.docker.com/)維護公用登錄。</span><span class="sxs-lookup"><span data-stu-id="d4277-313">Docker itself maintains a public registry via [Docker Hub](https://hub.docker.com/).</span></span> <span data-ttu-id="d4277-314">Azure 雲端提供 [容器](https://azure.microsoft.com/services/container-registry/) 登錄來儲存容器映射，以接近將執行這些映射的雲端應用程式。</span><span class="sxs-lookup"><span data-stu-id="d4277-314">The Azure cloud features a [container registry](https://azure.microsoft.com/services/container-registry/) to store container images close to the cloud applications that will run them.</span></span>

<span data-ttu-id="d4277-315">如有需要，您可以將映射轉換成執行中的容器實例。</span><span class="sxs-lookup"><span data-stu-id="d4277-315">When needed, you transform the image into a running container instance.</span></span> <span data-ttu-id="d4277-316">此實例會在已安裝 [容器運行](https://kubernetes.io/docs/setup/production-environment/container-runtimes/) 時間引擎的任何電腦上執行。</span><span class="sxs-lookup"><span data-stu-id="d4277-316">The instance runs on any computer that has a [container runtime](https://kubernetes.io/docs/setup/production-environment/container-runtimes/) engine installed.</span></span> <span data-ttu-id="d4277-317">您可以視需要擁有多個容器化服務的實例。</span><span class="sxs-lookup"><span data-stu-id="d4277-317">You can have as many instances of the containerized service as needed.</span></span>

<span data-ttu-id="d4277-318">圖1-5 顯示三個不同的微服務，每個都在自己的容器中執行于單一主機上。</span><span class="sxs-lookup"><span data-stu-id="d4277-318">Figure 1-5 shows three different microservices, each in its own container, running on a single host.</span></span>

![在容器主機上執行的多個容器](./media/hosting-mulitple-containers.png)

<span data-ttu-id="d4277-320">**圖 1-5**。</span><span class="sxs-lookup"><span data-stu-id="d4277-320">**Figure 1-5**.</span></span> <span data-ttu-id="d4277-321">在容器主機上執行的多個容器</span><span class="sxs-lookup"><span data-stu-id="d4277-321">Multiple containers running on a container host</span></span>

<span data-ttu-id="d4277-322">請注意，每個容器如何維護自己的相依性和執行時間集合，這兩者可能不同。</span><span class="sxs-lookup"><span data-stu-id="d4277-322">Note how each container maintains its own set of dependencies and runtime, which can be different.</span></span> <span data-ttu-id="d4277-323">在這裡，我們會看到不同版本的產品微服務在相同的主機上執行。</span><span class="sxs-lookup"><span data-stu-id="d4277-323">Here, we see different versions of the Product microservice running on the same host.</span></span> <span data-ttu-id="d4277-324">每個容器都會共用基礎主機作業系統、記憶體和處理器的配量，但彼此隔離。</span><span class="sxs-lookup"><span data-stu-id="d4277-324">Each container shares a slice of the underlying host operating system, memory, and processor, but is isolated from one another.</span></span>

<span data-ttu-id="d4277-325">請注意容器模型如何充分利用 [12 因數應用程式](https://12factor.net/)的「相依性」原則。</span><span class="sxs-lookup"><span data-stu-id="d4277-325">Note how well the container model embraces the "Dependencies" principle from the [Twelve-Factor Application](https://12factor.net/).</span></span>

> <span data-ttu-id="d4277-326">*\#第2因數指定「每個微服務隔離並封裝本身的相依性，並在不影響整個系統的情況下進行變更」。*</span><span class="sxs-lookup"><span data-stu-id="d4277-326">*Factor \#2  specifies that "Each microservice isolates and packages its own dependencies, embracing changes without impacting the entire system."*</span></span>

<span data-ttu-id="d4277-327">容器同時支援 Linux 和 Windows 工作負載。</span><span class="sxs-lookup"><span data-stu-id="d4277-327">Containers support both Linux and Windows workloads.</span></span> <span data-ttu-id="d4277-328">Azure 雲端的涵蓋兩者都有。</span><span class="sxs-lookup"><span data-stu-id="d4277-328">The Azure cloud openly embraces both.</span></span> <span data-ttu-id="d4277-329">有趣的是，它是 Linux 而非 Windows Server，已成為 Azure 中最受歡迎的作業系統。</span><span class="sxs-lookup"><span data-stu-id="d4277-329">Interestingly, it's Linux, not Windows Server, that has become the most popular operating system in Azure.</span></span>

<span data-ttu-id="d4277-330">雖然有數個容器廠商存在，但 Docker 已獲得 lion 的市場分享。</span><span class="sxs-lookup"><span data-stu-id="d4277-330">While several container vendors exist, Docker has captured the lion's share of the market.</span></span> <span data-ttu-id="d4277-331">公司已推動軟體容器的移動。</span><span class="sxs-lookup"><span data-stu-id="d4277-331">The company has been driving the software container movement.</span></span> <span data-ttu-id="d4277-332">它已成為封裝、部署和執行雲端原生應用程式的事實上標準。</span><span class="sxs-lookup"><span data-stu-id="d4277-332">It has become the de facto standard for packaging, deploying, and running cloud-native applications.</span></span>

### <a name="why-containers"></a><span data-ttu-id="d4277-333">為何選擇容器？</span><span class="sxs-lookup"><span data-stu-id="d4277-333">Why containers?</span></span>

<span data-ttu-id="d4277-334">容器提供可攜性，並保證環境之間的一致性。</span><span class="sxs-lookup"><span data-stu-id="d4277-334">Containers provide portability and guarantee consistency across environments.</span></span> <span data-ttu-id="d4277-335">將所有專案封裝成單一套件，即可將微服務及其相依性與基礎結構 *隔離* 。</span><span class="sxs-lookup"><span data-stu-id="d4277-335">By encapsulating everything into a single package, you *isolate* the microservice and its dependencies from the underlying infrastructure.</span></span>

<span data-ttu-id="d4277-336">您可以在具有 Docker 執行時間引擎的任何環境中部署相同的容器。</span><span class="sxs-lookup"><span data-stu-id="d4277-336">You can deploy that same container in any environment that has the Docker runtime engine.</span></span> <span data-ttu-id="d4277-337">容器化工作負載也可消除使用架構、軟體程式庫和執行時間引擎預先設定每個環境的費用。</span><span class="sxs-lookup"><span data-stu-id="d4277-337">Containerized workloads also eliminate the expense of pre-configuring each environment with frameworks, software libraries, and runtime engines.</span></span>

<span data-ttu-id="d4277-338">藉由共用基礎作業系統和主機資源，容器的使用量會比完整虛擬機器小得多。</span><span class="sxs-lookup"><span data-stu-id="d4277-338">By sharing the underlying operating system and host resources, containers have a much smaller footprint than a full virtual machine.</span></span> <span data-ttu-id="d4277-339">較小的大小會增加指定主機一次可以執行的 *密度*或微服務數目。</span><span class="sxs-lookup"><span data-stu-id="d4277-339">The smaller size increases the *density*, or number of microservices, that a given host can run at one time.</span></span>

### <a name="container-orchestration"></a><span data-ttu-id="d4277-340">容器協調流程</span><span class="sxs-lookup"><span data-stu-id="d4277-340">Container orchestration</span></span>

<span data-ttu-id="d4277-341">當 Docker 之類的工具建立映射並執行容器時，您也需要工具來管理它們。</span><span class="sxs-lookup"><span data-stu-id="d4277-341">While tools such as Docker create images and run containers, you also need tools to manage them.</span></span> <span data-ttu-id="d4277-342">使用稱為容器協調器的特殊軟體程式來管理容器。</span><span class="sxs-lookup"><span data-stu-id="d4277-342">Container management is done with a special software program called a container orchestrator.</span></span> <span data-ttu-id="d4277-343">大規模操作時，容器協調流程是不可或缺的。</span><span class="sxs-lookup"><span data-stu-id="d4277-343">When operating at scale, container orchestration is essential.</span></span>

<span data-ttu-id="d4277-344">圖1-6 顯示容器協調器提供的管理工作。</span><span class="sxs-lookup"><span data-stu-id="d4277-344">Figure 1-6 shows management tasks that container orchestrators provide.</span></span>

![容器協調器的用途](./media/what-container-orchestrators-do.png)

<span data-ttu-id="d4277-346">**圖 1-6**。</span><span class="sxs-lookup"><span data-stu-id="d4277-346">**Figure 1-6**.</span></span> <span data-ttu-id="d4277-347">容器協調器的用途</span><span class="sxs-lookup"><span data-stu-id="d4277-347">What container orchestrators do</span></span>

<span data-ttu-id="d4277-348">下表描述一般協調流程工作。</span><span class="sxs-lookup"><span data-stu-id="d4277-348">The following table describes common orchestration tasks.</span></span>

|  <span data-ttu-id="d4277-349">工作</span><span class="sxs-lookup"><span data-stu-id="d4277-349">Tasks</span></span> | <span data-ttu-id="d4277-350">說明</span><span class="sxs-lookup"><span data-stu-id="d4277-350">Explanation</span></span>  |
| :-------- | :-------- |
| <span data-ttu-id="d4277-351">排程</span><span class="sxs-lookup"><span data-stu-id="d4277-351">Scheduling</span></span> | <span data-ttu-id="d4277-352">自動布建容器實例。</span><span class="sxs-lookup"><span data-stu-id="d4277-352">Automatically provision container instances.</span></span>|
| <span data-ttu-id="d4277-353">親和性/反親和性</span><span class="sxs-lookup"><span data-stu-id="d4277-353">Affinity/anti-affinity</span></span> | <span data-ttu-id="d4277-354">布建鄰近或相距離彼此的容器，以協助提供可用性和效能。</span><span class="sxs-lookup"><span data-stu-id="d4277-354">Provision containers nearby or far apart from each other, helping  availability and performance.</span></span> |
| <span data-ttu-id="d4277-355">健康狀況監視</span><span class="sxs-lookup"><span data-stu-id="d4277-355">Health monitoring</span></span> | <span data-ttu-id="d4277-356">自動偵測並修正失敗。</span><span class="sxs-lookup"><span data-stu-id="d4277-356">Automatically detect and correct failures.</span></span>|
| <span data-ttu-id="d4277-357">容錯移轉</span><span class="sxs-lookup"><span data-stu-id="d4277-357">Failover</span></span> | <span data-ttu-id="d4277-358">自動將失敗的實例重新布建至狀況良好的機器。</span><span class="sxs-lookup"><span data-stu-id="d4277-358">Automatically reprovision failed instance to healthy machines.</span></span>|
| <span data-ttu-id="d4277-359">調整大小</span><span class="sxs-lookup"><span data-stu-id="d4277-359">Scaling</span></span> | <span data-ttu-id="d4277-360">自動新增或移除容器實例以符合需求。</span><span class="sxs-lookup"><span data-stu-id="d4277-360">Automatically add or remove container instance to meet demand.</span></span>|
| <span data-ttu-id="d4277-361">網路功能</span><span class="sxs-lookup"><span data-stu-id="d4277-361">Networking</span></span> | <span data-ttu-id="d4277-362">管理容器通訊的網路重迭。</span><span class="sxs-lookup"><span data-stu-id="d4277-362">Manage a networking overlay for container communication.</span></span>|
| <span data-ttu-id="d4277-363">服務探索</span><span class="sxs-lookup"><span data-stu-id="d4277-363">Service Discovery</span></span> | <span data-ttu-id="d4277-364">讓容器彼此找出。</span><span class="sxs-lookup"><span data-stu-id="d4277-364">Enable containers to locate each other.</span></span>|
| <span data-ttu-id="d4277-365">輪流升級</span><span class="sxs-lookup"><span data-stu-id="d4277-365">Rolling Upgrades</span></span> | <span data-ttu-id="d4277-366">協調增量升級與零停機部署。</span><span class="sxs-lookup"><span data-stu-id="d4277-366">Coordinate incremental upgrades with zero downtime deployment.</span></span> <span data-ttu-id="d4277-367">自動回復有問題的變更。</span><span class="sxs-lookup"><span data-stu-id="d4277-367">Automatically roll back problematic changes.</span></span>|

<span data-ttu-id="d4277-368">請注意，協調器如何從 [12 因數應用程式](https://12factor.net/)中採用 disposability 和並行原則，如稍早的章節中所述。</span><span class="sxs-lookup"><span data-stu-id="d4277-368">Note how orchestrators embrace the disposability and concurrency principles from the [Twelve-Factor Application](https://12factor.net/), discussed earlier in the chapter.</span></span>

> <span data-ttu-id="d4277-369">*第 \# 9 因數指定「服務實例應該是可處置的，favoring 快速的新創公司，以增加擴充性機會和正常關機，讓系統保持在正確的狀態。Docker 容器和協調器本身就能滿足這項需求。」*</span><span class="sxs-lookup"><span data-stu-id="d4277-369">*Factor \#9  specifies that "Service instances should be disposable, favoring fast startups to increase scalability opportunities and graceful shutdowns to leave the system in a correct state. Docker containers along with an orchestrator inherently satisfy this requirement."*</span></span>

> <span data-ttu-id="d4277-370">*\#第8因數指定「服務會在大量的小型相同程式之間相應放大 (複製) ，而不是在功能最強大的電腦上向上擴充單一大型實例。」*</span><span class="sxs-lookup"><span data-stu-id="d4277-370">*Factor \#8  specifies that "Services scale out across a large number of small identical processes (copies) as opposed to scaling-up a single large instance on the most powerful machine available."*</span></span>

<span data-ttu-id="d4277-371">由於有數個容器協調器存在， [Kubernetes](https://kubernetes.io/docs/concepts/overview/what-is-kubernetes/) 已成為雲端原生世界的實際標準。</span><span class="sxs-lookup"><span data-stu-id="d4277-371">While several container orchestrators exist, [Kubernetes](https://kubernetes.io/docs/concepts/overview/what-is-kubernetes/) has become the de facto standard for the cloud-native world.</span></span> <span data-ttu-id="d4277-372">它是可供管理容器化工作負載的可移植、可擴充、開放原始碼平臺。</span><span class="sxs-lookup"><span data-stu-id="d4277-372">It's a portable, extensible, open-source platform for managing containerized workloads.</span></span>

<span data-ttu-id="d4277-373">您可以裝載自己的 Kubernetes 實例，但您會負責布建和管理其資源，這可能很複雜。</span><span class="sxs-lookup"><span data-stu-id="d4277-373">You could host your own instance of Kubernetes, but then you'd be responsible for provisioning and managing its resources - which can be complex.</span></span> <span data-ttu-id="d4277-374">Azure 雲端功能 Kubernetes 為受控服務， [Azure Kubernetes Service (AKS) ](https://azure.microsoft.com/services/kubernetes-service/)。</span><span class="sxs-lookup"><span data-stu-id="d4277-374">The Azure cloud features Kubernetes as a managed service, [Azure Kubernetes Service (AKS)](https://azure.microsoft.com/services/kubernetes-service/).</span></span> <span data-ttu-id="d4277-375">受管理的服務可讓您充分利用其功能，而不需要安裝和維護它。</span><span class="sxs-lookup"><span data-stu-id="d4277-375">A managed service allows you to fully leverage its features, without having to install and maintain it.</span></span>

<span data-ttu-id="d4277-376">Azure Kubernetes Services 詳細說明第2章： *調整雲端原生應用程式*。</span><span class="sxs-lookup"><span data-stu-id="d4277-376">Azure Kubernetes Services is covered in detail Chapter 2, *Scaling Cloud-Native Applications*.</span></span>

## <a name="backing-services"></a><span data-ttu-id="d4277-377">支援服務</span><span class="sxs-lookup"><span data-stu-id="d4277-377">Backing services</span></span>

<span data-ttu-id="d4277-378">雲端原生系統取決於許多不同的輔助資源，例如資料存放區、訊息代理程式、監視和身分識別服務。</span><span class="sxs-lookup"><span data-stu-id="d4277-378">Cloud-native systems depend upon many different ancillary resources, such as data stores, message brokers, monitoring, and identity services.</span></span> <span data-ttu-id="d4277-379">這些服務稱為「 [支援服務](https://12factor.net/backing-services)」。</span><span class="sxs-lookup"><span data-stu-id="d4277-379">These services are known as [backing services](https://12factor.net/backing-services).</span></span>

 <span data-ttu-id="d4277-380">圖1-7 顯示雲端原生系統所耗用的許多常見支援服務。</span><span class="sxs-lookup"><span data-stu-id="d4277-380">Figure 1-7 shows many common backing services that cloud-native systems consume.</span></span>

![常見的支援服務](./media/common-backing-services.png)

<span data-ttu-id="d4277-382">**圖 1-7**。</span><span class="sxs-lookup"><span data-stu-id="d4277-382">**Figure 1-7**.</span></span> <span data-ttu-id="d4277-383">常見的支援服務</span><span class="sxs-lookup"><span data-stu-id="d4277-383">Common backing services</span></span>

<span data-ttu-id="d4277-384">備份服務會從 [十二個因素的應用程式](https://12factor.net/)升級 "無狀態" 原則，如稍早的章節中所述。</span><span class="sxs-lookup"><span data-stu-id="d4277-384">Backing services promote the "Statelessness" principle from the [Twelve-Factor Application](https://12factor.net/), discussed earlier in the chapter.</span></span>

><span data-ttu-id="d4277-385">\* \# 第6因數\* 指定：「每個微服務應該在自己的進程中執行，並與其他執行中的服務隔離。</span><span class="sxs-lookup"><span data-stu-id="d4277-385">*Factor \#6* specifies that, "Each microservice should execute in its own process, isolated from other running services.</span></span> <span data-ttu-id="d4277-386">具體化支援服務的必要狀態，例如分散式快取或資料存放區。」</span><span class="sxs-lookup"><span data-stu-id="d4277-386">Externalize required state to a backing service such as a distributed cache or data store."</span></span>

<span data-ttu-id="d4277-387">您可以裝載您自己的支援服務，但是您必須負責授權、布建和管理這些資源。</span><span class="sxs-lookup"><span data-stu-id="d4277-387">You could host your own backing services, but then you'd be responsible for licensing, provisioning, and managing those resources.</span></span>

<span data-ttu-id="d4277-388">雲端提供者提供各式各樣的 *受控支援服務。*</span><span class="sxs-lookup"><span data-stu-id="d4277-388">Cloud providers offer a rich assortment of *managed backing services.*</span></span> <span data-ttu-id="d4277-389">您只需使用服務，而不是擁有服務。</span><span class="sxs-lookup"><span data-stu-id="d4277-389">Instead of owning the service, you simply consume it.</span></span> <span data-ttu-id="d4277-390">此提供者會大規模地操作資源，並承擔效能、安全性和維護的責任。</span><span class="sxs-lookup"><span data-stu-id="d4277-390">The provider operates the resource at scale and bears the responsibility for performance, security, and maintenance.</span></span> <span data-ttu-id="d4277-391">服務內建監視、冗余和可用性。</span><span class="sxs-lookup"><span data-stu-id="d4277-391">Monitoring, redundancy, and availability are built into the service.</span></span> <span data-ttu-id="d4277-392">提供者完全支援其受控服務-開啟票證，並修正您的問題。</span><span class="sxs-lookup"><span data-stu-id="d4277-392">Providers fully support their managed services - open a ticket and they fix your issue.</span></span>

<span data-ttu-id="d4277-393">雲端原生系統優先于雲端廠商提供受管理的支援服務。</span><span class="sxs-lookup"><span data-stu-id="d4277-393">Cloud-native systems favor managed backing services from cloud vendors.</span></span> <span data-ttu-id="d4277-394">節省時間與人力很棒。</span><span class="sxs-lookup"><span data-stu-id="d4277-394">The savings in time and labor are great.</span></span> <span data-ttu-id="d4277-395">裝載您自己和遇到問題的作業風險，可能很快就會耗費資源。</span><span class="sxs-lookup"><span data-stu-id="d4277-395">The operational risk of hosting your own and experiencing trouble can get expensive fast.</span></span>

<span data-ttu-id="d4277-396">最佳做法是將支援服務視為 *附加的資源*，動態地系結至微服務，其中 (URL 和認證) 儲存在外部設定中。</span><span class="sxs-lookup"><span data-stu-id="d4277-396">A best practice is to treat a backing service as an *attached resource*, dynamically bound to a microservice with information (a URL and credentials) stored in an external configuration.</span></span> <span data-ttu-id="d4277-397">本指南將在第一章稍早所討論的 [12 要素應用程式](https://12factor.net/)中拼錯。</span><span class="sxs-lookup"><span data-stu-id="d4277-397">This guidance is spelled out in the [Twelve-Factor Application](https://12factor.net/), discussed earlier in the chapter.</span></span>

><span data-ttu-id="d4277-398">*因數 \# 4* 指定應透過可定址的 URL 公開支援服務」。</span><span class="sxs-lookup"><span data-stu-id="d4277-398">*Factor \#4* specifies that backing services "should be exposed via an addressable URL.</span></span> <span data-ttu-id="d4277-399">這樣做會將資源與應用程式分離，讓它能夠互換。」</span><span class="sxs-lookup"><span data-stu-id="d4277-399">Doing so decouples the resource from the application, enabling it to be interchangeable."</span></span>

><span data-ttu-id="d4277-400">\* \# 第3因數\* 指定「透過程式碼以外的設定管理工具，將設定資訊移出微服務和外部化。」</span><span class="sxs-lookup"><span data-stu-id="d4277-400">*Factor \#3* specifies that "Configuration information is moved out of the microservice and externalized through a configuration management tool outside of the code."</span></span>

<span data-ttu-id="d4277-401">使用這個模式時，可以在不變更程式碼的情況下附加和卸離支援服務。</span><span class="sxs-lookup"><span data-stu-id="d4277-401">With this pattern, a backing service can be attached and detached without code changes.</span></span> <span data-ttu-id="d4277-402">您可以將微服務從 QA 升階到預備環境。</span><span class="sxs-lookup"><span data-stu-id="d4277-402">You might promote a microservice from QA to a staging environment.</span></span> <span data-ttu-id="d4277-403">您可以將微服務設定更新為指向預備環境中的支援服務，並透過環境變數將設定插入容器中。</span><span class="sxs-lookup"><span data-stu-id="d4277-403">You update the microservice configuration to point to the backing services in staging and inject the settings into your container through an environment variable.</span></span>

<span data-ttu-id="d4277-404">雲端廠商會提供 Api，讓您與其專屬的支援服務進行通訊。</span><span class="sxs-lookup"><span data-stu-id="d4277-404">Cloud vendors provide APIs for you to communicate with their proprietary backing services.</span></span> <span data-ttu-id="d4277-405">這些程式庫會封裝管線和複雜度。</span><span class="sxs-lookup"><span data-stu-id="d4277-405">These libraries encapsulate the plumbing and complexity.</span></span> <span data-ttu-id="d4277-406">直接與這些 Api 通訊會將您的程式碼緊密結合到支援服務。</span><span class="sxs-lookup"><span data-stu-id="d4277-406">Communicating directly with these APIs will tightly couple your code to the backing service.</span></span> <span data-ttu-id="d4277-407">更好的作法是避免廠商 API 的執行詳細資料。</span><span class="sxs-lookup"><span data-stu-id="d4277-407">It's a better practice to insulate the implementation details of the vendor API.</span></span> <span data-ttu-id="d4277-408">引進 intermediation 層或中繼 API，將一般作業公開給您的服務程式代碼。</span><span class="sxs-lookup"><span data-stu-id="d4277-408">Introduce an intermediation layer, or intermediate API, exposing generic operations to your service code.</span></span> <span data-ttu-id="d4277-409">這項鬆散的結合可讓您交換另一個支援服務，或將程式碼移至不同的公用雲端，而不需要變更主線服務程式代碼。</span><span class="sxs-lookup"><span data-stu-id="d4277-409">This loose coupling enables you to swap out one backing service for another or move your code to a different public cloud without having to make changes to the mainline service code.</span></span>

<span data-ttu-id="d4277-410">支援服務將在第5章、 *雲端原生資料模式*和第4章（ *雲端原生通訊模式*）中詳細討論。</span><span class="sxs-lookup"><span data-stu-id="d4277-410">Backing services are discussed in detail Chapter 5, *Cloud-Native Data Patterns*, and Chapter 4, *Cloud-Native Communication Patterns*.</span></span>

## <a name="automation"></a><span data-ttu-id="d4277-411">自動化</span><span class="sxs-lookup"><span data-stu-id="d4277-411">Automation</span></span>

<span data-ttu-id="d4277-412">如您所見，雲端原生系統採用微服務、容器和新式系統設計，以達成速度和靈活性。</span><span class="sxs-lookup"><span data-stu-id="d4277-412">As you've seen, cloud-native systems embrace microservices, containers, and modern system design to achieve speed and agility.</span></span> <span data-ttu-id="d4277-413">但是，這只是故事的一部分。</span><span class="sxs-lookup"><span data-stu-id="d4277-413">But, that's only part of the story.</span></span> <span data-ttu-id="d4277-414">如何布建這些系統執行所在的雲端環境？</span><span class="sxs-lookup"><span data-stu-id="d4277-414">How do you provision the cloud environments upon which these systems run?</span></span> <span data-ttu-id="d4277-415">如何快速部署應用程式功能和更新？</span><span class="sxs-lookup"><span data-stu-id="d4277-415">How do you rapidly deploy app features and updates?</span></span> <span data-ttu-id="d4277-416">您要如何將完整圖片弄整？</span><span class="sxs-lookup"><span data-stu-id="d4277-416">How do you round out the full picture?</span></span>

<span data-ttu-id="d4277-417">輸入廣泛接受的 [基礎結構即程式碼](/azure/devops/learn/what-is-infrastructure-as-code)或 IaC 作法。</span><span class="sxs-lookup"><span data-stu-id="d4277-417">Enter the widely accepted practice of [Infrastructure as Code](/azure/devops/learn/what-is-infrastructure-as-code), or IaC.</span></span>

<span data-ttu-id="d4277-418">透過 IaC，您可以將平臺布建和應用程式部署自動化。</span><span class="sxs-lookup"><span data-stu-id="d4277-418">With IaC, you automate platform provisioning and application deployment.</span></span> <span data-ttu-id="d4277-419">您基本上會將軟體工程實務（例如測試和版本控制）套用至您的 DevOps 實務。</span><span class="sxs-lookup"><span data-stu-id="d4277-419">You essentially apply software engineering practices such as testing and versioning to your DevOps practices.</span></span> <span data-ttu-id="d4277-420">您的基礎結構和部署是自動化、一致且可重複的。</span><span class="sxs-lookup"><span data-stu-id="d4277-420">Your infrastructure and deployments are automated, consistent, and repeatable.</span></span>

### <a name="automating-infrastructure"></a><span data-ttu-id="d4277-421">自動化基礎結構</span><span class="sxs-lookup"><span data-stu-id="d4277-421">Automating infrastructure</span></span>

<span data-ttu-id="d4277-422">[Azure Resource Manager](/azure/azure-resource-manager/management/overview)、Terraform 和[Azure CLI](/cli/azure/)之類的工具，可讓您以宣告方式編寫需要的雲端基礎結構腳本。</span><span class="sxs-lookup"><span data-stu-id="d4277-422">Tools like [Azure Resource Manager](/azure/azure-resource-manager/management/overview), Terraform, and the [Azure CLI](/cli/azure/), enable you to declaratively script the cloud infrastructure you require.</span></span> <span data-ttu-id="d4277-423">資源名稱、位置、容量和密碼都是參數化和動態的。</span><span class="sxs-lookup"><span data-stu-id="d4277-423">Resource names, locations, capacities, and secrets are parameterized and dynamic.</span></span> <span data-ttu-id="d4277-424">腳本已建立版本，並簽入原始檔控制中做為專案的成品。</span><span class="sxs-lookup"><span data-stu-id="d4277-424">The script is versioned and checked into source control as an artifact of your project.</span></span> <span data-ttu-id="d4277-425">您可以叫用腳本來跨系統內容布建一致且可重複的基礎結構，例如 QA、預備環境和生產環境。</span><span class="sxs-lookup"><span data-stu-id="d4277-425">You invoke the script to provision a consistent and repeatable infrastructure across system environments, such as QA, staging, and production.</span></span>

<span data-ttu-id="d4277-426">在幕後，IaC 具有等冪性，這表示您可以執行相同的腳本，而不需要副作用。</span><span class="sxs-lookup"><span data-stu-id="d4277-426">Under the hood, IaC is idempotent, meaning that you can run the same script over and over without side effects.</span></span> <span data-ttu-id="d4277-427">如果小組需要進行變更，他們會編輯並重新執行腳本。</span><span class="sxs-lookup"><span data-stu-id="d4277-427">If the team needs to make a change, they edit and rerun the script.</span></span> <span data-ttu-id="d4277-428">只有更新的資源會受到影響。</span><span class="sxs-lookup"><span data-stu-id="d4277-428">Only the updated resources are affected.</span></span>

<span data-ttu-id="d4277-429">在這篇文章中， [什麼是基礎結構即程式碼](/azure/devops/learn/what-is-infrastructure-as-code)，作者 Sam 作者: guckenheimer 描述了「如何」，這是「實行 IaC 的團隊可以快速且大規模地提供穩定的環境。</span><span class="sxs-lookup"><span data-stu-id="d4277-429">In the article, [What is Infrastructure as Code](/azure/devops/learn/what-is-infrastructure-as-code), Author Sam Guckenheimer describes how, "Teams who implement IaC can deliver stable environments rapidly and at scale.</span></span> <span data-ttu-id="d4277-430">小組避免手動設定環境，並透過程式碼代表其環境的預期狀態，來強制執行一致性。</span><span class="sxs-lookup"><span data-stu-id="d4277-430">Teams avoid manual configuration of environments and enforce consistency by representing the desired state of their environments via code.</span></span> <span data-ttu-id="d4277-431">使用 IaC 的基礎結構部署是可重複的，可防止設定漂移或遺失相依性所造成的執行時間問題。</span><span class="sxs-lookup"><span data-stu-id="d4277-431">Infrastructure deployments with IaC are repeatable and prevent runtime issues caused by configuration drift or missing dependencies.</span></span> <span data-ttu-id="d4277-432">DevOps 團隊可以搭配一組整合的實務和工具，快速、可靠且大規模地傳遞應用程式及其支援的基礎結構。」</span><span class="sxs-lookup"><span data-stu-id="d4277-432">DevOps teams can work together with a unified set of practices and tools to deliver applications and their supporting infrastructure rapidly, reliably, and at scale."</span></span>

### <a name="automating-deployments"></a><span data-ttu-id="d4277-433">自動化部署</span><span class="sxs-lookup"><span data-stu-id="d4277-433">Automating deployments</span></span>

<span data-ttu-id="d4277-434">稍早所述的 [12 因數應用程式](https://12factor.net/)，會在將完成的程式碼轉換成執行中的應用程式時，呼叫個別的步驟。</span><span class="sxs-lookup"><span data-stu-id="d4277-434">The [Twelve-Factor Application](https://12factor.net/), discussed earlier, calls for separate steps when transforming completed code into a running application.</span></span>

> <span data-ttu-id="d4277-435">\* \# 第5因數\* 指定「每個版本都必須在組建、發行和執行階段之間強制執行嚴格的分隔。</span><span class="sxs-lookup"><span data-stu-id="d4277-435">*Factor \#5* specifies that "Each release must enforce a strict separation across the build, release and run stages.</span></span> <span data-ttu-id="d4277-436">每個都應該以唯一的識別碼標記，並支援復原的能力。」</span><span class="sxs-lookup"><span data-stu-id="d4277-436">Each should be tagged with a unique ID and support the ability to roll back."</span></span>

<span data-ttu-id="d4277-437">新式 CI/CD 系統可協助滿足此原則。</span><span class="sxs-lookup"><span data-stu-id="d4277-437">Modern CI/CD systems help fulfill this principle.</span></span> <span data-ttu-id="d4277-438">它們提供個別的部署步驟，並協助確保使用者可立即使用的一致且品質的程式碼。</span><span class="sxs-lookup"><span data-stu-id="d4277-438">They provide separate deployment steps and help ensure consistent and quality code that's readily available to users.</span></span>

<span data-ttu-id="d4277-439">圖1-8 顯示整個部署程式的分隔。</span><span class="sxs-lookup"><span data-stu-id="d4277-439">Figure 1-8 shows the separation across the deployment process.</span></span>

![CI/CD 管線中的部署步驟](./media/build-release-run-pipeline.png)

<span data-ttu-id="d4277-441">**圖 1-8**。</span><span class="sxs-lookup"><span data-stu-id="d4277-441">**Figure 1-8**.</span></span> <span data-ttu-id="d4277-442">CI/CD 管線中的部署步驟</span><span class="sxs-lookup"><span data-stu-id="d4277-442">Deployment steps in a CI/CD Pipeline</span></span>

<span data-ttu-id="d4277-443">在上圖中，請特別注意工作的分隔。</span><span class="sxs-lookup"><span data-stu-id="d4277-443">In the previous figure, pay special attention to separation of tasks.</span></span>

<span data-ttu-id="d4277-444">開發人員在其開發環境中建立一項功能，並逐一查看所謂程式碼的「內部迴圈」、執行和偵錯工具。</span><span class="sxs-lookup"><span data-stu-id="d4277-444">The developer constructs a feature in their development environment, iterating through what is called the "inner loop" of code, run, and debug.</span></span> <span data-ttu-id="d4277-445">完成時，該程式碼會 *推送* 至程式碼存放庫，例如 GitHub、Azure DevOps 或 BitBucket。</span><span class="sxs-lookup"><span data-stu-id="d4277-445">When complete, that code is *pushed* into a code repository, such as GitHub, Azure DevOps, or BitBucket.</span></span>

<span data-ttu-id="d4277-446">推送會觸發將程式碼轉換為二進位成品的組建階段。</span><span class="sxs-lookup"><span data-stu-id="d4277-446">The push triggers a build stage that transforms the code into a binary artifact.</span></span> <span data-ttu-id="d4277-447">這項工作是以 [持續整合 (CI) ](https://martinfowler.com/articles/continuousIntegration.html) 管線來執行。</span><span class="sxs-lookup"><span data-stu-id="d4277-447">The work is implemented with a [Continuous Integration (CI)](https://martinfowler.com/articles/continuousIntegration.html) pipeline.</span></span> <span data-ttu-id="d4277-448">它會自動建立、測試及封裝應用程式。</span><span class="sxs-lookup"><span data-stu-id="d4277-448">It automatically builds, tests, and packages the application.</span></span>

<span data-ttu-id="d4277-449">發行階段會挑選二進位成品、套用外部應用程式和環境設定資訊，並產生不可變的版本。</span><span class="sxs-lookup"><span data-stu-id="d4277-449">The release stage picks up the binary artifact, applies external application and environment configuration information, and produces an immutable release.</span></span> <span data-ttu-id="d4277-450">發行會部署到指定的環境。</span><span class="sxs-lookup"><span data-stu-id="d4277-450">The release is deployed to a specified environment.</span></span> <span data-ttu-id="d4277-451">這項工作是利用 [持續傳遞 (CD) ](https://martinfowler.com/bliki/ContinuousDelivery.html) 管線來執行。</span><span class="sxs-lookup"><span data-stu-id="d4277-451">The work is implemented with a [Continuous Delivery(CD)](https://martinfowler.com/bliki/ContinuousDelivery.html) pipeline.</span></span> <span data-ttu-id="d4277-452">每個版本都應該是可辨識的。</span><span class="sxs-lookup"><span data-stu-id="d4277-452">Each release should be identifiable.</span></span> <span data-ttu-id="d4277-453">您可以說：「這個部署正在執行應用程式的版本2.1.1」。</span><span class="sxs-lookup"><span data-stu-id="d4277-453">You can say, "This deployment is running Release 2.1.1 of the application."</span></span>

<span data-ttu-id="d4277-454">最後，已發行的功能會在目標執行環境中執行。</span><span class="sxs-lookup"><span data-stu-id="d4277-454">Finally, the released feature is run in the target execution environment.</span></span> <span data-ttu-id="d4277-455">版本是不可變的，這表示任何變更都必須建立新的版本。</span><span class="sxs-lookup"><span data-stu-id="d4277-455">Releases are immutable meaning that any change must create a new release.</span></span>

<span data-ttu-id="d4277-456">運用這些實務，組織也徹底演進了它們出貨軟體的方式。</span><span class="sxs-lookup"><span data-stu-id="d4277-456">Applying these practices, organizations have radically evolved how they ship software.</span></span> <span data-ttu-id="d4277-457">許多已從每季版本移至隨選更新。</span><span class="sxs-lookup"><span data-stu-id="d4277-457">Many have moved from quarterly releases to on-demand updates.</span></span> <span data-ttu-id="d4277-458">其目標是要及早在開發週期中捕捉問題，以修正成本較低的問題。</span><span class="sxs-lookup"><span data-stu-id="d4277-458">The goal is to catch problems early in the development cycle when they're less expensive to fix.</span></span> <span data-ttu-id="d4277-459">整合之間的持續時間越長，越昂貴的問題就越難解決。</span><span class="sxs-lookup"><span data-stu-id="d4277-459">The longer the duration between integrations, the more expensive problems become to resolve.</span></span>  <span data-ttu-id="d4277-460">由於整合程式的一致性，小組可以更頻繁地認可程式碼變更，進而提升共同作業和軟體品質。</span><span class="sxs-lookup"><span data-stu-id="d4277-460">With consistency in the integration process, teams can commit code changes more frequently, leading to better collaboration and software quality.</span></span>

### <a name="azure-pipelines"></a><span data-ttu-id="d4277-461">Azure Pipelines</span><span class="sxs-lookup"><span data-stu-id="d4277-461">Azure Pipelines</span></span>

<span data-ttu-id="d4277-462">Azure 雲端包含有權 [Azure Pipelines](https://azure.microsoft.com/services/devops/pipelines/)的新 CI/CD 服務，這是 [圖 1-9] 中所示 [Azure DevOps](https://azure.microsoft.com/services/devops/) 供應專案的一部分。</span><span class="sxs-lookup"><span data-stu-id="d4277-462">The Azure cloud includes a new CI/CD service entitled [Azure Pipelines](https://azure.microsoft.com/services/devops/pipelines/), which is part of the [Azure DevOps](https://azure.microsoft.com/services/devops/) offering shown in Figure 1-9.</span></span>

![DevOps 中的 Azure Pipelines](./media/devops-components.png)

<span data-ttu-id="d4277-464">**圖 1-9**。</span><span class="sxs-lookup"><span data-stu-id="d4277-464">**Figure 1-9**.</span></span> <span data-ttu-id="d4277-465">Azure DevOps 供應專案</span><span class="sxs-lookup"><span data-stu-id="d4277-465">Azure DevOps offerings</span></span>

<span data-ttu-id="d4277-466">Azure Pipelines 是一項雲端服務，其結合了持續整合 (CI) 與持續傳遞 (CD) 。</span><span class="sxs-lookup"><span data-stu-id="d4277-466">Azure Pipelines is a cloud service that combines continuous integration (CI) and continuous delivery (CD).</span></span> <span data-ttu-id="d4277-467">您可以自動測試、建立程式碼，並將其傳送至任何目標。</span><span class="sxs-lookup"><span data-stu-id="d4277-467">You can automatically test, build, and ship your code to any target.</span></span>

<span data-ttu-id="d4277-468">您可以在 YAML 檔案中的程式碼中定義管線，以及應用程式的其餘程式碼。</span><span class="sxs-lookup"><span data-stu-id="d4277-468">You define your pipeline in code in a YAML file alongside the rest of the code for your app.</span></span>

- <span data-ttu-id="d4277-469">管線會以您的程式碼建立版本，並遵循相同的分支結構。</span><span class="sxs-lookup"><span data-stu-id="d4277-469">The pipeline is versioned with your code and follows the same branching structure.</span></span>
- <span data-ttu-id="d4277-470">您可以透過提取要求和分支建置原則中的程式碼檢閱來驗證變更。</span><span class="sxs-lookup"><span data-stu-id="d4277-470">You get validation of your changes through code reviews in pull requests and branch build policies.</span></span>
- <span data-ttu-id="d4277-471">您使用的每個分支都可以藉由修改 >azure-pipelines.yml yml 檔案來自訂群組建原則。</span><span class="sxs-lookup"><span data-stu-id="d4277-471">Every branch you use can customize the build policy by modifying the azure-pipelines.yml file.</span></span>
- <span data-ttu-id="d4277-472">管線檔案會簽入版本控制中，並可在發生問題時進行調查。</span><span class="sxs-lookup"><span data-stu-id="d4277-472">The pipeline file is checked into version control and can be investigated if there's a problem.</span></span>

<span data-ttu-id="d4277-473">Azure Pipelines 服務支援大部分的 Git 提供者，而且可以為 Linux、macOS 或 Windows 平臺上所撰寫的應用程式產生部署管線。</span><span class="sxs-lookup"><span data-stu-id="d4277-473">The Azure Pipelines service supports most Git providers and can generate deployment pipelines for applications written on the Linux, macOS, or Windows platforms.</span></span> <span data-ttu-id="d4277-474">它包含 JAVA、.NET、JavaScript、Python、PHP、Go、XCode 和 c + + 的支援。</span><span class="sxs-lookup"><span data-stu-id="d4277-474">It includes support for Java, .NET, JavaScript, Python, PHP, Go, XCode, and C++.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="d4277-475">[上一個](introduction.md) 
>[下一步](candidate-apps.md)</span><span class="sxs-lookup"><span data-stu-id="d4277-475">[Previous](introduction.md)
[Next](candidate-apps.md)</span></span>
