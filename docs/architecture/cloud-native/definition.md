---
title: 雲端原生的定義
description: 瞭解為雲端原生系統提供探源的基本要素
author: robvet
ms.date: 05/13/2020
ms.openlocfilehash: 1f0d842a2369ae04ffc1c634f9de60398a88e86f
ms.sourcegitcommit: 4d45bda8cd9558ea8af4be591e3d5a29360c1ece
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 10/02/2020
ms.locfileid: "91654688"
---
# <a name="defining-cloud-native"></a>定義雲端原生

停止您正在執行的工作，以及您同事的文字10。 要求他們定義「雲端原生」一詞。 您很有可能得到十個不同的答案。

雲端原生的重點，是要改變您對於建立重要商務系統的方式。

雲端原生系統的設計是為了採用快速變更、大規模和彈性。

雲端原生運算基礎提供 [正式的定義](https://github.com/cncf/foundation/blob/master/charter.md)：

> *雲端原生技術可讓組織在新式動態環境（例如公用、私人和混合式雲端）中建立並執行可調整的應用程式。容器、服務網格、微服務、不可變的基礎結構和宣告式 Api 都會說明點這種方法。*

> *這些技術可讓您以鬆散耦合的系統提供復原性、可管理且可觀察的系統。它們結合了強大的自動化功能，可讓工程師以最少的辛勞，以頻繁且可預測的方式進行高度影響的變更。*

應用程式越來越複雜，使用者需要更多更多。 使用者預期快速回應性、創新功能和零停機時間。 無法再接受效能問題、週期性錯誤和無法快速移動。 他們將可輕鬆地移至您的競爭對手。

雲端原生的 *速度* 和 *靈活性*。 商務系統不斷演進，使商務功能成為策略性轉型的武器，以加速業務速度和成長。 請務必立即將構想推向市場。

以下是一些已實行這些技術的公司。 思考它們所達成的速度、靈活性和擴充性。

| 公司 | 體驗 |
| :-------- | :-------- |
| [Netflix](https://www.infoq.com/news/2013/06/netflix/) | 在生產環境中有600項以上的服務。 每天部署數百次。 |
| [Uber](https://eng.uber.com/micro-deploy/) | 在生產環境中有1000項以上的服務。 每週部署數千次。 |
| [微信](https://www.cs.columbia.edu/~ruigu/papers/socc18-final100.pdf) | 生產環境中有3000項以上的服務。 一天部署1000次。 |

如您所見，Netflix、Uber 和 WeChat 會公開由數百個獨立微服務組成的系統。 此架構樣式可讓它們快速回應市場狀況。 他們可以立即更新即時複雜應用程式的小型區域，並視需要個別調整這些區域。

雲端原生的速度和靈活性來自許多因素。 最重要的是雲端基礎結構。 圖1-3 中所示的五個額外基本要素也提供雲端原生系統的探源。

![雲端原生基本要素](./media/cloud-native-foundational-pillars.png)

**圖 1-3**。 雲端原生基本要素

讓我們花點時間進一步瞭解每個要件的重要性。

## <a name="the-cloud"></a>雲端 .。。

雲端原生系統充分利用雲端服務模型。

這些系統設計成在動態、虛擬化的雲端環境中，廣泛使用 [平臺即服務， (PaaS) ](https://azure.microsoft.com/overview/what-is-paas/) 計算基礎結構和受控服務。 它們會在幾分鐘內將基礎結構視為可 *處置* 的布建，並透過自動化來調整大小、調整、移動或損毀。

請考慮採用廣泛接受的 DevOps 概念 [與牛群](https://medium.com/@Joachim8675309/devops-concepts-pets-vs-cattle-2380b5aab313)。 在傳統的資料中心內，會將伺服器視為 *寵物*：實體機器、指定有意義的名稱，以及關懷。 您可以藉由將更多資源新增到同一部電腦， (相應增加) 來進行調整。 如果伺服器變成病假，您會將它傳回健康狀態。 如果伺服器無法使用，每個人都會注意到。

*牛群*服務模型不同。 您可以將每個實例布建為虛擬機器或容器。 它們是相同的，而且會指派系統識別碼，例如服務-01、Service-02 等等。 您可以藉由 (相應放大) 來調整規模。 當某個人無法使用時，沒有人會注意到。

牛群模型採用 *不可變的基礎結構*。 伺服器不會修復或修改。 如果其中一個失敗或需要更新，則會將它終結並布建新的（透過自動化完成）。

雲端原生系統採用牛群服務模型。 當基礎結構相應縮小或相應放大時，它們會繼續執行，而不考慮其執行所在的機器。

Azure 雲端平臺支援這類高度彈性的基礎結構，具有自動調整、自我修復和監視功能。

## <a name="modern-design"></a>新式設計

如何設計雲端原生應用程式？ 您的架構看起來像什麼？ 您會遵守哪些原則、模式和最佳做法？ 有哪些基礎結構和操作考慮會很重要？

### <a name="the-twelve-factor-application"></a>十二要素應用程式

建立雲端架構應用程式的廣泛接受方法是 [十二個因素的應用程式](https://12factor.net/)。 其中說明一組準則和作法，開發人員會遵循這些原則和實務來建立針對新式雲端環境優化的應用程式。 特別注意是跨環境和宣告式自動化提供可攜性。

雖然適用于任何 web 應用程式，但許多開發人員會將十二個因素視為建立雲端原生應用程式的穩固基礎。 根據這些準則建立的系統可以快速部署及調整規模，並新增功能，以快速回應市場變更。

下表強調十二因數方法：

|    |  因素 | 說明  |
| :-------- | :-------- | :-------- |
| 1 | 程式碼基底 | 每個微服務的單一程式碼基底，儲存在它自己的儲存機制中。 使用版本控制進行追蹤，它可以部署到多個環境 (QA、預備、生產) 。 |
| 2 | 相依性 | 每個微服務會隔離並封裝本身的相依性，並在不影響整個系統的情況下進行變更。 |
| 3 | 組態  | 設定資訊會透過程式碼外的設定管理工具移出微服務和外部化。 相同的部署可以跨環境傳播，並套用正確的設定。  |
| 4 | 支援服務 |  (資料存放區、快取、訊息代理程式) 的輔助資源，應該透過可定址的 URL 來公開。 這樣做會將資源與應用程式分離，讓它能夠互換。  |
| 5 | 組建、發行、執行 | 每個版本都必須在組建、發行和執行階段之間強制執行嚴格的分隔。 每個都應該使用唯一識別碼來標記，並支援復原的能力。 新式 CI/CD 系統可協助滿足此原則。 |
| 6 | 處理序 | 每個微服務都應該在其本身的進程中執行，並與其他正在執行的服務隔離。 具體化支援服務的必要狀態，例如分散式快取或資料存放區。 |
| 7 | 連接埠繫結 | 每個微服務都應該獨立于其本身的埠上公開的介面和功能。 這樣做會提供與其他微服務的隔離。 |
| 8 | 並行 | 服務會在大量的小型相同程式之間相應放大 (複製) ，而不是在最強大的電腦上相應增加單一大型實例。 |
| 9 | Disposability | 服務實例應該是可處置的 favoring 快速新創公司，以增加擴充性機會和正常關機，讓系統保持在正確的狀態。 Docker 容器和協調器本身就能滿足這項需求。 |
| 10 | 開發/生產同位 | 盡可能將環境維持在應用程式生命週期的盡可能處，以避免昂貴的快捷方式。 在這裡，您可以藉由升級相同的執行環境，大幅貢獻容器的採用。 |
| 11 | 記錄 | 將微服務所產生的記錄視為事件資料流程。 使用事件匯總工具進行處理，並將資料傳播至資料採礦/記錄管理工具，例如 Azure 監視器或 Splunk，最後長期保存。 |
| 12 | 管理進程 | 以一次性進程的形式執行管理/管理工作。 工作可包含資料清除和提取報表的分析。 執行這些工作的工具應該從生產環境中叫用，但會與應用程式分開。 |

在這本書中， [除了12個要素的應用程式外](https://content.pivotal.io/blog/beyond-the-twelve-factor-app)，撰寫了一份 Hoffman 詳細說明 (以 2011) 撰寫的原始12個因素。 此外，他還討論三個其他因素，以反映現今的新式雲端應用程式設計。

|    |  新因素 | 說明  |
| :-------- | :-------- | :-------- |
| 13 | API 優先 | 將所有專案設為服務。 假設您的程式碼將由前端用戶端、閘道或其他服務使用。 |
| 14 | 遙測 | 在工作站上，您可以深入瞭解您的應用程式及其行為。 在雲端中，您不需要這麼做。 確定您的設計包含監視、網域特定和健全/系統資料的集合。 |
| 15 | 驗證/授權  | 從一開始就執行身分識別。 請考慮 [RBAC (角色型存取控制) ](/azure/role-based-access-control/overview) 公用雲端中可用的功能。  |

我們將在本章節和整個書籍中參考許多12個以上的因素。

### <a name="critical-design-considerations"></a>重大設計考慮

除了12因數方法所提供的指引之外，您還必須在設計分散式系統時進行幾項重要的設計決策。

*通訊*

前端用戶端應用程式會如何與已備份的終端核心服務進行通訊？ 您是否允許直接通訊？ 或者，您是否可以使用提供彈性、控制和安全性的閘道外觀，將後端服務抽象化？

後端核心服務會如何彼此通訊？ 您是否允許直接 HTTP 呼叫，使其結合並影響效能和靈活性？ 或者，您可以考慮使用佇列和主題技術來分離訊息嗎？

詳細說明第4章： *雲端原生通訊模式*的通訊。

*復原*

微服務架構會將您的系統從同進程移至跨進程的網路通訊。 在分散式架構中，當服務 B 沒有回應服務 A 的網路呼叫時，會發生什麼事？ 或者，當服務 C 暫時無法使用時，以及其他呼叫它的服務會遭到封鎖時，會發生什麼事？

復原的詳細資訊請見第6章： *雲端原生復原*。

*分散式資料*

根據設計，每個微服務都會封裝自己的資料，透過其公用介面公開作業。 如果是，您要如何查詢資料或跨多個服務執行交易？

分散式資料詳細說明第5章： *雲端原生資料模式*。

*身分識別*

您的服務會如何識別正在存取的使用者，以及他們擁有的許可權為何？

身分識別會詳細說明第8章，也就是身分 *識別*。

## <a name="microservices"></a>微服務

雲端原生系統採用了微服務，這是用來建立新式應用程式的熱門架構樣式。

以一組分散式小型獨立服務的形式建立，可透過共用網狀架構進行互動，微服務共用下列特性：

- 每個都會在較大的網域內容中執行特定的商務功能。

- 每個都是自主開發，而且可以獨立部署。

- 每個都是自我自主封裝的資料儲存技術， (SQL、NoSQL) 和程式設計平臺。

- 每個都在自己的進程中執行，並使用標準通訊協定（例如 HTTP/HTTPS、Websocket 或 [AMQP](https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol)）與其他人通訊。

- 它們組合在一起，以構成應用程式。

圖1-4 以微服務方法來對比整合型應用程式方法。 請注意，單體是由在單一進程中執行的多層式架構所組成。 它通常會使用關係資料庫。 但是，微服務方法會將功能隔離到包含邏輯和資料的獨立服務中。 每個微服務都會裝載自己的資料存放區。

![整合型部署與微服務](./media/monolithic-vs-microservices.png)

**圖1-4。** 整合型部署與微服務

請注意，微服務如何從 [12 個因素的應用程式](https://12factor.net/)升級「一個程式碼基底，一個應用程式」的原則，如稍早的章節中所述。

> *因數 \# 1 指定每個微服務的單一程式碼基底，儲存在其自己的儲存機制中。使用版本控制進行追蹤，可以部署到多個環境。」*

### <a name="why-microservices"></a>使用微服務的理由？

微服務提供靈活性。

稍早在本章中，我們比較了以單體建立的電子商務應用程式與微服務。 在此範例中，我們看到一些清楚的優點：

- 每個微服務都有一個自發的生命週期，並且可以獨立且經常地進行部署。 您不必等候每季發行來部署新功能或更新。 您可以更新複雜應用程式的小型區域，但降低整個系統中斷的風險。

- 每個微服務都可以獨立調整。 您不需將整個應用程式以單一單位的形式調整，而是只向外擴充需要更多處理能力或網路頻寬的服務。 這種精細的調整方法可讓您更有效地控制系統，並在您調整系統的部分（而非所有）時，協助降低整體成本。

[.Net 微服務：容器化 .Net 應用程式的架構](https://dotnet.microsoft.com/download/thank-you/microservices-architecture-ebook)是瞭解微服務的絕佳參考指南。 這本書深入探討微服務的設計和架構。 它隨附于可從 Microsoft 免費下載的 [完整堆疊微服務參考架構](https://github.com/dotnet-architecture/eShopOnContainers) 。

### <a name="developing-microservices"></a>開發微服務

您可以使用任何新式開發平臺來建立微服務。

Microsoft .NET Core 平臺是絕佳的選擇。 免費且開放的原始碼，它有許多內建功能可簡化微服務的開發。 .NET Core 是跨平臺。 您可以在 Windows、macOS 和大部分的 Linux 類別上建立並執行應用程式。

.NET Core 的效能非常高，且相較于 Node.js 和其他競爭平臺，也有相當程度的評分。 有趣的是， [TechEmpower](https://www.techempower.com/) 在許多 web 應用程式平臺和架構之間進行了一組廣泛的 [效能基準](https://www.techempower.com/benchmarks/#section=data-r17&hw=ph&test=plaintext) 檢驗。 .NET Core 在上方 10-以上的 Node.js 和其他競爭平臺上進行評分。

.NET Core 是由 Microsoft 和 GitHub 上的 .NET 社區所維護。

## <a name="containers"></a>容器

現今，您可以很自然地聆聽任何與*雲端原生*相關的交談中所述的「*容器*」一詞。 在《 [雲端原生模式](https://www.manning.com/books/cloud-native-patterns)，作者 Cornelia Davis 》中，會觀察「容器是雲端原生軟體的絕佳促成者」。 雲端原生運算基礎將微服務容器化作為其 [雲端原生線索對應](https://raw.githubusercontent.com/cncf/trailmap/master/CNCF_TrailMap_latest.png) 的第一個步驟，也就是開始其雲端原生旅程的企業的指導方針。

容器化微服務很簡單明瞭。 程式碼、其相依性和執行時間會封裝到稱為 [容器映射](https://docs.docker.com/glossary/?term=image)的二進位檔中。 映射會儲存在 [容器](https://caylent.com/container-registries/)登錄中，作為映射的儲存機制或程式庫。 登錄可以位於您的開發電腦、資料中心或公用雲端中。 Docker 本身會透過 [Docker Hub](https://hub.docker.com/)維護公用登錄。 Azure 雲端提供 [容器](https://azure.microsoft.com/services/container-registry/) 登錄來儲存容器映射，以接近將執行這些映射的雲端應用程式。

如有需要，您可以將映射轉換成執行中的容器實例。 此實例會在已安裝 [容器運行](https://kubernetes.io/docs/setup/production-environment/container-runtimes/) 時間引擎的任何電腦上執行。 您可以視需要擁有多個容器化服務的實例。

圖1-5 顯示三個不同的微服務，每個都在自己的容器中執行于單一主機上。

![在容器主機上執行的多個容器](./media/hosting-mulitple-containers.png)

**圖 1-5**。 在容器主機上執行的多個容器

請注意，每個容器如何維護自己的相依性和執行時間集合，這兩者可能不同。 在這裡，我們會看到不同版本的產品微服務在相同的主機上執行。 每個容器都會共用基礎主機作業系統、記憶體和處理器的配量，但彼此隔離。

請注意容器模型如何充分利用 [12 因數應用程式](https://12factor.net/)的「相依性」原則。

> *\#第2因數指定「每個微服務隔離並封裝本身的相依性，並在不影響整個系統的情況下進行變更」。*

容器同時支援 Linux 和 Windows 工作負載。 Azure 雲端的涵蓋兩者都有。 有趣的是，它是 Linux 而非 Windows Server，已成為 Azure 中最受歡迎的作業系統。

雖然有數個容器廠商存在，但 Docker 已獲得 lion 的市場分享。 公司已推動軟體容器的移動。 它已成為封裝、部署和執行雲端原生應用程式的事實上標準。

### <a name="why-containers"></a>為何選擇容器？

容器提供可攜性，並保證環境之間的一致性。 將所有專案封裝成單一套件，即可將微服務及其相依性與基礎結構 *隔離* 。

您可以在具有 Docker 執行時間引擎的任何環境中部署相同的容器。 容器化工作負載也可消除使用架構、軟體程式庫和執行時間引擎預先設定每個環境的費用。

藉由共用基礎作業系統和主機資源，容器的使用量會比完整虛擬機器小得多。 較小的大小會增加指定主機一次可以執行的 *密度*或微服務數目。

### <a name="container-orchestration"></a>容器協調流程

當 Docker 之類的工具建立映射並執行容器時，您也需要工具來管理它們。 使用稱為容器協調器的特殊軟體程式來管理容器。 大規模操作時，容器協調流程是不可或缺的。

圖1-6 顯示容器協調器提供的管理工作。

![容器協調器的用途](./media/what-container-orchestrators-do.png)

**圖 1-6**。 容器協調器的用途

下表描述一般協調流程工作。

|  工作 | 說明  |
| :-------- | :-------- |
| 排程 | 自動布建容器實例。|
| 親和性/反親和性 | 布建鄰近或相距離彼此的容器，以協助提供可用性和效能。 |
| 健康狀況監視 | 自動偵測並修正失敗。|
| 容錯移轉 | 自動將失敗的實例重新布建至狀況良好的機器。|
| 調整大小 | 自動新增或移除容器實例以符合需求。|
| 網路功能 | 管理容器通訊的網路重迭。|
| 服務探索 | 讓容器彼此找出。|
| 輪流升級 | 協調增量升級與零停機部署。 自動回復有問題的變更。|

請注意，協調器如何從 [12 因數應用程式](https://12factor.net/)中採用 disposability 和並行原則，如稍早的章節中所述。

> *第 \# 9 因數指定「服務實例應該是可處置的，favoring 快速的新創公司，以增加擴充性機會和正常關機，讓系統保持在正確的狀態。Docker 容器和協調器本身就能滿足這項需求。」*

> *\#第8因數指定「服務會在大量的小型相同程式之間相應放大 (複製) ，而不是在功能最強大的電腦上向上擴充單一大型實例。」*

由於有數個容器協調器存在， [Kubernetes](https://kubernetes.io/docs/concepts/overview/what-is-kubernetes/) 已成為雲端原生世界的實際標準。 它是可供管理容器化工作負載的可移植、可擴充、開放原始碼平臺。

您可以裝載自己的 Kubernetes 實例，但您會負責布建和管理其資源，這可能很複雜。 Azure 雲端功能 Kubernetes 為受控服務， [Azure Kubernetes Service (AKS) ](https://azure.microsoft.com/services/kubernetes-service/)。 受管理的服務可讓您充分利用其功能，而不需要安裝和維護它。

Azure Kubernetes Services 詳細說明第2章： *調整雲端原生應用程式*。

## <a name="backing-services"></a>支援服務

雲端原生系統取決於許多不同的輔助資源，例如資料存放區、訊息代理程式、監視和身分識別服務。 這些服務稱為「 [支援服務](https://12factor.net/backing-services)」。

 圖1-7 顯示雲端原生系統所耗用的許多常見支援服務。

![常見的支援服務](./media/common-backing-services.png)

**圖 1-7**。 常見的支援服務

備份服務會從 [十二個因素的應用程式](https://12factor.net/)升級 "無狀態" 原則，如稍早的章節中所述。

>* \# 第6因數* 指定：「每個微服務應該在自己的進程中執行，並與其他執行中的服務隔離。 具體化支援服務的必要狀態，例如分散式快取或資料存放區。」

您可以裝載您自己的支援服務，但是您必須負責授權、布建和管理這些資源。

雲端提供者提供各式各樣的 *受控支援服務。* 您只需使用服務，而不是擁有服務。 此提供者會大規模地操作資源，並承擔效能、安全性和維護的責任。 服務內建監視、冗余和可用性。 提供者完全支援其受控服務-開啟票證，並修正您的問題。

雲端原生系統優先于雲端廠商提供受管理的支援服務。 節省時間與人力很棒。 裝載您自己和遇到問題的作業風險，可能很快就會耗費資源。

最佳做法是將支援服務視為 *附加的資源*，動態地系結至微服務，其中 (URL 和認證) 儲存在外部設定中。 本指南將在第一章稍早所討論的 [12 要素應用程式](https://12factor.net/)中拼錯。

>*因數 \# 4* 指定應透過可定址的 URL 公開支援服務」。 這樣做會將資源與應用程式分離，讓它能夠互換。」

>* \# 第3因數* 指定「透過程式碼以外的設定管理工具，將設定資訊移出微服務和外部化。」

使用這個模式時，可以在不變更程式碼的情況下附加和卸離支援服務。 您可以將微服務從 QA 升階到預備環境。 您可以將微服務設定更新為指向預備環境中的支援服務，並透過環境變數將設定插入容器中。

雲端廠商會提供 Api，讓您與其專屬的支援服務進行通訊。 這些程式庫會封裝管線和複雜度。 直接與這些 Api 通訊會將您的程式碼緊密結合到支援服務。 更好的作法是避免廠商 API 的執行詳細資料。 引進 intermediation 層或中繼 API，將一般作業公開給您的服務程式代碼。 這項鬆散的結合可讓您交換另一個支援服務，或將程式碼移至不同的公用雲端，而不需要變更主線服務程式代碼。

支援服務將在第5章、 *雲端原生資料模式*和第4章（ *雲端原生通訊模式*）中詳細討論。

## <a name="automation"></a>自動化

如您所見，雲端原生系統採用微服務、容器和新式系統設計，以達成速度和靈活性。 但是，這只是故事的一部分。 如何布建這些系統執行所在的雲端環境？ 如何快速部署應用程式功能和更新？ 您要如何將完整圖片弄整？

輸入廣泛接受的 [基礎結構即程式碼](/azure/devops/learn/what-is-infrastructure-as-code)或 IaC 作法。

透過 IaC，您可以將平臺布建和應用程式部署自動化。 您基本上會將軟體工程實務（例如測試和版本控制）套用至您的 DevOps 實務。 您的基礎結構和部署是自動化、一致且可重複的。

### <a name="automating-infrastructure"></a>自動化基礎結構

[Azure Resource Manager](/azure/azure-resource-manager/management/overview)、Terraform 和[Azure CLI](/cli/azure/)之類的工具，可讓您以宣告方式編寫需要的雲端基礎結構腳本。 資源名稱、位置、容量和密碼都是參數化和動態的。 腳本已建立版本，並簽入原始檔控制中做為專案的成品。 您可以叫用腳本來跨系統內容布建一致且可重複的基礎結構，例如 QA、預備環境和生產環境。

在幕後，IaC 具有等冪性，這表示您可以執行相同的腳本，而不需要副作用。 如果小組需要進行變更，他們會編輯並重新執行腳本。 只有更新的資源會受到影響。

在這篇文章中， [什麼是基礎結構即程式碼](/azure/devops/learn/what-is-infrastructure-as-code)，作者 Sam 作者: guckenheimer 描述了「如何」，這是「實行 IaC 的團隊可以快速且大規模地提供穩定的環境。 小組避免手動設定環境，並透過程式碼代表其環境的預期狀態，來強制執行一致性。 使用 IaC 的基礎結構部署是可重複的，可防止設定漂移或遺失相依性所造成的執行時間問題。 DevOps 團隊可以搭配一組整合的實務和工具，快速、可靠且大規模地傳遞應用程式及其支援的基礎結構。」

### <a name="automating-deployments"></a>自動化部署

稍早所述的 [12 因數應用程式](https://12factor.net/)，會在將完成的程式碼轉換成執行中的應用程式時，呼叫個別的步驟。

> * \# 第5因數* 指定「每個版本都必須在組建、發行和執行階段之間強制執行嚴格的分隔。 每個都應該以唯一的識別碼標記，並支援復原的能力。」

新式 CI/CD 系統可協助滿足此原則。 它們提供個別的部署步驟，並協助確保使用者可立即使用的一致且品質的程式碼。

圖1-8 顯示整個部署程式的分隔。

![CI/CD 管線中的部署步驟](./media/build-release-run-pipeline.png)

**圖 1-8**。 CI/CD 管線中的部署步驟

在上圖中，請特別注意工作的分隔。

開發人員在其開發環境中建立一項功能，並逐一查看所謂程式碼的「內部迴圈」、執行和偵錯工具。 完成時，該程式碼會 *推送* 至程式碼存放庫，例如 GitHub、Azure DevOps 或 BitBucket。

推送會觸發將程式碼轉換為二進位成品的組建階段。 這項工作是以 [持續整合 (CI) ](https://martinfowler.com/articles/continuousIntegration.html) 管線來執行。 它會自動建立、測試及封裝應用程式。

發行階段會挑選二進位成品、套用外部應用程式和環境設定資訊，並產生不可變的版本。 發行會部署到指定的環境。 這項工作是利用 [持續傳遞 (CD) ](https://martinfowler.com/bliki/ContinuousDelivery.html) 管線來執行。 每個版本都應該是可辨識的。 您可以說：「這個部署正在執行應用程式的版本2.1.1」。

最後，已發行的功能會在目標執行環境中執行。 版本是不可變的，這表示任何變更都必須建立新的版本。

運用這些實務，組織也徹底演進了它們出貨軟體的方式。 許多已從每季版本移至隨選更新。 其目標是要及早在開發週期中捕捉問題，以修正成本較低的問題。 整合之間的持續時間越長，越昂貴的問題就越難解決。  由於整合程式的一致性，小組可以更頻繁地認可程式碼變更，進而提升共同作業和軟體品質。

### <a name="azure-pipelines"></a>Azure Pipelines

Azure 雲端包含有權 [Azure Pipelines](https://azure.microsoft.com/services/devops/pipelines/)的新 CI/CD 服務，這是 [圖 1-9] 中所示 [Azure DevOps](https://azure.microsoft.com/services/devops/) 供應專案的一部分。

![DevOps 中的 Azure Pipelines](./media/devops-components.png)

**圖 1-9**。 Azure DevOps 供應專案

Azure Pipelines 是一項雲端服務，其結合了持續整合 (CI) 與持續傳遞 (CD) 。 您可以自動測試、建立程式碼，並將其傳送至任何目標。

您可以在 YAML 檔案中的程式碼中定義管線，以及應用程式的其餘程式碼。

- 管線會以您的程式碼建立版本，並遵循相同的分支結構。
- 您可以透過提取要求和分支建置原則中的程式碼檢閱來驗證變更。
- 您使用的每個分支都可以藉由修改 >azure-pipelines.yml yml 檔案來自訂群組建原則。
- 管線檔案會簽入版本控制中，並可在發生問題時進行調查。

Azure Pipelines 服務支援大部分的 Git 提供者，而且可以為 Linux、macOS 或 Windows 平臺上所撰寫的應用程式產生部署管線。 它包含 JAVA、.NET、JavaScript、Python、PHP、Go、XCode 和 c + + 的支援。

>[!div class="step-by-step"]
>[上一個](introduction.md) 
>[下一步](candidate-apps.md)
