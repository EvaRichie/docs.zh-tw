---
title: 一般 Web 應用程式架構
description: 使用 ASP.NET Core 和 Azure 架構現代化 Web 應用程式 | 探索一般 Web 應用程式架構
author: ardalis
ms.author: wiwagn
ms.date: 12/04/2019
ms.openlocfilehash: dd9cdf3cdda0605d9454fe096be01655e67a0d0a
ms.sourcegitcommit: 5b475c1855b32cf78d2d1bbb4295e4c236f39464
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 09/24/2020
ms.locfileid: "91169293"
---
# <a name="common-web-application-architectures"></a><span data-ttu-id="b2ccc-103">一般 Web 應用程式架構</span><span class="sxs-lookup"><span data-stu-id="b2ccc-103">Common web application architectures</span></span>

> <span data-ttu-id="b2ccc-104">「如果您認為好的架構很昂貴，那就試試壞的架構吧。」</span><span class="sxs-lookup"><span data-stu-id="b2ccc-104">"If you think good architecture is expensive, try bad architecture."</span></span>  
> <span data-ttu-id="b2ccc-105">_- Brian Foote 和 Joseph Yoder_</span><span class="sxs-lookup"><span data-stu-id="b2ccc-105">_- Brian Foote and Joseph Yoder_</span></span>

<span data-ttu-id="b2ccc-106">大部分傳統的 .NET 應用程式會部署為單一單位，對應至在單一 IIS appdomain 內執行的可執行檔或單一 Web 應用程式。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-106">Most traditional .NET applications are deployed as single units corresponding to an executable or a single web application running within a single IIS appdomain.</span></span> <span data-ttu-id="b2ccc-107">這是最簡單的部署模型，而且很妥善地服務許多與小型的內部公用應用程式。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-107">This is the simplest deployment model and serves many internal and smaller public applications very well.</span></span> <span data-ttu-id="b2ccc-108">不過，即使指定這種單一部署單位，大部分重要的商務應用程式都能受益於將邏輯稍微分割到數個層級。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-108">However, even given this single unit of deployment, most non-trivial business applications benefit from some logical separation into several layers.</span></span>

## <a name="what-is-a-monolithic-application"></a><span data-ttu-id="b2ccc-109">什麼是整合型應用程式？</span><span class="sxs-lookup"><span data-stu-id="b2ccc-109">What is a monolithic application?</span></span>

<span data-ttu-id="b2ccc-110">整合型應用程式是在行為方面完全獨立的應用程式。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-110">A monolithic application is one that is entirely self-contained, in terms of its behavior.</span></span> <span data-ttu-id="b2ccc-111">它可能會在執行作業的過程中，與其他服務或資料存放區互動，但它的行為核心會在自己的處理序內執行，且整個應用程式通常會部署為單一單位。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-111">It may interact with other services or data stores in the course of performing its operations, but the core of its behavior runs within its own process and the entire application is typically deployed as a single unit.</span></span> <span data-ttu-id="b2ccc-112">如果這樣的應用程式需要水平縮放，通常會在多個伺服器或虛擬機器之間複製整個應用程式。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-112">If such an application needs to scale horizontally, typically the entire application is duplicated across multiple servers or virtual machines.</span></span>

## <a name="all-in-one-applications"></a><span data-ttu-id="b2ccc-113">全方位應用程式</span><span class="sxs-lookup"><span data-stu-id="b2ccc-113">All-in-one applications</span></span>

<span data-ttu-id="b2ccc-114">應用程式架構專案的最小可能數目是一個。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-114">The smallest possible number of projects for an application architecture is one.</span></span> <span data-ttu-id="b2ccc-115">在這種架構中，應用程式的整個邏輯都包含在單一專案內、編譯成單一組件，並部署為單一單位。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-115">In this architecture, the entire logic of the application is contained in a single project, compiled to a single assembly, and deployed as a single unit.</span></span>

<span data-ttu-id="b2ccc-116">新的 ASP.NET Core 專案，不論是在 Visual Studio 或從命令列建立，一開始都是簡單的「全方位」整合型。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-116">A new ASP.NET Core project, whether created in Visual Studio or from the command line, starts out as a simple "all-in-one" monolith.</span></span> <span data-ttu-id="b2ccc-117">它包含應用程式的所有行為，包括簡報、商務和資料存取邏輯。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-117">It contains all of the behavior of the application, including presentation, business, and data access logic.</span></span> <span data-ttu-id="b2ccc-118">圖 5-1 顯示單一專案應用程式的檔案結構。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-118">Figure 5-1 shows the file structure of a single-project app.</span></span>

![單一專案 ASP.NET Core 應用程式](./media/image5-1.png)

<span data-ttu-id="b2ccc-120">**圖5-1。**</span><span class="sxs-lookup"><span data-stu-id="b2ccc-120">**Figure 5-1.**</span></span> <span data-ttu-id="b2ccc-121">單一專案 ASP.NET Core 應用程式。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-121">A single project ASP.NET Core app.</span></span>

<span data-ttu-id="b2ccc-122">在單一專案案例中，關注點分離是透過資料夾的使用而達成。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-122">In a single project scenario, separation of concerns is achieved through the use of folders.</span></span> <span data-ttu-id="b2ccc-123">預設範本包含 Models、Views 和 Controllers 等 MVC 模式責任的個別資料夾，以及適用於資料和服務的其他資料夾。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-123">The default template includes separate folders for MVC pattern responsibilities of Models, Views, and Controllers, as well as additional folders for Data and Services.</span></span> <span data-ttu-id="b2ccc-124">在這種安排中，應該盡量將簡報詳細資料限制在 Views 資料夾，且資料存取實作詳細資料應該限制為保留在 Data 資料夾中的類別。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-124">In this arrangement, presentation details should be limited as much as possible to the Views folder, and data access implementation details should be limited to classes kept in the Data folder.</span></span> <span data-ttu-id="b2ccc-125">商務邏輯應該位於 Models 資料夾內的服務和類別。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-125">Business logic should reside in services and classes within the Models folder.</span></span>

<span data-ttu-id="b2ccc-126">雖然簡單，但單一專案整合型解決方案有一些缺點。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-126">Although simple, the single-project monolithic solution has some disadvantages.</span></span> <span data-ttu-id="b2ccc-127">隨著專案的大小和複雜度增加，檔案和資料夾的數目也會持續成長。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-127">As the project's size and complexity grows, the number of files and folders will continue to grow as well.</span></span> <span data-ttu-id="b2ccc-128">使用者介面 (UI) 考量 (模型、檢視、控制器) 位於不依字母順序分組在一起的多個資料夾中。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-128">User interface (UI) concerns (models, views, controllers) reside in multiple folders, which aren't grouped together alphabetically.</span></span> <span data-ttu-id="b2ccc-129">當有其他 UI 層級建構，例如 Filter 或 ModelBinder ，新增到它們自己的資料夾中時，此問題只會惡化。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-129">This issue only gets worse when additional UI-level constructs, such as Filters or ModelBinders, are added in their own folders.</span></span> <span data-ttu-id="b2ccc-130">商務邏輯散佈在 Models 和 Services 資料夾之間，且不會清楚指出哪些資料夾中的哪些類別應該相依於哪些其他類別。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-130">Business logic is scattered between the Models and Services folders, and there's no clear indication of which classes in which folders should depend on which others.</span></span> <span data-ttu-id="b2ccc-131">這種在專案層級缺乏組織的情形經常會導致 [Spaghetti Code](https://deviq.com/spaghetti-code/) (非結構程式碼)。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-131">This lack of organization at the project level frequently leads to [spaghetti code](https://deviq.com/spaghetti-code/).</span></span>

<span data-ttu-id="b2ccc-132">為了解決這些問題，應用程式經常演化成多專案解決方案，其中每個專案被視為位於應用程式的特定「層級」__。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-132">To address these issues, applications often evolve into multi-project solutions, where each project is considered to reside in a particular _layer_ of the application.</span></span>

## <a name="what-are-layers"></a><span data-ttu-id="b2ccc-133">什麼是層次？</span><span class="sxs-lookup"><span data-stu-id="b2ccc-133">What are layers?</span></span>

<span data-ttu-id="b2ccc-134">當應用程式變得越來越複雜時，管理這種複雜性的一種方法，是根據應用程式的責任或關注點來分解應用程式。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-134">As applications grow in complexity, one way to manage that complexity is to break up the application according to its responsibilities or concerns.</span></span> <span data-ttu-id="b2ccc-135">這會遵循考慮原則的分隔，並可協助保持不斷成長的程式碼基底，讓開發人員可以輕鬆地找到特定功能的執行位置。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-135">This follows the separation of concerns principle and can help keep a growing codebase organized so that developers can easily find where certain functionality is implemented.</span></span> <span data-ttu-id="b2ccc-136">不過，除了程式碼組織之外，分層的架構還提供許多優勢。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-136">Layered architecture offers a number of advantages beyond just code organization, though.</span></span>

<span data-ttu-id="b2ccc-137">藉由將程式碼組織成層級，就可以在整個應用程式重複使用通用的低階功能。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-137">By organizing code into layers, common low-level functionality can be reused throughout the application.</span></span> <span data-ttu-id="b2ccc-138">這種重複使用是有益的，因為這表示需要撰寫較少的程式碼，且因為它可讓應用程式在單一實作標準化，遵循[一次且僅一次 (DRY)](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself) 準則。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-138">This reuse is beneficial because it means less code needs to be written and because it can allow the application to standardize on a single implementation, following the [don't repeat yourself (DRY)](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself) principle.</span></span>

<span data-ttu-id="b2ccc-139">使用分層式架構，應用程式可以強制限制哪些層級可以與其他層級通訊。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-139">With a layered architecture, applications can enforce restrictions on which layers can communicate with other layers.</span></span> <span data-ttu-id="b2ccc-140">這有助於達成封裝。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-140">This helps to achieve encapsulation.</span></span> <span data-ttu-id="b2ccc-141">變更或取代層級時，只有處理該層級的層級會受到影響。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-141">When a layer is changed or replaced, only those layers that work with it should be impacted.</span></span> <span data-ttu-id="b2ccc-142">藉由限制哪些層級相依於哪些其他層級，變更的影響可以得到緩解，讓單一變更不會影響整個應用程式。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-142">By limiting which layers depend on which other layers, the impact of changes can be mitigated so that a single change doesn't impact the entire application.</span></span>

<span data-ttu-id="b2ccc-143">層級 (和封裝) 使得可以更容易取代應用程式中的功能。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-143">Layers (and encapsulation) make it much easier to replace functionality within the application.</span></span> <span data-ttu-id="b2ccc-144">例如，針對持續性，應用程式一開始可能使用自己的 SQL Server 資料庫，但後來可以選擇使用以雲端為基礎的持續性策略，或 Web API 之後的策略。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-144">For example, an application might initially use its own SQL Server database for persistence, but later could choose to use a cloud-based persistence strategy, or one behind a web API.</span></span> <span data-ttu-id="b2ccc-145">如果應用程式已將其持續性實作正確封裝在邏輯層內，該 SQL Server 特定的層級可以取代為實作相同公用介面的新層級。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-145">If the application has properly encapsulated its persistence implementation within a logical layer, that SQL Server specific layer could be replaced by a new one implementing the same public interface.</span></span>

<span data-ttu-id="b2ccc-146">除了為了回應未來的需求變更而換掉實作的可能性，應用程式層級也能更輕鬆地基於測試目的而換掉實作。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-146">In addition to the potential of swapping out implementations in response to future changes in requirements, application layers can also make it easier to swap out implementations for testing purposes.</span></span> <span data-ttu-id="b2ccc-147">您不必撰寫測試來操作應用程式的實際資料層級或 UI 層級，這些層級可以在測試階段取代為假的實作，以提供已知的回應給要求。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-147">Instead of having to write tests that operate against the real data layer or UI layer of the application, these layers can be replaced at test time with fake implementations that provide known responses to requests.</span></span> <span data-ttu-id="b2ccc-148">這通常可讓測試更容易撰寫且更快速地執行 (相較於針對應用程式的實際基礎結構來執行測試)。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-148">This typically makes tests much easier to write and much faster to run when compared to running tests against the application's real infrastructure.</span></span>

<span data-ttu-id="b2ccc-149">邏輯分層是改善企業軟體應用程式中的程式碼組織的常見技術，並且有數種方式可以將程式碼組織成層級。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-149">Logical layering is a common technique for improving the organization of code in enterprise software applications, and there are several ways in which code can be organized into layers.</span></span>

> [!NOTE]
 > <span data-ttu-id="b2ccc-150">「層級」__ 代表應用程式中的邏輯分隔。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-150">_Layers_ represent logical separation within the application.</span></span> <span data-ttu-id="b2ccc-151">應用程式邏輯實際上分佈至不同伺服器或處理程序時，這些個別的實體部署目標稱為「層」__。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-151">In the event that application logic is physically distributed to separate servers or processes, these separate physical deployment targets are referred to as _tiers_.</span></span> <span data-ttu-id="b2ccc-152">可能 (而且很常見) 會有 N 層應用程式部署到單一層。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-152">It's possible, and quite common, to have an N-Layer application that is deployed to a single tier.</span></span>

## <a name="traditional-n-layer-architecture-applications"></a><span data-ttu-id="b2ccc-153">傳統的「N 層」架構應用程式</span><span class="sxs-lookup"><span data-stu-id="b2ccc-153">Traditional "N-Layer" architecture applications</span></span>

<span data-ttu-id="b2ccc-154">將應用程式邏輯組織成為層級的最常見方式顯示在圖 5-2 中。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-154">The most common organization of application logic into layers is shown in Figure 5-2.</span></span>

![一般應用層](./media/image5-2.png)

<span data-ttu-id="b2ccc-156">**圖5-2。**</span><span class="sxs-lookup"><span data-stu-id="b2ccc-156">**Figure 5-2.**</span></span> <span data-ttu-id="b2ccc-157">一般應用程式層級。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-157">Typical application layers.</span></span>

<span data-ttu-id="b2ccc-158">這些層級經常縮寫為 UI、BLL (商務邏輯層)，以及 DAL (資料存取層)。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-158">These layers are frequently abbreviated as UI, BLL (Business Logic Layer), and DAL (Data Access Layer).</span></span> <span data-ttu-id="b2ccc-159">使用此架構，使用者會透過 UI 層提出要求，這個層級只與 BLL 互動。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-159">Using this architecture, users make requests through the UI layer, which interacts only with the BLL.</span></span> <span data-ttu-id="b2ccc-160">接著，BLL 可以呼叫 DAL 以處理資料存取要求。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-160">The BLL, in turn, can call the DAL for data access requests.</span></span> <span data-ttu-id="b2ccc-161">UI 層應該不會對 DAL 直接提出任何要求，也不應直接透過其他方式與持續性互動。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-161">The UI layer shouldn't make any requests to the DAL directly, nor should it interact with persistence directly through other means.</span></span> <span data-ttu-id="b2ccc-162">同樣地，BLL 應該只能透過 DAL 與持續性互動。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-162">Likewise, the BLL should only interact with persistence by going through the DAL.</span></span> <span data-ttu-id="b2ccc-163">如此一來，每個層級都會有自己的已知責任。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-163">In this way, each layer has its own well-known responsibility.</span></span>

<span data-ttu-id="b2ccc-164">這種傳統分層方法的一項缺點是編譯時間相依性會從頂端一直到底部。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-164">One disadvantage of this traditional layering approach is that compile-time dependencies run from the top to the bottom.</span></span> <span data-ttu-id="b2ccc-165">也就是說，UI 層相依於 BLL，BLL 相依於 DAL。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-165">That is, the UI layer depends on the BLL, which depends on the DAL.</span></span> <span data-ttu-id="b2ccc-166">這表示，通常保存應用程式中最重要邏輯的 BLL，會相依於資料存取實作細節 (且通常相依於資料庫的存在)。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-166">This means that the BLL, which usually holds the most important logic in the application, is dependent on data access implementation details (and often on the existence of a database).</span></span> <span data-ttu-id="b2ccc-167">在這類架構中測試商務邏輯經常會很困難，需要一個測試資料庫。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-167">Testing business logic in such an architecture is often difficult, requiring a test database.</span></span> <span data-ttu-id="b2ccc-168">相依性反轉原則可用來解決這個問題，您將會在下一節看到。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-168">The dependency inversion principle can be used to address this issue, as you'll see in the next section.</span></span>

<span data-ttu-id="b2ccc-169">圖 5-3 顯示範例解決方案，會依責任 (或層級) 將應用程式分成三個專案。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-169">Figure 5-3 shows an example solution, breaking the application into three projects by responsibility (or layer).</span></span>

![具有三個專案的簡單整合型應用程式](./media/image5-3.png)

<span data-ttu-id="b2ccc-171">**圖5-3。**</span><span class="sxs-lookup"><span data-stu-id="b2ccc-171">**Figure 5-3.**</span></span> <span data-ttu-id="b2ccc-172">簡單的整合型應用程式，含三個專案。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-172">A simple monolithic application with three projects.</span></span>

<span data-ttu-id="b2ccc-173">雖然此應用程式為了組織的目的而使用數個專案，但它仍會部署為單一單位，且其用戶端會以單一 Web 應用程式與它互動。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-173">Although this application uses several projects for organizational purposes, it's still deployed as a single unit and its clients will interact with it as a single web app.</span></span> <span data-ttu-id="b2ccc-174">這樣能有非常簡單的部署程序。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-174">This allows for very simple deployment process.</span></span> <span data-ttu-id="b2ccc-175">圖 5-4 將示範這類應用程式可如何使用 Azure 來裝載。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-175">Figure 5-4 shows how such an app might be hosted using Azure.</span></span>

![Azure Web 應用程式的簡單部署](./media/image5-4.png)

<span data-ttu-id="b2ccc-177">**圖5-4。**</span><span class="sxs-lookup"><span data-stu-id="b2ccc-177">**Figure 5-4.**</span></span> <span data-ttu-id="b2ccc-178">Azure Web 應用程式的簡單部署</span><span class="sxs-lookup"><span data-stu-id="b2ccc-178">Simple deployment of Azure Web App</span></span>

<span data-ttu-id="b2ccc-179">當應用程式需求成長，可能需要更複雜且功能強大的部署解決方案。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-179">As application needs grow, more complex and robust deployment solutions may be required.</span></span> <span data-ttu-id="b2ccc-180">圖 5-5 示範更複雜的部署計劃範例，它支援額外的功能。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-180">Figure 5-5 shows an example of a more complex deployment plan that supports additional capabilities.</span></span>

![將 Web 應用程式部署至 Azure App Service](./media/image5-5.png)

<span data-ttu-id="b2ccc-182">**圖5-5。**</span><span class="sxs-lookup"><span data-stu-id="b2ccc-182">**Figure 5-5.**</span></span> <span data-ttu-id="b2ccc-183">將 Web 應用程式部署至 Azure App Service</span><span class="sxs-lookup"><span data-stu-id="b2ccc-183">Deploying a web app to an Azure App Service</span></span>

<span data-ttu-id="b2ccc-184">就內部而言，根據責任將此專案組織成多個專案，可以改善應用程式的可維護性。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-184">Internally, this project's organization into multiple projects based on responsibility improves the maintainability of the application.</span></span>

<span data-ttu-id="b2ccc-185">此單位可以相應增加或相應放大以充分利用雲端隨選延展性。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-185">This unit can be scaled up or out to take advantage of cloud-based on-demand scalability.</span></span> <span data-ttu-id="b2ccc-186">相應增加意思是新增額外的 CPU、記憶體、磁碟空間或其他資源到裝載應用程式的伺服器。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-186">Scaling up means adding additional CPU, memory, disk space, or other resources to the server(s) hosting your app.</span></span> <span data-ttu-id="b2ccc-187">相應放大的意思是額外新增這類伺服器的執行個體，不論它們是實體伺服器、虛擬機器或容器。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-187">Scaling out means adding additional instances of such servers, whether these are physical servers, virtual machines, or containers.</span></span> <span data-ttu-id="b2ccc-188">當您的應用程式裝載於多個執行個體時，負載平衡器會用於將要求指派給個別的應用程式執行個體。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-188">When your app is hosted across multiple instances, a load balancer is used to assign requests to individual app instances.</span></span>

<span data-ttu-id="b2ccc-189">在 Azure 中調整 Web 應用程式最簡單的方式，是在應用程式的 App Service 方案中手動設定調整。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-189">The simplest approach to scaling a web application in Azure is to configure scaling manually in the application's App Service Plan.</span></span> <span data-ttu-id="b2ccc-190">圖 5-6 顯示適當的 Azure 儀表板畫面，以設定多少個執行個體正在服務應用程式。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-190">Figure 5-6 shows the appropriate Azure dashboard screen to configure how many instances are serving an app.</span></span>

![App Service Azure 中的方案調整規模](./media/image5-6.png)

<span data-ttu-id="b2ccc-192">**圖5-6。**</span><span class="sxs-lookup"><span data-stu-id="b2ccc-192">**Figure 5-6.**</span></span> <span data-ttu-id="b2ccc-193">在 Azure 中調整應用程式服務方案。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-193">App Service Plan scaling in Azure.</span></span>

## <a name="clean-architecture"></a><span data-ttu-id="b2ccc-194">Clean Architecture</span><span class="sxs-lookup"><span data-stu-id="b2ccc-194">Clean architecture</span></span>

<span data-ttu-id="b2ccc-195">遵循相依性反轉準則以及領域驅動設計 (DDD) 準則的應用程式通常會達到類似的架構。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-195">Applications that follow the Dependency Inversion Principle as well as the Domain-Driven Design (DDD) principles tend to arrive at a similar architecture.</span></span> <span data-ttu-id="b2ccc-196">這個架構多年來有了許多名稱。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-196">This architecture has gone by many names over the years.</span></span> <span data-ttu-id="b2ccc-197">最早的其中一個名稱是 Hexagonal Architecture，後來則是 Ports-and-Adapters。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-197">One of the first names was Hexagonal Architecture, followed by Ports-and-Adapters.</span></span> <span data-ttu-id="b2ccc-198">最近，它被引用為 [Onion Architecture](https://jeffreypalermo.com/blog/the-onion-architecture-part-1/) 或 [Clean Architecture](https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html)。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-198">More recently, it's been cited as the [Onion Architecture](https://jeffreypalermo.com/blog/the-onion-architecture-part-1/) or [Clean Architecture](https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html).</span></span> <span data-ttu-id="b2ccc-199">本電子書使用第二個名稱 Clean Architecture 作為此架構的名稱。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-199">The latter name, Clean Architecture, is used as the name for this architecture in this e-book.</span></span>

<span data-ttu-id="b2ccc-200">EShopOnWeb 參考應用程式在將程式碼組織成專案時，會使用全新的架構方法。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-200">The eShopOnWeb reference application uses the Clean Architecture approach in organizing its code into projects.</span></span> <span data-ttu-id="b2ccc-201">您可以在 [ardalis/cleanarchitecture](https://github.com/ardalis/cleanarchitecture) GitHub 存放庫中找到可作為自己 ASP.NET Core 起點的解決方案範本。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-201">You can find a solution template you can use as a starting point for your own ASP.NET Core on the [ardalis/cleanarchitecture](https://github.com/ardalis/cleanarchitecture) GitHub repository.</span></span>

<span data-ttu-id="b2ccc-202">Clean Architecture 會將商務邏輯和應用程式模型放在應用程式的中央位置。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-202">Clean architecture puts the business logic and application model at the center of the application.</span></span> <span data-ttu-id="b2ccc-203">不讓商務邏輯相依於資料存取或其他基礎結構的關注點，而是反轉此相依性：基礎結構和實作詳細資料相依於應用程式核心。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-203">Instead of having business logic depend on data access or other infrastructure concerns, this dependency is inverted: infrastructure and implementation details depend on the Application Core.</span></span> <span data-ttu-id="b2ccc-204">藉由在應用程式核心定義抽象或介面，然後它們會由基礎結構層中定義的類型所實作，即可達到此目的。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-204">This is achieved by defining abstractions, or interfaces, in the Application Core, which are then implemented by types defined in the Infrastructure layer.</span></span> <span data-ttu-id="b2ccc-205">視覺化這個架構的常見方式是使用一系列的同心圓，類似於洋蔥。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-205">A common way of visualizing this architecture is to use a series of concentric circles, similar to an onion.</span></span> <span data-ttu-id="b2ccc-206">圖 5-7 示範這種架構的表示法。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-206">Figure 5-7 shows an example of this style of architectural representation.</span></span>

![Clean Architecture；洋蔥檢視](./media/image5-7.png)

<span data-ttu-id="b2ccc-208">**圖5-7。**</span><span class="sxs-lookup"><span data-stu-id="b2ccc-208">**Figure 5-7.**</span></span> <span data-ttu-id="b2ccc-209">Clean Architecture；洋蔥檢視</span><span class="sxs-lookup"><span data-stu-id="b2ccc-209">Clean Architecture; onion view</span></span>

<span data-ttu-id="b2ccc-210">在此圖中，相依性會流向最內層的圓形。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-210">In this diagram, dependencies flow toward the innermost circle.</span></span> <span data-ttu-id="b2ccc-211">應用程式核心從其在此圖核心的位置擷取其名稱。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-211">The Application Core takes its name from its position at the core of this diagram.</span></span> <span data-ttu-id="b2ccc-212">如圖所示，應用程式核心對於其他應用程式層級沒有任何相依性。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-212">And you can see on the diagram that the Application Core has no dependencies on other application layers.</span></span> <span data-ttu-id="b2ccc-213">應用程式的實體和介面位於正中心。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-213">The application's entities and interfaces are at the very center.</span></span> <span data-ttu-id="b2ccc-214">在外面一點，但仍在應用程式核心中，則是網域服務，它們通常會實作內部圓形中定義的介面。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-214">Just outside, but still in the Application Core, are domain services, which typically implement interfaces defined in the inner circle.</span></span> <span data-ttu-id="b2ccc-215">在應用程式核心外面，UI 與基礎結構層都相依於應用程式核心，但彼此不一定相依。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-215">Outside of the Application Core, both the UI and the Infrastructure layers depend on the Application Core, but not on one another (necessarily).</span></span>

<span data-ttu-id="b2ccc-216">圖 5-8 顯示更傳統的水平分層圖，更能反映出 UI 和其他層級之間的相依性。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-216">Figure 5-8 shows a more traditional horizontal layer diagram that better reflects the dependency between the UI and other layers.</span></span>

![Clean Architecture；水平層檢視](./media/image5-8.png)

<span data-ttu-id="b2ccc-218">**圖5-8。**</span><span class="sxs-lookup"><span data-stu-id="b2ccc-218">**Figure 5-8.**</span></span> <span data-ttu-id="b2ccc-219">Clean Architecture；水平層檢視</span><span class="sxs-lookup"><span data-stu-id="b2ccc-219">Clean Architecture; horizontal layer view</span></span>

<span data-ttu-id="b2ccc-220">請注意，實心箭號代表編譯時期相依性，而虛線箭頭代表僅限執行階段的相依性。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-220">Note that the solid arrows represent compile-time dependencies, while the dashed arrow represents a runtime-only dependency.</span></span> <span data-ttu-id="b2ccc-221">使用 Clean Architecture，UI 層適用於在編譯時期，在應用程式核心中定義的介面，並且在理想情況下，應該不知道基礎結構層定義的實作類型。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-221">With the clean architecture, the UI layer works with interfaces defined in the Application Core at compile time, and ideally shouldn't know about the implementation types defined in the Infrastructure layer.</span></span> <span data-ttu-id="b2ccc-222">不過，在執行階段，必須有這些實作類型，應用程式才能執行，因此它們必須存在並透過相依性插入而連接到應用程式核心介面。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-222">At run time, however, these implementation types are required for the app to execute, so they need to be present and wired up to the Application Core interfaces via dependency injection.</span></span>

<span data-ttu-id="b2ccc-223">圖 5-9 顯示遵循這些建議建置時，更詳細的 ASP.NET Core 應用程式架構。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-223">Figure 5-9 shows a more detailed view of an ASP.NET Core application's architecture when built following these recommendations.</span></span>

![遵循乾淨架構的 ASP.NET Core 架構圖表](./media/image5-9.png)

<span data-ttu-id="b2ccc-225">**圖5-9。**</span><span class="sxs-lookup"><span data-stu-id="b2ccc-225">**Figure 5-9.**</span></span> <span data-ttu-id="b2ccc-226">遵循 Clean Architecture 的 ASP.NET Core 架構圖表。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-226">ASP.NET Core architecture diagram following Clean Architecture.</span></span>

<span data-ttu-id="b2ccc-227">因為應用程式核心不會相依於基礎結構，所以很容易就能為此層級撰寫自動化的單元測試。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-227">Because the Application Core doesn't depend on Infrastructure, it's very easy to write automated unit tests for this layer.</span></span> <span data-ttu-id="b2ccc-228">圖 5-10 和 5-11 顯示測試如何配合這個架構。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-228">Figures 5-10 and 5-11 show how tests fit into this architecture.</span></span>

![UnitTestCore](./media/image5-10.png)

<span data-ttu-id="b2ccc-230">**圖5-10。**</span><span class="sxs-lookup"><span data-stu-id="b2ccc-230">**Figure 5-10.**</span></span> <span data-ttu-id="b2ccc-231">隔離進行應用程式核心的單元測試。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-231">Unit testing Application Core in isolation.</span></span>

![IntegrationTests](./media/image5-11.png)

<span data-ttu-id="b2ccc-233">**圖5-11。**</span><span class="sxs-lookup"><span data-stu-id="b2ccc-233">**Figure 5-11.**</span></span> <span data-ttu-id="b2ccc-234">整合測試具有外部相依性的基礎結構實作。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-234">Integration testing Infrastructure implementations with external dependencies.</span></span>

<span data-ttu-id="b2ccc-235">因為 UI 層對於基礎結構專案中定義的類型沒有直接的相依性，所以同樣很容易就能換掉實作，以方便測試或回應不斷變更的應用程式需求。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-235">Since the UI layer doesn't have any direct dependency on types defined in the Infrastructure project, it's likewise very easy to swap out implementations, either to facilitate testing or in response to changing application requirements.</span></span> <span data-ttu-id="b2ccc-236">ASP.NET Core 的內建相依性插入使用和支援，可讓此架構成為建構重要整合型應用程式的最適當方式。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-236">ASP.NET Core's built-in use of and support for dependency injection makes this architecture the most appropriate way to structure non-trivial monolithic applications.</span></span>

<span data-ttu-id="b2ccc-237">對於整合型應用程式，應用程式核心、基礎結構和 UI 專案全都執行為單一應用程式。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-237">For monolithic applications the Application Core, Infrastructure, and UI projects are all run as a single application.</span></span> <span data-ttu-id="b2ccc-238">執行階段應用程式架構看起來可能圖 5-12。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-238">The runtime application architecture might look something like Figure 5-12.</span></span>

![ASP.NET Core 架構 2](./media/image5-12.png)

<span data-ttu-id="b2ccc-240">**圖5-12。**</span><span class="sxs-lookup"><span data-stu-id="b2ccc-240">**Figure 5-12.**</span></span> <span data-ttu-id="b2ccc-241">範例 ASP.NET Core 應用程式的執行階段架構。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-241">A sample ASP.NET Core app's runtime architecture.</span></span>

### <a name="organizing-code-in-clean-architecture"></a><span data-ttu-id="b2ccc-242">以 Clean Architecture 組織程式碼</span><span class="sxs-lookup"><span data-stu-id="b2ccc-242">Organizing code in Clean Architecture</span></span>

<span data-ttu-id="b2ccc-243">在 Clean Architecture 解決方案中，每個專案都有清楚的責任。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-243">In a Clean Architecture solution, each project has clear responsibilities.</span></span> <span data-ttu-id="b2ccc-244">因此，某些類型屬於每個專案，而您將經常找到對應至適當專案中這些類型的資料夾。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-244">As such, certain types belong in each project and you'll frequently find folders corresponding to these types in the appropriate project.</span></span>

#### <a name="application-core"></a><span data-ttu-id="b2ccc-245">應用程式核心</span><span class="sxs-lookup"><span data-stu-id="b2ccc-245">Application Core</span></span>

<span data-ttu-id="b2ccc-246">應用程式核心會保存商務模型，其中包含實體、服務和介面。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-246">The Application Core holds the business model, which includes entities, services, and interfaces.</span></span> <span data-ttu-id="b2ccc-247">這些介面包含將使用基礎結構（例如資料存取、檔案系統存取、網路呼叫等）執行之作業的抽象概念。有時，在此層級定義的服務或介面，必須使用對 UI 或基礎結構沒有相依性的非實體類型。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-247">These interfaces include abstractions for operations that will be performed using Infrastructure, such as data access, file system access, network calls, etc. Sometimes services or interfaces defined at this layer will need to work with non-entity types that have no dependencies on UI or Infrastructure.</span></span> <span data-ttu-id="b2ccc-248">這些可以定義為簡單的資料傳輸物件 (DTO)。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-248">These can be defined as simple Data Transfer Objects (DTOs).</span></span>

##### <a name="application-core-types"></a><span data-ttu-id="b2ccc-249">應用程式核心類型</span><span class="sxs-lookup"><span data-stu-id="b2ccc-249">Application Core types</span></span>

- <span data-ttu-id="b2ccc-250">實體 (持續保存的商務模型類別)</span><span class="sxs-lookup"><span data-stu-id="b2ccc-250">Entities (business model classes that are persisted)</span></span>
- <span data-ttu-id="b2ccc-251">介面</span><span class="sxs-lookup"><span data-stu-id="b2ccc-251">Interfaces</span></span>
- <span data-ttu-id="b2ccc-252">服務</span><span class="sxs-lookup"><span data-stu-id="b2ccc-252">Services</span></span>
- <span data-ttu-id="b2ccc-253">DTO</span><span class="sxs-lookup"><span data-stu-id="b2ccc-253">DTOs</span></span>

#### <a name="infrastructure"></a><span data-ttu-id="b2ccc-254">基礎結構</span><span class="sxs-lookup"><span data-stu-id="b2ccc-254">Infrastructure</span></span>

<span data-ttu-id="b2ccc-255">基礎結構專案通常會包含資料存取實作。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-255">The Infrastructure project typically includes data access implementations.</span></span> <span data-ttu-id="b2ccc-256">在一般 ASP.NET Core Web 應用程式中，這些實作包括 Entity Framework (EF) DbContext、已定義的任何 EF Core `Migration` 物件和資料存取實作類別。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-256">In a typical ASP.NET Core web application, these implementations include the Entity Framework (EF) DbContext, any EF Core `Migration` objects that have been defined, and data access implementation classes.</span></span> <span data-ttu-id="b2ccc-257">擷取資料存取實作程式碼的最常見方式，是透過使用 [Repository design pattern](https://deviq.com/repository-pattern/) (存放庫設計模式)。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-257">The most common way to abstract data access implementation code is through the use of the [Repository design pattern](https://deviq.com/repository-pattern/).</span></span>

<span data-ttu-id="b2ccc-258">除了資料存取實作，基礎結構專案也應包含必須與基礎結構關注點互動的服務實作。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-258">In addition to data access implementations, the Infrastructure project should contain implementations of services that must interact with infrastructure concerns.</span></span> <span data-ttu-id="b2ccc-259">這些服務應該實作在應用程式核心定義的介面，且基礎結構應該有應用程式核心專案的參考。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-259">These services should implement interfaces defined in the Application Core, and so Infrastructure should have a reference to the Application Core project.</span></span>

##### <a name="infrastructure-types"></a><span data-ttu-id="b2ccc-260">基礎結構類型</span><span class="sxs-lookup"><span data-stu-id="b2ccc-260">Infrastructure types</span></span>

- <span data-ttu-id="b2ccc-261">EF Core 類型 (`DbContext`、`Migration`)</span><span class="sxs-lookup"><span data-stu-id="b2ccc-261">EF Core types (`DbContext`, `Migration`)</span></span>
- <span data-ttu-id="b2ccc-262">資料存取實作類型 (存放庫)</span><span class="sxs-lookup"><span data-stu-id="b2ccc-262">Data access implementation types (Repositories)</span></span>
- <span data-ttu-id="b2ccc-263">基礎結構特定服務 (例如 `FileLogger` 或 `SmtpNotifier`)</span><span class="sxs-lookup"><span data-stu-id="b2ccc-263">Infrastructure-specific services (for example, `FileLogger` or `SmtpNotifier`)</span></span>

#### <a name="ui-layer"></a><span data-ttu-id="b2ccc-264">UI 層</span><span class="sxs-lookup"><span data-stu-id="b2ccc-264">UI Layer</span></span>

<span data-ttu-id="b2ccc-265">ASP.NET Core MVC 應用程式中的使用者介面層是應用程式的進入點。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-265">The user interface layer in an ASP.NET Core MVC application is the entry point for the application.</span></span> <span data-ttu-id="b2ccc-266">這個專案應該參考應用程式核心專案，而其類型應該嚴格地透過應用程式核心中定義的介面與基礎結構互動。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-266">This project should reference the Application Core project, and its types should interact with infrastructure strictly through interfaces defined in Application Core.</span></span> <span data-ttu-id="b2ccc-267">在 UI 層不應該允許基礎結構層類型的任何直接具現化或靜態呼叫。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-267">No direct instantiation of or static calls to the Infrastructure layer types should be allowed in the UI layer.</span></span>

##### <a name="ui-layer-types"></a><span data-ttu-id="b2ccc-268">UI 層類型</span><span class="sxs-lookup"><span data-stu-id="b2ccc-268">UI Layer types</span></span>

- <span data-ttu-id="b2ccc-269">控制器</span><span class="sxs-lookup"><span data-stu-id="b2ccc-269">Controllers</span></span>
- <span data-ttu-id="b2ccc-270">篩選器</span><span class="sxs-lookup"><span data-stu-id="b2ccc-270">Filters</span></span>
- <span data-ttu-id="b2ccc-271">檢視</span><span class="sxs-lookup"><span data-stu-id="b2ccc-271">Views</span></span>
- <span data-ttu-id="b2ccc-272">ViewModels</span><span class="sxs-lookup"><span data-stu-id="b2ccc-272">ViewModels</span></span>
- <span data-ttu-id="b2ccc-273">啟動</span><span class="sxs-lookup"><span data-stu-id="b2ccc-273">Startup</span></span>

<span data-ttu-id="b2ccc-274">啟動類別負責設定應用程式，以及將實作類型連接至介面，讓相依性插入能在執行階段正常運作。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-274">The Startup class is responsible for configuring the application, and for wiring up implementation types to interfaces, allowing dependency injection to work properly at run time.</span></span>

> [!NOTE]
> <span data-ttu-id="b2ccc-275">若要在 UI 專案之 Startup.cs 檔的 ConfigureServices 中連接相依性插入，專案可能需要參考基礎結構專案。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-275">In order to wire up dependency injection in ConfigureServices in the Startup.cs file of the UI project, the project may need to reference the Infrastructure project.</span></span> <span data-ttu-id="b2ccc-276">此相依性可以使用自訂 DI 容器來輕易地去除。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-276">This dependency can be eliminated, most easily by using a custom DI container.</span></span> <span data-ttu-id="b2ccc-277">基於此範例的目的，最簡單的方法是允許 UI 專案參考基礎結構專案。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-277">For the purposes of this sample, the simplest approach is to allow the UI project to reference the Infrastructure project.</span></span>

## <a name="monolithic-applications-and-containers"></a><span data-ttu-id="b2ccc-278">整合型應用程式和容器</span><span class="sxs-lookup"><span data-stu-id="b2ccc-278">Monolithic applications and containers</span></span>

<span data-ttu-id="b2ccc-279">您可以建置單一且以整合型部署為基礎的 Web 應用程式或服務，並將它部署為容器。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-279">You can build a single and monolithic-deployment based Web Application or Service and deploy it as a container.</span></span> <span data-ttu-id="b2ccc-280">在應用程式內，它可能不是整合型，而是組織成幾個程式庫、元件或層級。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-280">Within the application, it might not be monolithic but organized into several libraries, components, or layers.</span></span> <span data-ttu-id="b2ccc-281">從外部來看，它是單一容器，像是單一處理序、單一 Web 應用程式或單一服務。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-281">Externally, it's a single container like a single process, single web application, or single service.</span></span>

<span data-ttu-id="b2ccc-282">為了管理此模型，您會部署單一容器來代表應用程式。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-282">To manage this model, you deploy a single container to represent the application.</span></span> <span data-ttu-id="b2ccc-283">若要調整，只要透過前端負載平衡器新增額外的複本即可。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-283">To scale, just add additional copies with a load balancer in front.</span></span> <span data-ttu-id="b2ccc-284">由於是在單一容器或 VM 中管理單一部署，因此很簡單。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-284">The simplicity comes from managing a single deployment in a single container or VM.</span></span>

![圖5-13](./media/image5-13.png)

<span data-ttu-id="b2ccc-286">您可以在每個容器中包含多個元件/程式庫或內部層級，如圖 5-13 所示。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-286">You can include multiple components/libraries or internal layers within each container, as illustrated in Figure 5-13.</span></span> <span data-ttu-id="b2ccc-287">不過，遵循「容器執行一項動作並在一個處理序中執行該動作」__ 的容器準則時，整合型模式可能會是一項衝突。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-287">But, following the container principle of _"a container does one thing, and does it in one process_", the monolithic pattern might be a conflict.</span></span>

<span data-ttu-id="b2ccc-288">如果應用程式成長而需要擴充，此方法的缺點便會浮現。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-288">The downside of this approach comes if/when the application grows, requiring it to scale.</span></span> <span data-ttu-id="b2ccc-289">若整個應用程式都擴充，則不成問題。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-289">If the entire application scales, it's not really a problem.</span></span> <span data-ttu-id="b2ccc-290">不過，在大多數情況下，應用程式只需要調整幾個造成阻礙的部分，其他元件則較少使用。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-290">However, in most cases, a few parts of the application are the choke points requiring scaling, while other components are used less.</span></span>

<span data-ttu-id="b2ccc-291">使用一般的電子商務範例，您可能需要調整的是產品資訊元件。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-291">Using the typical eCommerce example, what you likely need to scale is the product information component.</span></span> <span data-ttu-id="b2ccc-292">瀏覽產品的客戶比購買的人多。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-292">Many more customers browse products than purchase them.</span></span> <span data-ttu-id="b2ccc-293">比起使用付款管道，會有更多客戶使用其購物籃。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-293">More customers use their basket than use the payment pipeline.</span></span> <span data-ttu-id="b2ccc-294">新增留言或檢視其購買歷程記錄的客戶較少。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-294">Fewer customers add comments or view their purchase history.</span></span> <span data-ttu-id="b2ccc-295">而且在單一區域中，您可能只有少數幾個員工，需要管理內容和行銷活動。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-295">And you likely only have a handful of employees, in a single region, that need to manage the content and marketing campaigns.</span></span> <span data-ttu-id="b2ccc-296">藉由調整整合型設計，所有的程式碼會多次部署。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-296">By scaling the monolithic design, all the code is deployed multiple times.</span></span>

<span data-ttu-id="b2ccc-297">除了「全部調整」的問題之外，單一元件的變更都需要完整地重新測試整個應用程式，並完整重新部署所有執行個體。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-297">In addition to the "scale everything" problem, changes to a single component require complete retesting of the entire application, and a complete redeployment of all the instances.</span></span>

<span data-ttu-id="b2ccc-298">整合型方法很常見，許多組織也正在使用這個架構方法進行開發。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-298">The monolithic approach is common, and many organizations are developing with this architectural approach.</span></span> <span data-ttu-id="b2ccc-299">許多有足夠好的結果，但其他則只是達到限制。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-299">Many are having good enough results, while others are hitting limits.</span></span> <span data-ttu-id="b2ccc-300">許多組織使用此模型來設計其應用程式，因為工具和基礎結構很難建置服務導向架構 (SOA)，而且在應用程式成長之前也看不到此需求。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-300">Many designed their applications in this model, because the tools and infrastructure were too difficult to build service-oriented architectures (SOA), and they didn't see the need until the app grew.</span></span> <span data-ttu-id="b2ccc-301">如果您發現您達到整合型方法的限制，下個邏輯步驟可能是分解應用程式，以便讓它能更充分利用容器和微服務。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-301">If you find you're hitting the limits of the monolithic approach, breaking up the app to enable it to better leverage containers and microservices may be the next logical step.</span></span>

![圖5-14](./media/image5-14.png)

<span data-ttu-id="b2ccc-303">您可以針對每個執行個體使用專用 VM，在 Microsoft Azure 中部署整合型應用程式。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-303">Deploying monolithic applications in Microsoft Azure can be achieved using dedicated VMs for each instance.</span></span> <span data-ttu-id="b2ccc-304">您可以使用 [Azure 虛擬機器擴展集](/azure/virtual-machine-scale-sets/)輕鬆地調整 VM。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-304">Using [Azure Virtual Machine Scale Sets](/azure/virtual-machine-scale-sets/), you can easily scale the VMs.</span></span> <span data-ttu-id="b2ccc-305">[Azure App Service](https://azure.microsoft.com/services/app-service/) 可以執行整合型應用程式並輕鬆地調整執行個體，而不必管理 VM。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-305">[Azure App Services](https://azure.microsoft.com/services/app-service/) can run monolithic applications and easily scale instances without having to manage the VMs.</span></span> <span data-ttu-id="b2ccc-306">Azure App Service 也可以執行 Docker 容器的單一執行個體，以簡化部署。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-306">Azure App Services can run single instances of Docker containers as well, simplifying the deployment.</span></span> <span data-ttu-id="b2ccc-307">使用 Docker 時，您可以部署單一 VM 作為 Docker 主機，並執行多個執行個體。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-307">Using Docker, you can deploy a single VM as a Docker host, and run multiple instances.</span></span> <span data-ttu-id="b2ccc-308">使用 Azure 平衡器，如圖 5-14 中所示，您可以管理調整。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-308">Using the Azure balancer, as shown in the Figure 5-14, you can manage scaling.</span></span>

<span data-ttu-id="b2ccc-309">您可以透過傳統部署技術來管理不同主機的部署，</span><span class="sxs-lookup"><span data-stu-id="b2ccc-309">The deployment to the various hosts can be managed with traditional deployment techniques.</span></span> <span data-ttu-id="b2ccc-310">並可以手動執行 **docker run** 等命令，或是透過持續傳遞 (CD) 管線等自動化方法來管理 Docker 主機。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-310">The Docker hosts can be managed with commands like **docker run** performed manually, or through automation such as Continuous Delivery (CD) pipelines.</span></span>

### <a name="monolithic-application-deployed-as-a-container"></a><span data-ttu-id="b2ccc-311">整合型應用程式部署為容器</span><span class="sxs-lookup"><span data-stu-id="b2ccc-311">Monolithic application deployed as a container</span></span>

<span data-ttu-id="b2ccc-312">使用容器來管理整合型應用程式部署有許多優點。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-312">There are benefits of using containers to manage monolithic application deployments.</span></span> <span data-ttu-id="b2ccc-313">調整容器執行個體遠比部署額外的 VM 更輕鬆快速。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-313">Scaling the instances of containers is far faster and easier than deploying additional VMs.</span></span> <span data-ttu-id="b2ccc-314">即使是使用虛擬機器擴展集來調整 VM，它們也需要時間具現化。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-314">Even when using virtual machine scale sets to scale VMs, they take time to instance.</span></span> <span data-ttu-id="b2ccc-315">當部署為應用程式執行個體時，應用程式的設定是作為 VM 的一部分管理。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-315">When deployed as app instances, the configuration of the app is managed as part of the VM.</span></span>

<span data-ttu-id="b2ccc-316">以 Docker 映像來部署更新會更快且網路效率更高。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-316">Deploying updates as Docker images is far faster and network efficient.</span></span> <span data-ttu-id="b2ccc-317">Docker 映像通常只要幾秒鐘就能啟動，因此可加速推出。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-317">Docker Images typically start in seconds, speeding rollouts.</span></span> <span data-ttu-id="b2ccc-318">卸除 Docker 執行個體很容易，只要發出 `docker stop` 命令即可，而且通常不到一秒就會完成。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-318">Tearing down a Docker instance is as easy as issuing a `docker stop` command, typically completing in less than a second.</span></span>

<span data-ttu-id="b2ccc-319">容器的設計原本就是不可變的，您永遠不需要擔心 VM 損毀，而更新指令碼可能會忘記處理部分特定設定或是檔案殘留在磁碟上。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-319">As containers are inherently immutable by design, you never need to worry about corrupted VMs, whereas update scripts might forget to account for some specific configuration or file left on disk.</span></span>

<span data-ttu-id="b2ccc-320">您可以使用 Docker 容器進行更簡單的 Web 應用程式整合型部署。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-320">You can use Docker containers for monolithic deployment of simpler web applications.</span></span> <span data-ttu-id="b2ccc-321">如此可改善持續整合與持續部署管線，並協助完成部署到生產的過程。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-321">This improves continuous integration and continuous deployment pipelines and helps achieve deployment-to-production success.</span></span> <span data-ttu-id="b2ccc-322">不再有「它可在我的電腦上運作，為什麼它無法在生產環境中運作？」</span><span class="sxs-lookup"><span data-stu-id="b2ccc-322">No more “It works on my machine, why does it not work in production?”</span></span>

<span data-ttu-id="b2ccc-323">微服務架構有許多好處，但這些好處的代價是複雜度會增加。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-323">A microservices-based architecture has many benefits, but those benefits come at a cost of increased complexity.</span></span> <span data-ttu-id="b2ccc-324">在某些情況下，這些代價會遠大於所獲得的好處，因此在單一容器或幾個容器中執行整合型部署應用程式會是較佳的選擇。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-324">In some cases, the costs outweigh the benefits, so a monolithic deployment application running in a single container or in just a few containers is a better option.</span></span>

<span data-ttu-id="b2ccc-325">整合型應用程式可能不容易分解成多個適當分離的微服務。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-325">A monolithic application might not be easily decomposable into well-separated microservices.</span></span> <span data-ttu-id="b2ccc-326">微服務應該彼此獨立運作，才能提供復原能力更高的應用程式。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-326">Microservices should work independently of each other to provide a more resilient application.</span></span> <span data-ttu-id="b2ccc-327">如果您無法獨立切割應用程式的功能，將它分離只會增加複雜度。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-327">If you can't deliver independent feature slices of the application, separating it only adds complexity.</span></span>

<span data-ttu-id="b2ccc-328">應用程式可能還不需要獨立擴充功能。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-328">An application might not yet need to scale features independently.</span></span> <span data-ttu-id="b2ccc-329">許多應用程式若其規模需要超過單一執行個體，則可透過複製整個執行個體之相當簡單的程序來完成。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-329">Many applications, when they need to scale beyond a single instance, can do so through the relatively simple process of cloning that entire instance.</span></span> <span data-ttu-id="b2ccc-330">執行額外工作以將應用程式分成不同服務的好處有限，而擴充應用程式的整個執行個體不僅簡單且符合成本效益。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-330">The additional work to separate the application into discrete services provides minimal benefit when scaling full instances of the application is simple and cost-effective.</span></span>

<span data-ttu-id="b2ccc-331">在開發應用程式初期，您可能不清楚自然功能邊界止於何處。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-331">Early in the development of an application, you might not have a clear idea where the natural functional boundaries are.</span></span> <span data-ttu-id="b2ccc-332">當您開發最低可行性產品 (Minimum Viable Product) 時，自然分離的情況可能尚不明顯。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-332">As you develop a minimum viable product, the natural separation might not yet have emerged.</span></span> <span data-ttu-id="b2ccc-333">有些情況可能是暫時性的。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-333">Some of these conditions might be temporary.</span></span> <span data-ttu-id="b2ccc-334">您可以先建立一個整合型應用程式，稍後再將某些功能分成微服務來開發和部署。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-334">You might start by creating a monolithic application, and later separate some features to be developed and deployed as microservices.</span></span> <span data-ttu-id="b2ccc-335">其他條件可能對應用程式的問題空間很重要，這表示應用程式可能永遠不會分成多個微服務。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-335">Other conditions might be essential to the application's problem space, meaning that the application might never be broken into multiple microservices.</span></span>

<span data-ttu-id="b2ccc-336">將應用程式分成許多不同的處理序也會引進額外負荷。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-336">Separating an application into many discrete processes also introduces overhead.</span></span> <span data-ttu-id="b2ccc-337">將功能分成不同處理序的複雜度更高。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-337">There's more complexity in separating features into different processes.</span></span> <span data-ttu-id="b2ccc-338">通訊協定變得更複雜。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-338">The communication protocols become more complex.</span></span> <span data-ttu-id="b2ccc-339">您必須在服務之間使用非同步通訊，而不是方法呼叫。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-339">Instead of method calls, you must use asynchronous communications between services.</span></span> <span data-ttu-id="b2ccc-340">當您移至微服務架構時，您需要新增在 eShopOnContainers 應用程式的微服務版本中實作的許多建置組塊：事件匯流排處理、訊息復原與重試、最終一致性等等。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-340">As you move to a microservices architecture, you need to add many of the building blocks implemented in the microservices version of the eShopOnContainers application: event bus handling, message resiliency and retries, eventual consistency, and more.</span></span>

<span data-ttu-id="b2ccc-341">更簡單的 [eShopOnWeb 參考應用程式](https://github.com/dotnet-architecture/eShopOnWeb)支援單一容器的整合型容器使用。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-341">The much simpler [eShopOnWeb reference application](https://github.com/dotnet-architecture/eShopOnWeb) supports single-container monolithic container usage.</span></span> <span data-ttu-id="b2ccc-342">該應用程式包含一個 Web 應用程式，其中包括傳統 MVC 檢視、Web API 及 Razor Pages。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-342">The application includes one web application that includes traditional MVC views, web APIs, and Razor Pages.</span></span> <span data-ttu-id="b2ccc-343">這個應用程式可使用 `docker-compose build` 和 `docker-compose up` 命令從解決方案根目錄啟動。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-343">This application can be launched from the solution root using the `docker-compose build` and `docker-compose up` commands.</span></span> <span data-ttu-id="b2ccc-344">該命令會使用在 Web 專案根目錄中找到的 `Dockerfile` 來設定 Web 執行個體的容器，並在指定的連接埠上執行容器。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-344">This command configures a container for the web instance, using the `Dockerfile` found in the web project's root, and runs the container on a specified port.</span></span> <span data-ttu-id="b2ccc-345">您可以從 GitHub 下載此應用程式的來源並在本機執行。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-345">You can download the source for this application from GitHub and run it locally.</span></span> <span data-ttu-id="b2ccc-346">即使是此整合型應用程式也可以透過部署至容器環境獲利。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-346">Even this monolithic application benefits from being deployed in a container environment.</span></span>

<span data-ttu-id="b2ccc-347">其中一個優點是，容器化部署表示每個應用程式執行個體都會在相同的環境中執行。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-347">For one, the containerized deployment means that every instance of the application runs in the same environment.</span></span> <span data-ttu-id="b2ccc-348">這包括進行早期測試和開發的開發人員環境。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-348">This includes the developer environment where early testing and development take place.</span></span> <span data-ttu-id="b2ccc-349">開發小組可以在與生產環境相符的容器化環境中執行應用程式。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-349">The development team can run the application in a containerized environment that matches the production environment.</span></span>

<span data-ttu-id="b2ccc-350">此外，擴充容器化應用程式的成本較低。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-350">In addition, containerized applications scale out at lower cost.</span></span> <span data-ttu-id="b2ccc-351">使用容器環境可共用的資源比傳統 VM 環境更多。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-351">Using a container environment enables greater resource sharing than traditional VM environments.</span></span>

<span data-ttu-id="b2ccc-352">最後，容器化應用程式會強制分離商務邏輯與存放區伺服器。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-352">Finally, containerizing the application forces a separation between the business logic and the storage server.</span></span> <span data-ttu-id="b2ccc-353">當應用程式擴充時，多個容器全部都會依賴單一實體儲存媒體。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-353">As the application scales out, the multiple containers will all rely on a single physical storage medium.</span></span> <span data-ttu-id="b2ccc-354">此儲存媒體通常會是執行 SQL Server 資料庫的高可用性伺服器。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-354">This storage medium would typically be a high-availability server running a SQL Server database.</span></span>

## <a name="docker-support"></a><span data-ttu-id="b2ccc-355">Docker 支援</span><span class="sxs-lookup"><span data-stu-id="b2ccc-355">Docker support</span></span>

<span data-ttu-id="b2ccc-356">`eShopOnWeb` 專案是在 .NET Core 上執行。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-356">The `eShopOnWeb` project runs on .NET Core.</span></span> <span data-ttu-id="b2ccc-357">因此，它可以在 Linux 或 Windows 容器中執行。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-357">Therefore, it can run in either Linux-based or Windows-based containers.</span></span> <span data-ttu-id="b2ccc-358">請注意，若是 Docker 部署，您想要針對 SQL Server 使用相同的主機類型。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-358">Note that for Docker deployment, you want to use the same host type for SQL Server.</span></span> <span data-ttu-id="b2ccc-359">Linux 容器允許較小的使用量，而且是偏好選項。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-359">Linux-based containers allow a smaller footprint and are preferred.</span></span>

<span data-ttu-id="b2ccc-360">您可以使用 Visual Studio 2017 或更新版本將 Docker 支援新增到現有的應用程式，方法是以滑鼠右鍵按一下 [方案總管]\*\*\*\* 中的專案，然後選擇 [新增]\*\*\*\* > [Docker 支援]\*\*\*\*。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-360">You can use Visual Studio 2017 or later to add Docker support to an existing application by right-clicking on a project in **Solution Explorer** and choosing **Add** > **Docker Support**.</span></span> <span data-ttu-id="b2ccc-361">這會新增所需的檔案，並修改專案以使用這些檔案。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-361">This adds the files required and modifies the project to use them.</span></span> <span data-ttu-id="b2ccc-362">目前的 `eShopOnWeb` 範例已有這些檔案。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-362">The current `eShopOnWeb` sample already has these files in place.</span></span>

<span data-ttu-id="b2ccc-363">方案層級 `docker-compose.yml` 檔案包含要建置哪些映像及要啟動哪些容器的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-363">The solution-level `docker-compose.yml` file contains information about what images to build and what containers to launch.</span></span> <span data-ttu-id="b2ccc-364">該檔案可讓您使用 `docker-compose` 命令同時啟動多個應用程式。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-364">The file allows you to use the `docker-compose` command to launch multiple applications at the same time.</span></span> <span data-ttu-id="b2ccc-365">在這個情況下，它只會啟動 Web 專案。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-365">In this case, it is only launching the Web project.</span></span> <span data-ttu-id="b2ccc-366">您也可以使用它來設定相依性，例如個別的資料庫容器。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-366">You can also use it to configure dependencies, such as a separate database container.</span></span>

```yml
version: '3'

services:
  eshopwebmvc:
    image: eshopwebmvc
    build:
      context: .
      dockerfile: src/Web/Dockerfile
    environment:
      - ASPNETCORE_ENVIRONMENT=Development
    ports:
      - "5106:5106"

networks:
  default:
    external:
      name: nat
```

<span data-ttu-id="b2ccc-367">`docker-compose.yml` 檔案參考了 `Web` 專案中的 `Dockerfile`。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-367">The `docker-compose.yml` file references the `Dockerfile` in the `Web` project.</span></span> <span data-ttu-id="b2ccc-368">`Dockerfile` 是用來指定將使用的基底容器，以及如何在其上設定應用程式。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-368">The `Dockerfile` is used to specify which base container will be used and how the application will be configured on it.</span></span> <span data-ttu-id="b2ccc-369">`Web` 的 `Dockerfile`：</span><span class="sxs-lookup"><span data-stu-id="b2ccc-369">The `Web`' `Dockerfile`:</span></span>

```dockerfile
FROM mcr.microsoft.com/dotnet/core/sdk:3.1 AS build
WORKDIR /app

COPY *.sln .
COPY . .
WORKDIR /app/src/Web
RUN dotnet restore

RUN dotnet publish -c Release -o out

FROM mcr.microsoft.com/dotnet/core/aspnet:3.1 AS runtime
WORKDIR /app
COPY --from=build /app/src/Web/out ./

ENTRYPOINT ["dotnet", "Web.dll"]
```

### <a name="troubleshooting-docker-problems"></a><span data-ttu-id="b2ccc-370">Docker 問題疑難排解</span><span class="sxs-lookup"><span data-stu-id="b2ccc-370">Troubleshooting Docker problems</span></span>

<span data-ttu-id="b2ccc-371">一旦您執行容器化應用程式，它會一直執行到您停止為止。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-371">Once you run the containerized application, it continues to run until you stop it.</span></span> <span data-ttu-id="b2ccc-372">您可以使用 `docker ps` 命令，來檢視哪些容器正在執行。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-372">You can view which containers are running with the `docker ps` command.</span></span> <span data-ttu-id="b2ccc-373">您可以透過使用 `docker stop` 命令並指定容器識別碼，來停止執行容器。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-373">You can stop a running container by using the `docker stop` command and specifying the container ID.</span></span>

<span data-ttu-id="b2ccc-374">請注意，執行 Docker 容器可能會繫結至您嘗試在開發環境中使用的連接埠。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-374">Note that running Docker containers may be bound to ports you might otherwise try to use in your development environment.</span></span> <span data-ttu-id="b2ccc-375">如果您嘗試使用與執行 Docker 容器相同的連接埠來執行或偵錯應用程式，您會收到錯誤，指出伺服器無法繫結至該連接埠。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-375">If you try to run or debug an application using the same port as a running Docker container, you'll get an error stating that the server can't bind to that port.</span></span> <span data-ttu-id="b2ccc-376">同樣地，停止容器應能解決此問題。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-376">Once again, stopping the container should resolve the issue.</span></span>

<span data-ttu-id="b2ccc-377">如果您想要使用 Visual Studio 將 Docker 支援新增到應用程式，請確認這樣做時，Docker Desktop 正在執行。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-377">If you want to add Docker support to your application using Visual Studio, make sure Docker Desktop is running when you do so.</span></span> <span data-ttu-id="b2ccc-378">如果 Docker Desktop 在您啟動精靈時並未執行，精靈將無法正確執行。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-378">The wizard won't run correctly if Docker Desktop isn't running when you start the wizard.</span></span> <span data-ttu-id="b2ccc-379">此外，精靈會檢查您目前的容器選擇，以新增正確的 Docker 支援。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-379">In addition, the wizard examines your current container choice to add the correct Docker support.</span></span> <span data-ttu-id="b2ccc-380">如果您想要新增 Windows 容器的支援，您需要在有執行中 Docker 並已設定 Windows 容器的同時執行精靈。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-380">If you want to add support for Windows Containers, you need to run the wizard while you have Docker Desktop running with Windows Containers configured.</span></span> <span data-ttu-id="b2ccc-381">如果您想要新增 Linux 容器的支援，請在有執行中 Docker 並已設定 Linux 容器的同時執行精靈。</span><span class="sxs-lookup"><span data-stu-id="b2ccc-381">If you want to add support for Linux containers, run the wizard while you have Docker running with Linux containers configured.</span></span>

### <a name="references--common-web-architectures"></a><span data-ttu-id="b2ccc-382">參考資料 - 一般 Web 架構</span><span class="sxs-lookup"><span data-stu-id="b2ccc-382">References – Common web architectures</span></span>

- <span data-ttu-id="b2ccc-383">**Clean Architecture**</span><span class="sxs-lookup"><span data-stu-id="b2ccc-383">**The Clean Architecture**</span></span>  
  <https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html>
- <span data-ttu-id="b2ccc-384">**Onion Architecture**</span><span class="sxs-lookup"><span data-stu-id="b2ccc-384">**The Onion Architecture**</span></span>  
  <https://jeffreypalermo.com/blog/the-onion-architecture-part-1/>
- <span data-ttu-id="b2ccc-385">**存放庫模式**</span><span class="sxs-lookup"><span data-stu-id="b2ccc-385">**The Repository Pattern**</span></span>  
  <https://deviq.com/repository-pattern/>
- <span data-ttu-id="b2ccc-386">**清除架構解決方案範本**</span><span class="sxs-lookup"><span data-stu-id="b2ccc-386">**Clean Architecture Solution Template**</span></span>  
  <https://github.com/ardalis/cleanarchitecture>
- <span data-ttu-id="b2ccc-387">**架構微服務電子書**</span><span class="sxs-lookup"><span data-stu-id="b2ccc-387">**Architecting Microservices e-book**</span></span>  
  <https://aka.ms/MicroservicesEbook>
- <span data-ttu-id="b2ccc-388">**DDD (領域驅動設計)**</span><span class="sxs-lookup"><span data-stu-id="b2ccc-388">**DDD (Domain-Driven Design)**</span></span>  
  <https://docs.microsoft.com/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/>

>[!div class="step-by-step"]
><span data-ttu-id="b2ccc-389">[上一個](architectural-principles.md) 
>[下一步](common-client-side-web-technologies.md)</span><span class="sxs-lookup"><span data-stu-id="b2ccc-389">[Previous](architectural-principles.md)
[Next](common-client-side-web-technologies.md)</span></span>
