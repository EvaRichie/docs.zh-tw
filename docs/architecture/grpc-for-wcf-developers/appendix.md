---
title: 附錄-WCF 開發人員的 gRPC
description: 分散式交易及其在新式微服務架構中的實作討論。
ms.date: 09/02/2019
ms.openlocfilehash: f60899463a13e9f740f6ae63150d18eab3069124
ms.sourcegitcommit: 5b475c1855b32cf78d2d1bbb4295e4c236f39464
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 09/24/2020
ms.locfileid: "91165854"
---
# <a name="appendix-a---transactions"></a><span data-ttu-id="68ead-103">附錄 A-交易</span><span class="sxs-lookup"><span data-stu-id="68ead-103">Appendix A - Transactions</span></span>

<span data-ttu-id="68ead-104">Windows Communication Foundation (WCF) 支援分散式交易，可讓您跨多個服務執行不可部分完成的作業。</span><span class="sxs-lookup"><span data-stu-id="68ead-104">Windows Communication Foundation (WCF) supports distributed transactions, allowing you to perform atomic operations across multiple services.</span></span> <span data-ttu-id="68ead-105">這項功能是以 [Microsoft Distributed Transaction Coordinator](/previous-versions/windows/desktop/ms684146(v=vs.85))為基礎。</span><span class="sxs-lookup"><span data-stu-id="68ead-105">This functionality is based on the [Microsoft Distributed Transaction Coordinator](/previous-versions/windows/desktop/ms684146(v=vs.85)).</span></span>

<span data-ttu-id="68ead-106">在較新的微服務環境中，無法進行這種類型的自動分散式交易處理。</span><span class="sxs-lookup"><span data-stu-id="68ead-106">In the newer microservices landscape, this type of automated distributed transaction processing isn't possible.</span></span> <span data-ttu-id="68ead-107">牽涉到許多不同的技術，包括關係資料庫、NoSQL 資料存放區，以及訊息系統。</span><span class="sxs-lookup"><span data-stu-id="68ead-107">There are too many different technologies involved, including relational databases, NoSQL data stores, and messaging systems.</span></span> <span data-ttu-id="68ead-108">在單一環境中，也可能會混用作業系統、程式設計語言和架構。</span><span class="sxs-lookup"><span data-stu-id="68ead-108">There might also be a mix of operating systems, programming languages, and frameworks in use in a single environment.</span></span>

<span data-ttu-id="68ead-109">WCF 分散式交易是所謂的 [兩階段認可的實 (2pc) ](https://en.wikipedia.org/wiki/Two-phase_commit_protocol)。</span><span class="sxs-lookup"><span data-stu-id="68ead-109">WCF distributed transaction is an implementation of what is known as a [two-phase commit (2PC)](https://en.wikipedia.org/wiki/Two-phase_commit_protocol).</span></span> <span data-ttu-id="68ead-110">您可以藉由協調服務之間的訊息、在每個服務中建立開啟的交易，以及傳送認可或回復訊息（視成功或失敗而定），以手動方式執行2PC 交易。</span><span class="sxs-lookup"><span data-stu-id="68ead-110">You can implement 2PC transactions manually by coordinating messages across services, creating open transactions within each service, and sending commit or rollback messages, depending upon success or failure.</span></span> <span data-ttu-id="68ead-111">但是，管理2PC 時所牽涉到的複雜性會隨著系統演進而以指數方式增加。</span><span class="sxs-lookup"><span data-stu-id="68ead-111">However, the complexity involved in managing 2PC can increase exponentially as systems evolve.</span></span> <span data-ttu-id="68ead-112">開啟交易會保存可能對效能造成負面影響的資料庫鎖定，或更糟的原因會導致跨服務的鎖死。</span><span class="sxs-lookup"><span data-stu-id="68ead-112">Open transactions hold database locks that can negatively affect performance, or, worse, cause cross-service deadlocks.</span></span>

<span data-ttu-id="68ead-113">可能的話，最好完全避免分散式交易。</span><span class="sxs-lookup"><span data-stu-id="68ead-113">If possible, it's best to avoid distributed transactions altogether.</span></span> <span data-ttu-id="68ead-114">如果有兩個數據專案連結為需要不可部分完成的更新，請考慮使用相同的服務來處理它們。</span><span class="sxs-lookup"><span data-stu-id="68ead-114">If two items of data are so linked as to require atomic updates, consider handling them both with the same service.</span></span> <span data-ttu-id="68ead-115">使用單一要求或訊息將這些不可部分完成的變更套用至該服務。</span><span class="sxs-lookup"><span data-stu-id="68ead-115">Apply those atomic changes by using a single request or message to that service.</span></span>

<span data-ttu-id="68ead-116">如果無法這麼做，則有一個替代方法是使用 [Saga 模式](https://microservices.io/patterns/data/saga.html)。</span><span class="sxs-lookup"><span data-stu-id="68ead-116">If that isn't possible, then one alternative is to use the [Saga pattern](https://microservices.io/patterns/data/saga.html).</span></span> <span data-ttu-id="68ead-117">在 saga 中，更新會依序處理;每次更新成功時，就會觸發下一個更新。</span><span class="sxs-lookup"><span data-stu-id="68ead-117">In a saga, updates are processed sequentially; as each update succeeds, the next one is triggered.</span></span> <span data-ttu-id="68ead-118">這些觸發程式可以從服務傳播至服務，或由 saga 協調器或協調器進行管理。</span><span class="sxs-lookup"><span data-stu-id="68ead-118">These triggers can be propagated from service to service, or managed by a saga coordinator or orchestrator.</span></span> <span data-ttu-id="68ead-119">如果在處理期間的任何時間點更新失敗，已完成其更新的服務會套用特定邏輯以將其還原。</span><span class="sxs-lookup"><span data-stu-id="68ead-119">If an update fails at any point during the process, the services that have already completed their updates apply specific logic to reverse them.</span></span>

<span data-ttu-id="68ead-120">另一個選項是使用網域導向設計 (DDD) 和命令/查詢責任隔離 (CQRS) ，如 [.Net 微服務電子書](../microservices/microservice-ddd-cqrs-patterns/index.md)中所述。</span><span class="sxs-lookup"><span data-stu-id="68ead-120">Another option is to use Domain Driven Design (DDD) and Command/Query Responsibility Segregation (CQRS), as described in the [.NET Microservices e-book](../microservices/microservice-ddd-cqrs-patterns/index.md).</span></span> <span data-ttu-id="68ead-121">尤其是，使用領域事件或 [事件來源](https://martinfowler.com/eaaDev/EventSourcing.html) 有助於確保一致地套用更新（如果不會立即套用）。</span><span class="sxs-lookup"><span data-stu-id="68ead-121">In particular, using domain events or [event sourcing](https://martinfowler.com/eaaDev/EventSourcing.html) can help to ensure that updates are consistently, if not immediately, applied.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="68ead-122">[[上一步]](application-performance-management.md)</span><span class="sxs-lookup"><span data-stu-id="68ead-122">[Previous](application-performance-management.md)</span></span>
