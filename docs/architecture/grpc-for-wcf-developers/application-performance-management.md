---
title: 應用程式效能管理-WCF 開發人員的 gRPC
description: ASP.NET Core gRPC 應用程式的記錄、計量和追蹤。
ms.date: 09/02/2019
ms.openlocfilehash: 8a13d1c4df95768e55c90ac491150bfc78ec2bab
ms.sourcegitcommit: 6d1ae17e60384f3b5953ca7b45ac859ec6d4c3a0
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 11/20/2020
ms.locfileid: "94982338"
---
# <a name="application-performance-management"></a><span data-ttu-id="71aea-103">應用程式效能管理</span><span class="sxs-lookup"><span data-stu-id="71aea-103">Application Performance Management</span></span>

<span data-ttu-id="71aea-104">在 Kubernetes 之類的生產環境中，請務必監視應用程式，以確保它們能以最佳方式執行。</span><span class="sxs-lookup"><span data-stu-id="71aea-104">In production environments like Kubernetes, it's important to monitor applications to ensure they're running optimally.</span></span> <span data-ttu-id="71aea-105">記錄和計量特別重要。</span><span class="sxs-lookup"><span data-stu-id="71aea-105">Logging and metrics are particularly important.</span></span> <span data-ttu-id="71aea-106">ASP.NET Core （包括 gRPC）提供內建支援來產生和記錄管理訊息和計量資料，以及 *追蹤* 資料。</span><span class="sxs-lookup"><span data-stu-id="71aea-106">ASP.NET Core, including gRPC, provides built-in support for producing and managing log messages and metrics data, as well as *tracing* data.</span></span>

## <a name="the-difference-between-logging-and-metrics"></a><span data-ttu-id="71aea-107">記錄與計量之間的差異</span><span class="sxs-lookup"><span data-stu-id="71aea-107">The difference between logging and metrics</span></span>

<span data-ttu-id="71aea-108">*記錄* 涉及記錄系統中發生之事物的詳細資訊的文字訊息。</span><span class="sxs-lookup"><span data-stu-id="71aea-108">*Logging* is concerned with text messages that record detailed information about things that have happened in the system.</span></span> <span data-ttu-id="71aea-109">記錄訊息可能包括例外狀況資料，例如堆疊追蹤，或是提供訊息相關內容的結構化資料。</span><span class="sxs-lookup"><span data-stu-id="71aea-109">Log messages might include exception data, like stack traces, or structured data that provides context about the message.</span></span> <span data-ttu-id="71aea-110">記錄輸出通常會寫入至可搜尋的文字存放區。</span><span class="sxs-lookup"><span data-stu-id="71aea-110">Logging output is commonly written to a searchable text store.</span></span>

<span data-ttu-id="71aea-111">*計量* 指的是在儀表板中使用圖表和圖形來匯總和呈現的數值資料。</span><span class="sxs-lookup"><span data-stu-id="71aea-111">*Metrics* refers to numeric data designed to be aggregated and presented by using charts and graphs in a dashboard.</span></span> <span data-ttu-id="71aea-112">儀表板可讓您查看應用程式的整體健全狀況和效能。</span><span class="sxs-lookup"><span data-stu-id="71aea-112">The dashboard provides a view of the overall health and performance of an application.</span></span> <span data-ttu-id="71aea-113">當超過閾值時，計量資料也可以用來觸發自動警示。</span><span class="sxs-lookup"><span data-stu-id="71aea-113">Metrics data can also be used to trigger automated alerts when a threshold is exceeded.</span></span> <span data-ttu-id="71aea-114">以下是一些計量資料的範例：</span><span class="sxs-lookup"><span data-stu-id="71aea-114">Here are some examples of metrics data:</span></span>

- <span data-ttu-id="71aea-115">處理要求所花費的時間。</span><span class="sxs-lookup"><span data-stu-id="71aea-115">Time taken to process requests.</span></span>
- <span data-ttu-id="71aea-116">服務實例每秒處理的要求數目。</span><span class="sxs-lookup"><span data-stu-id="71aea-116">The number of requests per second being handled by an instance of a service.</span></span>
- <span data-ttu-id="71aea-117">實例上失敗的要求數目。</span><span class="sxs-lookup"><span data-stu-id="71aea-117">The number of failed requests on an instance.</span></span>

## <a name="logging-in-aspnet-core-grpc"></a><span data-ttu-id="71aea-118">ASP.NET Core gRPC 中的記錄</span><span class="sxs-lookup"><span data-stu-id="71aea-118">Logging in ASP.NET Core gRPC</span></span>

<span data-ttu-id="71aea-119">ASP.NET Core 提供記錄的內建支援，格式為「[記錄 NuGet 套件」。](https://www.nuget.org/packages/Microsoft.Extensions.Logging)</span><span class="sxs-lookup"><span data-stu-id="71aea-119">ASP.NET Core provides built-in support for logging, in the form of the [Microsoft.Extensions.Logging](https://www.nuget.org/packages/Microsoft.Extensions.Logging) NuGet package.</span></span> <span data-ttu-id="71aea-120">此程式庫的核心部分隨附于 Web SDK，因此不需要手動安裝。</span><span class="sxs-lookup"><span data-stu-id="71aea-120">The core parts of this library are included with the Web SDK, so there's no need to install it manually.</span></span> <span data-ttu-id="71aea-121">根據預設，記錄訊息會寫入至標準輸出 (「主控台」 ) 和任何附加的偵錯工具。</span><span class="sxs-lookup"><span data-stu-id="71aea-121">By default, log messages are written to the standard output (the "console") and to any attached debugger.</span></span> <span data-ttu-id="71aea-122">若要將記錄寫入持續性的外部資料存放區，您可能需要匯入 [選擇性的記錄接收套件](/aspnet/core/fundamentals/logging/?view=aspnetcore-3.0#third-party-logging-providers)。</span><span class="sxs-lookup"><span data-stu-id="71aea-122">To write logs to persistent external data stores, you might need to import [optional logging sink packages](/aspnet/core/fundamentals/logging/?view=aspnetcore-3.0#third-party-logging-providers).</span></span>

<span data-ttu-id="71aea-123">ASP.NET Core gRPC 架構會將詳細的診斷記錄訊息寫入此記錄架構中，因此可以處理和儲存應用程式本身的訊息。</span><span class="sxs-lookup"><span data-stu-id="71aea-123">The ASP.NET Core gRPC framework writes detailed diagnostic logging messages to this logging framework, so they can be processed and stored along with your application's own messages.</span></span>

### <a name="produce-log-messages"></a><span data-ttu-id="71aea-124">產生記錄訊息</span><span class="sxs-lookup"><span data-stu-id="71aea-124">Produce log messages</span></span>

<span data-ttu-id="71aea-125">記錄延伸模組會自動向 ASP.NET Core 的相依性插入系統註冊，因此您可以在 gRPC 服務類型上指定記錄器做為函式參數。</span><span class="sxs-lookup"><span data-stu-id="71aea-125">The logging extension is automatically registered with ASP.NET Core's dependency injection system, so you can specify loggers as a constructor parameter on gRPC service types.</span></span>

```csharp
public class StockData : Stocks.StocksBase
{
    private readonly ILogger<StockData> _logger;

    public StockData(ILogger<StockData> logger)
    {
        _logger = logger;
    }
}
```

<span data-ttu-id="71aea-126">許多記錄訊息（例如要求和例外狀況）都是由 ASP.NET Core 和 gRPC framework 元件所提供。</span><span class="sxs-lookup"><span data-stu-id="71aea-126">Many log messages, such as requests and exceptions, are provided by the ASP.NET Core and gRPC framework components.</span></span> <span data-ttu-id="71aea-127">新增您自己的記錄檔訊息，以提供有關應用程式邏輯的詳細資料和內容，而不是較低層級的考慮。</span><span class="sxs-lookup"><span data-stu-id="71aea-127">Add your own log messages to provide detail and context about application logic, rather than lower-level concerns.</span></span>

<span data-ttu-id="71aea-128">如需撰寫記錄訊息和可用記錄接收和目標的詳細資訊，請參閱  [.Net Core 和 ASP.NET Core 中的記錄](/aspnet/core/fundamentals/logging/)。</span><span class="sxs-lookup"><span data-stu-id="71aea-128">For more information about writing log messages and available logging sinks and targets, see  [Logging in .NET Core and ASP.NET Core](/aspnet/core/fundamentals/logging/).</span></span>

## <a name="metrics-in-aspnet-core-grpc"></a><span data-ttu-id="71aea-129">ASP.NET Core gRPC 中的計量</span><span class="sxs-lookup"><span data-stu-id="71aea-129">Metrics in ASP.NET Core gRPC</span></span>

<span data-ttu-id="71aea-130">.NET Core 執行時間提供一組用來發出和觀察計量的元件。</span><span class="sxs-lookup"><span data-stu-id="71aea-130">The .NET Core runtime provides a set of components for emitting and observing metrics.</span></span> <span data-ttu-id="71aea-131">這些包括 Api <xref:System.Diagnostics.Tracing.EventSource> ，例如和 <xref:System.Diagnostics.Tracing.EventCounter> 類別。</span><span class="sxs-lookup"><span data-stu-id="71aea-131">These include APIs such as the <xref:System.Diagnostics.Tracing.EventSource> and <xref:System.Diagnostics.Tracing.EventCounter> classes.</span></span> <span data-ttu-id="71aea-132">這些 Api 可以發出可供外部進程取用的基本數值資料，例如 [dotnet 計數器全域工具](../../core/diagnostics/dotnet-counters.md)或 Windows 事件追蹤。</span><span class="sxs-lookup"><span data-stu-id="71aea-132">These APIs can emit basic numeric data that can be consumed by external processes, like the [dotnet-counters global tool](../../core/diagnostics/dotnet-counters.md), or Event Tracing for Windows.</span></span> <span data-ttu-id="71aea-133">如需 `EventCounter` 在您自己的程式碼中使用的詳細資訊，請參閱 [EventCounter 簡介](https://github.com/dotnet/runtime/blob/master/src/libraries/System.Diagnostics.Tracing/documentation/EventCounterTutorial.md)。</span><span class="sxs-lookup"><span data-stu-id="71aea-133">For more information about using `EventCounter` in your own code, see [EventCounter introduction](https://github.com/dotnet/runtime/blob/master/src/libraries/System.Diagnostics.Tracing/documentation/EventCounterTutorial.md).</span></span>

<span data-ttu-id="71aea-134">如需更先進的計量，以及將計量資料寫入更廣泛的資料存放區，您可以嘗試一個稱為「 [應用程式計量](https://www.app-metrics.io)」的開放原始碼專案。</span><span class="sxs-lookup"><span data-stu-id="71aea-134">For more advanced metrics and for writing metric data to a wider range of data stores, you might try an open-source project called [App Metrics](https://www.app-metrics.io).</span></span> <span data-ttu-id="71aea-135">此程式庫套件提供一組廣泛的類型來檢測您的程式碼。</span><span class="sxs-lookup"><span data-stu-id="71aea-135">This suite of libraries provides an extensive set of types to instrument your code.</span></span> <span data-ttu-id="71aea-136">它也提供封裝，以將計量寫入不同類型的目標，包括時間序列資料庫，例如 Prometheus 和 InfluxDB，以及 [Application Insights](/azure/azure-monitor/app/app-insights-overview)。</span><span class="sxs-lookup"><span data-stu-id="71aea-136">It also offers packages to write metrics to different kinds of targets that include time-series databases, such as Prometheus and InfluxDB, and [Application Insights](/azure/azure-monitor/app/app-insights-overview).</span></span> <span data-ttu-id="71aea-137">[AspNetCore Mvc](https://www.nuget.org/packages/App.Metrics.AspNetCore.Mvc/) NuGet 套件甚至會新增一組完整的基本計量，這些計量會透過與 ASP.NET Core framework 的整合自動產生。</span><span class="sxs-lookup"><span data-stu-id="71aea-137">The [App.Metrics.AspNetCore.Mvc](https://www.nuget.org/packages/App.Metrics.AspNetCore.Mvc/) NuGet package even adds a comprehensive set of basic metrics that are automatically generated via integration with the ASP.NET Core framework.</span></span> <span data-ttu-id="71aea-138">專案網站提供的 [範本](https://www.app-metrics.io/samples/grafana/) 可讓您使用 [Grafana](https://grafana.com/) 視覺效果平臺來顯示這些計量。</span><span class="sxs-lookup"><span data-stu-id="71aea-138">The project website provides [templates](https://www.app-metrics.io/samples/grafana/) for displaying those metrics with the [Grafana](https://grafana.com/) visualization platform.</span></span>

### <a name="produce-metrics"></a><span data-ttu-id="71aea-139">產生計量</span><span class="sxs-lookup"><span data-stu-id="71aea-139">Produce metrics</span></span>

<span data-ttu-id="71aea-140">大部分的計量平臺都支援下列類型：</span><span class="sxs-lookup"><span data-stu-id="71aea-140">Most metrics platforms support the following types:</span></span>

| <span data-ttu-id="71aea-141">度量類型</span><span class="sxs-lookup"><span data-stu-id="71aea-141">Metric type</span></span> | <span data-ttu-id="71aea-142">說明</span><span class="sxs-lookup"><span data-stu-id="71aea-142">Description</span></span> |
| ----------- | ----------- |
| <span data-ttu-id="71aea-143">計數器</span><span class="sxs-lookup"><span data-stu-id="71aea-143">Counter</span></span>     | <span data-ttu-id="71aea-144">追蹤發生某件事的頻率，例如要求和錯誤。</span><span class="sxs-lookup"><span data-stu-id="71aea-144">Tracks how often something happens, such as requests and errors.</span></span> |
| <span data-ttu-id="71aea-145">量測計</span><span class="sxs-lookup"><span data-stu-id="71aea-145">Gauge</span></span>       | <span data-ttu-id="71aea-146">記錄會隨著時間而變更的單一值，例如使用中的連接。</span><span class="sxs-lookup"><span data-stu-id="71aea-146">Records a single value that changes over time, such as active connections.</span></span> |
| <span data-ttu-id="71aea-147">長條圖</span><span class="sxs-lookup"><span data-stu-id="71aea-147">Histogram</span></span>   | <span data-ttu-id="71aea-148">測量任意限制之間值的分佈。</span><span class="sxs-lookup"><span data-stu-id="71aea-148">Measures a distribution of values across arbitrary limits.</span></span> <span data-ttu-id="71aea-149">例如，長條圖可以追蹤資料集大小、計算有多少包含 <10 筆記錄、包含的11-100 記錄數目、包含的101-1000 記錄數量，以及包含的 >1000 記錄數目。</span><span class="sxs-lookup"><span data-stu-id="71aea-149">For example, a histogram can track dataset size, counting how many contained <10 records, how many contained 11-100 records, how many contained 101-1000 records, and how many contained >1000 records.</span></span> |
| <span data-ttu-id="71aea-150">計量</span><span class="sxs-lookup"><span data-stu-id="71aea-150">Meter</span></span>       | <span data-ttu-id="71aea-151">測量事件在不同時間範圍內發生的速率。</span><span class="sxs-lookup"><span data-stu-id="71aea-151">Measures the rate at which an event occurs in various time spans.</span></span> |
| <span data-ttu-id="71aea-152">計時器</span><span class="sxs-lookup"><span data-stu-id="71aea-152">Timer</span></span>       | <span data-ttu-id="71aea-153">追蹤事件的持續時間和發生的速率，儲存為長條圖。</span><span class="sxs-lookup"><span data-stu-id="71aea-153">Tracks the duration of events and the rate at which it occurs, stored as a histogram.</span></span> |

<span data-ttu-id="71aea-154">藉由使用 *應用程式計量*，您可以透過相依性 `IMetrics` 插入取得介面，也可以用來記錄 gRPC 服務的任何計量。</span><span class="sxs-lookup"><span data-stu-id="71aea-154">By using *App Metrics*, an `IMetrics` interface can be obtained via dependency injection, and used to record any of these metrics for a gRPC service.</span></span> <span data-ttu-id="71aea-155">下列範例會示範如何計算一 `Get` 段時間內所提出的要求數目：</span><span class="sxs-lookup"><span data-stu-id="71aea-155">The following example shows how to count the number of `Get` requests made over time:</span></span>

```csharp
public class StockData : Stocks.StocksBase
{
    private static readonly CounterOptions GetRequestCounter = new CounterOptions
    {
        Name = "StockData_Get_Requests",
        MeasurementUnit = Unit.Calls
    };

    private readonly IStockRepository _repository;
    private readonly IMetrics _metrics;

    public StockData(IStockRepository repository, IMetrics metrics)
    {
        _repository = repository;
        _metrics = metrics;
    }

    public override async Task<GetResponse> Get(GetRequest request, ServerCallContext context)
    {
        _metrics.Measure.Counter.Increment(GetRequestCounter);

        // Serve request...
    }
}
```

### <a name="store-and-visualize-metrics-data"></a><span data-ttu-id="71aea-156">儲存和視覺化度量資料</span><span class="sxs-lookup"><span data-stu-id="71aea-156">Store and visualize metrics data</span></span>

<span data-ttu-id="71aea-157">儲存度量資料的最佳方式是在 *時間序列資料庫* 中，這是專門用來記錄以時間戳記標記之數值資料數列的特殊資料存放區。</span><span class="sxs-lookup"><span data-stu-id="71aea-157">The best way to store metrics data is in a *time-series database*, a specialized data store designed to record numerical data series marked with timestamps.</span></span> <span data-ttu-id="71aea-158">這些資料庫中最受歡迎的 [Prometheus](https://prometheus.io/) 和 [InfluxDB](https://www.influxdata.com/products/influxdb-overview/)。</span><span class="sxs-lookup"><span data-stu-id="71aea-158">The most popular of these databases are [Prometheus](https://prometheus.io/) and [InfluxDB](https://www.influxdata.com/products/influxdb-overview/).</span></span> <span data-ttu-id="71aea-159">Microsoft Azure 也會透過 [Azure 監視器](/azure/azure-monitor/overview) 服務提供專用的計量儲存體。</span><span class="sxs-lookup"><span data-stu-id="71aea-159">Microsoft Azure also provides dedicated metrics storage through the [Azure Monitor](/azure/azure-monitor/overview) service.</span></span>

<span data-ttu-id="71aea-160">將計量資料視覺化的目前進入解決方案是 [Grafana](https://grafana.com)，可與各種不同的儲存提供者搭配運作。</span><span class="sxs-lookup"><span data-stu-id="71aea-160">The current go-to solution for visualizing metrics data is [Grafana](https://grafana.com), which works with a wide range of storage providers.</span></span> <span data-ttu-id="71aea-161">下圖顯示範例 Grafana 儀表板，此儀表板會顯示執行 StockData 範例之 Linkerd 服務網格中的計量：</span><span class="sxs-lookup"><span data-stu-id="71aea-161">The following image shows an example Grafana dashboard that displays metrics from the Linkerd service mesh running the StockData sample:</span></span>

![Grafana 儀表板的螢幕擷取畫面](media/application-performance-management/grafana-screenshot.png)

### <a name="metrics-based-alerting"></a><span data-ttu-id="71aea-163">以計量為基礎的警示</span><span class="sxs-lookup"><span data-stu-id="71aea-163">Metrics-based alerting</span></span>

<span data-ttu-id="71aea-164">計量資料的數值本質表示它最適合用來驅動警示系統，在某個值超出某些定義的容錯範圍時通知開發人員或支援工程師。</span><span class="sxs-lookup"><span data-stu-id="71aea-164">The numerical nature of metrics data means that it's ideally suited to drive alerting systems, notifying developers or support engineers when a value falls outside of some defined tolerance.</span></span> <span data-ttu-id="71aea-165">已提及的平臺可透過各種選項（包括電子郵件、文字訊息或儀表板內視覺效果）提供警示的支援。</span><span class="sxs-lookup"><span data-stu-id="71aea-165">The platforms already mentioned all provide support for alerting via a range of options, including emails, text messages, or in-dashboard visualizations.</span></span>

## <a name="distributed-tracing"></a><span data-ttu-id="71aea-166">分散式追蹤</span><span class="sxs-lookup"><span data-stu-id="71aea-166">Distributed tracing</span></span>

<span data-ttu-id="71aea-167">分散式追蹤是在監視中的最新開發，零件出現了從增加使用微服務和分散式架構。</span><span class="sxs-lookup"><span data-stu-id="71aea-167">Distributed tracing is a relatively recent development in monitoring, which has arisen from the increasing use of microservices and distributed architectures.</span></span> <span data-ttu-id="71aea-168">用戶端瀏覽器、應用程式或裝置的單一要求可以細分為許多步驟和子要求，並牽涉到跨網路使用許多服務。</span><span class="sxs-lookup"><span data-stu-id="71aea-168">A single request from a client browser, application, or device can be broken down into many steps and sub-requests, and involve the use of many services across a network.</span></span> <span data-ttu-id="71aea-169">這使得記錄訊息和計量與觸發這些訊息的特定要求很難相互關聯。</span><span class="sxs-lookup"><span data-stu-id="71aea-169">This makes it difficult to correlate log messages and metrics with the specific request that triggered them.</span></span> <span data-ttu-id="71aea-170">分散式追蹤會對要求套用識別碼，這可讓記錄和計量與特定作業相互關聯。</span><span class="sxs-lookup"><span data-stu-id="71aea-170">Distributed tracing applies identifiers to requests, and this allows logs and metrics to be correlated with a particular operation.</span></span> <span data-ttu-id="71aea-171">這類似于 [WCF 的端對端追蹤](../../framework/wcf/diagnostics/tracing/end-to-end-tracing.md)，但會在多個平臺上套用。</span><span class="sxs-lookup"><span data-stu-id="71aea-171">This is similar to [WCF's end-to-end tracing](../../framework/wcf/diagnostics/tracing/end-to-end-tracing.md), but it's applied across multiple platforms.</span></span>

<span data-ttu-id="71aea-172">分散式追蹤迅速成長，而且開始標準化。</span><span class="sxs-lookup"><span data-stu-id="71aea-172">Distributed tracing has grown quickly in popularity and is beginning to standardize.</span></span> <span data-ttu-id="71aea-173">雲端原生運算基礎建立了 [開放的追蹤標準](https://opentracing.io)，並嘗試提供廠商中立的程式庫，以搭配 [JAEGER](https://www.jaegertracing.io/) 和 [彈性 APM](https://www.elastic.co/products/apm)等後端運作。</span><span class="sxs-lookup"><span data-stu-id="71aea-173">The Cloud Native Computing Foundation created the [Open Tracing standard](https://opentracing.io), attempting to provide vendor-neutral libraries for working with back ends like [Jaeger](https://www.jaegertracing.io/) and [Elastic APM](https://www.elastic.co/products/apm).</span></span> <span data-ttu-id="71aea-174">同時，Google 建立了 [OpenCensus 專案](https://opencensus.io/) 來解決一組相同的問題。</span><span class="sxs-lookup"><span data-stu-id="71aea-174">At the same time, Google created the [OpenCensus project](https://opencensus.io/) to address the same set of problems.</span></span> <span data-ttu-id="71aea-175">這兩個專案會合並到新的專案 [OpenTelemetry](https://opentelemetry.io)中，其目標是未來的產業標準。</span><span class="sxs-lookup"><span data-stu-id="71aea-175">These two projects are merging into a new project, [OpenTelemetry](https://opentelemetry.io), which aims to be the industry standard of the future.</span></span>

### <a name="how-distributed-tracing-works"></a><span data-ttu-id="71aea-176">分散式追蹤的運作方式</span><span class="sxs-lookup"><span data-stu-id="71aea-176">How distributed tracing works</span></span>

<span data-ttu-id="71aea-177">分散式追蹤是以 *範圍* 的概念為基礎：命名為的計時作業，屬於單一 *追蹤* 的一部分，這可能牽涉到在系統的多個節點上處理。</span><span class="sxs-lookup"><span data-stu-id="71aea-177">Distributed tracing is based on the concept of *spans*: named, timed operations that are part of a single *trace*, which can involve processing on multiple nodes of a system.</span></span> <span data-ttu-id="71aea-178">起始新的作業時，會使用唯一識別碼來建立追蹤。</span><span class="sxs-lookup"><span data-stu-id="71aea-178">When a new operation is initiated, a trace is created with a unique identifier.</span></span> <span data-ttu-id="71aea-179">針對每個子作業，會使用自己的識別碼和追蹤識別碼來建立範圍。</span><span class="sxs-lookup"><span data-stu-id="71aea-179">For each sub-operation, a span is created with its own identifier and trace identifier.</span></span> <span data-ttu-id="71aea-180">當要求在系統中傳遞時，不同的元件可以建立包含其 *父系* 識別碼的 *子* 範圍。</span><span class="sxs-lookup"><span data-stu-id="71aea-180">As the request passes around the system, various components can create *child* spans that include the identifier of their *parent*.</span></span> <span data-ttu-id="71aea-181">範圍具有 *內容*，其中包含追蹤和 span 識別碼，以及索引鍵/值組形式的有用資料 (稱為「 *行李*) 」。</span><span class="sxs-lookup"><span data-stu-id="71aea-181">A span has a *context*, which contains the trace and span identifiers, as well as useful data in the form of key and value pairs (called *baggage*).</span></span>

### <a name="distributed-tracing-with-diagnosticsource"></a><span data-ttu-id="71aea-182">分散式追蹤 `DiagnosticSource`</span><span class="sxs-lookup"><span data-stu-id="71aea-182">Distributed tracing with `DiagnosticSource`</span></span>

<span data-ttu-id="71aea-183">.NET Core 的內部模組可適當地對應到分散式追蹤和範圍： [DiagnosticSource](https://github.com/dotnet/runtime/blob/master/src/libraries/System.Diagnostics.DiagnosticSource/src/DiagnosticSourceUsersGuide.md#diagnosticsource-users-guide)。</span><span class="sxs-lookup"><span data-stu-id="71aea-183">.NET Core has an internal module that maps well to distributed traces and spans: [DiagnosticSource](https://github.com/dotnet/runtime/blob/master/src/libraries/System.Diagnostics.DiagnosticSource/src/DiagnosticSourceUsersGuide.md#diagnosticsource-users-guide).</span></span> <span data-ttu-id="71aea-184">除了提供簡單的方法，讓您在進程內產生和取用診斷， `DiagnosticSource` 模組也有 *活動* 的概念。</span><span class="sxs-lookup"><span data-stu-id="71aea-184">As well as providing a simple way to produce and consume diagnostics within a process, the `DiagnosticSource` module has the concept of an *activity*.</span></span> <span data-ttu-id="71aea-185">活動實際上是分散式追蹤或追蹤內的範圍。</span><span class="sxs-lookup"><span data-stu-id="71aea-185">An activity is effectively an implementation of a distributed trace, or a span within a trace.</span></span> <span data-ttu-id="71aea-186">模組的內部負責處理父子式活動，包括配置識別碼。</span><span class="sxs-lookup"><span data-stu-id="71aea-186">The internals of the module take care of parent/child activities, including allocating identifiers.</span></span> <span data-ttu-id="71aea-187">如需使用此類型的詳細資訊 `Activity` ，請參閱 [GitHub 上的活動使用者指南](https://github.com/dotnet/runtime/blob/master/src/libraries/System.Diagnostics.DiagnosticSource/src/ActivityUserGuide.md#activity-user-guide)。</span><span class="sxs-lookup"><span data-stu-id="71aea-187">For more information about using the `Activity` type, see the [Activity User Guide on GitHub](https://github.com/dotnet/runtime/blob/master/src/libraries/System.Diagnostics.DiagnosticSource/src/ActivityUserGuide.md#activity-user-guide).</span></span>

<span data-ttu-id="71aea-188">因為 `DiagnosticSource` 是核心架構的一部分，所以有數個核心元件支援。</span><span class="sxs-lookup"><span data-stu-id="71aea-188">Because `DiagnosticSource` is a part of the core framework, it's supported by several core components.</span></span> <span data-ttu-id="71aea-189">這些包括 <xref:System.Net.Http.HttpClient> 、Entity Framework Core 和 ASP.NET Core，包括 gRPC 架構中的明確支援。</span><span class="sxs-lookup"><span data-stu-id="71aea-189">These include <xref:System.Net.Http.HttpClient>, Entity Framework Core, and ASP.NET Core, including explicit support in the gRPC framework.</span></span> <span data-ttu-id="71aea-190">當 ASP.NET Core 收到要求時，它會檢查符合 [W3C 追蹤內容](https://www.w3.org/TR/trace-context) 標準的一對 HTTP 標頭。</span><span class="sxs-lookup"><span data-stu-id="71aea-190">When ASP.NET Core receives a request, it checks for a pair of HTTP headers matching the [W3C Trace Context](https://www.w3.org/TR/trace-context) standard.</span></span> <span data-ttu-id="71aea-191">如果找不到標頭，則會使用標頭中的識別值和內容來啟動活動。</span><span class="sxs-lookup"><span data-stu-id="71aea-191">If the headers are found, an activity is started by using the identity values and context from the headers.</span></span> <span data-ttu-id="71aea-192">如果找不到標頭，則會使用符合標準格式之產生的識別值啟動活動。</span><span class="sxs-lookup"><span data-stu-id="71aea-192">If no headers are found, an activity is started with generated identity values that match the standard format.</span></span> <span data-ttu-id="71aea-193">在此活動存留期間，架構或應用程式程式碼所產生的任何診斷都可以使用追蹤和 span 識別碼標記。</span><span class="sxs-lookup"><span data-stu-id="71aea-193">Any diagnostics generated by the framework or by application code during the lifetime of this activity can be tagged with the trace and span identifiers.</span></span> <span data-ttu-id="71aea-194">`HttpClient`此支援會藉由檢查每個要求的目前活動，以及自動將追蹤標頭新增至傳出要求，來進一步延伸此功能。</span><span class="sxs-lookup"><span data-stu-id="71aea-194">The `HttpClient` support extends this further by checking for a current activity on every request, and automatically adding the trace headers to the outgoing request.</span></span>

<span data-ttu-id="71aea-195">ASP.NET Core gRPC 用戶端和伺服器程式庫包含對和的明確支援 `DiagnosticSource` `Activity` ，並會自動建立活動並套用和使用標頭資訊。</span><span class="sxs-lookup"><span data-stu-id="71aea-195">The ASP.NET Core gRPC client and server libraries include explicit support for `DiagnosticSource` and `Activity`, and create activities and apply and use header information automatically.</span></span>

> [!NOTE]
> <span data-ttu-id="71aea-196">只有當接聽程式取用診斷資訊時，才會發生這種情況。</span><span class="sxs-lookup"><span data-stu-id="71aea-196">All of this happens only if a listener is consuming the diagnostic information.</span></span> <span data-ttu-id="71aea-197">如果沒有任何接聽程式，則不會寫入任何診斷，也不會建立任何活動。</span><span class="sxs-lookup"><span data-stu-id="71aea-197">If there's no listener, no diagnostics are written and no activities are created.</span></span>

### <a name="add-your-own-diagnosticsource-and-activity"></a><span data-ttu-id="71aea-198">新增您自己 `DiagnosticSource` 的 `Activity`</span><span class="sxs-lookup"><span data-stu-id="71aea-198">Add your own `DiagnosticSource` and `Activity`</span></span>

<span data-ttu-id="71aea-199">若要在您的應用程式程式碼中新增您自己的診斷或建立明確的範圍，請參閱 [DiagnosticSource 使用者指南](https://github.com/dotnet/runtime/blob/master/src/libraries/System.Diagnostics.DiagnosticSource/src/DiagnosticSourceUsersGuide.md#instrumenting-with-diagnosticsourcediagnosticlistener) 和 [活動使用者指南](https://github.com/dotnet/runtime/blob/master/src/libraries/System.Diagnostics.DiagnosticSource/src/ActivityUserGuide.md#activity-usage)。</span><span class="sxs-lookup"><span data-stu-id="71aea-199">To add your own diagnostics or create explicit spans within your application code, see the [DiagnosticSource User Guide](https://github.com/dotnet/runtime/blob/master/src/libraries/System.Diagnostics.DiagnosticSource/src/DiagnosticSourceUsersGuide.md#instrumenting-with-diagnosticsourcediagnosticlistener) and [Activity User Guide](https://github.com/dotnet/runtime/blob/master/src/libraries/System.Diagnostics.DiagnosticSource/src/ActivityUserGuide.md#activity-usage).</span></span>

### <a name="store-distributed-trace-data"></a><span data-ttu-id="71aea-200">儲存分散式追蹤資料</span><span class="sxs-lookup"><span data-stu-id="71aea-200">Store distributed trace data</span></span>

<span data-ttu-id="71aea-201">在撰寫本文時，OpenTelemetry 專案仍處於早期階段，而且只有 Alpha 品質套件適用于 .NET 應用程式。</span><span class="sxs-lookup"><span data-stu-id="71aea-201">At the time of writing, the OpenTelemetry project is still in the early stages, and only alpha-quality packages are available for .NET applications.</span></span> <span data-ttu-id="71aea-202">OpenTracing 專案目前提供更成熟的程式庫。</span><span class="sxs-lookup"><span data-stu-id="71aea-202">The OpenTracing project currently offers more mature libraries.</span></span>

<span data-ttu-id="71aea-203">下一節將說明 OpenTracing API。</span><span class="sxs-lookup"><span data-stu-id="71aea-203">The OpenTracing API is described in the following section.</span></span> <span data-ttu-id="71aea-204">如果您想要改為在應用程式中使用 OpenTelemetry API，請參閱 GitHub 上的 [OpenTelemetry .NET SDK 存放庫](https://github.com/open-telemetry/opentelemetry-dotnet) 。</span><span class="sxs-lookup"><span data-stu-id="71aea-204">If you want to use the OpenTelemetry API in your application instead, refer to the [OpenTelemetry .NET SDK repository](https://github.com/open-telemetry/opentelemetry-dotnet) on GitHub.</span></span>

#### <a name="use-the-opentracing-package-to-store-distributed-trace-data"></a><span data-ttu-id="71aea-205">使用 OpenTracing 封裝來儲存分散式追蹤資料</span><span class="sxs-lookup"><span data-stu-id="71aea-205">Use the OpenTracing package to store distributed trace data</span></span>

<span data-ttu-id="71aea-206">[OpenTracing NuGet 套件](https://www.nuget.org/packages/OpenTracing/)支援所有符合 OpenTracing 規範的後端 (，可獨立于) 之外使用 `DiagnosticSource` 。</span><span class="sxs-lookup"><span data-stu-id="71aea-206">The [OpenTracing NuGet package](https://www.nuget.org/packages/OpenTracing/) supports all OpenTracing-compliant back ends (which can be used independently of `DiagnosticSource`).</span></span> <span data-ttu-id="71aea-207">OpenTracing API 投稿專案中還有另一個套件， [OpenTracing. Contrib. NetCore](https://www.nuget.org/packages/OpenTracing.Contrib.NetCore/)。</span><span class="sxs-lookup"><span data-stu-id="71aea-207">There's an additional package from the OpenTracing API Contributions project, [OpenTracing.Contrib.NetCore](https://www.nuget.org/packages/OpenTracing.Contrib.NetCore/).</span></span> <span data-ttu-id="71aea-208">此封裝會新增接聽程式 `DiagnosticSource` ，並自動將事件和活動寫入至後端。</span><span class="sxs-lookup"><span data-stu-id="71aea-208">This package adds a `DiagnosticSource` listener, and writes events and activities to a back end automatically.</span></span> <span data-ttu-id="71aea-209">啟用此封裝的方式就像從 NuGet 安裝它一樣簡單，並且將它新增為類別中的服務 `Startup` 。</span><span class="sxs-lookup"><span data-stu-id="71aea-209">Enabling this package is as simple as installing it from NuGet and adding it as a service in your `Startup` class.</span></span>

```csharp
public class Startup
{
    public void ConfigureServices(IServiceCollection services)
    {
        services.AddOpenTracing();
    }
}
```

<span data-ttu-id="71aea-210">OpenTracing 套件是一個抽象層，因此它需要後端的特定執行。</span><span class="sxs-lookup"><span data-stu-id="71aea-210">The OpenTracing package is an abstraction layer, and as such it requires implementation specific to the back end.</span></span> <span data-ttu-id="71aea-211">下列開放原始碼後端可使用 OpenTracing API。</span><span class="sxs-lookup"><span data-stu-id="71aea-211">OpenTracing API implementations are available for the following open source back ends.</span></span>

| <span data-ttu-id="71aea-212">名稱</span><span class="sxs-lookup"><span data-stu-id="71aea-212">Name</span></span> | <span data-ttu-id="71aea-213">Package</span><span class="sxs-lookup"><span data-stu-id="71aea-213">Package</span></span> | <span data-ttu-id="71aea-214">網站</span><span class="sxs-lookup"><span data-stu-id="71aea-214">Website</span></span> |
| ---- | ------- | -------- |
| <span data-ttu-id="71aea-215">Jaeger</span><span class="sxs-lookup"><span data-stu-id="71aea-215">Jaeger</span></span> | [<span data-ttu-id="71aea-216">Jaeger</span><span class="sxs-lookup"><span data-stu-id="71aea-216">Jaeger</span></span>](https://www.nuget.org/packages/Jaeger/) | [<span data-ttu-id="71aea-217">jaegertracing.io</span><span class="sxs-lookup"><span data-stu-id="71aea-217">jaegertracing.io</span></span>](https://jaegertracing.io) |
| <span data-ttu-id="71aea-218">彈性 APM</span><span class="sxs-lookup"><span data-stu-id="71aea-218">Elastic APM</span></span> | [<span data-ttu-id="71aea-219">NetCoreAll</span><span class="sxs-lookup"><span data-stu-id="71aea-219">Elastic.Apm.NetCoreAll</span></span>](https://www.nuget.org/packages/Elastic.Apm.NetCoreAll/) | [<span data-ttu-id="71aea-220">elastic.co/products/apm</span><span class="sxs-lookup"><span data-stu-id="71aea-220">elastic.co/products/apm</span></span>](https://www.elastic.co/products/apm) |

<span data-ttu-id="71aea-221">如需適用于 .NET 的 OpenTracing API 的詳細資訊，請參閱 GitHub 上的 [OpenTracing For c #](https://github.com/opentracing/opentracing-csharp) 和 [OpenTracing Contrib c #/.NET Core](https://github.com/opentracing-contrib/csharp-netcore) 存放庫。</span><span class="sxs-lookup"><span data-stu-id="71aea-221">For more information on the OpenTracing API for .NET, see the [OpenTracing for C#](https://github.com/opentracing/opentracing-csharp) and the [OpenTracing Contrib C#/.NET Core](https://github.com/opentracing-contrib/csharp-netcore) repositories on GitHub.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="71aea-222">[上一個](load-balancing.md) 
>[下一步](appendix.md)</span><span class="sxs-lookup"><span data-stu-id="71aea-222">[Previous](load-balancing.md)
[Next](appendix.md)</span></span>
