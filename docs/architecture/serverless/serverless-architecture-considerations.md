---
title: 無伺服器架構考慮-無伺服器應用程式
description: 瞭解架構無伺服器應用程式的挑戰，從狀態管理和持續性儲存體到調整、記錄、追蹤和診斷。
author: JEREMYLIKNESS
ms.author: jeliknes
ms.date: 04/06/2020
ms.openlocfilehash: fbbb0c38cea58902124743fb99f9ab31b3d09be9
ms.sourcegitcommit: 5b475c1855b32cf78d2d1bbb4295e4c236f39464
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 09/24/2020
ms.locfileid: "91171646"
---
# <a name="serverless-architecture-considerations"></a><span data-ttu-id="abc3d-103">無伺服器架構考量</span><span class="sxs-lookup"><span data-stu-id="abc3d-103">Serverless architecture considerations</span></span>

<span data-ttu-id="abc3d-104">採用無伺服器架構會帶來一些挑戰。</span><span class="sxs-lookup"><span data-stu-id="abc3d-104">Adopting a serverless architecture does come with certain challenges.</span></span> <span data-ttu-id="abc3d-105">本節將探討一些較常見的考慮事項。</span><span class="sxs-lookup"><span data-stu-id="abc3d-105">This section explores some of the more common considerations to be aware of.</span></span> <span data-ttu-id="abc3d-106">所有這些挑戰都有解決方案。</span><span class="sxs-lookup"><span data-stu-id="abc3d-106">All of these challenges have solutions.</span></span> <span data-ttu-id="abc3d-107">就像所有的架構選項一樣，最好在仔細考慮優缺點之後，才進行無伺服器的決策。</span><span class="sxs-lookup"><span data-stu-id="abc3d-107">As with all architecture choices, the decision to go serverless should be made only after carefully considering the pros and cons.</span></span> <span data-ttu-id="abc3d-108">視應用程式的需求而定，您可能會決定無伺服器的實作為特定元件的正確解決方案。</span><span class="sxs-lookup"><span data-stu-id="abc3d-108">Depending on the needs of your application, you may decide a serverless implementation isn't the right solution for certain components.</span></span>

## <a name="managing-state"></a><span data-ttu-id="abc3d-109">管理狀態</span><span class="sxs-lookup"><span data-stu-id="abc3d-109">Managing state</span></span>

<span data-ttu-id="abc3d-110">無伺服器函式（如同一般微服務）預設為無狀態。</span><span class="sxs-lookup"><span data-stu-id="abc3d-110">Serverless functions, as with microservices in general, are stateless by default.</span></span> <span data-ttu-id="abc3d-111">避免狀態可讓無伺服器成為暫時的、向外延展，並在沒有中央失敗點的情況下提供復原功能。</span><span class="sxs-lookup"><span data-stu-id="abc3d-111">Avoiding state enables serverless to be ephemeral, to scale out, and to provide resiliency without a central point of failure.</span></span> <span data-ttu-id="abc3d-112">在某些情況下，商務程式需要狀態。</span><span class="sxs-lookup"><span data-stu-id="abc3d-112">In some circumstances, business processes require state.</span></span> <span data-ttu-id="abc3d-113">如果您的進程需要狀態，您有兩個選項。</span><span class="sxs-lookup"><span data-stu-id="abc3d-113">If your process requires state, you have two options.</span></span> <span data-ttu-id="abc3d-114">您可以採用無伺服器的模型，或與提供狀態的個別服務互動。</span><span class="sxs-lookup"><span data-stu-id="abc3d-114">You can adopt a model other than serverless, or interact with a separate service that provides state.</span></span> <span data-ttu-id="abc3d-115">新增狀態可能會讓解決方案變得複雜，並使其更難調整，而且可能會建立單一失敗點。</span><span class="sxs-lookup"><span data-stu-id="abc3d-115">Adding state can complicate the solution and make it harder to scale, and potentially create a single point of failure.</span></span> <span data-ttu-id="abc3d-116">請仔細考慮您的函式是否確實需要狀態。</span><span class="sxs-lookup"><span data-stu-id="abc3d-116">Carefully consider whether your function absolutely requires state.</span></span> <span data-ttu-id="abc3d-117">如果答案為「是」，請判斷使用無伺服器來執行它是否仍然合理。</span><span class="sxs-lookup"><span data-stu-id="abc3d-117">If the answer is "yes," determine whether it still makes sense to implement it with serverless.</span></span>

<span data-ttu-id="abc3d-118">有幾個解決方案可採用狀態，而不會危及無伺服器的優點。</span><span class="sxs-lookup"><span data-stu-id="abc3d-118">There are several solutions to adopt state without compromising the benefits of serverless.</span></span> <span data-ttu-id="abc3d-119">一些更受歡迎的解決方案包括：</span><span class="sxs-lookup"><span data-stu-id="abc3d-119">Some of the more popular solutions include:</span></span>

- <span data-ttu-id="abc3d-120">使用暫存資料存放區或分散式快取，例如 Redis</span><span class="sxs-lookup"><span data-stu-id="abc3d-120">Use a temporary data store or distributed cache, like Redis</span></span>
- <span data-ttu-id="abc3d-121">在資料庫中儲存狀態，例如 SQL 或 CosmosDB</span><span class="sxs-lookup"><span data-stu-id="abc3d-121">Store state in a database, like SQL or CosmosDB</span></span>
- <span data-ttu-id="abc3d-122">透過工作流程引擎（例如[持久](/azure/azure-functions/durable/durable-functions-overview)函式）處理狀態</span><span class="sxs-lookup"><span data-stu-id="abc3d-122">Handle state through a workflow engine like [durable functions](/azure/azure-functions/durable/durable-functions-overview)</span></span>

<span data-ttu-id="abc3d-123">重點是，您應該留意到您正在考慮使用無伺服器來執行的進程內的任何狀態管理需求。</span><span class="sxs-lookup"><span data-stu-id="abc3d-123">The bottom line is that you should be aware of the need for any state management within processes you're considering to implement with serverless.</span></span>

## <a name="long-running-processes"></a><span data-ttu-id="abc3d-124">長時間執行的進程</span><span class="sxs-lookup"><span data-stu-id="abc3d-124">Long-running processes</span></span>

<span data-ttu-id="abc3d-125">無伺服器的許多優點都依賴處理常式是暫時的。</span><span class="sxs-lookup"><span data-stu-id="abc3d-125">Many benefits of serverless rely on the processes being ephemeral.</span></span> <span data-ttu-id="abc3d-126">縮短執行時間可讓無伺服器提供者更容易釋出資源，因為函式會在主機上結束和共用功能。</span><span class="sxs-lookup"><span data-stu-id="abc3d-126">Short run times make it easier for the serverless provider to free up resources as functions end and share functions across hosts.</span></span> <span data-ttu-id="abc3d-127">大部分的雲端提供者會限制您的函式執行的總時間（大約10分鐘）。</span><span class="sxs-lookup"><span data-stu-id="abc3d-127">Most cloud providers limit the total time your function can run to around 10 minutes.</span></span> <span data-ttu-id="abc3d-128">如果您的程式可能需要較長的時間，您可以考慮替代的執行方式。</span><span class="sxs-lookup"><span data-stu-id="abc3d-128">If your process may take longer, you might consider an alternative implementation.</span></span>

<span data-ttu-id="abc3d-129">有一些例外狀況和解決方案。</span><span class="sxs-lookup"><span data-stu-id="abc3d-129">There are a few exceptions and solutions.</span></span> <span data-ttu-id="abc3d-130">其中一個解決方法是將您的程式分成較小的元件，這些元件會個別花費較少的時間執行。</span><span class="sxs-lookup"><span data-stu-id="abc3d-130">One solution may be to break your process into smaller components that individually take less time to run.</span></span> <span data-ttu-id="abc3d-131">如果您的程式因為相依性而執行時間很長，您也可以考慮使用長期函式等解決方案的非同步工作流程。</span><span class="sxs-lookup"><span data-stu-id="abc3d-131">If your process runs long because of dependencies, you can also consider an asynchronous workflow using a solution like durable functions.</span></span> <span data-ttu-id="abc3d-132">長期函式會在等候外部進程完成時，暫停和維護進程的狀態。</span><span class="sxs-lookup"><span data-stu-id="abc3d-132">Durable functions pause and maintain the state of your process while it's waiting on an external process to finish.</span></span> <span data-ttu-id="abc3d-133">非同步處理可減少實際處理常式的執行時間。</span><span class="sxs-lookup"><span data-stu-id="abc3d-133">Asynchronous handling reduces the time the actual process runs.</span></span>

## <a name="startup-time"></a><span data-ttu-id="abc3d-134">啟動時間</span><span class="sxs-lookup"><span data-stu-id="abc3d-134">Startup time</span></span>

<span data-ttu-id="abc3d-135">無伺服器實施的一個潛在問題是啟動時間。</span><span class="sxs-lookup"><span data-stu-id="abc3d-135">One potential concern with serverless implementations is startup time.</span></span> <span data-ttu-id="abc3d-136">為了節省資源，許多無伺服器的提供者會依需求建立基礎結構。</span><span class="sxs-lookup"><span data-stu-id="abc3d-136">To conserve resources, many serverless providers create infrastructure "on demand."</span></span> <span data-ttu-id="abc3d-137">在一段時間後觸發無伺服器函式時，您可能需要建立或重新開機該函式所裝載的資源。</span><span class="sxs-lookup"><span data-stu-id="abc3d-137">When a serverless function is triggered after a period of time, the resources to host the function may need to be created or restarted.</span></span> <span data-ttu-id="abc3d-138">在某些情況下，冷啟動可能會導致延遲幾秒鐘。</span><span class="sxs-lookup"><span data-stu-id="abc3d-138">In some situations, cold starts may result in delays of several seconds.</span></span> <span data-ttu-id="abc3d-139">啟動時間會因提供者和服務等級而異。</span><span class="sxs-lookup"><span data-stu-id="abc3d-139">Startup time varies across providers and service levels.</span></span> <span data-ttu-id="abc3d-140">如果您要將應用程式的成功率降至最低，有幾種方法可以解決啟動時間。</span><span class="sxs-lookup"><span data-stu-id="abc3d-140">There are a few approaches to address startup time if it's important to minimize for the success of the app.</span></span>

- <span data-ttu-id="abc3d-141">有些提供者可讓使用者支付保證基礎結構為「永遠開啟」的服務等級。</span><span class="sxs-lookup"><span data-stu-id="abc3d-141">Some providers allow users to pay for service levels that guarantee infrastructure is "always on".</span></span>
- <span data-ttu-id="abc3d-142">實行保持運作機制 (ping 端點以保持「喚醒」 ) 。</span><span class="sxs-lookup"><span data-stu-id="abc3d-142">Implement a keep-alive mechanism (ping the endpoint to keep it "awake").</span></span>
- <span data-ttu-id="abc3d-143">使用 Kubernetes 搭配容器化函式方法來使用協調流程， (主機已在執行中，因此啟動新實例非常快速) 。</span><span class="sxs-lookup"><span data-stu-id="abc3d-143">Use orchestration like Kubernetes with a containerized function approach (the host is already running so spinning up new instances is extremely fast).</span></span>

## <a name="database-updates-and-migrations"></a><span data-ttu-id="abc3d-144">資料庫更新和遷移</span><span class="sxs-lookup"><span data-stu-id="abc3d-144">Database updates and migrations</span></span>

<span data-ttu-id="abc3d-145">無伺服器程式碼的優點是您可以發行新的函式，而不需要重新部署整個應用程式。</span><span class="sxs-lookup"><span data-stu-id="abc3d-145">An advantage of serverless code is that you can release new functions without having to redeploy the entire application.</span></span> <span data-ttu-id="abc3d-146">當涉及關係資料庫時，這種優點可能會成為缺點。</span><span class="sxs-lookup"><span data-stu-id="abc3d-146">This advantage can become a disadvantage when there's a relational database involved.</span></span> <span data-ttu-id="abc3d-147">資料庫架構的變更很難與無伺服器更新進行同步處理。</span><span class="sxs-lookup"><span data-stu-id="abc3d-147">Changes to database schemas are difficult to synchronize with serverless updates.</span></span> <span data-ttu-id="abc3d-148">當發生問題且變更必須回復時，就會造成其他挑戰。</span><span class="sxs-lookup"><span data-stu-id="abc3d-148">Additional challenges are posed when things go wrong and the changes must be rolled back.</span></span> <span data-ttu-id="abc3d-149">資料完整性是微服務和無伺服器函式的最佳作法的其中一個原因，就是它們擁有自己的資料。</span><span class="sxs-lookup"><span data-stu-id="abc3d-149">Data integrity is one reason that a best practice for microservices and serverless functions is that they own their own data.</span></span> <span data-ttu-id="abc3d-150">您可以將變更部署為計算和資料的單一單位。</span><span class="sxs-lookup"><span data-stu-id="abc3d-150">It is possible to deploy changes as a single unit of compute and data.</span></span> <span data-ttu-id="abc3d-151">實際的情況是，許多舊版系統都具有必須與無伺服器架構協調的大型後端資料庫。</span><span class="sxs-lookup"><span data-stu-id="abc3d-151">The reality is that many legacy systems feature a large back-end database that must be reconciled with the serverless architecture.</span></span>

<span data-ttu-id="abc3d-152">解決架構版本設定的常用方法是永遠不要修改現有的屬性和資料行，而是改為加入新的資訊。</span><span class="sxs-lookup"><span data-stu-id="abc3d-152">A popular approach to solve schema versioning is to never modify existing properties and columns, but instead add new information.</span></span> <span data-ttu-id="abc3d-153">例如，請考慮將待辦事項清單中的布林值「已完成」旗標移至「完成日期」。</span><span class="sxs-lookup"><span data-stu-id="abc3d-153">For example, consider a change to move from a Boolean "completed" flag for a todo list to a "completed date."</span></span> <span data-ttu-id="abc3d-154">資料庫變更將不會移除舊的欄位，而是：</span><span class="sxs-lookup"><span data-stu-id="abc3d-154">Instead of removing the old field, the database change will:</span></span>

1. <span data-ttu-id="abc3d-155">新增 [完成日期] 欄位。</span><span class="sxs-lookup"><span data-stu-id="abc3d-155">Add a new "completed date" field.</span></span>
1. <span data-ttu-id="abc3d-156">將「已完成」布林值欄位轉換為計算的函式，此函式會評估已完成的日期是否在目前日期之後。</span><span class="sxs-lookup"><span data-stu-id="abc3d-156">Transform the "completed" Boolean field to a computed function that evaluates whether the completed date is after the current date.</span></span>
1. <span data-ttu-id="abc3d-157">加入觸發程式，將完成的布林值設定為 true 時，將完成日期設定為目前日期。</span><span class="sxs-lookup"><span data-stu-id="abc3d-157">Add a trigger to set the completed date to the current date when the completed Boolean is set to true.</span></span>

<span data-ttu-id="abc3d-158">變更順序可確保舊版程式碼會繼續以「原樣」執行，而較新的無伺服器函式可以利用新的欄位。</span><span class="sxs-lookup"><span data-stu-id="abc3d-158">The sequence of changes ensures that legacy code continues to run "as is" while newer serverless functions can take advantage of the new field.</span></span>

<span data-ttu-id="abc3d-159">如需無伺服器架構中資料的詳細資訊，請參閱 [分散式資料管理的挑戰和解決方案](../microservices/architect-microservice-container-applications/distributed-data-management.md)。</span><span class="sxs-lookup"><span data-stu-id="abc3d-159">For more information about data in serverless architectures, see [Challenges and solutions for distributed data management](../microservices/architect-microservice-container-applications/distributed-data-management.md).</span></span>

## <a name="scaling"></a><span data-ttu-id="abc3d-160">調整大小</span><span class="sxs-lookup"><span data-stu-id="abc3d-160">Scaling</span></span>

<span data-ttu-id="abc3d-161">無伺服器表示「無伺服器」，這是常見的誤解。</span><span class="sxs-lookup"><span data-stu-id="abc3d-161">It's a common misconception that serverless means "no server."</span></span> <span data-ttu-id="abc3d-162">其實是「較少的伺服器」。</span><span class="sxs-lookup"><span data-stu-id="abc3d-162">It's in fact "less server."</span></span> <span data-ttu-id="abc3d-163">其實有一個支援基礎結構，就是了解調整規模的時機。</span><span class="sxs-lookup"><span data-stu-id="abc3d-163">The fact there is a backing infrastructure is important to understand when it comes to scaling.</span></span> <span data-ttu-id="abc3d-164">大部分的無伺服器平臺都會提供一組控制項，以處理事件密度增加時基礎結構的調整方式。</span><span class="sxs-lookup"><span data-stu-id="abc3d-164">Most serverless platforms provide a set of controls to handle how the infrastructure should scale when event density increases.</span></span> <span data-ttu-id="abc3d-165">您可以從各種不同的選項中進行選擇，但您的策略可能會因函式而異。</span><span class="sxs-lookup"><span data-stu-id="abc3d-165">You can choose from a variety of options, but your strategy may vary depending on the function.</span></span> <span data-ttu-id="abc3d-166">此外，函式通常會在相關主機下執行，讓相同主機上的函式具有相同的調整選項。</span><span class="sxs-lookup"><span data-stu-id="abc3d-166">Furthermore, functions are typically run under a related host, so that functions on the same host have the same scale options.</span></span> <span data-ttu-id="abc3d-167">因此，您必須根據規模需求來組織和制定哪些函式裝載在一起。</span><span class="sxs-lookup"><span data-stu-id="abc3d-167">Therefore it is necessary to organize and strategize which functions are hosted together based on scale requirements.</span></span>

<span data-ttu-id="abc3d-168">規則通常會指定如何擴大 (增加主機資源) 和向外延展 (根據不同的參數增加主控制項) 實例的數目。</span><span class="sxs-lookup"><span data-stu-id="abc3d-168">Rules often specify how to scale-up (increase the host resources) and scale-out (increase the number of host instances) based on varying parameters.</span></span> <span data-ttu-id="abc3d-169">調整的觸發程式可能包括排程、要求率、CPU 使用率和記憶體使用量。</span><span class="sxs-lookup"><span data-stu-id="abc3d-169">Triggers for scales may include schedule, request rates, CPU utilization, and memory usage.</span></span> <span data-ttu-id="abc3d-170">效能較高通常會產生較高的成本。</span><span class="sxs-lookup"><span data-stu-id="abc3d-170">Higher performance often comes at a greater cost.</span></span> <span data-ttu-id="abc3d-171">當要求速率突然增加時，耗用成本較低的方法可能無法迅速調整。</span><span class="sxs-lookup"><span data-stu-id="abc3d-171">The less expensive, consumption-based approaches may not scale as quickly when the request rate suddenly increases.</span></span> <span data-ttu-id="abc3d-172">支付前「保險成本」與「隨用隨付」的費用，以及因需求突然增加而產生的風險較慢的取捨。</span><span class="sxs-lookup"><span data-stu-id="abc3d-172">There is a trade-off between paying up front "insurance cost" versus paying strictly "as you go" and risking slower responses due to sudden increases in demand.</span></span>

## <a name="monitoring-tracing-and-logging"></a><span data-ttu-id="abc3d-173">監視、追蹤和記錄</span><span class="sxs-lookup"><span data-stu-id="abc3d-173">Monitoring, tracing, and logging</span></span>

<span data-ttu-id="abc3d-174">DevOps 經常被忽略的層面是在部署應用程式之後進行監視。</span><span class="sxs-lookup"><span data-stu-id="abc3d-174">An often overlooked aspect of DevOps is monitoring applications once deployed.</span></span> <span data-ttu-id="abc3d-175">請務必具有監視無伺服器函式的策略。</span><span class="sxs-lookup"><span data-stu-id="abc3d-175">It's important to have a strategy for monitoring serverless functions.</span></span> <span data-ttu-id="abc3d-176">最大的挑戰通常是相互關聯，或在使用者呼叫多個函式作為相同互動的一部分時辨識。</span><span class="sxs-lookup"><span data-stu-id="abc3d-176">The biggest challenge is often correlation, or recognizing when a user calls multiple functions as part of the same interaction.</span></span> <span data-ttu-id="abc3d-177">大部分的無伺服器平臺允許可匯入至協力廠商工具的主控台記錄。</span><span class="sxs-lookup"><span data-stu-id="abc3d-177">Most serverless platforms allow console logging that can be imported into third-party tools.</span></span> <span data-ttu-id="abc3d-178">另外還有一些選項可自動收集遙測、產生和追蹤相互關聯識別碼，以及監視特定動作以提供詳細的深入解析。</span><span class="sxs-lookup"><span data-stu-id="abc3d-178">There are also options to automate collection of telemetry, generate and track correlation IDs, and monitor specific actions to provide detailed insights.</span></span> <span data-ttu-id="abc3d-179">Azure 提供先進的 [Application Insights 平臺](/azure/azure-functions/functions-monitoring) 來進行監視和分析。</span><span class="sxs-lookup"><span data-stu-id="abc3d-179">Azure provides the advanced [Application Insights platform](/azure/azure-functions/functions-monitoring) for monitoring and analytics.</span></span>

## <a name="inter-service-dependencies"></a><span data-ttu-id="abc3d-180">服務間相依性</span><span class="sxs-lookup"><span data-stu-id="abc3d-180">Inter-service dependencies</span></span>

<span data-ttu-id="abc3d-181">無伺服器架構可能包含依賴其他函式的函式。</span><span class="sxs-lookup"><span data-stu-id="abc3d-181">A serverless architecture may include functions that rely on other functions.</span></span> <span data-ttu-id="abc3d-182">事實上，在無伺服器架構中，有多個服務在互動或分散式交易中彼此呼叫彼此的情況並不常見。</span><span class="sxs-lookup"><span data-stu-id="abc3d-182">In fact, it isn't uncommon in a serverless architecture to have multiple services call each other as part of an interaction or distributed transaction.</span></span> <span data-ttu-id="abc3d-183">為了避免強式結合，建議服務不會直接參考彼此。</span><span class="sxs-lookup"><span data-stu-id="abc3d-183">To avoid strong coupling, it's recommended that services don't reference each other directly.</span></span> <span data-ttu-id="abc3d-184">當服務的端點需要變更時，直接參考可能會導致主要重構。</span><span class="sxs-lookup"><span data-stu-id="abc3d-184">When the endpoint for a service needs to change, direct references could result in major refactoring.</span></span> <span data-ttu-id="abc3d-185">建議的解決方案是提供服務探索機制（例如登錄），為要求類型提供適當的結束點。</span><span class="sxs-lookup"><span data-stu-id="abc3d-185">A suggested solution is to provide a service discovery mechanism, such as a registry, that provides the appropriate end point for a request type.</span></span> <span data-ttu-id="abc3d-186">另一個解決方案是利用訊息服務（例如佇列或主題）來進行服務之間的通訊。</span><span class="sxs-lookup"><span data-stu-id="abc3d-186">Another solution is to leverage messaging services like queues or topics for communication between services.</span></span>

## <a name="managing-failure-and-providing-resiliency"></a><span data-ttu-id="abc3d-187">管理失敗並提供復原功能</span><span class="sxs-lookup"><span data-stu-id="abc3d-187">Managing failure and providing resiliency</span></span>

<span data-ttu-id="abc3d-188">也請務必考慮 *斷路器模式*：如果基於某些原因，服務會繼續失敗，建議您不要重複呼叫該服務。</span><span class="sxs-lookup"><span data-stu-id="abc3d-188">It's also important to consider the *circuit-breaker pattern*: If, for some reason, a service continues to fail, it isn't advisable to call that service repeatedly.</span></span> <span data-ttu-id="abc3d-189">相反地，會呼叫替代服務或傳回訊息，直到相依服務的健全狀況重新建立為止。</span><span class="sxs-lookup"><span data-stu-id="abc3d-189">Instead, an alternative service is called or a message returned until the health of the dependent service is re-established.</span></span> <span data-ttu-id="abc3d-190">無伺服器架構需要考慮解決和管理服務間相依性的策略。</span><span class="sxs-lookup"><span data-stu-id="abc3d-190">The serverless architecture needs to take into account the strategy for resolving and managing inter-service dependencies.</span></span>

<span data-ttu-id="abc3d-191">若要繼續斷路器模式，服務必須具有容錯能力和彈性。</span><span class="sxs-lookup"><span data-stu-id="abc3d-191">To continue the circuit-breaker pattern, services need to be fault tolerant and resilient.</span></span> <span data-ttu-id="abc3d-192">容錯指的是，即使在遇到未預期的例外狀況或無效狀態之後，您的應用程式仍可繼續執行的功能。</span><span class="sxs-lookup"><span data-stu-id="abc3d-192">Fault tolerance refers to the ability of your application to continue running even after unexpected exceptions or invalid states are encountered.</span></span> <span data-ttu-id="abc3d-193">容錯通常是程式碼本身的函式，以及其撰寫方式來處理例外狀況。</span><span class="sxs-lookup"><span data-stu-id="abc3d-193">Fault tolerance is typically a function of the code itself and how it's written to handle exceptions.</span></span> <span data-ttu-id="abc3d-194">復原是指應用程式從失敗中復原的能力。</span><span class="sxs-lookup"><span data-stu-id="abc3d-194">Resiliency refers to how capable the app is at recovering from failures.</span></span> <span data-ttu-id="abc3d-195">復原通常是由無伺服器平臺所管理。</span><span class="sxs-lookup"><span data-stu-id="abc3d-195">Resiliency is often managed by the serverless platform.</span></span> <span data-ttu-id="abc3d-196">當現有的無伺服器函式實例失敗時，該平臺應該能夠啟動新的無伺服器函式實例。</span><span class="sxs-lookup"><span data-stu-id="abc3d-196">The platform should be able to spin up a new serverless function instance when the existing one fails.</span></span> <span data-ttu-id="abc3d-197">在每個新實例失敗時，平臺也應該有足夠的智慧，以停止啟動新的實例。</span><span class="sxs-lookup"><span data-stu-id="abc3d-197">The platform should also be intelligent enough to stop spinning up new instances when every new instance fails.</span></span>

<span data-ttu-id="abc3d-198">如需詳細資訊，請參閱 [執行斷路器模式](../microservices/implement-resilient-applications/implement-circuit-breaker-pattern.md)。</span><span class="sxs-lookup"><span data-stu-id="abc3d-198">For more information, see [Implementing the Circuit Breaker pattern](../microservices/implement-resilient-applications/implement-circuit-breaker-pattern.md).</span></span>

## <a name="versioning-and-greenblue-deployments"></a><span data-ttu-id="abc3d-199">版本控制和綠色/藍色部署</span><span class="sxs-lookup"><span data-stu-id="abc3d-199">Versioning and green/blue deployments</span></span>

<span data-ttu-id="abc3d-200">無伺服器的主要優點是能夠升級特定功能，而不需要重新部署整個應用程式。</span><span class="sxs-lookup"><span data-stu-id="abc3d-200">A major benefit of serverless is the ability to upgrade a specific function without having to redeploy the entire application.</span></span> <span data-ttu-id="abc3d-201">若要成功升級，必須將函式設為版本，以便將呼叫它們的服務路由至正確的程式碼版本。</span><span class="sxs-lookup"><span data-stu-id="abc3d-201">For upgrades to be successful, functions must be versioned so that services calling them are routed to the correct version of code.</span></span> <span data-ttu-id="abc3d-202">部署新版本的策略也很重要。</span><span class="sxs-lookup"><span data-stu-id="abc3d-202">A strategy for deploying new versions is also important.</span></span> <span data-ttu-id="abc3d-203">常見的方法是使用「綠色/藍色部署」。</span><span class="sxs-lookup"><span data-stu-id="abc3d-203">A common approach is to use "green/blue deployments."</span></span> <span data-ttu-id="abc3d-204">綠色部署是目前的函式。</span><span class="sxs-lookup"><span data-stu-id="abc3d-204">The green deployment is the current function.</span></span> <span data-ttu-id="abc3d-205">新的「藍色」版本會部署到生產環境並經過測試。</span><span class="sxs-lookup"><span data-stu-id="abc3d-205">A new "blue" version is deployed to production and tested.</span></span> <span data-ttu-id="abc3d-206">測試通過時，會交換綠色和藍色版本，讓新版本上線。</span><span class="sxs-lookup"><span data-stu-id="abc3d-206">When testing passes, the green and blue versions are swapped so the new version comes live.</span></span> <span data-ttu-id="abc3d-207">如果遇到任何問題，可以將它們交換回來。</span><span class="sxs-lookup"><span data-stu-id="abc3d-207">If any issues are encountered, they can be swapped back.</span></span> <span data-ttu-id="abc3d-208">支援版本控制和綠色/藍色部署需要結合撰寫這些函式來容納版本變更，以及使用無伺服器平臺來處理部署。</span><span class="sxs-lookup"><span data-stu-id="abc3d-208">Supporting versioning and green/blue deployments requires a combination of authoring the functions to accommodate version changes and working with the serverless platform to handle deployments.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="abc3d-209">[上一個](serverless-architecture.md) 
>[下一步](serverless-design-examples.md)</span><span class="sxs-lookup"><span data-stu-id="abc3d-209">[Previous](serverless-architecture.md)
[Next](serverless-design-examples.md)</span></span>
