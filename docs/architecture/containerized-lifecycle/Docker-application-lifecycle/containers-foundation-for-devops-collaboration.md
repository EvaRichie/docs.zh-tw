---
title: 作為 DevOps 共同作業基礎的容器
description: 了解容器用以簡化 DevOps 的重要角色。
ms.date: 08/06/2020
ms.openlocfilehash: af28c1add8b2e6befbd2f3e6ae9fe707ccc5b106
ms.sourcegitcommit: ef50c99928183a0bba75e07b9f22895cd4c480f8
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/07/2020
ms.locfileid: "87916020"
---
# <a name="containers-as-the-foundation-for-devops-collaboration"></a>作為 DevOps 共同作業基礎的容器

依據容器和 Docker 技術的本質，開發人員可以輕鬆地與 IT 營運及生產環境共用其軟體和相依性時，同時消除一般「它在我的電腦上運行」的藉口。 容器可解決不同環境之間的應用程式衝突。 容器和 Docker 間接地將人員和 IT 營運更緊密地結合在一起，使其能夠輕鬆且有效率地共同作業。 採用容器工作流程可為許多客戶提供他們所尋求，但之前必須透過更複雜發行和建置管線組態實作的 DevOps 持續性。 容器會簡化 DevOps 中的建置/測試/部署管線。

![此圖顯示 Docker 應用程式生命週期的擁有權。](./media/containers-foundation-for-devops-collaboration/persona-workloads-docker-container-lifecycle.png)

**圖2-1。** 容器化 Docker 應用程式生命週期中每個「角色」的主要工作負載

透過 Docker 容器，開發人員擁有容器的內容 (應用程式和服務，以及對架構和元件的相依性)，以及容器和服務作為服務集合所組成應用程式一起運作的方式。 多個容器的交互相依性定義在 `docker-compose.yml` 檔案 (也可以稱為「部署資訊清單」**) 中。 同時，IT 營運小組 (IT 專業人員和管理人員) 可以專注在生產環境的管理；基礎結構、延展性、監視；以及最終確保應用程式正確傳遞給終端使用者，而不需要知道各種容器的內容。 因此，「容器」這個名稱可聯想到真實世界運送容器的比喻。 所以，容器內容擁有者不需要考慮運送容器的方式，運輸公司會將容器從其源點運輸至其目的地，而不需要知道或在意內容。 透過類似方式，開發人員可以建立並擁有 Docker 容器的內容，而不需要顧慮「傳輸」機制。

在圖 2-1 的左側支柱部分，開發人員使用適用於 Windows 或 Mac 的 Docker，在本機的 Docker 容器中撰寫及執行程式碼。 他們透過使用 Dockerfile 來定義程式碼的作業環境，該 Dockerfile 會指定要執行的基底作業系統，以及將其程式碼建置成 Docker 映像的建置步驟。 開發人員定義一或多個映像如何使用上述的 `docker-compose.yml` 檔案部署資訊清單來交互操作。 當他們完成其本機開發時，就會將其應用程式程式碼加上 Docker 組態檔推送至他們選擇的程式碼存放庫 (也就是 Git 存放庫)。

DevOps 支柱部分使用程式碼存放庫中提供的 Dockerfile 定義組建 – 持續整合 (CI) 管線。 CI 系統會從選取的 Docker 登錄中提取基底容器映像，並為應用程式建置自訂的 Docker 映像。 接著會驗證這些映像，並將其推送至用於部署到多個環境的 Docker 登錄。

在右側的支柱部分，營運小組管理生產環境中部署的應用程式和基礎結構，同時監視該環境和應用程式，讓他們能夠將有關如何改善應用程式的意見反應和見解提供給開發小組。 容器應用程式通常會使用像是[Kubernetes](https://kubernetes.io/)的容器協調器在生產環境中執行，其中通常會使用[Helm 圖表](https://helm.sh/)來設定部署單位，而不是 docker 撰寫的檔案。

兩個小組正透過提供關注點分離作為協議的基礎平台 (Docker 容器) 進行共同作業，同時大幅改善兩個小組在應用程式生命週期中的共同作業。 開發人員擁有容器內容、其作業環境和容器交互相依性，而營運小組會採用建置的映像以及資訊清單，並在其協調流程系統中加以執行。

## <a name="challenges-in-the-application-life-cycle-when-using-docker"></a>使用 Docker 時，應用程式生命週期中的挑戰。

將在未來幾年中增加容器化應用程式的數目有許多原因，其中之一是根據微服務建立應用程式。

過去15年來，web 服務的使用已經是數千個應用程式的基礎，而且可能在幾年之後，您會發現在 Docker 容器上執行的微服務應用程式也會發生相同的情況。

另外值得一提的是，您也可以將 Docker 容器用於整合型應用程式，且仍然可以獲得大部分的 Docker 優點。 容器不僅僅以微服務為目標。

使用 Docker 容器化和微服務會為您組織的開發過程帶來新挑戰；因此，您需要紮實策略來維護生產系統上執行的許多容器和微服務。 最後，企業應用程式會在生產環境中執行數百或數千個容器/執行個體。

當使用 DevOps 工具時，這些挑戰會建立新的需求，因此您必須在 DevOps 活動中定義新的流程，並尋找下列問題類型的解答：

- 我可以使用哪些工具來進行開發、CI/CD、管理和作業？

- 公司要如何管理在生產環境中執行之容器的錯誤？

- 我們要如何以最短停機時間變更軟體在生產環境中的部分？

- 我們要如何調整和監視我們的生產系統？

- 我們該如何在發行管線中包含容器的測試和部署？

- 我們要如何在 Microsoft Azure 中針對容器使用開放原始碼工具/平台？

如果您可以回答所有這些問題，就表示您充分準備好將您的應用程式 (現有或新的應用程式) 移到 Docker 容器。

## <a name="introduction-to-a-generic-end-to-end-docker-application-life-cycle-workflow"></a>泛型端對端 Docker 應用程式生命週期工作流程簡介

圖 2-2 呈現更詳細的 Docker 應用程式生命週期工作流程，這個執行個體將聚焦於特定的 DevOps 活動和資產。

![此圖顯示 Docker 應用程式的一般端對端生命週期。](./media/containers-foundation-for-devops-collaboration/generic-end-to-enddpcker-app-life-cycle.png)

**圖2-2。** Docker 容器化應用程式生命週期的高階工作流程

一切都從開發人員開始，該人員會在內部迴圈工作流程中開始撰寫程式碼。 內部迴圈階段可讓開發人員定義將程式碼推送至程式碼存放庫 (例如，Git 之類的原始檔控制系統) 之前發生的所有作業。 在認可它之後，存放庫會觸發持續整合 (CI) 和工作流程的其餘部分。

內部迴圈包含一般的步驟，例如「程式碼」、「執行」、「測試」和「debug」，再加上在本機執行應用程式之前所需的其他步驟。 這是開發人員執行和測試應用程式作為 Docker 容器的流程。 內部迴圈工作流程將會在下列各節中說明。

若要回頭查看端對端工作流程，DevOps 工作流程不只是技術或工具組，而是需要文化發展的思維。 它的人員、處理序及適當工具可讓應用程式生命週期更快速且更容易預測。 採用容器化工作流程的企業通常會重新建構其組織，以表示與容器化工作流程相符的人員和處理序。

實踐 DevOps 可協助小組更快地一同因應競爭壓力，做法是以自動化功能取代容易出錯的手動處理序，進而改善可追蹤性和可重複的工作流程。 透過內部部署與雲端資源組合以及緊密整合的工具，組織也可以更有效率地管理環境和實現成本節約。

針為 Docker 應用程式實作 DevOps 工作流程時，您會看到 Docker 技術幾乎存在於工作流程的每個階段，從在內部迴圈 (撰寫程式碼、執行、偵錯) 工作時的開發環境、建置/測試/CI 階段，以及最後將這些容器部署到預備和生產環境的作業。

改善品質實務有助於在開發週期中及早發現缺失，進而減少修正這些缺失的成本。 透過在映像中包含環境和相依性，並採用在多個環境中部署相同映像的原理，您可以提升擷取環境特定組態的專業領域，讓部署更加可靠。

透過有效檢測 (監視和診斷) 所取得的豐富資料可提供效能問題和使用者行為的見解，進而引導未來的優先順序和投資。

DevOps 應該被視為旅程，而不是目的地。 它應該透過適當範圍的專案逐步實作，而您可以從這些專案展現成就、學習和發展。

## <a name="benefits-of-devops-for-containerized-applications"></a>DevOps 為容器化應用程式提供的優點

以下是 DevOps 穩固工作流程所提供的一些最重要優點：

- 更快且以更高的相容性提供更高品質軟體。

- 更早且以更經濟實惠的方式推動持續改善和調整。

- 提高傳遞和操作軟體所涉及之專案關係人之間的透明度和共同作業。

- 控制成本並更有效地利用佈建的資源，同時將安全性風險降至最低。

- 妥善運用許多現有的 DevOps 投資，包括對開放原始碼的投資。

>[!div class="step-by-step"]
>[上一個](index.md) 
>[下一步](../Microsoft-platform-tools-containerized-apps/index.md)
