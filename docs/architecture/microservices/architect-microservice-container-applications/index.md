---
title: 架構容器與微服務應用程式
description: 架構容器與微服務應用程式不簡單，不可小視。 在此章節中了解核心概念。
ms.date: 01/13/2021
ms.openlocfilehash: d87633b6c5073a9098c34c1192bcca1abad00e5c
ms.sourcegitcommit: a4cecb7389f02c27e412b743f9189bd2a6dea4d6
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/14/2021
ms.locfileid: "98189482"
---
# <a name="architecting-container-and-microservice-based-applications"></a><span data-ttu-id="a3a90-104">架構容器與微服務應用程式</span><span class="sxs-lookup"><span data-stu-id="a3a90-104">Architecting container and microservice-based applications</span></span>

<span data-ttu-id="a3a90-105">*微服務提供絕佳的優點，但也帶來了巨大的新挑戰。微服務架構模式是建立以微服務為基礎的應用程式時的基本要素。*</span><span class="sxs-lookup"><span data-stu-id="a3a90-105">*Microservices offer great benefits but also raise huge new challenges. Microservice architecture patterns are fundamental pillars when creating a microservice-based application.*</span></span>

<span data-ttu-id="a3a90-106">稍早在本指南中，您了解有關容器和 Docker 的基本概念。</span><span class="sxs-lookup"><span data-stu-id="a3a90-106">Earlier in this guide, you learned basic concepts about containers and Docker.</span></span> <span data-ttu-id="a3a90-107">這是開始使用容器所需的最少資訊。</span><span class="sxs-lookup"><span data-stu-id="a3a90-107">That information was the minimum you needed to get started with containers.</span></span> <span data-ttu-id="a3a90-108">即使容器是啟用程式且非常適合微服務，但對微服務架構而言並不是必要的，而且此架構區段中的許多架構概念也可在沒有容器的情況下套用。</span><span class="sxs-lookup"><span data-stu-id="a3a90-108">Even though when containers are enablers and a great fit for microservices, they aren't mandatory for a microservice architecture and many architectural concepts in this architecture section could be applied without containers, too.</span></span> <span data-ttu-id="a3a90-109">不過，由於已介紹過容器的重要性，因此本指南會將重點放在這兩者的交集。</span><span class="sxs-lookup"><span data-stu-id="a3a90-109">However, this guidance focuses on the intersection of both due to the already introduced importance of containers.</span></span>

<span data-ttu-id="a3a90-110">企業應用程式可能很複雜，而且通常是由多個服務而不是單一服務應用程式所組成。</span><span class="sxs-lookup"><span data-stu-id="a3a90-110">Enterprise applications can be complex and are often composed of multiple services instead of a single service-based application.</span></span> <span data-ttu-id="a3a90-111">在這些情況下，您需要瞭解其他架構方法，例如微服務和特定 Domain-Driven 設計 (DDD) 模式加上容器協調流程概念。</span><span class="sxs-lookup"><span data-stu-id="a3a90-111">For those cases, you need to understand other architectural approaches, such as the microservices and certain Domain-Driven Design (DDD) patterns plus container orchestration concepts.</span></span> <span data-ttu-id="a3a90-112">請注意，本章不只描述容器上的微服務，也描述任何容器化應用程式。</span><span class="sxs-lookup"><span data-stu-id="a3a90-112">Note that this chapter describes not just microservices on containers, but any containerized application, as well.</span></span>

## <a name="container-design-principles"></a><span data-ttu-id="a3a90-113">容器設計原則</span><span class="sxs-lookup"><span data-stu-id="a3a90-113">Container design principles</span></span>

<span data-ttu-id="a3a90-114">在容器模型中，容器映像執行個體代表單一處理序。</span><span class="sxs-lookup"><span data-stu-id="a3a90-114">In the container model, a container image instance represents a single process.</span></span> <span data-ttu-id="a3a90-115">藉由將容器映像定義為處理序邊界，您可以建立基本類型，以便用來調整處理序或對它進行批次處理。</span><span class="sxs-lookup"><span data-stu-id="a3a90-115">By defining a container image as a process boundary, you can create primitives that can be used to scale the process or to batch it.</span></span>

<span data-ttu-id="a3a90-116">當您設計容器映像時，您將會在 Dockerfile 中看到 [ENTRYPOINT](https://docs.docker.com/engine/reference/builder/#entrypoint) 定義。</span><span class="sxs-lookup"><span data-stu-id="a3a90-116">When you design a container image, you'll see an [ENTRYPOINT](https://docs.docker.com/engine/reference/builder/#entrypoint) definition in the Dockerfile.</span></span> <span data-ttu-id="a3a90-117">此定義會定義其存留期控制容器存留期的進程。</span><span class="sxs-lookup"><span data-stu-id="a3a90-117">This definition defines the process whose lifetime controls the lifetime of the container.</span></span> <span data-ttu-id="a3a90-118">當處理序完成時，容器生命週期即告結束。</span><span class="sxs-lookup"><span data-stu-id="a3a90-118">When the process completes, the container lifecycle ends.</span></span> <span data-ttu-id="a3a90-119">容器可能代表長時間執行的處理序 (例如網頁伺服器)，但也可能代表短期處理序 (例如之前可能已實作為 Azure [WebJobs](https://github.com/Azure/azure-webjobs-sdk/wiki) 的批次工作)。</span><span class="sxs-lookup"><span data-stu-id="a3a90-119">Containers might represent long-running processes like web servers, but can also represent short-lived processes like batch jobs, which formerly might have been implemented as Azure [WebJobs](https://github.com/Azure/azure-webjobs-sdk/wiki).</span></span>

<span data-ttu-id="a3a90-120">如果處理序失敗，容器會結束並由 Orchestrator 接管。</span><span class="sxs-lookup"><span data-stu-id="a3a90-120">If the process fails, the container ends, and the orchestrator takes over.</span></span> <span data-ttu-id="a3a90-121">如果 Orchestrator 已設定為保留五個執行中的執行個體，且其中一個失敗，Orchestrator 將會建立另一個容器執行個體，來取代失敗的處理序。</span><span class="sxs-lookup"><span data-stu-id="a3a90-121">If the orchestrator was configured to keep five instances running and one fails, the orchestrator will create another container instance to replace the failed process.</span></span> <span data-ttu-id="a3a90-122">在批次工作中，處理序是透過參數來啟動。</span><span class="sxs-lookup"><span data-stu-id="a3a90-122">In a batch job, the process is started with parameters.</span></span> <span data-ttu-id="a3a90-123">當處理序完成時，工作即告完成。</span><span class="sxs-lookup"><span data-stu-id="a3a90-123">When the process completes, the work is complete.</span></span> <span data-ttu-id="a3a90-124">本指引稍後會向下鑽研至協調器。</span><span class="sxs-lookup"><span data-stu-id="a3a90-124">This guidance drills-down on orchestrators, later on.</span></span>

<span data-ttu-id="a3a90-125">您可能發現有時需要在單一容器中執行多個處理序。</span><span class="sxs-lookup"><span data-stu-id="a3a90-125">You might find a scenario where you want multiple processes running in a single container.</span></span> <span data-ttu-id="a3a90-126">在此情況下，由於每個容器只能有一個進入點，因此您可以在容器中執行指令碼來視需要啟動許多程式。</span><span class="sxs-lookup"><span data-stu-id="a3a90-126">For that scenario, since there can be only one entry point per container, you could run a script within the container that launches as many programs as needed.</span></span> <span data-ttu-id="a3a90-127">例如，您可以使用 [Supervisor](http://supervisord.org/) 或類似工具，在單一容器中啟動多個處理序。</span><span class="sxs-lookup"><span data-stu-id="a3a90-127">For example, you can use [Supervisor](http://supervisord.org/) or a similar tool to take care of launching multiple processes inside a single container.</span></span> <span data-ttu-id="a3a90-128">但是即使您能找到每個容器保有多個處理序的結構，該方法仍不常見。</span><span class="sxs-lookup"><span data-stu-id="a3a90-128">However, even though you can find architectures that hold multiple processes per container, that approach isn't very common.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="a3a90-129">[上一個](../net-core-net-framework-containers/official-net-docker-images.md) 
>[下一步](containerize-monolithic-applications.md)</span><span class="sxs-lookup"><span data-stu-id="a3a90-129">[Previous](../net-core-net-framework-containers/official-net-docker-images.md)
[Next](containerize-monolithic-applications.md)</span></span>
