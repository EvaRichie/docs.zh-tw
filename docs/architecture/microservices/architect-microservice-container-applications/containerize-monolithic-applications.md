---
title: 容器化整合型應用程式
description: 容器化整合型應用程式雖然無法從微服務架構獲得所有好處，但可立即提供重要部署優勢。
ms.date: 01/30/2020
ms.openlocfilehash: b26a9b79ec00ba06404a12d62343ea31d67151cb
ms.sourcegitcommit: 6d4ee46871deb9ea1e45bb5f3784474e240bbc26
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 09/11/2020
ms.locfileid: "90022879"
---
# <a name="containerizing-monolithic-applications"></a><span data-ttu-id="0f586-103">容器化整合型應用程式</span><span class="sxs-lookup"><span data-stu-id="0f586-103">Containerizing monolithic applications</span></span>

<span data-ttu-id="0f586-104">您可能想要建置單一完整部署的 Web 應用程式或服務，並將它部署為容器。</span><span class="sxs-lookup"><span data-stu-id="0f586-104">You might want to build a single, monolithically deployed web application or service and deploy it as a container.</span></span> <span data-ttu-id="0f586-105">應用程式本身從內部來看可能不是單體式，而是結構化為數個程式庫、元件或甚至是階層 (應用程式層、領域層、資料存取層等)。</span><span class="sxs-lookup"><span data-stu-id="0f586-105">The application itself might not be internally monolithic, but structured as several libraries, components, or even layers (application layer, domain layer, data-access layer, etc.).</span></span> <span data-ttu-id="0f586-106">不過從外部來看，它是單一容器 (單一處理序、單一 Web 應用程式或單一服務)。</span><span class="sxs-lookup"><span data-stu-id="0f586-106">Externally, however, it's a single container—a single process, a single web application, or a single service.</span></span>

<span data-ttu-id="0f586-107">為了管理此模型，您會部署單一容器來代表應用程式。</span><span class="sxs-lookup"><span data-stu-id="0f586-107">To manage this model, you deploy a single container to represent the application.</span></span> <span data-ttu-id="0f586-108">若要增加容量，您需要進行擴充，也就是只在前端新增多個含有負載平衡器的複本。</span><span class="sxs-lookup"><span data-stu-id="0f586-108">To increase capacity, you scale out, that is, just add more copies with a load balancer in front.</span></span> <span data-ttu-id="0f586-109">由於是在單一容器或 VM 中管理單一部署，因此很簡單。</span><span class="sxs-lookup"><span data-stu-id="0f586-109">The simplicity comes from managing a single deployment in a single container or VM.</span></span>

![顯示整合型容器化應用程式元件的圖表。](./media/containerize-monolithic-applications/monolithic-containerized-application.png)

<span data-ttu-id="0f586-111">**圖 4-1**。</span><span class="sxs-lookup"><span data-stu-id="0f586-111">**Figure 4-1**.</span></span> <span data-ttu-id="0f586-112">容器化整合型應用程式的架構範例</span><span class="sxs-lookup"><span data-stu-id="0f586-112">Example of the architecture of a containerized monolithic application</span></span>

<span data-ttu-id="0f586-113">您可以在每個容器中包含多個元件、程式庫或內部階層，如圖 4-1 所示。</span><span class="sxs-lookup"><span data-stu-id="0f586-113">You can include multiple components, libraries, or internal layers in each container, as illustrated in Figure 4-1.</span></span> <span data-ttu-id="0f586-114">整合型容器化應用程式在單一容器內具有內部層或程式庫的大部分功能，並藉由將容器複製到多部伺服器/Vm 來相應放大。</span><span class="sxs-lookup"><span data-stu-id="0f586-114">A monolithic containerized application has most of its functionality within a single container, with internal layers or libraries, and scales out by cloning the container on multiple servers/VMs.</span></span> <span data-ttu-id="0f586-115">不過，此整合型模式可能會與「容器執行一項動作並在一個處理序中執行」的容器原則衝突，但在某些情況下可能沒問題。</span><span class="sxs-lookup"><span data-stu-id="0f586-115">However, this monolithic pattern might conflict with the container principle "a container does one thing, and does it in one process", but might be ok for some cases.</span></span>

<span data-ttu-id="0f586-116">如果應用程式成長而需要擴充，此方法的缺點會變得很明顯。</span><span class="sxs-lookup"><span data-stu-id="0f586-116">The downside of this approach becomes evident if the application grows, requiring it to scale.</span></span> <span data-ttu-id="0f586-117">若可調整整個應用程式，則不成問題。</span><span class="sxs-lookup"><span data-stu-id="0f586-117">If the entire application can scale, it isn't really a problem.</span></span> <span data-ttu-id="0f586-118">不過，在大部分情況下，應用程式的幾個部分是需要調整的扼點，而其他元件則較少使用。</span><span class="sxs-lookup"><span data-stu-id="0f586-118">However, in most cases, just a few parts of the application are the choke points that require scaling, while other components are used less.</span></span>

<span data-ttu-id="0f586-119">例如，在典型電子商務應用程式中，您可能需要擴充產品資訊子系統，因為比起購買產品，會有更多客戶瀏覽產品。</span><span class="sxs-lookup"><span data-stu-id="0f586-119">For example, in a typical e-commerce application, you likely need to scale the product information subsystem, because many more customers browse products than purchase them.</span></span> <span data-ttu-id="0f586-120">比起使用付款管道，會有更多客戶使用其購物籃。</span><span class="sxs-lookup"><span data-stu-id="0f586-120">More customers use their basket than use the payment pipeline.</span></span> <span data-ttu-id="0f586-121">新增留言或檢視其購買歷程記錄的客戶較少。</span><span class="sxs-lookup"><span data-stu-id="0f586-121">Fewer customers add comments or view their purchase history.</span></span> <span data-ttu-id="0f586-122">而且，您可能只有少數幾個員工需要管理內容和行銷活動。</span><span class="sxs-lookup"><span data-stu-id="0f586-122">And you might have only a handful of employees that need to manage the content and marketing campaigns.</span></span> <span data-ttu-id="0f586-123">如果您擴充整合型設計，這些不同工作的所有程式碼會部署多次並等比例擴充。</span><span class="sxs-lookup"><span data-stu-id="0f586-123">If you scale the monolithic design, all the code for these different tasks is deployed multiple times and scaled at the same grade.</span></span>

<span data-ttu-id="0f586-124">調整應用程式的方式有許多種：水平複製、分割應用程式的不同區域，以及分割類似的商務概念或資料。</span><span class="sxs-lookup"><span data-stu-id="0f586-124">There are multiple ways to scale an application-horizontal duplication, splitting different areas of the application, and partitioning similar business concepts or data.</span></span> <span data-ttu-id="0f586-125">但除了擴充所有元件的問題之外，每個元件的變更都需要完整重新測試整個應用程式，並完整重新部署所有執行個體。</span><span class="sxs-lookup"><span data-stu-id="0f586-125">But, in addition to the problem of scaling all components, changes to a single component require complete retesting of the entire application, and a complete redeployment of all the instances.</span></span>

<span data-ttu-id="0f586-126">不過，整合型方法並不常見，因為應用程式開發一開始會比微服務方法更容易。</span><span class="sxs-lookup"><span data-stu-id="0f586-126">However, the monolithic approach is common, because the development of the application is initially easier than for microservices approaches.</span></span> <span data-ttu-id="0f586-127">因此，許多組織會使用此架構方法進行開發。</span><span class="sxs-lookup"><span data-stu-id="0f586-127">Thus, many organizations develop using this architectural approach.</span></span> <span data-ttu-id="0f586-128">雖然某些組織的結果就已夠好，但其他組織會遇到極限。</span><span class="sxs-lookup"><span data-stu-id="0f586-128">While some organizations have had good enough results, others are hitting limits.</span></span> <span data-ttu-id="0f586-129">許多組織使用此模型來設計其應用程式，因為多年前的工具和基礎結構很難建置服務導向架構 (SOA)，而且在應用程式成長之前也沒有需求。</span><span class="sxs-lookup"><span data-stu-id="0f586-129">Many organizations designed their applications using this model because tools and infrastructure made it too difficult to build service-oriented architectures (SOA) years ago, and they did not see the need-until the application grew.</span></span>

<span data-ttu-id="0f586-130">從基礎結構的觀點來看，每部伺服器可以在相同主機內執行許多應用程式，並有可接受的資源使用效率比，如圖 4-2 所示。</span><span class="sxs-lookup"><span data-stu-id="0f586-130">From an infrastructure perspective, each server can run many applications within the same host and have an acceptable ratio of efficiency in resources usage, as shown in Figure 4-2.</span></span>

![顯示一部主機在容器中執行許多應用程式的圖表。](./media/containerize-monolithic-applications/host-multiple-apps-containers.png)

<span data-ttu-id="0f586-132">**圖 4-2**。</span><span class="sxs-lookup"><span data-stu-id="0f586-132">**Figure 4-2**.</span></span> <span data-ttu-id="0f586-133">整合型方法：執行多個應用程式的主機，每個應用程式會當做容器來執行</span><span class="sxs-lookup"><span data-stu-id="0f586-133">Monolithic approach: Host running multiple apps, each app running as a container</span></span>

<span data-ttu-id="0f586-134">您可以針對每個執行個體使用專用 VM，在 Microsoft Azure 中部署整合型應用程式。</span><span class="sxs-lookup"><span data-stu-id="0f586-134">Monolithic applications in Microsoft Azure can be deployed using dedicated VMs for each instance.</span></span> <span data-ttu-id="0f586-135">此外，您還可以使用 [Azure 虛擬機器擴展集](https://azure.microsoft.com/documentation/services/virtual-machine-scale-sets/)輕鬆地調整 VM。</span><span class="sxs-lookup"><span data-stu-id="0f586-135">Additionally, using [Azure virtual machine scale sets](https://azure.microsoft.com/documentation/services/virtual-machine-scale-sets/), you can easily scale the VMs.</span></span> <span data-ttu-id="0f586-136">[Azure App Service](https://azure.microsoft.com/services/app-service/) 也可以執行整合型應用程式並輕鬆地擴充執行個體，而不需要您管理 VM。</span><span class="sxs-lookup"><span data-stu-id="0f586-136">[Azure App Service](https://azure.microsoft.com/services/app-service/) can also run monolithic applications and easily scale instances without requiring you to manage the VMs.</span></span> <span data-ttu-id="0f586-137">從 2016 年開始，Azure App Service 也可以執行 Docker 容器的單一執行個體，以簡化部署。</span><span class="sxs-lookup"><span data-stu-id="0f586-137">Since 2016, Azure App Services can run single instances of Docker containers as well, simplifying deployment.</span></span>

<span data-ttu-id="0f586-138">在 QA 環境或有限的生產環境中，您可以部署多部 Docker 主機 VM 並使用 Azure 平衡器進行平衡，如圖 4-3 所示。</span><span class="sxs-lookup"><span data-stu-id="0f586-138">As a QA environment or a limited production environment, you can deploy multiple Docker host VMs and balance them using the Azure balancer, as shown in Figure 4-3.</span></span> <span data-ttu-id="0f586-139">這可讓您以粗略的方法來管理擴充，因為整個應用程式都位於單一容器內。</span><span class="sxs-lookup"><span data-stu-id="0f586-139">This lets you manage scaling with a coarse-grain approach, because the whole application lives within a single container.</span></span>

![此圖顯示數個執行整合型應用程式容器的主機。](./media/containerize-monolithic-applications/docker-infrastructure-monolithic-application.png)

<span data-ttu-id="0f586-141">**圖 4-3**。</span><span class="sxs-lookup"><span data-stu-id="0f586-141">**Figure 4-3**.</span></span> <span data-ttu-id="0f586-142">向上擴充單一容器應用程式的多部主機範例</span><span class="sxs-lookup"><span data-stu-id="0f586-142">Example of multiple hosts scaling up a single container application</span></span>

<span data-ttu-id="0f586-143">您可以透過傳統部署技術來管理不同主機的部署，</span><span class="sxs-lookup"><span data-stu-id="0f586-143">Deployment to the various hosts can be managed with traditional deployment techniques.</span></span> <span data-ttu-id="0f586-144">並可以手動執行 `docker run` 或 `docker-compose` 等命令，或是透過持續傳遞 (CD) 管線等自動化方法來管理 Docker 主機。</span><span class="sxs-lookup"><span data-stu-id="0f586-144">Docker hosts can be managed with commands like `docker run` or `docker-compose` performed manually, or through automation such as continuous delivery (CD) pipelines.</span></span>

## <a name="deploying-a-monolithic-application-as-a-container"></a><span data-ttu-id="0f586-145">將整合型應用程式部署為容器</span><span class="sxs-lookup"><span data-stu-id="0f586-145">Deploying a monolithic application as a container</span></span>

<span data-ttu-id="0f586-146">使用容器來管理整合型應用程式部署有許多優點。</span><span class="sxs-lookup"><span data-stu-id="0f586-146">There are benefits to using containers to manage monolithic application deployments.</span></span> <span data-ttu-id="0f586-147">擴充容器執行個體遠比部署額外的 VM 更輕鬆快速。</span><span class="sxs-lookup"><span data-stu-id="0f586-147">Scaling container instances is far faster and easier than deploying additional VMs.</span></span> <span data-ttu-id="0f586-148">即使您使用虛擬機器擴展集，VM 還是需要時間才能啟動。</span><span class="sxs-lookup"><span data-stu-id="0f586-148">Even if you use virtual machine scale sets, VMs take time to start.</span></span> <span data-ttu-id="0f586-149">部署為傳統應用程式執行個體而不是容器時，應用程式的組態會當作 VM 的一部分來管理，這並不理想。</span><span class="sxs-lookup"><span data-stu-id="0f586-149">When deployed as traditional application instances instead of containers, the configuration of the application is managed as part of the VM, which isn't ideal.</span></span>

<span data-ttu-id="0f586-150">以 Docker 映像來部署更新會更快且網路效率更高。</span><span class="sxs-lookup"><span data-stu-id="0f586-150">Deploying updates as Docker images is far faster and network efficient.</span></span> <span data-ttu-id="0f586-151">Docker 映像通常只要幾秒鐘就能啟動，因此可加速推出。</span><span class="sxs-lookup"><span data-stu-id="0f586-151">Docker images typically start in seconds, which speeds rollouts.</span></span> <span data-ttu-id="0f586-152">卸除 Docker 映像執行個體很容易，只要發出 `docker stop` 命令即可，而且通常不到一秒就會完成。</span><span class="sxs-lookup"><span data-stu-id="0f586-152">Tearing down a Docker image instance is as easy as issuing a `docker stop` command, and typically completes in less than a second.</span></span>

<span data-ttu-id="0f586-153">由於容器根據設計是不可變的，因此您永遠不必擔心已損毀的 VM。</span><span class="sxs-lookup"><span data-stu-id="0f586-153">Because containers are immutable by design, you never need to worry about corrupted VMs.</span></span> <span data-ttu-id="0f586-154">相反地，VM 的更新指令碼可能會忘記說明某些特定組態，或忘記有檔案還留在磁碟上。</span><span class="sxs-lookup"><span data-stu-id="0f586-154">In contrast, update scripts for a VM might forget to account for some specific configuration or file left on disk.</span></span>

<span data-ttu-id="0f586-155">雖然整合型應用程式可以從 Docker 獲益，但這只是一小部分優點。</span><span class="sxs-lookup"><span data-stu-id="0f586-155">While monolithic applications can benefit from Docker, we're touching only on the benefits.</span></span> <span data-ttu-id="0f586-156">管理容器的其他優點來自於使用容器協調器進行部署，這會管理各種執行個體和每個容器執行個體的生命週期。</span><span class="sxs-lookup"><span data-stu-id="0f586-156">Additional benefits of managing containers come from deploying with container orchestrators, which manage the various instances and lifecycle of each container instance.</span></span> <span data-ttu-id="0f586-157">將整合型應用程式分成可個別擴充、開發及部署的多個子系統，是您開始使用微服務的不錯起點。</span><span class="sxs-lookup"><span data-stu-id="0f586-157">Breaking up the monolithic application into subsystems that can be scaled, developed, and deployed individually is your entry point into the realm of microservices.</span></span>

## <a name="publishing-a-single-container-based-application-to-azure-app-service"></a><span data-ttu-id="0f586-158">將單一容器應用程式發行至 Azure App Service</span><span class="sxs-lookup"><span data-stu-id="0f586-158">Publishing a single-container-based application to Azure App Service</span></span>

<span data-ttu-id="0f586-159">不論您想要取得部署至 Azure 的容器驗證，還是在應用程式只是單一容器應用程式的情況下，Azure App Service 都有絕佳的方法來提供可擴充的單一容器服務。</span><span class="sxs-lookup"><span data-stu-id="0f586-159">Whether you want to get validation of a container deployed to Azure or when an application is simply a single-container application, Azure App Service provides a great way to provide scalable single-container-based services.</span></span> <span data-ttu-id="0f586-160">使用 Azure App Service 很簡單。</span><span class="sxs-lookup"><span data-stu-id="0f586-160">Using Azure App Service is simple.</span></span> <span data-ttu-id="0f586-161">它提供與 Git 的絕佳整合，讓您可以輕鬆地取得程式碼、在 Visual Studio 中建置，並將它直接部署至 Azure。</span><span class="sxs-lookup"><span data-stu-id="0f586-161">It provides great integration with Git to make it easy to take your code, build it in Visual Studio, and deploy it directly to Azure.</span></span>

![顯示容器登錄的 [建立 App Service] 對話方塊的螢幕擷取畫面。](./media/containerize-monolithic-applications/publish-azure-app-service-container.png)

<span data-ttu-id="0f586-163">**圖 4-4**。</span><span class="sxs-lookup"><span data-stu-id="0f586-163">**Figure 4-4**.</span></span> <span data-ttu-id="0f586-164">從 Visual Studio 2019 將單一容器應用程式發佈至 Azure App Service</span><span class="sxs-lookup"><span data-stu-id="0f586-164">Publishing a single-container application to Azure App Service from Visual Studio 2019</span></span>

<span data-ttu-id="0f586-165">之前沒有 Docker 時，如果您需要 Azure App Service 不支援的其他功能、架構或相依性，您必須等到 Azure 小組更新 App Service 中的這些相依性。</span><span class="sxs-lookup"><span data-stu-id="0f586-165">Without Docker, if you needed other capabilities, frameworks, or dependencies that aren't supported in Azure App Service, you had to wait until the Azure team updated those dependencies in App Service.</span></span> <span data-ttu-id="0f586-166">或者，您必須切換至其他服務 (例如 Azure 雲端服務或 VM)，才能進一步控制並可安裝應用程式的必要元件或架構。</span><span class="sxs-lookup"><span data-stu-id="0f586-166">Or you had to switch to other services like Azure Cloud Services or VMs, where you had further control and you could install a required component or framework for your application.</span></span>

<span data-ttu-id="0f586-167">Visual Studio 2017 和更新版本中的容器支援可讓您在應用程式環境中包含您要的任何項目，如圖 4-4 所示。</span><span class="sxs-lookup"><span data-stu-id="0f586-167">Container support in Visual Studio 2017 and later gives you the ability to include whatever you want in your application environment, as shown in Figure 4-4.</span></span> <span data-ttu-id="0f586-168">由於您在容器中執行，因此如果您將相依性新增至應用程式，您可以在 Dockerfile 或 Docker 映像中包含此相依性。</span><span class="sxs-lookup"><span data-stu-id="0f586-168">Since you're running it in a container, if you add a dependency to your application, you can include the dependency in your Dockerfile or Docker image.</span></span>

<span data-ttu-id="0f586-169">此外，如圖 4-4 所示，發行流程會透過容器登錄推送映像。</span><span class="sxs-lookup"><span data-stu-id="0f586-169">As also shown in Figure 4-4, the publish flow pushes an image through a container registry.</span></span> <span data-ttu-id="0f586-170">這可以是 Azure Container Registry (接近您的 Azure 部署並受到 Azure Active Directory 群組和帳戶保護的登錄)，或任何其他 Docker 登錄，例如 Docker Hub 或內部部署登錄。</span><span class="sxs-lookup"><span data-stu-id="0f586-170">This can be the Azure Container Registry (a registry close to your deployments in Azure and secured by Azure Active Directory groups and accounts), or any other Docker registry, like Docker Hub or an on-premises registry.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="0f586-171">[上一個](index.md) 
>[下一步](docker-application-state-data.md)</span><span class="sxs-lookup"><span data-stu-id="0f586-171">[Previous](index.md)
[Next](docker-application-state-data.md)</span></span>
