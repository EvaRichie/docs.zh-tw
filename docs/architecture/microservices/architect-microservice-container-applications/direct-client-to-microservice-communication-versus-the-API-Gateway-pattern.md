---
title: API 閘道模式與直接用戶端對微服務通訊
description: 了解 API 閘道模式和直接用戶端對微服務通訊的差異與使用方式。
ms.date: 01/07/2019
ms.openlocfilehash: 089b6302132437e4bb733653b3edb401ff81a164
ms.sourcegitcommit: 5280b2aef60a1ed99002dba44e4b9e7f6c830604
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 06/03/2020
ms.locfileid: "84306951"
---
# <a name="the-api-gateway-pattern-versus-the-direct-client-to-microservice-communication"></a><span data-ttu-id="3e98c-103">API 閘道模式與直接用戶端對微服務通訊</span><span class="sxs-lookup"><span data-stu-id="3e98c-103">The API gateway pattern versus the Direct client-to-microservice communication</span></span>

<span data-ttu-id="3e98c-104">在微服務架構中，每個微服務都會公開一組 (通常是) 微調端點。</span><span class="sxs-lookup"><span data-stu-id="3e98c-104">In a microservices architecture, each microservice exposes a set of (typically) fine-grained endpoints.</span></span> <span data-ttu-id="3e98c-105">這項事實可能會影響用戶端與微服務通訊，如本節所述。</span><span class="sxs-lookup"><span data-stu-id="3e98c-105">This fact can impact the client-to-microservice communication, as explained in this section.</span></span>

## <a name="direct-client-to-microservice-communication"></a><span data-ttu-id="3e98c-106">直接用戶端對微服務通訊</span><span class="sxs-lookup"><span data-stu-id="3e98c-106">Direct client-to-microservice communication</span></span>

<span data-ttu-id="3e98c-107">可能的方法是使用直接用戶端對微服務通訊架構。</span><span class="sxs-lookup"><span data-stu-id="3e98c-107">A possible approach is to use a direct client-to-microservice communication architecture.</span></span> <span data-ttu-id="3e98c-108">使用這種方法，用戶端應用程式可以直接對某些微服務提出要求，如圖 4-12 所示。</span><span class="sxs-lookup"><span data-stu-id="3e98c-108">In this approach, a client app can make requests directly to some of the microservices, as shown in Figure 4-12.</span></span>

![顯示用戶端對微服務通訊架構的圖表。](./media/direct-client-to-microservice-communication.png)

<span data-ttu-id="3e98c-110">**圖 4-12**.</span><span class="sxs-lookup"><span data-stu-id="3e98c-110">**Figure 4-12**.</span></span> <span data-ttu-id="3e98c-111">使用直接用戶端對微服務通訊架構</span><span class="sxs-lookup"><span data-stu-id="3e98c-111">Using a direct client-to-microservice communication architecture</span></span>

<span data-ttu-id="3e98c-112">在此方法中，每個微服務都會有公用端點，有時每個微服務會有不同的 TCP 連接埠。</span><span class="sxs-lookup"><span data-stu-id="3e98c-112">In this approach, each microservice has a public endpoint, sometimes with a different TCP port for each microservice.</span></span> <span data-ttu-id="3e98c-113">在 Azure 中，特定服務的 URL 範例可以是下列 URL：</span><span class="sxs-lookup"><span data-stu-id="3e98c-113">An example of a URL for a particular service could be the following URL in Azure:</span></span>

`http://eshoponcontainers.westus.cloudapp.azure.com:88/`

<span data-ttu-id="3e98c-114">在根據叢集的生產環境中，該 URL 會對應至叢集中所使用的負載平衡器，而負載平衡器接著會將要求分散到微服務。</span><span class="sxs-lookup"><span data-stu-id="3e98c-114">In a production environment based on a cluster, that URL would map to the load balancer used in the cluster, which in turn distributes the requests across the microservices.</span></span> <span data-ttu-id="3e98c-115">在生產環境中，您在微服務與網際網路之間可能會有 [Azure 應用程式閘道](https://docs.microsoft.com/azure/application-gateway/application-gateway-introduction)這類應用程式傳遞控制站 (ADC)。</span><span class="sxs-lookup"><span data-stu-id="3e98c-115">In production environments, you could have an Application Delivery Controller (ADC) like [Azure Application Gateway](https://docs.microsoft.com/azure/application-gateway/application-gateway-introduction) between your microservices and the Internet.</span></span> <span data-ttu-id="3e98c-116">這會作為透明層，不僅可執行負載平衡，也會透過提供 SSL 終止來保護您的服務。</span><span class="sxs-lookup"><span data-stu-id="3e98c-116">This acts as a transparent tier that not only performs load balancing, but secures your services by offering SSL termination.</span></span> <span data-ttu-id="3e98c-117">這會改善主機的負載，方法是將 CPU 密集 SSL 終止和其他路由責任卸載給 Azure 應用程式閘道。</span><span class="sxs-lookup"><span data-stu-id="3e98c-117">This improves the load of your hosts by offloading CPU-intensive SSL termination and other routing duties to the Azure Application Gateway.</span></span> <span data-ttu-id="3e98c-118">從邏輯應用程式架構觀點，在任何情況下，負載平衡器和 ADC 都是透明的。</span><span class="sxs-lookup"><span data-stu-id="3e98c-118">In any case, a load balancer and ADC are transparent from a logical application architecture point of view.</span></span>

<span data-ttu-id="3e98c-119">直接用戶端對微服務通訊架構可能適用於小型微服務應用程式，特別是用戶端應用程式為 ASP.NET MVC 應用程式這類伺服器端 Web 應用程式時。</span><span class="sxs-lookup"><span data-stu-id="3e98c-119">A direct client-to-microservice communication architecture could be good enough for a small microservice-based application, especially if the client app is a server-side web application like an ASP.NET MVC app.</span></span> <span data-ttu-id="3e98c-120">不過，如果您建置大型且複雜的微服務應用程式 (例如，處理數十個微服務型別時)，特別是用戶端應用程式為遠端行動應用程式或 SPA Web 應用程式時，該方法會面臨的一些問題。</span><span class="sxs-lookup"><span data-stu-id="3e98c-120">However, when you build large and complex microservice-based applications (for example, when handling dozens of microservice types), and especially when the client apps are remote mobile apps or SPA web applications, that approach faces a few issues.</span></span>

<span data-ttu-id="3e98c-121">開發根據微服務的大型應用程式時，請考慮下列問題：</span><span class="sxs-lookup"><span data-stu-id="3e98c-121">Consider the following questions when developing a large application based on microservices:</span></span>

- <span data-ttu-id="3e98c-122">用戶端應用程式如何將後端要求數目最小化，以及減少與多個微服務的過度頻繁通訊？\*\*</span><span class="sxs-lookup"><span data-stu-id="3e98c-122">*How can client apps minimize the number of requests to the back end and reduce chatty communication to multiple microservices?*</span></span>

<span data-ttu-id="3e98c-123">與多個微服務互動來建置單一 UI 畫面，會增加跨網際網路來回行程的次數。</span><span class="sxs-lookup"><span data-stu-id="3e98c-123">Interacting with multiple microservices to build a single UI screen increases the number of round trips across the Internet.</span></span> <span data-ttu-id="3e98c-124">這會增加 UI 端的延遲和複雜性。</span><span class="sxs-lookup"><span data-stu-id="3e98c-124">This increases latency and complexity on the UI side.</span></span> <span data-ttu-id="3e98c-125">在理想情況下，回應應該有效率地在伺服器端中彙總。</span><span class="sxs-lookup"><span data-stu-id="3e98c-125">Ideally, responses should be efficiently aggregated in the server side.</span></span> <span data-ttu-id="3e98c-126">因為多個部分的資料會平行返回，所以可以減少延遲，而某些 UI 一準備好就可以顯示資料。</span><span class="sxs-lookup"><span data-stu-id="3e98c-126">This reduces latency, since multiple pieces of data come back in parallel and some UI can show data as soon as it's ready.</span></span>

- <span data-ttu-id="3e98c-127">*如何處理授權、資料轉換和動態要求分派這類跨領域考量？*</span><span class="sxs-lookup"><span data-stu-id="3e98c-127">*How can you handle cross-cutting concerns such as authorization, data transformations, and dynamic request dispatching?*</span></span>

<span data-ttu-id="3e98c-128">實作安全性和跨領域考量 (例如每個微服務上的安全性和授權) 可能需要大量開發工作。</span><span class="sxs-lookup"><span data-stu-id="3e98c-128">Implementing security and cross-cutting concerns like security and authorization on every microservice can require significant development effort.</span></span> <span data-ttu-id="3e98c-129">可能的方法是 Docker 主機或內部叢集內有這些服務，以限制從外部直接存取它們，並在集中位置 (例如 API 閘道) 實作這些跨領域考量。</span><span class="sxs-lookup"><span data-stu-id="3e98c-129">A possible approach is to have those services within the Docker host or internal cluster to restrict direct access to them from the outside, and to implement those cross-cutting concerns in a centralized place, like an API Gateway.</span></span>

- <span data-ttu-id="3e98c-130">*用戶端應用程式如何與使用非網際網路好用通訊協定的服務通訊？*</span><span class="sxs-lookup"><span data-stu-id="3e98c-130">*How can client apps communicate with services that use non-Internet-friendly protocols?*</span></span>

<span data-ttu-id="3e98c-131">用戶端應用程式通常不支援伺服器端上使用的通訊協定 (例如 AMQP 或二進位通訊協定)。</span><span class="sxs-lookup"><span data-stu-id="3e98c-131">Protocols used on the server side (like AMQP or binary protocols) are usually not supported in client apps.</span></span> <span data-ttu-id="3e98c-132">因此，必須透過 HTTP/HTTPS 這類通訊協定執行要求，而且之後會轉譯成其他通訊協定。</span><span class="sxs-lookup"><span data-stu-id="3e98c-132">Therefore, requests must be performed through protocols like HTTP/HTTPS and translated to the other protocols afterwards.</span></span> <span data-ttu-id="3e98c-133">在此情況下，「攔截式」\*\* 方法可能有幫助。</span><span class="sxs-lookup"><span data-stu-id="3e98c-133">A *man-in-the-middle* approach can help in this situation.</span></span>

- <span data-ttu-id="3e98c-134">如何形成特別針對行動應用程式所產生的外觀？\*\*</span><span class="sxs-lookup"><span data-stu-id="3e98c-134">*How can you shape a facade especially made for mobile apps?*</span></span>

<span data-ttu-id="3e98c-135">多個微服務 API 的設計可能不是最適合不同用戶端應用程式的需求。</span><span class="sxs-lookup"><span data-stu-id="3e98c-135">The API of multiple microservices might not be well designed for the needs of different client applications.</span></span> <span data-ttu-id="3e98c-136">例如，行動應用程式需求可能會與 Web 應用程式需求不同。</span><span class="sxs-lookup"><span data-stu-id="3e98c-136">For instance, the needs of a mobile app might be different than the needs of a web app.</span></span> <span data-ttu-id="3e98c-137">針對行動應用程式，您甚至可能需要更進一步最佳化，讓資料回應更具效率。</span><span class="sxs-lookup"><span data-stu-id="3e98c-137">For mobile apps, you might need to optimize even further so that data responses can be more efficient.</span></span> <span data-ttu-id="3e98c-138">作法是彙總多個微服務中的資料並傳回一組資料，有時會排除行動應用程式不需要之回應中的任何資料。</span><span class="sxs-lookup"><span data-stu-id="3e98c-138">You might do this by aggregating data from multiple microservices and returning a single set of data, and sometimes eliminating any data in the response that isn't needed by the mobile app.</span></span> <span data-ttu-id="3e98c-139">而且，您當然可以壓縮該資料。</span><span class="sxs-lookup"><span data-stu-id="3e98c-139">And, of course, you might compress that data.</span></span> <span data-ttu-id="3e98c-140">同樣地，在此案例中，行動應用程式與微服務之間的外觀或 API 可能十分方便使用。</span><span class="sxs-lookup"><span data-stu-id="3e98c-140">Again, a facade or API in between the mobile app and the microservices can be convenient for this scenario.</span></span>

## <a name="why-consider-api-gateways-instead-of-direct-client-to-microservice-communication"></a><span data-ttu-id="3e98c-141">為何考慮 API 閘道而不考慮直接用戶端對微服務通訊</span><span class="sxs-lookup"><span data-stu-id="3e98c-141">Why consider API Gateways instead of direct client-to-microservice communication</span></span>

<span data-ttu-id="3e98c-142">在微服務架構中，用戶端應用程式通常需要從超過一個的微服務取用功能。</span><span class="sxs-lookup"><span data-stu-id="3e98c-142">In a microservices architecture, the client apps usually need to consume functionality from more than one microservice.</span></span> <span data-ttu-id="3e98c-143">如直接執行取用，用戶端需要處理多個對微服務端點的呼叫。</span><span class="sxs-lookup"><span data-stu-id="3e98c-143">If that consumption is performed directly, the client needs to handle multiple calls to microservice endpoints.</span></span> <span data-ttu-id="3e98c-144">當應用程式演進且微服務推出新版時，或現有的微服務推出更新時，會發生什麼事？</span><span class="sxs-lookup"><span data-stu-id="3e98c-144">What happens when the application evolves and new microservices are introduced or existing microservices are updated?</span></span> <span data-ttu-id="3e98c-145">如果您的應用程式有許多微服務，從用戶端應用程式處理這麼多端點會是個夢魘。</span><span class="sxs-lookup"><span data-stu-id="3e98c-145">If your application has many microservices, handling so many endpoints from the client apps can be a nightmare.</span></span> <span data-ttu-id="3e98c-146">因為用戶端應用程式可能會與那些內部端點結合，導致未來微服務演進時，對用戶端應用程式可能產生重大影響。</span><span class="sxs-lookup"><span data-stu-id="3e98c-146">Since the client app would be coupled to those internal endpoints, evolving the microservices in the future can cause high impact for the client apps.</span></span>

<span data-ttu-id="3e98c-147">因此，具有中繼層級或間接階層 (閘道)，對於微服務型應用程式會非常方便。</span><span class="sxs-lookup"><span data-stu-id="3e98c-147">Therefore, having an intermediate level or tier of indirection (Gateway) can be very convenient for microservice-based applications.</span></span> <span data-ttu-id="3e98c-148">如果您沒有 API 閘道，用戶端應用程式就必須直接傳送要求至微服務，而這樣會產生如以下的問題：</span><span class="sxs-lookup"><span data-stu-id="3e98c-148">If you don't have API Gateways, the client apps must send requests directly to the microservices and that raises problems, such as the following issues:</span></span>

- <span data-ttu-id="3e98c-149">**結合**：如果沒有 API 閘道模式，用戶端應用程式就會與內部微服務結合。</span><span class="sxs-lookup"><span data-stu-id="3e98c-149">**Coupling**: Without the API Gateway pattern, the client apps are coupled to the internal microservices.</span></span> <span data-ttu-id="3e98c-150">用戶端應用程式需要知道應用程式的多個部分在微服務中分解的方式。</span><span class="sxs-lookup"><span data-stu-id="3e98c-150">The client apps need to know how the multiple areas of the application are decomposed in microservices.</span></span> <span data-ttu-id="3e98c-151">在進化和重構內部微服務時，這些動作會影響維護，因為它們會因為用戶端應用程式直接參考內部微服務，而導致用戶端應用程式的突破性變更。</span><span class="sxs-lookup"><span data-stu-id="3e98c-151">When evolving and refactoring the internal microservices, those actions impact maintenance because they cause breaking changes to the client apps due to the direct reference to the internal microservices from the client apps.</span></span> <span data-ttu-id="3e98c-152">用戶端應用程式需要經常更新，使解決方案難以演進。</span><span class="sxs-lookup"><span data-stu-id="3e98c-152">Client apps need to be updated frequently, making the solution harder to evolve.</span></span>

- <span data-ttu-id="3e98c-153">**太多來回行程**：用戶端應用程式中的單一頁面/畫面可能需要對多個服務進行數個呼叫。</span><span class="sxs-lookup"><span data-stu-id="3e98c-153">**Too many round trips**: A single page/screen in the client app might require several calls to multiple services.</span></span> <span data-ttu-id="3e98c-154">此動作會讓用戶端與伺服器之間有多次網路往返，而大幅增加延遲時間。</span><span class="sxs-lookup"><span data-stu-id="3e98c-154">That can result in multiple network round trips between the client and the server, adding significant latency.</span></span> <span data-ttu-id="3e98c-155">在中繼層級中處理的彙總可改善用戶端應用程式的效能和使用者體驗。</span><span class="sxs-lookup"><span data-stu-id="3e98c-155">Aggregation handled in an intermediate level could improve the performance and user experience for the client app.</span></span>

- <span data-ttu-id="3e98c-156">**安全性問題**：在沒有閘道的情況下，所有微服務都必須公開給「外部世界」，這樣的攻擊面會比您隱藏未直接由用戶端應用程式使用的內部微服務的情況來得更大。</span><span class="sxs-lookup"><span data-stu-id="3e98c-156">**Security issues**: Without a gateway, all the microservices must be exposed to the "external world", making the attack surface larger than if you hide internal microservices that aren't directly used by the client apps.</span></span> <span data-ttu-id="3e98c-157">攻擊面越小，您的應用程式就越安全。</span><span class="sxs-lookup"><span data-stu-id="3e98c-157">The smaller the attack surface is, the more secure your application can be.</span></span>

- <span data-ttu-id="3e98c-158">**跨領域考慮**：每個公開發行的微服務都必須處理授權和 SSL 等考慮。</span><span class="sxs-lookup"><span data-stu-id="3e98c-158">**Cross-cutting concerns**: Each publicly published microservice must handle concerns such as authorization and SSL.</span></span> <span data-ttu-id="3e98c-159">在許多情況下，那些考量可以在單一階層中處理，這樣就能簡化內部的微服務。</span><span class="sxs-lookup"><span data-stu-id="3e98c-159">In many situations, those concerns could be handled in a single tier so the internal microservices are simplified.</span></span>

## <a name="what-is-the-api-gateway-pattern"></a><span data-ttu-id="3e98c-160">什麼是 API 閘道模式？</span><span class="sxs-lookup"><span data-stu-id="3e98c-160">What is the API Gateway pattern?</span></span>

<span data-ttu-id="3e98c-161">當您使用多個用戶端應用程式來設計和建置大型或複雜微服務應用程式時，可以考慮使用的不錯方法是 [API 閘道](https://microservices.io/patterns/apigateway.html)。</span><span class="sxs-lookup"><span data-stu-id="3e98c-161">When you design and build large or complex microservice-based applications with multiple client apps, a good approach to consider can be an [API Gateway](https://microservices.io/patterns/apigateway.html).</span></span> <span data-ttu-id="3e98c-162">這個服務提供特定一組微服務的單一進入點。</span><span class="sxs-lookup"><span data-stu-id="3e98c-162">This is a service that provides a single-entry point for certain groups of microservices.</span></span> <span data-ttu-id="3e98c-163">它類似物件導向設計的[外觀模式](https://en.wikipedia.org/wiki/Facade_pattern)，不過在此案例中，它是分散式系統的一部分。</span><span class="sxs-lookup"><span data-stu-id="3e98c-163">It's similar to the [Facade pattern](https://en.wikipedia.org/wiki/Facade_pattern) from object-oriented design, but in this case, it's part of a distributed system.</span></span> <span data-ttu-id="3e98c-164">因為您是在考量用戶端應用程式需求時建置 API 閘道模式，所以它有時也稱為「前端的後端」([BFF](https://samnewman.io/patterns/architectural/bff/))。</span><span class="sxs-lookup"><span data-stu-id="3e98c-164">The API Gateway pattern is also sometimes known as the "backend for frontend" ([BFF](https://samnewman.io/patterns/architectural/bff/)) because you build it while thinking about the needs of the client app.</span></span>

<span data-ttu-id="3e98c-165">因此，API 閘道位在用戶端應用程式和微服務之間，</span><span class="sxs-lookup"><span data-stu-id="3e98c-165">Therefore, the API gateway sits between the client apps and the microservices.</span></span> <span data-ttu-id="3e98c-166">它會作為反向 Proxy，將要求從用戶端路由傳送到服務。</span><span class="sxs-lookup"><span data-stu-id="3e98c-166">It acts as a reverse proxy, routing requests from clients to services.</span></span> <span data-ttu-id="3e98c-167">它也可以提供額外的跨領域功能，例如驗證、SSL 終止和快取。</span><span class="sxs-lookup"><span data-stu-id="3e98c-167">It can also provide additional cross-cutting features such as authentication, SSL termination, and cache.</span></span>

<span data-ttu-id="3e98c-168">圖 4-13 顯示自訂的 API 閘道如何搭配只有幾個微服務的簡化微服務型架構。</span><span class="sxs-lookup"><span data-stu-id="3e98c-168">Figure 4-13 shows how a custom API Gateway can fit into a simplified microservice-based architecture with just a few microservices.</span></span>

![此圖顯示實作為自訂服務的 API 閘道。](./media/direct-client-to-microservice-communication-versus-the-API-Gateway-pattern/custom-service-api-gateway.png)

<span data-ttu-id="3e98c-170">**圖 4-13**.</span><span class="sxs-lookup"><span data-stu-id="3e98c-170">**Figure 4-13**.</span></span> <span data-ttu-id="3e98c-171">使用實作為自訂服務的 API 閘道</span><span class="sxs-lookup"><span data-stu-id="3e98c-171">Using an API Gateway implemented as a custom service</span></span>

<span data-ttu-id="3e98c-172">應用程式會連線至單一端點（即 API 閘道），其設定為將要求轉送至個別微服務。</span><span class="sxs-lookup"><span data-stu-id="3e98c-172">Apps connect to a single endpoint, the API Gateway, that's configured to forward requests to individual microservices.</span></span> <span data-ttu-id="3e98c-173">在此範例中，API 閘道會實作為以容器形式執行的自訂 ASP.NET Core WebHost 服務。</span><span class="sxs-lookup"><span data-stu-id="3e98c-173">In this example, the API Gateway would be implemented as a custom ASP.NET Core WebHost service running as a container.</span></span>

<span data-ttu-id="3e98c-174">請務必在該圖表中將它反白顯示，您會使用面向多個和不同用戶端應用程式的單一自訂 API 閘道服務。</span><span class="sxs-lookup"><span data-stu-id="3e98c-174">It's important to highlight that in that diagram, you would be using a single custom API Gateway service facing multiple and different client apps.</span></span> <span data-ttu-id="3e98c-175">這項事實的風險可能十分重大，因為 API 閘道服務將會根據用戶端應用程式的許多不同需求而成長和演變。</span><span class="sxs-lookup"><span data-stu-id="3e98c-175">That fact can be an important risk because your API Gateway service will be growing and evolving based on many different requirements from the client apps.</span></span> <span data-ttu-id="3e98c-176">最後，它會因為不同的需求而膨脹，而且實際上可能類似整合型應用程式或整合型服務。</span><span class="sxs-lookup"><span data-stu-id="3e98c-176">Eventually, it will be bloated because of those different needs and effectively it could be similar to a monolithic application or monolithic service.</span></span> <span data-ttu-id="3e98c-177">這就是為什麼我們極為建議將 API 閘道分割為多個服務或多個較小的 API 閘道 (例如，每個用戶端應用程式外形規格類型都有一個)。</span><span class="sxs-lookup"><span data-stu-id="3e98c-177">That's why it's very much recommended to split the API Gateway in multiple services or multiple smaller API Gateways, one per client app form-factor type, for instance.</span></span>

<span data-ttu-id="3e98c-178">您需要謹慎地實作 API 閘道模式。</span><span class="sxs-lookup"><span data-stu-id="3e98c-178">You need to be careful when implementing the API Gateway pattern.</span></span> <span data-ttu-id="3e98c-179">通常不適合讓單一 API 閘道彙總您應用程式的所有內部微服務。</span><span class="sxs-lookup"><span data-stu-id="3e98c-179">Usually it isn't a good idea to have a single API Gateway aggregating all the internal microservices of your application.</span></span> <span data-ttu-id="3e98c-180">若是如此，它會作為整合型彙總工具或協調器，並且因結合所有微服務而違反微服務自主性。</span><span class="sxs-lookup"><span data-stu-id="3e98c-180">If it does, it acts as a monolithic aggregator or orchestrator and violates microservice autonomy by coupling all the microservices.</span></span>

<span data-ttu-id="3e98c-181">因此，應該根據商務界限和用戶端應用程式來隔離 API 閘道，而不是作為所有內部微服務的彙總工具。</span><span class="sxs-lookup"><span data-stu-id="3e98c-181">Therefore, the API Gateways should be segregated based on business boundaries and the client apps and not act as a single aggregator for all the internal microservices.</span></span>

<span data-ttu-id="3e98c-182">當 API 閘道階層分成多個 API 閘道時，如果您的應用程式有多個用戶端應用程式，這樣可當作識別多個 API 閘道類型的樞紐，您就可以擁有適用於每個用戶端應用程式需求的不同外觀。</span><span class="sxs-lookup"><span data-stu-id="3e98c-182">When splitting the API Gateway tier into multiple API Gateways, if your application has multiple client apps, that can be a primary pivot when identifying the multiple API Gateways types, so that you can have a different facade for the needs of each client app.</span></span> <span data-ttu-id="3e98c-183">此案例是名為「前端的後端」([BFF](https://samnewman.io/patterns/architectural/bff/)) 的模式，藉由實作底層會呼叫多個內部微服務的特定配接器程式碼，其中每個 API 閘道都可以提供針對每個用戶端應用程式類型量身訂做的不同 API (甚至可能以用戶端外形規格為基礎)，如以下影像所示：</span><span class="sxs-lookup"><span data-stu-id="3e98c-183">This case is a pattern named "Backend for Frontend" ([BFF](https://samnewman.io/patterns/architectural/bff/)) where each API Gateway can provide a different API tailored for each client app type, possibly even based on the client form factor by implementing specific adapter code which underneath calls multiple internal microservices, as shown in the following image:</span></span>

![顯示多個自訂 API 閘道的圖表。](./media/direct-client-to-microservice-communication-versus-the-API-Gateway-pattern/multiple-custom-api-gateways.png)

<span data-ttu-id="3e98c-185">**圖 4-13.1**.</span><span class="sxs-lookup"><span data-stu-id="3e98c-185">**Figure 4-13.1**.</span></span> <span data-ttu-id="3e98c-186">使用多個自訂 API 閘道</span><span class="sxs-lookup"><span data-stu-id="3e98c-186">Using multiple custom API Gateways</span></span>

<span data-ttu-id="3e98c-187">圖 4-13.1 顯示依用戶端類型隔離的 API 閘道;一個用於行動用戶端，另一個用於 web 用戶端。</span><span class="sxs-lookup"><span data-stu-id="3e98c-187">Figure 4-13.1 shows API Gateways that are segregated by client type; one for mobile clients and one for web clients.</span></span> <span data-ttu-id="3e98c-188">使用 Web API 閘道連線至 MVC 微服務的傳統 Web 應用程式。</span><span class="sxs-lookup"><span data-stu-id="3e98c-188">A traditional web app connects to an MVC microservice that uses the web API Gateway.</span></span> <span data-ttu-id="3e98c-189">此範例使用多個更精細的 API 閘道來描述簡化的架構。</span><span class="sxs-lookup"><span data-stu-id="3e98c-189">The example depicts a simplified architecture with multiple fine-grained API Gateways.</span></span> <span data-ttu-id="3e98c-190">在此案例中，針對每個 API 閘道識別的界限只以「前端的後端」([BFF](https://samnewman.io/patterns/architectural/bff/)) 模式為基礎，因此也只以每個用戶端應用程式所需的 API 為基礎。</span><span class="sxs-lookup"><span data-stu-id="3e98c-190">In this case, the boundaries identified for each API Gateway are based purely on the "Backend for Frontend" ([BFF](https://samnewman.io/patterns/architectural/bff/)) pattern, hence based just on the API needed per client app.</span></span> <span data-ttu-id="3e98c-191">但在更大型的應用程式中，您應該也進一步建立以商務界限為基礎的 API 閘道，作為第二設計樞紐。</span><span class="sxs-lookup"><span data-stu-id="3e98c-191">But in larger applications you should also go further and create additional API Gateways based on business boundaries as a second design pivot.</span></span>

## <a name="main-features-in-the-api-gateway-pattern"></a><span data-ttu-id="3e98c-192">API 閘道模式中的主要功能</span><span class="sxs-lookup"><span data-stu-id="3e98c-192">Main features in the API Gateway pattern</span></span>

<span data-ttu-id="3e98c-193">API 閘道可以提供多個功能。</span><span class="sxs-lookup"><span data-stu-id="3e98c-193">An API Gateway can offer multiple features.</span></span> <span data-ttu-id="3e98c-194">視產品而定，它可以提供更豐富或更簡單的功能，不過，對於任何 API 閘道最重要且最基本的功能是以下設計模式：</span><span class="sxs-lookup"><span data-stu-id="3e98c-194">Depending on the product it might offer richer or simpler features, however, the most important and foundational features for any API Gateway are the following design patterns:</span></span>

<span data-ttu-id="3e98c-195">**反向 Proxy 或閘道路由。**</span><span class="sxs-lookup"><span data-stu-id="3e98c-195">**Reverse proxy or gateway routing.**</span></span> <span data-ttu-id="3e98c-196">API 閘道提供反向 Proxy，以重新導向或路由要求 (第 7 層路由，通常是 HTTP 要求) 至內部微服務的端點。</span><span class="sxs-lookup"><span data-stu-id="3e98c-196">The API Gateway offers a reverse proxy to redirect or route requests (layer 7 routing, usually HTTP requests) to the endpoints of the internal microservices.</span></span> <span data-ttu-id="3e98c-197">閘道針對用戶端應用程式提供單一端點或 URL，然後在內部將要求對應至內部微服務群組。</span><span class="sxs-lookup"><span data-stu-id="3e98c-197">The gateway provides a single endpoint or URL for the client apps and then internally maps the requests to a group of internal microservices.</span></span> <span data-ttu-id="3e98c-198">此路由功能有助於將用戶端應用程式與微服務分離，但當您透過整合型 API 與用戶端應用程式之間的 API 閘道來現代化整合型 API 時也很方便，您可以將新的 Api 新增為新的微服務，同時仍然使用舊版整合型 API，直到未來將它分割成許多微服務為止。</span><span class="sxs-lookup"><span data-stu-id="3e98c-198">This routing feature helps to decouple the client apps from the microservices but it's also convenient when modernizing a monolithic API by sitting the API Gateway in between the monolithic API and the client apps, then you can add new APIs as new microservices while still using the legacy monolithic API until it's split into many microservices in the future.</span></span> <span data-ttu-id="3e98c-199">因為 API 閘道的關係，用戶端應用程式不會注意到使用的 API 是實作成內部微服務或整合型 API，而且更重要的是，當整合型 API 演進並重構成微服務時，因為有 API 閘道路由，用戶端應用程式不會受任何 URI 變更影響。</span><span class="sxs-lookup"><span data-stu-id="3e98c-199">Because of the API Gateway, the client apps won't notice if the APIs being used are implemented as internal microservices or a monolithic API and more importantly, when evolving and refactoring the monolithic API into microservices, thanks to the API Gateway routing, client apps won't be impacted with any URI change.</span></span>

<span data-ttu-id="3e98c-200">如需詳細資訊，請參閱[閘道路由模式](https://docs.microsoft.com/azure/architecture/patterns/gateway-routing)。</span><span class="sxs-lookup"><span data-stu-id="3e98c-200">For more information, see [Gateway routing pattern](https://docs.microsoft.com/azure/architecture/patterns/gateway-routing).</span></span>

<span data-ttu-id="3e98c-201">**要求彙總。**</span><span class="sxs-lookup"><span data-stu-id="3e98c-201">**Requests aggregation.**</span></span> <span data-ttu-id="3e98c-202">在選擇閘道模式時，您可以將多個目標為多個內部微服務的用戶端要求 (通常是 HTTP 要求) 彙總成單一用戶端要求。</span><span class="sxs-lookup"><span data-stu-id="3e98c-202">As part of the gateway pattern you can aggregate multiple client requests (usually HTTP requests) targeting multiple internal microservices into a single client request.</span></span> <span data-ttu-id="3e98c-203">當用戶端頁面/畫面需要來自數個微服務的資訊時，此模式特別方便。</span><span class="sxs-lookup"><span data-stu-id="3e98c-203">This pattern is especially convenient when a client page/screen needs information from several microservices.</span></span> <span data-ttu-id="3e98c-204">使用此方法時，用戶端應用程式會傳送單一要求至 API 閘道，此閘道會將數個要求分派到內部微服務，然後彙總結果並將所有資訊傳送回用戶端應用程式。</span><span class="sxs-lookup"><span data-stu-id="3e98c-204">With this approach, the client app sends a single request to the API Gateway that dispatches several requests to the internal microservices and then aggregates the results and sends everything back to the client app.</span></span> <span data-ttu-id="3e98c-205">此設計模式的主要優點和目標是減少用戶端應用程式與後端 API 之間的對話，這對於從微服務上線的資料中心（例如行動應用程式或來自用戶端遠端瀏覽器中 JavaScript 的 SPA 應用程式）而言，這一點特別重要。</span><span class="sxs-lookup"><span data-stu-id="3e98c-205">The main benefit and goal of this design pattern is to reduce chattiness between the client apps and the backend API, which is especially important for remote apps out of the datacenter where the microservices live, like mobile apps or requests coming from SPA apps that come from JavaScript in client remote browsers.</span></span> <span data-ttu-id="3e98c-206">針對在伺服器環境中執行要求的一般 Web 應用程式 (如 ASP.NET Core MVC Web 應用程式) 來說，此模式就不是那麼重要，因為其延遲遠小於遠端用戶端應用程式。</span><span class="sxs-lookup"><span data-stu-id="3e98c-206">For regular web apps performing the requests in the server environment (like an ASP.NET Core MVC web app), this pattern is not so important as the latency is very much smaller than for remote client apps.</span></span>

<span data-ttu-id="3e98c-207">視您使用的 API 閘道產品而定，它可能可以執行此彙總。</span><span class="sxs-lookup"><span data-stu-id="3e98c-207">Depending on the API Gateway product you use, it might be able to perform this aggregation.</span></span> <span data-ttu-id="3e98c-208">不過在許多情況下，於 API 閘道的範圍內建立彙總微服務會更有彈性，因此建議您在程式碼 (亦即 C# 程式碼) 中定義彙總：</span><span class="sxs-lookup"><span data-stu-id="3e98c-208">However, in many cases it's more flexible to create aggregation microservices under the scope of the API Gateway, so you define the aggregation in code (that is, C# code):</span></span>

<span data-ttu-id="3e98c-209">如需詳細資訊，請參閱[閘道彙總模式](https://docs.microsoft.com/azure/architecture/patterns/gateway-aggregation)。</span><span class="sxs-lookup"><span data-stu-id="3e98c-209">For more information, see [Gateway aggregation pattern](https://docs.microsoft.com/azure/architecture/patterns/gateway-aggregation).</span></span>

<span data-ttu-id="3e98c-210">**跨領域考量或閘道卸載。**</span><span class="sxs-lookup"><span data-stu-id="3e98c-210">**Cross-cutting concerns or gateway offloading.**</span></span> <span data-ttu-id="3e98c-211">視每個 API 閘道產品提供的功能而定，您可以將功能從個別微服務卸載，以藉由將跨領域考量合併至一個階層來簡化每個微服務的實作。</span><span class="sxs-lookup"><span data-stu-id="3e98c-211">Depending on the features offered by each API Gateway product, you can offload functionality from individual microservices to the gateway, which simplifies the implementation of each microservice by consolidating cross-cutting concerns into one tier.</span></span> <span data-ttu-id="3e98c-212">這對於要在每個內部微服務中正確實作會很複雜的特殊功能來說格外方便，例如以下功能：</span><span class="sxs-lookup"><span data-stu-id="3e98c-212">This is especially convenient for specialized features that can be complex to implement properly in every internal microservice, such as the following functionality:</span></span>

- <span data-ttu-id="3e98c-213">驗證與授權</span><span class="sxs-lookup"><span data-stu-id="3e98c-213">Authentication and authorization</span></span>
- <span data-ttu-id="3e98c-214">服務探索整合</span><span class="sxs-lookup"><span data-stu-id="3e98c-214">Service discovery integration</span></span>
- <span data-ttu-id="3e98c-215">回應快取</span><span class="sxs-lookup"><span data-stu-id="3e98c-215">Response caching</span></span>
- <span data-ttu-id="3e98c-216">重試原則、斷路器和 QoS</span><span class="sxs-lookup"><span data-stu-id="3e98c-216">Retry policies, circuit breaker, and QoS</span></span>
- <span data-ttu-id="3e98c-217">速率限制和節流</span><span class="sxs-lookup"><span data-stu-id="3e98c-217">Rate limiting and throttling</span></span>
- <span data-ttu-id="3e98c-218">負載平衡</span><span class="sxs-lookup"><span data-stu-id="3e98c-218">Load balancing</span></span>
- <span data-ttu-id="3e98c-219">記錄、追蹤、相互關聯</span><span class="sxs-lookup"><span data-stu-id="3e98c-219">Logging, tracing, correlation</span></span>
- <span data-ttu-id="3e98c-220">標頭、查詢字串和宣告轉換</span><span class="sxs-lookup"><span data-stu-id="3e98c-220">Headers, query strings, and claims transformation</span></span>
- <span data-ttu-id="3e98c-221">IP 允許清單</span><span class="sxs-lookup"><span data-stu-id="3e98c-221">IP whitelisting</span></span>

<span data-ttu-id="3e98c-222">如需詳細資訊，請參閱[閘道卸載模式](https://docs.microsoft.com/azure/architecture/patterns/gateway-offloading)。</span><span class="sxs-lookup"><span data-stu-id="3e98c-222">For more information, see [Gateway offloading pattern](https://docs.microsoft.com/azure/architecture/patterns/gateway-offloading).</span></span>

## <a name="using-products-with-api-gateway-features"></a><span data-ttu-id="3e98c-223">使用具備 API 閘道功能的產品</span><span class="sxs-lookup"><span data-stu-id="3e98c-223">Using products with API Gateway features</span></span>

<span data-ttu-id="3e98c-224">視每個實作而定，API 閘道產品可以提供更多跨領域考量。</span><span class="sxs-lookup"><span data-stu-id="3e98c-224">There can be many more cross-cutting concerns offered by the API Gateways products depending on each implementation.</span></span> <span data-ttu-id="3e98c-225">我們會探討以下項目：</span><span class="sxs-lookup"><span data-stu-id="3e98c-225">We'll explore here:</span></span>

- [<span data-ttu-id="3e98c-226">Azure API 管理</span><span class="sxs-lookup"><span data-stu-id="3e98c-226">Azure API Management</span></span>](https://azure.microsoft.com/services/api-management/)
- [<span data-ttu-id="3e98c-227">Ocelot</span><span class="sxs-lookup"><span data-stu-id="3e98c-227">Ocelot</span></span>](https://github.com/ThreeMammals/Ocelot)

### <a name="azure-api-management"></a><span data-ttu-id="3e98c-228">Azure API 管理</span><span class="sxs-lookup"><span data-stu-id="3e98c-228">Azure API Management</span></span>

<span data-ttu-id="3e98c-229">[Azure API 管理](https://azure.microsoft.com/services/api-management/) (如圖 4-14 所示) 不但可以解決您的 API 閘道需求，還能提供如從 API 收集見解等功能。</span><span class="sxs-lookup"><span data-stu-id="3e98c-229">[Azure API Management](https://azure.microsoft.com/services/api-management/) (as shown in Figure 4-14) not only solves your API Gateway needs but provides features like gathering insights from your APIs.</span></span> <span data-ttu-id="3e98c-230">如果您使用 API 管理解決方案，則 API 閘道只是該完整 API 管理解決方案內的元件。</span><span class="sxs-lookup"><span data-stu-id="3e98c-230">If you're using an API management solution, an API Gateway is only a component within that full API management solution.</span></span>

![此圖顯示如何使用 Azure API 管理作為 API 閘道。](./media/direct-client-to-microservice-communication-versus-the-API-Gateway-pattern/api-gateway-azure-api-management.png)

<span data-ttu-id="3e98c-232">**圖 4-14**.</span><span class="sxs-lookup"><span data-stu-id="3e98c-232">**Figure 4-14**.</span></span> <span data-ttu-id="3e98c-233">將 Azure API 管理用於 API 閘道</span><span class="sxs-lookup"><span data-stu-id="3e98c-233">Using Azure API Management for your API Gateway</span></span>

<span data-ttu-id="3e98c-234">Azure API 管理可解決您的 API 閘道和管理需求，例如記錄、安全性、計量等等。在此情況下，使用 Azure API 管理之類的產品時，您可能會有單一 API 閘道不會有風險，因為這類 API 閘道是「精簡」的，這表示您不會執行可能演變為整合型元件的自訂 c # 程式碼。</span><span class="sxs-lookup"><span data-stu-id="3e98c-234">Azure API Management solves both your API Gateway and Management needs like logging, security, metering, etc. In this case, when using a product like Azure API Management, the fact that you might have a single API Gateway is not so risky because these kinds of API Gateways are "thinner", meaning that you don't implement custom C# code that could evolve towards a monolithic component.</span></span>

<span data-ttu-id="3e98c-235">API 閘道產品的作用通常像是連入通訊的反向 Proxy，您也可以篩選內部微服務的 API，以及在此單一階層中將授權套用至已發行的 API。</span><span class="sxs-lookup"><span data-stu-id="3e98c-235">The API Gateway products usually act like a reverse proxy for ingress communication, where you can also filter the APIs from the internal microservices plus apply authorization to the published APIs in this single tier.</span></span>

<span data-ttu-id="3e98c-236">可從 API 管理系統取得的深入資訊可幫助您了解 API 使用方式和其執行方式。</span><span class="sxs-lookup"><span data-stu-id="3e98c-236">The insights available from an API Management system help you get an understanding of how your APIs are being used and how they are performing.</span></span> <span data-ttu-id="3e98c-237">作法是讓您檢視接近即時的分析報表，以及識別可能會影響您商務的趨勢。</span><span class="sxs-lookup"><span data-stu-id="3e98c-237">They do this by letting you view near real-time analytics reports and identifying trends that might impact your business.</span></span> <span data-ttu-id="3e98c-238">此外，您可能會有要求和回應活動的記錄，以進行進一步線上及離線分析。</span><span class="sxs-lookup"><span data-stu-id="3e98c-238">Plus, you can have logs about request and response activity for further online and offline analysis.</span></span>

<span data-ttu-id="3e98c-239">使用 Azure API 管理，您可以使用金鑰、權杖和 IP 篩選來保護 API。</span><span class="sxs-lookup"><span data-stu-id="3e98c-239">With Azure API Management, you can secure your APIs using a key, a token, and IP filtering.</span></span> <span data-ttu-id="3e98c-240">這些功能可讓您強制執行彈性且微調的配額和速率限制、使用原則修改您 API 的形狀和行為，並改善快取回應的效能。</span><span class="sxs-lookup"><span data-stu-id="3e98c-240">These features let you enforce flexible and fine-grained quotas and rate limits, modify the shape and behavior of your APIs using policies, and improve performance with response caching.</span></span>

<span data-ttu-id="3e98c-241">在本指南和參考範例應用程式 (eShopOnContainers) 中，架構會限制在較簡單且自訂容器化的架構，以專注於一般容器，而不需要使用 Azure API 管理這類 PaaS 產品。</span><span class="sxs-lookup"><span data-stu-id="3e98c-241">In this guide and the reference sample application (eShopOnContainers), the architecture is limited to a simpler and custom-made containerized architecture in order to focus on plain containers without using PaaS products like Azure API Management.</span></span> <span data-ttu-id="3e98c-242">但對於部署至 Microsoft Azure 的大型微服務型應用程式，建議您考慮以 API Azure API 管理作為生產環境中的 API 閘道基底。</span><span class="sxs-lookup"><span data-stu-id="3e98c-242">But for large microservice-based applications that are deployed into Microsoft Azure, we encourage you to evaluate Azure API Management as the base for your API Gateways in production.</span></span>

### <a name="ocelot"></a><span data-ttu-id="3e98c-243">Ocelot</span><span class="sxs-lookup"><span data-stu-id="3e98c-243">Ocelot</span></span>

<span data-ttu-id="3e98c-244">[Ocelot](https://github.com/ThreeMammals/Ocelot) 是輕量型 API 閘道，如需較簡單的方法建議加以採用。</span><span class="sxs-lookup"><span data-stu-id="3e98c-244">[Ocelot](https://github.com/ThreeMammals/Ocelot) is a lightweight API Gateway, recommended for simpler approaches.</span></span> <span data-ttu-id="3e98c-245">Ocelot 是開放原始碼的 .NET Core 型 API 閘道，特別針對需要在其系統中整合進入點的微服務架構而建立。</span><span class="sxs-lookup"><span data-stu-id="3e98c-245">Ocelot is an Open Source .NET Core-based API Gateway especially made for microservices architectures that need unified points of entry into their systems.</span></span> <span data-ttu-id="3e98c-246">它既輕量又快速，而且可在許多其他功能之間提供路由和驗證。</span><span class="sxs-lookup"><span data-stu-id="3e98c-246">It's lightweight, fast, and scalable and provides routing and authentication among many other features.</span></span>

<span data-ttu-id="3e98c-247">為[eShopOnContainers 參考應用程式](https://github.com/dotnet-architecture/eShopOnContainers)選擇 Ocelot 的主要原因是，Ocelot 是一個 .net Core 輕量 API 閘道，您可以將其部署到部署微服務/容器的相同應用程式部署環境，例如 Docker 主機、Kubernetes 等。而且因為它是以 .NET Core 為基礎，所以它是跨平臺，可讓您在 Linux 或 Windows 上進行部署。</span><span class="sxs-lookup"><span data-stu-id="3e98c-247">The main reason to choose Ocelot for the [eShopOnContainers reference application](https://github.com/dotnet-architecture/eShopOnContainers) is because Ocelot is a .NET Core lightweight API Gateway that you can deploy into the same application deployment environment where you're deploying your microservices/containers, such as a Docker Host, Kubernetes, etc. And since it's based on .NET Core, it's cross-platform allowing you to deploy on Linux or Windows.</span></span>

<span data-ttu-id="3e98c-248">上面的圖表顯示在容器中執行的自訂 API 閘道，正如同您也可以在容器和微服務型應用程式中執行 Ocelot。</span><span class="sxs-lookup"><span data-stu-id="3e98c-248">The previous diagrams showing custom API Gateways running in containers are precisely how you can also run Ocelot in a container and microservice-based application.</span></span>

<span data-ttu-id="3e98c-249">此外，市場上許多其他產品也都提供 API 閘道功能，例如 Apigee、Kong、MuleSoft、WSO2，以及提供服務網格連入控制器功能的 Linkerd 和 Istio 等產品。</span><span class="sxs-lookup"><span data-stu-id="3e98c-249">In addition, there are many other products in the market offering API Gateways features, such as Apigee, Kong, MuleSoft, WSO2, and other products like Linkerd and Istio for service mesh ingress controller features.</span></span>

<span data-ttu-id="3e98c-250">在初始架構和模式探索的小節之後，以下各節說明如何搭配 [Ocelot](https://github.com/ThreeMammals/Ocelot) \(英文\) 實作 API 閘道。</span><span class="sxs-lookup"><span data-stu-id="3e98c-250">After the initial architecture and patterns explanation sections, the next sections explain how to implement API Gateways with [Ocelot](https://github.com/ThreeMammals/Ocelot).</span></span>

## <a name="drawbacks-of-the-api-gateway-pattern"></a><span data-ttu-id="3e98c-251">API 閘道模式的缺點</span><span class="sxs-lookup"><span data-stu-id="3e98c-251">Drawbacks of the API Gateway pattern</span></span>

- <span data-ttu-id="3e98c-252">最大的缺點在於當您實作 API 閘道時，會結合該階層與內部微服務。</span><span class="sxs-lookup"><span data-stu-id="3e98c-252">The most important drawback is that when you implement an API Gateway, you're coupling that tier with the internal microservices.</span></span> <span data-ttu-id="3e98c-253">這類結合可能會造成您應用程式的嚴重問題。</span><span class="sxs-lookup"><span data-stu-id="3e98c-253">Coupling like this might introduce serious difficulties for your application.</span></span> <span data-ttu-id="3e98c-254">Clemens Vaster 是 Azure 服務匯流排小組的架構設計人員，在 GOTO 2016 的 [Messaging and Microservices](https://www.youtube.com/watch?v=rXi5CLjIQ9k) \(傳訊和微服務\) 研討會中將這個潛在困難稱為「新的 ESB」。</span><span class="sxs-lookup"><span data-stu-id="3e98c-254">Clemens Vaster, architect at the Azure Service Bus team, refers to this potential difficulty as "the new ESB" in the "[Messaging and Microservices](https://www.youtube.com/watch?v=rXi5CLjIQ9k)" session at GOTO 2016.</span></span>

- <span data-ttu-id="3e98c-255">使用微服務 API 閘道會建立其他可能單一失敗點。</span><span class="sxs-lookup"><span data-stu-id="3e98c-255">Using a microservices API Gateway creates an additional possible single point of failure.</span></span>

- <span data-ttu-id="3e98c-256">API 閘道可能會導致因額外網路呼叫而增加回應時間。</span><span class="sxs-lookup"><span data-stu-id="3e98c-256">An API Gateway can introduce increased response time due to the additional network call.</span></span> <span data-ttu-id="3e98c-257">不過，這個額外呼叫的影響通常會小於擁有過於頻繁直接呼叫內部微服務的用戶端介面。</span><span class="sxs-lookup"><span data-stu-id="3e98c-257">However, this extra call usually has less impact than having a client interface that's too chatty directly calling the internal microservices.</span></span>

- <span data-ttu-id="3e98c-258">如果未正確地相應放大，則 API 閘道可能會成為瓶頸。</span><span class="sxs-lookup"><span data-stu-id="3e98c-258">If not scaled out properly, the API Gateway can become a bottleneck.</span></span>

- <span data-ttu-id="3e98c-259">如果 API 閘道包含自訂邏輯和資料彙總，則需要額外開發成本和未來維護。</span><span class="sxs-lookup"><span data-stu-id="3e98c-259">An API Gateway requires additional development cost and future maintenance if it includes custom logic and data aggregation.</span></span> <span data-ttu-id="3e98c-260">開發人員必須更新 API 閘道，才能公開每個微服務的端點。</span><span class="sxs-lookup"><span data-stu-id="3e98c-260">Developers must update the API Gateway in order to expose each microservice's endpoints.</span></span> <span data-ttu-id="3e98c-261">此外，內部微服務中的實作變更可能會導致 API 閘道層級的程式碼變更。</span><span class="sxs-lookup"><span data-stu-id="3e98c-261">Moreover, implementation changes in the internal microservices might cause code changes at the API Gateway level.</span></span> <span data-ttu-id="3e98c-262">不過，如果 API 閘道只會套用安全性、記錄和版本控制 (就像使用 Azure API 管理時一樣)，可能不會套用這個額外的開發成本。</span><span class="sxs-lookup"><span data-stu-id="3e98c-262">However, if the API Gateway is just applying security, logging, and versioning (as when using Azure API Management), this additional development cost might not apply.</span></span>

- <span data-ttu-id="3e98c-263">如果 API 閘道是由單一小組所開發，則可能會有開發瓶頸。</span><span class="sxs-lookup"><span data-stu-id="3e98c-263">If the API Gateway is developed by a single team, there can be a development bottleneck.</span></span> <span data-ttu-id="3e98c-264">這是較佳方法是具有數個回應不同用戶端需求之微調 API 閘道的另一個原因。</span><span class="sxs-lookup"><span data-stu-id="3e98c-264">This is another reason why a better approach is to have several fined-grained API Gateways that respond to different client needs.</span></span> <span data-ttu-id="3e98c-265">您也可以在內部將 API 閘道區分為處理內部微服務之不同小組所擁有的多個區域或層級。</span><span class="sxs-lookup"><span data-stu-id="3e98c-265">You could also segregate the API Gateway internally into multiple areas or layers that are owned by the different teams working on the internal microservices.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="3e98c-266">其他資源</span><span class="sxs-lookup"><span data-stu-id="3e98c-266">Additional resources</span></span>

- <span data-ttu-id="3e98c-267">**Chris Richardson。模式：適用于前端的 API 閘道/後端** </span><span class="sxs-lookup"><span data-stu-id="3e98c-267">**Chris Richardson. Pattern: API Gateway / Backend for Front-End** </span></span>\
  <https://microservices.io/patterns/apigateway.html>

- <span data-ttu-id="3e98c-268">**API 閘道模式** </span><span class="sxs-lookup"><span data-stu-id="3e98c-268">**API Gateway pattern** </span></span>\
  <https://docs.microsoft.com/azure/architecture/microservices/gateway>

- <span data-ttu-id="3e98c-269">**匯總和撰寫模式** </span><span class="sxs-lookup"><span data-stu-id="3e98c-269">**Aggregation and composition pattern** </span></span>\
  <https://microservices.io/patterns/data/api-composition.html>

- <span data-ttu-id="3e98c-270">**Azure API 管理** </span><span class="sxs-lookup"><span data-stu-id="3e98c-270">**Azure API Management** </span></span>\
  <https://azure.microsoft.com/services/api-management/>

- <span data-ttu-id="3e98c-271">**Udi Dahan。服務導向組合** </span><span class="sxs-lookup"><span data-stu-id="3e98c-271">**Udi Dahan. Service Oriented Composition** </span></span>\
  <https://udidahan.com/2014/07/30/service-oriented-composition-with-video/>

- <span data-ttu-id="3e98c-272">**Clemens Vasters。訊息和微服務，位於 GOTO 2016 （影片）** </span><span class="sxs-lookup"><span data-stu-id="3e98c-272">**Clemens Vasters. Messaging and Microservices at GOTO 2016 (video)** </span></span>\
  <https://www.youtube.com/watch?v=rXi5CLjIQ9k>

- <span data-ttu-id="3e98c-273">**Api 閘道**簡介（ASP.NET Core Api 閘道教學課程系列） </span><span class="sxs-lookup"><span data-stu-id="3e98c-273">**API Gateway in a Nutshell** (ASP.NET Core API Gateway Tutorial Series) </span></span>\
  <https://www.pogsdotnet.com/2018/08/api-gateway-in-nutshell.html>

>[!div class="step-by-step"]
><span data-ttu-id="3e98c-274">[上一個](identify-microservice-domain-model-boundaries.md) 
>[下一步](communication-in-microservice-architecture.md)</span><span class="sxs-lookup"><span data-stu-id="3e98c-274">[Previous](identify-microservice-domain-model-boundaries.md)
[Next](communication-in-microservice-architecture.md)</span></span>
