---
title: 設計 DDD 導向微服務
description: .NET 微服務：容器化 .NET 應用程式的架構 | 了解 DDD 導向的訂購微服務及其應用程式層的設計。
ms.date: 01/13/2021
ms.openlocfilehash: 1d17f0842bb371ce65e96f33d25b2d6e94493396
ms.sourcegitcommit: a4cecb7389f02c27e412b743f9189bd2a6dea4d6
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/14/2021
ms.locfileid: "98188331"
---
# <a name="design-a-ddd-oriented-microservice"></a><span data-ttu-id="d7e84-103">設計 DDD 導向微服務</span><span class="sxs-lookup"><span data-stu-id="d7e84-103">Design a DDD-oriented microservice</span></span>

<span data-ttu-id="d7e84-104">網域驅動設計 (DDD) 支援以與您的使用案例相關之商務實際情況建立模型。</span><span class="sxs-lookup"><span data-stu-id="d7e84-104">Domain-driven design (DDD) advocates modeling based on the reality of business as relevant to your use cases.</span></span> <span data-ttu-id="d7e84-105">在建置應用程式的內容中，DDD 會將問題作為領域討論。</span><span class="sxs-lookup"><span data-stu-id="d7e84-105">In the context of building applications, DDD talks about problems as domains.</span></span> <span data-ttu-id="d7e84-106">它將獨立問題區域描述為限定內容 (每個限定內容都與一個微服務相互關聯)，並強調討論這些問題的通用語言。</span><span class="sxs-lookup"><span data-stu-id="d7e84-106">It describes independent problem areas as Bounded Contexts (each Bounded Context correlates to a microservice), and emphasizes a common language to talk about these problems.</span></span> <span data-ttu-id="d7e84-107">它也會建議許多技術概念和模式，例如具有豐富模型的領域實體 (沒有 [anemic 領域模型](https://martinfowler.com/bliki/AnemicDomainModel.html)) 、值物件、匯總，以及匯總根 (或根實體) 規則來支援內部執行。</span><span class="sxs-lookup"><span data-stu-id="d7e84-107">It also suggests many technical concepts and patterns, like domain entities with rich models (no [anemic-domain model](https://martinfowler.com/bliki/AnemicDomainModel.html)), value objects, aggregates, and aggregate root (or root entity) rules to support the internal implementation.</span></span> <span data-ttu-id="d7e84-108">本節將介紹這些內部模式的設計及實作。</span><span class="sxs-lookup"><span data-stu-id="d7e84-108">This section introduces the design and implementation of those internal patterns.</span></span>

<span data-ttu-id="d7e84-109">有時候這些 DDD 技術規則和模式會被認為是實作 DDD 方法時具有陡峭學習曲線的障礙。</span><span class="sxs-lookup"><span data-stu-id="d7e84-109">Sometimes these DDD technical rules and patterns are perceived as obstacles that have a steep learning curve for implementing DDD approaches.</span></span> <span data-ttu-id="d7e84-110">但重要的並非模式本身，而是組織程式碼，使其能與商務問題校準，並使用相同的商務字詞 (通用語言)。</span><span class="sxs-lookup"><span data-stu-id="d7e84-110">But the important part is not the patterns themselves, but organizing the code so it is aligned to the business problems, and using the same business terms (ubiquitous language).</span></span> <span data-ttu-id="d7e84-111">此外，只有您在使用大量商務規則實作複雜的微服務時，才應套用 DDD 方法。</span><span class="sxs-lookup"><span data-stu-id="d7e84-111">In addition, DDD approaches should be applied only if you are implementing complex microservices with significant business rules.</span></span> <span data-ttu-id="d7e84-112">較簡單的責任，例如 CRUD 服務，可使用更為簡單的方法來管理。</span><span class="sxs-lookup"><span data-stu-id="d7e84-112">Simpler responsibilities, like a CRUD service, can be managed with simpler approaches.</span></span>

<span data-ttu-id="d7e84-113">如何劃定界線便是設計及定義微服務時的關鍵工作。</span><span class="sxs-lookup"><span data-stu-id="d7e84-113">Where to draw the boundaries is the key task when designing and defining a microservice.</span></span> <span data-ttu-id="d7e84-114">DDD 模式可協助您了解領域中的複雜度。</span><span class="sxs-lookup"><span data-stu-id="d7e84-114">DDD patterns help you understand the complexity in the domain.</span></span> <span data-ttu-id="d7e84-115">針對每一個限定內容的領域模型，您會識別並定義實體、值物件，以及為您的領域建立模型的彙總。</span><span class="sxs-lookup"><span data-stu-id="d7e84-115">For the domain model for each Bounded Context, you identify and define the entities, value objects, and aggregates that model your domain.</span></span> <span data-ttu-id="d7e84-116">您會建置並精簡化包含於定義您內容之界限內的領域模型。</span><span class="sxs-lookup"><span data-stu-id="d7e84-116">You build and refine a domain model that is contained within a boundary that defines your context.</span></span> <span data-ttu-id="d7e84-117">而且這是微服務形式的明確。</span><span class="sxs-lookup"><span data-stu-id="d7e84-117">And that is explicit in the form of a microservice.</span></span> <span data-ttu-id="d7e84-118">包含在那些界限內的元件最後會變成您的微服務，雖然在一些案例中，BC 或商務微服務可由數種實體服務組成。</span><span class="sxs-lookup"><span data-stu-id="d7e84-118">The components within those boundaries end up being your microservices, although in some cases a BC or business microservices can be composed of several physical services.</span></span> <span data-ttu-id="d7e84-119">DDD 與界限相關，微服務也一樣。</span><span class="sxs-lookup"><span data-stu-id="d7e84-119">DDD is about boundaries and so are microservices.</span></span>

## <a name="keep-the-microservice-context-boundaries-relatively-small"></a><span data-ttu-id="d7e84-120">讓微服務內容界限保持相對較小</span><span class="sxs-lookup"><span data-stu-id="d7e84-120">Keep the microservice context boundaries relatively small</span></span>

<span data-ttu-id="d7e84-121">決定在限定內容之間的何處放置界限，才能平衡兩個競爭的目標。</span><span class="sxs-lookup"><span data-stu-id="d7e84-121">Determining where to place boundaries between Bounded Contexts balances two competing goals.</span></span> <span data-ttu-id="d7e84-122">首先，您會希望在一開始盡可能的建立最小的微服務，即使那並不是最主要的驅策因素。您應在需要內聚的事物周圍建立界限。</span><span class="sxs-lookup"><span data-stu-id="d7e84-122">First, you want to initially create the smallest possible microservices, although that should not be the main driver; you should create a boundary around things that need cohesion.</span></span> <span data-ttu-id="d7e84-123">接著，您會想要避免任何微服務間多餘的通訊。</span><span class="sxs-lookup"><span data-stu-id="d7e84-123">Second, you want to avoid chatty communications between microservices.</span></span> <span data-ttu-id="d7e84-124">這些目標可能會彼此互相矛盾。</span><span class="sxs-lookup"><span data-stu-id="d7e84-124">These goals can contradict one another.</span></span> <span data-ttu-id="d7e84-125">您應該藉由盡可能的將系統分解為許多小型的微服務來平衡他們，直到您發現隨著每一次分離新限定內容的額外嘗試，通訊界限正迅速的成長。</span><span class="sxs-lookup"><span data-stu-id="d7e84-125">You should balance them by decomposing the system into as many small microservices as you can until you see communication boundaries growing quickly with each additional attempt to separate a new Bounded Context.</span></span> <span data-ttu-id="d7e84-126">內聚是單一限定內容中的關鍵。</span><span class="sxs-lookup"><span data-stu-id="d7e84-126">Cohesion is key within a single bounded context.</span></span>

<span data-ttu-id="d7e84-127">這與在實作類別時的 [Inappropriate Intimacy (程式碼不適當的親密性)](https://sourcemaking.com/refactoring/smells/inappropriate-intimacy) 相似。</span><span class="sxs-lookup"><span data-stu-id="d7e84-127">It is similar to the [Inappropriate Intimacy code smell](https://sourcemaking.com/refactoring/smells/inappropriate-intimacy) when implementing classes.</span></span> <span data-ttu-id="d7e84-128">若兩個微服務需要彼此進行大量的共同作業，他們便應該成為相同的一項微服務。</span><span class="sxs-lookup"><span data-stu-id="d7e84-128">If two microservices need to collaborate a lot with each other, they should probably be the same microservice.</span></span>

<span data-ttu-id="d7e84-129">另一種查看此層面的方法是自我管理。</span><span class="sxs-lookup"><span data-stu-id="d7e84-129">Another way to look at this aspect is autonomy.</span></span> <span data-ttu-id="d7e84-130">若微服務必須倚賴另外一個服務才能服務一項要求，它便不是真正的自主。</span><span class="sxs-lookup"><span data-stu-id="d7e84-130">If a microservice must rely on another service to directly service a request, it is not truly autonomous.</span></span>

## <a name="layers-in-ddd-microservices"></a><span data-ttu-id="d7e84-131">DDD 微服務中的層</span><span class="sxs-lookup"><span data-stu-id="d7e84-131">Layers in DDD microservices</span></span>

<span data-ttu-id="d7e84-132">大部分包含大量商務與技術複雜性的企業應用程式都會由多個層定義。</span><span class="sxs-lookup"><span data-stu-id="d7e84-132">Most enterprise applications with significant business and technical complexity are defined by multiple layers.</span></span> <span data-ttu-id="d7e84-133">「層」只是邏輯的成品，與服務的部署無關。</span><span class="sxs-lookup"><span data-stu-id="d7e84-133">The layers are a logical artifact, and are not related to the deployment of the service.</span></span> <span data-ttu-id="d7e84-134">他們存在的目的只是為了要協助開發人員管理程式碼中的複雜度。</span><span class="sxs-lookup"><span data-stu-id="d7e84-134">They exist to help developers manage the complexity in the code.</span></span> <span data-ttu-id="d7e84-135">不同層 (像是領域模型層和展示層等，) 可能會有不同的類型，這會在這些類型之間強制翻譯。</span><span class="sxs-lookup"><span data-stu-id="d7e84-135">Different layers (like the domain model layer versus the presentation layer, etc.) might have different types, which mandate translations between those types.</span></span>

<span data-ttu-id="d7e84-136">例如，實體可從資料庫載入。</span><span class="sxs-lookup"><span data-stu-id="d7e84-136">For example, an entity could be loaded from the database.</span></span> <span data-ttu-id="d7e84-137">然後該資訊的一部份，或是包含從其他實體取得之額外資料的資訊彙總，便可透過 REST Web API 傳送至用戶端 UI。</span><span class="sxs-lookup"><span data-stu-id="d7e84-137">Then part of that information, or an aggregation of information including additional data from other entities, can be sent to the client UI through a REST Web API.</span></span> <span data-ttu-id="d7e84-138">重點在於領域實體是包含在領域模型層中，不應散佈到其不屬於的其他區域，例如展示層。</span><span class="sxs-lookup"><span data-stu-id="d7e84-138">The point here is that the domain entity is contained within the domain model layer and should not be propagated to other areas that it does not belong to, like to the presentation layer.</span></span>

<span data-ttu-id="d7e84-139">此外，您需要讓彙總根 (根實體) 控制永遠有效的實體 (請參閱[在領域模型層中設計驗證](domain-model-layer-validations.md)一節)。</span><span class="sxs-lookup"><span data-stu-id="d7e84-139">Additionally, you need to have always-valid entities (see the [Designing validations in the domain model layer](domain-model-layer-validations.md) section) controlled by aggregate roots (root entities).</span></span> <span data-ttu-id="d7e84-140">因此，實體不應繫結於用戶端檢視，因為在 UI 層級中，有些資料可能尚未驗證。</span><span class="sxs-lookup"><span data-stu-id="d7e84-140">Therefore, entities should not be bound to client views, because at the UI level some data might still not be validated.</span></span> <span data-ttu-id="d7e84-141">這是 ViewModel 的目的。</span><span class="sxs-lookup"><span data-stu-id="d7e84-141">This reason is what the ViewModel is for.</span></span> <span data-ttu-id="d7e84-142">ViewModel 是一種僅針對展示層需求的資料模型。</span><span class="sxs-lookup"><span data-stu-id="d7e84-142">The ViewModel is a data model exclusively for presentation layer needs.</span></span> <span data-ttu-id="d7e84-143">領域實體不直接屬於 ViewModel。</span><span class="sxs-lookup"><span data-stu-id="d7e84-143">The domain entities do not belong directly to the ViewModel.</span></span> <span data-ttu-id="d7e84-144">相反地，您需要在 ViewModel 和領域實體之間進行轉換，反之亦然。</span><span class="sxs-lookup"><span data-stu-id="d7e84-144">Instead, you need to translate between ViewModels and domain entities and vice versa.</span></span>

<span data-ttu-id="d7e84-145">當處理複雜性時，擁有由確認所有與該實體群組 (彙總) 相關的不區分及規則都是透過單一進入點或閘道 (彙總根) 執行的彙總根控制的領域模型是非常重要的。</span><span class="sxs-lookup"><span data-stu-id="d7e84-145">When tackling complexity, it is important to have a domain model controlled by aggregate roots that make sure that all the invariants and rules related to that group of entities (aggregate) are performed through a single entry-point or gate, the aggregate root.</span></span>

<span data-ttu-id="d7e84-146">圖 7-5 顯示分層設計在 eShopOnContainer 應用程式中的實作方式。</span><span class="sxs-lookup"><span data-stu-id="d7e84-146">Figure 7-5 shows how a layered design is implemented in the eShopOnContainers application.</span></span>

![顯示領域驅動設計微服務中之圖層的圖表。](./media/ddd-oriented-microservice/domain-driven-design-microservice.png)

<span data-ttu-id="d7e84-148">**圖 7-5**.</span><span class="sxs-lookup"><span data-stu-id="d7e84-148">**Figure 7-5**.</span></span> <span data-ttu-id="d7e84-149">eShopOnContainers 訂購微服務中的 DDD 層</span><span class="sxs-lookup"><span data-stu-id="d7e84-149">DDD layers in the ordering microservice in eShopOnContainers</span></span>

<span data-ttu-id="d7e84-150">訂購等 DDD 微服務中的三層。</span><span class="sxs-lookup"><span data-stu-id="d7e84-150">The three layers in a DDD microservice like Ordering.</span></span> <span data-ttu-id="d7e84-151">每一層都是 VS 專案：應用程式層是 Ordering.API、領域層是 Ordering.Domain，而基礎結構層是 Ordering.Infrastructure。</span><span class="sxs-lookup"><span data-stu-id="d7e84-151">Each layer is a VS project: Application layer is Ordering.API, Domain layer is Ordering.Domain and the Infrastructure layer is Ordering.Infrastructure.</span></span> <span data-ttu-id="d7e84-152">您會希望將系統設計成每一個層都只會跟特定的其他層通訊。</span><span class="sxs-lookup"><span data-stu-id="d7e84-152">You want to design the system so that each layer communicates only with certain other layers.</span></span> <span data-ttu-id="d7e84-153">如果將圖層實作為不同的類別庫，則該方法可能更容易強制執行，因為您可以清楚地識別程式庫間設定的相依性。</span><span class="sxs-lookup"><span data-stu-id="d7e84-153">That approach may be easier to enforce if layers are implemented as different class libraries, because you can clearly identify what dependencies are set between libraries.</span></span> <span data-ttu-id="d7e84-154">例如，領域模型層不應該相依於任何其他的層 (領域模型類別應為簡單的 CLR 物件 ([POCO](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object)) 類別)。</span><span class="sxs-lookup"><span data-stu-id="d7e84-154">For instance, the domain model layer should not take a dependency on any other layer (the domain model classes should be Plain Old CLR Objects, or [POCO](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object), classes).</span></span> <span data-ttu-id="d7e84-155">如 [圖 7-6] 所示，「 **網域** 層程式庫」只在 .net 程式庫或 NuGet 套件上具有相依性，而不是在其他任何自訂程式庫上，例如資料連結庫或持續性程式庫。</span><span class="sxs-lookup"><span data-stu-id="d7e84-155">As shown in Figure 7-6, the **Ordering.Domain** layer library has dependencies only on the .NET libraries or NuGet packages, but not on any other custom library, such as data library or persistence library.</span></span>

![排序網域相依性的螢幕擷取畫面。](./media/ddd-oriented-microservice/ordering-domain-dependencies.png)

<span data-ttu-id="d7e84-157">**圖 7-6**。</span><span class="sxs-lookup"><span data-stu-id="d7e84-157">**Figure 7-6**.</span></span> <span data-ttu-id="d7e84-158">作為程式庫實作的層允許對層之間的相依性進行更佳的控制</span><span class="sxs-lookup"><span data-stu-id="d7e84-158">Layers implemented as libraries allow better control of dependencies between layers</span></span>

### <a name="the-domain-model-layer"></a><span data-ttu-id="d7e84-159">領域模型層</span><span class="sxs-lookup"><span data-stu-id="d7e84-159">The domain model layer</span></span>

<span data-ttu-id="d7e84-160">Eric Evans 的優良書籍 [Domain Driven Design (領域驅動設計)](https://domainlanguage.com/ddd/) 提到了下列關於領域模型層及應用程式層的內容。</span><span class="sxs-lookup"><span data-stu-id="d7e84-160">Eric Evans's excellent book [Domain Driven Design](https://domainlanguage.com/ddd/) says the following about the domain model layer and the application layer.</span></span>

<span data-ttu-id="d7e84-161">**領域模型層** 負責呈現商務概念、商務情況的資訊，以及商務規則。</span><span class="sxs-lookup"><span data-stu-id="d7e84-161">**Domain Model Layer**: Responsible for representing concepts of the business, information about the business situation, and business rules.</span></span> <span data-ttu-id="d7e84-162">反映商務情況的狀態會受控並用於此處，即使儲存它的技術細節已委派給基礎結構。</span><span class="sxs-lookup"><span data-stu-id="d7e84-162">State that reflects the business situation is controlled and used here, even though the technical details of storing it are delegated to the infrastructure.</span></span> <span data-ttu-id="d7e84-163">此層是商務軟體的核心。</span><span class="sxs-lookup"><span data-stu-id="d7e84-163">This layer is the heart of business software.</span></span>

<span data-ttu-id="d7e84-164">領域模型層是表達商務的地方。</span><span class="sxs-lookup"><span data-stu-id="d7e84-164">The domain model layer is where the business is expressed.</span></span> <span data-ttu-id="d7e84-165">當您在 .NET 中實作微服務領域模型層時，該層會編碼為帶有擷取資料與行為 (帶有邏輯的方法) 之領域實體的類別庫。</span><span class="sxs-lookup"><span data-stu-id="d7e84-165">When you implement a microservice domain model layer in .NET, that layer is coded as a class library with the domain entities that capture data plus behavior (methods with logic).</span></span>

<span data-ttu-id="d7e84-166">遵循 [Persistence Ignorance (永續性無知)](https://deviq.com/persistence-ignorance/) 與 [Infrastructure Ignorance (基礎結構無知)](https://ayende.com/blog/3137/infrastructure-ignorance) 準則，此層必須完全忽略資料永續性詳細資料。</span><span class="sxs-lookup"><span data-stu-id="d7e84-166">Following the [Persistence Ignorance](https://deviq.com/persistence-ignorance/) and the [Infrastructure Ignorance](https://ayende.com/blog/3137/infrastructure-ignorance) principles, this layer must completely ignore data persistence details.</span></span> <span data-ttu-id="d7e84-167">這些永續性工作應由基礎結構層執行。</span><span class="sxs-lookup"><span data-stu-id="d7e84-167">These persistence tasks should be performed by the infrastructure layer.</span></span> <span data-ttu-id="d7e84-168">因此，此層不應直接相依於基礎結構。這表示讓您的領域模型實體類別為 [POCO](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object) 是非常重要的一項規則。</span><span class="sxs-lookup"><span data-stu-id="d7e84-168">Therefore, this layer should not take direct dependencies on the infrastructure, which means that an important rule is that your domain model entity classes should be [POCO](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object)s.</span></span>

<span data-ttu-id="d7e84-169">領域實體不應直接相依 (例如衍生自基底類別) 於任何資料存取基礎結構架構，例如 Entity Framework 或 NHibernate。</span><span class="sxs-lookup"><span data-stu-id="d7e84-169">Domain entities should not have any direct dependency (like deriving from a base class) on any data access infrastructure framework like Entity Framework or NHibernate.</span></span> <span data-ttu-id="d7e84-170">在理想情況下，您的領域實體不應衍生自或實作在任何基礎結構架構中定義的任何類型。</span><span class="sxs-lookup"><span data-stu-id="d7e84-170">Ideally, your domain entities should not derive from or implement any type defined in any infrastructure framework.</span></span>

<span data-ttu-id="d7e84-171">大多數的現代 ORM 架構 (例如 Entity Framework Core) 允許這種方法，以使您的領域模型類別不會與基礎結構結合。</span><span class="sxs-lookup"><span data-stu-id="d7e84-171">Most modern ORM frameworks like Entity Framework Core allow this approach, so that your domain model classes are not coupled to the infrastructure.</span></span> <span data-ttu-id="d7e84-172">然而，在使用特定 NoSQL 資料庫及架構，例如 Azure Service Fabric 中的動作項目及可靠集合時，不見得都能擁有 POCO 實體。</span><span class="sxs-lookup"><span data-stu-id="d7e84-172">However, having POCO entities is not always possible when using certain NoSQL databases and frameworks, like Actors and Reliable Collections in Azure Service Fabric.</span></span>

<span data-ttu-id="d7e84-173">即使針對您的領域模型遵循永續性無知準則是非常重要的，您也不應忽略永續性考量。</span><span class="sxs-lookup"><span data-stu-id="d7e84-173">Even when it is important to follow the Persistence Ignorance principle for your Domain model, you should not ignore persistence concerns.</span></span> <span data-ttu-id="d7e84-174">但請務必瞭解實體資料模型，以及它如何對應至您的實體物件模型。</span><span class="sxs-lookup"><span data-stu-id="d7e84-174">It is still important to understand the physical data model and how it maps to your entity object model.</span></span> <span data-ttu-id="d7e84-175">否則，您便可以建立不可能的設計。</span><span class="sxs-lookup"><span data-stu-id="d7e84-175">Otherwise you can create impossible designs.</span></span>

<span data-ttu-id="d7e84-176">此外，此層面並不表示您可以使用為關係資料庫設計的模型，並將它直接移至 NoSQL 或檔導向的資料庫。</span><span class="sxs-lookup"><span data-stu-id="d7e84-176">Also, this aspect does not mean you can take a model designed for a relational database and directly move it to a NoSQL or document-oriented database.</span></span> <span data-ttu-id="d7e84-177">在某些實體模型中，模型可能會適合，但通常並不會。</span><span class="sxs-lookup"><span data-stu-id="d7e84-177">In some entity models, the model might fit, but usually it does not.</span></span> <span data-ttu-id="d7e84-178">您的實體模型仍然必須基於儲存技術和 ORM 技術遵守條件約束。</span><span class="sxs-lookup"><span data-stu-id="d7e84-178">There are still constraints that your entity model must adhere to, based both on the storage technology and ORM technology.</span></span>

### <a name="the-application-layer"></a><span data-ttu-id="d7e84-179">應用程式層</span><span class="sxs-lookup"><span data-stu-id="d7e84-179">The application layer</span></span>

<span data-ttu-id="d7e84-180">接下來移動到應用程式層，我們可以再次引用 Eric Evan 的書籍 [Domain Driven Design (領域驅動設計)](https://domainlanguage.com/ddd/)：</span><span class="sxs-lookup"><span data-stu-id="d7e84-180">Moving on to the application layer, we can again cite Eric Evans's book [Domain Driven Design](https://domainlanguage.com/ddd/):</span></span>

<span data-ttu-id="d7e84-181">**應用程式層：** 定義軟體應執行的工作，並指示表達性領域物件解決問題。</span><span class="sxs-lookup"><span data-stu-id="d7e84-181">**Application Layer:** Defines the jobs the software is supposed to do and directs the expressive domain objects to work out problems.</span></span> <span data-ttu-id="d7e84-182">此層負責的工作對於商務來說是有意義的，或是對與其他系統應用程式層進行的互動來說是必要的。</span><span class="sxs-lookup"><span data-stu-id="d7e84-182">The tasks this layer is responsible for are meaningful to the business or necessary for interaction with the application layers of other systems.</span></span> <span data-ttu-id="d7e84-183">此圖層會保持精簡。</span><span class="sxs-lookup"><span data-stu-id="d7e84-183">This layer is kept thin.</span></span> <span data-ttu-id="d7e84-184">它並不會包含商務規則或知識，而只負責協調工作並將工作委派給下一層領域物件的共同作業。</span><span class="sxs-lookup"><span data-stu-id="d7e84-184">It does not contain business rules or knowledge, but only coordinates tasks and delegates work to collaborations of domain objects in the next layer down.</span></span> <span data-ttu-id="d7e84-185">它不具有反映商務情況的狀態，但可以擁有反映使用者或程式工作進度的狀態。</span><span class="sxs-lookup"><span data-stu-id="d7e84-185">It does not have state reflecting the business situation, but it can have state that reflects the progress of a task for the user or the program.</span></span>

<span data-ttu-id="d7e84-186">.NET 中的微服務應用層通常會編碼為 ASP.NET Core Web API 專案。</span><span class="sxs-lookup"><span data-stu-id="d7e84-186">A microservice's application layer in .NET is commonly coded as an ASP.NET Core Web API project.</span></span> <span data-ttu-id="d7e84-187">專案會執行微服務的互動、遠端網路存取，以及從 UI 或用戶端應用程式使用的外部 Web Api。</span><span class="sxs-lookup"><span data-stu-id="d7e84-187">The project implements the microservice's interaction, remote network access, and the external Web APIs used from the UI or client apps.</span></span> <span data-ttu-id="d7e84-188">若使用的是 CQRS 方法，它便會包含查詢、微服務接受的命令，甚至是微服務之間的事件驅動通訊 (整合事件)。</span><span class="sxs-lookup"><span data-stu-id="d7e84-188">It includes queries if using a CQRS approach, commands accepted by the microservice, and even the event-driven communication between microservices (integration events).</span></span> <span data-ttu-id="d7e84-189">代表應用程式層的 ASP.NET Core Web API 不可包含商務規則或領域知識 (尤其是交易或更新的領域規則)。這些內容應該由領域模型類別庫擁有。</span><span class="sxs-lookup"><span data-stu-id="d7e84-189">The ASP.NET Core Web API that represents the application layer must not contain business rules or domain knowledge (especially domain rules for transactions or updates); these should be owned by the domain model class library.</span></span> <span data-ttu-id="d7e84-190">應用程式層應僅負責協調工作，而不可保有或定義任何領域狀態 (領域模型)。</span><span class="sxs-lookup"><span data-stu-id="d7e84-190">The application layer must only coordinate tasks and must not hold or define any domain state (domain model).</span></span> <span data-ttu-id="d7e84-191">它會將商務規則的執行委派給領域模型類別自身 (彙總根及領域實體)，而後者最後便會在那些領域實體中更新資料。</span><span class="sxs-lookup"><span data-stu-id="d7e84-191">It delegates the execution of business rules to the domain model classes themselves (aggregate roots and domain entities), which will ultimately update the data within those domain entities.</span></span>

<span data-ttu-id="d7e84-192">基本上，應用程式邏輯便是您實作所有相依於指定前端之使用案例的地方。</span><span class="sxs-lookup"><span data-stu-id="d7e84-192">Basically, the application logic is where you implement all use cases that depend on a given front end.</span></span> <span data-ttu-id="d7e84-193">例如，與 Web API 服務相關的實作。</span><span class="sxs-lookup"><span data-stu-id="d7e84-193">For example, the implementation related to a Web API service.</span></span>

<span data-ttu-id="d7e84-194">目標是位於領域模型層中的領域邏輯、其不區分、資料模型，以及相關的商務規則都必須完全獨立於展示層及應用程式層。</span><span class="sxs-lookup"><span data-stu-id="d7e84-194">The goal is that the domain logic in the domain model layer, its invariants, the data model, and related business rules must be completely independent from the presentation and application layers.</span></span> <span data-ttu-id="d7e84-195">最重要的是，領域模型層不可直接相依於任何基礎結構架構。</span><span class="sxs-lookup"><span data-stu-id="d7e84-195">Most of all, the domain model layer must not directly depend on any infrastructure framework.</span></span>

### <a name="the-infrastructure-layer"></a><span data-ttu-id="d7e84-196">基礎結構層</span><span class="sxs-lookup"><span data-stu-id="d7e84-196">The infrastructure layer</span></span>

<span data-ttu-id="d7e84-197">基礎結構層是一開始保有在領域實體 (記憶體中) 中的資料永續保存在資料庫或其他永續性存放區的方式。</span><span class="sxs-lookup"><span data-stu-id="d7e84-197">The infrastructure layer is how the data that is initially held in domain entities (in memory) is persisted in databases or another persistent store.</span></span> <span data-ttu-id="d7e84-198">其中一個範例便是使用 Entity Framework Core 程式碼來實作使用 DBContext 來將資料永續存放在關聯式資料庫中的存放庫模式類別。</span><span class="sxs-lookup"><span data-stu-id="d7e84-198">An example is using Entity Framework Core code to implement the Repository pattern classes that use a DBContext to persist data in a relational database.</span></span>

<span data-ttu-id="d7e84-199">根據先前所述的 [持續性無知](https://deviq.com/persistence-ignorance/) 和 [基礎結構無知](https://ayende.com/blog/3137/infrastructure-ignorance) 準則，基礎結構層不能「污染」網域模型層。</span><span class="sxs-lookup"><span data-stu-id="d7e84-199">In accordance with the previously mentioned [Persistence Ignorance](https://deviq.com/persistence-ignorance/) and [Infrastructure Ignorance](https://ayende.com/blog/3137/infrastructure-ignorance) principles, the infrastructure layer must not "contaminate" the domain model layer.</span></span> <span data-ttu-id="d7e84-200">您必須透過使其對架構不具有硬式相依性，來讓領域模型實體類別保持無從得知您用來永續保存資料的基礎結構 (EF 或其他任何架構)。</span><span class="sxs-lookup"><span data-stu-id="d7e84-200">You must keep the domain model entity classes agnostic from the infrastructure that you use to persist data (EF or any other framework) by not taking hard dependencies on frameworks.</span></span> <span data-ttu-id="d7e84-201">您的領域模型層類別庫應僅具有您的領域程式碼，即只有實作您軟體核心的 [POCO](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object)，並且完全與基礎技術分開。</span><span class="sxs-lookup"><span data-stu-id="d7e84-201">Your domain model layer class library should have only your domain code, just [POCO](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object) entity classes implementing the heart of your software and completely decoupled from infrastructure technologies.</span></span>

<span data-ttu-id="d7e84-202">因此，您的層或類別庫及專案最後應相依於您的領域模型層 (程式庫)，而不是反過來也一樣，如圖 7-7 所示。</span><span class="sxs-lookup"><span data-stu-id="d7e84-202">Thus, your layers or class libraries and projects should ultimately depend on your domain model layer (library), not vice versa, as shown in Figure 7-7.</span></span>

![顯示 DDD 服務層級之間存在相依性的圖表。](./media/ddd-oriented-microservice/ddd-service-layer-dependencies.png)

<span data-ttu-id="d7e84-204">**圖 7-7**。</span><span class="sxs-lookup"><span data-stu-id="d7e84-204">**Figure 7-7**.</span></span> <span data-ttu-id="d7e84-205">DDD 中層之間的相依性</span><span class="sxs-lookup"><span data-stu-id="d7e84-205">Dependencies between layers in DDD</span></span>

<span data-ttu-id="d7e84-206">DDD 服務中的相依性，應用程式層相依於領域和基礎結構，基礎結構相依於網域，但網域不相依於任一層。</span><span class="sxs-lookup"><span data-stu-id="d7e84-206">Dependencies in a DDD Service, the Application layer depends on Domain and Infrastructure, and Infrastructure depends on Domain, but Domain doesn't depend on any layer.</span></span> <span data-ttu-id="d7e84-207">針對每一個微服務，此層應獨立設計。</span><span class="sxs-lookup"><span data-stu-id="d7e84-207">This layer design should be independent for each microservice.</span></span> <span data-ttu-id="d7e84-208">如前文所述，您可以遵循 DDD 模式來實作最複雜的微服務，同時卻能以更簡單的方式實作更簡單的資料驅動微服務 (於單一層中的簡單 CRUD)。</span><span class="sxs-lookup"><span data-stu-id="d7e84-208">As noted earlier, you can implement the most complex microservices following DDD patterns, while implementing simpler data-driven microservices (simple CRUD in a single layer) in a simpler way.</span></span>

#### <a name="additional-resources"></a><span data-ttu-id="d7e84-209">其他資源</span><span class="sxs-lookup"><span data-stu-id="d7e84-209">Additional resources</span></span>

- <span data-ttu-id="d7e84-210">**DevIQ.持續性無知準則** </span><span class="sxs-lookup"><span data-stu-id="d7e84-210">**DevIQ. Persistence Ignorance principle** </span></span>\
  <https://deviq.com/persistence-ignorance/>

- <span data-ttu-id="d7e84-211">**Oren Eini。基礎結構無知** </span><span class="sxs-lookup"><span data-stu-id="d7e84-211">**Oren Eini. Infrastructure Ignorance** </span></span>\
  <https://ayende.com/blog/3137/infrastructure-ignorance>

- <span data-ttu-id="d7e84-212">**天使 Lopez。Domain-Driven 設計中的分層架構** </span><span class="sxs-lookup"><span data-stu-id="d7e84-212">**Angel Lopez. Layered Architecture In Domain-Driven Design** </span></span>\
  <https://ajlopez.wordpress.com/2008/09/12/layered-architecture-in-domain-driven-design/>

>[!div class="step-by-step"]
><span data-ttu-id="d7e84-213">[上一個](cqrs-microservice-reads.md) 
>[下一步](microservice-domain-model.md)</span><span class="sxs-lookup"><span data-stu-id="d7e84-213">[Previous](cqrs-microservice-reads.md)
[Next](microservice-domain-model.md)</span></span>
