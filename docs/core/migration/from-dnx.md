---
title: 從 DNX 移轉到 .NET Core CLI
description: 從使用 DNX 工具移轉為 .NET Core CLI 工具。
ms.date: 06/20/2016
ms.openlocfilehash: e5ebbab2551cf750a5b1136e7b1d4b67816c3b03
ms.sourcegitcommit: bf5c5850654187705bc94cc40ebfb62fe346ab02
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 09/23/2020
ms.locfileid: "91071114"
---
# <a name="migrating-from-dnx-to-net-core-cli-projectjson"></a><span data-ttu-id="f9a71-103">從 DNX 移轉到 .NET Core CLI (project.json)</span><span class="sxs-lookup"><span data-stu-id="f9a71-103">Migrating from DNX to .NET Core CLI (project.json)</span></span>

## <a name="overview"></a><span data-ttu-id="f9a71-104">概觀</span><span class="sxs-lookup"><span data-stu-id="f9a71-104">Overview</span></span>

<span data-ttu-id="f9a71-105">.NET Core 的 RC1 版本與 ASP.NET Core 1.0 引進了 DNX 工具。</span><span class="sxs-lookup"><span data-stu-id="f9a71-105">The RC1 release of .NET Core and ASP.NET Core 1.0 introduced DNX tooling.</span></span> <span data-ttu-id="f9a71-106">.NET Core 的 RC2 版本與 ASP.NET Core 1.0 則從 DNX 進展到了 .NET Core CLI。</span><span class="sxs-lookup"><span data-stu-id="f9a71-106">The RC2 release of .NET Core and ASP.NET Core 1.0 moved from DNX to the .NET Core CLI.</span></span>

<span data-ttu-id="f9a71-107">現在，讓我們稍微複習一下什麼是 DNX。</span><span class="sxs-lookup"><span data-stu-id="f9a71-107">As a slight refresher, let's recap what DNX was about.</span></span> <span data-ttu-id="f9a71-108">DNX 是一種執行階段和工具組，可用來建置 .NET Core 和 ASP.NET Core 1.0 應用程式。</span><span class="sxs-lookup"><span data-stu-id="f9a71-108">DNX was a runtime and a toolset used to build .NET Core and, more specifically, ASP.NET Core 1.0 applications.</span></span> <span data-ttu-id="f9a71-109">它由 3 個主要部分所組成：</span><span class="sxs-lookup"><span data-stu-id="f9a71-109">It consisted of 3 main pieces:</span></span>

1. <span data-ttu-id="f9a71-110">DNVM - 可取得 DNX 的安裝指令碼</span><span class="sxs-lookup"><span data-stu-id="f9a71-110">DNVM - an install script for obtaining DNX</span></span>
2. <span data-ttu-id="f9a71-111">DNX (Dotnet 執行階段) - 執行程式碼的執行階段</span><span class="sxs-lookup"><span data-stu-id="f9a71-111">DNX (Dotnet Execution Runtime) - the runtime that executes your code</span></span>
3. <span data-ttu-id="f9a71-112">DNU (Dotnet 開發人員公用程式) - 可管理相依性、建置並發佈應用程式的工具</span><span class="sxs-lookup"><span data-stu-id="f9a71-112">DNU (Dotnet Developer Utility) - tooling for managing dependencies, building and publishing your applications</span></span>

<span data-ttu-id="f9a71-113">現在，引進 CLI 之後，單一工具組即包含上述所有項目。</span><span class="sxs-lookup"><span data-stu-id="f9a71-113">With the introduction of the CLI, all of the above are now part of a single toolset.</span></span> <span data-ttu-id="f9a71-114">不過，由於 DNX 是在 RC1 時間範圍內可供使用，因此您可能會想將使用它所建置的專案移出至新的 CLI 工具。</span><span class="sxs-lookup"><span data-stu-id="f9a71-114">However, since DNX was available in RC1 timeframe, you might have projects that were built using it that you would want to move off to the new CLI tooling.</span></span>

<span data-ttu-id="f9a71-115">本移轉指南說明如何將專案從 DNX 移轉至 .NET Core CLI 的基本資訊。</span><span class="sxs-lookup"><span data-stu-id="f9a71-115">This migration guide will cover the essentials on how to migrate projects off of DNX and onto .NET Core CLI.</span></span> <span data-ttu-id="f9a71-116">如果您一開始就是從 .NET Core 開始專案，可放心略過這份文件。</span><span class="sxs-lookup"><span data-stu-id="f9a71-116">If you are just starting a project on .NET Core from scratch, you can freely skip this document.</span></span>

## <a name="main-changes-in-the-tooling"></a><span data-ttu-id="f9a71-117">工具的主要變更</span><span class="sxs-lookup"><span data-stu-id="f9a71-117">Main changes in the tooling</span></span>

<span data-ttu-id="f9a71-118">首先，我們必須先概述這項工具的幾個一般變更。</span><span class="sxs-lookup"><span data-stu-id="f9a71-118">There are some general changes in the tooling that should be outlined first.</span></span>

### <a name="no-more-dnvm"></a><span data-ttu-id="f9a71-119">不再有 DNVM</span><span class="sxs-lookup"><span data-stu-id="f9a71-119">No more DNVM</span></span>

<span data-ttu-id="f9a71-120">DNVM 是「DotNet 版本管理員」\*\* 的簡稱，其為一種可用來在電腦上安裝 DNX 的 Bash/PowerShell 指令碼。</span><span class="sxs-lookup"><span data-stu-id="f9a71-120">DNVM, short for *DotNet Version Manager* was a bash/PowerShell script used to install a DNX on your machine.</span></span> <span data-ttu-id="f9a71-121">它可幫助使用者從其指定的摘要 (或預設摘要) 取得所需的 DNX，並將特定 DNX 標示為「作用中」，以將它放在指定工作階段的 $PATH 中。</span><span class="sxs-lookup"><span data-stu-id="f9a71-121">It helped users get the DNX they need from the feed they specified (or default ones) as well as mark a certain DNX "active", which would put it on the $PATH for the given session.</span></span> <span data-ttu-id="f9a71-122">這樣一來，您就可以使用各種工具。</span><span class="sxs-lookup"><span data-stu-id="f9a71-122">This would allow you to use the various tools.</span></span>

<span data-ttu-id="f9a71-123">DNVM 已中止，因為 .NET Core CLI 中的變更使其功能集變得重複。</span><span class="sxs-lookup"><span data-stu-id="f9a71-123">DNVM was discontinued because its feature set was made redundant by changes coming in the .NET Core CLI.</span></span>

<span data-ttu-id="f9a71-124">CLI 以兩種主要方式封裝：</span><span class="sxs-lookup"><span data-stu-id="f9a71-124">The CLI comes packaged in two main ways:</span></span>

1. <span data-ttu-id="f9a71-125">適用於指定平台的原生安裝程式</span><span class="sxs-lookup"><span data-stu-id="f9a71-125">Native installers for a given platform</span></span>
2. <span data-ttu-id="f9a71-126">適用於其他情況的安裝指令碼 (例如 CI 伺服器)</span><span class="sxs-lookup"><span data-stu-id="f9a71-126">Install script for other situations (like CI servers)</span></span>

<span data-ttu-id="f9a71-127">基於此，即不需要 DNVM 安裝功能。</span><span class="sxs-lookup"><span data-stu-id="f9a71-127">Given this, the DNVM install features are not needed.</span></span> <span data-ttu-id="f9a71-128">那麼執行階段選取功能呢？</span><span class="sxs-lookup"><span data-stu-id="f9a71-128">But what about the runtime selection features?</span></span>

<span data-ttu-id="f9a71-129">您可在相依性中新增特定版本的套件，以參考 `project.json` 中的執行階段。</span><span class="sxs-lookup"><span data-stu-id="f9a71-129">You reference a runtime in your `project.json` by adding a package of a certain version to your dependencies.</span></span> <span data-ttu-id="f9a71-130">這項變更可讓您的應用程式使用新的執行階段位元。</span><span class="sxs-lookup"><span data-stu-id="f9a71-130">With this change, your application will be able to use the new runtime bits.</span></span> <span data-ttu-id="f9a71-131">若要讓您的電腦具有這些位元，其方式與 CLI 相同︰您可透過執行階段支援的其中一個原生安裝程式，或是執行階段的安裝指令碼，來安裝執行階段。</span><span class="sxs-lookup"><span data-stu-id="f9a71-131">Getting these bits to your machine is the same as with the CLI: you install the runtime via one of the native installers it supports or via its install script.</span></span>

### <a name="different-commands"></a><span data-ttu-id="f9a71-132">不同的命令</span><span class="sxs-lookup"><span data-stu-id="f9a71-132">Different commands</span></span>

<span data-ttu-id="f9a71-133">如果您以前使用 DNX，您應該從其中的三個組件之一 (DNX、DNU 或 DNVM) 使用過一些命令。</span><span class="sxs-lookup"><span data-stu-id="f9a71-133">If you were using DNX, you used some commands from one of its three parts (DNX, DNU or DNVM).</span></span> <span data-ttu-id="f9a71-134">使用 CLI 時，其中某些命令已變更，某些可能無法使用，某些雖然相同但有稍微不同的語意。</span><span class="sxs-lookup"><span data-stu-id="f9a71-134">With the CLI, some of these commands change, some are not available and some are the same but have slightly different semantics.</span></span>

<span data-ttu-id="f9a71-135">下表顯示 DNX/DNU 命令和 CLI 對應項目之間的對應。</span><span class="sxs-lookup"><span data-stu-id="f9a71-135">The table below shows the mapping between the DNX/DNU commands and their CLI counterparts.</span></span>

| <span data-ttu-id="f9a71-136">DNX 命令</span><span class="sxs-lookup"><span data-stu-id="f9a71-136">DNX command</span></span>                    | <span data-ttu-id="f9a71-137">CLI 命令</span><span class="sxs-lookup"><span data-stu-id="f9a71-137">CLI command</span></span>    | <span data-ttu-id="f9a71-138">描述</span><span class="sxs-lookup"><span data-stu-id="f9a71-138">Description</span></span>                                                                                                     |
|--------------------------------|----------------|-----------------------------------------------------------------------------------------------------------------|
| <span data-ttu-id="f9a71-139">dnx run</span><span class="sxs-lookup"><span data-stu-id="f9a71-139">dnx run</span></span>                        | `dotnet run`     | <span data-ttu-id="f9a71-140">從來源執行程式碼。</span><span class="sxs-lookup"><span data-stu-id="f9a71-140">Run code from source.</span></span>                                                                                           |
| <span data-ttu-id="f9a71-141">dnu build</span><span class="sxs-lookup"><span data-stu-id="f9a71-141">dnu build</span></span>                      | `dotnet build`   | <span data-ttu-id="f9a71-142">建置您程式碼的 IL 二進位檔。</span><span class="sxs-lookup"><span data-stu-id="f9a71-142">Build an IL binary of your code.</span></span>                                                                                |
| <span data-ttu-id="f9a71-143">dnu pack</span><span class="sxs-lookup"><span data-stu-id="f9a71-143">dnu pack</span></span>                       | `dotnet pack`    | <span data-ttu-id="f9a71-144">封裝您程式碼的 NuGet 套件。</span><span class="sxs-lookup"><span data-stu-id="f9a71-144">Package up a NuGet package of your code.</span></span>                                                                        |
| <span data-ttu-id="f9a71-145">dnx \[command] (例如 "dnx web")</span><span class="sxs-lookup"><span data-stu-id="f9a71-145">dnx \[command] (for example, "dnx web")</span></span> | <span data-ttu-id="f9a71-146">N/A\*</span><span class="sxs-lookup"><span data-stu-id="f9a71-146">N/A\*</span></span>          | <span data-ttu-id="f9a71-147">在 DNX 環境中，依據 project.json 的定義來執行命令。</span><span class="sxs-lookup"><span data-stu-id="f9a71-147">In DNX world, run a command as defined in the project.json.</span></span>                                                     |
| <span data-ttu-id="f9a71-148">dnu install</span><span class="sxs-lookup"><span data-stu-id="f9a71-148">dnu install</span></span>                    | <span data-ttu-id="f9a71-149">N/A\*</span><span class="sxs-lookup"><span data-stu-id="f9a71-149">N/A\*</span></span>          | <span data-ttu-id="f9a71-150">在 DNX 環境中，將套件安裝為相依性。</span><span class="sxs-lookup"><span data-stu-id="f9a71-150">In the DNX world, install a package as a dependency.</span></span>                                                            |
| <span data-ttu-id="f9a71-151">dnu restore</span><span class="sxs-lookup"><span data-stu-id="f9a71-151">dnu restore</span></span>                    | `dotnet restore` | <span data-ttu-id="f9a71-152">還原您在 project.json 中指定的相依性。</span><span class="sxs-lookup"><span data-stu-id="f9a71-152">Restore dependencies specified in your project.json.</span></span> <span data-ttu-id="f9a71-153"> ([請參閱附注](#dotnet-restore-note)) </span><span class="sxs-lookup"><span data-stu-id="f9a71-153">([see note](#dotnet-restore-note))</span></span>                                                            |
| <span data-ttu-id="f9a71-154">dnu publish</span><span class="sxs-lookup"><span data-stu-id="f9a71-154">dnu publish</span></span>                    | `dotnet publish` | <span data-ttu-id="f9a71-155">在可攜式、原生可攜式與獨立式這三種形式中，以其中一種方式來發佈要部署的應用程式。</span><span class="sxs-lookup"><span data-stu-id="f9a71-155">Publish your application for deployment in one of the three forms (portable, portable with native and standalone).</span></span> |
| <span data-ttu-id="f9a71-156">dnu wrap</span><span class="sxs-lookup"><span data-stu-id="f9a71-156">dnu wrap</span></span>                       | <span data-ttu-id="f9a71-157">N/A\*</span><span class="sxs-lookup"><span data-stu-id="f9a71-157">N/A\*</span></span>          | <span data-ttu-id="f9a71-158">在 DNX 環境中，將 project.json 包裝在 csproj 中。</span><span class="sxs-lookup"><span data-stu-id="f9a71-158">In DNX world, wrap a project.json in csproj.</span></span>                                                                    |
| <span data-ttu-id="f9a71-159">dnu 命令</span><span class="sxs-lookup"><span data-stu-id="f9a71-159">dnu commands</span></span>                   | <span data-ttu-id="f9a71-160">N/A\*</span><span class="sxs-lookup"><span data-stu-id="f9a71-160">N/A\*</span></span>          | <span data-ttu-id="f9a71-161">在 DNX 環境中，管理已全域安裝的命令。</span><span class="sxs-lookup"><span data-stu-id="f9a71-161">In DNX world, manage the globally installed commands.</span></span>                                                           |

<span data-ttu-id="f9a71-162">(\*) - CLI 的設計並不支援這些功能。</span><span class="sxs-lookup"><span data-stu-id="f9a71-162">(\*) - these features are not supported in the CLI by design.</span></span>

## <a name="dnx-features-that-are-not-supported"></a><span data-ttu-id="f9a71-163">不支援的 DNX 功能</span><span class="sxs-lookup"><span data-stu-id="f9a71-163">DNX features that are not supported</span></span>

<span data-ttu-id="f9a71-164">如上表所示，我們決定 CLI 目前不再支援 DNX 環境的部分功能。</span><span class="sxs-lookup"><span data-stu-id="f9a71-164">As the table above shows, there are features from the DNX world that we decided not to support in the CLI, at least for the time being.</span></span> <span data-ttu-id="f9a71-165">本節會探討其中最重要的功能，並簡述不支援的理由，以及在您需要使用這些功能時的因應措施。</span><span class="sxs-lookup"><span data-stu-id="f9a71-165">This section will go through the most important ones and outline the rationale behind not supporting them as well as workarounds if you do need them.</span></span>

### <a name="global-commands"></a><span data-ttu-id="f9a71-166">全域命令</span><span class="sxs-lookup"><span data-stu-id="f9a71-166">Global commands</span></span>

<span data-ttu-id="f9a71-167">DNU 具有「全域命令」的概念。</span><span class="sxs-lookup"><span data-stu-id="f9a71-167">DNU came with a concept called "global commands".</span></span> <span data-ttu-id="f9a71-168">基本上，這當中包括封裝為 NuGet 套件的主控台應用程式，以及可叫用您指定要執行應用程式之 DNX 的殼層指令碼。</span><span class="sxs-lookup"><span data-stu-id="f9a71-168">These were, essentially, console applications packaged up as NuGet packages with a shell script that would invoke the DNX you specified to run the application.</span></span>

<span data-ttu-id="f9a71-169">CLI 不支援此概念。</span><span class="sxs-lookup"><span data-stu-id="f9a71-169">The CLI does not support this concept.</span></span> <span data-ttu-id="f9a71-170">不過，它支援新增個別專案命令的概念；您可使用熟悉的 `dotnet <command>` 語法叫用這些命令。</span><span class="sxs-lookup"><span data-stu-id="f9a71-170">It does, however, support the concept of adding per-project commands that can be invoked using the familiar `dotnet <command>` syntax.</span></span>

### <a name="installing-dependencies"></a><span data-ttu-id="f9a71-171">安裝相依性</span><span class="sxs-lookup"><span data-stu-id="f9a71-171">Installing dependencies</span></span>

<span data-ttu-id="f9a71-172">從 v1 起，.NET Core CLI 沒有可安裝相依性的 `install` 命令。</span><span class="sxs-lookup"><span data-stu-id="f9a71-172">As of v1, the .NET Core CLI doesn't have an `install` command for installing dependencies.</span></span> <span data-ttu-id="f9a71-173">若要從 NuGet 安裝套件，您必須將它以相依性形式新增至 `project.json` 檔案，然後執行 `dotnet restore` ([請參閱注意事項](#dotnet-restore-note))。</span><span class="sxs-lookup"><span data-stu-id="f9a71-173">In order to install a package from NuGet, you would need to add it as a dependency to your `project.json` file and then run `dotnet restore` ([see note](#dotnet-restore-note)).</span></span>

### <a name="running-your-code"></a><span data-ttu-id="f9a71-174">執行您的程式碼</span><span class="sxs-lookup"><span data-stu-id="f9a71-174">Running your code</span></span>

<span data-ttu-id="f9a71-175">有以下兩種執行程式碼的主要方式。</span><span class="sxs-lookup"><span data-stu-id="f9a71-175">There are two main ways to run your code.</span></span> <span data-ttu-id="f9a71-176">一個是使用 `dotnet run`，從來源執行。</span><span class="sxs-lookup"><span data-stu-id="f9a71-176">One is from source, with `dotnet run`.</span></span> <span data-ttu-id="f9a71-177">不同於 `dnx run`，這麼做並不會執行任何記憶體中編譯。</span><span class="sxs-lookup"><span data-stu-id="f9a71-177">Unlike `dnx run`, this will not do any in-memory compilation.</span></span> <span data-ttu-id="f9a71-178">實際上，它會叫用 `dotnet build` 以建置您的程式碼，然後執行建置的二進位檔。</span><span class="sxs-lookup"><span data-stu-id="f9a71-178">It will actually invoke `dotnet build` to build your code and then run the built binary.</span></span>

<span data-ttu-id="f9a71-179">另一個方法是使用 `dotnet` 本身來執行您的程式碼。</span><span class="sxs-lookup"><span data-stu-id="f9a71-179">Another way is using the `dotnet` itself to run your code.</span></span> <span data-ttu-id="f9a71-180">此作業是藉由提供組件的路徑來完成：`dotnet path/to/an/assembly.dll`。</span><span class="sxs-lookup"><span data-stu-id="f9a71-180">This is done by providing a path to your assembly: `dotnet path/to/an/assembly.dll`.</span></span>

## <a name="migrating-your-dnx-project-to-net-core-cli"></a><span data-ttu-id="f9a71-181">將 DNX 專案移轉至 .NET Core CLI</span><span class="sxs-lookup"><span data-stu-id="f9a71-181">Migrating your DNX project to .NET Core CLI</span></span>

<span data-ttu-id="f9a71-182">處理程式碼時，除了要使用新的命令之外，還有下列三個主要項目要從 DNX 移轉過來：</span><span class="sxs-lookup"><span data-stu-id="f9a71-182">In addition to using new commands when working with your code, there are three major things left in migrating from DNX:</span></span>

1. <span data-ttu-id="f9a71-183">如果您已經可以使用 CLI，請移轉 `global.json` 檔案。</span><span class="sxs-lookup"><span data-stu-id="f9a71-183">Migrate the `global.json` file if you have it to be able to use CLI.</span></span>
2. <span data-ttu-id="f9a71-184">將專案檔 (`project.json`) 本身移轉至 CLI 工具。</span><span class="sxs-lookup"><span data-stu-id="f9a71-184">Migrating the project file (`project.json`) itself to the CLI tooling.</span></span>
3. <span data-ttu-id="f9a71-185">將任何 DNX API 移轉至其 BCL 對應項目。</span><span class="sxs-lookup"><span data-stu-id="f9a71-185">Migrating off of any DNX APIs to their BCL counterparts.</span></span>

### <a name="changing-the-globaljson-file"></a><span data-ttu-id="f9a71-186">變更 global.json 檔案</span><span class="sxs-lookup"><span data-stu-id="f9a71-186">Changing the global.json file</span></span>

<span data-ttu-id="f9a71-187">`global.json` 檔案的作用如同 RC1 和 RC2 (或更新版本) 專案的方案檔。</span><span class="sxs-lookup"><span data-stu-id="f9a71-187">The `global.json` file acts like a solution file for both the RC1 and RC2 (or later) projects.</span></span> <span data-ttu-id="f9a71-188">為了讓 .NET Core CLI (和 Visual Studio) 區分 RC1 和更新版本，它們使用 `"sdk": { "version" }` 屬性來區分 RC1 或更新版本的專案。</span><span class="sxs-lookup"><span data-stu-id="f9a71-188">In order for the .NET Core CLI (as well as Visual Studio) to differentiate between RC1 and later versions, they use the `"sdk": { "version" }` property to make the distinction which project is RC1 or later.</span></span> <span data-ttu-id="f9a71-189">如果 `global.json` 完全沒有這個節點，就會假設其為最新版本。</span><span class="sxs-lookup"><span data-stu-id="f9a71-189">If `global.json` doesn't have this node at all, it is assumed to be the latest.</span></span>

<span data-ttu-id="f9a71-190">若要更新 `global.json` 檔案，可移除該屬性或將它設為您想要使用之工具的正確版本，在此案例中為 **1.0.0-preview2-003121**：</span><span class="sxs-lookup"><span data-stu-id="f9a71-190">In order to update the `global.json` file, either remove the property or set it to the exact version of the tools that you wish to use, in this case **1.0.0-preview2-003121**:</span></span>

```json
{
    "sdk": {
        "version": "1.0.0-preview2-003121"
    }
}
```

### <a name="migrating-the-project-file"></a><span data-ttu-id="f9a71-191">移轉專案檔</span><span class="sxs-lookup"><span data-stu-id="f9a71-191">Migrating the project file</span></span>

<span data-ttu-id="f9a71-192">CLI 和 DNX 都使用以 `project.json` 檔案為基礎的相同基本專案系統。</span><span class="sxs-lookup"><span data-stu-id="f9a71-192">The CLI and DNX both use the same basic project system based on `project.json` file.</span></span> <span data-ttu-id="f9a71-193">專案檔語法和語意基本上維持不變，僅有不同案例的小差異。</span><span class="sxs-lookup"><span data-stu-id="f9a71-193">The syntax and the semantics of the project file are pretty much the same, with small differences based on the scenarios.</span></span> <span data-ttu-id="f9a71-194">結構描述也有一些變更，而您可在[結構描述檔案](http://json.schemastore.org/project)中查看這些變更。</span><span class="sxs-lookup"><span data-stu-id="f9a71-194">There are also some changes to the schema which you can see in the [schema file](http://json.schemastore.org/project).</span></span>

<span data-ttu-id="f9a71-195">如果您要建置主控台應用程式，則需要將下列程式碼片段新增至您的專案檔：</span><span class="sxs-lookup"><span data-stu-id="f9a71-195">If you are building a console application, you need to add the following snippet to your project file:</span></span>

```json
"buildOptions": {
    "emitEntryPoint": true
}
```

<span data-ttu-id="f9a71-196">這麼做會指示 `dotnet build` 針對您的應用程式發出進入點，以讓程式碼可有效執行。</span><span class="sxs-lookup"><span data-stu-id="f9a71-196">This instructs `dotnet build` to emit an entry point for your application, effectively making your code runnable.</span></span> <span data-ttu-id="f9a71-197">如果您要建置類別庫，只要省略上一節即可。</span><span class="sxs-lookup"><span data-stu-id="f9a71-197">If you are building a class library, simply omit the above section.</span></span> <span data-ttu-id="f9a71-198">當然，一旦將上述程式碼片段新增至 `project.json` 檔案之後，您必須新增靜態進入點。</span><span class="sxs-lookup"><span data-stu-id="f9a71-198">Of course, once you add the above snippet to your `project.json` file, you need to add a static entry point.</span></span> <span data-ttu-id="f9a71-199">移出 DNX 時，它所提供的 DI 服務便無法再使用，因此進入點必須是基本 .NET 進入點：`static void Main()`。</span><span class="sxs-lookup"><span data-stu-id="f9a71-199">With the move off DNX, the DI services it provided are no longer available and thus this needs to be a basic .NET entry point: `static void Main()`.</span></span>

<span data-ttu-id="f9a71-200">如果您的 `project.json` 中有「命令」區段，您可以將它移除。</span><span class="sxs-lookup"><span data-stu-id="f9a71-200">If you have a "commands" section in your `project.json`, you can remove it.</span></span> <span data-ttu-id="f9a71-201">如果某些命令原本是以 DNU 命令的形式存在 (例如 Entity Framework CLI 命令)，則這些命令會以每個專案擴充功能的形式移植至 CLI。</span><span class="sxs-lookup"><span data-stu-id="f9a71-201">Some of the commands that used to exist as DNU commands, such as Entity Framework CLI commands, are being ported to be per-project extensions to the CLI.</span></span> <span data-ttu-id="f9a71-202">如果您要自行建立命令以在專案中使用，則需要將其取代為 CLI 擴充功能。</span><span class="sxs-lookup"><span data-stu-id="f9a71-202">If you built your own commands that you are using in your projects, you need to replace them with CLI extensions.</span></span> <span data-ttu-id="f9a71-203">在此情況下，`project.json` 中的 `commands` 節點必須以 `tools` 節點取代，且它需要列出工具相依性。</span><span class="sxs-lookup"><span data-stu-id="f9a71-203">In this case, the `commands` node in `project.json` needs to be replaced by the `tools` node and it needs to list the tools dependencies.</span></span>

<span data-ttu-id="f9a71-204">完成這些作業之後，您必須決定應用程式要具備哪種類型的可攜性。</span><span class="sxs-lookup"><span data-stu-id="f9a71-204">After these things are done, you need to decide which type of portability you wish for you app.</span></span> <span data-ttu-id="f9a71-205">我們對 .NET Core 所提供的可攜性選項範圍投注不少心力，以供您選擇。</span><span class="sxs-lookup"><span data-stu-id="f9a71-205">With .NET Core, we have invested into providing a spectrum of portability options that you can choose from.</span></span> <span data-ttu-id="f9a71-206">比方說，您可能需要完全*可攜式*的應用程式，或希望擁有*獨立*的應用程式。</span><span class="sxs-lookup"><span data-stu-id="f9a71-206">For instance, you may want to have a fully *portable* application or you may want to have a *self-contained* application.</span></span> <span data-ttu-id="f9a71-207">可攜式應用程式選項很像 .NET Framework 應用程式的運作方式：它需要共用元件以在目標電腦 (.NET Core) 上執行。</span><span class="sxs-lookup"><span data-stu-id="f9a71-207">The portable application option is more like .NET Framework applications work: it needs a shared component to execute it on the target machine (.NET Core).</span></span> <span data-ttu-id="f9a71-208">獨立的應用程式不需要在目標上安裝 .NET Core，但是您必須為每個想要支援的作業系統產生一個應用程式。</span><span class="sxs-lookup"><span data-stu-id="f9a71-208">The self-contained application doesn't require .NET Core to be installed on the target, but you have to produce one application for each OS you wish to support.</span></span> <span data-ttu-id="f9a71-209">[應用程式可攜性類型](../deploying/index.md)文件中會說明這些可攜性類型等相關資訊。</span><span class="sxs-lookup"><span data-stu-id="f9a71-209">These portability types and more are discussed in the [application portability type](../deploying/index.md) document.</span></span>

<span data-ttu-id="f9a71-210">一旦您決定要使用何種可攜性類型時，即需要變更目標架構。</span><span class="sxs-lookup"><span data-stu-id="f9a71-210">Once you make a call on what type of portability you want, you need to change your targeted framework(s).</span></span> <span data-ttu-id="f9a71-211">如果您撰寫過 .NET Core 的應用程式，您很可能會使用 `dnxcore50` 做為目標架構。</span><span class="sxs-lookup"><span data-stu-id="f9a71-211">If you were writing applications for .NET Core, you were most likely using `dnxcore50` as  your targeted framework.</span></span> <span data-ttu-id="f9a71-212">由新的 [.NET Standard](../../standard/net-standard.md) \(英文\) 所帶來的 CLI 和變更，使得架構必須為下列其中一項：</span><span class="sxs-lookup"><span data-stu-id="f9a71-212">With the CLI and the changes that the new [.NET Standard](../../standard/net-standard.md) brought, the framework needs to be one of the following:</span></span>

1. <span data-ttu-id="f9a71-213">`netcoreapp1.0`- 如果您要撰寫的應用程式在 .NET Core (包括 ASP.NET Core 應用程式) 上</span><span class="sxs-lookup"><span data-stu-id="f9a71-213">`netcoreapp1.0` - if you are writing applications on .NET Core (including ASP.NET Core applications)</span></span>
2. <span data-ttu-id="f9a71-214">`netstandard1.6`- 如果您要撰寫 .NET Core 的類別庫</span><span class="sxs-lookup"><span data-stu-id="f9a71-214">`netstandard1.6` - if you are writing class libraries for .NET Core</span></span>

<span data-ttu-id="f9a71-215">如果您使用其他 `dnx` 目標 (例如 `dnx451`)，也必須變更這些項目。</span><span class="sxs-lookup"><span data-stu-id="f9a71-215">If you are using other `dnx` targets, like `dnx451` you will need to change those as well.</span></span> <span data-ttu-id="f9a71-216">`net451`應變更為 `dnx451`。</span><span class="sxs-lookup"><span data-stu-id="f9a71-216">`dnx451` should be changed to `net451`.</span></span>
<span data-ttu-id="f9a71-217">如需詳細資訊，請參閱 [.NET Standard](../../standard/net-standard.md) 主題。</span><span class="sxs-lookup"><span data-stu-id="f9a71-217">Please refer to the [.NET Standard](../../standard/net-standard.md) topic for more information.</span></span>

<span data-ttu-id="f9a71-218">您的 `project.json` 現已大致就緒。</span><span class="sxs-lookup"><span data-stu-id="f9a71-218">Your `project.json` is now mostly ready.</span></span> <span data-ttu-id="f9a71-219">接著，您必須檢查相依性清單，並將相依性更新為較新版本；如果您是使用 ASP.NET Core 相依性的話，更應注意這項作業。</span><span class="sxs-lookup"><span data-stu-id="f9a71-219">You need to go through your dependencies list and update the dependencies to their newer versions, especially if you are using ASP.NET Core dependencies.</span></span> <span data-ttu-id="f9a71-220">如果您之前針對 BCL API 使用不同的套件，則可以使用[應用程式可攜性類型](../deploying/index.md)文件中所述的執行階段套件。</span><span class="sxs-lookup"><span data-stu-id="f9a71-220">If you were using separate packages for BCL APIs, you can use the runtime package as explained in the [application portability type](../deploying/index.md) document.</span></span>

<span data-ttu-id="f9a71-221">準備好後，您可以嘗試使用 `dotnet restore` ([請參閱注意事項](#dotnet-restore-note)) 進行還原。</span><span class="sxs-lookup"><span data-stu-id="f9a71-221">Once you are ready, you can try restoring with `dotnet restore` ([see note](#dotnet-restore-note)).</span></span> <span data-ttu-id="f9a71-222">根據您的相依性版本而定，如果 NuGet 無法解析上述其中一個目標架構的相依性，就可能會發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="f9a71-222">Depending on the version of your dependencies, you may encounter errors if NuGet cannot resolve the dependencies for one of the targeted frameworks above.</span></span> <span data-ttu-id="f9a71-223">這是「時間點」的問題，因為隨著時間過去，會有越來越多套件支援這些架構。</span><span class="sxs-lookup"><span data-stu-id="f9a71-223">This is a "point-in-time" problem; as time progresses, more and more packages will include support for these frameworks.</span></span> <span data-ttu-id="f9a71-224">目前來看，如果您遇到這個問題，可以使用 `framework` 節點內的 `imports` 陳述式，指定 NuGet 可以還原目標為 "imports" 陳述式內之架構的套件。</span><span class="sxs-lookup"><span data-stu-id="f9a71-224">For now, if you run into this, you can use the `imports` statement within the `framework` node to specify to NuGet that it can restore the packages targeting the framework within the "imports" statement.</span></span>
<span data-ttu-id="f9a71-225">在此情況下取得的還原錯誤應具有足夠資訊，可讓您知道需要匯入哪些架構。</span><span class="sxs-lookup"><span data-stu-id="f9a71-225">The restoring errors you get in this case should provide enough information to tell you which frameworks you need to import.</span></span> <span data-ttu-id="f9a71-226">如果您有點跟不上或對這方面不太熟悉，一般來說，只要在 `imports` 陳述式中指定 `dnxcore50` 和 `portable-net45+win8` 就可以達到目的。</span><span class="sxs-lookup"><span data-stu-id="f9a71-226">If you are slightly lost or new to this, in general, specifying `dnxcore50` and `portable-net45+win8` in the `imports` statement should do the trick.</span></span> <span data-ttu-id="f9a71-227">下列 JSON 程式碼片段會示範這個過程：</span><span class="sxs-lookup"><span data-stu-id="f9a71-227">The JSON snippet below shows how this looks like:</span></span>

```json
    "frameworks": {
        "netcoreapp1.0": {
            "imports": ["dnxcore50", "portable-net45+win8"]
        }
    }
```

<span data-ttu-id="f9a71-228">執行 `dotnet build` 時，會將任何最終建置錯誤顯示出來，但不應該有太多錯誤。</span><span class="sxs-lookup"><span data-stu-id="f9a71-228">Running `dotnet build` will show any eventual build errors, though there shouldn't be too many of them.</span></span> <span data-ttu-id="f9a71-229">建置好程式碼並順利執行後，您可以再使用執行器測試一下。</span><span class="sxs-lookup"><span data-stu-id="f9a71-229">After your code is building and running properly, you can test it out with the runner.</span></span> <span data-ttu-id="f9a71-230">執行 `dotnet <path-to-your-assembly>`，並查看其執行狀況。</span><span class="sxs-lookup"><span data-stu-id="f9a71-230">Execute `dotnet <path-to-your-assembly>` and see it run.</span></span>

<a name="dotnet-restore-note"></a>

[!INCLUDE[DotNet Restore Note](~/includes/dotnet-restore-note.md)]
