---
title: 瞭解 AssemblyLoadCoNtext-.NET Core
description: 瞭解 .NET Core 中 AssemblyLoadCoNtext 用途和行為的重要概念。
ms.date: 08/09/2019
author: sdmaclea
ms.author: stmaclea
ms.openlocfilehash: 4d3f0e50e7c336469bd9af4d1589427388684434
ms.sourcegitcommit: dfcbc096ad7908cd58a5f0aeabd2256f05266bac
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 10/21/2020
ms.locfileid: "92332818"
---
# <a name="understanding-systemruntimeloaderassemblyloadcontext"></a><span data-ttu-id="226f5-103">瞭解 AssemblyLoadCoNtext。</span><span class="sxs-lookup"><span data-stu-id="226f5-103">Understanding System.Runtime.Loader.AssemblyLoadContext</span></span>

<span data-ttu-id="226f5-104"><xref:System.Runtime.Loader.AssemblyLoadContext>類別對 .Net Core 而言是唯一的。</span><span class="sxs-lookup"><span data-stu-id="226f5-104">The <xref:System.Runtime.Loader.AssemblyLoadContext> class is unique to .NET Core.</span></span> <span data-ttu-id="226f5-105">本文嘗試以 <xref:System.Runtime.Loader.AssemblyLoadContext> 概念資訊補充 API 檔。</span><span class="sxs-lookup"><span data-stu-id="226f5-105">This article attempts to supplement the <xref:System.Runtime.Loader.AssemblyLoadContext> API documentation with conceptual information.</span></span>

<span data-ttu-id="226f5-106">本文與執行動態載入的開發人員相關，尤其是動態載入架構開發人員。</span><span class="sxs-lookup"><span data-stu-id="226f5-106">This article is relevant to developers implementing dynamic loading, especially dynamic loading framework developers.</span></span>

## <a name="what-is-the-assemblyloadcontext"></a><span data-ttu-id="226f5-107">什麼是 AssemblyLoadCoNtext？</span><span class="sxs-lookup"><span data-stu-id="226f5-107">What is the AssemblyLoadContext?</span></span>

<span data-ttu-id="226f5-108">每個 .NET Core 應用程式都會隱含地使用 <xref:System.Runtime.Loader.AssemblyLoadContext> 。</span><span class="sxs-lookup"><span data-stu-id="226f5-108">Every .NET Core application implicitly uses the <xref:System.Runtime.Loader.AssemblyLoadContext>.</span></span>
<span data-ttu-id="226f5-109">它是執行時間的提供者，用來尋找和載入相依性。</span><span class="sxs-lookup"><span data-stu-id="226f5-109">It's the runtime's provider for locating and loading dependencies.</span></span> <span data-ttu-id="226f5-110">當相依性載入時，會叫用 <xref:System.Runtime.Loader.AssemblyLoadContext> 實例以找出它。</span><span class="sxs-lookup"><span data-stu-id="226f5-110">Whenever a dependency is loaded, an <xref:System.Runtime.Loader.AssemblyLoadContext> instance is invoked to locate it.</span></span>

- <span data-ttu-id="226f5-111">它提供了尋找、載入及快取 managed 元件和其他相依性的服務。</span><span class="sxs-lookup"><span data-stu-id="226f5-111">It provides a service of locating, loading, and caching managed assemblies and other dependencies.</span></span>

- <span data-ttu-id="226f5-112">為了支援動態程式碼載入和卸載，它會建立隔離的內容，以在其本身的實例中載入程式碼及其相依性 <xref:System.Runtime.Loader.AssemblyLoadContext> 。</span><span class="sxs-lookup"><span data-stu-id="226f5-112">To support dynamic code loading and unloading, it creates an isolated context for loading code and its dependencies in their own <xref:System.Runtime.Loader.AssemblyLoadContext> instance.</span></span>

## <a name="when-do-you-need-multiple-assemblyloadcontext-instances"></a><span data-ttu-id="226f5-113">何時需要多個 AssemblyLoadCoNtext 實例？</span><span class="sxs-lookup"><span data-stu-id="226f5-113">When do you need multiple AssemblyLoadContext instances?</span></span>

<span data-ttu-id="226f5-114">單一 <xref:System.Runtime.Loader.AssemblyLoadContext> 實例限制為 <xref:System.Reflection.Assembly> 每個簡單元件名稱只載入一個版本的 <xref:System.Reflection.AssemblyName.Name?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="226f5-114">A single <xref:System.Runtime.Loader.AssemblyLoadContext> instance is limited to loading exactly one version of an <xref:System.Reflection.Assembly> per simple assembly name, <xref:System.Reflection.AssemblyName.Name?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="226f5-115">當動態載入程式碼模組時，這種限制可能會變成問題。</span><span class="sxs-lookup"><span data-stu-id="226f5-115">This restriction can become a problem when loading code modules dynamically.</span></span> <span data-ttu-id="226f5-116">每個模組都是獨立編譯的，而且可能相依于不同的版本 <xref:System.Reflection.Assembly> 。</span><span class="sxs-lookup"><span data-stu-id="226f5-116">Each module is independently compiled and may depend on different versions of an <xref:System.Reflection.Assembly>.</span></span> <span data-ttu-id="226f5-117">當不同的模組相依于不同版本的常用程式庫時，通常就會發生此問題。</span><span class="sxs-lookup"><span data-stu-id="226f5-117">This problem commonly occurs when different modules depend on different versions of a commonly used library.</span></span>

<span data-ttu-id="226f5-118">為了支援動態載入程式碼， <xref:System.Runtime.Loader.AssemblyLoadContext> API 可 <xref:System.Reflection.Assembly> 在相同的應用程式中載入的衝突版本。</span><span class="sxs-lookup"><span data-stu-id="226f5-118">To support dynamically loading code, the <xref:System.Runtime.Loader.AssemblyLoadContext> API provides for loading conflicting versions of an <xref:System.Reflection.Assembly> in the same application.</span></span> <span data-ttu-id="226f5-119">每個 <xref:System.Runtime.Loader.AssemblyLoadContext> 實例都會提供唯一的字典對應 <xref:System.Reflection.AssemblyName.Name?displayProperty=nameWithType> 至特定的 <xref:System.Reflection.Assembly> 實例。</span><span class="sxs-lookup"><span data-stu-id="226f5-119">Each <xref:System.Runtime.Loader.AssemblyLoadContext> instance provides a unique dictionary mapping each <xref:System.Reflection.AssemblyName.Name?displayProperty=nameWithType> to a specific <xref:System.Reflection.Assembly> instance.</span></span>

<span data-ttu-id="226f5-120">它也提供便利的機制，以將與程式碼模組相關的相依性分組以供稍後卸載。</span><span class="sxs-lookup"><span data-stu-id="226f5-120">It also provides a convenient mechanism for grouping dependencies related to a code module for later unload.</span></span>

## <a name="what-is-special-about-the-assemblyloadcontextdefault-instance"></a><span data-ttu-id="226f5-121">AssemblyLoadCoNtext 的特殊功能。預設實例是什麼？</span><span class="sxs-lookup"><span data-stu-id="226f5-121">What is special about the AssemblyLoadContext.Default instance?</span></span>

<span data-ttu-id="226f5-122"><xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType>執行時間會在啟動時自動填入實例。</span><span class="sxs-lookup"><span data-stu-id="226f5-122">The <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType> instance is automatically populated by the runtime at startup.</span></span>  <span data-ttu-id="226f5-123">它會使用 [預設探查](default-probing.md) 來找出並尋找所有靜態相依性。</span><span class="sxs-lookup"><span data-stu-id="226f5-123">It uses [default probing](default-probing.md) to locate and find all static dependencies.</span></span>

<span data-ttu-id="226f5-124">它可解決最常見的相依性載入案例。</span><span class="sxs-lookup"><span data-stu-id="226f5-124">It solves the most common dependency loading scenarios.</span></span>

## <a name="how-does-assemblyloadcontext-support-dynamic-dependencies"></a><span data-ttu-id="226f5-125">AssemblyLoadCoNtext 如何支援動態相依性？</span><span class="sxs-lookup"><span data-stu-id="226f5-125">How does AssemblyLoadContext support dynamic dependencies?</span></span>

<span data-ttu-id="226f5-126"><xref:System.Runtime.Loader.AssemblyLoadContext> 具有可覆寫的各種事件和虛擬函數。</span><span class="sxs-lookup"><span data-stu-id="226f5-126"><xref:System.Runtime.Loader.AssemblyLoadContext> has various events and virtual functions that can be overridden.</span></span>

<span data-ttu-id="226f5-127">此 <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType> 實例只支援覆寫事件。</span><span class="sxs-lookup"><span data-stu-id="226f5-127">The <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType> instance only supports overriding the events.</span></span>

<span data-ttu-id="226f5-128">[受管理的元件載入演算法](loading-managed.md)、[附屬元件載入演算法](loading-resources.md)和[非受控 (原生) 程式庫載入演算法](loading-unmanaged.md)會參考所有可用的事件和虛擬函式。</span><span class="sxs-lookup"><span data-stu-id="226f5-128">The articles [Managed assembly loading algorithm](loading-managed.md), [Satellite assembly loading algorithm](loading-resources.md), and [Unmanaged (native) library loading algorithm](loading-unmanaged.md) refer to all the available events and virtual functions.</span></span>  <span data-ttu-id="226f5-129">這些文章會顯示每個事件和函式在載入演算法中的相對位置。</span><span class="sxs-lookup"><span data-stu-id="226f5-129">The articles show each event and function's relative position in the loading algorithms.</span></span> <span data-ttu-id="226f5-130">本文不會重現該資訊。</span><span class="sxs-lookup"><span data-stu-id="226f5-130">This article doesn't reproduce that information.</span></span>

<span data-ttu-id="226f5-131">本節涵蓋相關事件和功能的一般原則。</span><span class="sxs-lookup"><span data-stu-id="226f5-131">This section covers the general principles for the relevant events and functions.</span></span>

- <span data-ttu-id="226f5-132">**可重複**執行。</span><span class="sxs-lookup"><span data-stu-id="226f5-132">**Be repeatable**.</span></span> <span data-ttu-id="226f5-133">特定相依性的查詢一定會產生相同的回應。</span><span class="sxs-lookup"><span data-stu-id="226f5-133">A query for a specific dependency must always result in the same response.</span></span> <span data-ttu-id="226f5-134">必須傳回相同載入的相依性實例。</span><span class="sxs-lookup"><span data-stu-id="226f5-134">The same loaded dependency instance must be returned.</span></span> <span data-ttu-id="226f5-135">這項需求是快取一致性的基礎。</span><span class="sxs-lookup"><span data-stu-id="226f5-135">This requirement is fundamental  for cache consistency.</span></span> <span data-ttu-id="226f5-136">尤其是針對 managed 元件，我們會建立快取 <xref:System.Reflection.Assembly> 。</span><span class="sxs-lookup"><span data-stu-id="226f5-136">For managed assemblies in particular, we're creating an <xref:System.Reflection.Assembly> cache.</span></span> <span data-ttu-id="226f5-137">快取索引鍵是簡單的元件名稱 <xref:System.Reflection.AssemblyName.Name?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="226f5-137">The cache key is a simple assembly name, <xref:System.Reflection.AssemblyName.Name?displayProperty=nameWithType>.</span></span>
- <span data-ttu-id="226f5-138">**通常不會擲**回。</span><span class="sxs-lookup"><span data-stu-id="226f5-138">**Typically don't throw**.</span></span>  <span data-ttu-id="226f5-139">在找不到要求的相依性時，這些函式預期會傳回 `null` 而非擲回。</span><span class="sxs-lookup"><span data-stu-id="226f5-139">It's expected that these functions return `null` rather than throw when unable to find the requested dependency.</span></span> <span data-ttu-id="226f5-140">擲回會提前結束搜尋，並將例外狀況傳播至呼叫端。</span><span class="sxs-lookup"><span data-stu-id="226f5-140">Throwing will prematurely end the search and be propagate an exception to the caller.</span></span> <span data-ttu-id="226f5-141">擲回應限制為非預期的錯誤，例如元件損毀或記憶體不足的狀況。</span><span class="sxs-lookup"><span data-stu-id="226f5-141">Throwing should be restricted to unexpected errors like a corrupted assembly or an out of memory condition.</span></span>
- <span data-ttu-id="226f5-142">**避免遞迴**。</span><span class="sxs-lookup"><span data-stu-id="226f5-142">**Avoid recursion**.</span></span> <span data-ttu-id="226f5-143">請注意，這些函式和處理常式會執行用於尋找相依性的載入規則。</span><span class="sxs-lookup"><span data-stu-id="226f5-143">Be aware that these functions and handlers implement the loading rules for locating dependencies.</span></span> <span data-ttu-id="226f5-144">您的執行不應呼叫觸發遞迴的 Api。</span><span class="sxs-lookup"><span data-stu-id="226f5-144">Your implementation shouldn't call APIs that trigger recursion.</span></span> <span data-ttu-id="226f5-145">您的程式碼通常應該呼叫需要特定路徑或記憶體參考引數的 **AssemblyLoadCoNtext** 載入函數。</span><span class="sxs-lookup"><span data-stu-id="226f5-145">Your code should typically call **AssemblyLoadContext** load functions that require a specific path or memory reference argument.</span></span>
- <span data-ttu-id="226f5-146">**載入至正確的 AssemblyLoadCoNtext**。</span><span class="sxs-lookup"><span data-stu-id="226f5-146">**Load into the correct AssemblyLoadContext**.</span></span> <span data-ttu-id="226f5-147">選擇載入相依性的位置是應用程式特定的。</span><span class="sxs-lookup"><span data-stu-id="226f5-147">The choice of where to load dependencies is application-specific.</span></span>  <span data-ttu-id="226f5-148">此選項是由這些事件和函式所執行。</span><span class="sxs-lookup"><span data-stu-id="226f5-148">The choice is implemented by these events and functions.</span></span> <span data-ttu-id="226f5-149">當您的程式碼呼叫 **AssemblyLoadCoNtext** 時，函式會在您想要載入程式碼的實例上呼叫這些函式。</span><span class="sxs-lookup"><span data-stu-id="226f5-149">When your code calls **AssemblyLoadContext** load-by-path functions call them on the instance where you want the code loaded.</span></span> <span data-ttu-id="226f5-150">當您傳回 `null` 並讓 <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType> 處理負載的時候，可能是最簡單的選項。</span><span class="sxs-lookup"><span data-stu-id="226f5-150">Sometime returning `null` and letting the <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType> handle the load may be the simplest option.</span></span>
- <span data-ttu-id="226f5-151">**請留意執行緒爭用**。</span><span class="sxs-lookup"><span data-stu-id="226f5-151">**Be aware of thread races**.</span></span> <span data-ttu-id="226f5-152">載入可以由多個執行緒觸發。</span><span class="sxs-lookup"><span data-stu-id="226f5-152">Loading can be triggered by multiple threads.</span></span> <span data-ttu-id="226f5-153">AssemblyLoadCoNtext 藉由將元件以不可部分完成的方式新增至其快取來處理執行緒爭用。</span><span class="sxs-lookup"><span data-stu-id="226f5-153">The AssemblyLoadContext handles thread races by atomically adding assemblies to its cache.</span></span> <span data-ttu-id="226f5-154">將會捨棄競爭失敗者的實例。</span><span class="sxs-lookup"><span data-stu-id="226f5-154">The race loser's instance is discarded.</span></span> <span data-ttu-id="226f5-155">在您的執行邏輯中，請勿新增未正確處理多個執行緒的額外邏輯。</span><span class="sxs-lookup"><span data-stu-id="226f5-155">In your implementation logic, don't add extra logic that doesn't handle multiple threads properly.</span></span>

## <a name="how-are-dynamic-dependencies-isolated"></a><span data-ttu-id="226f5-156">如何隔離動態相依性？</span><span class="sxs-lookup"><span data-stu-id="226f5-156">How are dynamic dependencies isolated?</span></span>

<span data-ttu-id="226f5-157">每個 <xref:System.Runtime.Loader.AssemblyLoadContext> 實例都代表 <xref:System.Reflection.Assembly> 實例和定義的唯一範圍 <xref:System.Type> 。</span><span class="sxs-lookup"><span data-stu-id="226f5-157">Each <xref:System.Runtime.Loader.AssemblyLoadContext> instance represents a unique scope for <xref:System.Reflection.Assembly> instances and <xref:System.Type> definitions.</span></span>

<span data-ttu-id="226f5-158">這些相依性之間沒有二進位隔離。</span><span class="sxs-lookup"><span data-stu-id="226f5-158">There's no binary isolation between these dependencies.</span></span> <span data-ttu-id="226f5-159">它們只會透過名稱找不到彼此來隔離。</span><span class="sxs-lookup"><span data-stu-id="226f5-159">They're only isolated by not finding each other by name.</span></span>

<span data-ttu-id="226f5-160">在每個 <xref:System.Runtime.Loader.AssemblyLoadContext> ：</span><span class="sxs-lookup"><span data-stu-id="226f5-160">In each <xref:System.Runtime.Loader.AssemblyLoadContext>:</span></span>

- <span data-ttu-id="226f5-161"><xref:System.Reflection.AssemblyName.Name?displayProperty=nameWithType> 可能參考不同的 <xref:System.Reflection.Assembly> 實例。</span><span class="sxs-lookup"><span data-stu-id="226f5-161"><xref:System.Reflection.AssemblyName.Name?displayProperty=nameWithType> may refer to a different <xref:System.Reflection.Assembly> instance.</span></span>
- <span data-ttu-id="226f5-162"><xref:System.Type.GetType%2A?displayProperty=nameWithType> 可能會針對相同的類型傳回不同的類型實例 `name` 。</span><span class="sxs-lookup"><span data-stu-id="226f5-162"><xref:System.Type.GetType%2A?displayProperty=nameWithType> may return a different type instance for the same type `name`.</span></span>

## <a name="how-are-dependencies-shared"></a><span data-ttu-id="226f5-163">如何共用相依性？</span><span class="sxs-lookup"><span data-stu-id="226f5-163">How are dependencies shared?</span></span>

<span data-ttu-id="226f5-164">您可以輕鬆地在實例之間共用相依性 <xref:System.Runtime.Loader.AssemblyLoadContext> 。</span><span class="sxs-lookup"><span data-stu-id="226f5-164">Dependencies can easily be shared between <xref:System.Runtime.Loader.AssemblyLoadContext> instances.</span></span> <span data-ttu-id="226f5-165">一般模型是用來載入相依性的模型 <xref:System.Runtime.Loader.AssemblyLoadContext> 。</span><span class="sxs-lookup"><span data-stu-id="226f5-165">The general model is for one <xref:System.Runtime.Loader.AssemblyLoadContext> to load a dependency.</span></span>  <span data-ttu-id="226f5-166">另一個則是使用已載入元件的參考來共用相依性。</span><span class="sxs-lookup"><span data-stu-id="226f5-166">The other shares the dependency by using a reference to the loaded assembly.</span></span>

<span data-ttu-id="226f5-167">執行時間元件需要此共用。</span><span class="sxs-lookup"><span data-stu-id="226f5-167">This sharing is required of the runtime assemblies.</span></span> <span data-ttu-id="226f5-168">這些元件只能載入至 <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="226f5-168">These assemblies can only be loaded into the <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType>.</span></span> <span data-ttu-id="226f5-169">例如、或等架構都需要相同的 `ASP.NET` `WPF` `WinForms` 。</span><span class="sxs-lookup"><span data-stu-id="226f5-169">The same is required for frameworks like `ASP.NET`, `WPF`, or `WinForms`.</span></span>

<span data-ttu-id="226f5-170">建議將共用的相依性載入至 <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="226f5-170">It's recommended that shared dependencies should be loaded into <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType>.</span></span> <span data-ttu-id="226f5-171">這種共用是常見的設計模式。</span><span class="sxs-lookup"><span data-stu-id="226f5-171">This sharing is the common design pattern.</span></span>

<span data-ttu-id="226f5-172">共用會在自訂實例的程式碼中執行 <xref:System.Runtime.Loader.AssemblyLoadContext> 。</span><span class="sxs-lookup"><span data-stu-id="226f5-172">Sharing is implemented in the coding of the custom <xref:System.Runtime.Loader.AssemblyLoadContext> instance.</span></span> <span data-ttu-id="226f5-173"><xref:System.Runtime.Loader.AssemblyLoadContext> 具有可覆寫的各種事件和虛擬函數。</span><span class="sxs-lookup"><span data-stu-id="226f5-173"><xref:System.Runtime.Loader.AssemblyLoadContext> has various events and virtual functions that can be overridden.</span></span> <span data-ttu-id="226f5-174">當這些函式中有任何一個傳回 <xref:System.Reflection.Assembly> 已載入至另一個實例之實例的參考時 <xref:System.Runtime.Loader.AssemblyLoadContext> ， <xref:System.Reflection.Assembly> 就會共用該實例。</span><span class="sxs-lookup"><span data-stu-id="226f5-174">When any of these functions return a reference to an <xref:System.Reflection.Assembly> instance that was loaded in another <xref:System.Runtime.Loader.AssemblyLoadContext> instance, the <xref:System.Reflection.Assembly> instance is shared.</span></span> <span data-ttu-id="226f5-175">標準載入演算法會延遲 <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType> 載入，以簡化常見的共用模式。</span><span class="sxs-lookup"><span data-stu-id="226f5-175">The standard load algorithm defers to <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType> for loading to simplify the common sharing pattern.</span></span>  <span data-ttu-id="226f5-176">請參閱 [Managed 元件載入演算法](loading-managed.md)。</span><span class="sxs-lookup"><span data-stu-id="226f5-176">See [Managed assembly loading algorithm](loading-managed.md).</span></span>

## <a name="complications"></a><span data-ttu-id="226f5-177">複雜功能</span><span class="sxs-lookup"><span data-stu-id="226f5-177">Complications</span></span>

### <a name="type-conversion-issues"></a><span data-ttu-id="226f5-178">類型轉換問題</span><span class="sxs-lookup"><span data-stu-id="226f5-178">Type conversion issues</span></span>

<span data-ttu-id="226f5-179">當兩個 <xref:System.Runtime.Loader.AssemblyLoadContext> 實例包含的型別定義相同時 `name` ，就不是相同的類型。</span><span class="sxs-lookup"><span data-stu-id="226f5-179">When two <xref:System.Runtime.Loader.AssemblyLoadContext> instances contain type definitions with the same `name`, they're not the same type.</span></span> <span data-ttu-id="226f5-180">如果只有來自相同的實例，則它們是相同的類型 <xref:System.Reflection.Assembly> 。</span><span class="sxs-lookup"><span data-stu-id="226f5-180">They're the same type if and only if they come from the same <xref:System.Reflection.Assembly> instance.</span></span>

<span data-ttu-id="226f5-181">為了讓事情變得複雜，這些不相符類型的例外狀況訊息可能會造成混淆。</span><span class="sxs-lookup"><span data-stu-id="226f5-181">To complicate matters, exception messages about these mismatched types can be confusing.</span></span> <span data-ttu-id="226f5-182">在例外狀況訊息中，類型是透過其簡單類型名稱來參考。</span><span class="sxs-lookup"><span data-stu-id="226f5-182">The types are referred to in the exception messages by their simple type names.</span></span> <span data-ttu-id="226f5-183">在此情況下，一般例外狀況訊息的形式如下：</span><span class="sxs-lookup"><span data-stu-id="226f5-183">The common exception message in this case would be of the form:</span></span>

> <span data-ttu-id="226f5-184">類型 ' IsolatedType ' 的物件無法轉換成類型 ' IsolatedType '。</span><span class="sxs-lookup"><span data-stu-id="226f5-184">Object of type 'IsolatedType' cannot be converted to type 'IsolatedType'.</span></span>

### <a name="debugging-type-conversion-issues"></a><span data-ttu-id="226f5-185">調試型別轉換問題</span><span class="sxs-lookup"><span data-stu-id="226f5-185">Debugging type conversion issues</span></span>

<span data-ttu-id="226f5-186">假設有一組不相符的類型，也請務必瞭解：</span><span class="sxs-lookup"><span data-stu-id="226f5-186">Given a pair of mismatched types it's important to also know:</span></span>

- <span data-ttu-id="226f5-187">每個類型的 <xref:System.Type.Assembly?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="226f5-187">Each type's <xref:System.Type.Assembly?displayProperty=nameWithType></span></span>
- <span data-ttu-id="226f5-188">每個型別都 <xref:System.Runtime.Loader.AssemblyLoadContext> 可以透過 <xref:System.Runtime.Loader.AssemblyLoadContext.GetLoadContext(System.Reflection.Assembly)?displayProperty=nameWithType> 函數取得。</span><span class="sxs-lookup"><span data-stu-id="226f5-188">Each type's <xref:System.Runtime.Loader.AssemblyLoadContext>, which can be obtained via the <xref:System.Runtime.Loader.AssemblyLoadContext.GetLoadContext(System.Reflection.Assembly)?displayProperty=nameWithType> function.</span></span>

<span data-ttu-id="226f5-189">假設有兩個物件 `a` 和 `b` ，在偵錯工具中評估下列各項將會很有説明：</span><span class="sxs-lookup"><span data-stu-id="226f5-189">Given two objects `a` and `b`, evaluating the following in the debugger will be helpful:</span></span>

```csharp
// In debugger look at each assembly's instance, Location, and FullName
a.GetType().Assembly
b.GetType().Assembly
// In debugger look at each AssemblyLoadContext's instance and name
System.Runtime.Loader.AssemblyLoadContext.GetLoadContext(a.GetType().Assembly)
System.Runtime.Loader.AssemblyLoadContext.GetLoadContext(b.GetType().Assembly)
```

### <a name="resolving-type-conversion-issues"></a><span data-ttu-id="226f5-190">解決類型轉換問題</span><span class="sxs-lookup"><span data-stu-id="226f5-190">Resolving type conversion issues</span></span>

<span data-ttu-id="226f5-191">有兩種設計模式可解決這些類型轉換問題。</span><span class="sxs-lookup"><span data-stu-id="226f5-191">There are two design patterns for solving these type conversion issues.</span></span>

1. <span data-ttu-id="226f5-192">使用一般共用類型。</span><span class="sxs-lookup"><span data-stu-id="226f5-192">Use common shared types.</span></span> <span data-ttu-id="226f5-193">此共用類型可以是基本的執行時間類型，也可以包含在共用元件中建立新的共用類型。</span><span class="sxs-lookup"><span data-stu-id="226f5-193">This shared type can either be a primitive runtime type, or it can involve creating a new shared type in a shared assembly.</span></span>  <span data-ttu-id="226f5-194">共用類型通常是在應用程式元件中定義的 [介面](../../csharp/language-reference/keywords/interface.md) 。</span><span class="sxs-lookup"><span data-stu-id="226f5-194">Often the shared type is an [interface](../../csharp/language-reference/keywords/interface.md) defined in an application assembly.</span></span> <span data-ttu-id="226f5-195">另請參閱：相依性 [如何共用？](#how-are-dependencies-shared)。</span><span class="sxs-lookup"><span data-stu-id="226f5-195">See also: [How are dependencies shared?](#how-are-dependencies-shared).</span></span>

2. <span data-ttu-id="226f5-196">使用封送處理技術，從某個類型轉換成另一個類型。</span><span class="sxs-lookup"><span data-stu-id="226f5-196">Use marshaling techniques to convert from one type to another.</span></span>
