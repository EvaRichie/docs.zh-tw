---
title: 將 WPF 應用程式遷移至 .NET Core 3。0
description: 瞭解如何將 Windows Presentation Foundation (WPF) 應用程式遷移至 .NET Core 3.0。
author: mjrousos
ms.date: 09/12/2019
ms.author: mikerou
ms.openlocfilehash: d8abcde4a941ac6e8f9f438cfe7e30f8d1e8a0bc
ms.sourcegitcommit: 27a15a55019f6b5f2733961738babe94aec0def3
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 09/15/2020
ms.locfileid: "90551942"
---
# <a name="migrating-wpf-apps-to-net-core"></a><span data-ttu-id="ad8a8-103">將 WPF 應用程式遷移至 .NET Core</span><span class="sxs-lookup"><span data-stu-id="ad8a8-103">Migrating WPF apps to .NET Core</span></span>

<span data-ttu-id="ad8a8-104">本文涵蓋將 Windows Presentation Foundation (WPF) 應用程式從 .NET Framework 遷移至 .NET Core 3.0 所需的步驟。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-104">This article covers the steps necessary to migrate a Windows Presentation Foundation (WPF) app from .NET Framework to .NET Core 3.0.</span></span> <span data-ttu-id="ad8a8-105">如果您沒有任何適用于埠的 WPF 應用程式，但想要嘗試此程式，您可以使用[GitHub](https://github.com/dotnet/windows-desktop/tree/master/Samples/BeanTrader)上提供的**Bean Trader**範例應用程式。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-105">If you don't have a WPF app on hand to port, but would like to try out the process, you can use the **Bean Trader** sample app available on [GitHub](https://github.com/dotnet/windows-desktop/tree/master/Samples/BeanTrader).</span></span> <span data-ttu-id="ad8a8-106">以 .NET Framework 4.7.2) 為目標的原始應用程式 (可在 NetFx\BeanTraderClient 資料夾中取得。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-106">The original app (targeting .NET Framework 4.7.2) is available in the NetFx\BeanTraderClient folder.</span></span> <span data-ttu-id="ad8a8-107">首先，我們將說明在一般情況下移植應用程式所需的步驟，然後我們會逐步解說適用于 **Bean Trader** 範例的特定變更。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-107">First we'll explain the steps necessary to port apps in general, and then we'll walk through the specific changes that apply to the **Bean Trader** sample.</span></span>

[!INCLUDE [desktop guide under construction](../../../includes/desktop-guide-preview-note.md)]

<span data-ttu-id="ad8a8-108">若要遷移至 .NET Core，您必須先：</span><span class="sxs-lookup"><span data-stu-id="ad8a8-108">To migrate to .NET Core, you must first:</span></span>

01. <span data-ttu-id="ad8a8-109">瞭解和更新 NuGet 相依性：</span><span class="sxs-lookup"><span data-stu-id="ad8a8-109">Understand and update NuGet dependencies:</span></span>

    01. <span data-ttu-id="ad8a8-110">升級 NuGet 相依性以使用此 `<PackageReference>` 格式。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-110">Upgrade NuGet dependencies to use the `<PackageReference>` format.</span></span>
    01. <span data-ttu-id="ad8a8-111">複習適用于 .NET Core 或 .NET Standard 相容性的最上層 NuGet 相依性。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-111">Review top-level NuGet dependencies for .NET Core or .NET Standard compatibility.</span></span>
    01. <span data-ttu-id="ad8a8-112">將 NuGet 套件升級至較新的版本。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-112">Upgrade NuGet packages to newer versions.</span></span>
    01. <span data-ttu-id="ad8a8-113">使用 [.net 可攜性分析器](../../standard/analyzers/portability-analyzer.md) 來瞭解 .Net 相依性。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-113">Use the [.NET Portability Analyzer](../../standard/analyzers/portability-analyzer.md) to understand .NET dependencies.</span></span>

01. <span data-ttu-id="ad8a8-114">將專案檔案遷移至新的 SDK 樣式格式：</span><span class="sxs-lookup"><span data-stu-id="ad8a8-114">Migrate the project file to the new SDK-style format:</span></span>

    01. <span data-ttu-id="ad8a8-115">選擇是否要以 .NET Core 和 .NET Framework 為目標，或僅以 .NET Core 為目標。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-115">Choose whether to target both .NET Core and .NET Framework, or only .NET Core.</span></span>
    01. <span data-ttu-id="ad8a8-116">將相關的專案檔案屬性和專案複製到新的專案檔。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-116">Copy relevant project file properties and items to the new project file.</span></span>

01. <span data-ttu-id="ad8a8-117">修正組建問題：</span><span class="sxs-lookup"><span data-stu-id="ad8a8-117">Fix build issues:</span></span>

    01. <span data-ttu-id="ad8a8-118">新增對 [Microsoft 相容性](https://www.nuget.org/packages/Microsoft.Windows.Compatibility/) 套件的參考。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-118">Add a reference to the [Microsoft.Windows.Compatibility](https://www.nuget.org/packages/Microsoft.Windows.Compatibility/) package.</span></span>
    01. <span data-ttu-id="ad8a8-119">尋找並修正 API 層級的差異。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-119">Find and fix API-level differences.</span></span>
    01. <span data-ttu-id="ad8a8-120">移除*app.config*或以外的app.config`appSettings` 區段 `connectionStrings` 。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-120">Remove *app.config* sections other than `appSettings` or `connectionStrings`.</span></span>
    01. <span data-ttu-id="ad8a8-121">視需要重新產生產生的程式碼。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-121">Regenerate generated code, if necessary.</span></span>

01. <span data-ttu-id="ad8a8-122">執行時間測試：</span><span class="sxs-lookup"><span data-stu-id="ad8a8-122">Runtime testing:</span></span>

    01. <span data-ttu-id="ad8a8-123">確認已移植的應用程式如預期般運作。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-123">Confirm the ported app works as expected.</span></span>
    01. <span data-ttu-id="ad8a8-124">注意 <xref:System.NotSupportedException> 例外狀況。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-124">Beware of <xref:System.NotSupportedException> exceptions.</span></span>

## <a name="about-the-sample"></a><span data-ttu-id="ad8a8-125">關於範例</span><span class="sxs-lookup"><span data-stu-id="ad8a8-125">About the sample</span></span>

<span data-ttu-id="ad8a8-126">本文參考了 [Bean Trader 範例應用程式](https://github.com/dotnet/windows-desktop/tree/master/Samples/BeanTrader) ，因為它使用的相依性類似于真實世界的 WPF 應用程式可能擁有的各種相依性。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-126">This article references the [Bean Trader sample app](https://github.com/dotnet/windows-desktop/tree/master/Samples/BeanTrader) because it uses a variety of dependencies similar to those that real-world WPF apps might have.</span></span> <span data-ttu-id="ad8a8-127">應用程式並不大，但其目的是從「Hello World」開始，以複雜度為複雜度。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-127">The app isn't large, but is meant to be a step up from 'Hello World' in terms of complexity.</span></span> <span data-ttu-id="ad8a8-128">應用程式會示範在移植實際的應用程式時，使用者可能會遇到的一些問題。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-128">The app demonstrates some issues users may encounter while porting real apps.</span></span> <span data-ttu-id="ad8a8-129">應用程式會與 WCF 服務進行通訊，因此若要讓它正常執行，您也需要執行 BeanTraderServer 專案 (可在相同的 GitHub 存放庫中使用) 並確保 BeanTraderClient 設定指向正確的端點。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-129">The app communicates with a WCF service, so for it to run properly, you'll also need to run the BeanTraderServer project (available in the same GitHub repository) and make sure the BeanTraderClient configuration points to the correct endpoint.</span></span> <span data-ttu-id="ad8a8-130"> (預設情況下，此範例假設伺服器是在相同的電腦上執行 `http://localhost:8090` ，如果您在本機啟動 BeanTraderServer，則會是 true。 ) </span><span class="sxs-lookup"><span data-stu-id="ad8a8-130">(By default, the sample assumes the server is running on the same machine at `http://localhost:8090`, which will be true if you launch BeanTraderServer locally.)</span></span>

<span data-ttu-id="ad8a8-131">請記住，此範例應用程式的目的是要示範 .NET Core 移植的挑戰和解決方案。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-131">Keep in mind that this sample app is meant to demonstrate .NET Core porting challenges and solutions.</span></span> <span data-ttu-id="ad8a8-132">它不是用來示範 WPF 最佳做法。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-132">It's not meant to demonstrate WPF best practices.</span></span> <span data-ttu-id="ad8a8-133">事實上，它會刻意包含一些反模式，以確保您在移植時遇到至少幾個有趣的挑戰。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-133">In fact, it deliberately includes some anti-patterns to make sure you come across at least a couple of interesting challenges while porting.</span></span>

## <a name="getting-ready"></a><span data-ttu-id="ad8a8-134">準備就緒</span><span class="sxs-lookup"><span data-stu-id="ad8a8-134">Getting ready</span></span>

<span data-ttu-id="ad8a8-135">將 .NET Framework 應用程式遷移至 .NET Core 的主要挑戰是它的相依性可能會以不同的方式運作。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-135">The primary challenge of migrating a .NET Framework app to .NET Core is that its dependencies may work differently or not at all.</span></span> <span data-ttu-id="ad8a8-136">遷移比以往更容易;許多 NuGet 套件現在都以 .NET Standard 為目標。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-136">Migration is much easier than it used to be; many NuGet packages now target .NET Standard.</span></span> <span data-ttu-id="ad8a8-137">從 .NET Core 2.0 開始，.NET Framework 和 .NET Core 介面區都很類似。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-137">Starting with .NET Core 2.0, the .NET Framework and .NET Core surface areas have become similar.</span></span> <span data-ttu-id="ad8a8-138">儘管如此， (NuGet 套件和可用 .NET Api 中的支援也) 保留。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-138">Even so, some differences (both in support from NuGet packages and in available .NET APIs) remain.</span></span> <span data-ttu-id="ad8a8-139">遷移的第一個步驟是檢查應用程式的相依性，並確保參考的格式可以輕鬆地遷移至 .NET Core。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-139">The first step in migrating is to review the app's dependencies and make sure references are in a format that's easily migrated to .NET Core.</span></span>

### <a name="upgrade-to-packagereference-nuget-references"></a><span data-ttu-id="ad8a8-140">升級至 `<PackageReference>` NuGet 參考</span><span class="sxs-lookup"><span data-stu-id="ad8a8-140">Upgrade to `<PackageReference>` NuGet references</span></span>

<span data-ttu-id="ad8a8-141">較舊的 .NET Framework 專案通常會在 *packages.config* 檔案中列出其 NuGet 相依性。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-141">Older .NET Framework projects typically list their NuGet dependencies in a *packages.config* file.</span></span> <span data-ttu-id="ad8a8-142">新的 SDK 樣式專案檔案格式會以 [`<PackageReference>`](/nuget/consume-packages/package-references-in-project-files) .csproj 檔案本身的元素，而不是在個別的設定檔中參考 NuGet 套件。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-142">The new SDK-style project file format references NuGet packages as [`<PackageReference>`](/nuget/consume-packages/package-references-in-project-files) elements in the csproj file itself rather than in a separate config file.</span></span>

<span data-ttu-id="ad8a8-143">在遷移時，使用樣式參考有兩個優點 `<PackageReference>` ：</span><span class="sxs-lookup"><span data-stu-id="ad8a8-143">When migrating, there are two advantages to using `<PackageReference>`-style references:</span></span>

- <span data-ttu-id="ad8a8-144">這是新的 .NET Core 專案檔案所需的 NuGet 參考樣式。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-144">This is the style of NuGet reference that is required for the new .NET Core project file.</span></span> <span data-ttu-id="ad8a8-145">如果您已在使用 `<PackageReference>` 中，可以將這些專案檔專案直接複製並貼到新的專案中。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-145">If you're already using `<PackageReference>`, those project file elements can be copied and pasted directly into the new project.</span></span>
- <span data-ttu-id="ad8a8-146">不同于 packages.config 檔案， `<PackageReference>` 元素只會參考您的專案相依的最上層相依性。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-146">Unlike a packages.config file, `<PackageReference>` elements only refer to the top-level dependencies that your project depends on directly.</span></span> <span data-ttu-id="ad8a8-147">所有其他的可轉移 NuGet 套件將會在還原時決定，並記錄在自動產生的 obj\project.assets.js檔案中。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-147">All other transitive NuGet packages will be determined at restore time and recorded in the autogenerated obj\project.assets.json file.</span></span> <span data-ttu-id="ad8a8-148">這可讓您更輕鬆地判斷專案的相依性，這在判斷所需的相依性是否可在 .NET Core 上運作時相當實用。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-148">This makes it much easier to determine what dependencies your project has, which is useful when determining whether the necessary dependencies will work on .NET Core or not.</span></span>

<span data-ttu-id="ad8a8-149">將 .NET Framework 應用程式遷移至 .NET Core 的第一個步驟是將其更新為使用 `<PackageReference>` NuGet 參考。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-149">The first step to migrating a .NET Framework app to .NET Core is to update it to use `<PackageReference>` NuGet references.</span></span> <span data-ttu-id="ad8a8-150">Visual Studio 讓這種情況變得簡單。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-150">Visual Studio makes this simple.</span></span> <span data-ttu-id="ad8a8-151">您只需在 Visual Studio 的**方案總管**中，以滑鼠右鍵按一下專案的*packages.config*檔案，然後選取 [**將 packages.config 遷移至 PackageReference**]。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-151">Just right-click the project's *packages.config* file in Visual Studio's **Solution Explorer**, and then select **Migrate packages.config to PackageReference**.</span></span>

![升級至 PackageReference](./media/convert-project-from-net-framework/package-reference-migration.png)

<span data-ttu-id="ad8a8-153">隨即出現一個對話方塊，顯示計算最上層的 NuGet 相依性，並詢問哪些其他 NuGet 套件應升級為最上層。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-153">A dialog appears showing calculated top-level NuGet dependencies and asking which other NuGet packages should be promoted to top-level.</span></span> <span data-ttu-id="ad8a8-154">這些其他封裝都不需要是 Bean Trader 範例的最上層，所以您可以取消選取所有這些方塊。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-154">None of these other packages need to be top-level for the Bean Trader sample, so you can uncheck all of those boxes.</span></span> <span data-ttu-id="ad8a8-155">然後按一下 **[確定]** ，就會移除 *packages.config* 的檔案，並將 `<PackageReference>` 專案新增至專案檔。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-155">Then, click **Ok** and the *packages.config* file is removed and `<PackageReference>` elements are added to the project file.</span></span>

<span data-ttu-id="ad8a8-156">`<PackageReference>`-樣式參考不會將 NuGet 套件儲存在本機的封裝資料夾中。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-156">`<PackageReference>`-style references don't store NuGet packages locally in a packages folder.</span></span> <span data-ttu-id="ad8a8-157">相反地，它們會在全域儲存為優化。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-157">Instead, they're stored globally as an optimization.</span></span> <span data-ttu-id="ad8a8-158">完成遷移之後，請編輯 .csproj 檔案，並移除任何 `<Analyzer>` 參考先前來自的分析器的元素 *。\packages* 目錄。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-158">After the migration completes, edit the csproj file and remove any `<Analyzer>` elements referring to the analyzers that previously came from the *..\packages* directory.</span></span> <span data-ttu-id="ad8a8-159">別擔心，因為您仍有 NuGet 套件參考，所以分析器將包含在專案中。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-159">Don't worry; since you still have the NuGet package references, the analyzers will be included in the project.</span></span> <span data-ttu-id="ad8a8-160">您只需要清除舊的 packages.config 樣式 `<Analyzer>` 元素。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-160">You just need to clean up the old packages.config-style `<Analyzer>` elements.</span></span>

### <a name="review-nuget-packages"></a><span data-ttu-id="ad8a8-161">檢查 NuGet 套件</span><span class="sxs-lookup"><span data-stu-id="ad8a8-161">Review NuGet packages</span></span>

<span data-ttu-id="ad8a8-162">現在您可以看到專案所相依的最上層 NuGet 套件，您可以複習這些封裝是否可在 .NET Core 上使用。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-162">Now that you can see the top-level NuGet packages that the project depends on, you can review whether those packages are available on .NET Core.</span></span> <span data-ttu-id="ad8a8-163">您可以在 [nuget.org](https://www.nuget.org/)上查看套件的相依性，以判斷套件是否支援 .net Core。建立社區的 [fuget.org](https://www.fuget.org/) 網站會在 [套件資訊] 頁面的頂端醒目顯示這項資訊。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-163">You can determine whether a package supports .NET Core by looking at its dependencies on [nuget.org](https://www.nuget.org/). The community-created [fuget.org](https://www.fuget.org/) site shows this information prominently at the top of the package information page.</span></span>

<span data-ttu-id="ad8a8-164">以 .net core 3.0 為目標時，以 .NET core 或 .NET Standard 為目標的任何套件都應可運作 (因為 .NET Core 會執行 .NET Standard 介面區) 。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-164">When targeting .NET Core 3.0, any packages targeting .NET Core or .NET Standard should work (since .NET Core implements the .NET Standard surface area).</span></span> <span data-ttu-id="ad8a8-165">在某些情況下，所使用套件的特定版本不會以 .NET Core 或 .NET Standard 為目標，但較新的版本將會。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-165">In some cases, the specific version of a package that's used won't target .NET Core or .NET Standard, but newer versions will.</span></span> <span data-ttu-id="ad8a8-166">在此情況下，您應該考慮升級為最新版本的套件。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-166">In this case, you should consider upgrading to the latest version of the package.</span></span>

<span data-ttu-id="ad8a8-167">您也可以使用以 .NET Framework 為目標的封裝，但這會帶來一些風險。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-167">You can use packages targeting .NET Framework, as well, but that introduces some risk.</span></span> <span data-ttu-id="ad8a8-168">您可以使用 .NET Core 來 .NET Framework 相依性，因為 .NET Core 和 .NET Framework 介面區十分類似，這類的相依性 *通常* 可以運作。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-168">.NET Core to .NET Framework dependencies are allowed because .NET Core and .NET Framework surface areas are similar enough that such dependencies *often* work.</span></span> <span data-ttu-id="ad8a8-169">不過，如果套件嘗試使用 .net Core 中不存在的 .NET API，您將會遇到執行時間例外狀況。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-169">However, if the package tries to use a .NET API that isn't present in .NET Core, you'll encounter a runtime exception.</span></span> <span data-ttu-id="ad8a8-170">因此，當沒有其他可用的選項時，您應該只參考 .NET Framework 套件，並瞭解這麼做會造成測試負擔。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-170">Because of that, you should only reference .NET Framework packages when no other options are available and understand that doing so imposes a test burden.</span></span>

<span data-ttu-id="ad8a8-171">如果參考的套件未以 .NET Core 或 .NET Standard 為目標，您必須考慮其他替代方案：</span><span class="sxs-lookup"><span data-stu-id="ad8a8-171">If there are packages referenced that don't target .NET Core or .NET Standard, you'll have to think about other alternatives:</span></span>

- <span data-ttu-id="ad8a8-172">是否有其他類似的套件可以改用？</span><span class="sxs-lookup"><span data-stu-id="ad8a8-172">Are there other similar packages that can be used instead?</span></span> <span data-ttu-id="ad8a8-173">有時候 NuGet 作者會發佈個別的 '。其程式庫的核心版本，專門以 .NET Core 為目標。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-173">Sometimes NuGet authors publish separate '.Core' versions of their libraries specifically targeting .NET Core.</span></span> <span data-ttu-id="ad8a8-174">企業程式庫套件是「社區發佈」的範例。NetCore "替代方案。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-174">Enterprise Library packages are an example of the community publishing ".NetCore" alternatives.</span></span> <span data-ttu-id="ad8a8-175">在其他情況下，特定服務的較新 Sdk (有時會有不同的封裝名稱) 可供 .NET Standard 使用。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-175">In other cases, newer SDKs for a particular service (sometimes with different package names) are available for .NET Standard.</span></span> <span data-ttu-id="ad8a8-176">如果沒有可用的替代方案，您可以繼續使用 .NET Framework 目標套件，並記住，在 .NET Core 上執行之後，您必須徹底測試它們。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-176">If no alternatives are available, you can proceed using the .NET Framework-targeted packages, bearing in mind that you'll need to test them thoroughly once running on .NET Core.</span></span>

<span data-ttu-id="ad8a8-177">Bean Trader 範例具有下列最上層 NuGet 相依性：</span><span class="sxs-lookup"><span data-stu-id="ad8a8-177">The Bean Trader sample has the following top-level NuGet dependencies:</span></span>

- [<span data-ttu-id="ad8a8-178">**Castle. Windsor，version 4.1。1**</span><span class="sxs-lookup"><span data-stu-id="ad8a8-178">**Castle.Windsor, version 4.1.1**</span></span>](https://www.castleproject.org/projects/windsor/)  

  <span data-ttu-id="ad8a8-179">此封裝的目標 .NET Standard 1.6，因此可在 .NET Core 上運作。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-179">This package targets .NET Standard 1.6, so it works on .NET Core.</span></span>

- [<span data-ttu-id="ad8a8-180">**CodeAnalysis. 將 microsoft.codeanalysis.fxcopanalyzers，version 2.6。3**</span><span class="sxs-lookup"><span data-stu-id="ad8a8-180">**Microsoft.CodeAnalysis.FxCopAnalyzers, version 2.6.3**</span></span>](https://www.nuget.org/packages/Microsoft.CodeAnalysis.FxCopAnalyzers/2.6.3)  
  <span data-ttu-id="ad8a8-181">這是中繼套件，因此不會立即察覺它所支援的平臺，但 [檔](https://github.com/dotnet/roslyn-analyzers#microsoftcodeanalysisfxcopanalyzers) 會指出其最新版本 (2.9.2) 適用于 .NET FRAMEWORK 和 .net Core。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-181">This is a meta-package, so it's not immediately obvious which platforms it supports, but [documentation](https://github.com/dotnet/roslyn-analyzers#microsoftcodeanalysisfxcopanalyzers) indicates that its newest version (2.9.2) will work for both .NET Framework and .NET Core.</span></span>

- [<span data-ttu-id="ad8a8-182">**Nito. AsyncEx，version 4.0。1**</span><span class="sxs-lookup"><span data-stu-id="ad8a8-182">**Nito.AsyncEx, version 4.0.1**</span></span>](https://www.nuget.org/packages/Nito.AsyncEx/4.0.1)  

  <span data-ttu-id="ad8a8-183">此套件不是以 .NET Core 為目標，但較新的5.0 版本會執行。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-183">This package doesn't target .NET Core, but the newer 5.0 version does.</span></span> <span data-ttu-id="ad8a8-184">這在遷移時很常見，因為許多 NuGet 套件已新增 .NET Standard 的支援，但較舊的專案版本只會以 .NET Framework 為目標。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-184">This is common when migrating because many NuGet packages have added .NET Standard support recently, but older project versions will only target .NET Framework.</span></span> <span data-ttu-id="ad8a8-185">如果版本差異只是次要版本差異，通常可以輕鬆地升級至較新的版本。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-185">If the version difference is only a minor version difference, it's often easy to upgrade to the newer version.</span></span> <span data-ttu-id="ad8a8-186">因為這是主要版本變更，所以您必須謹慎升級，因為封裝中可能有重大變更。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-186">Because this is a major version change, you need to be cautious upgrading since there could be breaking changes in the package.</span></span> <span data-ttu-id="ad8a8-187">但有一個途徑是不錯的。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-187">There is a path forward, though, which is good.</span></span>

- [<span data-ttu-id="ad8a8-188">**MahApps Metro，version 1.6。5**</span><span class="sxs-lookup"><span data-stu-id="ad8a8-188">**MahApps.Metro, version 1.6.5**</span></span>](https://www.nuget.org/packages/MahApps.Metro/1.6.5)  

  <span data-ttu-id="ad8a8-189">此套件也不是以 .NET Core 為目標，但是有較新的發行前版本 (2.0-Alpha) 。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-189">This package also doesn't target .NET Core, but has a newer pre-release (2.0-alpha) that does.</span></span> <span data-ttu-id="ad8a8-190">同樣地，您必須瞭解是否有重大變更，但較新的封裝很鼓勵。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-190">Again, you have to look out for breaking changes, but the newer package is encouraging.</span></span>

<span data-ttu-id="ad8a8-191">Bean Trader 範例的 NuGet 相依性全都以 .NET Standard/.NET Core 為目標，或有較新的版本，因此這裡不太可能發生任何封鎖問題。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-191">The Bean Trader sample's NuGet dependencies all either target .NET Standard/.NET Core or have newer versions that do, so there are unlikely to be any blocking issues here.</span></span>

### <a name="upgrade-nuget-packages"></a><span data-ttu-id="ad8a8-192">升級 NuGet 套件</span><span class="sxs-lookup"><span data-stu-id="ad8a8-192">Upgrade NuGet packages</span></span>

<span data-ttu-id="ad8a8-193">可能的話，最好先升級所有以 .NET Core 為目標的套件版本，或在此時以較新版本為目標 .NET Standard 套件的版本， (專案仍以 .NET Framework) 的目標，以及早探索及解決任何重大變更。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-193">If possible, it would be good to upgrade the versions of any packages that only target .NET Core or .NET Standard with more recent versions at this point (with the project still targeting .NET Framework) to discover and address any breaking changes early.</span></span>

<span data-ttu-id="ad8a8-194">如果您不想對現有的 .NET Framework 版本的應用程式進行任何內容變更，則可以等到您有以 .NET Core 為目標的新專案檔。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-194">If you would rather not make any material changes to the existing .NET Framework version of the app, this can wait until you have a new project file targeting .NET Core.</span></span> <span data-ttu-id="ad8a8-195">不過，事先將 NuGet 套件升級為 .NET Core 相容版本，可讓您更輕鬆地建立新的專案檔，並減少應用程式 .NET Framework 和 .NET Core 版本之間的差異數目。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-195">However, upgrading the NuGet packages to .NET Core-compatible versions ahead of time makes the migration process even easier once you create the new project file and reduces the number of differences between the .NET Framework and .NET Core versions of the app.</span></span>

<span data-ttu-id="ad8a8-196">使用 Bean Trader 範例，您可以使用 Visual Studio 的 NuGet 套件) 管理員，輕鬆地 (所有必要的升級，但有一項例外：從 **MahApps** 升級至 **2.0** 會顯示與主題和輔色管理 api 相關的重大變更。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-196">With the Bean Trader sample, all of the necessary upgrades can be made easily (using Visual Studio's NuGet package manager) with one exception: upgrading from **MahApps.Metro 1.6.5** to **2.0** reveals breaking changes related to theme and accent management APIs.</span></span>

<span data-ttu-id="ad8a8-197">在理想的情況下，應用程式會更新為使用較新版本的套件 (，因為這比較可能是在 .NET Core) 上運作。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-197">Ideally, the app would be updated to use the newer version of the package (since that is more likely to work on .NET Core).</span></span> <span data-ttu-id="ad8a8-198">不過，在某些情況下，這可能不可行。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-198">In some cases, however, that may not be feasible.</span></span> <span data-ttu-id="ad8a8-199">在這些情況下，請勿升級 **MahApps** ，因為必要的變更並不重要，而本教學課程著重于遷移至 .net Core 3，而不是 **MahApps。 Metro 2。**</span><span class="sxs-lookup"><span data-stu-id="ad8a8-199">In these cases, don't upgrade **MahApps.Metro** because the necessary changes are non-trivial and this tutorial focuses on migrating to .NET Core 3, not to **MahApps.Metro 2.**</span></span> <span data-ttu-id="ad8a8-200">此外，這也是低風險的 .NET Framework 相依性，因為 Trader 應用程式只會練習 **MahApps**的一小部分。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-200">Also, this is a low-risk .NET Framework dependency because the Bean Trader app only exercises a small part of **MahApps.Metro**.</span></span> <span data-ttu-id="ad8a8-201">當然，它也需要進行測試，以確保完成遷移後，一切都能正常運作。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-201">It will, of course, require testing to make sure everything's working once the migration is complete.</span></span> <span data-ttu-id="ad8a8-202">如果這是真實世界的案例，則最好提出問題來追蹤移至 **MahApps** 2.0 版的工作，因為未進行遷移，現在會保留在某些技術債務的背後。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-202">If this were a real-world scenario, it would be good to file an issue to track the work to move to **MahApps.Metro** version 2.0 since not doing the migration now leaves behind some technical debt.</span></span>

<span data-ttu-id="ad8a8-203">將 NuGet 套件更新至最新版本之後， `<PackageReference>` Bean Trader 範例的專案檔中的專案群組看起來應該像這樣。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-203">Once the NuGet packages are updated to recent versions, the `<PackageReference>` item group in the Bean Trader sample's project file should look like this.</span></span>

```xml
<ItemGroup>
  <PackageReference Include="Castle.Windsor">
    <Version>4.1.1</Version>
  </PackageReference>
  <PackageReference Include="MahApps.Metro">
    <Version>1.6.5</Version>
  </PackageReference>
  <PackageReference Include="Microsoft.CodeAnalysis.FxCopAnalyzers">
    <Version>2.9.2</Version>
  </PackageReference>
  <PackageReference Include="Nito.AsyncEx">
    <Version>5.0.0</Version>
  </PackageReference>
</ItemGroup>
```

### <a name="net-framework-portability-analysis"></a><span data-ttu-id="ad8a8-204">.NET Framework 可攜性分析</span><span class="sxs-lookup"><span data-stu-id="ad8a8-204">.NET Framework portability analysis</span></span>

<span data-ttu-id="ad8a8-205">一旦您瞭解專案的 NuGet 相依性狀態之後，接下來要考慮的事項是 .NET Framework API 相依性。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-205">Once you understand the state of your project's NuGet dependencies, the next thing to consider is .NET Framework API dependencies.</span></span> <span data-ttu-id="ad8a8-206">[.Net 可攜性分析器](../../standard/analyzers/portability-analyzer.md)工具很適合用來瞭解您的專案所使用的哪些 .net api 可在其他 .net 平臺上使用。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-206">The [.NET Portability Analyzer](../../standard/analyzers/portability-analyzer.md) tool is useful for understanding which of the .NET APIs your project uses are available on other .NET platforms.</span></span>

<span data-ttu-id="ad8a8-207">此工具是 [Visual Studio 外掛程式](https://marketplace.visualstudio.com/items?itemName=ConnieYau.NETPortabilityAnalyzer)、 [命令列工具](https://github.com/Microsoft/dotnet-apiport/releases)，或包裝在 [簡單的 GUI](https://github.com/Microsoft/dotnet-apiport-ui)中，可簡化其選項。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-207">The tool comes as a [Visual Studio plugin](https://marketplace.visualstudio.com/items?itemName=ConnieYau.NETPortabilityAnalyzer), a [command-line tool](https://github.com/Microsoft/dotnet-apiport/releases), or wrapped in a [simple GUI](https://github.com/Microsoft/dotnet-apiport-ui), which simplifies its options.</span></span> <span data-ttu-id="ad8a8-208">您可以使用將 [桌面應用程式移植到 .Net Core](https://devblogs.microsoft.com/dotnet/porting-desktop-apps-to-net-core/) blog 文章中的 GUI，深入瞭解如何使用 .Net 可攜性分析器 (API 埠) 。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-208">You can read more about using the .NET Portability Analyzer (API Port) using the GUI in the [Porting desktop apps to .NET Core](https://devblogs.microsoft.com/dotnet/porting-desktop-apps-to-net-core/) blog post.</span></span> <span data-ttu-id="ad8a8-209">如果您偏好使用命令列，則必要的步驟如下：</span><span class="sxs-lookup"><span data-stu-id="ad8a8-209">If you prefer to use the command line, the necessary steps are:</span></span>

1. <span data-ttu-id="ad8a8-210">如果您還沒有 [.net 可攜性分析器](https://github.com/Microsoft/dotnet-apiport/releases) ，請加以下載。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-210">Download the [.NET Portability Analyzer](https://github.com/Microsoft/dotnet-apiport/releases) if you don't already have it.</span></span>
1. <span data-ttu-id="ad8a8-211">請確定要成功移植組建的 .NET Framework 應用程式， (這在遷移之前是不錯的想法，無論) 。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-211">Make sure the .NET Framework app to be ported builds successfully (this is a good idea prior to migration regardless).</span></span>
1. <span data-ttu-id="ad8a8-212">使用如下的命令列執行 API 埠。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-212">Run API Port with a command line like this.</span></span>

    ```console
    ApiPort.exe analyze -f <PathToBeanTraderBinaries> -r html -r excel -t ".NET Core"
    ```

    <span data-ttu-id="ad8a8-213">`-f`引數會指定包含要分析之二進位檔的路徑。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-213">The `-f` argument specifies the path containing the binaries to analyze.</span></span> <span data-ttu-id="ad8a8-214">`-r`引數會指定您想要的輸出檔案格式。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-214">The `-r` argument specifies which output file format you want.</span></span> <span data-ttu-id="ad8a8-215">`-t`引數會指定要對其分析 API 使用量的 .net 平臺。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-215">The `-t` argument specifies which .NET platform to analyze API usage against.</span></span> <span data-ttu-id="ad8a8-216">在此情況下，您需要 .NET Core。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-216">In this case, you want .NET Core.</span></span>

<span data-ttu-id="ad8a8-217">當您開啟 HTML 報表時，第一個區段會列出所有已分析的二進位檔，以及它們所使用的 .NET Api 百分比在目標平臺上可供使用。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-217">When you open the HTML report, the first section will list all of the analyzed binaries and what percentage of the .NET APIs they use are available on the targeted platform.</span></span> <span data-ttu-id="ad8a8-218">百分比本身並沒有意義。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-218">The percentage is not meaningful by itself.</span></span> <span data-ttu-id="ad8a8-219">更有用的是查看遺失的特定 Api。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-219">What's more useful is to see the specific APIs that are missing.</span></span> <span data-ttu-id="ad8a8-220">若要這樣做，請選取元件名稱，或向下滾動至個別元件的報表。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-220">To do that, either select an assembly name or scroll down to the reports for individual assemblies.</span></span>

<span data-ttu-id="ad8a8-221">將焦點放在您擁有原始程式碼的元件上。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-221">Focus on the assemblies that you own the source code for.</span></span> <span data-ttu-id="ad8a8-222">例如，在 [Bean Trader ApiPort] 報表中，有許多二進位檔列出，但大部分都屬於 NuGet 套件。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-222">In the Bean Trader ApiPort report, for example, there are many binaries listed, but most of them belong to NuGet packages.</span></span> <span data-ttu-id="ad8a8-223">`Castle.Windsor` 顯示它相依于 .NET Core 中遺失的一些 Web.config Api。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-223">`Castle.Windsor` shows that it depends on some System.Web APIs that are missing in .NET Core.</span></span> <span data-ttu-id="ad8a8-224">這不是問題，因為您先前已確認是否 `Castle.Windsor` 支援 .Net Core。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-224">This isn't a concern because you previously verified that `Castle.Windsor` supports .NET Core.</span></span> <span data-ttu-id="ad8a8-225">NuGet 套件通常會有不同的二進位檔可與不同的 .NET 平臺搭配使用，因此 `Castle.Windsor` 只要封裝也是以 .NET Standard 或 .Net Core (（) ）為目標，則 .NET Framework 版的會是不相關的。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-225">It is common for NuGet packages to have different binaries for use with different .NET platforms, so whether the .NET Framework version of `Castle.Windsor` uses System.Web APIs or not is irrelevant as long as the package also targets .NET Standard or .NET Core (which it does).</span></span>

<span data-ttu-id="ad8a8-226">使用 Bean Trader 範例，您需要考慮的唯一二進位檔是 **BeanTraderClient** ，而且報表會顯示只有兩個 .net api 遺失： `System.ServiceModel.ClientBase<T>.Close` 和 `System.ServiceModel.ClientBase<T>.Open` 。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-226">With the Bean Trader sample, the only binary that you need to consider is **BeanTraderClient** and the report shows that only two .NET APIs are missing: `System.ServiceModel.ClientBase<T>.Close` and `System.ServiceModel.ClientBase<T>.Open`.</span></span>

![BeanTraderClient 可攜性報表](./media/convert-project-from-net-framework/portability-report.png)

<span data-ttu-id="ad8a8-228">因為 WCF 用戶端 Api 大多 (.NET Core 上的) 支援，所以這些核心用戶端 Api 很不可能發生封鎖問題，因此這些中央 Api 必須有替代方案。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-228">These are unlikely to be blocking issues because WCF Client APIs are (mostly) supported on .NET Core, so there must be alternatives available for these central APIs.</span></span> <span data-ttu-id="ad8a8-229">事實上，查看 `System.ServiceModel` .Net core 介面區 (使用 <https://apisof.net>) ，您會看到 .net core 中有非同步替代方案。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-229">In fact, looking at `System.ServiceModel`'s .NET Core surface area (using <https://apisof.net>), you see that there are async alternatives in .NET Core instead.</span></span>

<span data-ttu-id="ad8a8-230">根據這份報告和先前的 NuGet 相依性分析，您似乎不會有將 Bean Trader 範例遷移至 .NET Core 的主要問題。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-230">Based on this report and the previous NuGet dependency analysis, it looks like there should be no major issues migrating the Bean Trader sample to .NET Core.</span></span> <span data-ttu-id="ad8a8-231">您已經準備好進行下一個步驟，您將在其中實際開始進行遷移。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-231">You're ready for the next step in which you'll actually start the migration.</span></span>

## <a name="migrating-the-project-file"></a><span data-ttu-id="ad8a8-232">移轉專案檔</span><span class="sxs-lookup"><span data-stu-id="ad8a8-232">Migrating the project file</span></span>

<span data-ttu-id="ad8a8-233">如果您的應用程式未使用新的 [SDK 樣式專案檔案格式](../../core/tools/csproj.md)，您將需要以 .net Core 為目標的新專案檔。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-233">If your app isn't using the new [SDK-style project file format](../../core/tools/csproj.md), you'll need a new project file to target .NET Core.</span></span> <span data-ttu-id="ad8a8-234">您可以取代現有的 .csproj 檔案，或者，如果您想要讓現有的專案保持不變，您可以加入以 .NET Core 為目標的新 .csproj 檔案。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-234">You can replace the existing csproj file or, if you prefer to keep the existing project untouched in its current state, you can add a new csproj file targeting .NET Core.</span></span> <span data-ttu-id="ad8a8-235">您可以使用單一 SDK 樣式專案檔來建立 .NET Framework 和 .NET Core 的應用程式版本，並使用 [多目標](../../standard/library-guidance/cross-platform-targeting.md) (指定多個 `<TargetFrameworks>` 目標) 。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-235">You can build versions of the app for .NET Framework and .NET Core with a single SDK-style project file with [multi-targeting](../../standard/library-guidance/cross-platform-targeting.md) (specifying multiple `<TargetFrameworks>` targets).</span></span>

<span data-ttu-id="ad8a8-236">若要建立新的專案檔，您可以在 Visual Studio 中建立新的 WPF 專案，或在 `dotnet new wpf` 臨時目錄中使用命令來產生專案檔，然後將它複製/重新命名為正確的位置。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-236">To create the new project file, you can create a new WPF project in Visual Studio or use the `dotnet new wpf` command in a temporary directory to generate the project file and then copy/rename it to the correct location.</span></span> <span data-ttu-id="ad8a8-237">另外還有一個 [CsprojToVs2017](https://github.com/hvanbakel/CsprojToVs2017)的工具，可將部分專案檔案遷移自動化。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-237">There is also a community-created tool, [CsprojToVs2017](https://github.com/hvanbakel/CsprojToVs2017), that can automate some of the project file migration.</span></span> <span data-ttu-id="ad8a8-238">此工具很有説明，但仍需要人力來檢查結果，以確保遷移的所有詳細資料都正確無誤。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-238">The tool is helpful but still needs a human to review the results to make sure all the details of the migration are correct.</span></span> <span data-ttu-id="ad8a8-239">工具未以最佳方式處理的某個特定區域是從 *packages.config* 檔案遷移 NuGet 套件。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-239">One particular area that the tool doesn't handle optimally is migrating NuGet packages from *packages.config* files.</span></span> <span data-ttu-id="ad8a8-240">如果此工具是在仍使用 *packages.config* 檔案參考 NuGet 套件的專案檔上執行，它會自動遷移至專案 `<PackageReference>` ，但會 `<PackageReference>` 為 *所有* 封裝（而不只是最上層的封裝）新增元素。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-240">If the tool runs on a project file that still uses a *packages.config* file to reference NuGet packages, it will migrate to `<PackageReference>` elements automatically, but will add `<PackageReference>` elements for *all* of the packages instead of just top-level ones.</span></span> <span data-ttu-id="ad8a8-241">如果您已經使用 Visual Studio (來遷移至專案 `<PackageReference>` ，則) 此工具可協助您進行其餘的轉換。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-241">If you have already migrated to`<PackageReference>` elements with Visual Studio (as you've done in this sample), then the tool can help with the rest of the conversion.</span></span> <span data-ttu-id="ad8a8-242">如同 Scott Hanselman，建議在他的文章中，介紹如何 [遷移 .csproj](https://www.hanselman.com/blog/UpgradingAnExistingNETProjectFilesToTheLeanNewCSPROJFormatFromNETCore.aspx)檔案、手動移植是教育版，而且如果您只有幾個專案要移植，則會提供更好的結果。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-242">Like Scott Hanselman recommends in [his blog post on migrating csproj files](https://www.hanselman.com/blog/UpgradingAnExistingNETProjectFilesToTheLeanNewCSPROJFormatFromNETCore.aspx), porting by hand is educational and will give better results if you only have a few projects to port.</span></span> <span data-ttu-id="ad8a8-243">但是，如果您要移植數十個或數百個專案檔，則 [CsprojToVs2017](https://github.com/hvanbakel/CsprojToVs2017) 之類的工具可能會是一項協助。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-243">But if you're porting dozens or hundreds of project files, then a tool like [CsprojToVs2017](https://github.com/hvanbakel/CsprojToVs2017) can be a help.</span></span>

<span data-ttu-id="ad8a8-244">若要為 Bean Trader 範例建立新的專案檔，請 `dotnet new wpf` 在臨時目錄中執行，並將產生的 *.csproj*檔案移至*BeanTraderClient*資料夾，然後將它重新命名為**BeanTraderClient。**</span><span class="sxs-lookup"><span data-stu-id="ad8a8-244">To create a new project file for the Bean Trader sample, run `dotnet new wpf` in a temporary directory and move the generated *.csproj* file into the *BeanTraderClient* folder and rename it **BeanTraderClient.Core.csproj**.</span></span>

<span data-ttu-id="ad8a8-245">由於新的專案檔格式會自動包含 c # 檔案、 *resx* 檔案，以及它在目錄中找到的 XAML 檔案，因此專案檔已經幾乎完成了！</span><span class="sxs-lookup"><span data-stu-id="ad8a8-245">Because the new project file format automatically includes C# files, *resx* files, and XAML files that it finds in or under its directory, the project file is already almost complete!</span></span> <span data-ttu-id="ad8a8-246">若要完成遷移，請並存開啟舊的和新的專案檔，並查看舊的專案檔，以查看是否有任何包含的資訊需要遷移。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-246">To finish the migration, open the old and new project files side-by-side and look through the old one to see if any information it contains needs to be migrated.</span></span> <span data-ttu-id="ad8a8-247">在 [Bean Trader] 範例案例中，應該將下列專案複製到新的專案：</span><span class="sxs-lookup"><span data-stu-id="ad8a8-247">In the Bean Trader sample case, the following items should be copied to the new project:</span></span>

- <span data-ttu-id="ad8a8-248">`<RootNamespace>` `<AssemblyName>` `<ApplicationIcon>` 應該全部複製、和屬性。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-248">The `<RootNamespace>`, `<AssemblyName>`, and `<ApplicationIcon>` properties should all be copied.</span></span>

- <span data-ttu-id="ad8a8-249">您也必須將屬性加入 `<GenerateAssemblyInfo>false</GenerateAssemblyInfo>` 至新的專案檔，因為 Bean Trader 範例包含元件層級屬性 (例如 `[AssemblyTitle]` AssemblyInfo.cs 檔中的) 。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-249">You also need to add a `<GenerateAssemblyInfo>false</GenerateAssemblyInfo>` property to the new project file since the Bean Trader sample includes assembly-level attributes (like `[AssemblyTitle]`) in an AssemblyInfo.cs file.</span></span> <span data-ttu-id="ad8a8-250">根據預設，新的 SDK 樣式專案會根據 .csproj 檔案中的屬性自動產生這些屬性。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-250">By default, new SDK-style projects will autogenerate these attributes based on properties in the csproj file.</span></span> <span data-ttu-id="ad8a8-251">因為您不想在這種情況下發生此情況 (自動產生的屬性會與來自 AssemblyInfo.cs) 的屬性衝突，所以您可以停用自動產生的屬性 `<GenerateAssemblyInfo>` 。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-251">Because you don't want that to happen in this case (the autogenerated attributes would conflict with those from AssemblyInfo.cs), you disable the autogenerated attributes with `<GenerateAssemblyInfo>`.</span></span>

- <span data-ttu-id="ad8a8-252">雖然 *resx* 檔會自動包含為內嵌資源，但其他 `<Resource>` 專案（例如影像）則否。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-252">Although *resx* files are automatically included as embedded resources, other `<Resource>` items like images are not.</span></span> <span data-ttu-id="ad8a8-253">因此，請複製內嵌 `<Resource>` 影像和圖示檔的元素。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-253">So, copy the `<Resource>` elements for embedding image and icon files.</span></span> <span data-ttu-id="ad8a8-254">您可以使用新的專案檔案格式支援萬用字元模式，將 png 參考簡化為單一行： `<Resource Include="**\*.png" />` 。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-254">You can simplify the png references to a single line by using the new project file format's support for globbing patterns: `<Resource Include="**\*.png" />`.</span></span>

- <span data-ttu-id="ad8a8-255">同樣地， `<None>` 專案會自動包含在內，但預設不會將它們複製到輸出目錄。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-255">Similarly, `<None>` items are included automatically, but they aren't copied to the output directory, by default.</span></span> <span data-ttu-id="ad8a8-256">由於 Bean Trader 專案包含 `<None>` 複製到輸出目錄*is*的專案， (使用 `PreserveNewest`) 的行為，因此您必須更新該檔案的自動填入 `<None>` 專案，如下所示。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-256">Because the Bean Trader project includes a `<None>` item that *is* copied to the output directory (using `PreserveNewest` behaviors), you need to update the automatically populated `<None>` item for that file, like this.</span></span>

  ```xml
  <None Update="BeanTrader.pfx">
    <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
  </None>
  ```

- <span data-ttu-id="ad8a8-257">Bean Trader 範例包含 XAML 檔案 (預設) 為 `Content` (而不是 `Page`) ，因為此檔案中所定義的主題和重音會在執行時間從檔案的 XAML 載入，而不是內嵌在應用程式本身中。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-257">The Bean Trader sample includes a XAML file (Default.Accent.xaml) as `Content` (rather than as a `Page`) because themes and accents defined in this file are loaded from the file's XAML at runtime, rather than being embedded in the app itself.</span></span> <span data-ttu-id="ad8a8-258">不過，新的專案系統會自動將這個檔案包含在 `<Page>` 中，因為它是 XAML 檔案。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-258">The new project system automatically includes this file as a `<Page>`, however, since it's a XAML file.</span></span> <span data-ttu-id="ad8a8-259">因此，您必須將 XAML 檔案移除為頁面 (`<Page Remove="**\Default.Accent.xaml" />`) ，並將它新增為內容。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-259">So, you need to both remove the XAML file as a page (`<Page Remove="**\Default.Accent.xaml" />`) and add it as content.</span></span>

  ```xml
  <Content Include="Resources\Themes\Default.Accent.xaml">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
  </Content>
  ```

- <span data-ttu-id="ad8a8-260">最後，藉由複製包含所有元素的來新增 NuGet 參考 `<ItemGroup>` `<PackageReference>` 。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-260">Finally, add NuGet references by copying the `<ItemGroup>` with all the `<PackageReference>` elements.</span></span> <span data-ttu-id="ad8a8-261">如果您先前未將 NuGet 套件升級為 .NET Core 相容版本，您可以完成套件參考是在 .NET Core 特定專案中。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-261">If you hadn't previously upgraded the NuGet packages to .NET Core-compatible versions, you could do that now that the package references are in a .NET Core-specific project.</span></span>

<span data-ttu-id="ad8a8-262">此時，應該可以將新的專案加入至 BeanTrader 方案，並在 Visual Studio 中開啟它。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-262">At this point, it should be possible to add the new project to the BeanTrader solution and open it in Visual Studio.</span></span> <span data-ttu-id="ad8a8-263">專案應該會在 **方案總管**中看起來正確，而且 `dotnet restore BeanTraderClient.Core.csproj` 應該會成功地將封裝還原 (有兩個預期的警告，也就是您使用目標 .NET Framework) 的 MahApps 版本。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-263">The project should look correct in **Solution Explorer**, and `dotnet restore BeanTraderClient.Core.csproj` should successfully restore packages (with two expected warnings related to the MahApps.Metro version you're using targeting .NET Framework).</span></span>

<span data-ttu-id="ad8a8-264">雖然您可以將這兩個專案檔並存 (，但如果您想要讓舊的專案完全依照) 的方式來建立舊的專案，它會使遷移程式變得更複雜 (這兩個專案會嘗試使用相同的 bin 和 obj 資料夾) ，通常並不是必要的。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-264">Although it's possible to keep both project files side-by-side (and may even be desirable if you want to keep building the old project exactly as it was), it complicates the migration process (the two projects will try to use the same bin and obj folders) and usually isn't necessary.</span></span> <span data-ttu-id="ad8a8-265">如果您想要建立 .NET Core 和 .NET Framework 目標，您可以 `<TargetFramework>netcoreapp3.0</TargetFramework>` 改為將新專案檔中的屬性取代為 `<TargetFrameworks>netcoreapp3.0;net472</TargetFrameworks>` 。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-265">If you want to build for both .NET Core and .NET Framework targets, you can replace the `<TargetFramework>netcoreapp3.0</TargetFramework>` property in the new project file with `<TargetFrameworks>netcoreapp3.0;net472</TargetFrameworks>` instead.</span></span> <span data-ttu-id="ad8a8-266">針對 Bean Trader 範例，請刪除舊的專案檔 (BeanTraderClient) ，因為不再需要它。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-266">For the Bean Trader sample, delete the old project file (BeanTraderClient.csproj) since it's no longer needed.</span></span> <span data-ttu-id="ad8a8-267">如果您想要保留這兩個專案檔，請務必將它們建立為不同的輸出和中繼輸出路徑。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-267">If you prefer to keep both project files, be sure to have them build to different output and intermediate output paths.</span></span>

## <a name="fix-build-issues"></a><span data-ttu-id="ad8a8-268">修正組建問題</span><span class="sxs-lookup"><span data-stu-id="ad8a8-268">Fix build issues</span></span>

<span data-ttu-id="ad8a8-269">移植程式的第三個步驟是取得專案的組建。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-269">The third step of the porting process is getting the project to build.</span></span> <span data-ttu-id="ad8a8-270">當專案檔轉換成 SDK 樣式專案之後，有些應用程式就已成功建立。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-270">Some apps will already build successfully once the project file is converted to an SDK-style project.</span></span> <span data-ttu-id="ad8a8-271">如果您的應用程式是這種情況，恭喜您！</span><span class="sxs-lookup"><span data-stu-id="ad8a8-271">If that's the case for your app, congratulations!</span></span> <span data-ttu-id="ad8a8-272">您可以繼續進行步驟4。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-272">You can go on to Step 4.</span></span> <span data-ttu-id="ad8a8-273">其他應用程式將需要一些更新才能讓它們建立 .NET Core。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-273">Other apps will need some updates to get them building for .NET Core.</span></span> <span data-ttu-id="ad8a8-274">比方說，如果您嘗試 `dotnet build` 在 Bean Trader 範例專案上執行，例如 (或建立在 Visual Studio) 中，將會有許多錯誤，但您將會快速地修正這些錯誤。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-274">If you try to run `dotnet build` on the Bean Trader sample project now, for example, (or build it in Visual Studio), there will be many errors, but you'll get them fixed quickly.</span></span>

### <a name="systemservicemodel-references-and-microsoftwindowscompatibility"></a><span data-ttu-id="ad8a8-275">System.servicemodel 參考和 Microsoft Windows 相容性</span><span class="sxs-lookup"><span data-stu-id="ad8a8-275">System.ServiceModel references and Microsoft.Windows.Compatibility</span></span>

<span data-ttu-id="ad8a8-276">常見的錯誤來源缺少適用于 .NET Core 的 Api 參考，但不會自動包含在 .NET Core 應用程式中繼套件中。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-276">A common source of errors is missing references for APIs that are available for .NET Core but not automatically included in the .NET Core app metapackage.</span></span> <span data-ttu-id="ad8a8-277">若要解決此情況，您應該參考該 `Microsoft.Windows.Compatibility` 套件。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-277">To address this, you should reference the `Microsoft.Windows.Compatibility` package.</span></span> <span data-ttu-id="ad8a8-278">相容性套件包含一組廣泛的 Api，在 Windows 桌面應用程式中很常見，例如 WCF 用戶端、目錄服務、登錄、設定、Acl Api 等等。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-278">The compatibility package includes a broad set of APIs that are common in Windows desktop apps, such as WCF client, directory services, registry, configuration, ACLs APIs, and more.</span></span>

<span data-ttu-id="ad8a8-279">使用 Bean Trader 範例，大部分的組建錯誤都是因為遺漏 <xref:System.ServiceModel> 類型。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-279">With the Bean Trader sample, the majority of the build errors are due to missing <xref:System.ServiceModel> types.</span></span> <span data-ttu-id="ad8a8-280">您可以參考必要的 WCF NuGet 套件來解決這些問題。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-280">These could be addressed by referencing the necessary WCF NuGet packages.</span></span> <span data-ttu-id="ad8a8-281">WCF 用戶端 Api 是套件中的應用 `Microsoft.Windows.Compatibility` 程式開發介面，因此參考相容性套件是更好的解決方案 (，因為它也可解決與 api 相關的任何問題，以及相容性套件可供) 使用的 wcf 問題解決方案。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-281">WCF client APIs are among those present in the `Microsoft.Windows.Compatibility` package, though, so referencing the compatibility package is an even better solution (since it also addresses any issues related to APIs as well as solutions to the WCF issues that the compatibility package makes available).</span></span> <span data-ttu-id="ad8a8-282">`Microsoft.Windows.Compatibility`封裝有助於大部分的 .Net Core 3.0 WPF 和 WinForms 移植案例。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-282">The `Microsoft.Windows.Compatibility` package helps in most .NET Core 3.0 WPF and WinForms porting scenarios.</span></span> <span data-ttu-id="ad8a8-283">將 NuGet 參考新增至之後 `Microsoft.Windows.Compatibility` ，只會保留一個組建錯誤！</span><span class="sxs-lookup"><span data-stu-id="ad8a8-283">After adding the NuGet reference to `Microsoft.Windows.Compatibility`, only one build error remains!</span></span>

### <a name="cleaning-up-unused-files"></a><span data-ttu-id="ad8a8-284">清除未使用的檔案</span><span class="sxs-lookup"><span data-stu-id="ad8a8-284">Cleaning up unused files</span></span>

<span data-ttu-id="ad8a8-285">通常會產生的一種遷移問題，與先前未包含在新的 SDK 樣式專案（包含 *所有* 來源）所挑選的組建中的 c # 和 XAML 檔案相關。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-285">One type of migration issue that comes up often relates to C# and XAML files that weren't previously included in the build getting picked up by the new SDK-style projects that include *all* source automatically.</span></span>

<span data-ttu-id="ad8a8-286">您在 Bean Trader 範例中看到的下一個組建錯誤，是指 *OldUnusedViewModel.cs*中有不正確的介面執行。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-286">The next build error you see in the Bean Trader sample refers to a bad interface implementation in *OldUnusedViewModel.cs*.</span></span> <span data-ttu-id="ad8a8-287">檔案名是提示，但在檢查時，您會發現此原始程式檔不正確。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-287">The file name is a hint, but on inspection, you'll find that this source file is incorrect.</span></span> <span data-ttu-id="ad8a8-288">它不會造成先前的問題，因為它未包含在原始 .NET Framework 專案中。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-288">It didn't cause issues previously because it wasn't included in the original .NET Framework project.</span></span> <span data-ttu-id="ad8a8-289">存在於磁片上但未包含在舊的 *.csproj* 中的原始程式檔，現在會自動包含在內。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-289">Source files that were present on disk but not included in the old *csproj* are included automatically now.</span></span>

<span data-ttu-id="ad8a8-290">針對這類的一次性問題，您可以輕鬆地與先前的 *.csproj* 進行比較，以確認不需要該檔案，然後再將 `<Compile Remove="" />` 它刪除，或者，如果來源檔案不再需要，請刪除它。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-290">For one-off issues like this, it's easy to compare to the previous *csproj* to confirm that the file isn't needed, and then either `<Compile Remove="" />` it or, if the source file isn't needed anywhere anymore, delete it.</span></span> <span data-ttu-id="ad8a8-291">在此情況下，只需刪除 *OldUnusedViewModel.cs*即可安全。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-291">In this case, it's safe to just delete *OldUnusedViewModel.cs*.</span></span>

<span data-ttu-id="ad8a8-292">如果您有許多需要以這種方式排除的原始程式檔，您可以 `<EnableDefaultCompileItems>` 在專案檔中將屬性設為 false，以停用自動包含 c # 檔案。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-292">If you have many source files that would need to be excluded this way, you can disable auto-inclusion of C# files by setting the `<EnableDefaultCompileItems>` property to false in the project file.</span></span> <span data-ttu-id="ad8a8-293">然後，您可以將 `<Compile Include>` 舊專案檔中的專案複製到新的專案檔，以便只建立您要包含的來源。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-293">Then, you can copy `<Compile Include>` items from the old project file to the new one in order to only build sources you intended to include.</span></span> <span data-ttu-id="ad8a8-294">同樣地， `<EnableDefaultPageItems>` 可以使用來關閉自動包含 XAML 頁面，而且 `<EnableDefaultItems>` 可以使用單一屬性來控制兩者。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-294">Similarly, `<EnableDefaultPageItems>` can be used to turn off auto-inclusion of XAML pages and `<EnableDefaultItems>` can control both with a single property.</span></span>

### <a name="a-brief-aside-on-multi-pass-compilers"></a><span data-ttu-id="ad8a8-295">多階段編譯器簡介</span><span class="sxs-lookup"><span data-stu-id="ad8a8-295">A brief aside on multi-pass compilers</span></span>

<span data-ttu-id="ad8a8-296">從 Bean Trader 範例中移除有問題的檔案之後，您可以重新建立，並會收到四個錯誤。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-296">After removing the offending file from the Bean Trader sample, you can re-build and will get four errors.</span></span> <span data-ttu-id="ad8a8-297">您之前沒有一個嗎？</span><span class="sxs-lookup"><span data-stu-id="ad8a8-297">Didn't you have one before?</span></span> <span data-ttu-id="ad8a8-298">為什麼會出現錯誤數目？</span><span class="sxs-lookup"><span data-stu-id="ad8a8-298">Why did the number of errors go up?</span></span> <span data-ttu-id="ad8a8-299">C # 編譯器是 [多重傳遞編譯器](/archive/blogs/ericlippert/how-many-passes)。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-299">The C# compiler is a [multi-pass compiler](/archive/blogs/ericlippert/how-many-passes).</span></span> <span data-ttu-id="ad8a8-300">這表示每個原始程式檔會執行兩次。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-300">This means that it goes through each source file twice.</span></span> <span data-ttu-id="ad8a8-301">首先，編譯器只會查看每個原始檔中的中繼資料和宣告，並識別任何宣告層級的問題。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-301">First, the compiler just looks at metadata and declarations in each source file and identifies any declaration-level problems.</span></span> <span data-ttu-id="ad8a8-302">這些是您已修正的錯誤。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-302">Those are the errors you've fixed.</span></span> <span data-ttu-id="ad8a8-303">然後，它會再次執行程式碼，以將 c # 原始檔建立成 IL。這些是您現在看到的第二組錯誤。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-303">Then it goes through the code again to build the C# source into IL; those are the second set of errors that you're seeing now.</span></span>

> [!NOTE]
> <span data-ttu-id="ad8a8-304">C # 編譯器只會執行 [兩次以上](/archive/blogs/ericlippert/how-many-passes)的結果，但最終結果是大型程式碼變更的編譯器錯誤通常會以兩種方式進行。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-304">The C# compiler does [more than just two passes](/archive/blogs/ericlippert/how-many-passes), but the end result is that compiler errors for large code changes like this tend to come in two waves.</span></span>

### <a name="third-party-dependency-fixes-castlewindsor"></a><span data-ttu-id="ad8a8-305">協力廠商相依性修正 (Castle Windsor) </span><span class="sxs-lookup"><span data-stu-id="ad8a8-305">Third-party dependency fixes (Castle.Windsor)</span></span>

<span data-ttu-id="ad8a8-306">在某些遷移案例中引發的另一個問題類別，是 .NET Framework 和 .NET Core 版本的相依性之間的 API 差異。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-306">Another class of issue that comes up in some migration scenarios is API differences between .NET Framework and .NET Core versions of dependencies.</span></span> <span data-ttu-id="ad8a8-307">即使 NuGet 套件同時以 .NET Framework 和 .NET Standard 或 .NET Core 為目標，也可能會有不同的程式庫可搭配不同的 .NET 目標使用。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-307">Even if a NuGet package targets both .NET Framework and .NET Standard or .NET Core, there may be different libraries for use with different .NET targets.</span></span> <span data-ttu-id="ad8a8-308">這可讓套件支援許多不同的 .NET 平臺，而這些平臺可能需要不同的執行方式。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-308">This allows the packages to support many different .NET platforms, which may require different implementations.</span></span> <span data-ttu-id="ad8a8-309">這也表示以不同的 .NET 平臺為目標時，程式庫中可能會有小型的 API 差異。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-309">It also means that there may be small API differences in the libraries when targeting different .NET platforms.</span></span>

<span data-ttu-id="ad8a8-310">您將在 Bean Trader 範例中看到的下一組錯誤與 api 相關 `Castle.Windsor` 。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-310">The next set of errors you'll see in the Bean Trader sample are related to `Castle.Windsor` APIs.</span></span> <span data-ttu-id="ad8a8-311">.NET Core Bean Trader 專案所使用的版本， `Castle.Windsor` 與 .NET Framework 目標專案 (4.1.1) 相同，但這兩個平臺的執行方式稍有不同。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-311">The .NET Core Bean Trader project uses the same version of `Castle.Windsor` as the .NET Framework-targeted project (4.1.1), but the implementations for those two platforms are slightly different.</span></span>

<span data-ttu-id="ad8a8-312">在此情況下，您會看到下列需要修正的問題：</span><span class="sxs-lookup"><span data-stu-id="ad8a8-312">In this case, you see the following issues that need to be fixed:</span></span>

1. <span data-ttu-id="ad8a8-313">`Castle.MicroKernel.Registration.Classes.FromThisAssembly` 無法在 .NET Core 上使用。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-313">`Castle.MicroKernel.Registration.Classes.FromThisAssembly` isn't available on .NET Core.</span></span> <span data-ttu-id="ad8a8-314">不過，您可以使用類似的 API `Classes.FromAssemblyContaining` ，因此我們可以將的這兩個用途取代 `Classes.FromThisAssembly()` 為的 `Classes.FromAssemblyContaining(t)` ，其中 `t` 是進行呼叫的型別。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-314">There is, however, the similar API `Classes.FromAssemblyContaining` available, so we can replace both uses of `Classes.FromThisAssembly()` with calls to `Classes.FromAssemblyContaining(t)`, where `t` is the type making the call.</span></span>
1. <span data-ttu-id="ad8a8-315">同樣地，在 *Bootstrapper.cs*中 `Castle.Windsor.Installer.FromAssembly` 。這無法在 .NET Core 上使用。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-315">Similarly, in *Bootstrapper.cs*, `Castle.Windsor.Installer.FromAssembly`.This is unavailable on .NET Core.</span></span> <span data-ttu-id="ad8a8-316">相反地，該呼叫可以取代為 `FromAssembly.Containing(typeof(Bootstrapper))` 。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-316">Instead, that call can be replaced with `FromAssembly.Containing(typeof(Bootstrapper))`.</span></span>

### <a name="updating-wcf-client-usage"></a><span data-ttu-id="ad8a8-317">更新 WCF 用戶端使用方式</span><span class="sxs-lookup"><span data-stu-id="ad8a8-317">Updating WCF client usage</span></span>

<span data-ttu-id="ad8a8-318">修正 `Castle.Windsor` 差異之後，.Net Core Bean Trader 專案中最後剩下的組建錯誤就是 `BeanTraderServiceClient` 衍生自) 的 (`DuplexClientBase` 沒有 `Open` 方法。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-318">Having fixed the `Castle.Windsor` differences, the last remaining build error in the .NET Core Bean Trader project is that `BeanTraderServiceClient` (which derives from `DuplexClientBase`) doesn't have an `Open` method.</span></span> <span data-ttu-id="ad8a8-319">這並不令人驚訝，因為這是在這個遷移程式開始時，由 .NET 可攜性分析器所強調的 API。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-319">This isn't surprising since this is an API that was highlighted by the .NET Portability Analyzer at the beginning of this migration process.</span></span> <span data-ttu-id="ad8a8-320">`BeanTraderServiceClient`不過，查看會將重點放在更大的問題。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-320">Looking at `BeanTraderServiceClient` draws our attention to a larger issue, though.</span></span> <span data-ttu-id="ad8a8-321">此 WCF 用戶端是由 [Svcutil.exe](../../framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md) 工具自動產生。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-321">This WCF client was autogenerated by the [Svcutil.exe](../../framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md) tool.</span></span>

<span data-ttu-id="ad8a8-322">**Svcutil 所產生的 WCF 用戶端旨在用於 .NET Framework。**</span><span class="sxs-lookup"><span data-stu-id="ad8a8-322">**WCF clients generated by Svcutil are meant for use on .NET Framework.**</span></span>

<span data-ttu-id="ad8a8-323">使用 svcutil 產生之 WCF 用戶端的解決方案，將需要重新產生與 .NET Core 搭配使用 .NET Standard 相容的用戶端。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-323">Solutions that use svcutil-generated WCF clients will need to regenerate .NET Standard-compatible clients for use with .NET Core.</span></span> <span data-ttu-id="ad8a8-324">舊用戶端無法運作的主要原因之一，是它們依存于定義 WCF 系結和端點的應用程式設定。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-324">One of the main reasons the old clients won't work is that they depend on app configuration for defining WCF bindings and endpoints.</span></span> <span data-ttu-id="ad8a8-325">因為 .NET Standard WCF Api 可跨平臺運作 (System.Configuration Api 無法) ，所以 .NET Core 和 .NET Standard 案例的 WCF 用戶端必須以程式設計的方式定義系結和端點，而不是在設定中。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-325">Because .NET Standard WCF APIs can work cross-platform (where System.Configuration APIs aren't available), WCF clients for .NET Core and .NET Standard scenarios must define bindings and endpoints programmatically instead of in configuration.</span></span>

<span data-ttu-id="ad8a8-326">事實上，相依于 app.config 區段)  (的任何 WCF 用戶端使用， `<system.serviceModel>` 都必須變更為在 .Net Core 上運作。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-326">In fact, any WCF client usage that depends on the `<system.serviceModel>` app.config section (whether created with Svcutil or manually) will need to be changed to work on .NET Core.</span></span>

<span data-ttu-id="ad8a8-327">有兩種方式可以自動產生 .NET Standard 相容的 WCF 用戶端：</span><span class="sxs-lookup"><span data-stu-id="ad8a8-327">There are two ways to automatically generate .NET Standard-compatible WCF clients:</span></span>

- <span data-ttu-id="ad8a8-328">此 `dotnet-svcutil` 工具是一種 .net 工具，其產生 WCF 用戶端的方式類似于 Svcutil 之前的運作方式。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-328">The `dotnet-svcutil` tool is a .NET tool that generates WCF clients in a way that is similar to how Svcutil worked previously.</span></span>
- <span data-ttu-id="ad8a8-329">Visual Studio 可以使用其已連線的服務功能的 [WCF Web Service Reference](../../core/additional-tools/wcf-web-service-reference-guide.md) 選項來產生 WCF 用戶端。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-329">Visual Studio can generate WCF clients using the [WCF Web Service Reference](../../core/additional-tools/wcf-web-service-reference-guide.md) option of its Connected Services feature.</span></span>

<span data-ttu-id="ad8a8-330">這兩種方法都能順利運作。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-330">Either approach works well.</span></span> <span data-ttu-id="ad8a8-331">當然，您也可以自行撰寫 WCF 用戶端程式代碼。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-331">Alternatively, of course, you could write the WCF client code yourself.</span></span> <span data-ttu-id="ad8a8-332">在此範例中，我選擇使用 Visual Studio Connected Service 功能。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-332">For this sample, I chose to use the Visual Studio Connected Service feature.</span></span> <span data-ttu-id="ad8a8-333">若要這樣做，請以滑鼠右鍵按一下 Visual Studio 的 [solution explorer] 中的 [ *BeanTraderClient* ] 專案，然後選取 [**加入**  >  **已連接服務**]。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-333">To do that, right-click on the *BeanTraderClient.Core* project in Visual Studio's solution explorer and select **Add** > **Connected Service**.</span></span> <span data-ttu-id="ad8a8-334">接下來，選擇 WCF Web Service Reference 提供者。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-334">Next, choose the WCF Web Service Reference Provider.</span></span> <span data-ttu-id="ad8a8-335">這會顯示一個對話方塊，您可以在其中指定後端 Bean Trader web 服務的位址 (`localhost:8080` 如果您是在本機執行伺服器) ，而且產生的型別應該使用 (**BeanTrader**的命名空間，例如) 。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-335">This will bring up a dialog where you can specify the address of the backend Bean Trader web service (`localhost:8080` if you are running the server locally) and the namespace that generated types should use (**BeanTrader.Service**, for example).</span></span>

![WCF Web Service Reference 已連接服務] 對話方塊](./media/convert-project-from-net-framework/connected-service-dialog.png)

<span data-ttu-id="ad8a8-337">當您選取 [ **完成]** 按鈕之後，就會將新的已連線的服務節點新增至專案，並在該節點下加入 Reference.cs 檔案，其中包含用來存取 Bean Trader 服務的新 .NET Standard WCF 用戶端。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-337">After you select the **Finish** button, a new Connected Services node is added to the project and a Reference.cs file is added under that node containing the new .NET Standard WCF client for accessing the Bean Trader service.</span></span> <span data-ttu-id="ad8a8-338">如果您查看該檔案 `GetEndpointAddress` 中的或 `GetBindingForEndpoint` 方法，您會看到現在以程式設計的方式產生系結和端點 (而不是透過應用程式設定) 。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-338">If you look at the `GetEndpointAddress` or `GetBindingForEndpoint` methods in that file, you'll see that bindings and endpoints are now generated programmatically (instead of via app config).</span></span> <span data-ttu-id="ad8a8-339">「新增已連線的服務」功能也可能會在專案檔中加入某些 System.servicemodel 封裝的參考，因為所有必要的 WCF 封裝都包含在 Windows 的相容性中，所以不需要這些專案。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-339">The 'Add Connected Services' feature may also add references to some System.ServiceModel packages in the project file, which aren't needed since all necessary WCF packages are included via Microsoft.Windows.Compatibility.</span></span> <span data-ttu-id="ad8a8-340">檢查 .csproj 以查看是否已新增任何額外的 System.servicemodel `<PackageReference>` 專案，如果有的話，請將它們移除。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-340">Check the csproj to see if any extra System.ServiceModel `<PackageReference>` items have been added, and if so, remove them.</span></span>

<span data-ttu-id="ad8a8-341">我們的專案現在有新的 WCF 用戶端類別 (在 *Reference.cs*) 中，但在 BeanTrader.cs) 中仍有舊的 (。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-341">Our project has new WCF client classes now (in *Reference.cs*), but it also still has the old ones (in BeanTrader.cs).</span></span> <span data-ttu-id="ad8a8-342">此時有兩個選項：</span><span class="sxs-lookup"><span data-stu-id="ad8a8-342">There are two options at this point:</span></span>

- <span data-ttu-id="ad8a8-343">如果您想要能夠建立原始的 .NET Framework 專案 (與新的 .NET Core （以一個) 為目標），您可以使用 `<Compile Remove="BeanTrader.cs" />` .Net core 專案 .csproj 檔案中的專案，讓應用程式的 .NET Framework 和 .Net Core 版本使用不同的 WCF 用戶端。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-343">If you want to be able to build the original .NET Framework project (alongside the new .NET Core-targeted one), you can use a `<Compile Remove="BeanTrader.cs" />` item in the .NET Core project's csproj file so that the .NET Framework and .NET Core versions of the app use different WCF clients.</span></span> <span data-ttu-id="ad8a8-344">這樣做的優點是讓現有的 .NET Framework 專案保持不變，但缺點是，使用所產生 WCF 用戶端的程式碼在 .NET Core 案例中可能需要與在 .NET Framework 專案中稍有不同，因此您可能需要使用指示詞，有 `#if` 條件地編譯一些 WCF 用戶端使用方式， (建立用戶端，例如，) 在針對 .Net Core 建立時使用一種方式，並在建立 .NET Framework 時使用另一種方式。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-344">This has the advantage of leaving the existing .NET Framework project unchanged, but has the disadvantage that code using the generated WCF clients may need to be slightly different in the .NET Core case than it was in the .NET Framework project, so you'll likely need to use `#if` directives to conditionally compile some WCF client usage (creating clients, for example) to work one way when built for .NET Core and another way when built for .NET Framework.</span></span>

- <span data-ttu-id="ad8a8-345">另一方面，在現有的 .NET Framework 專案中，某些程式碼變換是可接受的，您可以同時移除 *BeanTrader.cs* 。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-345">If, on the other hand, some code churn in the existing .NET Framework project is acceptable, you can remove *BeanTrader.cs* all together.</span></span> <span data-ttu-id="ad8a8-346">由於新的 WCF 用戶端是針對 .NET Standard 所建立，因此可在 .NET Core 和 .NET Framework 案例中運作。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-346">Because the new WCF client is built for .NET Standard, it will work in both .NET Core and .NET Framework scenarios.</span></span> <span data-ttu-id="ad8a8-347">如果您要建立的 .NET Framework 除了 .NET (Core 之外，您還可以透過多重目標或在) 中使用兩個 .csproj 檔案，將這個新的 *Reference.cs* 檔用於這兩個目標。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-347">If you are building for .NET Framework in addition to .NET Core (either by multi-targeting or by having two csproj files), you can use this new *Reference.cs* file for both targets.</span></span> <span data-ttu-id="ad8a8-348">這種方法的優點是，程式碼不需要 bifurcate 以支援兩個不同的 WCF 用戶端;相同的程式碼將會在所有位置使用。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-348">This approach has the advantage that the code won't need to bifurcate to support two different WCF clients; the same code will be used everywhere.</span></span> <span data-ttu-id="ad8a8-349">缺點是，它牽涉到變更 (可能穩定的) .NET Framework 專案。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-349">The drawback is that it involves changing the (presumably stable) .NET Framework project.</span></span>

<span data-ttu-id="ad8a8-350">在 Bean Trader 範例的案例中，您可以對原始專案進行較小的變更，如果它讓遷移更容易，請遵循下列步驟來協調 WCF 用戶端使用：</span><span class="sxs-lookup"><span data-stu-id="ad8a8-350">In the case of the Bean Trader sample, you can make small changes to the original project if it makes migration easier, so follow these steps to reconcile WCF client usage:</span></span>

01. <span data-ttu-id="ad8a8-351">使用 [方案 Reference.cs] 中的 [加入現有專案] 內容功能表，將新的檔案加入至 .NET Framework *BeanTraderClient .csproj* 專案。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-351">Add the new Reference.cs file to the .NET Framework *BeanTraderClient.csproj* project using the 'Add existing item' context menu from the solution explorer.</span></span> <span data-ttu-id="ad8a8-352">請務必新增 ' as link '，使兩個專案都使用相同的檔案 (而不是複製 c # 檔案) 。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-352">Be sure to add 'as link' so that the same file is used by both projects (as opposed to copying the C# file).</span></span> <span data-ttu-id="ad8a8-353">如果您同時使用多目標) 來建立 .NET Core 和 .NET Framework 與單一 .csproj (，則不需要此步驟。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-353">If you are building for both .NET Core and .NET Framework with a single csproj (using multi-targeting) then this step isn't necessary.</span></span>

01. <span data-ttu-id="ad8a8-354">刪除 *BeanTrader.cs*。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-354">Delete *BeanTrader.cs*.</span></span>

01. <span data-ttu-id="ad8a8-355">新的 WCF 用戶端類似舊的 WCF 用戶端，但產生的程式碼中有許多命名空間不同。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-355">The new WCF client is similar to the old one, but a number of namespaces in the generated code are different.</span></span> <span data-ttu-id="ad8a8-356">基於這個原因，您必須更新專案，才能使用 BeanTrader 中的 WCF 用戶端類型 (或您選擇的任何命名空間名稱) 而不是 BeanTrader，而不是命名空間。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-356">Because of this, it is necessary to update the project so that WCF client types are used from BeanTrader.Service (or whatever namespace name you chose) instead of BeanTrader.Model or without a namespace.</span></span> <span data-ttu-id="ad8a8-357">建立 *BeanTraderClient* 可協助您找出需要進行這些變更的位置。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-357">Building *BeanTraderClient.Core.csproj* will help to identify where these changes need to be made.</span></span> <span data-ttu-id="ad8a8-358">C # 和 XAML 原始程式檔中都需要修正。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-358">Fixes will be needed both in C# and in XAML source files.</span></span>

01. <span data-ttu-id="ad8a8-359">最後，您會發現 *BeanTraderServiceClientFactory.cs* 中有錯誤，因為類型的可用函式 `BeanTraderServiceClient` 已變更。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-359">Finally, you'll discover that there is an error in *BeanTraderServiceClientFactory.cs* because the available constructors for the `BeanTraderServiceClient` type have changed.</span></span> <span data-ttu-id="ad8a8-360">它可用來提供自 `InstanceContext` 變數， (使用 `CallbackHandler` 從 `Castle.Windsor` IoC 容器) 所建立的引數。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-360">It used to be possible to supply an `InstanceContext` argument (which was created using a `CallbackHandler` from the `Castle.Windsor` IoC container).</span></span> <span data-ttu-id="ad8a8-361">新的函式會建立新的 `CallbackHandler` 。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-361">The new constructors create new `CallbackHandler`s.</span></span> <span data-ttu-id="ad8a8-362">不過，基底類型中的函式 `BeanTraderServiceClient` 符合您的需要。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-362">There are, however, constructors in `BeanTraderServiceClient`'s base type that match what you want.</span></span> <span data-ttu-id="ad8a8-363">由於自動產生的 WCF 用戶端程式代碼都存在於部分類別中，因此您可以輕鬆地加以擴充。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-363">Since the autogenerated WCF client code all exists in partial classes, you can easily extend it.</span></span> <span data-ttu-id="ad8a8-364">若要這樣做，請建立名為 *BeanTraderServiceClient.cs* 的新檔案，然後使用 BeanTrader 命名空間) 來建立具有相同名稱 (部分類別。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-364">To do this, create a new file called *BeanTraderServiceClient.cs* and then create a partial class with that same name (using the BeanTrader.Service namespace).</span></span> <span data-ttu-id="ad8a8-365">然後，將一個函式加入至部分類型，如下所示。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-365">Then, add one constructor to the partial type as shown here.</span></span>

    ```csharp
    public BeanTraderServiceClient(System.ServiceModel.InstanceContext callbackInstance) :
        base(callbackInstance, EndpointConfiguration.NetTcpBinding_BeanTraderService)
            { }
    ```

<span data-ttu-id="ad8a8-366">完成這些變更後，Bean Trader 範例現在會使用新的 .NET Standard 相容 WCF 用戶端，而您可以進行最後的修正，將 `Open` *TradingService.cs* 中的呼叫改為改用 `await OpenAsync` 。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-366">With those changes made, the Bean Trader sample will now be using a new .NET Standard-compatible WCF client and you can make the final fix of changing the `Open` call in *TradingService.cs* to use `await OpenAsync` instead.</span></span>

<span data-ttu-id="ad8a8-367">解決 WCF 問題之後，.NET Core 版本的 Bean Trader 範例現在已完全建立！</span><span class="sxs-lookup"><span data-stu-id="ad8a8-367">With the WCF issues addressed, the .NET Core version of the Bean Trader sample now builds cleanly!</span></span>

## <a name="runtime-testing"></a><span data-ttu-id="ad8a8-368">執行時間測試</span><span class="sxs-lookup"><span data-stu-id="ad8a8-368">Runtime testing</span></span>

<span data-ttu-id="ad8a8-369">您可以很容易忘記，當專案完全以 .NET Core 為基礎建立時，就不會完成遷移工作。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-369">It's easy to forget that migration work isn't done as soon as the project builds cleanly against .NET Core.</span></span> <span data-ttu-id="ad8a8-370">也請務必保留測試移植應用程式的時間。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-370">It's important to leave time for testing the ported app, too.</span></span> <span data-ttu-id="ad8a8-371">一旦成功建立專案之後，請確定應用程式會如預期般執行並正常運作，尤其是當您使用以 .NET Framework 為目標的任何封裝時。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-371">Once things build successfully, make sure the app runs and works as expected, especially if you are using any packages targeting .NET Framework.</span></span>

<span data-ttu-id="ad8a8-372">讓我們試著啟動移植的 Bean Trader 應用程式，看看會發生什麼事。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-372">Let's try launching the ported Bean Trader app and see what happens.</span></span> <span data-ttu-id="ad8a8-373">在發生下列例外狀況之前，應用程式不會有太多的處理失敗。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-373">The app doesn't get far before failing with the following exception.</span></span>

```output
System.Configuration.ConfigurationErrorsException: 'Configuration system failed to initialize'

Inner Exception
ConfigurationErrorsException: Unrecognized configuration section system.serviceModel.
```

<span data-ttu-id="ad8a8-374">當然，這也是合理的。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-374">This makes sense, of course.</span></span> <span data-ttu-id="ad8a8-375">請記住，WCF 不再使用應用程式設定，因此必須移除 app.config 檔案的舊 System.servicemodel 區段。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-375">Remember that WCF no longer uses app configuration, so the old system.serviceModel section of the app.config file needs to be removed.</span></span> <span data-ttu-id="ad8a8-376">更新的 WCF 用戶端會在其程式碼中包含所有相同的資訊，因此不再需要 config 區段。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-376">The updated WCF client includes all of the same information in its code, so the config section isn't needed anymore.</span></span> <span data-ttu-id="ad8a8-377">如果您想要在 app.config 中設定 WCF 端點，可以將它新增為應用程式設定，並更新 WCF 用戶端程式代碼，以從設定中取出 WCF 服務端點。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-377">If you wanted the WCF endpoint to be configurable in app.config, you could add it as an app setting and update the WCF client code to retrieve the WCF service endpoint from configuration.</span></span>

<span data-ttu-id="ad8a8-378">移除 *app.config*的 system.servicemodel 區段之後，應用程式會啟動，但會在使用者登入時發生另一個例外狀況而失敗。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-378">After removing the system.serviceModel section of *app.config*, the app launches but fails with another exception when a user signs in.</span></span>

```output
System.PlatformNotSupportedException: 'Operation is not supported on this platform.'
```

<span data-ttu-id="ad8a8-379">不支援的 API 為 `Func<T>.BeginInvoke` 。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-379">The unsupported API is `Func<T>.BeginInvoke`.</span></span> <span data-ttu-id="ad8a8-380">如 [dotnet/corefx # 5940](https://github.com/dotnet/corefx/issues/5940)中所述，.net Core 不支援 `BeginInvoke` `EndInvoke` 委派類型上的和方法，因為基礎遠端相依性。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-380">As explained in [dotnet/corefx#5940](https://github.com/dotnet/corefx/issues/5940), .NET Core doesn't support the `BeginInvoke` and `EndInvoke` methods on delegate types due to underlying remoting dependencies.</span></span> <span data-ttu-id="ad8a8-381">此問題及其修正會在遷移委派中更詳細地說明 [。 BeginInvoke 呼叫 .Net Core 的](https://devblogs.microsoft.com/dotnet/migrating-delegate-begininvoke-calls-for-net-core/) blog 文章，但 gist 是， `BeginInvoke` `EndInvoke` `Task.Run` 如果可能) 的話，應該將呼叫取代為 (或非同步替代專案。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-381">This issue and its fix are explained in more detail in the [Migrating Delegate.BeginInvoke Calls for .NET Core](https://devblogs.microsoft.com/dotnet/migrating-delegate-begininvoke-calls-for-net-core/) blog post, but the gist is that `BeginInvoke` and `EndInvoke` calls should be replaced with `Task.Run` (or async alternatives, if possible).</span></span> <span data-ttu-id="ad8a8-382">在這裡套用一般方案， `BeginInvoke` 呼叫可以用啟動的呼叫取代 `Invoke` `Task.Run` 。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-382">Applying the general solution here, the `BeginInvoke` call can be replaced with an `Invoke` call launched by `Task.Run`.</span></span>

```csharp
Task.Run(() =>
{
    return userInfoRetriever.Invoke();
}).ContinueWith(result =>
{
    // BeginInvoke's callback is replaced with ContinueWith
    var task = result.ConfigureAwait(false);
    CurrentTrader = task.GetAwaiter().GetResult();
}, TaskScheduler.Default);
```

<span data-ttu-id="ad8a8-383">移除使用方式之後 `BeginInvoke` ，Bean Trader 應用程式就會在 .Net Core 上成功執行！</span><span class="sxs-lookup"><span data-stu-id="ad8a8-383">After removing the `BeginInvoke` usage, the Bean Trader app runs successfully on .NET Core!</span></span>

![在 .NET Core 上執行的 Bean Trader](./media/convert-project-from-net-framework/running-on-core.png)

<span data-ttu-id="ad8a8-385">所有應用程式不同，因此將您自己的應用程式遷移至 .NET Core 所需的特定步驟會有所不同。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-385">All apps are different, so the specific steps needed to migrate your own apps to .NET Core will vary.</span></span> <span data-ttu-id="ad8a8-386">但希望 Bean Trader 範例會示範一般工作流程，以及可能預期的問題類型。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-386">But hopefully the Bean Trader sample demonstrates the general workflow and the types of issues that can be expected.</span></span> <span data-ttu-id="ad8a8-387">而且，儘管本文的長度的限制，Bean Trader 範例中所需的實際變更，使其在 .NET Core 上運作相當有限。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-387">And, despite this article's length, the actual changes needed in the Bean Trader sample to make it work on .NET Core were fairly limited.</span></span> <span data-ttu-id="ad8a8-388">許多應用程式都會以同樣的方式遷移至 .NET Core;但不需要變更任何程式碼。</span><span class="sxs-lookup"><span data-stu-id="ad8a8-388">Many apps migrate to .NET Core in this same way; with limited or even no code changes needed.</span></span>
