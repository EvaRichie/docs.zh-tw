---
title: 將 WPF 應用程式遷移至 .NET Core 3。0
description: 瞭解如何將 Windows Presentation Foundation （WPF）應用程式遷移至 .NET Core 3.0。
author: mjrousos
ms.date: 09/12/2019
ms.author: mikerou
ms.openlocfilehash: fda4f618ddb4a3edbe6f2dd9fba0b10bc618e88d
ms.sourcegitcommit: 71b8f5a2108a0f1a4ef1d8d75c5b3e129ec5ca1e
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 05/29/2020
ms.locfileid: "84201564"
---
# <a name="migrating-wpf-apps-to-net-core"></a><span data-ttu-id="2b249-103">將 WPF 應用程式遷移至 .NET Core</span><span class="sxs-lookup"><span data-stu-id="2b249-103">Migrating WPF apps to .NET Core</span></span>

<span data-ttu-id="2b249-104">本文涵蓋將 Windows Presentation Foundation （WPF）應用程式從 .NET Framework 遷移至 .NET Core 3.0 所需的步驟。</span><span class="sxs-lookup"><span data-stu-id="2b249-104">This article covers the steps necessary to migrate a Windows Presentation Foundation (WPF) app from .NET Framework to .NET Core 3.0.</span></span> <span data-ttu-id="2b249-105">如果您沒有任何適用于埠的 WPF 應用程式，但想要嘗試執行程式，您可以使用[GitHub](https://github.com/dotnet/windows-desktop/tree/master/Samples/BeanTrader)上提供的**Bean Trader**範例應用程式。</span><span class="sxs-lookup"><span data-stu-id="2b249-105">If you don't have a WPF app on hand to port, but would like to try out the process, you can use the **Bean Trader** sample app available on [GitHub](https://github.com/dotnet/windows-desktop/tree/master/Samples/BeanTrader).</span></span> <span data-ttu-id="2b249-106">原始應用程式（目標為 .NET Framework 4.7.2）可在 NetFx\BeanTraderClient 資料夾中取得。</span><span class="sxs-lookup"><span data-stu-id="2b249-106">The original app (targeting .NET Framework 4.7.2) is available in the NetFx\BeanTraderClient folder.</span></span> <span data-ttu-id="2b249-107">首先，我們將說明一般移植應用程式所需的步驟，然後我們會逐步解說適用于**Bean Trader**範例的特定變更。</span><span class="sxs-lookup"><span data-stu-id="2b249-107">First we'll explain the steps necessary to port apps in general, and then we'll walk through the specific changes that apply to the **Bean Trader** sample.</span></span>

[!INCLUDE [desktop guide under construction](../../../includes/desktop-guide-preview-note.md)]

<span data-ttu-id="2b249-108">若要遷移至 .NET Core，您必須先：</span><span class="sxs-lookup"><span data-stu-id="2b249-108">To migrate to .NET Core, you must first:</span></span>

01. <span data-ttu-id="2b249-109">瞭解和更新 NuGet 相依性：</span><span class="sxs-lookup"><span data-stu-id="2b249-109">Understand and update NuGet dependencies:</span></span>

    01. <span data-ttu-id="2b249-110">將 NuGet 相依性升級為使用 `<PackageReference>` 格式。</span><span class="sxs-lookup"><span data-stu-id="2b249-110">Upgrade NuGet dependencies to use the `<PackageReference>` format.</span></span>
    01. <span data-ttu-id="2b249-111">查看 .NET Core 或 .NET Standard 相容性的最上層 NuGet 相依性。</span><span class="sxs-lookup"><span data-stu-id="2b249-111">Review top-level NuGet dependencies for .NET Core or .NET Standard compatibility.</span></span>
    01. <span data-ttu-id="2b249-112">將 NuGet 套件升級至較新的版本。</span><span class="sxs-lookup"><span data-stu-id="2b249-112">Upgrade NuGet packages to newer versions.</span></span>
    01. <span data-ttu-id="2b249-113">使用[.net 可攜性分析器](../../standard/analyzers/portability-analyzer.md)來瞭解 .Net 相依性。</span><span class="sxs-lookup"><span data-stu-id="2b249-113">Use the [.NET Portability Analyzer](../../standard/analyzers/portability-analyzer.md) to understand .NET dependencies.</span></span>

01. <span data-ttu-id="2b249-114">將專案檔案遷移至新的 SDK 樣式格式：</span><span class="sxs-lookup"><span data-stu-id="2b249-114">Migrate the project file to the new SDK-style format:</span></span>

    01. <span data-ttu-id="2b249-115">選擇要以 .NET Core 和 .NET Framework，還是僅以 .NET Core 為目標。</span><span class="sxs-lookup"><span data-stu-id="2b249-115">Choose whether to target both .NET Core and .NET Framework, or only .NET Core.</span></span>
    01. <span data-ttu-id="2b249-116">將相關的專案檔案屬性和專案複製到新的專案檔。</span><span class="sxs-lookup"><span data-stu-id="2b249-116">Copy relevant project file properties and items to the new project file.</span></span>

01. <span data-ttu-id="2b249-117">修正組建問題：</span><span class="sxs-lookup"><span data-stu-id="2b249-117">Fix build issues:</span></span>

    01. <span data-ttu-id="2b249-118">新增對[Microsoft. Windows 相容性](https://www.nuget.org/packages/Microsoft.Windows.Compatibility/)套件的參考。</span><span class="sxs-lookup"><span data-stu-id="2b249-118">Add a reference to the [Microsoft.Windows.Compatibility](https://www.nuget.org/packages/Microsoft.Windows.Compatibility/) package.</span></span>
    01. <span data-ttu-id="2b249-119">尋找並修正 API 層級的差異。</span><span class="sxs-lookup"><span data-stu-id="2b249-119">Find and fix API-level differences.</span></span>
    01. <span data-ttu-id="2b249-120">移除*app.config* `appSettings` 或以外的 app.config 區段。 `connectionStrings`</span><span class="sxs-lookup"><span data-stu-id="2b249-120">Remove *app.config* sections other than `appSettings` or `connectionStrings`.</span></span>
    01. <span data-ttu-id="2b249-121">視需要重新產生所產生的程式碼。</span><span class="sxs-lookup"><span data-stu-id="2b249-121">Regenerate generated code, if necessary.</span></span>

01. <span data-ttu-id="2b249-122">執行時間測試：</span><span class="sxs-lookup"><span data-stu-id="2b249-122">Runtime testing:</span></span>

    01. <span data-ttu-id="2b249-123">確認已移植的應用程式如預期般運作。</span><span class="sxs-lookup"><span data-stu-id="2b249-123">Confirm the ported app works as expected.</span></span>
    01. <span data-ttu-id="2b249-124">注意 <xref:System.NotSupportedException> 例外狀況。</span><span class="sxs-lookup"><span data-stu-id="2b249-124">Beware of <xref:System.NotSupportedException> exceptions.</span></span>

## <a name="about-the-sample"></a><span data-ttu-id="2b249-125">關於範例</span><span class="sxs-lookup"><span data-stu-id="2b249-125">About the sample</span></span>

<span data-ttu-id="2b249-126">本文參考[Bean Trader 範例應用程式](https://github.com/dotnet/windows-desktop/tree/master/Samples/BeanTrader)，因為它使用的相依性與實際的 WPF 應用程式可能會有的相依性相似。</span><span class="sxs-lookup"><span data-stu-id="2b249-126">This article references the [Bean Trader sample app](https://github.com/dotnet/windows-desktop/tree/master/Samples/BeanTrader) because it uses a variety of dependencies similar to those that real-world WPF apps might have.</span></span> <span data-ttu-id="2b249-127">應用程式並不大，而是從「Hello World」到複雜度的一個步驟。</span><span class="sxs-lookup"><span data-stu-id="2b249-127">The app isn't large, but is meant to be a step up from 'Hello World' in terms of complexity.</span></span> <span data-ttu-id="2b249-128">應用程式會示範使用者在移植實際應用程式時可能會遇到的一些問題。</span><span class="sxs-lookup"><span data-stu-id="2b249-128">The app demonstrates some issues users may encounter while porting real apps.</span></span> <span data-ttu-id="2b249-129">應用程式會與 WCF 服務通訊，因此若要讓它正常執行，您也必須執行 BeanTraderServer 專案（可在相同的 GitHub 存放庫中取得），並確定 BeanTraderClient 設定指向正確的端點。</span><span class="sxs-lookup"><span data-stu-id="2b249-129">The app communicates with a WCF service, so for it to run properly, you'll also need to run the BeanTraderServer project (available in the same GitHub repository) and make sure the BeanTraderClient configuration points to the correct endpoint.</span></span> <span data-ttu-id="2b249-130">（根據預設，此範例假設伺服器是在同一部電腦上執行 `http://localhost:8090` ，如果您在本機啟動 BeanTraderServer，這會是 true）。</span><span class="sxs-lookup"><span data-stu-id="2b249-130">(By default, the sample assumes the server is running on the same machine at `http://localhost:8090`, which will be true if you launch BeanTraderServer locally.)</span></span>

<span data-ttu-id="2b249-131">請記住，此範例應用程式的目的是要示範 .NET Core 移植的挑戰和解決方案。</span><span class="sxs-lookup"><span data-stu-id="2b249-131">Keep in mind that this sample app is meant to demonstrate .NET Core porting challenges and solutions.</span></span> <span data-ttu-id="2b249-132">它不是用來示範 WPF 的最佳做法。</span><span class="sxs-lookup"><span data-stu-id="2b249-132">It's not meant to demonstrate WPF best practices.</span></span> <span data-ttu-id="2b249-133">事實上，它刻意包含一些反模式，確保您在移植時，遇到至少幾個有趣的挑戰。</span><span class="sxs-lookup"><span data-stu-id="2b249-133">In fact, it deliberately includes some anti-patterns to make sure you come across at least a couple of interesting challenges while porting.</span></span>

## <a name="getting-ready"></a><span data-ttu-id="2b249-134">準備就緒</span><span class="sxs-lookup"><span data-stu-id="2b249-134">Getting ready</span></span>

<span data-ttu-id="2b249-135">將 .NET Framework 應用程式遷移至 .NET Core 的主要挑戰，在於它的相依性可能會以不同的方式執行，或是完全不適用。</span><span class="sxs-lookup"><span data-stu-id="2b249-135">The primary challenge of migrating a .NET Framework app to .NET Core is that its dependencies may work differently or not at all.</span></span> <span data-ttu-id="2b249-136">遷移比過去更容易;許多 NuGet 套件現在都是以 .NET Standard 為目標。</span><span class="sxs-lookup"><span data-stu-id="2b249-136">Migration is much easier than it used to be; many NuGet packages now target .NET Standard.</span></span> <span data-ttu-id="2b249-137">從 .NET Core 2.0 開始，.NET Framework 和 .NET Core 介面區已變得類似。</span><span class="sxs-lookup"><span data-stu-id="2b249-137">Starting with .NET Core 2.0, the .NET Framework and .NET Core surface areas have become similar.</span></span> <span data-ttu-id="2b249-138">儘管如此，還是會保留一些差異（兩者都是來自 NuGet 套件和可用 .NET Api 的支援）。</span><span class="sxs-lookup"><span data-stu-id="2b249-138">Even so, some differences (both in support from NuGet packages and in available .NET APIs) remain.</span></span> <span data-ttu-id="2b249-139">遷移的第一個步驟是檢查應用程式的相依性，並確定參考的格式可以輕鬆地遷移至 .NET Core。</span><span class="sxs-lookup"><span data-stu-id="2b249-139">The first step in migrating is to review the app's dependencies and make sure references are in a format that's easily migrated to .NET Core.</span></span>

### <a name="upgrade-to-packagereference-nuget-references"></a><span data-ttu-id="2b249-140">升級至 `<PackageReference>` NuGet 參考</span><span class="sxs-lookup"><span data-stu-id="2b249-140">Upgrade to `<PackageReference>` NuGet references</span></span>

<span data-ttu-id="2b249-141">較舊的 .NET Framework 專案通常會在*封裝 .config*檔案中列出其 NuGet 相依性。</span><span class="sxs-lookup"><span data-stu-id="2b249-141">Older .NET Framework projects typically list their NuGet dependencies in a *packages.config* file.</span></span> <span data-ttu-id="2b249-142">新的 SDK 樣式專案檔案格式會將 NuGet 套件當做 .csproj 檔案本身的元素來參考， [`<PackageReference>`](/nuget/consume-packages/package-references-in-project-files) 而不是在個別的設定檔中。</span><span class="sxs-lookup"><span data-stu-id="2b249-142">The new SDK-style project file format references NuGet packages as [`<PackageReference>`](/nuget/consume-packages/package-references-in-project-files) elements in the csproj file itself rather than in a separate config file.</span></span>

<span data-ttu-id="2b249-143">在遷移時，使用樣式參考有兩個優點 `<PackageReference>` ：</span><span class="sxs-lookup"><span data-stu-id="2b249-143">When migrating, there are two advantages to using `<PackageReference>`-style references:</span></span>

- <span data-ttu-id="2b249-144">這是新的 .NET Core 專案檔所需的 NuGet 參考樣式。</span><span class="sxs-lookup"><span data-stu-id="2b249-144">This is the style of NuGet reference that is required for the new .NET Core project file.</span></span> <span data-ttu-id="2b249-145">如果您已經在使用 `<PackageReference>` ，則可以將這些專案檔案元素直接複製並貼到新的專案中。</span><span class="sxs-lookup"><span data-stu-id="2b249-145">If you're already using `<PackageReference>`, those project file elements can be copied and pasted directly into the new project.</span></span>
- <span data-ttu-id="2b249-146">不同于封裝 .config 檔案， `<PackageReference>` 元素只會參考您的專案直接依存的最上層相依性。</span><span class="sxs-lookup"><span data-stu-id="2b249-146">Unlike a packages.config file, `<PackageReference>` elements only refer to the top-level dependencies that your project depends on directly.</span></span> <span data-ttu-id="2b249-147">所有其他可轉移的 NuGet 套件將會在還原時決定，並記錄在自動產生的 obj\project.assets.json 檔案中。</span><span class="sxs-lookup"><span data-stu-id="2b249-147">All other transitive NuGet packages will be determined at restore time and recorded in the autogenerated obj\project.assets.json file.</span></span> <span data-ttu-id="2b249-148">這可讓您更輕鬆地判斷專案具有哪些相依性，這在判斷必要的相依性是否適用于 .NET Core 時非常有用。</span><span class="sxs-lookup"><span data-stu-id="2b249-148">This makes it much easier to determine what dependencies your project has, which is useful when determining whether the necessary dependencies will work on .NET Core or not.</span></span>

<span data-ttu-id="2b249-149">將 .NET Framework 應用程式遷移至 .NET Core 的第一個步驟是將它更新為使用 `<PackageReference>` NuGet 參考。</span><span class="sxs-lookup"><span data-stu-id="2b249-149">The first step to migrating a .NET Framework app to .NET Core is to update it to use `<PackageReference>` NuGet references.</span></span> <span data-ttu-id="2b249-150">Visual Studio 讓這簡單。</span><span class="sxs-lookup"><span data-stu-id="2b249-150">Visual Studio makes this simple.</span></span> <span data-ttu-id="2b249-151">只要以滑鼠右鍵按一下 Visual Studio 的**方案總管**中專案的*封裝 .config*檔案，然後選取 [**將 PackageReference 遷移至] 即可**。</span><span class="sxs-lookup"><span data-stu-id="2b249-151">Just right-click the project's *packages.config* file in Visual Studio's **Solution Explorer**, and then select **Migrate packages.config to PackageReference**.</span></span>

![升級至 PackageReference](./media/convert-project-from-net-framework/package-reference-migration.png)

<span data-ttu-id="2b249-153">隨即出現一個對話方塊，顯示計算的最上層 NuGet 相依性，並詢問哪些其他 NuGet 套件應升級為最上層。</span><span class="sxs-lookup"><span data-stu-id="2b249-153">A dialog appears showing calculated top-level NuGet dependencies and asking which other NuGet packages should be promoted to top-level.</span></span> <span data-ttu-id="2b249-154">這些其他套件都不需要是 Bean Trader 範例的頂層，因此您可以取消選取所有這些方塊。</span><span class="sxs-lookup"><span data-stu-id="2b249-154">None of these other packages need to be top-level for the Bean Trader sample, so you can uncheck all of those boxes.</span></span> <span data-ttu-id="2b249-155">然後，按一下 **[確定]** ，就會移除*封裝 .config*檔案，並將 `<PackageReference>` 元素加入至專案檔。</span><span class="sxs-lookup"><span data-stu-id="2b249-155">Then, click **Ok** and the *packages.config* file is removed and `<PackageReference>` elements are added to the project file.</span></span>

<span data-ttu-id="2b249-156">`<PackageReference>`-樣式參考不會將 NuGet 套件儲存在本機的套件資料夾中。</span><span class="sxs-lookup"><span data-stu-id="2b249-156">`<PackageReference>`-style references don't store NuGet packages locally in a packages folder.</span></span> <span data-ttu-id="2b249-157">相反地，它們會全域儲存為優化。</span><span class="sxs-lookup"><span data-stu-id="2b249-157">Instead, they're stored globally as an optimization.</span></span> <span data-ttu-id="2b249-158">完成遷移之後，請編輯 .csproj 檔案，並移除任何 `<Analyzer>` 參考先前來自之分析器的元素 *。\packages*目錄。</span><span class="sxs-lookup"><span data-stu-id="2b249-158">After the migration completes, edit the csproj file and remove any `<Analyzer>` elements referring to the analyzers that previously came from the *..\packages* directory.</span></span> <span data-ttu-id="2b249-159">別擔心;由於您仍有 NuGet 套件參考，因此分析器會包含在專案中。</span><span class="sxs-lookup"><span data-stu-id="2b249-159">Don't worry; since you still have the NuGet package references, the analyzers will be included in the project.</span></span> <span data-ttu-id="2b249-160">您只需要清除舊的封裝 .config 樣式 `<Analyzer>` 元素。</span><span class="sxs-lookup"><span data-stu-id="2b249-160">You just need to clean up the old packages.config-style `<Analyzer>` elements.</span></span>

### <a name="review-nuget-packages"></a><span data-ttu-id="2b249-161">審查 NuGet 套件</span><span class="sxs-lookup"><span data-stu-id="2b249-161">Review NuGet packages</span></span>

<span data-ttu-id="2b249-162">現在您可以看到專案相依的最上層 NuGet 套件，您可以檢查這些封裝是否可在 .NET Core 上使用。</span><span class="sxs-lookup"><span data-stu-id="2b249-162">Now that you can see the top-level NuGet packages that the project depends on, you can review whether those packages are available on .NET Core.</span></span> <span data-ttu-id="2b249-163">您可以藉由查看[nuget.org](https://www.nuget.org/)上的相依性，判斷封裝是否支援 .net Core。建立社區的[fuget.org](https://www.fuget.org/)網站會在 [套件資訊] 頁面的頂端，以醒目方式顯示這項資訊。</span><span class="sxs-lookup"><span data-stu-id="2b249-163">You can determine whether a package supports .NET Core by looking at its dependencies on [nuget.org](https://www.nuget.org/). The community-created [fuget.org](https://www.fuget.org/) site shows this information prominently at the top of the package information page.</span></span>

<span data-ttu-id="2b249-164">以 .NET Core 3.0 為目標時，任何以 .NET core 或 .NET Standard 為目標的套件都應該可行（因為 .NET Core 會執行 .NET Standard 介面區）。</span><span class="sxs-lookup"><span data-stu-id="2b249-164">When targeting .NET Core 3.0, any packages targeting .NET Core or .NET Standard should work (since .NET Core implements the .NET Standard surface area).</span></span> <span data-ttu-id="2b249-165">在某些情況下，所使用之套件的特定版本不會以 .NET Core 或 .NET Standard 為目標，但較新的版本將會。</span><span class="sxs-lookup"><span data-stu-id="2b249-165">In some cases, the specific version of a package that's used won't target .NET Core or .NET Standard, but newer versions will.</span></span> <span data-ttu-id="2b249-166">在此情況下，您應該考慮升級至套件的最新版本。</span><span class="sxs-lookup"><span data-stu-id="2b249-166">In this case, you should consider upgrading to the latest version of the package.</span></span>

<span data-ttu-id="2b249-167">您也可以使用以 .NET Framework 為目標的套件，但這會帶來一些風險。</span><span class="sxs-lookup"><span data-stu-id="2b249-167">You can use packages targeting .NET Framework, as well, but that introduces some risk.</span></span> <span data-ttu-id="2b249-168">由於 .NET Core 和 .NET Framework 介面區域很類似，因此這類相依性*通常*是可行的，因此可以使用 .net core 來 .NET Framework 相依性。</span><span class="sxs-lookup"><span data-stu-id="2b249-168">.NET Core to .NET Framework dependencies are allowed because .NET Core and .NET Framework surface areas are similar enough that such dependencies *often* work.</span></span> <span data-ttu-id="2b249-169">不過，如果套件嘗試使用 .NET Core 中不存在的 .NET API，您將會遇到執行時間例外狀況。</span><span class="sxs-lookup"><span data-stu-id="2b249-169">However, if the package tries to use a .NET API that isn't present in .NET Core, you'll encounter a runtime exception.</span></span> <span data-ttu-id="2b249-170">因此，您應該只在沒有其他可用選項時參考 .NET Framework 套件，並瞭解這麼做會造成測試負擔。</span><span class="sxs-lookup"><span data-stu-id="2b249-170">Because of that, you should only reference .NET Framework packages when no other options are available and understand that doing so imposes a test burden.</span></span>

<span data-ttu-id="2b249-171">如果有參考的套件不是以 .NET Core 或 .NET Standard 為目標，您就必須考慮其他替代方法：</span><span class="sxs-lookup"><span data-stu-id="2b249-171">If there are packages referenced that don't target .NET Core or .NET Standard, you'll have to think about other alternatives:</span></span>

- <span data-ttu-id="2b249-172">是否有其他類似的套件可以改用？</span><span class="sxs-lookup"><span data-stu-id="2b249-172">Are there other similar packages that can be used instead?</span></span> <span data-ttu-id="2b249-173">有時 NuGet 作者會發佈個別的 '。核心版本的程式庫，特別以 .NET Core 為目標。</span><span class="sxs-lookup"><span data-stu-id="2b249-173">Sometimes NuGet authors publish separate '.Core' versions of their libraries specifically targeting .NET Core.</span></span> <span data-ttu-id="2b249-174">企業程式庫套件是「社區發行」的範例。NetCore 「替代方案」。</span><span class="sxs-lookup"><span data-stu-id="2b249-174">Enterprise Library packages are an example of the community publishing ".NetCore" alternatives.</span></span> <span data-ttu-id="2b249-175">在其他情況下，可 .NET Standard 特定服務的較新 Sdk （有時具有不同的套件名稱）。</span><span class="sxs-lookup"><span data-stu-id="2b249-175">In other cases, newer SDKs for a particular service (sometimes with different package names) are available for .NET Standard.</span></span> <span data-ttu-id="2b249-176">如果沒有可用的替代專案，您可以繼續使用以 .NET Framework 為目標的套件，請注意，在 .NET Core 上執行之後，您必須徹底進行測試。</span><span class="sxs-lookup"><span data-stu-id="2b249-176">If no alternatives are available, you can proceed using the .NET Framework-targeted packages, bearing in mind that you'll need to test them thoroughly once running on .NET Core.</span></span>

<span data-ttu-id="2b249-177">[Bean Trader 範例] 具有下列最上層的 NuGet 相依性：</span><span class="sxs-lookup"><span data-stu-id="2b249-177">The Bean Trader sample has the following top-level NuGet dependencies:</span></span>

- [<span data-ttu-id="2b249-178">**Castle. Windsor，版本4.1。1**</span><span class="sxs-lookup"><span data-stu-id="2b249-178">**Castle.Windsor, version 4.1.1**</span></span>](https://www.castleproject.org/projects/windsor/)  

  <span data-ttu-id="2b249-179">此套件的目標為 .NET Standard 1.6，因此可在 .NET Core 上運作。</span><span class="sxs-lookup"><span data-stu-id="2b249-179">This package targets .NET Standard 1.6, so it works on .NET Core.</span></span>

- [<span data-ttu-id="2b249-180">**CodeAnalysis. FxCopAnalyzers，版本2.6。3**</span><span class="sxs-lookup"><span data-stu-id="2b249-180">**Microsoft.CodeAnalysis.FxCopAnalyzers, version 2.6.3**</span></span>](https://www.nuget.org/packages/Microsoft.CodeAnalysis.FxCopAnalyzers/2.6.3)  
  <span data-ttu-id="2b249-181">這是中繼套件，因此不會立即察覺它支援的平臺，但[檔](https://github.com/dotnet/roslyn-analyzers#microsoftcodeanalysisfxcopanalyzers)會指出其最新版本（2.9.2）適用于 .NET FRAMEWORK 和 .net Core。</span><span class="sxs-lookup"><span data-stu-id="2b249-181">This is a meta-package, so it's not immediately obvious which platforms it supports, but [documentation](https://github.com/dotnet/roslyn-analyzers#microsoftcodeanalysisfxcopanalyzers) indicates that its newest version (2.9.2) will work for both .NET Framework and .NET Core.</span></span>

- [<span data-ttu-id="2b249-182">**Nito. AsyncEx，版本4.0。1**</span><span class="sxs-lookup"><span data-stu-id="2b249-182">**Nito.AsyncEx, version 4.0.1**</span></span>](https://www.nuget.org/packages/Nito.AsyncEx/4.0.1)  

  <span data-ttu-id="2b249-183">此套件不是以 .NET Core 為目標，但較新的5.0 版本則會這麼做。</span><span class="sxs-lookup"><span data-stu-id="2b249-183">This package doesn't target .NET Core, but the newer 5.0 version does.</span></span> <span data-ttu-id="2b249-184">這在遷移時很常見，因為許多 NuGet 封裝已新增 .NET Standard 的支援，但較舊的專案版本只會以 .NET Framework 為目標。</span><span class="sxs-lookup"><span data-stu-id="2b249-184">This is common when migrating because many NuGet packages have added .NET Standard support recently, but older project versions will only target .NET Framework.</span></span> <span data-ttu-id="2b249-185">如果版本差異只是次要版本的差異，通常可以輕鬆地升級至較新的版本。</span><span class="sxs-lookup"><span data-stu-id="2b249-185">If the version difference is only a minor version difference, it's often easy to upgrade to the newer version.</span></span> <span data-ttu-id="2b249-186">因為這是主要的版本變更，所以您必須小心升級，因為封裝中可能會有重大變更。</span><span class="sxs-lookup"><span data-stu-id="2b249-186">Because this is a major version change, you need to be cautious upgrading since there could be breaking changes in the package.</span></span> <span data-ttu-id="2b249-187">不過，有一個路徑向前邁進，這是很好的方法。</span><span class="sxs-lookup"><span data-stu-id="2b249-187">There is a path forward, though, which is good.</span></span>

- [<span data-ttu-id="2b249-188">**MahApps，版本1.6。5**</span><span class="sxs-lookup"><span data-stu-id="2b249-188">**MahApps.Metro, version 1.6.5**</span></span>](https://www.nuget.org/packages/MahApps.Metro/1.6.5)  

  <span data-ttu-id="2b249-189">此套件也不會以 .NET Core 為目標，但具有較新的發行前版本（2.0-Alpha），其會執行。</span><span class="sxs-lookup"><span data-stu-id="2b249-189">This package also doesn't target .NET Core, but has a newer pre-release (2.0-alpha) that does.</span></span> <span data-ttu-id="2b249-190">同樣地，您必須找出重大變更，但較新的套件鼓勵您。</span><span class="sxs-lookup"><span data-stu-id="2b249-190">Again, you have to look out for breaking changes, but the newer package is encouraging.</span></span>

<span data-ttu-id="2b249-191">Bean Trader 範例的 NuGet 相依性全都以 .NET Standard/.NET Core 為目標，或具有較新的版本，因此這裡不太可能發生任何封鎖問題。</span><span class="sxs-lookup"><span data-stu-id="2b249-191">The Bean Trader sample's NuGet dependencies all either target .NET Standard/.NET Core or have newer versions that do, so there are unlikely to be any blocking issues here.</span></span>

### <a name="upgrade-nuget-packages"></a><span data-ttu-id="2b249-192">升級 NuGet 套件</span><span class="sxs-lookup"><span data-stu-id="2b249-192">Upgrade NuGet packages</span></span>

<span data-ttu-id="2b249-193">可能的話，最好是升級僅以 .NET Core 為目標的任何封裝版本，或目前以較新版本 .NET Standard 的任何套件（專案仍以 .NET Framework 為目標），以及早探索並解決任何重大變更。</span><span class="sxs-lookup"><span data-stu-id="2b249-193">If possible, it would be good to upgrade the versions of any packages that only target .NET Core or .NET Standard with more recent versions at this point (with the project still targeting .NET Framework) to discover and address any breaking changes early.</span></span>

<span data-ttu-id="2b249-194">如果您不想對應用程式的現有 .NET Framework 版本進行任何材質變更，這可以等到您有以 .NET Core 為目標的新專案檔。</span><span class="sxs-lookup"><span data-stu-id="2b249-194">If you would rather not make any material changes to the existing .NET Framework version of the app, this can wait until you have a new project file targeting .NET Core.</span></span> <span data-ttu-id="2b249-195">不過，預先將 NuGet 套件升級至 .NET Core 相容版本，可讓您在建立新的專案檔之後更輕鬆地進行遷移程式，並減少 .NET Framework 與 .NET Core 版本的應用程式之間的差異。</span><span class="sxs-lookup"><span data-stu-id="2b249-195">However, upgrading the NuGet packages to .NET Core-compatible versions ahead of time makes the migration process even easier once you create the new project file and reduces the number of differences between the .NET Framework and .NET Core versions of the app.</span></span>

<span data-ttu-id="2b249-196">使用 Bean Trader 範例，可以輕鬆地進行所有必要的升級（使用 Visual Studio 的 NuGet 套件管理員），但有一個例外：從**MahApps**升級到**2.0** ，會顯示與主題和輔色管理 api 相關的重大變更。</span><span class="sxs-lookup"><span data-stu-id="2b249-196">With the Bean Trader sample, all of the necessary upgrades can be made easily (using Visual Studio's NuGet package manager) with one exception: upgrading from **MahApps.Metro 1.6.5** to **2.0** reveals breaking changes related to theme and accent management APIs.</span></span>

<span data-ttu-id="2b249-197">在理想的情況下，應用程式會更新為使用較新版本的套件（因為這較可能在 .NET Core 上使用）。</span><span class="sxs-lookup"><span data-stu-id="2b249-197">Ideally, the app would be updated to use the newer version of the package (since that is more likely to work on .NET Core).</span></span> <span data-ttu-id="2b249-198">不過，在某些情況下，這可能不可行。</span><span class="sxs-lookup"><span data-stu-id="2b249-198">In some cases, however, that may not be feasible.</span></span> <span data-ttu-id="2b249-199">在這些情況下，請不要升級**MahApps** ，因為必要的變更並不簡單，而本教學課程著重于遷移至 .net Core 3，而不是**MahApps。 Metro 2。**</span><span class="sxs-lookup"><span data-stu-id="2b249-199">In these cases, don't upgrade **MahApps.Metro** because the necessary changes are non-trivial and this tutorial focuses on migrating to .NET Core 3, not to **MahApps.Metro 2.**</span></span> <span data-ttu-id="2b249-200">此外，這是一項低風險 .NET Framework 相依性，因為 Bean Trader 應用程式只會練習**MahApps**的一小部分。</span><span class="sxs-lookup"><span data-stu-id="2b249-200">Also, this is a low-risk .NET Framework dependency because the Bean Trader app only exercises a small part of **MahApps.Metro**.</span></span> <span data-ttu-id="2b249-201">當然，它還需要進行測試，以確保在完成遷移之後，一切都能正常運作。</span><span class="sxs-lookup"><span data-stu-id="2b249-201">It will, of course, require testing to make sure everything's working once the migration is complete.</span></span> <span data-ttu-id="2b249-202">如果這是真實世界的案例，建議您提出問題以追蹤移至**MahApps** 2.0 版的工作，因為不會進行遷移，因此現在不會留下一些技術債務。</span><span class="sxs-lookup"><span data-stu-id="2b249-202">If this were a real-world scenario, it would be good to file an issue to track the work to move to **MahApps.Metro** version 2.0 since not doing the migration now leaves behind some technical debt.</span></span>

<span data-ttu-id="2b249-203">將 NuGet 套件更新為最新版本之後， `<PackageReference>` Bean Trader 範例的專案檔中的專案群組看起來應該像這樣。</span><span class="sxs-lookup"><span data-stu-id="2b249-203">Once the NuGet packages are updated to recent versions, the `<PackageReference>` item group in the Bean Trader sample's project file should look like this.</span></span>

```xml
<ItemGroup>
  <PackageReference Include="Castle.Windsor">
    <Version>4.1.1</Version>
  </PackageReference>
  <PackageReference Include="MahApps.Metro">
    <Version>1.6.5</Version>
  </PackageReference>
  <PackageReference Include="Microsoft.CodeAnalysis.FxCopAnalyzers">
    <Version>2.9.2</Version>
  </PackageReference>
  <PackageReference Include="Nito.AsyncEx">
    <Version>5.0.0</Version>
  </PackageReference>
</ItemGroup>
```

### <a name="net-framework-portability-analysis"></a><span data-ttu-id="2b249-204">.NET Framework 可攜性分析</span><span class="sxs-lookup"><span data-stu-id="2b249-204">.NET Framework portability analysis</span></span>

<span data-ttu-id="2b249-205">一旦您瞭解專案的 NuGet 相依性狀態之後，接下來要考慮的事項是 .NET Framework API 相依性。</span><span class="sxs-lookup"><span data-stu-id="2b249-205">Once you understand the state of your project's NuGet dependencies, the next thing to consider is .NET Framework API dependencies.</span></span> <span data-ttu-id="2b249-206">[.Net 可攜性分析器](../../standard/analyzers/portability-analyzer.md)工具適合用來瞭解您的專案所使用的 .net api 在其他 .net 平臺上是否可用。</span><span class="sxs-lookup"><span data-stu-id="2b249-206">The [.NET Portability Analyzer](../../standard/analyzers/portability-analyzer.md) tool is useful for understanding which of the .NET APIs your project uses are available on other .NET platforms.</span></span>

<span data-ttu-id="2b249-207">此工具會做為[Visual Studio 外掛程式](https://marketplace.visualstudio.com/items?itemName=ConnieYau.NETPortabilityAnalyzer)、[命令列工具](https://github.com/Microsoft/dotnet-apiport/releases)，或包裝在[簡單的 GUI](https://github.com/Microsoft/dotnet-apiport-ui)中，以簡化其選項。</span><span class="sxs-lookup"><span data-stu-id="2b249-207">The tool comes as a [Visual Studio plugin](https://marketplace.visualstudio.com/items?itemName=ConnieYau.NETPortabilityAnalyzer), a [command-line tool](https://github.com/Microsoft/dotnet-apiport/releases), or wrapped in a [simple GUI](https://github.com/Microsoft/dotnet-apiport-ui), which simplifies its options.</span></span> <span data-ttu-id="2b249-208">若要深入瞭解如何使用 .NET 可攜性分析器（API 埠），請參閱將[桌面應用程式移植到 .Net Core](https://devblogs.microsoft.com/dotnet/porting-desktop-apps-to-net-core/)的 blog 文章。</span><span class="sxs-lookup"><span data-stu-id="2b249-208">You can read more about using the .NET Portability Analyzer (API Port) using the GUI in the [Porting desktop apps to .NET Core](https://devblogs.microsoft.com/dotnet/porting-desktop-apps-to-net-core/) blog post.</span></span> <span data-ttu-id="2b249-209">如果您想要使用命令列，所需的步驟如下：</span><span class="sxs-lookup"><span data-stu-id="2b249-209">If you prefer to use the command line, the necessary steps are:</span></span>

1. <span data-ttu-id="2b249-210">下載[.net 可攜性分析器](https://github.com/Microsoft/dotnet-apiport/releases)（如果尚未安裝的話）。</span><span class="sxs-lookup"><span data-stu-id="2b249-210">Download the [.NET Portability Analyzer](https://github.com/Microsoft/dotnet-apiport/releases) if you don't already have it.</span></span>
1. <span data-ttu-id="2b249-211">請確定 .NET Framework 應用程式可以成功地進行移植（這在遷移之前是不錯的主意）。</span><span class="sxs-lookup"><span data-stu-id="2b249-211">Make sure the .NET Framework app to be ported builds successfully (this is a good idea prior to migration regardless).</span></span>
1. <span data-ttu-id="2b249-212">使用類似如下的命令列來執行 API 埠。</span><span class="sxs-lookup"><span data-stu-id="2b249-212">Run API Port with a command line like this.</span></span>

    ```console
    ApiPort.exe analyze -f <PathToBeanTraderBinaries> -r html -r excel -t ".NET Core"
    ```

    <span data-ttu-id="2b249-213">`-f`引數會指定包含要分析之二進位檔的路徑。</span><span class="sxs-lookup"><span data-stu-id="2b249-213">The `-f` argument specifies the path containing the binaries to analyze.</span></span> <span data-ttu-id="2b249-214">`-r`引數會指定您想要的輸出檔案格式。</span><span class="sxs-lookup"><span data-stu-id="2b249-214">The `-r` argument specifies which output file format you want.</span></span> <span data-ttu-id="2b249-215">`-t`引數會指定分析 API 使用的目標 .net 平臺。</span><span class="sxs-lookup"><span data-stu-id="2b249-215">The `-t` argument specifies which .NET platform to analyze API usage against.</span></span> <span data-ttu-id="2b249-216">在此情況下，您會想要 .NET Core。</span><span class="sxs-lookup"><span data-stu-id="2b249-216">In this case, you want .NET Core.</span></span>

<span data-ttu-id="2b249-217">當您開啟 HTML 報表時，第一個區段會列出所有分析的二進位檔，以及它們使用的 .NET Api 的百分比在目標平臺上可用。</span><span class="sxs-lookup"><span data-stu-id="2b249-217">When you open the HTML report, the first section will list all of the analyzed binaries and what percentage of the .NET APIs they use are available on the targeted platform.</span></span> <span data-ttu-id="2b249-218">百分比本身並沒有意義。</span><span class="sxs-lookup"><span data-stu-id="2b249-218">The percentage is not meaningful by itself.</span></span> <span data-ttu-id="2b249-219">最有用的是查看遺漏的特定 Api。</span><span class="sxs-lookup"><span data-stu-id="2b249-219">What's more useful is to see the specific APIs that are missing.</span></span> <span data-ttu-id="2b249-220">若要這麼做，請選取元件名稱，或向下移動至個別元件的報表。</span><span class="sxs-lookup"><span data-stu-id="2b249-220">To do that, either select an assembly name or scroll down to the reports for individual assemblies.</span></span>

<span data-ttu-id="2b249-221">將焦點放在您擁有原始程式碼的元件上。</span><span class="sxs-lookup"><span data-stu-id="2b249-221">Focus on the assemblies that you own the source code for.</span></span> <span data-ttu-id="2b249-222">例如，在 [Bean Trader ApiPort] 報告中，列出許多二進位檔，但其中大部分都屬於 NuGet 套件。</span><span class="sxs-lookup"><span data-stu-id="2b249-222">In the Bean Trader ApiPort report, for example, there are many binaries listed, but most of them belong to NuGet packages.</span></span> <span data-ttu-id="2b249-223">`Castle.Windsor`顯示相依于 .NET Core 中遺漏的一些 System.web Api。</span><span class="sxs-lookup"><span data-stu-id="2b249-223">`Castle.Windsor` shows that it depends on some System.Web APIs that are missing in .NET Core.</span></span> <span data-ttu-id="2b249-224">這不是問題，因為您先前已確認 `Castle.Windsor` 支援 .Net Core。</span><span class="sxs-lookup"><span data-stu-id="2b249-224">This isn't a concern because you previously verified that `Castle.Windsor` supports .NET Core.</span></span> <span data-ttu-id="2b249-225">NuGet 套件通常會有不同的二進位檔，以便與不同的 .NET 平臺搭配使用，因此， `Castle.Windsor` 只要封裝也以 .NET Standard 或 .Net Core 為目標（其具備），.NET Framework 版本的就會使用 System.web api 或不相關。</span><span class="sxs-lookup"><span data-stu-id="2b249-225">It is common for NuGet packages to have different binaries for use with different .NET platforms, so whether the .NET Framework version of `Castle.Windsor` uses System.Web APIs or not is irrelevant as long as the package also targets .NET Standard or .NET Core (which it does).</span></span>

<span data-ttu-id="2b249-226">使用 Bean Trader 範例時，您唯一需要考慮的二進位檔是**BeanTraderClient** ，而且報表會顯示只有兩個 .net api 遺失： `System.ServiceModel.ClientBase<T>.Close` 和 `System.ServiceModel.ClientBase<T>.Open` 。</span><span class="sxs-lookup"><span data-stu-id="2b249-226">With the Bean Trader sample, the only binary that you need to consider is **BeanTraderClient** and the report shows that only two .NET APIs are missing: `System.ServiceModel.ClientBase<T>.Close` and `System.ServiceModel.ClientBase<T>.Open`.</span></span>

![BeanTraderClient 可攜性報告](./media/convert-project-from-net-framework/portability-report.png)

<span data-ttu-id="2b249-228">這不太可能會造成封鎖問題，因為 WCF 用戶端 Api （大多）在 .NET Core 上受到支援，因此這些中央 Api 必須有替代方案。</span><span class="sxs-lookup"><span data-stu-id="2b249-228">These are unlikely to be blocking issues because WCF Client APIs are (mostly) supported on .NET Core, so there must be alternatives available for these central APIs.</span></span> <span data-ttu-id="2b249-229">事實上，在查看 `System.ServiceModel` .Net core 介面區（使用）時 <https://apisof.net> ，您會看到 .net core 中有非同步替代專案。</span><span class="sxs-lookup"><span data-stu-id="2b249-229">In fact, looking at `System.ServiceModel`'s .NET Core surface area (using <https://apisof.net>), you see that there are async alternatives in .NET Core instead.</span></span>

<span data-ttu-id="2b249-230">根據這份報告和先前的 NuGet 相依性分析，將 Bean Trader 範例遷移至 .NET Core 時似乎不會有任何重大問題。</span><span class="sxs-lookup"><span data-stu-id="2b249-230">Based on this report and the previous NuGet dependency analysis, it looks like there should be no major issues migrating the Bean Trader sample to .NET Core.</span></span> <span data-ttu-id="2b249-231">您已準備好進行下一個步驟，也就是您將會實際開始進行遷移。</span><span class="sxs-lookup"><span data-stu-id="2b249-231">You're ready for the next step in which you'll actually start the migration.</span></span>

## <a name="migrating-the-project-file"></a><span data-ttu-id="2b249-232">移轉專案檔</span><span class="sxs-lookup"><span data-stu-id="2b249-232">Migrating the project file</span></span>

<span data-ttu-id="2b249-233">如果您的應用程式未使用新的[SDK 樣式專案檔案格式](../../core/tools/csproj.md)，您將需要新的專案檔來以 .net Core 為目標。</span><span class="sxs-lookup"><span data-stu-id="2b249-233">If your app isn't using the new [SDK-style project file format](../../core/tools/csproj.md), you'll need a new project file to target .NET Core.</span></span> <span data-ttu-id="2b249-234">您可以取代現有的 .csproj 檔案，或者，如果您想要讓現有專案保持不變的目前狀態，您可以加入以 .NET Core 為目標的新 .csproj 檔案。</span><span class="sxs-lookup"><span data-stu-id="2b249-234">You can replace the existing csproj file or, if you prefer to keep the existing project untouched in its current state, you can add a new csproj file targeting .NET Core.</span></span> <span data-ttu-id="2b249-235">您可以使用具有[多目標](../../standard/library-guidance/cross-platform-targeting.md)（指定多個目標）的單一 SDK 樣式專案檔，建立適用于 .NET FRAMEWORK 和 .net Core 的應用程式版本 `<TargetFrameworks>` 。</span><span class="sxs-lookup"><span data-stu-id="2b249-235">You can build versions of the app for .NET Framework and .NET Core with a single SDK-style project file with [multi-targeting](../../standard/library-guidance/cross-platform-targeting.md) (specifying multiple `<TargetFrameworks>` targets).</span></span>

<span data-ttu-id="2b249-236">若要建立新的專案檔，您可以在 Visual Studio 中建立新的 WPF 專案，或在 `dotnet new wpf` 臨時目錄中使用命令來產生專案檔案，然後將它複製/重新命名為正確的位置。</span><span class="sxs-lookup"><span data-stu-id="2b249-236">To create the new project file, you can create a new WPF project in Visual Studio or use the `dotnet new wpf` command in a temporary directory to generate the project file and then copy/rename it to the correct location.</span></span> <span data-ttu-id="2b249-237">另外還有一個以社區建立的工具[CsprojToVs2017](https://github.com/hvanbakel/CsprojToVs2017)，可以自動化部分專案檔案遷移。</span><span class="sxs-lookup"><span data-stu-id="2b249-237">There is also a community-created tool, [CsprojToVs2017](https://github.com/hvanbakel/CsprojToVs2017), that can automate some of the project file migration.</span></span> <span data-ttu-id="2b249-238">此工具很有説明，但仍需要人工檢查結果，以確保所有的遷移詳細資料都正確無誤。</span><span class="sxs-lookup"><span data-stu-id="2b249-238">The tool is helpful but still needs a human to review the results to make sure all the details of the migration are correct.</span></span> <span data-ttu-id="2b249-239">工具無法以最佳方式處理的一個特定區域是從*套件 .config*檔案遷移 NuGet 套件。</span><span class="sxs-lookup"><span data-stu-id="2b249-239">One particular area that the tool doesn't handle optimally is migrating NuGet packages from *packages.config* files.</span></span> <span data-ttu-id="2b249-240">如果此工具在專案檔上執行，而該檔案仍使用*封裝 .config*檔案來參考 NuGet 套件，它會自動遷移至 `<PackageReference>` 元素，但會 `<PackageReference>` 為*所有*封裝加入元素，而不只是最上層的套件。</span><span class="sxs-lookup"><span data-stu-id="2b249-240">If the tool runs on a project file that still uses a *packages.config* file to reference NuGet packages, it will migrate to `<PackageReference>` elements automatically, but will add `<PackageReference>` elements for *all* of the packages instead of just top-level ones.</span></span> <span data-ttu-id="2b249-241">如果您已經使用 Visual Studio 遷移至專案 `<PackageReference>` （如您在此範例中所做的），則工具可以協助進行其餘的轉換。</span><span class="sxs-lookup"><span data-stu-id="2b249-241">If you have already migrated to`<PackageReference>` elements with Visual Studio (as you've done in this sample), then the tool can help with the rest of the conversion.</span></span> <span data-ttu-id="2b249-242">就像 Scott Hanselman 在[他的](https://www.hanselman.com/blog/UpgradingAnExistingNETProjectFilesToTheLeanNewCSPROJFormatFromNETCore.aspx)文章中建議您在遷移 .csproj 檔案時，以手動方式移植是教育的，如果您只需要幾個專案，就會得到更好的結果。</span><span class="sxs-lookup"><span data-stu-id="2b249-242">Like Scott Hanselman recommends in [his blog post on migrating csproj files](https://www.hanselman.com/blog/UpgradingAnExistingNETProjectFilesToTheLeanNewCSPROJFormatFromNETCore.aspx), porting by hand is educational and will give better results if you only have a few projects to port.</span></span> <span data-ttu-id="2b249-243">但是，如果您要移植數十個或數百個專案檔，那麼[CsprojToVs2017](https://github.com/hvanbakel/CsprojToVs2017)之類的工具就可以提供協助。</span><span class="sxs-lookup"><span data-stu-id="2b249-243">But if you're porting dozens or hundreds of project files, then a tool like [CsprojToVs2017](https://github.com/hvanbakel/CsprojToVs2017) can be a help.</span></span>

<span data-ttu-id="2b249-244">若要建立 Bean Trader 範例的新專案檔，請 `dotnet new wpf` 在臨時目錄中執行，並將產生的 *.csproj*檔案移至*BeanTraderClient*資料夾，並將它重新命名為 BeanTraderClient. **Core .csproj**。</span><span class="sxs-lookup"><span data-stu-id="2b249-244">To create a new project file for the Bean Trader sample, run `dotnet new wpf` in a temporary directory and move the generated *.csproj* file into the *BeanTraderClient* folder and rename it **BeanTraderClient.Core.csproj**.</span></span>

<span data-ttu-id="2b249-245">因為新的專案檔案格式會自動包含 c # 檔案、 *resx*檔案和 XAML 檔案，其可在或其目錄底下找到，所以專案檔已幾乎完成！</span><span class="sxs-lookup"><span data-stu-id="2b249-245">Because the new project file format automatically includes C# files, *resx* files, and XAML files that it finds in or under its directory, the project file is already almost complete!</span></span> <span data-ttu-id="2b249-246">若要完成遷移，請並存開啟舊的和新的專案檔，並查看舊的專案檔，以查看是否需要遷移其中包含的任何資訊。</span><span class="sxs-lookup"><span data-stu-id="2b249-246">To finish the migration, open the old and new project files side-by-side and look through the old one to see if any information it contains needs to be migrated.</span></span> <span data-ttu-id="2b249-247">在 Bean Trader 範例案例中，下列專案應該複製到新的專案：</span><span class="sxs-lookup"><span data-stu-id="2b249-247">In the Bean Trader sample case, the following items should be copied to the new project:</span></span>

- <span data-ttu-id="2b249-248">`<RootNamespace>`、 `<AssemblyName>` 和 `<ApplicationIcon>` 屬性應全部複製。</span><span class="sxs-lookup"><span data-stu-id="2b249-248">The `<RootNamespace>`, `<AssemblyName>`, and `<ApplicationIcon>` properties should all be copied.</span></span>

- <span data-ttu-id="2b249-249">您也需要將屬性加入 `<GenerateAssemblyInfo>false</GenerateAssemblyInfo>` 至新的專案檔，因為「Bean Trader 範例會在 AssemblyInfo.cs 檔中包含元件層級屬性（例如 `[AssemblyTitle]` ）。</span><span class="sxs-lookup"><span data-stu-id="2b249-249">You also need to add a `<GenerateAssemblyInfo>false</GenerateAssemblyInfo>` property to the new project file since the Bean Trader sample includes assembly-level attributes (like `[AssemblyTitle]`) in an AssemblyInfo.cs file.</span></span> <span data-ttu-id="2b249-250">根據預設，新的 SDK 樣式專案會依據 .csproj 檔案中的屬性來自動產生這些屬性。</span><span class="sxs-lookup"><span data-stu-id="2b249-250">By default, new SDK-style projects will autogenerate these attributes based on properties in the csproj file.</span></span> <span data-ttu-id="2b249-251">因為您不想在這種情況下發生這種情況（自動產生的屬性會與 AssemblyInfo.cs 中的屬性衝突），所以您可以使用來停用自動產生的屬性 `<GenerateAssemblyInfo>` 。</span><span class="sxs-lookup"><span data-stu-id="2b249-251">Because you don't want that to happen in this case (the autogenerated attributes would conflict with those from AssemblyInfo.cs), you disable the autogenerated attributes with `<GenerateAssemblyInfo>`.</span></span>

- <span data-ttu-id="2b249-252">雖然*resx*檔案會自動納入為內嵌資源，但其他 `<Resource>` 專案（例如影像）則不會。</span><span class="sxs-lookup"><span data-stu-id="2b249-252">Although *resx* files are automatically included as embedded resources, other `<Resource>` items like images are not.</span></span> <span data-ttu-id="2b249-253">因此，請複製 `<Resource>` 用於內嵌影像和圖示檔的元素。</span><span class="sxs-lookup"><span data-stu-id="2b249-253">So, copy the `<Resource>` elements for embedding image and icon files.</span></span> <span data-ttu-id="2b249-254">您可以使用新的專案檔案格式對萬用字元模式的支援，來簡化單一行的 png 參考： `<Resource Include="**\*.png" />` 。</span><span class="sxs-lookup"><span data-stu-id="2b249-254">You can simplify the png references to a single line by using the new project file format's support for globbing patterns: `<Resource Include="**\*.png" />`.</span></span>

- <span data-ttu-id="2b249-255">同樣地，系統 `<None>` 會自動包含專案，但預設不會將它們複製到輸出目錄。</span><span class="sxs-lookup"><span data-stu-id="2b249-255">Similarly, `<None>` items are included automatically, but they aren't copied to the output directory, by default.</span></span> <span data-ttu-id="2b249-256">由於 Bean Trader 專案包含 `<None>` 複製到輸出目錄*is* （使用行為）的專案，因此 `PreserveNewest` 您必須更新該檔案的自動填入 `<None>` 專案，如下所示。</span><span class="sxs-lookup"><span data-stu-id="2b249-256">Because the Bean Trader project includes a `<None>` item that *is* copied to the output directory (using `PreserveNewest` behaviors), you need to update the automatically populated `<None>` item for that file, like this.</span></span>

  ```xml
  <None Update="BeanTrader.pfx">
    <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
  </None>
  ```

- <span data-ttu-id="2b249-257">[Bean Trader] 範例包含 XAML 檔案（預設值）做為 `Content` （而不是 `Page` ），因為在執行時間會從檔案的 XAML 載入這個檔案中定義的主題和重音，而不是內嵌在應用程式本身。</span><span class="sxs-lookup"><span data-stu-id="2b249-257">The Bean Trader sample includes a XAML file (Default.Accent.xaml) as `Content` (rather than as a `Page`) because themes and accents defined in this file are loaded from the file's XAML at runtime, rather than being embedded in the app itself.</span></span> <span data-ttu-id="2b249-258">不過，新的專案系統會自動將此檔案包含在 `<Page>` 中，因為它是 XAML 檔案。</span><span class="sxs-lookup"><span data-stu-id="2b249-258">The new project system automatically includes this file as a `<Page>`, however, since it's a XAML file.</span></span> <span data-ttu-id="2b249-259">因此，您必須將 XAML 檔案移除為頁面（ `<Page Remove="**\Default.Accent.xaml" />` ），並將它新增為內容。</span><span class="sxs-lookup"><span data-stu-id="2b249-259">So, you need to both remove the XAML file as a page (`<Page Remove="**\Default.Accent.xaml" />`) and add it as content.</span></span>

  ```xml
  <Content Include="Resources\Themes\Default.Accent.xaml">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
  </Content>
  ```

- <span data-ttu-id="2b249-260">最後，藉由複製包含所有元素的來新增 NuGet 參考 `<ItemGroup>` `<PackageReference>` 。</span><span class="sxs-lookup"><span data-stu-id="2b249-260">Finally, add NuGet references by copying the `<ItemGroup>` with all the `<PackageReference>` elements.</span></span> <span data-ttu-id="2b249-261">如果您先前未將 NuGet 套件升級為 .NET Core 相容版本，您可以執行這項操作，因為套件參考是在 .NET Core 特定的專案中。</span><span class="sxs-lookup"><span data-stu-id="2b249-261">If you hadn't previously upgraded the NuGet packages to .NET Core-compatible versions, you could do that now that the package references are in a .NET Core-specific project.</span></span>

<span data-ttu-id="2b249-262">此時，您應該可以將新專案新增至 BeanTrader 方案，並在 Visual Studio 中開啟它。</span><span class="sxs-lookup"><span data-stu-id="2b249-262">At this point, it should be possible to add the new project to the BeanTrader solution and open it in Visual Studio.</span></span> <span data-ttu-id="2b249-263">專案在**方案總管**中應該看起來是正確的，而且 `dotnet restore BeanTraderClient.Core.csproj` 應該成功還原套件（有兩個預期的警告，與您使用的目標是 .NET Framework 的 MahApps 版本有關）。</span><span class="sxs-lookup"><span data-stu-id="2b249-263">The project should look correct in **Solution Explorer**, and `dotnet restore BeanTraderClient.Core.csproj` should successfully restore packages (with two expected warnings related to the MahApps.Metro version you're using targeting .NET Framework).</span></span>

<span data-ttu-id="2b249-264">雖然可以同時保留這兩個專案檔（如果您想要保持完全相同的專案，可能也會需要），它會使遷移程式變得更複雜（這兩個專案會嘗試使用相同的 bin 和 obj 資料夾），而且通常不是必要的。</span><span class="sxs-lookup"><span data-stu-id="2b249-264">Although it's possible to keep both project files side-by-side (and may even be desirable if you want to keep building the old project exactly as it was), it complicates the migration process (the two projects will try to use the same bin and obj folders) and usually isn't necessary.</span></span> <span data-ttu-id="2b249-265">如果您想要同時建立 .NET Core 和 .NET Framework 目標，您可以 `<TargetFramework>netcoreapp3.0</TargetFramework>` 改為將新專案檔中的屬性取代 `<TargetFrameworks>netcoreapp3.0;net472</TargetFrameworks>` 為。</span><span class="sxs-lookup"><span data-stu-id="2b249-265">If you want to build for both .NET Core and .NET Framework targets, you can replace the `<TargetFramework>netcoreapp3.0</TargetFramework>` property in the new project file with `<TargetFrameworks>netcoreapp3.0;net472</TargetFrameworks>` instead.</span></span> <span data-ttu-id="2b249-266">針對 [Bean Trader 範例]，刪除舊的專案檔（BeanTraderClient），因為已不再需要它。</span><span class="sxs-lookup"><span data-stu-id="2b249-266">For the Bean Trader sample, delete the old project file (BeanTraderClient.csproj) since it's no longer needed.</span></span> <span data-ttu-id="2b249-267">如果您想要保留這兩個專案檔，請務必將它們建立成不同的輸出和中繼輸出路徑。</span><span class="sxs-lookup"><span data-stu-id="2b249-267">If you prefer to keep both project files, be sure to have them build to different output and intermediate output paths.</span></span>

## <a name="fix-build-issues"></a><span data-ttu-id="2b249-268">修正組建問題</span><span class="sxs-lookup"><span data-stu-id="2b249-268">Fix build issues</span></span>

<span data-ttu-id="2b249-269">移植程式的第三個步驟是取得要建立的專案。</span><span class="sxs-lookup"><span data-stu-id="2b249-269">The third step of the porting process is getting the project to build.</span></span> <span data-ttu-id="2b249-270">專案檔轉換成 SDK 樣式的專案之後，某些應用程式就已成功建立。</span><span class="sxs-lookup"><span data-stu-id="2b249-270">Some apps will already build successfully once the project file is converted to an SDK-style project.</span></span> <span data-ttu-id="2b249-271">如果您的應用程式是這種情況，恭喜您！</span><span class="sxs-lookup"><span data-stu-id="2b249-271">If that's the case for your app, congratulations!</span></span> <span data-ttu-id="2b249-272">您可以移至步驟4。</span><span class="sxs-lookup"><span data-stu-id="2b249-272">You can go on to Step 4.</span></span> <span data-ttu-id="2b249-273">其他應用程式將需要一些更新，才能為 .NET Core 建立。</span><span class="sxs-lookup"><span data-stu-id="2b249-273">Other apps will need some updates to get them building for .NET Core.</span></span> <span data-ttu-id="2b249-274">如果您 `dotnet build` 現在嘗試在 Bean Trader 範例專案上執行，例如（或在 Visual Studio 中建立），則會有許多錯誤，但您會很快地解決問題。</span><span class="sxs-lookup"><span data-stu-id="2b249-274">If you try to run `dotnet build` on the Bean Trader sample project now, for example, (or build it in Visual Studio), there will be many errors, but you'll get them fixed quickly.</span></span>

### <a name="systemservicemodel-references-and-microsoftwindowscompatibility"></a><span data-ttu-id="2b249-275">System.servicemodel 參考和 Microsoft. Windows 相容性</span><span class="sxs-lookup"><span data-stu-id="2b249-275">System.ServiceModel references and Microsoft.Windows.Compatibility</span></span>

<span data-ttu-id="2b249-276">錯誤的常見來源缺少適用于 .NET Core 但不會自動包含在 .NET Core 應用程式中繼套件中的 Api 參考。</span><span class="sxs-lookup"><span data-stu-id="2b249-276">A common source of errors is missing references for APIs that are available for .NET Core but not automatically included in the .NET Core app metapackage.</span></span> <span data-ttu-id="2b249-277">若要解決此情況，您應該參考該 `Microsoft.Windows.Compatibility` 套件。</span><span class="sxs-lookup"><span data-stu-id="2b249-277">To address this, you should reference the `Microsoft.Windows.Compatibility` package.</span></span> <span data-ttu-id="2b249-278">相容性套件包含一組廣泛的 Api，在 Windows 桌面應用程式中很常見，例如 WCF 用戶端、目錄服務、登錄、設定、Acl Api 等等。</span><span class="sxs-lookup"><span data-stu-id="2b249-278">The compatibility package includes a broad set of APIs that are common in Windows desktop apps, such as WCF client, directory services, registry, configuration, ACLs APIs, and more.</span></span>

<span data-ttu-id="2b249-279">使用 Bean Trader 範例時，大部分的組建錯誤都是因為遺漏類型所致 <xref:System.ServiceModel> 。</span><span class="sxs-lookup"><span data-stu-id="2b249-279">With the Bean Trader sample, the majority of the build errors are due to missing <xref:System.ServiceModel> types.</span></span> <span data-ttu-id="2b249-280">藉由參考必要的 WCF NuGet 套件，即可解決這些問題。</span><span class="sxs-lookup"><span data-stu-id="2b249-280">These could be addressed by referencing the necessary WCF NuGet packages.</span></span> <span data-ttu-id="2b249-281">不過，WCF 用戶端 Api 是封裝中的應用程式開發介面 `Microsoft.Windows.Compatibility` ，因此參考相容性套件是一個更好的解決方案（因為它也能解決與 api 相關的任何問題，以及相容性套件所提供之 WCF 問題的解決方案）。</span><span class="sxs-lookup"><span data-stu-id="2b249-281">WCF client APIs are among those present in the `Microsoft.Windows.Compatibility` package, though, so referencing the compatibility package is an even better solution (since it also addresses any issues related to APIs as well as solutions to the WCF issues that the compatibility package makes available).</span></span> <span data-ttu-id="2b249-282">在 `Microsoft.Windows.Compatibility` 大部分 .Net Core 3.0 WPF 和 WinForms 移植案例中，封裝都有説明。</span><span class="sxs-lookup"><span data-stu-id="2b249-282">The `Microsoft.Windows.Compatibility` package helps in most .NET Core 3.0 WPF and WinForms porting scenarios.</span></span> <span data-ttu-id="2b249-283">將 NuGet 參考新增至之後 `Microsoft.Windows.Compatibility` ，只會保留一個組建錯誤！</span><span class="sxs-lookup"><span data-stu-id="2b249-283">After adding the NuGet reference to `Microsoft.Windows.Compatibility`, only one build error remains!</span></span>

### <a name="cleaning-up-unused-files"></a><span data-ttu-id="2b249-284">清除未使用的檔案</span><span class="sxs-lookup"><span data-stu-id="2b249-284">Cleaning up unused files</span></span>

<span data-ttu-id="2b249-285">其中一種會產生的遷移問題，通常與先前未包含在組建中的 c # 和 XAML 檔案有關，這些檔案會自動包含*所有*來源，並由新的 SDK 樣式專案所挑選。</span><span class="sxs-lookup"><span data-stu-id="2b249-285">One type of migration issue that comes up often relates to C# and XAML files that weren't previously included in the build getting picked up by the new SDK-style projects that include *all* source automatically.</span></span>

<span data-ttu-id="2b249-286">您在 Bean Trader 範例中看到的下一個組建錯誤是指*OldUnusedViewModel.cs*中的不正確介面實。</span><span class="sxs-lookup"><span data-stu-id="2b249-286">The next build error you see in the Bean Trader sample refers to a bad interface implementation in *OldUnusedViewModel.cs*.</span></span> <span data-ttu-id="2b249-287">檔案名是提示，但在檢查時，您會發現這個原始程式檔不正確。</span><span class="sxs-lookup"><span data-stu-id="2b249-287">The file name is a hint, but on inspection, you'll find that this source file is incorrect.</span></span> <span data-ttu-id="2b249-288">它不會造成先前的問題，因為它並未包含在原始的 .NET Framework 專案中。</span><span class="sxs-lookup"><span data-stu-id="2b249-288">It didn't cause issues previously because it wasn't included in the original .NET Framework project.</span></span> <span data-ttu-id="2b249-289">出現在磁片上但未包含在舊的 *.csproj*中的原始程式檔，現在會自動包含在內。</span><span class="sxs-lookup"><span data-stu-id="2b249-289">Source files that were present on disk but not included in the old *csproj* are included automatically now.</span></span>

<span data-ttu-id="2b249-290">對於這類的一次性問題，很容易就能與先前的 *.csproj*進行比較，以確認不需要該檔案， `<Compile Remove="" />` 或者，如果在任何地方不需要來源檔案，請將它刪除。</span><span class="sxs-lookup"><span data-stu-id="2b249-290">For one-off issues like this, it's easy to compare to the previous *csproj* to confirm that the file isn't needed, and then either `<Compile Remove="" />` it or, if the source file isn't needed anywhere anymore, delete it.</span></span> <span data-ttu-id="2b249-291">在此情況下，只需刪除*OldUnusedViewModel.cs*即可安全。</span><span class="sxs-lookup"><span data-stu-id="2b249-291">In this case, it's safe to just delete *OldUnusedViewModel.cs*.</span></span>

<span data-ttu-id="2b249-292">如果您有許多需要以這種方式排除的原始程式檔，您可以 `<EnableDefaultCompileItems>` 在專案檔中將屬性設定為 false，以停用自動包含 c # 檔案。</span><span class="sxs-lookup"><span data-stu-id="2b249-292">If you have many source files that would need to be excluded this way, you can disable auto-inclusion of C# files by setting the `<EnableDefaultCompileItems>` property to false in the project file.</span></span> <span data-ttu-id="2b249-293">然後，您可以將 `<Compile Include>` 舊專案檔中的專案複製到新的專案檔，以便只建立您要包含的來源。</span><span class="sxs-lookup"><span data-stu-id="2b249-293">Then, you can copy `<Compile Include>` items from the old project file to the new one in order to only build sources you intended to include.</span></span> <span data-ttu-id="2b249-294">同樣地， `<EnableDefaultPageItems>` 可以用來關閉自動包含 XAML 頁面，而且 `<EnableDefaultItems>` 可以使用單一屬性來控制兩者。</span><span class="sxs-lookup"><span data-stu-id="2b249-294">Similarly, `<EnableDefaultPageItems>` can be used to turn off auto-inclusion of XAML pages and `<EnableDefaultItems>` can control both with a single property.</span></span>

### <a name="a-brief-aside-on-multi-pass-compilers"></a><span data-ttu-id="2b249-295">多階段編譯器簡介</span><span class="sxs-lookup"><span data-stu-id="2b249-295">A brief aside on multi-pass compilers</span></span>

<span data-ttu-id="2b249-296">從 Bean Trader 範例中移除有問題的檔案之後，您可以重新建立，而且會收到四個錯誤。</span><span class="sxs-lookup"><span data-stu-id="2b249-296">After removing the offending file from the Bean Trader sample, you can re-build and will get four errors.</span></span> <span data-ttu-id="2b249-297">您之前沒有人嗎？</span><span class="sxs-lookup"><span data-stu-id="2b249-297">Didn't you have one before?</span></span> <span data-ttu-id="2b249-298">為什麼會出現錯誤數目？</span><span class="sxs-lookup"><span data-stu-id="2b249-298">Why did the number of errors go up?</span></span> <span data-ttu-id="2b249-299">C # 編譯器是[多階段編譯器](https://docs.microsoft.com/archive/blogs/ericlippert/how-many-passes)。</span><span class="sxs-lookup"><span data-stu-id="2b249-299">The C# compiler is a [multi-pass compiler](https://docs.microsoft.com/archive/blogs/ericlippert/how-many-passes).</span></span> <span data-ttu-id="2b249-300">這表示它會逐一處理每個來源檔案兩次。</span><span class="sxs-lookup"><span data-stu-id="2b249-300">This means that it goes through each source file twice.</span></span> <span data-ttu-id="2b249-301">首先，編譯器只會查看每個來源檔案中的中繼資料和宣告，並識別任何宣告層級的問題。</span><span class="sxs-lookup"><span data-stu-id="2b249-301">First, the compiler just looks at metadata and declarations in each source file and identifies any declaration-level problems.</span></span> <span data-ttu-id="2b249-302">這些是您已修正的錯誤。</span><span class="sxs-lookup"><span data-stu-id="2b249-302">Those are the errors you've fixed.</span></span> <span data-ttu-id="2b249-303">然後，它會再次流覽程式碼，將 c # 原始檔建立為 IL;這些是您現在看到的第二組錯誤。</span><span class="sxs-lookup"><span data-stu-id="2b249-303">Then it goes through the code again to build the C# source into IL; those are the second set of errors that you're seeing now.</span></span>

> [!NOTE]
> <span data-ttu-id="2b249-304">C # 編譯器不[只](https://docs.microsoft.com/archive/blogs/ericlippert/how-many-passes)會執行兩個階段，但最終結果是，大型程式碼變更的編譯器錯誤，這通常會出現在兩個波狀中。</span><span class="sxs-lookup"><span data-stu-id="2b249-304">The C# compiler does [more than just two passes](https://docs.microsoft.com/archive/blogs/ericlippert/how-many-passes), but the end result is that compiler errors for large code changes like this tend to come in two waves.</span></span>

### <a name="third-party-dependency-fixes-castlewindsor"></a><span data-ttu-id="2b249-305">協力廠商相依性修正（Castle. Windsor）</span><span class="sxs-lookup"><span data-stu-id="2b249-305">Third-party dependency fixes (Castle.Windsor)</span></span>

<span data-ttu-id="2b249-306">在某些遷移案例中出現的另一個問題，就是 .NET Framework 和 .NET Core 版本的相依性之間的 API 差異。</span><span class="sxs-lookup"><span data-stu-id="2b249-306">Another class of issue that comes up in some migration scenarios is API differences between .NET Framework and .NET Core versions of dependencies.</span></span> <span data-ttu-id="2b249-307">即使 NuGet 套件同時以 .NET Framework 和 .NET Standard 或 .NET Core 為目標，也可能有不同的程式庫可與不同的 .NET 目標搭配使用。</span><span class="sxs-lookup"><span data-stu-id="2b249-307">Even if a NuGet package targets both .NET Framework and .NET Standard or .NET Core, there may be different libraries for use with different .NET targets.</span></span> <span data-ttu-id="2b249-308">這可讓封裝支援許多不同的 .NET 平臺，這可能需要不同的執行方式。</span><span class="sxs-lookup"><span data-stu-id="2b249-308">This allows the packages to support many different .NET platforms, which may require different implementations.</span></span> <span data-ttu-id="2b249-309">這也表示以不同的 .NET 平臺為目標時，程式庫中可能會有小型的 API 差異。</span><span class="sxs-lookup"><span data-stu-id="2b249-309">It also means that there may be small API differences in the libraries when targeting different .NET platforms.</span></span>

<span data-ttu-id="2b249-310">您會在 Bean Trader 範例中看到的下一組錯誤與 api 相關 `Castle.Windsor` 。</span><span class="sxs-lookup"><span data-stu-id="2b249-310">The next set of errors you'll see in the Bean Trader sample are related to `Castle.Windsor` APIs.</span></span> <span data-ttu-id="2b249-311">.NET Core Bean Trader 專案使用與 `Castle.Windsor` .NET Framework 目標專案（4.1.1）相同的版本，但這兩個平臺的執行方式稍有不同。</span><span class="sxs-lookup"><span data-stu-id="2b249-311">The .NET Core Bean Trader project uses the same version of `Castle.Windsor` as the .NET Framework-targeted project (4.1.1), but the implementations for those two platforms are slightly different.</span></span>

<span data-ttu-id="2b249-312">在此情況下，您會看到下列需要修正的問題：</span><span class="sxs-lookup"><span data-stu-id="2b249-312">In this case, you see the following issues that need to be fixed:</span></span>

1. <span data-ttu-id="2b249-313">`Castle.MicroKernel.Registration.Classes.FromThisAssembly`無法在 .NET Core 上使用。</span><span class="sxs-lookup"><span data-stu-id="2b249-313">`Castle.MicroKernel.Registration.Classes.FromThisAssembly` isn't available on .NET Core.</span></span> <span data-ttu-id="2b249-314">不過，有類似的 API `Classes.FromAssemblyContaining` 可供使用，因此我們可以將的兩個用法取代 `Classes.FromThisAssembly()` 為的呼叫 `Classes.FromAssemblyContaining(t)` ，其中 `t` 是發出呼叫的類型。</span><span class="sxs-lookup"><span data-stu-id="2b249-314">There is, however, the similar API `Classes.FromAssemblyContaining` available, so we can replace both uses of `Classes.FromThisAssembly()` with calls to `Classes.FromAssemblyContaining(t)`, where `t` is the type making the call.</span></span>
1. <span data-ttu-id="2b249-315">同樣地，在*Bootstrapper.cs*中， `Castle.Windsor.Installer.FromAssembly` 。這無法在 .NET Core 上使用。</span><span class="sxs-lookup"><span data-stu-id="2b249-315">Similarly, in *Bootstrapper.cs*, `Castle.Windsor.Installer.FromAssembly`.This is unavailable on .NET Core.</span></span> <span data-ttu-id="2b249-316">相反地，可以使用取代該呼叫 `FromAssembly.Containing(typeof(Bootstrapper))` 。</span><span class="sxs-lookup"><span data-stu-id="2b249-316">Instead, that call can be replaced with `FromAssembly.Containing(typeof(Bootstrapper))`.</span></span>

### <a name="updating-wcf-client-usage"></a><span data-ttu-id="2b249-317">更新 WCF 用戶端使用方式</span><span class="sxs-lookup"><span data-stu-id="2b249-317">Updating WCF client usage</span></span>

<span data-ttu-id="2b249-318">修正了 `Castle.Windsor` 差異，.Net Core Bean Trader 專案中最後一個剩餘的組建錯誤是 `BeanTraderServiceClient` （衍生自 `DuplexClientBase` ）沒有 `Open` 方法。</span><span class="sxs-lookup"><span data-stu-id="2b249-318">Having fixed the `Castle.Windsor` differences, the last remaining build error in the .NET Core Bean Trader project is that `BeanTraderServiceClient` (which derives from `DuplexClientBase`) doesn't have an `Open` method.</span></span> <span data-ttu-id="2b249-319">這並不令人驚訝，因為這是在此遷移程式開始時由 .NET 可攜性分析器反白顯示的 API。</span><span class="sxs-lookup"><span data-stu-id="2b249-319">This isn't surprising since this is an API that was highlighted by the .NET Portability Analyzer at the beginning of this migration process.</span></span> <span data-ttu-id="2b249-320">`BeanTraderServiceClient`不過，查看會將我們的注意力繪製到較大的問題。</span><span class="sxs-lookup"><span data-stu-id="2b249-320">Looking at `BeanTraderServiceClient` draws our attention to a larger issue, though.</span></span> <span data-ttu-id="2b249-321">此 WCF 用戶端是由[Svcutil](../../framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md)自動產生。</span><span class="sxs-lookup"><span data-stu-id="2b249-321">This WCF client was autogenerated by the [Svcutil.exe](../../framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md) tool.</span></span>

<span data-ttu-id="2b249-322">**Svcutil 所產生的 WCF 用戶端是用於 .NET Framework 上。**</span><span class="sxs-lookup"><span data-stu-id="2b249-322">**WCF clients generated by Svcutil are meant for use on .NET Framework.**</span></span>

<span data-ttu-id="2b249-323">使用 svcutil 產生之 WCF 用戶端的解決方案，必須重新產生與 .NET Standard 相容的用戶端，以與 .NET Core 搭配使用。</span><span class="sxs-lookup"><span data-stu-id="2b249-323">Solutions that use svcutil-generated WCF clients will need to regenerate .NET Standard-compatible clients for use with .NET Core.</span></span> <span data-ttu-id="2b249-324">舊用戶端無法使用的主要原因之一，是它們相依于定義 WCF 系結和端點的應用程式設定。</span><span class="sxs-lookup"><span data-stu-id="2b249-324">One of the main reasons the old clients won't work is that they depend on app configuration for defining WCF bindings and endpoints.</span></span> <span data-ttu-id="2b249-325">由於 .NET Standard WCF Api 可跨平臺運作（其中不提供系統設定 Api），因此 .NET Core 和 .NET Standard 案例的 WCF 用戶端必須以程式設計方式（而不是在設定中）定義系結和端點。</span><span class="sxs-lookup"><span data-stu-id="2b249-325">Because .NET Standard WCF APIs can work cross-platform (where System.Configuration APIs aren't available), WCF clients for .NET Core and .NET Standard scenarios must define bindings and endpoints programmatically instead of in configuration.</span></span>

<span data-ttu-id="2b249-326">事實上，相依于 `<system.serviceModel>` app.config 區段（不論是使用 Svcutil 或手動建立）的任何 WCF 用戶端使用方式都必須變更，才能在 .Net Core 上使用。</span><span class="sxs-lookup"><span data-stu-id="2b249-326">In fact, any WCF client usage that depends on the `<system.serviceModel>` app.config section (whether created with Svcutil or manually) will need to be changed to work on .NET Core.</span></span>

<span data-ttu-id="2b249-327">有兩種方式可以自動產生 .NET Standard 相容的 WCF 用戶端：</span><span class="sxs-lookup"><span data-stu-id="2b249-327">There are two ways to automatically generate .NET Standard-compatible WCF clients:</span></span>

- <span data-ttu-id="2b249-328">此 `dotnet-svcutil` 工具是一種 .net 工具，其產生的 WCF 用戶端與 Svcutil 之前的運作方式類似。</span><span class="sxs-lookup"><span data-stu-id="2b249-328">The `dotnet-svcutil` tool is a .NET tool that generates WCF clients in a way that is similar to how Svcutil worked previously.</span></span>
- <span data-ttu-id="2b249-329">Visual Studio 可以使用其已連線的服務功能的[Wcf Web 服務參考](../../core/additional-tools/wcf-web-service-reference-guide.md)選項來產生 wcf 用戶端。</span><span class="sxs-lookup"><span data-stu-id="2b249-329">Visual Studio can generate WCF clients using the [WCF Web Service Reference](../../core/additional-tools/wcf-web-service-reference-guide.md) option of its Connected Services feature.</span></span>

<span data-ttu-id="2b249-330">這兩種方法都很好用。</span><span class="sxs-lookup"><span data-stu-id="2b249-330">Either approach works well.</span></span> <span data-ttu-id="2b249-331">當然，您也可以自行撰寫 WCF 用戶端程式代碼。</span><span class="sxs-lookup"><span data-stu-id="2b249-331">Alternatively, of course, you could write the WCF client code yourself.</span></span> <span data-ttu-id="2b249-332">在此範例中，我選擇使用 Visual Studio 連接的服務功能。</span><span class="sxs-lookup"><span data-stu-id="2b249-332">For this sample, I chose to use the Visual Studio Connected Service feature.</span></span> <span data-ttu-id="2b249-333">若要這麼做，請以滑鼠右鍵按一下 Visual Studio 的 [方案瀏覽器] 中的 [ *BeanTraderClient* ] 專案，然後選取 [**新增**  >  **已連線的服務**]。</span><span class="sxs-lookup"><span data-stu-id="2b249-333">To do that, right-click on the *BeanTraderClient.Core* project in Visual Studio's solution explorer and select **Add** > **Connected Service**.</span></span> <span data-ttu-id="2b249-334">接下來，選擇 [WCF Web 服務參考提供者]。</span><span class="sxs-lookup"><span data-stu-id="2b249-334">Next, choose the WCF Web Service Reference Provider.</span></span> <span data-ttu-id="2b249-335">這會顯示一個對話方塊，您可以在其中指定後端 Bean Trader web 服務的位址（ `localhost:8080` 如果您是在本機執行伺服器），以及產生的類型應使用的命名空間（例如**BeanTrader**）。</span><span class="sxs-lookup"><span data-stu-id="2b249-335">This will bring up a dialog where you can specify the address of the backend Bean Trader web service (`localhost:8080` if you are running the server locally) and the namespace that generated types should use (**BeanTrader.Service**, for example).</span></span>

![WCF Web 服務參考已連接服務對話方塊](./media/convert-project-from-net-framework/connected-service-dialog.png)

<span data-ttu-id="2b249-337">選取 [**完成]** 按鈕之後，會將新的已連線的服務節點加入至專案，並在該節點下加入 Reference.cs 檔案，其中包含用來存取 Bean Trader 服務的新 .NET Standard WCF 用戶端。</span><span class="sxs-lookup"><span data-stu-id="2b249-337">After you select the **Finish** button, a new Connected Services node is added to the project and a Reference.cs file is added under that node containing the new .NET Standard WCF client for accessing the Bean Trader service.</span></span> <span data-ttu-id="2b249-338">如果您查看該檔案 `GetEndpointAddress` 中的或 `GetBindingForEndpoint` 方法，您會看到現在以程式設計方式產生系結和端點（而不是透過 app config）。</span><span class="sxs-lookup"><span data-stu-id="2b249-338">If you look at the `GetEndpointAddress` or `GetBindingForEndpoint` methods in that file, you'll see that bindings and endpoints are now generated programmatically (instead of via app config).</span></span> <span data-ttu-id="2b249-339">「新增已連線的服務」功能也可能會將參考新增至專案檔中的某些 System.servicemodel 封裝，因為所有必要的 WCF 封裝都是透過 Microsoft 所包含，所以不需要這麼做。</span><span class="sxs-lookup"><span data-stu-id="2b249-339">The 'Add Connected Services' feature may also add references to some System.ServiceModel packages in the project file, which aren't needed since all necessary WCF packages are included via Microsoft.Windows.Compatibility.</span></span> <span data-ttu-id="2b249-340">檢查 .csproj 以查看是否已加入任何額外的 System.servicemodel `<PackageReference>` 專案，如果有的話，請將它們移除。</span><span class="sxs-lookup"><span data-stu-id="2b249-340">Check the csproj to see if any extra System.ServiceModel `<PackageReference>` items have been added, and if so, remove them.</span></span>

<span data-ttu-id="2b249-341">我們的專案現在有新的 WCF 用戶端類別（在*Reference.cs*中），但它仍然具有舊的（在 BeanTrader.cs 中）。</span><span class="sxs-lookup"><span data-stu-id="2b249-341">Our project has new WCF client classes now (in *Reference.cs*), but it also still has the old ones (in BeanTrader.cs).</span></span> <span data-ttu-id="2b249-342">此時有兩個選項：</span><span class="sxs-lookup"><span data-stu-id="2b249-342">There are two options at this point:</span></span>

- <span data-ttu-id="2b249-343">如果您想要能夠建立原始的 .NET Framework 專案（連同新的 .NET Core 目標），您可以使用 `<Compile Remove="BeanTrader.cs" />` .Net Core 專案的 .csproj 檔案中的專案，讓應用程式的 .NET Framework 和 .Net Core 版本使用不同的 WCF 用戶端。</span><span class="sxs-lookup"><span data-stu-id="2b249-343">If you want to be able to build the original .NET Framework project (alongside the new .NET Core-targeted one), you can use a `<Compile Remove="BeanTrader.cs" />` item in the .NET Core project's csproj file so that the .NET Framework and .NET Core versions of the app use different WCF clients.</span></span> <span data-ttu-id="2b249-344">這樣做的優點是讓現有的 .NET Framework 專案保持不變，但缺點是，在 .NET Core 案例中，使用產生的 WCF 用戶端的程式碼可能需要與 .NET Framework 專案中的略有不同，因此您可能需要使用指示詞 `#if` ，有條件地編譯一些 wcf 用戶端使用方式（例如，建立用戶端），以便在針對 .Net core 建立時，以另一種方式來工作，並在建立時進行 .NET Framework。</span><span class="sxs-lookup"><span data-stu-id="2b249-344">This has the advantage of leaving the existing .NET Framework project unchanged, but has the disadvantage that code using the generated WCF clients may need to be slightly different in the .NET Core case than it was in the .NET Framework project, so you'll likely need to use `#if` directives to conditionally compile some WCF client usage (creating clients, for example) to work one way when built for .NET Core and another way when built for .NET Framework.</span></span>

- <span data-ttu-id="2b249-345">另一方面，如果現有 .NET Framework 專案中的某些程式碼變換是可接受的，您就可以將*BeanTrader.cs*全部移除。</span><span class="sxs-lookup"><span data-stu-id="2b249-345">If, on the other hand, some code churn in the existing .NET Framework project is acceptable, you can remove *BeanTrader.cs* all together.</span></span> <span data-ttu-id="2b249-346">由於新的 WCF 用戶端是針對 .NET Standard 所建立，因此可在 .NET Core 和 .NET Framework 案例中使用。</span><span class="sxs-lookup"><span data-stu-id="2b249-346">Because the new WCF client is built for .NET Standard, it will work in both .NET Core and .NET Framework scenarios.</span></span> <span data-ttu-id="2b249-347">如果您要建立的是除了 .NET Core 以外的 .NET Framework （由多目標或有兩個 .csproj 檔案），您可以針對這兩個目標使用這個新的*Reference.cs*檔案。</span><span class="sxs-lookup"><span data-stu-id="2b249-347">If you are building for .NET Framework in addition to .NET Core (either by multi-targeting or by having two csproj files), you can use this new *Reference.cs* file for both targets.</span></span> <span data-ttu-id="2b249-348">這種方法的優點是，程式碼不需要 bifurcate 以支援兩個不同的 WCF 用戶端;所有地方都會使用相同的程式碼。</span><span class="sxs-lookup"><span data-stu-id="2b249-348">This approach has the advantage that the code won't need to bifurcate to support two different WCF clients; the same code will be used everywhere.</span></span> <span data-ttu-id="2b249-349">缺點是，它牽涉到變更（可能是穩定的） .NET Framework 專案。</span><span class="sxs-lookup"><span data-stu-id="2b249-349">The drawback is that it involves changing the (presumably stable) .NET Framework project.</span></span>

<span data-ttu-id="2b249-350">在 Bean Trader 範例的案例中，您可以對原始專案進行較小的變更，讓您更輕鬆地進行遷移，因此請遵循下列步驟來協調 WCF 用戶端的使用方式：</span><span class="sxs-lookup"><span data-stu-id="2b249-350">In the case of the Bean Trader sample, you can make small changes to the original project if it makes migration easier, so follow these steps to reconcile WCF client usage:</span></span>

01. <span data-ttu-id="2b249-351">使用 [方案瀏覽器] 中的 [加入現有專案] 操作功能表，將新的 Reference.cs 檔案加入至 .NET Framework *BeanTraderClient. .csproj*專案。</span><span class="sxs-lookup"><span data-stu-id="2b249-351">Add the new Reference.cs file to the .NET Framework *BeanTraderClient.csproj* project using the 'Add existing item' context menu from the solution explorer.</span></span> <span data-ttu-id="2b249-352">請務必加入 ' as link '，讓這兩個專案都使用相同的檔案（相對於複製 c # 檔案）。</span><span class="sxs-lookup"><span data-stu-id="2b249-352">Be sure to add 'as link' so that the same file is used by both projects (as opposed to copying the C# file).</span></span> <span data-ttu-id="2b249-353">如果您使用單一 .csproj 同時建立 .NET Core 和 .NET Framework （使用多目標），則不需要執行此步驟。</span><span class="sxs-lookup"><span data-stu-id="2b249-353">If you are building for both .NET Core and .NET Framework with a single csproj (using multi-targeting) then this step isn't necessary.</span></span>

01. <span data-ttu-id="2b249-354">刪除*BeanTrader.cs*。</span><span class="sxs-lookup"><span data-stu-id="2b249-354">Delete *BeanTrader.cs*.</span></span>

01. <span data-ttu-id="2b249-355">新的 WCF 用戶端與舊版類似，但產生的程式碼中有數個命名空間不同。</span><span class="sxs-lookup"><span data-stu-id="2b249-355">The new WCF client is similar to the old one, but a number of namespaces in the generated code are different.</span></span> <span data-ttu-id="2b249-356">因此，您必須更新專案，以便從 BeanTrader （或您選擇的任何命名空間名稱）使用 WCF 用戶端類型，而不是 BeanTrader 或沒有命名空間。</span><span class="sxs-lookup"><span data-stu-id="2b249-356">Because of this, it is necessary to update the project so that WCF client types are used from BeanTrader.Service (or whatever namespace name you chose) instead of BeanTrader.Model or without a namespace.</span></span> <span data-ttu-id="2b249-357">建立*BeanTraderClient*有助於識別需要進行這些變更的位置。</span><span class="sxs-lookup"><span data-stu-id="2b249-357">Building *BeanTraderClient.Core.csproj* will help to identify where these changes need to be made.</span></span> <span data-ttu-id="2b249-358">C # 和 XAML 原始程式檔都需要修正。</span><span class="sxs-lookup"><span data-stu-id="2b249-358">Fixes will be needed both in C# and in XAML source files.</span></span>

01. <span data-ttu-id="2b249-359">最後，您會發現*BeanTraderServiceClientFactory.cs*中發生錯誤，因為類型的可用的函式 `BeanTraderServiceClient` 已變更。</span><span class="sxs-lookup"><span data-stu-id="2b249-359">Finally, you'll discover that there is an error in *BeanTraderServiceClientFactory.cs* because the available constructors for the `BeanTraderServiceClient` type have changed.</span></span> <span data-ttu-id="2b249-360">它可用來提供 `InstanceContext` 引數（使用 `CallbackHandler` 來自 IoC 容器的來建立 `Castle.Windsor` ）。</span><span class="sxs-lookup"><span data-stu-id="2b249-360">It used to be possible to supply an `InstanceContext` argument (which was created using a `CallbackHandler` from the `Castle.Windsor` IoC container).</span></span> <span data-ttu-id="2b249-361">新的函式會建立新的 `CallbackHandler` 。</span><span class="sxs-lookup"><span data-stu-id="2b249-361">The new constructors create new `CallbackHandler`s.</span></span> <span data-ttu-id="2b249-362">不過，在 `BeanTraderServiceClient` 的基底型別中，會符合您想要的函式。</span><span class="sxs-lookup"><span data-stu-id="2b249-362">There are, however, constructors in `BeanTraderServiceClient`'s base type that match what you want.</span></span> <span data-ttu-id="2b249-363">因為自動產生的 WCF 用戶端程式代碼都存在於部分類別中，所以您可以輕鬆地將它擴充。</span><span class="sxs-lookup"><span data-stu-id="2b249-363">Since the autogenerated WCF client code all exists in partial classes, you can easily extend it.</span></span> <span data-ttu-id="2b249-364">若要這麼做，請建立名為*BeanTraderServiceClient.cs*的新檔案，然後建立具有該相同名稱的部分類別（使用 BeanTrader 命名空間）。</span><span class="sxs-lookup"><span data-stu-id="2b249-364">To do this, create a new file called *BeanTraderServiceClient.cs* and then create a partial class with that same name (using the BeanTrader.Service namespace).</span></span> <span data-ttu-id="2b249-365">然後，將一個函式加入至部分型別，如下所示。</span><span class="sxs-lookup"><span data-stu-id="2b249-365">Then, add one constructor to the partial type as shown here.</span></span>

    ```csharp
    public BeanTraderServiceClient(System.ServiceModel.InstanceContext callbackInstance) :
        base(callbackInstance, EndpointConfiguration.NetTcpBinding_BeanTraderService)
            { }
    ```

<span data-ttu-id="2b249-366">進行這些變更之後，Bean Trader 範例現在會使用新的 .NET Standard 相容 WCF 用戶端，而您可以在 `Open` *TradingService.cs*中變更呼叫以改用 `await OpenAsync` 。</span><span class="sxs-lookup"><span data-stu-id="2b249-366">With those changes made, the Bean Trader sample will now be using a new .NET Standard-compatible WCF client and you can make the final fix of changing the `Open` call in *TradingService.cs* to use `await OpenAsync` instead.</span></span>

<span data-ttu-id="2b249-367">在解決 WCF 問題的情況下，現在就能完全建立 .NET Core 版本的 Bean Trader 範例！</span><span class="sxs-lookup"><span data-stu-id="2b249-367">With the WCF issues addressed, the .NET Core version of the Bean Trader sample now builds cleanly!</span></span>

## <a name="runtime-testing"></a><span data-ttu-id="2b249-368">執行時間測試</span><span class="sxs-lookup"><span data-stu-id="2b249-368">Runtime testing</span></span>

<span data-ttu-id="2b249-369">只要專案完全針對 .NET Core 建立，就不會忘記遷移工作的完成。</span><span class="sxs-lookup"><span data-stu-id="2b249-369">It's easy to forget that migration work isn't done as soon as the project builds cleanly against .NET Core.</span></span> <span data-ttu-id="2b249-370">請務必保留測試已移植應用程式的時間。</span><span class="sxs-lookup"><span data-stu-id="2b249-370">It's important to leave time for testing the ported app, too.</span></span> <span data-ttu-id="2b249-371">成功建立專案之後，請確定應用程式執行並如預期般運作，特別是當您使用任何以 .NET Framework 為目標的套件時。</span><span class="sxs-lookup"><span data-stu-id="2b249-371">Once things build successfully, make sure the app runs and works as expected, especially if you are using any packages targeting .NET Framework.</span></span>

<span data-ttu-id="2b249-372">讓我們嘗試啟動已移植的 Bean Trader 應用程式，並瞭解會發生什麼事。</span><span class="sxs-lookup"><span data-stu-id="2b249-372">Let's try launching the ported Bean Trader app and see what happens.</span></span> <span data-ttu-id="2b249-373">應用程式在失敗前不會遇到下列例外狀況。</span><span class="sxs-lookup"><span data-stu-id="2b249-373">The app doesn't get far before failing with the following exception.</span></span>

```output
System.Configuration.ConfigurationErrorsException: 'Configuration system failed to initialize'

Inner Exception
ConfigurationErrorsException: Unrecognized configuration section system.serviceModel.
```

<span data-ttu-id="2b249-374">當然，這就是合理的。</span><span class="sxs-lookup"><span data-stu-id="2b249-374">This makes sense, of course.</span></span> <span data-ttu-id="2b249-375">請記住，WCF 不再使用應用程式設定，因此必須移除 app.config 檔案的舊 System.servicemodel 區段。</span><span class="sxs-lookup"><span data-stu-id="2b249-375">Remember that WCF no longer uses app configuration, so the old system.serviceModel section of the app.config file needs to be removed.</span></span> <span data-ttu-id="2b249-376">更新的 WCF 用戶端會在其程式碼中包含所有相同的資訊，因此不再需要 config 區段。</span><span class="sxs-lookup"><span data-stu-id="2b249-376">The updated WCF client includes all of the same information in its code, so the config section isn't needed anymore.</span></span> <span data-ttu-id="2b249-377">如果您想要在 app.config 中設定 WCF 端點，您可以將它新增為應用程式設定，並更新 WCF 用戶端程式代碼，以從設定中取出 WCF 服務端點。</span><span class="sxs-lookup"><span data-stu-id="2b249-377">If you wanted the WCF endpoint to be configurable in app.config, you could add it as an app setting and update the WCF client code to retrieve the WCF service endpoint from configuration.</span></span>

<span data-ttu-id="2b249-378">移除*app.config*的 system.servicemodel 區段之後，應用程式會啟動，但在使用者登入時發生另一個例外狀況。</span><span class="sxs-lookup"><span data-stu-id="2b249-378">After removing the system.serviceModel section of *app.config*, the app launches but fails with another exception when a user signs in.</span></span>

```output
System.PlatformNotSupportedException: 'Operation is not supported on this platform.'
```

<span data-ttu-id="2b249-379">不支援的 API 是 `Func<T>.BeginInvoke` 。</span><span class="sxs-lookup"><span data-stu-id="2b249-379">The unsupported API is `Func<T>.BeginInvoke`.</span></span> <span data-ttu-id="2b249-380">如[dotnet/corefx # 5940](https://github.com/dotnet/corefx/issues/5940)中所述，.net Core 不支援 `BeginInvoke` `EndInvoke` 委派類型上的和方法，因為基礎遠端相依性的關係。</span><span class="sxs-lookup"><span data-stu-id="2b249-380">As explained in [dotnet/corefx#5940](https://github.com/dotnet/corefx/issues/5940), .NET Core doesn't support the `BeginInvoke` and `EndInvoke` methods on delegate types due to underlying remoting dependencies.</span></span> <span data-ttu-id="2b249-381">此問題及其修正程式會在遷移委派中更詳細地說明[。 BeginInvoke 呼叫 .Net Core 的](https://devblogs.microsoft.com/dotnet/migrating-delegate-begininvoke-calls-for-net-core/)blog 文章，但 gist 是， `BeginInvoke` 而 `EndInvoke` 呼叫應取代為 `Task.Run` （或非同步替代專案，如果可能的話）。</span><span class="sxs-lookup"><span data-stu-id="2b249-381">This issue and its fix are explained in more detail in the [Migrating Delegate.BeginInvoke Calls for .NET Core](https://devblogs.microsoft.com/dotnet/migrating-delegate-begininvoke-calls-for-net-core/) blog post, but the gist is that `BeginInvoke` and `EndInvoke` calls should be replaced with `Task.Run` (or async alternatives, if possible).</span></span> <span data-ttu-id="2b249-382">在此套用一般解決方案， `BeginInvoke` 可以使用由啟動的呼叫來取代呼叫 `Invoke` `Task.Run` 。</span><span class="sxs-lookup"><span data-stu-id="2b249-382">Applying the general solution here, the `BeginInvoke` call can be replaced with an `Invoke` call launched by `Task.Run`.</span></span>

```csharp
Task.Run(() =>
{
    return userInfoRetriever.Invoke();
}).ContinueWith(result =>
{
    // BeginInvoke's callback is replaced with ContinueWith
    var task = result.ConfigureAwait(false);
    CurrentTrader = task.GetAwaiter().GetResult();
}, TaskScheduler.Default);
```

<span data-ttu-id="2b249-383">移除使用量之後 `BeginInvoke` ，Bean Trader 應用程式會在 .Net Core 上成功執行！</span><span class="sxs-lookup"><span data-stu-id="2b249-383">After removing the `BeginInvoke` usage, the Bean Trader app runs successfully on .NET Core!</span></span>

![在 .NET Core 上執行的 Bean Trader](./media/convert-project-from-net-framework/running-on-core.png)

<span data-ttu-id="2b249-385">所有應用程式都不同，因此將您自己的應用程式遷移至 .NET Core 所需的特定步驟會有所不同。</span><span class="sxs-lookup"><span data-stu-id="2b249-385">All apps are different, so the specific steps needed to migrate your own apps to .NET Core will vary.</span></span> <span data-ttu-id="2b249-386">但希望 Bean Trader 範例會示範一般工作流程，以及可預期的問題類型。</span><span class="sxs-lookup"><span data-stu-id="2b249-386">But hopefully the Bean Trader sample demonstrates the general workflow and the types of issues that can be expected.</span></span> <span data-ttu-id="2b249-387">而且雖然這篇文章的長度，但在 Trader 範例中，為了讓它能夠在 .NET Core 上工作，所需的實際變更相當有限。</span><span class="sxs-lookup"><span data-stu-id="2b249-387">And, despite this article's length, the actual changes needed in the Bean Trader sample to make it work on .NET Core were fairly limited.</span></span> <span data-ttu-id="2b249-388">許多應用程式都會以同樣的方式遷移至 .NET Core;但不需要變更程式碼。</span><span class="sxs-lookup"><span data-stu-id="2b249-388">Many apps migrate to .NET Core in this same way; with limited or even no code changes needed.</span></span>
