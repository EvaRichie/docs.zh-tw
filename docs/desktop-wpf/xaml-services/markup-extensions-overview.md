---
title: XAML 標記延伸概觀
ms.date: 03/30/2017
helpviewer_keywords:
- markup extensions [XAML Services], custom
- XAML [XAML Services], markup extensions
ms.assetid: 261b2b11-2dc0-462f-8c66-55b8c9c6e436
ms.openlocfilehash: efb41f31a3baa895b5739021af5fa36e32aefeea
ms.sourcegitcommit: 27a15a55019f6b5f2733961738babe94aec0def3
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 09/15/2020
ms.locfileid: "90556989"
---
# <a name="overview-of-markup-extensions-for-xaml"></a><span data-ttu-id="e65bf-102">XAML 標記延伸的總覽</span><span class="sxs-lookup"><span data-stu-id="e65bf-102">Overview of markup extensions for XAML</span></span>

<span data-ttu-id="e65bf-103">標記延伸是一種 XAML 技巧，可取得不是基本或特定 XAML 類型的值。</span><span class="sxs-lookup"><span data-stu-id="e65bf-103">Markup extensions are a XAML technique for obtaining a value that's not a primitive or a specific XAML type.</span></span> <span data-ttu-id="e65bf-104">對於屬性使用方式，標記延伸使用左大括號 `{` 的已知字元序列進入標記延伸範圍，並使用右大括號 `}` 結束。</span><span class="sxs-lookup"><span data-stu-id="e65bf-104">For attribute usage, markup extensions use the known character sequence of an opening curly brace `{` to enter the markup extension scope, and a closing curly brace `}` to exit.</span></span> <span data-ttu-id="e65bf-105">使用 .NET XAML 服務時，您可以使用來自 system.string 元件的部分預先定義 XAML 語言標記延伸。</span><span class="sxs-lookup"><span data-stu-id="e65bf-105">When using .NET XAML Services, you can use some of the predefined XAML language markup extensions from the System.Xaml assembly.</span></span> <span data-ttu-id="e65bf-106">您也可以從 <xref:System.Windows.Markup.MarkupExtension> 類別產生子類別 (定義於 System.Xaml 中)，以及定義您自己的標記延伸。</span><span class="sxs-lookup"><span data-stu-id="e65bf-106">You can also subclass from the <xref:System.Windows.Markup.MarkupExtension> class, defined in System.Xaml, and define your own markup extensions.</span></span> <span data-ttu-id="e65bf-107">或者，如果您已參考該架構，您可以使用特定架構所定義的標記延伸。</span><span class="sxs-lookup"><span data-stu-id="e65bf-107">Or you can use markup extensions defined by a particular framework if you are already referencing that framework.</span></span>

<span data-ttu-id="e65bf-108">存取標記延伸使用方式時，XAML 物件寫入器可以透過 <xref:System.Windows.Markup.MarkupExtension> 覆寫中的服務連接點，將服務提供給自訂 <xref:System.Windows.Markup.MarkupExtension.ProvideValue%2A?displayProperty=nameWithType> 類別。</span><span class="sxs-lookup"><span data-stu-id="e65bf-108">When a markup extension usage is accessed, the XAML object writer can provide services to a custom <xref:System.Windows.Markup.MarkupExtension> class through a service connection point in the <xref:System.Windows.Markup.MarkupExtension.ProvideValue%2A?displayProperty=nameWithType> override.</span></span> <span data-ttu-id="e65bf-109">服務可以用來取得有關使用方式、物件寫入器之特定功能、XAML 結構描述內容等的內容。</span><span class="sxs-lookup"><span data-stu-id="e65bf-109">The services can be used to obtain context about the usage, specific capabilities of the object writer, XAML schema context, and so on.</span></span>

## <a name="xaml-defined-markup-extensions"></a><span data-ttu-id="e65bf-110">XAML 定義標記延伸</span><span class="sxs-lookup"><span data-stu-id="e65bf-110">XAML-defined markup extensions</span></span>

<span data-ttu-id="e65bf-111">.NET XAML 服務會針對 XAML 語言支援來執行數個標記延伸。</span><span class="sxs-lookup"><span data-stu-id="e65bf-111">Several markup extensions are implemented by .NET XAML Services for XAML language support.</span></span> <span data-ttu-id="e65bf-112">這些標記延伸對應至 XAML 規格的各部分，做為語言。</span><span class="sxs-lookup"><span data-stu-id="e65bf-112">These markup extensions correspond to parts of the specification of XAML as a language.</span></span> <span data-ttu-id="e65bf-113">這些通常可透過常見使用方式中所見語法的 `x:` 前置詞予以識別。</span><span class="sxs-lookup"><span data-stu-id="e65bf-113">These are typically identifiable by the `x:` prefix in the syntax as seen in common usage.</span></span> <span data-ttu-id="e65bf-114">這些 XAML 語言專案的 .NET XAML 服務實現全都衍生自  <xref:System.Windows.Markup.MarkupExtension> 基類。</span><span class="sxs-lookup"><span data-stu-id="e65bf-114">.NET XAML Services implementations for these XAML language elements all derive from the  <xref:System.Windows.Markup.MarkupExtension> base class.</span></span>

> [!NOTE]
> <span data-ttu-id="e65bf-115">`x:` 前置詞用於 XAML 生產的根項目中 XAML 語言命名空間的一般 XAML 命名空間對應。</span><span class="sxs-lookup"><span data-stu-id="e65bf-115">The `x:` prefix is used for the typical XAML namespace mapping of the XAML language namespace, in the root element of a XAML production.</span></span> <span data-ttu-id="e65bf-116">例如，各種特定架構的 Visual Studio 專案和頁面範本，會使用此對應來起始 XAML 檔案 `x:` 。</span><span class="sxs-lookup"><span data-stu-id="e65bf-116">For example, the Visual Studio project and page templates for various specific frameworks initiate a XAML file using this `x:` mapping.</span></span> <span data-ttu-id="e65bf-117">您可以選擇專屬 XAML 命名空間對應中的不同前置詞語彙基元，但是這份文件將假設使用預設 `x:` 對應來識別這些是 XAML 語言 XAML 命名空間之定義部分的實體，而非特定 Framework 的預設 XAML 命名空間或其他任意 CLR 或 XML 命名空間。</span><span class="sxs-lookup"><span data-stu-id="e65bf-117">You could choose a different prefix token in your own XAML namespace mapping, but this documentation will assume the default `x:` mapping as a means of identifying those entities that are a defined part of the XAML language XAML namespace, as opposed to a specific framework's default XAML namespace or other arbitrary CLR or XML namespaces.</span></span>

### <a name="xtype"></a><span data-ttu-id="e65bf-118">x:Type</span><span class="sxs-lookup"><span data-stu-id="e65bf-118">x:Type</span></span>

<span data-ttu-id="e65bf-119">`x:Type` 提供具名類型的 <xref:System.Type> 物件。</span><span class="sxs-lookup"><span data-stu-id="e65bf-119">`x:Type` supplies the <xref:System.Type> object for the named type.</span></span> <span data-ttu-id="e65bf-120">這項功能最常用於延遲機制，而延遲機制使用基礎 CLR 類型和類型衍生做為群組 Moniker 或識別碼。</span><span class="sxs-lookup"><span data-stu-id="e65bf-120">This functionality is used most frequently in deferral mechanisms that use underlying CLR type and type derivation as a grouping moniker or identifier.</span></span> <span data-ttu-id="e65bf-121">WPF 樣式和樣板 (以及其 `TargetType` 屬性使用方式) 是特定範例。</span><span class="sxs-lookup"><span data-stu-id="e65bf-121">WPF styles and templates, and their usage of `TargetType` properties, are a specific example.</span></span> <span data-ttu-id="e65bf-122">如需詳細資訊，請參閱 [x:Type Markup Extension](xtype-markup-extension.md)。</span><span class="sxs-lookup"><span data-stu-id="e65bf-122">For more information, see [x:Type Markup Extension](xtype-markup-extension.md).</span></span>

### <a name="xstatic"></a><span data-ttu-id="e65bf-123">x:Static</span><span class="sxs-lookup"><span data-stu-id="e65bf-123">x:Static</span></span>

<span data-ttu-id="e65bf-124">`x:Static` 會從實值類型程式碼實體 (非直接是屬性值的類型) 產生靜態值，但可評估為該類型。</span><span class="sxs-lookup"><span data-stu-id="e65bf-124">`x:Static` produces static values from value-type code entities that are not directly the type of a property's value, but can be evaluated to that type.</span></span> <span data-ttu-id="e65bf-125">這適用於指定已存在做為類型定義中已知常數的值。</span><span class="sxs-lookup"><span data-stu-id="e65bf-125">This is useful for specifying values that already exist as well-known constants in a type definition.</span></span> <span data-ttu-id="e65bf-126">如需詳細資訊，請參閱 [x:Static Markup Extension](xstatic-markup-extension.md)。</span><span class="sxs-lookup"><span data-stu-id="e65bf-126">For more information, see [x:Static Markup Extension](xstatic-markup-extension.md).</span></span>

### <a name="xnull"></a><span data-ttu-id="e65bf-127">x:Null</span><span class="sxs-lookup"><span data-stu-id="e65bf-127">x:Null</span></span>

<span data-ttu-id="e65bf-128">`x:Null` 指定 `null` 做為 XAML 成員的值。</span><span class="sxs-lookup"><span data-stu-id="e65bf-128">`x:Null` specifies `null` as a value for a XAML member.</span></span> <span data-ttu-id="e65bf-129">根據特定類型的設計或更大的架構概念， `null` 不一定是屬性的預設值或空字串屬性的隱含值。</span><span class="sxs-lookup"><span data-stu-id="e65bf-129">Depending on the design of specific types or on larger framework concepts, `null` is not always a default value for a property, or the implied value of an empty string attribute.</span></span> <span data-ttu-id="e65bf-130">如需詳細資訊，請參閱 [x:Null Markup Extension](xnull-markup-extension.md)。</span><span class="sxs-lookup"><span data-stu-id="e65bf-130">For more information, see [x:Null Markup Extension](xnull-markup-extension.md).</span></span>

### <a name="xarray"></a><span data-ttu-id="e65bf-131">x:Array</span><span class="sxs-lookup"><span data-stu-id="e65bf-131">x:Array</span></span>

<span data-ttu-id="e65bf-132">如果故意不使用基底項目和控制模型所提供的集合支援，則`x:Array` 支援使用 XAML 語法建立一般陣列。</span><span class="sxs-lookup"><span data-stu-id="e65bf-132">`x:Array` supports creation of general arrays in XAML syntax in cases where the collection support that is provided by base elements and control models is deliberately not used.</span></span> <span data-ttu-id="e65bf-133">如需詳細資訊，請參閱 [x:Array Markup Extension](xarray-markup-extension.md)。</span><span class="sxs-lookup"><span data-stu-id="e65bf-133">For more information, see [x:Array Markup Extension](xarray-markup-extension.md).</span></span> <span data-ttu-id="e65bf-134">具體來說，在 XAML 2009 中，陣列會存取為語言基本類型，而不是延伸。</span><span class="sxs-lookup"><span data-stu-id="e65bf-134">In XAML 2009 specifically, arrays are accessed as language primitives instead of as an extension.</span></span> <span data-ttu-id="e65bf-135">如需詳細資訊，請參閱 [XAML 2009 Language Features](xaml-2009-language-features.md)。</span><span class="sxs-lookup"><span data-stu-id="e65bf-135">For more information, see [XAML 2009 Language Features](xaml-2009-language-features.md).</span></span>

### <a name="xreference"></a><span data-ttu-id="e65bf-136">x:Reference</span><span class="sxs-lookup"><span data-stu-id="e65bf-136">x:Reference</span></span>

<span data-ttu-id="e65bf-137">`x:Reference` 是 XAML 2009 的一部分 (原始 (2006) 語言集的延伸模組)。</span><span class="sxs-lookup"><span data-stu-id="e65bf-137">`x:Reference` is part of XAML 2009, an extension of the original (2006) language set.</span></span> <span data-ttu-id="e65bf-138">`x:Reference` 代表物件圖形中另一個現有物件的參考。</span><span class="sxs-lookup"><span data-stu-id="e65bf-138">`x:Reference` represents a reference to another existing object in an object graph.</span></span> <span data-ttu-id="e65bf-139">該物件是透過其 `x:Name`進行識別。</span><span class="sxs-lookup"><span data-stu-id="e65bf-139">That object is identified by its `x:Name`.</span></span> <span data-ttu-id="e65bf-140">如需詳細資訊，請參閱 [x:Reference Markup Extension](xreference-markup-extension.md)。</span><span class="sxs-lookup"><span data-stu-id="e65bf-140">For more information, see [x:Reference Markup Extension](xreference-markup-extension.md).</span></span>

### <a name="other-x-constructs"></a><span data-ttu-id="e65bf-141">其他 x: 建構</span><span class="sxs-lookup"><span data-stu-id="e65bf-141">Other x: Constructs</span></span>

<span data-ttu-id="e65bf-142">具有支援 XAML 語言功能的其他 `x:` 建構，但這些不會實作為標記延伸。</span><span class="sxs-lookup"><span data-stu-id="e65bf-142">Other `x:` constructs to support XAML language features exist, but these are not implemented as markup extensions.</span></span> <span data-ttu-id="e65bf-143">如需詳細資訊，請參閱 [XAML Namespace (x:) Language Features](namespace-language-features.md)。</span><span class="sxs-lookup"><span data-stu-id="e65bf-143">For more information, see [XAML Namespace (x:) Language Features](namespace-language-features.md).</span></span>

## <a name="the-markupextension-base-class"></a><span data-ttu-id="e65bf-144">MarkupExtension 基底類別</span><span class="sxs-lookup"><span data-stu-id="e65bf-144">The MarkupExtension Base Class</span></span>

<span data-ttu-id="e65bf-145">若要定義自訂標記延伸模組，以與 System.Xaml 中的預設 XAML 讀取器和 XAML 寫入器實作互動，請從抽象 <xref:System.Windows.Markup.MarkupExtension> 類別衍生類別。</span><span class="sxs-lookup"><span data-stu-id="e65bf-145">To define a custom markup extension that can interact with the default implementations of XAML readers and XAML writers in System.Xaml, you derive a class from the abstract <xref:System.Windows.Markup.MarkupExtension> class.</span></span> <span data-ttu-id="e65bf-146">該類別有一個覆寫的方法 (即 <xref:System.Windows.Markup.MarkupExtension.ProvideValue%2A>)。</span><span class="sxs-lookup"><span data-stu-id="e65bf-146">That class has one method to override, which is <xref:System.Windows.Markup.MarkupExtension.ProvideValue%2A>.</span></span> <span data-ttu-id="e65bf-147">您可能也需要定義其他建構函式來支援標記延伸使用方式的引數，以及相符的可設定屬性。</span><span class="sxs-lookup"><span data-stu-id="e65bf-147">You might also need to define additional constructors to support arguments to the markup extension usage, and matching settable properties.</span></span>

<span data-ttu-id="e65bf-148">透過 <xref:System.Windows.Markup.MarkupExtension.ProvideValue%2A> ，自訂標記延伸可以存取服務內容，此內容會報告 XAML 處理器叫用標記延伸的環境。</span><span class="sxs-lookup"><span data-stu-id="e65bf-148">Through <xref:System.Windows.Markup.MarkupExtension.ProvideValue%2A>, a custom markup extension has access to a service context that reports the environment where the markup extension is invoked by a XAML processor.</span></span> <span data-ttu-id="e65bf-149">在載入路徑中，這通常是 <xref:System.Xaml.XamlObjectWriter> 。</span><span class="sxs-lookup"><span data-stu-id="e65bf-149">In the load path, this is typically a <xref:System.Xaml.XamlObjectWriter>.</span></span> <span data-ttu-id="e65bf-150">在儲存路徑中，這通常是 <xref:System.Xaml.XamlXmlWriter>。</span><span class="sxs-lookup"><span data-stu-id="e65bf-150">In the save path this is typically a <xref:System.Xaml.XamlXmlWriter>.</span></span> <span data-ttu-id="e65bf-151">每個都會將服務內容報告為內部 XAML 服務提供者內容類別，以實作服務提供者模式。</span><span class="sxs-lookup"><span data-stu-id="e65bf-151">Each report the service context as an internal XAML service provider context class that implements a service provider pattern.</span></span> <span data-ttu-id="e65bf-152">如需可用服務和其代表項目的詳細資訊，請參閱 [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions.md)。</span><span class="sxs-lookup"><span data-stu-id="e65bf-152">For more information about the available services and what they represent, see [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions.md).</span></span>

<span data-ttu-id="e65bf-153">您的標記延伸類別必須使用公用存取層級；XAML 處理器必須一律可以具現化標記延伸的支援類別，才能使用其服務。</span><span class="sxs-lookup"><span data-stu-id="e65bf-153">Your markup extension class must use a public access level; XAML processors must always be able to instantiate the markup extension's support class in order to use its services.</span></span>

## <a name="defining-the-support-type-for-a-custom-markup-extension"></a><span data-ttu-id="e65bf-154">定義自訂標記延伸的支援類型</span><span class="sxs-lookup"><span data-stu-id="e65bf-154">Defining the Support Type for a Custom Markup Extension</span></span>

<span data-ttu-id="e65bf-155">當您使用 .NET XAML 服務或以 .NET XAML 服務為建立的架構時，您有兩種方式可以選擇如何命名標記延伸支援類型。</span><span class="sxs-lookup"><span data-stu-id="e65bf-155">When you use .NET XAML Services or frameworks that build on .NET XAML Services, you have two choices for how to name the markup extension support type.</span></span> <span data-ttu-id="e65bf-156">類型名稱是與下列方式有關：XAML 物件寫入器在 XAML 中發現標記延伸使用方式時，嘗試存取和叫用標記延伸支援類型的方式。</span><span class="sxs-lookup"><span data-stu-id="e65bf-156">The type name is relevant to how XAML object writers attempt to access and invoke a markup extension support type when they encounter a markup extension usage in XAML.</span></span> <span data-ttu-id="e65bf-157">使用下列其中一種命名策略：</span><span class="sxs-lookup"><span data-stu-id="e65bf-157">Use one of the following naming strategies:</span></span>

- <span data-ttu-id="e65bf-158">將類型名稱命名為與 XAML 標記使用方式語彙基元完全相符的名稱。</span><span class="sxs-lookup"><span data-stu-id="e65bf-158">Name the type name to be an exact match to the XAML markup usage token.</span></span> <span data-ttu-id="e65bf-159">例如，若要支援 `{Collate ...}` 延伸使用方式，請將支援類型命名為 `Collate`。</span><span class="sxs-lookup"><span data-stu-id="e65bf-159">For example, to support a `{Collate ...}` extension usage, name the support type `Collate`.</span></span>
- <span data-ttu-id="e65bf-160">將類型名稱命名為使用方式字串語彙基元加上後置詞 `Extension`。</span><span class="sxs-lookup"><span data-stu-id="e65bf-160">Name the type name to be the usage string token plus the suffix `Extension`.</span></span> <span data-ttu-id="e65bf-161">例如，若要支援 `{Collate ...}` 延伸使用方式，請將支援類型命名為 `CollateExtension`。</span><span class="sxs-lookup"><span data-stu-id="e65bf-161">For example, to support a `{Collate ...}` extension usage, name the support type `CollateExtension`.</span></span>

<span data-ttu-id="e65bf-162">查閱順序是先尋找後面加上 `Extension`的類別名稱，然後尋找沒有 `Extension` 後置詞的類別名稱。</span><span class="sxs-lookup"><span data-stu-id="e65bf-162">The order of lookup is to look for the `Extension`-suffixed class name first and then look for the class name without the `Extension` suffix.</span></span>

<span data-ttu-id="e65bf-163">從標記使用方式觀點來看，將 `Extension` 後置詞包括為使用方式的一部分是有效的。</span><span class="sxs-lookup"><span data-stu-id="e65bf-163">From the markup usage perspective, including the `Extension` suffix as part of the usage is valid.</span></span> <span data-ttu-id="e65bf-164">不過，其行為就像 `Extension` 是類別名稱的真正部分，如果支援類別沒有 `Extension` 後置詞，則 XAML 物件寫入器無法解析這種使用方式的標記延伸支援類別。</span><span class="sxs-lookup"><span data-stu-id="e65bf-164">However, this behaves as if `Extension` is truly part of the class name, and XAML object writers would fail to resolve a markup extension support class for that usage if the support class did not have the `Extension` suffix.</span></span>

### <a name="the-parameterless-constructor"></a><span data-ttu-id="e65bf-165">無參數的函式</span><span class="sxs-lookup"><span data-stu-id="e65bf-165">The parameterless constructor</span></span>

<span data-ttu-id="e65bf-166">針對所有標記延伸支援類型，您應該公開公用無參數的函式。</span><span class="sxs-lookup"><span data-stu-id="e65bf-166">For all markup extension support types, you should expose a public parameterless constructor.</span></span> <span data-ttu-id="e65bf-167">XAML 物件寫入器從物件專案使用方式具現化標記延伸的任何情況下，都需要無參數的函式。</span><span class="sxs-lookup"><span data-stu-id="e65bf-167">A parameterless constructor is required for any case where a XAML object writer instantiates the markup extension from an object element usage.</span></span> <span data-ttu-id="e65bf-168">支援物件項目使用方式是標記延伸的合理預期，特別是針對序列化。</span><span class="sxs-lookup"><span data-stu-id="e65bf-168">Supporting object element usage is a fair expectation for a markup extension, particularly for serialization.</span></span> <span data-ttu-id="e65bf-169">不過，如果您只想要支援標記延伸的屬性使用方式，則可以實作沒有公用建構函式的標記延伸。</span><span class="sxs-lookup"><span data-stu-id="e65bf-169">However, you can implement a markup extension without a public constructor if you only intend to support attribute usages of the markup extension.</span></span>

<span data-ttu-id="e65bf-170">如果您的標記延伸使用方式沒有引數，則需要無參數的函式來支援使用方式。</span><span class="sxs-lookup"><span data-stu-id="e65bf-170">If your markup extension usage has no arguments, the parameterless constructor is required to support usage.</span></span>

## <a name="constructor-patterns-and-positional-arguments-for-a-custom-markup-extension"></a><span data-ttu-id="e65bf-171">自訂標記延伸的建構函式模式和位置引數</span><span class="sxs-lookup"><span data-stu-id="e65bf-171">Constructor Patterns and Positional Arguments for a Custom Markup Extension</span></span>

<span data-ttu-id="e65bf-172">對於具有預定引數使用方式的標記延伸，公用建構函式必須對應於預定使用方式的模式。</span><span class="sxs-lookup"><span data-stu-id="e65bf-172">For a markup extension with intended argument usage, the public constructors must correspond to the modes of the intended usage.</span></span> <span data-ttu-id="e65bf-173">換句話說，如果標記延伸設計成需要一個位置引數做為有效使用方式，則應該支援具有一個接受位置引數之輸入參數的公用建構函式。</span><span class="sxs-lookup"><span data-stu-id="e65bf-173">In other words, if your markup extension is designed to require one positional argument as a valid usage, you should support a public constructor with one input parameter that takes the positional argument.</span></span>

<span data-ttu-id="e65bf-174">例如，假設 `Collate` 標記延伸僅支援有一個位置引數代表其模式的模式 (指定為 `CollationMode` 列舉常數)。</span><span class="sxs-lookup"><span data-stu-id="e65bf-174">For example, suppose the `Collate` markup extension is intended to support only a mode where there is one positional argument that represents its mode, specified as a `CollationMode` enumeration constant.</span></span> <span data-ttu-id="e65bf-175">在此情況下，應該有下列形式的建構函式：</span><span class="sxs-lookup"><span data-stu-id="e65bf-175">In this case, there should be a constructor with the following form:</span></span>

```csharp
public Collate(CollationMode collationMode) {...}
```

<span data-ttu-id="e65bf-176">在基本層級，傳遞給標記延伸的引數是字串，因為正在從標記的屬性值轉送引數。</span><span class="sxs-lookup"><span data-stu-id="e65bf-176">At a basic level, the arguments passed to a markup extension are a string because they are being forwarded from the markup's attribute values.</span></span> <span data-ttu-id="e65bf-177">您可以將所有引數都設為字串，並使用該層級的輸入。</span><span class="sxs-lookup"><span data-stu-id="e65bf-177">You can make all of your arguments strings and work with input at that level.</span></span> <span data-ttu-id="e65bf-178">不過，您確實可以存取將標記延伸引數傳遞至支援類別之前所發生的特定處理。</span><span class="sxs-lookup"><span data-stu-id="e65bf-178">However, you do have access to certain processing that occurs before the markup extension arguments are passed to the support class.</span></span>

<span data-ttu-id="e65bf-179">處理的運作在概念上如同標記延伸是要建立的物件，然後設定其成員值。</span><span class="sxs-lookup"><span data-stu-id="e65bf-179">The processing works conceptually as if the markup extension is an object to be created, and then its member values are set.</span></span> <span data-ttu-id="e65bf-180">每個要設定之指定屬性的評估方式，類似剖析 XAML 時，如何在已建立物件上設定指定成員。</span><span class="sxs-lookup"><span data-stu-id="e65bf-180">Each specified property to set is evaluated similar to how a specified member can be set on a created object when XAML is parsed.</span></span> <span data-ttu-id="e65bf-181">有兩個重大差異：</span><span class="sxs-lookup"><span data-stu-id="e65bf-181">There are two important differences:</span></span>

- <span data-ttu-id="e65bf-182">如先前所述，標記延伸支援型別不需要有無參數的函式，就可以在 XAML 中具現化。</span><span class="sxs-lookup"><span data-stu-id="e65bf-182">As noted previously, a markup extension support type does not need to have a parameterless constructor in order to be instantiated in XAML.</span></span> <span data-ttu-id="e65bf-183">除非它在文字語法中的可能引數語彙基元化並評估為位置或具名引數，以及在該時間呼叫適當的建構函式，否則會延後其物件建構。</span><span class="sxs-lookup"><span data-stu-id="e65bf-183">Its object construction is deferred until its possible arguments in the text syntax are tokenized and evaluated as either positional or named arguments, and the appropriate constructor is called at that time.</span></span>
- <span data-ttu-id="e65bf-184">標記延伸使用方式可以是巢狀的。</span><span class="sxs-lookup"><span data-stu-id="e65bf-184">Markup extensions usages can be nested.</span></span> <span data-ttu-id="e65bf-185">會先評估最內層的標記延伸。</span><span class="sxs-lookup"><span data-stu-id="e65bf-185">The innermost markup extension is evaluated first.</span></span> <span data-ttu-id="e65bf-186">因此，您可以假設使用這類使用方式，並將一個建構參數宣告為需要值轉換器 (例如標記延伸) 的類型。</span><span class="sxs-lookup"><span data-stu-id="e65bf-186">Therefore, you can assume such a usage and declare one of the construction parameters to be a type that requires a value converter (such as a markup extension) to produce.</span></span>

<span data-ttu-id="e65bf-187">在先前範例中，顯示與這類處理的依賴性。</span><span class="sxs-lookup"><span data-stu-id="e65bf-187">A reliance on such processing was shown in the previous example.</span></span> <span data-ttu-id="e65bf-188">.NET XAML 服務 XAML 物件寫入器會將列舉常數名稱處理為原生層級的列舉值。</span><span class="sxs-lookup"><span data-stu-id="e65bf-188">.NET XAML Services XAML object writer processes enumeration constant names into enumerated values at a native level.</span></span>

<span data-ttu-id="e65bf-189">處理標記延伸位置參數的文字語法也可以仰賴與建構引數中類型相關聯的類型轉換器。</span><span class="sxs-lookup"><span data-stu-id="e65bf-189">Processing text syntax of a markup extension positional parameter can also rely on a type converter that is associated with the type that is in the construction argument.</span></span>

<span data-ttu-id="e65bf-190">引數稱為位置引數，因為使用方式中的語彙基元順序對應至指派給語彙基元之建構函式參數的位置順序。</span><span class="sxs-lookup"><span data-stu-id="e65bf-190">The arguments are called positional arguments because the order in which the tokens in the usage is encountered corresponds to the positional order of the constructor parameter to which they are assigned.</span></span> <span data-ttu-id="e65bf-191">例如，請考慮下列建構函式簽章：</span><span class="sxs-lookup"><span data-stu-id="e65bf-191">For example, consider the following constructor signature:</span></span>

```csharp
public Collate(CollationMode collationMode, object collateThis) {...}
```

<span data-ttu-id="e65bf-192">XAML 處理器預期此標記延伸會有兩個位置引數。</span><span class="sxs-lookup"><span data-stu-id="e65bf-192">A XAML processor expects two positional arguments for this markup extension.</span></span> <span data-ttu-id="e65bf-193">如果有使用方式 `{Collate AlphaUp,{x:Reference circularFile}}`，則會將 `AlphaUp` 權杖傳送至第一個參數，並評估為 `CollationMode` 列舉具名常數。</span><span class="sxs-lookup"><span data-stu-id="e65bf-193">If there was a usage `{Collate AlphaUp,{x:Reference circularFile}}`, the `AlphaUp` token is sent to the first parameter and evaluated as a `CollationMode` enumeration named constant.</span></span> <span data-ttu-id="e65bf-194">內部 `x:Reference` 的結果會傳送至第二個參數，並評估為物件。</span><span class="sxs-lookup"><span data-stu-id="e65bf-194">The result of the inner `x:Reference` is sent to the second parameter and evaluated as an object.</span></span>

<span data-ttu-id="e65bf-195">在標記延伸語法和處理的 XAML 指定規則中，不論引數是位置引數還是具名引數，逗號都是這些引數之間的分隔符號。</span><span class="sxs-lookup"><span data-stu-id="e65bf-195">In the XAML specified rules for markup extension syntax and processing, the comma is the delimiter between arguments, whether those arguments are positional arguments or named arguments.</span></span>

### <a name="duplicate-arity-of-positional-arguments"></a><span data-ttu-id="e65bf-196">位置引數的重複 arity</span><span class="sxs-lookup"><span data-stu-id="e65bf-196">Duplicate arity of positional arguments</span></span>

<span data-ttu-id="e65bf-197">如果 XAML 物件寫入器遇到具有位置引數的標記延伸使用方式，而且有接受該數目之引數 (重複 Arity) 的多個建構函式引數，則這不一定是錯誤。</span><span class="sxs-lookup"><span data-stu-id="e65bf-197">If a XAML object writer encounters a markup extension usage with positional arguments, and there are multiple constructor arguments that take that number of arguments (a duplicate arity), that is not necessarily an error.</span></span> <span data-ttu-id="e65bf-198">行為取決於可自訂 XAML 結構描述內容設定 ( <xref:System.Xaml.XamlSchemaContextSettings.SupportMarkupExtensionsWithDuplicateArity%2A>)。</span><span class="sxs-lookup"><span data-stu-id="e65bf-198">The behavior depends on a customizable XAML schema context setting, <xref:System.Xaml.XamlSchemaContextSettings.SupportMarkupExtensionsWithDuplicateArity%2A>.</span></span> <span data-ttu-id="e65bf-199">如果 <xref:System.Xaml.XamlSchemaContextSettings.SupportMarkupExtensionsWithDuplicateArity%2A> 是 `true`，XAML 物件寫入器應該不會僅針對重複 Arity 原因擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="e65bf-199">If <xref:System.Xaml.XamlSchemaContextSettings.SupportMarkupExtensionsWithDuplicateArity%2A> is `true`, a XAML object writer should not throw an exception only for reasons of duplicate arity.</span></span> <span data-ttu-id="e65bf-200">該點的行為並未嚴格進行定義。</span><span class="sxs-lookup"><span data-stu-id="e65bf-200">Behavior beyond that point is not strictly defined.</span></span> <span data-ttu-id="e65bf-201">基本設計假設是結構描述內容具有可用於特定參數的類型資訊，而且可以嘗試比對重複候選項的明確轉換，以查看哪些簽章可能是最佳相符項。</span><span class="sxs-lookup"><span data-stu-id="e65bf-201">The basic design assumption is that the schema context has type information available for the specific parameters and can attempt explicit casts that match the duplicate candidates to see which signature might be the best match.</span></span> <span data-ttu-id="e65bf-202">如果沒有簽章可以通過 XAML 物件寫入器上執行的特定結構描述內容所進行的測試，則可能還是會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="e65bf-202">An exception might still be thrown if no signatures can pass the tests that are imposed by that particular schema context that is running on a XAML object writer.</span></span>

<span data-ttu-id="e65bf-203">根據預設， <xref:System.Xaml.XamlSchemaContextSettings.SupportMarkupExtensionsWithDuplicateArity%2A> 會 `false` 在以 CLR 為基礎 <xref:System.Xaml.XamlSchemaContext> 的 .net XAML 服務中。</span><span class="sxs-lookup"><span data-stu-id="e65bf-203">By default, <xref:System.Xaml.XamlSchemaContextSettings.SupportMarkupExtensionsWithDuplicateArity%2A> is `false` in the CLR-based <xref:System.Xaml.XamlSchemaContext> for .NET XAML Services.</span></span> <span data-ttu-id="e65bf-204">因此，如果遇到支援類型建構函式中有重複 Arity 的標記延伸使用方式，則預設 <xref:System.Xaml.XamlObjectWriter> 會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="e65bf-204">Thus, the default <xref:System.Xaml.XamlObjectWriter> throws exceptions if it encounters a markup extension usage where there is duplicate arity in the backing type's constructors.</span></span>

## <a name="named-arguments-for-a-custom-markup-extension"></a><span data-ttu-id="e65bf-205">自訂標記延伸的具名引數</span><span class="sxs-lookup"><span data-stu-id="e65bf-205">Named arguments for a custom markup extension</span></span>

<span data-ttu-id="e65bf-206">XAML 所指定的標記延伸也可以使用使用方式的具名引數形式。</span><span class="sxs-lookup"><span data-stu-id="e65bf-206">Markup extensions as specified by XAML can also use a named arguments form for usage.</span></span> <span data-ttu-id="e65bf-207">在第一個語彙基元化層級，文字語法會分成數個引數。</span><span class="sxs-lookup"><span data-stu-id="e65bf-207">At the first level of tokenization, the text syntax is divided into arguments.</span></span> <span data-ttu-id="e65bf-208">任何引數內有等號 (=) 會將引數識別為具名引數。</span><span class="sxs-lookup"><span data-stu-id="e65bf-208">The presence of an equals sign (=) within any argument identifies an argument as a named argument.</span></span> <span data-ttu-id="e65bf-209">這類引數也會語彙基元化成名稱/值組。</span><span class="sxs-lookup"><span data-stu-id="e65bf-209">Such an argument is also tokenized into a name/value pair.</span></span> <span data-ttu-id="e65bf-210">在此情況下，名稱會指定標記延伸支援類型的公用可設定屬性。</span><span class="sxs-lookup"><span data-stu-id="e65bf-210">The name in this case names a public settable property of the markup extension's support type.</span></span> <span data-ttu-id="e65bf-211">如果您想要支援具名引數使用方式，則應該提供這些公用可設定屬性。</span><span class="sxs-lookup"><span data-stu-id="e65bf-211">If you intend to support named argument usage, you should provide these public settable properties.</span></span> <span data-ttu-id="e65bf-212">屬性只要保持公用，就可以是繼承屬性。</span><span class="sxs-lookup"><span data-stu-id="e65bf-212">The properties can be inherited properties as long as they remain public.</span></span>

## <a name="accessing-service-provider-context-from-a-markup-extension-implementation"></a><span data-ttu-id="e65bf-213">從標記延伸實作存取服務提供者內容</span><span class="sxs-lookup"><span data-stu-id="e65bf-213">Accessing Service Provider Context from a Markup Extension Implementation</span></span>

<span data-ttu-id="e65bf-214">任何值轉換器的可用服務都相同。</span><span class="sxs-lookup"><span data-stu-id="e65bf-214">The services available are the same for any value converter.</span></span> <span data-ttu-id="e65bf-215">差異在於每個值轉換器如何接收服務內容。</span><span class="sxs-lookup"><span data-stu-id="e65bf-215">The difference is in how each value converter receives the service context.</span></span> <span data-ttu-id="e65bf-216">存取服務和可用服務記載於 [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions.md)主題中。</span><span class="sxs-lookup"><span data-stu-id="e65bf-216">Accessing services and the services available are documented in the topic [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions.md).</span></span>

## <a name="property-element-usage-of-a-markup-extension"></a><span data-ttu-id="e65bf-217">標記延伸的屬性專案使用方式</span><span class="sxs-lookup"><span data-stu-id="e65bf-217">Property element usage of a markup extension</span></span>

<span data-ttu-id="e65bf-218">通常是在屬性使用方式中使用標記延伸來設定標記延伸使用方式的案例。</span><span class="sxs-lookup"><span data-stu-id="e65bf-218">The scenarios for markup extension usages are often designed around using the markup extension in attribute usage.</span></span> <span data-ttu-id="e65bf-219">不過，也可能可以定義支援類別，以支援屬性項目使用方式。</span><span class="sxs-lookup"><span data-stu-id="e65bf-219">However, it is also potentially possible to define the backing class to support property element usage.</span></span>

<span data-ttu-id="e65bf-220">若要支援標記延伸的屬性專案使用方式，請定義公用無參數的函式。</span><span class="sxs-lookup"><span data-stu-id="e65bf-220">To support property element usage of your markup extension, define a public parameterless constructor.</span></span> <span data-ttu-id="e65bf-221">這應該是執行個體建構函式，而不是靜態建構函式。</span><span class="sxs-lookup"><span data-stu-id="e65bf-221">This should be an instance constructor not a static constructor.</span></span> <span data-ttu-id="e65bf-222">這是必要的，因為 XAML 處理器通常必須在它從標記處理的任何物件元素上叫用無參數的函式，而這會將標記延伸類別包含為物件元素。</span><span class="sxs-lookup"><span data-stu-id="e65bf-222">This is required because a XAML processor must generally invoke the parameterless constructor on any object element it processes from markup, and this includes markup extension classes as object elements.</span></span> <span data-ttu-id="e65bf-223">在進階案例中，您可以定義類別的非預設建構路徑。</span><span class="sxs-lookup"><span data-stu-id="e65bf-223">For advanced scenarios, you can define non-default construction paths for classes.</span></span> <span data-ttu-id="e65bf-224"> (如需詳細資訊，請參閱 [x:FactoryMethod](xfactorymethod-directive.md)指示詞。 ) 不過，您不應該將這些模式用於標記延伸用途，因為這會讓設計人員和原始標記使用者的使用模式探索變得更困難。</span><span class="sxs-lookup"><span data-stu-id="e65bf-224">(For more information, see [x:FactoryMethod Directive](xfactorymethod-directive.md).) However, you should not use these patterns for markup extension purposes because this makes discovery of the usage pattern much more difficult, both for designers and for users of raw markup.</span></span>

## <a name="attributing-for-a-custom-markup-extension"></a><span data-ttu-id="e65bf-225">自訂標記延伸的特性化</span><span class="sxs-lookup"><span data-stu-id="e65bf-225">Attributing for a custom markup extension</span></span>

<span data-ttu-id="e65bf-226">為了支援設計環境和特定 XAML 物件寫入器案例，您應該設定具有數個 CLR 屬性之標記延伸支援類型的屬性。</span><span class="sxs-lookup"><span data-stu-id="e65bf-226">To support both design environments and certain XAML object writer scenarios, you should attribute a markup extension support type with several CLR attributes.</span></span> <span data-ttu-id="e65bf-227">這些屬性會報告預定標記延伸使用方式。</span><span class="sxs-lookup"><span data-stu-id="e65bf-227">These attributes report the intended markup extension usage.</span></span>

 <span data-ttu-id="e65bf-228"><xref:System.Windows.Markup.MarkupExtensionReturnTypeAttribute> 會報告 <xref:System.Type> 所傳回之物件類型的 <xref:System.Windows.Markup.ArrayExtension.ProvideValue%2A> 資訊。</span><span class="sxs-lookup"><span data-stu-id="e65bf-228"><xref:System.Windows.Markup.MarkupExtensionReturnTypeAttribute> reports the <xref:System.Type> information for the object type that <xref:System.Windows.Markup.ArrayExtension.ProvideValue%2A> returns.</span></span> <span data-ttu-id="e65bf-229">透過其純正簽章， <xref:System.Windows.Markup.ArrayExtension.ProvideValue%2A> 會傳回 <xref:System.Object>。</span><span class="sxs-lookup"><span data-stu-id="e65bf-229">By its pure signature, <xref:System.Windows.Markup.ArrayExtension.ProvideValue%2A> returns <xref:System.Object>.</span></span> <span data-ttu-id="e65bf-230">但是，各種消費者可能想要更精確的傳回類型資訊。</span><span class="sxs-lookup"><span data-stu-id="e65bf-230">But various consumers might want more precise return type information.</span></span> <span data-ttu-id="e65bf-231">這包括：</span><span class="sxs-lookup"><span data-stu-id="e65bf-231">This includes:</span></span>

- <span data-ttu-id="e65bf-232">設計人員和 IDE，可能可以提供標記延伸使用方式的類型感知支援。</span><span class="sxs-lookup"><span data-stu-id="e65bf-232">Designers and IDEs, who might be able to provide type-aware support for markup extension usages.</span></span>
- <span data-ttu-id="e65bf-233">目標類別上 `SetMarkupExtension` 處理常式的進階實作，可能依賴反映來判斷標記延伸的傳回類型，而不是依名稱對特定已知 <xref:System.Windows.Markup.MarkupExtension> 實作進行分支處理。</span><span class="sxs-lookup"><span data-stu-id="e65bf-233">Advanced implementations of `SetMarkupExtension` handlers on target classes, which might rely on reflection to determine a markup extension's return type instead of branching on specific known <xref:System.Windows.Markup.MarkupExtension> implementations by name.</span></span>

## <a name="serialization-of-markup-extension-usages"></a><span data-ttu-id="e65bf-234">標記延伸使用方式的序列化</span><span class="sxs-lookup"><span data-stu-id="e65bf-234">Serialization of markup extension usages</span></span>

<span data-ttu-id="e65bf-235">XAML 物件寫入器處理標記延伸使用方式並呼叫 <xref:System.Windows.Markup.MarkupExtension.ProvideValue%2A>時，先前為標記延伸使用方式的內容存在於 XAML 節點資料流中，但不在物件圖形中。</span><span class="sxs-lookup"><span data-stu-id="e65bf-235">When a XAML object writer processes a markup extension usage and calls <xref:System.Windows.Markup.MarkupExtension.ProvideValue%2A>, the context for it previously being a markup extension usage persists in the XAML node stream but not in the object graph.</span></span> <span data-ttu-id="e65bf-236">在物件圖形中，只會保留值。</span><span class="sxs-lookup"><span data-stu-id="e65bf-236">In the object graph, only the value is preserved.</span></span> <span data-ttu-id="e65bf-237">如果您有設計案例或將原始標記延伸使用方式持續保存至序列化輸出的其他原因，則必須設計您自己的基礎結構，以從載入路徑 XAML 節點資料流追蹤標記延伸使用方式。</span><span class="sxs-lookup"><span data-stu-id="e65bf-237">If you have design scenarios or other reasons for persisting the original markup extension usage into the serialized output, you must design your own infrastructure for tracking the markup extension usages from the load path XAML node stream.</span></span> <span data-ttu-id="e65bf-238">您可以實作行為以從載入路徑重新建立節點資料流的項目，並將它們播放回 XAML 寫入器以在儲存路徑中進行序列化，但需替換節點資料流適當位置中的值。</span><span class="sxs-lookup"><span data-stu-id="e65bf-238">You can implement behavior to recreate the elements of the node stream from the load path and play them back to XAML writers for serialization in the save path, substituting for the value in the appropriate position of the node stream.</span></span>

## <a name="markup-extensions-in-the-xaml-node-stream"></a><span data-ttu-id="e65bf-239">XAML 節點資料流程中的標記延伸</span><span class="sxs-lookup"><span data-stu-id="e65bf-239">Markup extensions in the XAML node stream</span></span>

<span data-ttu-id="e65bf-240">如果您是在載入路徑上使用 XAML 節點資料流，則標記延伸使用方式會以物件形式出現在節點資料流中。</span><span class="sxs-lookup"><span data-stu-id="e65bf-240">If you are working with a XAML node stream on the load path, a markup extension usage appears in the node stream as an object.</span></span>

<span data-ttu-id="e65bf-241">如果標記延伸使用方式使用位置引數，則會呈現為具有初始化值的啟動物件。</span><span class="sxs-lookup"><span data-stu-id="e65bf-241">If the markup extension usage uses positional arguments, it is represented as a start object with an initialization value.</span></span> <span data-ttu-id="e65bf-242">節點資料流是以粗略的文字表示，看起來如下：</span><span class="sxs-lookup"><span data-stu-id="e65bf-242">As a rough text representation, the node stream resembles the following:</span></span>

<span data-ttu-id="e65bf-243">`StartObject` (<xref:System.Xaml.XamlType> 是標記延伸的定義類型，而不是它的傳回類型)</span><span class="sxs-lookup"><span data-stu-id="e65bf-243">`StartObject` (<xref:System.Xaml.XamlType> is the markup extension's definition type, not its return type)</span></span>

<span data-ttu-id="e65bf-244">`StartMember` ( <xref:System.Xaml.XamlMember> 的名稱是 `_InitializationText`)</span><span class="sxs-lookup"><span data-stu-id="e65bf-244">`StartMember` (name of the <xref:System.Xaml.XamlMember> is `_InitializationText`)</span></span>

<span data-ttu-id="e65bf-245">`Value` (值是字串形式的位置引數，包括中間分隔符號)</span><span class="sxs-lookup"><span data-stu-id="e65bf-245">`Value` (value is the positional arguments as a string including the intervening delimiters)</span></span>

`EndMember`

`EndObject`

<span data-ttu-id="e65bf-246">具有具名引數的標記延伸使用方式會呈現為具有相關名稱之成員的物件，且成員各設定文字字串值。</span><span class="sxs-lookup"><span data-stu-id="e65bf-246">A markup extension usage with named arguments is represented as an object with members of the relevant names, each set with text string values.</span></span>

<span data-ttu-id="e65bf-247">實際叫用標記延伸的 `ProvideValue` 實作需要 XAML 結構描述內容，因為這需要類型對應以及建立標記延伸支援類型執行個體。</span><span class="sxs-lookup"><span data-stu-id="e65bf-247">Actually invoking the `ProvideValue` implementation of a markup extension requires the XAML schema context because that requires type-mapping and creating a markup extension support type instance.</span></span> <span data-ttu-id="e65bf-248">這是在預設的 .NET XAML 服務節點資料流程中以這種方式保留標記延伸使用方式的其中一個原因-載入路徑的讀取器部分通常不會有必要的 XAML 架構內容可用。</span><span class="sxs-lookup"><span data-stu-id="e65bf-248">This is one reason why markup extension usages are preserved this way in the default .NET XAML Services node streams -  the reader part of a load path often does not have the necessary XAML schema context available.</span></span>

<span data-ttu-id="e65bf-249">如果您是在儲存路徑上使用 XAML 節點資料流，則物件圖形呈現中通常不會有任何項目可通知您：要序列化的物件一開始是由標記延伸使用方式和 `ProvideValue` 結果所提供。</span><span class="sxs-lookup"><span data-stu-id="e65bf-249">If you are working with a XAML node stream on the save path, there generally is nothing present in an object graph representation that can inform you that the object to serialize was originally provided by a markup extension usage and a `ProvideValue` result.</span></span> <span data-ttu-id="e65bf-250">如果案例需要針對來回處理保存標記延伸使用方式，同時擷取物件圖形中的其他變更，則必須設計自己的技術來保留原始 XAML 輸入中的標記延伸使用方式知識。</span><span class="sxs-lookup"><span data-stu-id="e65bf-250">Scenarios that need to persist markup extension usages for round-tripping while also capturing other changes in the object graph must devise their own techniques for preserving the knowledge of a markup extension usage from the original XAML input.</span></span> <span data-ttu-id="e65bf-251">例如，若要還原標記延伸使用方式，您可能需要在儲存路徑上使用節點資料流才能還原標記延伸使用方式，或在原始 XAML 與往返 XAML 之間執行某種類型的合併。</span><span class="sxs-lookup"><span data-stu-id="e65bf-251">For example, to restore the markup extension usages, you may need to work with the node stream on the save path in order to restore markup extension usages, or perform some type of merge between the original XAML and the round-tripped XAML.</span></span> <span data-ttu-id="e65bf-252">一些實作 XAML 的架構 (例如 WPF) 使用中繼類型 (運算式)，協助代表標記延伸使用方式提供值的情況。</span><span class="sxs-lookup"><span data-stu-id="e65bf-252">Some XAML-implementing frameworks such as WPF use intermediate types (expressions) to help represent cases where markup extension usages provided the values.</span></span>

## <a name="see-also"></a><span data-ttu-id="e65bf-253">另請參閱</span><span class="sxs-lookup"><span data-stu-id="e65bf-253">See also</span></span>

- <xref:System.Windows.Markup.MarkupExtension>
- [<span data-ttu-id="e65bf-254">XAML 的類型轉換子和標記延伸</span><span class="sxs-lookup"><span data-stu-id="e65bf-254">Type Converters and Markup Extensions for XAML</span></span>](type-converters-and-markup-extensions.md)
- [<span data-ttu-id="e65bf-255">標記延伸和 WPF XAML</span><span class="sxs-lookup"><span data-stu-id="e65bf-255">Markup Extensions and WPF XAML</span></span>](/dotnet/desktop/wpf/advanced/markup-extensions-and-wpf-xaml)
