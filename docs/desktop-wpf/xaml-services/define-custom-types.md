---
title: 定義可搭配 .NET XAML 服務使用的自訂類型
ms.date: 03/30/2017
helpviewer_keywords:
- defining custom types [XAML Services]
ms.assetid: c2667cbd-2f46-4a7f-9dfc-53696e35e8e4
ms.openlocfilehash: 2c0578b5397172814c708706173c69ef69f91b2a
ms.sourcegitcommit: 27a15a55019f6b5f2733961738babe94aec0def3
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 09/15/2020
ms.locfileid: "90551774"
---
# <a name="define-custom-types-for-use-with-net-xaml-services"></a><span data-ttu-id="c8ff8-102">定義搭配 .NET XAML 服務使用的自訂類型</span><span class="sxs-lookup"><span data-stu-id="c8ff8-102">Define custom types for use with .NET XAML Services</span></span>

<span data-ttu-id="c8ff8-103">當您定義屬於商務物件的自訂類型，或是沒有相依于特定架構的類型時，可以遵循 XAML 的一些最佳作法。</span><span class="sxs-lookup"><span data-stu-id="c8ff8-103">When you define custom types that are business objects or are types that do not have a dependency on specific frameworks, there are certain best practices for XAML you can follow.</span></span> <span data-ttu-id="c8ff8-104">如果您遵循這些做法，.NET XAML 服務及其 XAML 讀取器和 XAML 寫入器可以探索您類型的 XAML 特性，並使用 XAML 型別系統在 XAML 節點資料流程中提供適當的標記法。</span><span class="sxs-lookup"><span data-stu-id="c8ff8-104">If you follow these practices, .NET XAML Services and its XAML readers and XAML writers can discover the XAML characteristics of your type and give it appropriate representation in a XAML node stream using the XAML type system.</span></span> <span data-ttu-id="c8ff8-105">本主題說明型別定義、成員定義以及型別或成員的 CLR 類型的最佳作法。</span><span class="sxs-lookup"><span data-stu-id="c8ff8-105">This topic describes best practices for type definitions, member definitions, and CLR attributing of types or members.</span></span>

## <a name="constructor-patterns-and-type-definitions-for-xaml"></a><span data-ttu-id="c8ff8-106">XAML 的函式模式和類型定義</span><span class="sxs-lookup"><span data-stu-id="c8ff8-106">Constructor Patterns and Type Definitions for XAML</span></span>

<span data-ttu-id="c8ff8-107">若要在 XAML 中具現化為物件元素，自訂類別必須符合下列需求：</span><span class="sxs-lookup"><span data-stu-id="c8ff8-107">To be instantiated as an object element in XAML, a custom class must meet the following requirements:</span></span>

- <span data-ttu-id="c8ff8-108">自訂類別必須是公用的，而且必須公開無參數公用的函式。</span><span class="sxs-lookup"><span data-stu-id="c8ff8-108">The custom class must be public and must expose a parameterless public constructor.</span></span> <span data-ttu-id="c8ff8-109">(如需結構相關附註，請參閱下節)。</span><span class="sxs-lookup"><span data-stu-id="c8ff8-109">(See following section for notes regarding structures.)</span></span>

- <span data-ttu-id="c8ff8-110">自訂類別不得為嵌套類別。</span><span class="sxs-lookup"><span data-stu-id="c8ff8-110">The custom class must not be a nested class.</span></span> <span data-ttu-id="c8ff8-111">在完整名稱路徑中的額外「點」讓類別命名空間的除法不明確，並干擾其他 XAML 功能，例如附加屬性。</span><span class="sxs-lookup"><span data-stu-id="c8ff8-111">The extra "dot" in the full-name path makes the class-namespace division ambiguous, and interferes with other XAML features such as attached properties.</span></span>
<span data-ttu-id="c8ff8-112">如果物件可以具現化為物件專案，則建立的物件可以填滿將物件做為其基礎型別的任何屬性（property element）形式的屬性（property element）。</span><span class="sxs-lookup"><span data-stu-id="c8ff8-112">If an object can be instantiated as an object element, the created object can fill the property element form of any properties that take the object as their underlying type.</span></span>

<span data-ttu-id="c8ff8-113">如果您啟用值轉換器，您仍然可以針對不符合這些準則的類型提供物件值。</span><span class="sxs-lookup"><span data-stu-id="c8ff8-113">You can still provide object values for types that do not meet these criteria, if you enable a value converter.</span></span> <span data-ttu-id="c8ff8-114">如需詳細資訊，請參閱 [XAML 的類型轉換器和標記延伸](type-converters-and-markup-extensions.md)。</span><span class="sxs-lookup"><span data-stu-id="c8ff8-114">For more information, see [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions.md).</span></span>

### <a name="structures"></a><span data-ttu-id="c8ff8-115">結構</span><span class="sxs-lookup"><span data-stu-id="c8ff8-115">Structures</span></span>

<span data-ttu-id="c8ff8-116">結構一律可以透過 CLR 定義在 XAML 中進行。</span><span class="sxs-lookup"><span data-stu-id="c8ff8-116">Structures are always able to be constructed in XAML, by CLR definition.</span></span> <span data-ttu-id="c8ff8-117">這是因為 CLR 編譯器會隱含地為結構建立無參數的函式。</span><span class="sxs-lookup"><span data-stu-id="c8ff8-117">This is because a CLR compiler implicitly creates a parameterless constructor for a structure.</span></span> <span data-ttu-id="c8ff8-118">這個函式會將所有屬性值初始化為其預設值。</span><span class="sxs-lookup"><span data-stu-id="c8ff8-118">This constructor initializes all property values to their defaults.</span></span>

<span data-ttu-id="c8ff8-119">在某些情況下，不需要結構的預設結構行為。</span><span class="sxs-lookup"><span data-stu-id="c8ff8-119">In some cases, the default construction behavior for a structure is not desirable.</span></span> <span data-ttu-id="c8ff8-120">這可能是因為結構的目的是要將值填滿，並且在概念上以聯集的方式運作。</span><span class="sxs-lookup"><span data-stu-id="c8ff8-120">This might be because the structure is intended to fill values and function conceptually as a union.</span></span> <span data-ttu-id="c8ff8-121">以聯集的形式，包含的值可能會有互斥的解讀，因此不會設定其任何屬性。</span><span class="sxs-lookup"><span data-stu-id="c8ff8-121">As a union, the contained values might have mutually exclusive interpretations, and therefore, none of its properties are settable.</span></span> <span data-ttu-id="c8ff8-122">WPF 詞彙中的這類結構範例為 <xref:System.Windows.GridLength> 。</span><span class="sxs-lookup"><span data-stu-id="c8ff8-122">An example of such a structure in the WPF vocabulary is <xref:System.Windows.GridLength>.</span></span> <span data-ttu-id="c8ff8-123">這類結構應該採用型別轉換子，藉由使用可建立結構值之不同解讀或模式的字串慣例，以屬性形式表示值。</span><span class="sxs-lookup"><span data-stu-id="c8ff8-123">Such structures should implement a type converter so that the values can be expressed in attribute form, by using string conventions that create the different interpretations or modes of the structure values.</span></span> <span data-ttu-id="c8ff8-124">此結構也應該透過非參數的函式來公開程式碼結構的類似行為。</span><span class="sxs-lookup"><span data-stu-id="c8ff8-124">The structure should also expose similar behavior for code construction through a non-parameterless constructor.</span></span>

### <a name="interfaces"></a><span data-ttu-id="c8ff8-125">介面</span><span class="sxs-lookup"><span data-stu-id="c8ff8-125">Interfaces</span></span>

<span data-ttu-id="c8ff8-126">介面可以用來做為成員的基礎類型。</span><span class="sxs-lookup"><span data-stu-id="c8ff8-126">Interfaces can be used as underlying types of members.</span></span> <span data-ttu-id="c8ff8-127">XAML 類型系統會檢查可指派的清單，並預期以值形式提供的物件可以指派給介面。</span><span class="sxs-lookup"><span data-stu-id="c8ff8-127">The XAML type system checks the assignable list and expects that the object that is provided as the value can be assigned to the interface.</span></span> <span data-ttu-id="c8ff8-128">如果有相關的可指派型別支援 XAML 結構需求，就不需要將介面呈現為 XAML 型別。</span><span class="sxs-lookup"><span data-stu-id="c8ff8-128">There is no concept of how the interface must be presented as a XAML type as long as a relevant assignable type supports the XAML construction requirements.</span></span>

### <a name="factory-methods"></a><span data-ttu-id="c8ff8-129">Factory 方法</span><span class="sxs-lookup"><span data-stu-id="c8ff8-129">Factory Methods</span></span>

<span data-ttu-id="c8ff8-130">Factory 方法是 XAML 2009 功能。</span><span class="sxs-lookup"><span data-stu-id="c8ff8-130">Factory methods are a XAML 2009 feature.</span></span> <span data-ttu-id="c8ff8-131">它們會修改物件必須具有無參數的函式的 XAML 原則。</span><span class="sxs-lookup"><span data-stu-id="c8ff8-131">They modify the XAML principle that objects must have parameterless constructors.</span></span> <span data-ttu-id="c8ff8-132">本文中未記載 Factory 方法。</span><span class="sxs-lookup"><span data-stu-id="c8ff8-132">Factory methods are not documented in this article.</span></span> <span data-ttu-id="c8ff8-133">請參閱 [x:FactoryMethod](xfactorymethod-directive.md)指示詞。</span><span class="sxs-lookup"><span data-stu-id="c8ff8-133">See [x:FactoryMethod Directive](xfactorymethod-directive.md).</span></span>

## <a name="enumerations"></a><span data-ttu-id="c8ff8-134">列舉</span><span class="sxs-lookup"><span data-stu-id="c8ff8-134">Enumerations</span></span>

<span data-ttu-id="c8ff8-135">列舉具有 XAML 原生類型轉換行為。</span><span class="sxs-lookup"><span data-stu-id="c8ff8-135">Enumerations have XAML native type conversion behavior.</span></span> <span data-ttu-id="c8ff8-136">XAML 中指定的列舉常數名稱是根據基礎列舉型別來解析，並且將列舉值傳回給 XAML 物件寫入器。</span><span class="sxs-lookup"><span data-stu-id="c8ff8-136">Enumeration constant names specified in XAML are resolved against the underlying enumeration type, and return the enumeration value to a XAML object writer.</span></span>

<span data-ttu-id="c8ff8-137">XAML 針對已套用的列舉支援旗標樣式用法 <xref:System.FlagsAttribute> 。</span><span class="sxs-lookup"><span data-stu-id="c8ff8-137">XAML supports a flags-style usage for enumerations with <xref:System.FlagsAttribute> applied.</span></span> <span data-ttu-id="c8ff8-138">如需詳細資訊，請參閱 [XAML 語法的詳細](/dotnet/desktop/wpf/advanced/xaml-syntax-in-detail)資訊。</span><span class="sxs-lookup"><span data-stu-id="c8ff8-138">For more information, see [XAML Syntax In Detail](/dotnet/desktop/wpf/advanced/xaml-syntax-in-detail).</span></span> <span data-ttu-id="c8ff8-139"> ([Xaml 語法的詳細](/dotnet/desktop/wpf/advanced/xaml-syntax-in-detail) 資訊是針對 WPF 物件撰寫的，但該主題中大部分的資訊都與特定執行架構無關的 xaml 有關。 ) </span><span class="sxs-lookup"><span data-stu-id="c8ff8-139">([XAML Syntax In Detail](/dotnet/desktop/wpf/advanced/xaml-syntax-in-detail) is written for the WPF audience, but most of the information in that topic is relevant for XAML that is not specific to a particular implementing framework.)</span></span>

## <a name="member-definitions"></a><span data-ttu-id="c8ff8-140">成員定義</span><span class="sxs-lookup"><span data-stu-id="c8ff8-140">Member Definitions</span></span>

<span data-ttu-id="c8ff8-141">類型可以定義 XAML 用法的成員。</span><span class="sxs-lookup"><span data-stu-id="c8ff8-141">Types can define members for XAML usage.</span></span> <span data-ttu-id="c8ff8-142">類型可以定義可供 XAML 使用的成員，即使該特定型別不是 XAML 可用也是一樣。</span><span class="sxs-lookup"><span data-stu-id="c8ff8-142">It's possible for types to define members that are XAML-usable even if that specific type is not XAML-usable.</span></span> <span data-ttu-id="c8ff8-143">這是可能的，因為 CLR 繼承。</span><span class="sxs-lookup"><span data-stu-id="c8ff8-143">This is possible because of CLR inheritance.</span></span> <span data-ttu-id="c8ff8-144">只要有一些繼承成員的型別支援 XAML 使用方式做為型別，而成員支援其基礎類型的 XAML 使用方式，或有原生 XAML 語法可用，該成員就可以使用 XAML。</span><span class="sxs-lookup"><span data-stu-id="c8ff8-144">So long as some type that inherits the member supports XAML usage as a type, and the member supports XAML usage for its underlying type or has a native XAML syntax available, that member is XAML-usable.</span></span>

### <a name="properties"></a><span data-ttu-id="c8ff8-145">屬性</span><span class="sxs-lookup"><span data-stu-id="c8ff8-145">Properties</span></span>

<span data-ttu-id="c8ff8-146">如果您使用一般 CLR 和存取子模式和語言適當的 keywording，將屬性定義為公用 CLR 屬性， `get` `set` XAML 型別系統可以將屬性報告為具有提供給屬性之適當資訊的成員 <xref:System.Xaml.XamlMember> ，例如 <xref:System.Xaml.XamlMember.IsReadPublic%2A> 和 <xref:System.Xaml.XamlMember.IsWritePublic%2A> 。</span><span class="sxs-lookup"><span data-stu-id="c8ff8-146">If you define properties as a public CLR property using the typical CLR `get` and `set` accessor patterns and language-appropriate keywording, the XAML type system can report the property as a member with appropriate information provided for <xref:System.Xaml.XamlMember> properties, such as <xref:System.Xaml.XamlMember.IsReadPublic%2A> and <xref:System.Xaml.XamlMember.IsWritePublic%2A>.</span></span>

<span data-ttu-id="c8ff8-147">特定屬性可以藉由套用來啟用文字語法 <xref:System.ComponentModel.TypeConverterAttribute> 。</span><span class="sxs-lookup"><span data-stu-id="c8ff8-147">Specific properties can enable a text syntax by applying <xref:System.ComponentModel.TypeConverterAttribute>.</span></span> <span data-ttu-id="c8ff8-148">如需詳細資訊，請參閱 [XAML 的類型轉換器和標記延伸](type-converters-and-markup-extensions.md)。</span><span class="sxs-lookup"><span data-stu-id="c8ff8-148">For more information, see [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions.md).</span></span>

<span data-ttu-id="c8ff8-149">如果沒有文字語法或原生 XAML 轉換，而且沒有進一步的間接取值（例如標記延伸使用方式），則在 XAML 型別系統中 (的屬性型別， <xref:System.Xaml.XamlMember.TargetType%2A>) 必須能夠將目標型別視為 CLR 型別，以將實例傳回 xaml 物件寫入器。</span><span class="sxs-lookup"><span data-stu-id="c8ff8-149">In the absence of a text syntax or native XAML conversion and in the absence of further indirection, such as a markup extension usage, the type of a property (<xref:System.Xaml.XamlMember.TargetType%2A> in the XAML type system) must be able to return an instance to a XAML object writer by treating the target type as a CLR type.</span></span>

<span data-ttu-id="c8ff8-150">如果使用 XAML 2009，如果不符合先前的考慮， [X:Reference 標記延伸](xreference-markup-extension.md) 可以用來提供值;不過，這比型別定義問題更是使用問題。</span><span class="sxs-lookup"><span data-stu-id="c8ff8-150">If using XAML 2009, [x:Reference Markup Extension](xreference-markup-extension.md) can be used to provide values if the previous considerations are not met; however, that is more of a usage issue than a type definition issue.</span></span>

### <a name="events"></a><span data-ttu-id="c8ff8-151">事件</span><span class="sxs-lookup"><span data-stu-id="c8ff8-151">Events</span></span>

<span data-ttu-id="c8ff8-152">如果您將事件定義為公用 CLR 事件，XAML 型別系統可以將附隨報告為具有 as 的 <xref:System.Xaml.XamlMember.IsEvent%2A> 成員 `true` 。</span><span class="sxs-lookup"><span data-stu-id="c8ff8-152">If you define events as a public CLR event, the XAML type system can report the event as a member with <xref:System.Xaml.XamlMember.IsEvent%2A> as `true`.</span></span> <span data-ttu-id="c8ff8-153">連接事件處理常式不在 .NET XAML 服務功能的範圍內;線路會留給特定的架構和實施。</span><span class="sxs-lookup"><span data-stu-id="c8ff8-153">Wiring the event handlers is not within the scope of .NET XAML Services capabilities; wiring is left to specific frameworks and implementations.</span></span>

### <a name="methods"></a><span data-ttu-id="c8ff8-154">方法</span><span class="sxs-lookup"><span data-stu-id="c8ff8-154">Methods</span></span>

<span data-ttu-id="c8ff8-155">方法的內嵌程式碼不是預設的 XAML 功能。</span><span class="sxs-lookup"><span data-stu-id="c8ff8-155">Inline code for methods is not a default XAML capability.</span></span> <span data-ttu-id="c8ff8-156">在大多數情況下，您不會直接從 XAML 參考方法成員，而 XAML 中方法的角色只是提供對特定 XAML 模式的支援。</span><span class="sxs-lookup"><span data-stu-id="c8ff8-156">In most cases, you do not directly reference method members from XAML, and the role of methods in XAML is only to provide support for specific XAML patterns.</span></span> <span data-ttu-id="c8ff8-157">[x:FactoryMethod](xfactorymethod-directive.md) 指示詞是例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c8ff8-157">[x:FactoryMethod Directive](xfactorymethod-directive.md) is an exception.</span></span>

### <a name="fields"></a><span data-ttu-id="c8ff8-158">欄位</span><span class="sxs-lookup"><span data-stu-id="c8ff8-158">Fields</span></span>

<span data-ttu-id="c8ff8-159">CLR 設計方針不鼓勵非靜態欄位。</span><span class="sxs-lookup"><span data-stu-id="c8ff8-159">CLR design guidelines discourage nonstatic fields.</span></span> <span data-ttu-id="c8ff8-160">針對靜態欄位，您只能透過 [X:Static 標記延伸](xstatic-markup-extension.md)來存取靜態域值;在此情況下，您不會在 CLR 定義中執行任何特殊作業來公開 [x:Static](xstatic-markup-extension.md) 使用的欄位。</span><span class="sxs-lookup"><span data-stu-id="c8ff8-160">For static fields, you can access static field values only through [x:Static Markup Extension](xstatic-markup-extension.md); in this case you are not doing anything special in the CLR definition to expose a field for [x:Static](xstatic-markup-extension.md) usages.</span></span>

## <a name="attachable-members"></a><span data-ttu-id="c8ff8-161">可附加成員</span><span class="sxs-lookup"><span data-stu-id="c8ff8-161">Attachable Members</span></span>

<span data-ttu-id="c8ff8-162">可附加的成員會透過定義型別的存取子方法模式，對 XAML 公開。</span><span class="sxs-lookup"><span data-stu-id="c8ff8-162">Attachable members are exposed to XAML through an accessor method pattern on a defining type.</span></span> <span data-ttu-id="c8ff8-163">定義型別本身不需要當做物件使用 XAML。</span><span class="sxs-lookup"><span data-stu-id="c8ff8-163">The defining type itself does not need to be XAML-usable as an object.</span></span> <span data-ttu-id="c8ff8-164">事實上，常見的模式是宣告服務類別，其角色是擁有可附加的成員並執行相關的行為，但不提供任何其他功能（例如 UI 標記法）。</span><span class="sxs-lookup"><span data-stu-id="c8ff8-164">In fact, a common pattern is to declare a service class whose role is to own the attachable member and implement the related behaviors, but serve no other function such as a UI representation.</span></span> <span data-ttu-id="c8ff8-165">在下列各節中，預留位置 *屬性* 名稱代表可附加成員的名稱。</span><span class="sxs-lookup"><span data-stu-id="c8ff8-165">For the following sections, the placeholder *PropertyName* represents the name of your attachable member.</span></span> <span data-ttu-id="c8ff8-166">該名稱在 [XamlName 文法](xamlname-grammar.md)中必須是有效的。</span><span class="sxs-lookup"><span data-stu-id="c8ff8-166">That name must be valid in the [XamlName Grammar](xamlname-grammar.md).</span></span>

<span data-ttu-id="c8ff8-167">請注意這些模式與類型的其他方法之間的名稱衝突。</span><span class="sxs-lookup"><span data-stu-id="c8ff8-167">Be cautious of name collisions between these patterns and other methods of a type.</span></span> <span data-ttu-id="c8ff8-168">如果有符合其中一個模式的成員存在，則它可以被 XAML 處理器視為可附加的成員使用路徑，即使這不是您的目的。</span><span class="sxs-lookup"><span data-stu-id="c8ff8-168">If a member exists that matches one of the patterns, it can be interpreted as an attachable member usage pathway by a XAML processor even if that was not your intention.</span></span>

#### <a name="the-getpropertyname-accessor"></a><span data-ttu-id="c8ff8-169">GetPropertyName 存取子</span><span class="sxs-lookup"><span data-stu-id="c8ff8-169">The GetPropertyName Accessor</span></span>

<span data-ttu-id="c8ff8-170">存取子的簽章 `GetPropertyName` 必須是：</span><span class="sxs-lookup"><span data-stu-id="c8ff8-170">The signature for the `GetPropertyName` accessor must be:</span></span>

`public static object GetPropertyName(object target)`

- <span data-ttu-id="c8ff8-171">`target` 物件可以指定為實作中的更特定類型。</span><span class="sxs-lookup"><span data-stu-id="c8ff8-171">The `target` object can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="c8ff8-172">您可以使用此值來限定可附加成員的使用方式;預期範圍之外的使用方式將會擲回不正確轉換例外狀況，然後由 XAML 剖析錯誤呈現。</span><span class="sxs-lookup"><span data-stu-id="c8ff8-172">You can use this to scope the usage of your attachable member; usages outside your intended scope will throw invalid cast exceptions that are then surfaced by a XAML parse error.</span></span> <span data-ttu-id="c8ff8-173">參數名稱不是必要的 `target` ，但 `target` 在大部分的執行中依慣例命名。</span><span class="sxs-lookup"><span data-stu-id="c8ff8-173">The parameter name `target` is not a requirement, but is named `target` by convention in most implementations.</span></span>

- <span data-ttu-id="c8ff8-174">傳回值可以指定為實作中的更特定類型。</span><span class="sxs-lookup"><span data-stu-id="c8ff8-174">The return value can be specified as a more specific type in your implementation.</span></span>

<span data-ttu-id="c8ff8-175">若要 <xref:System.ComponentModel.TypeConverter> 針對可附加成員的屬性用法支援啟用的文字語法，請套用 <xref:System.ComponentModel.TypeConverterAttribute> 至存取子 `GetPropertyName` 。</span><span class="sxs-lookup"><span data-stu-id="c8ff8-175">To support a <xref:System.ComponentModel.TypeConverter> enabled text syntax for attribute usage of the attachable member, apply <xref:System.ComponentModel.TypeConverterAttribute> to the `GetPropertyName` accessor.</span></span> <span data-ttu-id="c8ff8-176">套用至 `get` 而不是 `set` 直覺化; 不過，這個慣例可支援可序列化之唯讀可附加成員的概念，在設計工具案例中很有用。</span><span class="sxs-lookup"><span data-stu-id="c8ff8-176">Applying to the `get` instead of the `set` may seem non-intuitive; however, this convention can support the concept of read-only attachable members that are serializable, which is useful in designer scenarios.</span></span>

#### <a name="the-setpropertyname-accessor"></a><span data-ttu-id="c8ff8-177">SetPropertyName 存取子</span><span class="sxs-lookup"><span data-stu-id="c8ff8-177">The SetPropertyName Accessor</span></span>

<span data-ttu-id="c8ff8-178">存取子的簽章 `SetPropertyName` 必須是：</span><span class="sxs-lookup"><span data-stu-id="c8ff8-178">The signature for the `SetPropertyName` accessor must be:</span></span>

`public static void SetPropertyName(object target, object value)`

- <span data-ttu-id="c8ff8-179">`target`您可以將物件指定為您的實作為中的更特定類型，具有與上一節所述相同的邏輯和結果。</span><span class="sxs-lookup"><span data-stu-id="c8ff8-179">The `target` object can be specified as a more specific type in your implementation, with same logic and consequences as described in the previous section.</span></span>

- <span data-ttu-id="c8ff8-180">`value` 物件可以指定為實作中的更特定類型。</span><span class="sxs-lookup"><span data-stu-id="c8ff8-180">The `value` object can be specified as a more specific type in your implementation.</span></span>

<span data-ttu-id="c8ff8-181">請記住，這個方法的值是來自 XAML 使用方式的輸入，通常是在屬性表單中。</span><span class="sxs-lookup"><span data-stu-id="c8ff8-181">Remember that the value for this method is the input coming from the XAML usage, typically in attribute form.</span></span> <span data-ttu-id="c8ff8-182">在屬性表單中，必須有 text 語法的值轉換器支援，而且您可以在 s 存取子上進行屬性 `GetPropertyName` 。</span><span class="sxs-lookup"><span data-stu-id="c8ff8-182">From attribute form there must be value converter support for a text syntax, and you attribute on the `GetPropertyName`s accessor.</span></span>

### <a name="attachable-member-stores"></a><span data-ttu-id="c8ff8-183">可附加的成員存放區</span><span class="sxs-lookup"><span data-stu-id="c8ff8-183">Attachable Member Stores</span></span>

<span data-ttu-id="c8ff8-184">存取子方法通常不足以提供方法，將可附加的成員值放入物件圖形中，或從物件圖形取出值並正確地加以序列化。</span><span class="sxs-lookup"><span data-stu-id="c8ff8-184">The accessor methods are typically not enough to provide a means to place attachable member values into an object graph, or to retrieve values out of the object graph and serialize them properly.</span></span> <span data-ttu-id="c8ff8-185">若要提供這項功能，先前存取子簽章 `target` 中的物件必須能夠儲存值。</span><span class="sxs-lookup"><span data-stu-id="c8ff8-185">To provide this functionality, the `target` objects in the previous accessor signatures must be capable of storing values.</span></span> <span data-ttu-id="c8ff8-186">儲存機制應該與可附加的成員主體一致，該成員可附加至可附加成員不在成員清單中的目標。</span><span class="sxs-lookup"><span data-stu-id="c8ff8-186">The storage mechanism should be consistent with the attachable member principle that the member is attachable to targets where the attachable member is not in the members list.</span></span> <span data-ttu-id="c8ff8-187">.NET XAML 服務透過 Api 和提供可附加的成員存放區的實作為方法 <xref:System.Xaml.IAttachedPropertyStore> <xref:System.Xaml.AttachablePropertyServices> 。</span><span class="sxs-lookup"><span data-stu-id="c8ff8-187">.NET XAML Services provides an implementation technique for attachable member stores through the APIs <xref:System.Xaml.IAttachedPropertyStore> and <xref:System.Xaml.AttachablePropertyServices>.</span></span> <span data-ttu-id="c8ff8-188"><xref:System.Xaml.IAttachedPropertyStore> XAML 寫入器會使用來探索存放區的執行，而且應該在存取子的類型上執行 `target` 。</span><span class="sxs-lookup"><span data-stu-id="c8ff8-188"><xref:System.Xaml.IAttachedPropertyStore> is used by the XAML writers to discover the store implementation, and should be implemented on the type that is the `target` of the accessors.</span></span> <span data-ttu-id="c8ff8-189">靜態 <xref:System.Xaml.AttachablePropertyServices> api 用於存取子的主體內，並由其參考可附加的成員 <xref:System.Xaml.AttachableMemberIdentifier> 。</span><span class="sxs-lookup"><span data-stu-id="c8ff8-189">The static <xref:System.Xaml.AttachablePropertyServices> APIs are used within the body of the accessors, and refer to the attachable member by its <xref:System.Xaml.AttachableMemberIdentifier>.</span></span>

## <a name="xaml-related-clr-attributes"></a><span data-ttu-id="c8ff8-190">XAML 相關 CLR 屬性</span><span class="sxs-lookup"><span data-stu-id="c8ff8-190">XAML-Related CLR Attributes</span></span>

<span data-ttu-id="c8ff8-191">正確地將型別、成員和元件的特性化，是為了將 XAML 類型系統資訊回報給 .NET XAML 服務的重要。</span><span class="sxs-lookup"><span data-stu-id="c8ff8-191">Correctly attributing your types, members, and assemblies is important in order to report XAML type system information to .NET XAML Services.</span></span> <span data-ttu-id="c8ff8-192">如果適用下列其中一種情況，則報告 XAML 類型系統資訊是相關的：</span><span class="sxs-lookup"><span data-stu-id="c8ff8-192">Reporting XAML type system information is relevant if either of the following situations apply:</span></span>

- <span data-ttu-id="c8ff8-193">您想要搭配直接以 .NET XAML 服務 XAML 讀取器和 XAML 寫入器為基礎的 XAML 系統使用類型。</span><span class="sxs-lookup"><span data-stu-id="c8ff8-193">You intend your types for use with XAML systems that are directly based on .NET XAML Services XAML readers and XAML writers.</span></span>
- <span data-ttu-id="c8ff8-194">您可以根據 xaml 讀取器和 XAML 寫入器，定義或使用以 XAML 為基礎的架構。</span><span class="sxs-lookup"><span data-stu-id="c8ff8-194">You define or use a XAML-utilizing framework that's based on those XAML readers and XAML writers.</span></span>

<span data-ttu-id="c8ff8-195">如需與自訂類型的 XAML 支援相關之每個 XAML 相關屬性的清單，請參閱 [自訂類型和程式庫的 Xaml 相關 CLR 屬性](clr-attributes-with-custom-types-and-libraries.md)。</span><span class="sxs-lookup"><span data-stu-id="c8ff8-195">For a listing of each XAML-related attribute that's relevant for XAML support of your custom types, see [XAML-Related CLR Attributes for Custom Types and Libraries](clr-attributes-with-custom-types-and-libraries.md).</span></span>

## <a name="usage"></a><span data-ttu-id="c8ff8-196">使用方式</span><span class="sxs-lookup"><span data-stu-id="c8ff8-196">Usage</span></span>

<span data-ttu-id="c8ff8-197">使用自訂類型時，標記作者必須針對包含自訂類型的元件和 CLR 命名空間對應前置詞。</span><span class="sxs-lookup"><span data-stu-id="c8ff8-197">Usage of custom types requires that the markup author must map a prefix for the assembly and CLR namespace that contain the custom type.</span></span> <span data-ttu-id="c8ff8-198">本主題未記載此程式。</span><span class="sxs-lookup"><span data-stu-id="c8ff8-198">This procedure is not documented in this topic.</span></span>

## <a name="access-level"></a><span data-ttu-id="c8ff8-199">存取層級</span><span class="sxs-lookup"><span data-stu-id="c8ff8-199">Access Level</span></span>

<span data-ttu-id="c8ff8-200">XAML 提供載入和具現化具有存取層級之類型的方法 `internal` 。</span><span class="sxs-lookup"><span data-stu-id="c8ff8-200">XAML provides a means to load and instantiate types that have an `internal` access level.</span></span> <span data-ttu-id="c8ff8-201">提供這項功能的目的是讓使用者程式碼可以定義自己的型別，然後從同時也屬於相同使用者程式碼範圍的標記將這些類別具現化。</span><span class="sxs-lookup"><span data-stu-id="c8ff8-201">This capability is provided so that user code can define its own types, and then instantiate those classes from markup that is also part of the same user code scope.</span></span>

<span data-ttu-id="c8ff8-202">WPF 中的一個範例，就是當使用者程式碼定義了，其 <xref:System.Windows.Controls.UserControl> 目的是要做為重構 UI 行為的方式，但不是任何可能的擴充機制的一部分，因為宣告支援的類別具有 `public` 存取層級。</span><span class="sxs-lookup"><span data-stu-id="c8ff8-202">An example from WPF is whenever user code defines a <xref:System.Windows.Controls.UserControl> that is intended as a way to refactor a UI behavior, but not as part of any possible extension mechanism that might be implied by declaring the supporting class with `public` access level.</span></span> <span data-ttu-id="c8ff8-203"><xref:System.Windows.Controls.UserControl> `internal` 如果支援的程式碼編譯成相同的元件，而這些程式碼會被視為 XAML 型別，則可以使用存取權來宣告這類。</span><span class="sxs-lookup"><span data-stu-id="c8ff8-203">Such a <xref:System.Windows.Controls.UserControl> can be declared with `internal` access if the backing code is compiled into the same assembly from which it is referenced as a XAML type.</span></span>

<span data-ttu-id="c8ff8-204">對於在完全信任和使用下載入 XAML 的應用程式 <xref:System.Xaml.XamlObjectWriter> ， `internal` 一律會啟用以存取層級載入類別的功能。</span><span class="sxs-lookup"><span data-stu-id="c8ff8-204">For an application that loads XAML under full trust and uses <xref:System.Xaml.XamlObjectWriter>, loading classes with `internal` access level is always enabled.</span></span>

<span data-ttu-id="c8ff8-205">針對在部分信任下載入 XAML 的應用程式，您可以使用 API 來控制存取層級的特性 <xref:System.Xaml.Permissions.XamlAccessLevel> 。</span><span class="sxs-lookup"><span data-stu-id="c8ff8-205">For an application that loads XAML under partial trust, you can control the access level characteristics by using the <xref:System.Xaml.Permissions.XamlAccessLevel> API.</span></span> <span data-ttu-id="c8ff8-206">此外，延遲機制 (例如 WPF 範本系統) 必須能夠傳播任何存取層級許可權，並保留這些許可權以進行最終的執行時間評估;這會藉由傳遞資訊在內部處理 <xref:System.Xaml.Permissions.XamlAccessLevel> 。</span><span class="sxs-lookup"><span data-stu-id="c8ff8-206">Also, deferral mechanisms (such as the WPF template system) must be able to propagate any access level permissions and preserve them for the eventual run time evaluations; this is handled internally by passing the <xref:System.Xaml.Permissions.XamlAccessLevel> information.</span></span>

### <a name="wpf-implementation"></a><span data-ttu-id="c8ff8-207">WPF 執行</span><span class="sxs-lookup"><span data-stu-id="c8ff8-207">WPF Implementation</span></span>

<span data-ttu-id="c8ff8-208">WPF XAML 使用部分信任存取模型，其中如果 BAML 是在部分信任下載入，則會限制為 <xref:System.Xaml.Permissions.XamlAccessLevel.AssemblyAccessTo%2A> baml 來源元件的存取權。</span><span class="sxs-lookup"><span data-stu-id="c8ff8-208">WPF XAML uses a partial-trust access model where if BAML is loaded under partial trust, access is restricted to <xref:System.Xaml.Permissions.XamlAccessLevel.AssemblyAccessTo%2A> for the assembly that is the BAML source.</span></span> <span data-ttu-id="c8ff8-209">針對延遲，WPF 會使用 <xref:System.Xaml.IXamlObjectWriterFactory.GetParentSettings%2A?displayProperty=nameWithType> 做為傳遞存取層級資訊的機制。</span><span class="sxs-lookup"><span data-stu-id="c8ff8-209">For deferral, WPF uses <xref:System.Xaml.IXamlObjectWriterFactory.GetParentSettings%2A?displayProperty=nameWithType> as a mechanism for passing the access level information.</span></span>

<span data-ttu-id="c8ff8-210">在 WPF XAML 術語中， *內部型* 別是由相同元件所定義的型別，也包括參考的 XAML。</span><span class="sxs-lookup"><span data-stu-id="c8ff8-210">In WPF XAML terminology, an *internal type* is a type that is defined by the same assembly that also includes the referencing XAML.</span></span> <span data-ttu-id="c8ff8-211">這類型別可透過 XAML 命名空間進行對應，該命名空間會刻意省略對應的元件 = 部分，例如 `xmlns:local="clr-namespace:WPFApplication1"` 。</span><span class="sxs-lookup"><span data-stu-id="c8ff8-211">Such a type can be mapped through a XAML namespace that deliberately omits the assembly= portion of a mapping, for example, `xmlns:local="clr-namespace:WPFApplication1"`.</span></span> <span data-ttu-id="c8ff8-212">如果 BAML 參考內部型別，而該型別具有 `internal` 存取層級， `GeneratedInternalTypeHelper` 則會產生元件的類別。</span><span class="sxs-lookup"><span data-stu-id="c8ff8-212">If BAML references an internal type and that type has `internal` access level, this generates a `GeneratedInternalTypeHelper` class for the assembly.</span></span> <span data-ttu-id="c8ff8-213">如果您想要避免 `GeneratedInternalTypeHelper` ，您必須使用 `public` 存取層級，或必須將相關的類別納入不同的元件，並使該元件相依。</span><span class="sxs-lookup"><span data-stu-id="c8ff8-213">If you want to avoid `GeneratedInternalTypeHelper`, you either must use `public` access level, or must factor the relevant class into a separate assembly and make that assembly dependent.</span></span>

## <a name="see-also"></a><span data-ttu-id="c8ff8-214">另請參閱</span><span class="sxs-lookup"><span data-stu-id="c8ff8-214">See also</span></span>

- [<span data-ttu-id="c8ff8-215">自訂類型和程式庫的 XAML 相關 CLR 屬性</span><span class="sxs-lookup"><span data-stu-id="c8ff8-215">XAML-Related CLR Attributes for Custom Types and Libraries</span></span>](clr-attributes-with-custom-types-and-libraries.md)
- [<span data-ttu-id="c8ff8-216">XAML 服務</span><span class="sxs-lookup"><span data-stu-id="c8ff8-216">XAML Services</span></span>](../../../api/index.md)
