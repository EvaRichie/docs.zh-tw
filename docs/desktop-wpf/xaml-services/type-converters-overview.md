---
title: XAML 類型轉換子概觀
ms.date: 03/30/2017
helpviewer_keywords:
- XAML [XAML Services], type converters
- XAML [XAML Services], TypeConverter
- type conversion for XAML [XAML Services]
ms.assetid: 51a65860-efcb-4fe0-95a0-1c679cde66b7
ms.openlocfilehash: 6e78210178fda65bb3baad0d24eb3a20cd6f2a3e
ms.sourcegitcommit: 27a15a55019f6b5f2733961738babe94aec0def3
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 09/15/2020
ms.locfileid: "90540109"
---
# <a name="overview-of-type-converters-for-xaml"></a><span data-ttu-id="30a13-102">XAML 的類型轉換器總覽</span><span class="sxs-lookup"><span data-stu-id="30a13-102">Overview of type converters for XAML</span></span>

<span data-ttu-id="30a13-103">物件寫入器的類型轉換器供應邏輯，可將 XAML 標記中的字串轉換為物件圖形中的特定物件。</span><span class="sxs-lookup"><span data-stu-id="30a13-103">Type converters supply logic for an object writer that converts from a string in XAML markup into particular objects in an object graph.</span></span> <span data-ttu-id="30a13-104">在 .NET XAML 服務中，類型轉換器必須是衍生自的類別 <xref:System.ComponentModel.TypeConverter> 。</span><span class="sxs-lookup"><span data-stu-id="30a13-104">In .NET XAML Services, the type converter must be a class that derives from <xref:System.ComponentModel.TypeConverter>.</span></span> <span data-ttu-id="30a13-105">有些轉換器也支援 XAML 儲存路徑，而且可用來將序列化標記中的物件序列化成字串格式。</span><span class="sxs-lookup"><span data-stu-id="30a13-105">Some converters also support the XAML save path and can be used to serialize an object into a string form in serialization markup.</span></span> <span data-ttu-id="30a13-106">本主題描述如何以及何時叫用 XAML 中的類型轉換器，並提供 <xref:System.ComponentModel.TypeConverter>之方法覆寫的實作建議。</span><span class="sxs-lookup"><span data-stu-id="30a13-106">This topic describes how and when type converters in XAML are invoked, and provides implementation advice for the method overrides of <xref:System.ComponentModel.TypeConverter>.</span></span>

## <a name="type-conversion-concepts"></a><span data-ttu-id="30a13-107">類型轉換概念</span><span class="sxs-lookup"><span data-stu-id="30a13-107">Type Conversion Concepts</span></span>

<span data-ttu-id="30a13-108">下列各節說明 XAML 如何使用字串的基本概念，以及 .NET XAML 服務中的物件寫入器如何使用類型轉換器來處理 XAML 來源中遇到的某些字串值。</span><span class="sxs-lookup"><span data-stu-id="30a13-108">The following sections explain basic concepts about how XAML uses strings, and how object writers in .NET XAML Services use type converters to process some of the string values that are encountered in a XAML source.</span></span>

### <a name="xaml-and-string-values"></a><span data-ttu-id="30a13-109">XAML 和字串值</span><span class="sxs-lookup"><span data-stu-id="30a13-109">XAML and String Values</span></span>

<span data-ttu-id="30a13-110">在 XAML 檔案中設定屬性值時，該值的初始類型是一般感應器中的字串，以及 XML 感應器中的字串屬性值。</span><span class="sxs-lookup"><span data-stu-id="30a13-110">When you set an attribute value in a XAML file, the initial type of that value is a string in a general sense, and a string attribute value in an XML sense.</span></span> <span data-ttu-id="30a13-111">甚至，其他基本類型 (例如 <xref:System.Double> ) 一開始是 XAML 處理器的字串。</span><span class="sxs-lookup"><span data-stu-id="30a13-111">Even other primitives such as <xref:System.Double> are initially strings to a XAML processor.</span></span>

<span data-ttu-id="30a13-112">在大部分情況下，XAML 處理器需要兩項資訊才能處理屬性值。</span><span class="sxs-lookup"><span data-stu-id="30a13-112">In most cases, a XAML processor needs two pieces of information to process an attribute value.</span></span> <span data-ttu-id="30a13-113">第一項資訊是正在設定之屬性的實值類型。</span><span class="sxs-lookup"><span data-stu-id="30a13-113">The first piece of information is the value type of the property that is being set.</span></span> <span data-ttu-id="30a13-114">任何定義屬性值並在 XAML 中處理的字串最後必須轉換或解析成該類型的值。</span><span class="sxs-lookup"><span data-stu-id="30a13-114">Any string that defines an attribute value and that is processed in XAML must ultimately be converted or resolved to a value of that type.</span></span> <span data-ttu-id="30a13-115">如果值是 XAML 剖析器可理解的基本類型 (例如數值)，則會嘗試直接轉換字串。</span><span class="sxs-lookup"><span data-stu-id="30a13-115">If the value is a primitive that is understood by the XAML parser (such as a numeric value), a direct conversion of the string is attempted.</span></span> <span data-ttu-id="30a13-116">如果屬性的值參考列舉，則會檢查提供的字串是否有該列舉中具名常數的名稱相符項。</span><span class="sxs-lookup"><span data-stu-id="30a13-116">If the value for the attribute references an enumeration, the supplied string is checked for a name match to a named constant in that enumeration.</span></span> <span data-ttu-id="30a13-117">如果值不是剖析器理解的基本類型或列舉中的常數名稱，適用的型別必須能夠提供以轉換過的字串為基礎的值或參考。</span><span class="sxs-lookup"><span data-stu-id="30a13-117">If the value is not a parser-understood primitive or a constant name from an enumeration, the applicable type must be able to provide a value or reference that is based on a converted string.</span></span>

> [!NOTE]
> <span data-ttu-id="30a13-118">XAML 語言指示詞不會使用類型轉換器。</span><span class="sxs-lookup"><span data-stu-id="30a13-118">XAML language directives do not use type converters.</span></span>

### <a name="type-converters-and-markup-extensions"></a><span data-ttu-id="30a13-119">類型轉換器和標記延伸</span><span class="sxs-lookup"><span data-stu-id="30a13-119">Type Converters and Markup Extensions</span></span>

<span data-ttu-id="30a13-120">XAML 處理器必須先處理標記延伸使用方式，才會檢查屬性類型和其他考量。</span><span class="sxs-lookup"><span data-stu-id="30a13-120">Markup extension usages must be handled by a XAML processor before it checks for property type and other considerations.</span></span> <span data-ttu-id="30a13-121">例如，如果設為屬性 (Attribute) 的屬性 (Property) 通常具有類型轉換，但在特定情況下是由標記延伸使用方式所設定，則會先處理標記延伸行為。</span><span class="sxs-lookup"><span data-stu-id="30a13-121">For example, if a property being set as an attribute normally has a type conversion, but in a particular case is set by a markup extension usage, then the markup extension behavior processes first.</span></span> <span data-ttu-id="30a13-122">需要有標記延伸的一個常見情況是參考現有的物件。</span><span class="sxs-lookup"><span data-stu-id="30a13-122">One common situation where a markup extension is necessary is to make a reference to an object that already exists.</span></span> <span data-ttu-id="30a13-123">在此案例中，無狀態類型轉換器只能產生新的執行個體，但這可能不是令人滿意的情況。</span><span class="sxs-lookup"><span data-stu-id="30a13-123">For this scenario, a stateless type converter can only generate a new instance, which might not be desirable.</span></span> <span data-ttu-id="30a13-124">如需標記延伸的詳細資訊，請參閱 [Markup Extensions for XAML Overview](markup-extensions-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="30a13-124">For more information about markup extensions, see [Markup Extensions for XAML Overview](markup-extensions-overview.md).</span></span>

### <a name="native-type-converters"></a><span data-ttu-id="30a13-125">原生類型轉換器</span><span class="sxs-lookup"><span data-stu-id="30a13-125">Native Type Converters</span></span>

<span data-ttu-id="30a13-126">在 Windows Presentation Foundation (WPF) 和 .NET XAML 服務執行中，有一些具有原生類型轉換處理的 CLR 類型。</span><span class="sxs-lookup"><span data-stu-id="30a13-126">In the Windows Presentation Foundation (WPF) and .NET XAML services implementations, there are certain CLR types that have native type conversion handling.</span></span> <span data-ttu-id="30a13-127">不過，這些 CLR 型別並不會被視為基本類型。</span><span class="sxs-lookup"><span data-stu-id="30a13-127">However, those CLR types are not conventionally thought of as primitives.</span></span> <span data-ttu-id="30a13-128">這類類型的範例是 <xref:System.DateTime>。</span><span class="sxs-lookup"><span data-stu-id="30a13-128">An example of such a type is <xref:System.DateTime>.</span></span> <span data-ttu-id="30a13-129">其中一個原因是 .NET Framework 架構的運作方式：類型 <xref:System.DateTime> 定義於 mscorlib (.NET 中的最基本程式庫)。</span><span class="sxs-lookup"><span data-stu-id="30a13-129">One reason for this is how the .NET Framework architecture works: the type <xref:System.DateTime> is defined in mscorlib, the most basic library in .NET.</span></span> <span data-ttu-id="30a13-130"><xref:System.DateTime> 不允許使用來自另一個引入相依性之元件的屬性進行屬性化， (<xref:System.ComponentModel.TypeConverterAttribute> 是從系統) 。</span><span class="sxs-lookup"><span data-stu-id="30a13-130"><xref:System.DateTime> is not permitted to be attributed with an attribute that comes from another assembly that introduces a dependency (<xref:System.ComponentModel.TypeConverterAttribute> is from System).</span></span> <span data-ttu-id="30a13-131">因此，不支援使用一般型別轉換子探索機制。</span><span class="sxs-lookup"><span data-stu-id="30a13-131">Therefore, the usual type converter discovery mechanism by attributing cannot be supported.</span></span> <span data-ttu-id="30a13-132">而是，XAML 剖析器都有一份需要原生處理的類型清單，而且這些類型的處理方式與 true 基本類型的處理方式類似。</span><span class="sxs-lookup"><span data-stu-id="30a13-132">Instead, the XAML parser has a list of types that need native processing, and it processes these types similar to how the true primitives are processed.</span></span> <span data-ttu-id="30a13-133">如果是 <xref:System.DateTime>則此處理包含 <xref:System.DateTime.Parse%2A>呼叫。</span><span class="sxs-lookup"><span data-stu-id="30a13-133">In the case of <xref:System.DateTime>, this processing involves a call to <xref:System.DateTime.Parse%2A>.</span></span>

## <a name="implementing-a-type-converter"></a><span data-ttu-id="30a13-134">實作類型轉換器</span><span class="sxs-lookup"><span data-stu-id="30a13-134">Implementing a Type Converter</span></span>

<span data-ttu-id="30a13-135">下列章節討論 <xref:System.ComponentModel.TypeConverter> 類別的 API。</span><span class="sxs-lookup"><span data-stu-id="30a13-135">The following sections discuss the API of the <xref:System.ComponentModel.TypeConverter> class.</span></span>

### <a name="typeconverter"></a><span data-ttu-id="30a13-136">TypeConverter</span><span class="sxs-lookup"><span data-stu-id="30a13-136">TypeConverter</span></span>

<span data-ttu-id="30a13-137">在 .NET XAML 服務下，用於 XAML 用途的所有類型轉換器都是衍生自基類的類別 <xref:System.ComponentModel.TypeConverter> 。</span><span class="sxs-lookup"><span data-stu-id="30a13-137">Under .NET XAML Services, all type converters that are used for XAML purposes are classes that derive from the base class <xref:System.ComponentModel.TypeConverter>.</span></span> <span data-ttu-id="30a13-138"><xref:System.ComponentModel.TypeConverter> 類別要先存在於 .NET Framework 版本中，XAML 才會存在；其中一個原始 <xref:System.ComponentModel.TypeConverter> 案例是提供視覺化設計工具中屬性編輯器的字串轉換。</span><span class="sxs-lookup"><span data-stu-id="30a13-138">The <xref:System.ComponentModel.TypeConverter> class existed in versions of the .NET Framework before XAML existed; one of the original <xref:System.ComponentModel.TypeConverter> scenarios was to provide string conversion for property editors in visual designers.</span></span>

<span data-ttu-id="30a13-139">針對 XAML，會展開 <xref:System.ComponentModel.TypeConverter> 的角色。</span><span class="sxs-lookup"><span data-stu-id="30a13-139">For XAML, the role of <xref:System.ComponentModel.TypeConverter> is expanded.</span></span> <span data-ttu-id="30a13-140">基於 XAML， <xref:System.ComponentModel.TypeConverter> 是支援特定目標字串與來源字串轉換的基底類別。</span><span class="sxs-lookup"><span data-stu-id="30a13-140">For XAML purposes, <xref:System.ComponentModel.TypeConverter> is the base class for providing support for certain to-string and from-string conversions.</span></span> <span data-ttu-id="30a13-141">來源字串會從 XAML 剖析字串屬性值。</span><span class="sxs-lookup"><span data-stu-id="30a13-141">From-string enables parsing a string attribute value from XAML.</span></span> <span data-ttu-id="30a13-142">目標字串可能會讓特定物件屬性的執行階段值處理回 XAML 中的屬性，以進行序列化。</span><span class="sxs-lookup"><span data-stu-id="30a13-142">To-string might enable processing a run-time value of a particular object property back into an attribute in XAML for serialization.</span></span>

<span data-ttu-id="30a13-143"><xref:System.ComponentModel.TypeConverter> 定義四個成員，而這些成員與基於 XAML 處理轉換目標字串和來源字串有關：</span><span class="sxs-lookup"><span data-stu-id="30a13-143"><xref:System.ComponentModel.TypeConverter> defines four members that are relevant for converting to-string and from-string for XAML processing purposes:</span></span>

- <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A>

- <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A>

- <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>

- <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>

<span data-ttu-id="30a13-144">在這些成員中，最重要的方法是 <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>，可將輸入字串轉換成所需的物件類型。</span><span class="sxs-lookup"><span data-stu-id="30a13-144">Of these members, the most important method is <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>, which converts the input string to the required object type.</span></span> <span data-ttu-id="30a13-145"><xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> 方法可以實作以將更廣泛範圍的類型轉換為轉換器的預定目的地類型。</span><span class="sxs-lookup"><span data-stu-id="30a13-145">The <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> method can be implemented to convert a wider range of types into the intended destination type of the converter.</span></span> <span data-ttu-id="30a13-146">因此，它可以提供不僅 XAML 的用途，例如支援執行階段轉換。</span><span class="sxs-lookup"><span data-stu-id="30a13-146">Therefore, it can serve purposes that extend beyond XAML, such as supporting run-time conversions.</span></span> <span data-ttu-id="30a13-147">不過，對於 XAML 使用，只有可處理 <xref:System.String> 輸入的程式碼路徑才重要。</span><span class="sxs-lookup"><span data-stu-id="30a13-147">However, for XAML use, only the code path that can process a <xref:System.String> input is important.</span></span>

<span data-ttu-id="30a13-148">第二個最重要的方法是 <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> 。</span><span class="sxs-lookup"><span data-stu-id="30a13-148">The second-most important method is <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>.</span></span> <span data-ttu-id="30a13-149">如果應用程式轉換成標記標記法 (例如，將它儲存至 XAML 做為檔案) ， <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> 就會牽涉到 xaml 文字寫入器的較大情節，以產生標記標記法。</span><span class="sxs-lookup"><span data-stu-id="30a13-149">If an application is converted to a markup representation (for example, if it is saved to XAML as a file), <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> is involved in the larger scenario of a XAML text writer to produce a markup representation.</span></span> <span data-ttu-id="30a13-150">在此情況下，XAML 的重要程式碼路徑是呼叫端通過 `destinationType` 的 <xref:System.String>時。</span><span class="sxs-lookup"><span data-stu-id="30a13-150">In this case, the important code path for XAML is when the caller passes a `destinationType` of <xref:System.String>.</span></span>

<span data-ttu-id="30a13-151"><xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> 和 <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> 是服務查詢 <xref:System.ComponentModel.TypeConverter> 實作之功能時所使用的支援方法。</span><span class="sxs-lookup"><span data-stu-id="30a13-151"><xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> and <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> are support methods that are used when a service queries the capabilities of the <xref:System.ComponentModel.TypeConverter> implementation.</span></span> <span data-ttu-id="30a13-152">您必須實作這些方法來傳回轉換器對等轉換方法所支援類型特有案例的 `true` 。</span><span class="sxs-lookup"><span data-stu-id="30a13-152">You must implement these methods to return `true` for type-specific cases that the equivalent conversion methods of your converter support.</span></span> <span data-ttu-id="30a13-153">基於 XAML，這通常表示 <xref:System.String> 類型。</span><span class="sxs-lookup"><span data-stu-id="30a13-153">For XAML purposes, this generally means the <xref:System.String> type.</span></span>

### <a name="culture-information-and-type-converters-for-xaml"></a><span data-ttu-id="30a13-154">XAML 的文化特性資訊和類型轉換器</span><span class="sxs-lookup"><span data-stu-id="30a13-154">Culture Information and Type Converters for XAML</span></span>

<span data-ttu-id="30a13-155">每個 <xref:System.ComponentModel.TypeConverter> 實作都可以唯一解譯轉換的有效字串，也可以使用或忽略傳遞為參數的類型描述。</span><span class="sxs-lookup"><span data-stu-id="30a13-155">Each <xref:System.ComponentModel.TypeConverter> implementation can uniquely interpret what is a valid string for a conversion, and it can also use or ignore the type description that is passed as parameters.</span></span> <span data-ttu-id="30a13-156">文化特性和 XAML 類型轉換的重要考量如下：雖然 XAML 支援使用可當地語系化字串做為屬性值，但是您無法使用這些可當地語系化字串做為具有特定文化特性需求的類型轉換器輸入。</span><span class="sxs-lookup"><span data-stu-id="30a13-156">An important consideration for culture and XAML type conversion is the following: although using localizable strings as attribute values is supported by XAML, you cannot use these localizable strings as type converter input with specific culture requirements.</span></span> <span data-ttu-id="30a13-157">這項限制是因為 XAML 屬性值的類型轉換器包含使用 `en-US` 文化特性的必要固定語言 XAML 處理行為。</span><span class="sxs-lookup"><span data-stu-id="30a13-157">This limitation is because type converters for XAML attribute values involve a necessarily fixed-language XAML-processing behavior that uses `en-US` culture.</span></span> <span data-ttu-id="30a13-158">如需這種限制的設計原因的詳細資訊，請參閱 XAML 語言規格 ([ \[ Ms-chap \] ](/previous-versions/msp-n-p/ff650760(v=pandp.10))) 或[WPF 全球化和當地語系化總覽](/dotnet/desktop/wpf/advanced/wpf-globalization-and-localization-overview)。</span><span class="sxs-lookup"><span data-stu-id="30a13-158">For more information about the design reasons for this restriction, see the XAML language specification ([\[MS-XAML\]](/previous-versions/msp-n-p/ff650760(v=pandp.10))) or [WPF Globalization and Localization Overview](/dotnet/desktop/wpf/advanced/wpf-globalization-and-localization-overview).</span></span>

<span data-ttu-id="30a13-159">在文化特性可能是問題的範例中，某些文化特性會使用逗號 (而非句號) 做為字串形式中數字的小數點分隔符號。</span><span class="sxs-lookup"><span data-stu-id="30a13-159">As an example where culture can be an issue, some cultures use a comma instead of a period as the decimal point delimiter for numbers in string form.</span></span> <span data-ttu-id="30a13-160">這項使用與許多現有類型轉換器的行為衝突，後者是使用逗號做為分隔符號。</span><span class="sxs-lookup"><span data-stu-id="30a13-160">This use collides with the behavior that many existing type converters have, which is to use a comma as a delimiter.</span></span> <span data-ttu-id="30a13-161">在周圍 XAML 中透過 `xml:lang` 傳遞文化特性並不能解決問題。</span><span class="sxs-lookup"><span data-stu-id="30a13-161">Passing a culture through `xml:lang` in the surrounding XAML does not solve the issue.</span></span>

### <a name="implementing-convertfrom"></a><span data-ttu-id="30a13-162">實作 ConvertFrom</span><span class="sxs-lookup"><span data-stu-id="30a13-162">Implementing ConvertFrom</span></span>

<span data-ttu-id="30a13-163">若要可做為支援 XAML 的 <xref:System.ComponentModel.TypeConverter> 實作來重複使用，該轉換器的 <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> 方法必須接受字串做為 `value` 參數。</span><span class="sxs-lookup"><span data-stu-id="30a13-163">To be usable as a <xref:System.ComponentModel.TypeConverter> implementation that supports XAML, the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> method for that converter must accept a string as the `value` parameter.</span></span> <span data-ttu-id="30a13-164">如果字串的格式有效，而且可以透過 <xref:System.ComponentModel.TypeConverter> 實作進行轉換，則傳回的物件必須支援轉型為屬性所預期的類型。</span><span class="sxs-lookup"><span data-stu-id="30a13-164">If the string is in a valid format and can be converted by the <xref:System.ComponentModel.TypeConverter> implementation, the returned object must support a cast to the type that is expected by the property.</span></span> <span data-ttu-id="30a13-165">否則， <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> 實作必須傳回 `null`。</span><span class="sxs-lookup"><span data-stu-id="30a13-165">Otherwise, the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> implementation must return `null`.</span></span>

<span data-ttu-id="30a13-166">每個 <xref:System.ComponentModel.TypeConverter> 實作都可以唯一解譯什麼可替代轉換的有效字串，也可以使用或忽略傳遞為參數的類型描述或文化特性內容。</span><span class="sxs-lookup"><span data-stu-id="30a13-166">Each <xref:System.ComponentModel.TypeConverter> implementation can uniquely interpret what constitutes a valid string for a conversion, and it can also use or ignore the type description or culture contexts that are passed as parameters.</span></span> <span data-ttu-id="30a13-167">不過，WPF XAML 處理可能不會在所有情況下都將值傳遞至類型描述內容，也可能不會根據 `xml:lang`來傳遞文化特性。</span><span class="sxs-lookup"><span data-stu-id="30a13-167">However, the WPF XAML processing might not pass values to the type description context in all cases and also might not pass culture based on `xml:lang`.</span></span>

> [!NOTE]
> <span data-ttu-id="30a13-168">請勿使用大括弧 ({}) ，尤其是左大括弧 ( {) ，作為字串格式的元素。</span><span class="sxs-lookup"><span data-stu-id="30a13-168">Do not use the braces ({}), specifically the opening brace ({), as an element of your string format.</span></span> <span data-ttu-id="30a13-169">這些字元保留做為標記延伸序列的進入及結束。</span><span class="sxs-lookup"><span data-stu-id="30a13-169">These characters are reserved as the entry and exit for a markup extension sequence.</span></span>

<span data-ttu-id="30a13-170">當您的型別轉換子必須有 .NET XAML 服務物件寫入器的 XAML 服務存取權時，才會擲回例外狀況，但對 <xref:System.IServiceProvider.GetService%2A> 內容所進行的呼叫不會傳回該服務。</span><span class="sxs-lookup"><span data-stu-id="30a13-170">It is appropriate to throw an exception when your type converter must have access to a XAML service from .NET XAML Services object writer, but the <xref:System.IServiceProvider.GetService%2A> call that is made against the context does not return that service.</span></span>

### <a name="implementing-convertto"></a><span data-ttu-id="30a13-171">實作 ConvertTo</span><span class="sxs-lookup"><span data-stu-id="30a13-171">Implementing ConvertTo</span></span>

<span data-ttu-id="30a13-172"><xref:System.ComponentModel.TypeConverter.ConvertTo%2A> 可能用於序列化支援。</span><span class="sxs-lookup"><span data-stu-id="30a13-172"><xref:System.ComponentModel.TypeConverter.ConvertTo%2A> is potentially used for serialization support.</span></span> <span data-ttu-id="30a13-173">透過自訂類型和其類型轉換器之 <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> 的序列化支援不是絕對需求。</span><span class="sxs-lookup"><span data-stu-id="30a13-173">Serialization support through <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> for your custom type and its type converter is not an absolute requirement.</span></span> <span data-ttu-id="30a13-174">不過，如果您正在實作控制項，或使用功能某部分的序列化或類別設計，則應該實作 <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>。</span><span class="sxs-lookup"><span data-stu-id="30a13-174">However, if you are implementing a control, or using serialization of as part of the features or design of your class, you should implement <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>.</span></span>

<span data-ttu-id="30a13-175">若要可做為支援 XAML 的 <xref:System.ComponentModel.TypeConverter> 實作來重複使用，該轉換器的 <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> 方法必須接受所支援類型 (或值) 的執行個體做為 `value` 參數。</span><span class="sxs-lookup"><span data-stu-id="30a13-175">To be usable as a <xref:System.ComponentModel.TypeConverter> implementation that supports XAML, the <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> method for that converter must accept an instance of the type (or a value) that is supported as the `value` parameter.</span></span> <span data-ttu-id="30a13-176">`destinationType` 參數的類型是 <xref:System.String>時，傳回的物件必須可以轉型為 <xref:System.String>。</span><span class="sxs-lookup"><span data-stu-id="30a13-176">When the `destinationType` parameter is of type <xref:System.String>, the returned object must be able to be cast as <xref:System.String>.</span></span> <span data-ttu-id="30a13-177">傳回的字串必須代表 `value`的序列化值。</span><span class="sxs-lookup"><span data-stu-id="30a13-177">The returned string must represent a serialized value of `value`.</span></span> <span data-ttu-id="30a13-178">理想上，您選擇的序列化格式應該可以產生相同的值，就像將該字串傳遞給相同轉換器的 <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> 實作，而不會明顯遺失資訊。</span><span class="sxs-lookup"><span data-stu-id="30a13-178">Ideally, the serialization format that you choose should be able to generate the same value as if that string were passed to the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> implementation of the same converter, without significant loss of information.</span></span>

<span data-ttu-id="30a13-179">如果無法序列化值，或轉換器不支援序列化，則 <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> 實作必須傳回 `null` 並可能會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="30a13-179">If the value cannot be serialized or the converter does not support serialization, the <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> implementation must return `null` and can throw an exception.</span></span> <span data-ttu-id="30a13-180">不過，如果您確實擲回例外狀況，則應該報告無法使用該轉換做為 <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> 實作的一部分；因此，支援先使用 <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> 檢查以避免例外狀況的最佳做法。</span><span class="sxs-lookup"><span data-stu-id="30a13-180">However, if you do throw exceptions, you should report the inability to use that conversion as part of your <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> implementation so that the best practice of checking with <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> first to avoid exceptions is supported.</span></span>

<span data-ttu-id="30a13-181">如果 `destinationType` 參數的類型不是 <xref:System.String>，則可以選擇專屬轉換器處理。</span><span class="sxs-lookup"><span data-stu-id="30a13-181">If the `destinationType` parameter is not of type <xref:System.String>, you can choose your own converter handling.</span></span> <span data-ttu-id="30a13-182">一般而言，您會回復成基底實作處理，而在基底 <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> 中會引發特定例外狀況。</span><span class="sxs-lookup"><span data-stu-id="30a13-182">Typically, you revert to base implementation handling, which in the base <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> raises a specific exception.</span></span>

<span data-ttu-id="30a13-183">當您的型別轉換子必須有 .NET XAML 服務物件寫入器的 XAML 服務存取權時，才會擲回例外狀況，但對 <xref:System.IServiceProvider.GetService%2A> 內容所進行的呼叫不會傳回該服務。</span><span class="sxs-lookup"><span data-stu-id="30a13-183">It is appropriate to throw an exception when your type converter must have access to a XAML service from .NET XAML Services object writer, but the <xref:System.IServiceProvider.GetService%2A> call that is made against the context does not return that service.</span></span>

### <a name="implementing-canconvertfrom"></a><span data-ttu-id="30a13-184">實作 CanConvertFrom</span><span class="sxs-lookup"><span data-stu-id="30a13-184">Implementing CanConvertFrom</span></span>

<span data-ttu-id="30a13-185">您的 <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> 實作應該傳回類型 `true` 之 `sourceType` 的 <xref:System.String> ，否則會進行基底實作。</span><span class="sxs-lookup"><span data-stu-id="30a13-185">Your <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> implementation should return `true` for `sourceType` of type <xref:System.String> and otherwise, defer to the base implementation.</span></span> <span data-ttu-id="30a13-186">不會從 <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A>擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="30a13-186">Do not throw exceptions from <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A>.</span></span>

### <a name="implementing-canconvertto"></a><span data-ttu-id="30a13-187">實作 CanConvertTo</span><span class="sxs-lookup"><span data-stu-id="30a13-187">Implementing CanConvertTo</span></span>

<span data-ttu-id="30a13-188">您的 <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> 實作應該傳回類型 `true` 之 `destinationType` 的 <xref:System.String>，否則會進行基底實作。</span><span class="sxs-lookup"><span data-stu-id="30a13-188">Your <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> implementation should return `true` for `destinationType` of type <xref:System.String>, and otherwise defer to the base implementation.</span></span> <span data-ttu-id="30a13-189">不會從 <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A>擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="30a13-189">Do not throw exceptions from <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A>.</span></span>

## <a name="applying-the-typeconverterattribute"></a><span data-ttu-id="30a13-190">套用 TypeConverterAttribute</span><span class="sxs-lookup"><span data-stu-id="30a13-190">Applying the TypeConverterAttribute</span></span>

<span data-ttu-id="30a13-191">若要讓您的自訂類型轉換器當做 .NET XAML 服務的自訂類別的作用型別轉換子，您必須將套用 <xref:System.ComponentModel.TypeConverterAttribute> 至您的類別定義。</span><span class="sxs-lookup"><span data-stu-id="30a13-191">For your custom type converter to be used as the acting type converter for a custom class by .NET XAML Services, you must apply the <xref:System.ComponentModel.TypeConverterAttribute> to your class definition.</span></span> <span data-ttu-id="30a13-192">您透過屬性指定的 <xref:System.ComponentModel.TypeConverterAttribute.ConverterTypeName%2A> 必須是您自訂類型轉換器的類型名稱。</span><span class="sxs-lookup"><span data-stu-id="30a13-192">The <xref:System.ComponentModel.TypeConverterAttribute.ConverterTypeName%2A> that you specify through the attribute must be the type name of your custom type converter.</span></span> <span data-ttu-id="30a13-193">如果您套用這個屬性，則在 XAML 處理器處理屬性類型使用您自訂類別類型的值時，可以輸入字串，並傳回物件執行個體。</span><span class="sxs-lookup"><span data-stu-id="30a13-193">If you apply this attribute, when a XAML processor handles values where the property type uses your custom class type, it can input strings and return object instances.</span></span>

<span data-ttu-id="30a13-194">您也可以提供每個屬性的類型轉換器。</span><span class="sxs-lookup"><span data-stu-id="30a13-194">You can also provide a type converter on a per-property basis.</span></span> <span data-ttu-id="30a13-195">不是將套用至 <xref:System.ComponentModel.TypeConverterAttribute> 類別定義，而是將它套用至主要定義 (的屬性定義，而不是 `get` / `set`) 內的內部部署。</span><span class="sxs-lookup"><span data-stu-id="30a13-195">Instead of applying a <xref:System.ComponentModel.TypeConverterAttribute> to the class definition, apply it to a property definition (the main definition, not the `get`/`set` implementations within it).</span></span> <span data-ttu-id="30a13-196">屬性的類型必須符合您自訂類型轉換器所處理的類型。</span><span class="sxs-lookup"><span data-stu-id="30a13-196">The type of the property must match the type that is processed by your custom type converter.</span></span> <span data-ttu-id="30a13-197">如果已套用這個屬性，則在 XAML 處理器處理該屬性的值時，可以處理輸入字串，並傳回物件執行個體。</span><span class="sxs-lookup"><span data-stu-id="30a13-197">With this attribute applied, when a XAML processor handles values of that property, it can process input strings and return object instances.</span></span> <span data-ttu-id="30a13-198">如果您選擇使用 Microsoft .NET Framework 中的屬性類型，或從無法控制類別定義且無法套用至該處的其他程式庫，則每個屬性的類型轉換器技術會很有用 <xref:System.ComponentModel.TypeConverterAttribute> 。</span><span class="sxs-lookup"><span data-stu-id="30a13-198">The per-property type converter technique is useful if you choose to use a property type from Microsoft .NET Framework or from some other library where you cannot control the class definition and cannot apply a <xref:System.ComponentModel.TypeConverterAttribute> there.</span></span>

<span data-ttu-id="30a13-199">若要提供自訂附加成員的類型轉換行為，請將 <xref:System.ComponentModel.TypeConverterAttribute> 套用至附加成員之實作模式的 `Get` 存取子方法。</span><span class="sxs-lookup"><span data-stu-id="30a13-199">To supply a type conversion behavior for a custom attached member, apply <xref:System.ComponentModel.TypeConverterAttribute> to the `Get` accessor method of the implementation pattern for the attached member.</span></span>

## <a name="accessing-service-provider-context-from-a-markup-extension-implementation"></a><span data-ttu-id="30a13-200">從標記延伸實作存取服務提供者內容</span><span class="sxs-lookup"><span data-stu-id="30a13-200">Accessing Service Provider Context from a Markup Extension Implementation</span></span>

<span data-ttu-id="30a13-201">任何值轉換器的可用服務都會相同。</span><span class="sxs-lookup"><span data-stu-id="30a13-201">The available services are the same for any value converter.</span></span> <span data-ttu-id="30a13-202">差異在於每個值轉換器如何接收服務內容。</span><span class="sxs-lookup"><span data-stu-id="30a13-202">The difference is in how each value converter receives the service context.</span></span> <span data-ttu-id="30a13-203">存取服務和可用服務記載於 [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions.md)主題中。</span><span class="sxs-lookup"><span data-stu-id="30a13-203">Accessing services and the services available are documented in the topic [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions.md).</span></span>

## <a name="type-converters-in-the-xaml-node-stream"></a><span data-ttu-id="30a13-204">XAML 節點資料流中的類型轉換器</span><span class="sxs-lookup"><span data-stu-id="30a13-204">Type Converters in the XAML Node Stream</span></span>

<span data-ttu-id="30a13-205">如果您是使用 XAML 節點資料流，則尚未執行類型轉換器的動作或最終結果。</span><span class="sxs-lookup"><span data-stu-id="30a13-205">If you are working with a XAML node stream, the action or end result of a type converter is not yet executed.</span></span> <span data-ttu-id="30a13-206">在載入路徑中，最後需要進行類型轉換才能載入的屬性字串仍然維持為開始成員和結束成員內的文字值。</span><span class="sxs-lookup"><span data-stu-id="30a13-206">In a load path, the attribute string that eventually needs to be type-converted in order to load remains as a text value within a start member and end member.</span></span> <span data-ttu-id="30a13-207">使用 <xref:System.Xaml.XamlMember.TypeConverter%2A?displayProperty=nameWithType> 屬性可以判定這項作業最後需要的類型轉換器。</span><span class="sxs-lookup"><span data-stu-id="30a13-207">The type converter that is eventually needed for this operation can be determined by using the <xref:System.Xaml.XamlMember.TypeConverter%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="30a13-208">不過，從 <xref:System.Xaml.XamlMember.TypeConverter%2A?displayProperty=nameWithType> 取得有效值是依賴具有 XAML 結構描述內容 (可透過基礎成員存取這類資訊) 或成員所使用物件值的類型。</span><span class="sxs-lookup"><span data-stu-id="30a13-208">However, obtaining a valid value from <xref:System.Xaml.XamlMember.TypeConverter%2A?displayProperty=nameWithType> relies on having a XAML schema context, which can access such information through the underlying member, or the type of the object value that the member uses.</span></span> <span data-ttu-id="30a13-209">叫用類型轉換行為時也需要 XAML 結構描述內容，因為這需要類型對應以及建立轉換器執行個體。</span><span class="sxs-lookup"><span data-stu-id="30a13-209">Invoking the type conversion behavior also requires the XAML schema context because that requires type-mapping and creating a converter instance.</span></span>

## <a name="see-also"></a><span data-ttu-id="30a13-210">另請參閱</span><span class="sxs-lookup"><span data-stu-id="30a13-210">See also</span></span>

- <xref:System.ComponentModel.TypeConverterAttribute>
- [<span data-ttu-id="30a13-211">XAML 的類型轉換子和標記延伸</span><span class="sxs-lookup"><span data-stu-id="30a13-211">Type Converters and Markup Extensions for XAML</span></span>](type-converters-and-markup-extensions.md)
- [<span data-ttu-id="30a13-212">XAML 概觀 (WPF)</span><span class="sxs-lookup"><span data-stu-id="30a13-212">XAML Overview (WPF)</span></span>](../fundamentals/xaml.md)
