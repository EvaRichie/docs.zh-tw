---
title: " (程式碼分析) 的安全性規則"
description: 瞭解程式碼分析安全性規則。
ms.date: 10/02/2019
ms.topic: reference
f1_keywords:
- vs.codeanalysis.securityrules
helpviewer_keywords:
- security [Visual Studio ALM], Enterprise Templates
- security rules
- managed code analysis rules, security rules
- rules, security
author: gewarren
ms.author: gewarren
ms.openlocfilehash: e907905b065d786fc8b3c370fb2d2e2b19e62a2b
ms.sourcegitcommit: 5114e7847e0ff8ddb8c266802d47af78567949cf
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 11/19/2020
ms.locfileid: "96586649"
---
# <a name="security-rules"></a><span data-ttu-id="628ce-103">安全性規則</span><span class="sxs-lookup"><span data-stu-id="628ce-103">Security rules</span></span>

<span data-ttu-id="628ce-104">安全性規則支援更安全的程式庫和應用程式。</span><span class="sxs-lookup"><span data-stu-id="628ce-104">Security rules support safer libraries and applications.</span></span> <span data-ttu-id="628ce-105">這些規則有助於防止程式發生安全性瑕疵問題。</span><span class="sxs-lookup"><span data-stu-id="628ce-105">These rules help prevent security flaws in your program.</span></span> <span data-ttu-id="628ce-106">如果您停用這些規則中的任何一項，您應該清楚地標示程式碼中的原因，並針對您的開發專案通知指定的安全性長。</span><span class="sxs-lookup"><span data-stu-id="628ce-106">If you disable any of these rules, you should clearly mark the reason in code and also inform the designated security officer for your development project.</span></span>

## <a name="in-this-section"></a><span data-ttu-id="628ce-107">本節內容</span><span class="sxs-lookup"><span data-stu-id="628ce-107">In this section</span></span>

|<span data-ttu-id="628ce-108">規則</span><span class="sxs-lookup"><span data-stu-id="628ce-108">Rule</span></span>|<span data-ttu-id="628ce-109">描述</span><span class="sxs-lookup"><span data-stu-id="628ce-109">Description</span></span>|
|----------|-----------------|
|[<span data-ttu-id="628ce-110">CA2100:必須檢閱 SQL 查詢中是否有安全性弱點</span><span class="sxs-lookup"><span data-stu-id="628ce-110">CA2100: Review SQL queries for security vulnerabilities</span></span>](ca2100.md)|<span data-ttu-id="628ce-111">方法會使用透過字串引數所建置的字串，將 System.Data.IDbCommand.CommandText 屬性設定為方法。</span><span class="sxs-lookup"><span data-stu-id="628ce-111">A method sets the System.Data.IDbCommand.CommandText property by using a string that is built from a string argument to the method.</span></span> <span data-ttu-id="628ce-112">這項規則假設字串引數包含使用者輸入。</span><span class="sxs-lookup"><span data-stu-id="628ce-112">This rule assumes that the string argument contains user input.</span></span> <span data-ttu-id="628ce-113">從使用者輸入所建置的 SQL 命令字串很容易遭到 SQL 插入攻擊。</span><span class="sxs-lookup"><span data-stu-id="628ce-113">A SQL command string built from user input is vulnerable to SQL injection attacks.</span></span>|
|[<span data-ttu-id="628ce-114">CA2109:必須檢閱可見的事件處理常式</span><span class="sxs-lookup"><span data-stu-id="628ce-114">CA2109: Review visible event handlers</span></span>](ca2109.md)|<span data-ttu-id="628ce-115">偵測到公用或保護的事件處理方法。</span><span class="sxs-lookup"><span data-stu-id="628ce-115">A public or protected event-handling method was detected.</span></span> <span data-ttu-id="628ce-116">除非有絕對的必要性，否則不應該公開事件處理方法。</span><span class="sxs-lookup"><span data-stu-id="628ce-116">Event-handling methods should not be exposed unless absolutely necessary.</span></span>|
|[<span data-ttu-id="628ce-117">CA2119:密封方法以滿足私用介面的要求</span><span class="sxs-lookup"><span data-stu-id="628ce-117">CA2119: Seal methods that satisfy private interfaces</span></span>](ca2119.md)|<span data-ttu-id="628ce-118">可繼承的公用類型會提供內部 (在 Visual Basic 中為 Friend) 介面的可覆寫方法實作。</span><span class="sxs-lookup"><span data-stu-id="628ce-118">An inheritable public type provides an overridable method implementation of an internal (Friend in Visual Basic) interface.</span></span> <span data-ttu-id="628ce-119">若要修正此規則的違規情形，請避免在組件外覆寫方法。</span><span class="sxs-lookup"><span data-stu-id="628ce-119">To fix a violation of this rule, prevent the method from being overridden outside the assembly.</span></span>|
|[<span data-ttu-id="628ce-120">CA2153:避免處理損毀狀態例外狀況</span><span class="sxs-lookup"><span data-stu-id="628ce-120">CA2153: Avoid Handling Corrupted State Exceptions</span></span>](ca2153.md)|<span data-ttu-id="628ce-121">[損毀狀態例外狀況 (CSE)](/archive/msdn-magazine/2009/february/clr-inside-out-handling-corrupted-state-exceptions) 指出您的處理序中有記憶體損毀的狀況。</span><span class="sxs-lookup"><span data-stu-id="628ce-121">[Corrupted State Exceptions (CSE)](/archive/msdn-magazine/2009/february/clr-inside-out-handling-corrupted-state-exceptions) indicate that memory corruption exists in your process.</span></span> <span data-ttu-id="628ce-122">如果攻擊者將攻擊放入損毀的記憶體區域，則攔截這些處理序而非讓它們損毀，會導致安全性弱點。</span><span class="sxs-lookup"><span data-stu-id="628ce-122">Catching these rather than allowing the process to crash can lead to security vulnerabilities if an attacker can place an exploit into the corrupted memory region.</span></span>|
|[<span data-ttu-id="628ce-123">CA2300：請勿使用不安全的還原序列化程式 BinaryFormatter</span><span class="sxs-lookup"><span data-stu-id="628ce-123">CA2300: Do not use insecure deserializer BinaryFormatter</span></span>](ca2300.md)|<span data-ttu-id="628ce-124">在還原序列化不受信任的資料時，不安全的還原序列化程式很容易。</span><span class="sxs-lookup"><span data-stu-id="628ce-124">Insecure deserializers are vulnerable when deserializing untrusted data.</span></span> <span data-ttu-id="628ce-125">攻擊者可以修改序列化的資料，以包含未預期的類型，以插入具有惡意副作用的物件。</span><span class="sxs-lookup"><span data-stu-id="628ce-125">An attacker could modify the serialized data to include unexpected types to inject objects with malicious side effects.</span></span>|
|[<span data-ttu-id="628ce-126">CA2301：未先設定 BinaryFormatter.Binder 之前，請勿呼叫 BinaryFormatter.Deserialize</span><span class="sxs-lookup"><span data-stu-id="628ce-126">CA2301: Do not call BinaryFormatter.Deserialize without first setting BinaryFormatter.Binder</span></span>](ca2301.md)|<span data-ttu-id="628ce-127">在還原序列化不受信任的資料時，不安全的還原序列化程式很容易。</span><span class="sxs-lookup"><span data-stu-id="628ce-127">Insecure deserializers are vulnerable when deserializing untrusted data.</span></span> <span data-ttu-id="628ce-128">攻擊者可以修改序列化的資料，以包含未預期的類型，以插入具有惡意副作用的物件。</span><span class="sxs-lookup"><span data-stu-id="628ce-128">An attacker could modify the serialized data to include unexpected types to inject objects with malicious side effects.</span></span>|
|[<span data-ttu-id="628ce-129">CA2302：呼叫 BinaryFormatter.Deserialize 之前，請務必先設定 BinaryFormatter.Binder</span><span class="sxs-lookup"><span data-stu-id="628ce-129">CA2302: Ensure BinaryFormatter.Binder is set before calling BinaryFormatter.Deserialize</span></span>](ca2302.md)|<span data-ttu-id="628ce-130">在還原序列化不受信任的資料時，不安全的還原序列化程式很容易。</span><span class="sxs-lookup"><span data-stu-id="628ce-130">Insecure deserializers are vulnerable when deserializing untrusted data.</span></span> <span data-ttu-id="628ce-131">攻擊者可以修改序列化的資料，以包含未預期的類型，以插入具有惡意副作用的物件。</span><span class="sxs-lookup"><span data-stu-id="628ce-131">An attacker could modify the serialized data to include unexpected types to inject objects with malicious side effects.</span></span>|
|[<span data-ttu-id="628ce-132">CA2305：請勿使用不安全的還原序列化程式 LosFormatter</span><span class="sxs-lookup"><span data-stu-id="628ce-132">CA2305: Do not use insecure deserializer LosFormatter</span></span>](ca2305.md)|<span data-ttu-id="628ce-133">在還原序列化不受信任的資料時，不安全的還原序列化程式很容易。</span><span class="sxs-lookup"><span data-stu-id="628ce-133">Insecure deserializers are vulnerable when deserializing untrusted data.</span></span> <span data-ttu-id="628ce-134">攻擊者可以修改序列化的資料，以包含未預期的類型，以插入具有惡意副作用的物件。</span><span class="sxs-lookup"><span data-stu-id="628ce-134">An attacker could modify the serialized data to include unexpected types to inject objects with malicious side effects.</span></span>|
|[<span data-ttu-id="628ce-135">CA2310：請勿使用不安全的還原序列化程式 NetDataContractSerializer</span><span class="sxs-lookup"><span data-stu-id="628ce-135">CA2310: Do not use insecure deserializer NetDataContractSerializer</span></span>](ca2310.md)|<span data-ttu-id="628ce-136">在還原序列化不受信任的資料時，不安全的還原序列化程式很容易。</span><span class="sxs-lookup"><span data-stu-id="628ce-136">Insecure deserializers are vulnerable when deserializing untrusted data.</span></span> <span data-ttu-id="628ce-137">攻擊者可以修改序列化的資料，以包含未預期的類型，以插入具有惡意副作用的物件。</span><span class="sxs-lookup"><span data-stu-id="628ce-137">An attacker could modify the serialized data to include unexpected types to inject objects with malicious side effects.</span></span>|
|[<span data-ttu-id="628ce-138">CA2311：未先設定 NetDataContractSerializer.Binder 之前，請勿還原序列化</span><span class="sxs-lookup"><span data-stu-id="628ce-138">CA2311: Do not deserialize without first setting NetDataContractSerializer.Binder</span></span>](ca2311.md)|<span data-ttu-id="628ce-139">在還原序列化不受信任的資料時，不安全的還原序列化程式很容易。</span><span class="sxs-lookup"><span data-stu-id="628ce-139">Insecure deserializers are vulnerable when deserializing untrusted data.</span></span> <span data-ttu-id="628ce-140">攻擊者可以修改序列化的資料，以包含未預期的類型，以插入具有惡意副作用的物件。</span><span class="sxs-lookup"><span data-stu-id="628ce-140">An attacker could modify the serialized data to include unexpected types to inject objects with malicious side effects.</span></span>|
|[<span data-ttu-id="628ce-141">CA2312：還原序列化之前，請務必先設定 NetDataContractSerializer.Binder</span><span class="sxs-lookup"><span data-stu-id="628ce-141">CA2312: Ensure NetDataContractSerializer.Binder is set before deserializing</span></span>](ca2312.md)|<span data-ttu-id="628ce-142">在還原序列化不受信任的資料時，不安全的還原序列化程式很容易。</span><span class="sxs-lookup"><span data-stu-id="628ce-142">Insecure deserializers are vulnerable when deserializing untrusted data.</span></span> <span data-ttu-id="628ce-143">攻擊者可以修改序列化的資料，以包含未預期的類型，以插入具有惡意副作用的物件。</span><span class="sxs-lookup"><span data-stu-id="628ce-143">An attacker could modify the serialized data to include unexpected types to inject objects with malicious side effects.</span></span>|
|[<span data-ttu-id="628ce-144">CA2315：請勿使用不安全的還原序列化程式 ObjectStateFormatter</span><span class="sxs-lookup"><span data-stu-id="628ce-144">CA2315: Do not use insecure deserializer ObjectStateFormatter</span></span>](ca2315.md)|<span data-ttu-id="628ce-145">在還原序列化不受信任的資料時，不安全的還原序列化程式很容易。</span><span class="sxs-lookup"><span data-stu-id="628ce-145">Insecure deserializers are vulnerable when deserializing untrusted data.</span></span> <span data-ttu-id="628ce-146">攻擊者可以修改序列化的資料，以包含未預期的類型，以插入具有惡意副作用的物件。</span><span class="sxs-lookup"><span data-stu-id="628ce-146">An attacker could modify the serialized data to include unexpected types to inject objects with malicious side effects.</span></span>|
|[<span data-ttu-id="628ce-147">CA2321：請勿使用 SimpleTypeResolver 搭配 JavaScriptSerializer 來還原序列化</span><span class="sxs-lookup"><span data-stu-id="628ce-147">CA2321: Do not deserialize with JavaScriptSerializer using a SimpleTypeResolver</span></span>](ca2321.md)|<span data-ttu-id="628ce-148">在還原序列化不受信任的資料時，不安全的還原序列化程式很容易。</span><span class="sxs-lookup"><span data-stu-id="628ce-148">Insecure deserializers are vulnerable when deserializing untrusted data.</span></span> <span data-ttu-id="628ce-149">攻擊者可以修改序列化的資料，以包含未預期的類型，以插入具有惡意副作用的物件。</span><span class="sxs-lookup"><span data-stu-id="628ce-149">An attacker could modify the serialized data to include unexpected types to inject objects with malicious side effects.</span></span>|
|[<span data-ttu-id="628ce-150">CA2322：還原序列化之前，請確定不會使用 SimpleTypeResolver 來將 JavaScriptSerializer 初始化</span><span class="sxs-lookup"><span data-stu-id="628ce-150">CA2322: Ensure JavaScriptSerializer is not initialized with SimpleTypeResolver before deserializing</span></span>](ca2322.md)|<span data-ttu-id="628ce-151">在還原序列化不受信任的資料時，不安全的還原序列化程式很容易。</span><span class="sxs-lookup"><span data-stu-id="628ce-151">Insecure deserializers are vulnerable when deserializing untrusted data.</span></span> <span data-ttu-id="628ce-152">攻擊者可以修改序列化的資料，以包含未預期的類型，以插入具有惡意副作用的物件。</span><span class="sxs-lookup"><span data-stu-id="628ce-152">An attacker could modify the serialized data to include unexpected types to inject objects with malicious side effects.</span></span>|
|[<span data-ttu-id="628ce-153">CA2326:請勿使用「無」以外的 TypeNameHandling 值</span><span class="sxs-lookup"><span data-stu-id="628ce-153">CA2326: Do not use TypeNameHandling values other than None</span></span>](ca2326.md)|<span data-ttu-id="628ce-154">在還原序列化不受信任的資料時，不安全的還原序列化程式很容易。</span><span class="sxs-lookup"><span data-stu-id="628ce-154">Insecure deserializers are vulnerable when deserializing untrusted data.</span></span> <span data-ttu-id="628ce-155">攻擊者可以修改序列化的資料，以包含未預期的類型，以插入具有惡意副作用的物件。</span><span class="sxs-lookup"><span data-stu-id="628ce-155">An attacker could modify the serialized data to include unexpected types to inject objects with malicious side effects.</span></span>|
|[<span data-ttu-id="628ce-156">CA2327:請勿使用不安全的 JsonSerializerSettings</span><span class="sxs-lookup"><span data-stu-id="628ce-156">CA2327: Do not use insecure JsonSerializerSettings</span></span>](ca2327.md)|<span data-ttu-id="628ce-157">在還原序列化不受信任的資料時，不安全的還原序列化程式很容易。</span><span class="sxs-lookup"><span data-stu-id="628ce-157">Insecure deserializers are vulnerable when deserializing untrusted data.</span></span> <span data-ttu-id="628ce-158">攻擊者可以修改序列化的資料，以包含未預期的類型，以插入具有惡意副作用的物件。</span><span class="sxs-lookup"><span data-stu-id="628ce-158">An attacker could modify the serialized data to include unexpected types to inject objects with malicious side effects.</span></span>|
|[<span data-ttu-id="628ce-159">CA2328:確定 JsonSerializerSettings 安全</span><span class="sxs-lookup"><span data-stu-id="628ce-159">CA2328: Ensure that JsonSerializerSettings are secure</span></span>](ca2328.md)|<span data-ttu-id="628ce-160">在還原序列化不受信任的資料時，不安全的還原序列化程式很容易。</span><span class="sxs-lookup"><span data-stu-id="628ce-160">Insecure deserializers are vulnerable when deserializing untrusted data.</span></span> <span data-ttu-id="628ce-161">攻擊者可以修改序列化的資料，以包含未預期的類型，以插入具有惡意副作用的物件。</span><span class="sxs-lookup"><span data-stu-id="628ce-161">An attacker could modify the serialized data to include unexpected types to inject objects with malicious side effects.</span></span>|
|[<span data-ttu-id="628ce-162">CA2329:請勿使用不安全的組態來還原序列化 JsonSerializer</span><span class="sxs-lookup"><span data-stu-id="628ce-162">CA2329: Do not deserialize with JsonSerializer using an insecure configuration</span></span>](ca2329.md)|<span data-ttu-id="628ce-163">在還原序列化不受信任的資料時，不安全的還原序列化程式很容易。</span><span class="sxs-lookup"><span data-stu-id="628ce-163">Insecure deserializers are vulnerable when deserializing untrusted data.</span></span> <span data-ttu-id="628ce-164">攻擊者可以修改序列化的資料，以包含未預期的類型，以插入具有惡意副作用的物件。</span><span class="sxs-lookup"><span data-stu-id="628ce-164">An attacker could modify the serialized data to include unexpected types to inject objects with malicious side effects.</span></span>|
|[<span data-ttu-id="628ce-165">CA2330:在還原序列化時，請確認 JsonSerializer 有安全的組態</span><span class="sxs-lookup"><span data-stu-id="628ce-165">CA2330: Ensure that JsonSerializer has a secure configuration when deserializing</span></span>](ca2330.md)|<span data-ttu-id="628ce-166">在還原序列化不受信任的資料時，不安全的還原序列化程式很容易。</span><span class="sxs-lookup"><span data-stu-id="628ce-166">Insecure deserializers are vulnerable when deserializing untrusted data.</span></span> <span data-ttu-id="628ce-167">攻擊者可以修改序列化的資料，以包含未預期的類型，以插入具有惡意副作用的物件。</span><span class="sxs-lookup"><span data-stu-id="628ce-167">An attacker could modify the serialized data to include unexpected types to inject objects with malicious side effects.</span></span>|
|[<span data-ttu-id="628ce-168">CA2350：請確認 DataTable.ReadXml() 的輸入是受信任的</span><span class="sxs-lookup"><span data-stu-id="628ce-168">CA2350: Ensure DataTable.ReadXml()'s input is trusted</span></span>](ca2350.md)|<span data-ttu-id="628ce-169"><xref:System.Data.DataTable>使用不受信任的輸入還原序列化時，攻擊者可以製作惡意輸入來執行阻斷服務攻擊。</span><span class="sxs-lookup"><span data-stu-id="628ce-169">When deserializing a <xref:System.Data.DataTable> with untrusted input, an attacker can craft malicious input to perform a denial of service attack.</span></span> <span data-ttu-id="628ce-170">可能有未知的遠端程式碼執行弱點。</span><span class="sxs-lookup"><span data-stu-id="628ce-170">There may be unknown remote code execution vulnerabilities.</span></span>|
|[<span data-ttu-id="628ce-171">CA2351：請確認 DataSet.ReadXml() 的輸入是受信任的</span><span class="sxs-lookup"><span data-stu-id="628ce-171">CA2351: Ensure DataSet.ReadXml()'s input is trusted</span></span>](ca2351.md)|<span data-ttu-id="628ce-172"><xref:System.Data.DataSet>使用不受信任的輸入還原序列化時，攻擊者可以製作惡意輸入來執行阻斷服務攻擊。</span><span class="sxs-lookup"><span data-stu-id="628ce-172">When deserializing a <xref:System.Data.DataSet> with untrusted input, an attacker can craft malicious input to perform a denial of service attack.</span></span> <span data-ttu-id="628ce-173">可能有未知的遠端程式碼執行弱點。</span><span class="sxs-lookup"><span data-stu-id="628ce-173">There may be unknown remote code execution vulnerabilities.</span></span>|
|[<span data-ttu-id="628ce-174">CA2352：可序列化類型中的不安全 DataSet 或 DataTable 可能容易受到遠端程式碼執行攻擊</span><span class="sxs-lookup"><span data-stu-id="628ce-174">CA2352: Unsafe DataSet or DataTable in serializable type can be vulnerable to remote code execution attacks</span></span>](ca2352.md)|<span data-ttu-id="628ce-175">標記為的類別或結構 <xref:System.SerializableAttribute> 包含 <xref:System.Data.DataSet> 或 <xref:System.Data.DataTable> 欄位或屬性，而且沒有 <xref:System.CodeDom.Compiler.GeneratedCodeAttribute> 。</span><span class="sxs-lookup"><span data-stu-id="628ce-175">A class or struct marked with <xref:System.SerializableAttribute> contains a <xref:System.Data.DataSet> or <xref:System.Data.DataTable> field or property, and doesn't have a <xref:System.CodeDom.Compiler.GeneratedCodeAttribute>.</span></span>|
|[<span data-ttu-id="628ce-176">CA2353：可序列化類型中的不安全 DataSet 或 DataTable</span><span class="sxs-lookup"><span data-stu-id="628ce-176">CA2353: Unsafe DataSet or DataTable in serializable type</span></span>](ca2353.md)|<span data-ttu-id="628ce-177">以 XML 序列化屬性（attribute）或資料合約屬性（attribute）標記的類別或結構包含 <xref:System.Data.DataSet> 或 <xref:System.Data.DataTable> 欄位或屬性（property）。</span><span class="sxs-lookup"><span data-stu-id="628ce-177">A class or struct marked with an XML serialization attribute or a data contract attribute contains a <xref:System.Data.DataSet> or <xref:System.Data.DataTable> field or property.</span></span>|
|[<span data-ttu-id="628ce-178">CA2354：還原序列化物件圖中的不安全 DataSet 或 DataTable 可能容易受到遠端程式碼執行攻擊</span><span class="sxs-lookup"><span data-stu-id="628ce-178">CA2354: Unsafe DataSet or DataTable in deserialized object graph can be vulnerable to remote code execution attack</span></span>](ca2354.md)|<span data-ttu-id="628ce-179">使用序列化還原序列化 <xref:System.Runtime.Serialization.IFormatter?displayProperty=nameWithType> ，而轉換類型的物件圖形可以包含 <xref:System.Data.DataSet> 或 <xref:System.Data.DataTable> 。</span><span class="sxs-lookup"><span data-stu-id="628ce-179">Deserializing with an <xref:System.Runtime.Serialization.IFormatter?displayProperty=nameWithType> serialized, and the casted type's object graph can include a <xref:System.Data.DataSet> or <xref:System.Data.DataTable>.</span></span>|
|[<span data-ttu-id="628ce-180">CA2355：還原序列化物件圖中的不安全 DataSet 或 DataTable</span><span class="sxs-lookup"><span data-stu-id="628ce-180">CA2355: Unsafe DataSet or DataTable in deserialized object graph</span></span>](ca2355.md)|<span data-ttu-id="628ce-181">在轉換或指定類型的物件圖形可以包含或時還原 <xref:System.Data.DataSet> 序列化 <xref:System.Data.DataTable> 。</span><span class="sxs-lookup"><span data-stu-id="628ce-181">Deserializing when the casted or specified type's object graph can include a <xref:System.Data.DataSet> or <xref:System.Data.DataTable>.</span></span>|
|[<span data-ttu-id="628ce-182">CA2356： web 還原序列化物件圖形中不安全的資料集或 DataTable</span><span class="sxs-lookup"><span data-stu-id="628ce-182">CA2356: Unsafe DataSet or DataTable in web deserialized object graph</span></span>](ca2356.md)|<span data-ttu-id="628ce-183">具有或的方法 <xref:System.Web.Services.WebMethodAttribute?displayProperty=nameWithType> <xref:System.ServiceModel.OperationContractAttribute?displayProperty=nameWithType> 具有可參考或的參數 <xref:System.Data.DataSet> <xref:System.Data.DataTable> 。</span><span class="sxs-lookup"><span data-stu-id="628ce-183">A method with a <xref:System.Web.Services.WebMethodAttribute?displayProperty=nameWithType> or <xref:System.ServiceModel.OperationContractAttribute?displayProperty=nameWithType> has a parameter that may reference a <xref:System.Data.DataSet> or <xref:System.Data.DataTable>.</span></span>|
|[<span data-ttu-id="628ce-184">CA2361：確認不會搭配不受信任的資料使用包含 DataSet.ReadXml() 的自動產生類別</span><span class="sxs-lookup"><span data-stu-id="628ce-184">CA2361: Ensure autogenerated class containing DataSet.ReadXml() is not used with untrusted data</span></span>](ca2361.md)|<span data-ttu-id="628ce-185"><xref:System.Data.DataSet>使用不受信任的輸入還原序列化時，攻擊者可以製作惡意輸入來執行阻斷服務攻擊。</span><span class="sxs-lookup"><span data-stu-id="628ce-185">When deserializing a <xref:System.Data.DataSet> with untrusted input, an attacker can craft malicious input to perform a denial of service attack.</span></span> <span data-ttu-id="628ce-186">可能有未知的遠端程式碼執行弱點。</span><span class="sxs-lookup"><span data-stu-id="628ce-186">There may be unknown remote code execution vulnerabilities.</span></span>|
|[<span data-ttu-id="628ce-187">CA2362：自動產生之可序列化型別中不安全的 DataSet 或 DataTable，容易受到遠端程式碼執行攻擊</span><span class="sxs-lookup"><span data-stu-id="628ce-187">CA2362: Unsafe DataSet or DataTable in autogenerated serializable type can be vulnerable to remote code execution attacks</span></span>](ca2362.md)|<span data-ttu-id="628ce-188">當還原序列化未受信任的輸入，而且還原序列化 <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> 的物件圖形包含 <xref:System.Data.DataSet> 或時 <xref:System.Data.DataTable> ，攻擊者可以製作惡意的內容來執行遠端程式碼執行攻擊。</span><span class="sxs-lookup"><span data-stu-id="628ce-188">When deserializing untrusted input with <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> and the deserialized object graph contains a <xref:System.Data.DataSet> or <xref:System.Data.DataTable>, an attacker can craft a malicious payload to perform a remote code execution attack.</span></span>|
|[<span data-ttu-id="628ce-189">CA3001：檢閱程式碼是否有 SQL 插入式攻擊弱點</span><span class="sxs-lookup"><span data-stu-id="628ce-189">CA3001: Review code for SQL injection vulnerabilities</span></span>](ca3001.md)|<span data-ttu-id="628ce-190">使用不受信任的輸入和 SQL 命令時，請注意 SQL 插入式攻擊。</span><span class="sxs-lookup"><span data-stu-id="628ce-190">When working with untrusted input and SQL commands, be mindful of SQL injection attacks.</span></span> <span data-ttu-id="628ce-191">SQL 插入式攻擊可能會執行惡意的 SQL 命令，而危及應用程式的安全性和完整性。</span><span class="sxs-lookup"><span data-stu-id="628ce-191">An SQL injection attack can execute malicious SQL commands, compromising the security and integrity of your application.</span></span>|
|[<span data-ttu-id="628ce-192">CA3002：檢閱程式碼是否有 XSS 弱點</span><span class="sxs-lookup"><span data-stu-id="628ce-192">CA3002: Review code for XSS vulnerabilities</span></span>](ca3002.md)|<span data-ttu-id="628ce-193">從 web 要求處理不受信任的輸入時，請注意跨網站腳本 (XSS) 攻擊。</span><span class="sxs-lookup"><span data-stu-id="628ce-193">When working with untrusted input from web requests, be mindful of cross-site scripting (XSS) attacks.</span></span> <span data-ttu-id="628ce-194">XSS 攻擊會將不受信任的輸入插入原始 HTML 輸出，讓攻擊者可以執行惡意腳本或惡意地修改您網頁中的內容。</span><span class="sxs-lookup"><span data-stu-id="628ce-194">An XSS attack injects untrusted input into raw HTML output, allowing the attacker to execute malicious scripts or maliciously modify content in your web page.</span></span>|
|[<span data-ttu-id="628ce-195">CA3003：檢閱程式碼是否有檔案路徑插入式攻擊弱點</span><span class="sxs-lookup"><span data-stu-id="628ce-195">CA3003: Review code for file path injection vulnerabilities</span></span>](ca3003.md)|<span data-ttu-id="628ce-196">使用來自 web 要求的未受信任輸入時，請留意在指定檔案路徑時使用使用者控制的輸入。</span><span class="sxs-lookup"><span data-stu-id="628ce-196">When working with untrusted input from web requests, be mindful of using user-controlled input when specifying paths to files.</span></span>|
|[<span data-ttu-id="628ce-197">CA3004：檢閱程式碼是否有資訊洩漏弱點</span><span class="sxs-lookup"><span data-stu-id="628ce-197">CA3004: Review code for information disclosure vulnerabilities</span></span>](ca3004.md)|<span data-ttu-id="628ce-198">洩漏例外狀況資訊可讓攻擊者深入瞭解您的應用程式內部，這可協助攻擊者找出其他弱點來進行攻擊。</span><span class="sxs-lookup"><span data-stu-id="628ce-198">Disclosing exception information gives attackers insight into the internals of your application, which can help attackers find other vulnerabilities to exploit.</span></span>|
|[<span data-ttu-id="628ce-199">CA3006：檢閱程式碼是否有處理序命令插入式攻擊弱點</span><span class="sxs-lookup"><span data-stu-id="628ce-199">CA3006: Review code for process command injection vulnerabilities</span></span>](ca3006.md)|<span data-ttu-id="628ce-200">使用不受信任的輸入時，請注意命令插入式攻擊。</span><span class="sxs-lookup"><span data-stu-id="628ce-200">When working with untrusted input, be mindful of command injection attacks.</span></span> <span data-ttu-id="628ce-201">命令插入式攻擊可在基礎作業系統上執行惡意命令，而危及伺服器的安全性和完整性。</span><span class="sxs-lookup"><span data-stu-id="628ce-201">A command injection attack can execute malicious commands on the underlying operating system, compromising the security and integrity of your server.</span></span>|
|[<span data-ttu-id="628ce-202">CA3007：檢閱程式碼是否有開放式重新導向弱點</span><span class="sxs-lookup"><span data-stu-id="628ce-202">CA3007: Review code for open redirect vulnerabilities</span></span>](ca3007.md)|<span data-ttu-id="628ce-203">使用不受信任的輸入時，請留意開放式重新導向弱點。</span><span class="sxs-lookup"><span data-stu-id="628ce-203">When working with untrusted input, be mindful of open redirect vulnerabilities.</span></span> <span data-ttu-id="628ce-204">攻擊者可以利用開放式重新導向弱點，使用您的網站提供合法 URL 的外觀，但將不受信任的訪客重新導向至網路釣魚或其他惡意網頁。</span><span class="sxs-lookup"><span data-stu-id="628ce-204">An attacker can exploit an open redirect vulnerability to use your website to give the appearance of a legitimate URL, but redirect an unsuspecting visitor to a phishing or other malicious webpage.</span></span>|
|[<span data-ttu-id="628ce-205">CA3008：檢閱程式碼是否有 XPath 插入式攻擊弱點</span><span class="sxs-lookup"><span data-stu-id="628ce-205">CA3008: Review code for XPath injection vulnerabilities</span></span>](ca3008.md)|<span data-ttu-id="628ce-206">使用不受信任的輸入時，請注意 XPath 插入式攻擊。</span><span class="sxs-lookup"><span data-stu-id="628ce-206">When working with untrusted input, be mindful of XPath injection attacks.</span></span> <span data-ttu-id="628ce-207">使用不受信任的輸入來建立 XPath 查詢，可能會讓攻擊者惡意地操作查詢以傳回非預期的結果，而且可能會洩漏所查詢 XML 的內容。</span><span class="sxs-lookup"><span data-stu-id="628ce-207">Constructing XPath queries using untrusted input may allow an attacker to maliciously manipulate the query to return an unintended result, and possibly disclose the contents of the queried XML.</span></span>|
|[<span data-ttu-id="628ce-208">CA3009：檢閱程式碼是否有 XML 插入式攻擊弱點</span><span class="sxs-lookup"><span data-stu-id="628ce-208">CA3009: Review code for XML injection vulnerabilities</span></span>](ca3009.md)|<span data-ttu-id="628ce-209">使用不受信任的輸入時，請注意 XML 插入式攻擊。</span><span class="sxs-lookup"><span data-stu-id="628ce-209">When working with untrusted input, be mindful of XML injection attacks.</span></span>|
|[<span data-ttu-id="628ce-210">CA3010：檢閱程式碼是否有 XAML 插入式攻擊弱點</span><span class="sxs-lookup"><span data-stu-id="628ce-210">CA3010: Review code for XAML injection vulnerabilities</span></span>](ca3010.md)|<span data-ttu-id="628ce-211">使用不受信任的輸入時，請注意 XAML 插入式攻擊。</span><span class="sxs-lookup"><span data-stu-id="628ce-211">When working with untrusted input, be mindful of XAML injection attacks.</span></span> <span data-ttu-id="628ce-212">XAML 是直接表示物件執行個體化和執行的標記語言。</span><span class="sxs-lookup"><span data-stu-id="628ce-212">XAML is a markup language that directly represents object instantiation and execution.</span></span> <span data-ttu-id="628ce-213">這表示在 XAML 中建立的元素可以與系統資源互動 (例如，網路存取和檔案系統 IO) 。</span><span class="sxs-lookup"><span data-stu-id="628ce-213">That means elements created in XAML can interact with system resources (for example, network access and file system IO).</span></span>|
|[<span data-ttu-id="628ce-214">CA3011：檢閱程式碼是否有 DLL 插入式攻擊弱點</span><span class="sxs-lookup"><span data-stu-id="628ce-214">CA3011: Review code for DLL injection vulnerabilities</span></span>](ca3011.md)|<span data-ttu-id="628ce-215">使用不受信任的輸入時，請注意載入未受信任的程式碼。</span><span class="sxs-lookup"><span data-stu-id="628ce-215">When working with untrusted input, be mindful of loading untrusted code.</span></span> <span data-ttu-id="628ce-216">如果您的 web 應用程式載入未受信任的程式碼，攻擊者可能會將惡意 Dll 插入您的進程，並執行惡意程式碼。</span><span class="sxs-lookup"><span data-stu-id="628ce-216">If your web application loads untrusted code, an attacker may be able to inject malicious DLLs into your process and execute malicious code.</span></span>|
|[<span data-ttu-id="628ce-217">CA3012：檢閱程式碼是否有 regex 插入式攻擊弱點</span><span class="sxs-lookup"><span data-stu-id="628ce-217">CA3012: Review code for regex injection vulnerabilities</span></span>](ca3012.md)|<span data-ttu-id="628ce-218">使用不受信任的輸入時，請注意 RegEx 插入式攻擊。</span><span class="sxs-lookup"><span data-stu-id="628ce-218">When working with untrusted input, be mindful of regex injection attacks.</span></span> <span data-ttu-id="628ce-219">攻擊者可以使用 RegEx 插入來惡意地修改正則運算式、讓 RegEx 符合非預期的結果，或讓 RegEx 耗用過多的 CPU，造成阻絕服務攻擊。</span><span class="sxs-lookup"><span data-stu-id="628ce-219">An attacker can use regex injection to maliciously modify a regular expression, to make the regex match unintended results, or to make the regex consume excessive CPU resulting in a Denial of Service attack.</span></span>|
|[<span data-ttu-id="628ce-220">CA3061：請勿透過 URL 新增結構描述</span><span class="sxs-lookup"><span data-stu-id="628ce-220">CA3061: Do not add schema by URL</span></span>](ca3061.md)|<span data-ttu-id="628ce-221">請勿使用 Add 方法的 unsafe 多載，因為它可能會造成危險的外部參考。</span><span class="sxs-lookup"><span data-stu-id="628ce-221">Do not use the unsafe overload of the Add method because it may cause dangerous external references.</span></span>|
|[<span data-ttu-id="628ce-222">CA3075:不安全的 DTD 處理</span><span class="sxs-lookup"><span data-stu-id="628ce-222">CA3075: Insecure DTD Processing</span></span>](ca3075.md)|<span data-ttu-id="628ce-223">如果您使用不安全的 DTDProcessing 執行個體或參考外部實體來源，剖析器可能會接受未受信任的輸入，而將機密資訊洩漏給攻擊者。</span><span class="sxs-lookup"><span data-stu-id="628ce-223">If you use insecure DTDProcessing instances or reference external entity sources, the parser may accept untrusted input and disclose sensitive information to attackers.</span></span>|
|[<span data-ttu-id="628ce-224">CA3076:不安全的 XSLT 指令碼執行</span><span class="sxs-lookup"><span data-stu-id="628ce-224">CA3076: Insecure XSLT Script Execution</span></span>](ca3076.md)|<span data-ttu-id="628ce-225">如果您在 .NET 應用程式, 中執行 (XSLT) 的可延伸樣式表語言轉換，處理器可能會解析可能洩漏機密資訊給攻擊者的不受信任 URI 參考，進而導致阻絕服務和跨網站攻擊。</span><span class="sxs-lookup"><span data-stu-id="628ce-225">If you execute Extensible StyleSheet Language Transformations (XSLT) in .NET applications insecurely, the processor may resolve untrusted URI references that could disclose sensitive information to attackers, leading to Denial of Service and Cross-Site attacks.</span></span>|
|[<span data-ttu-id="628ce-226">CA3077:API 設計、XML 文件和 XML 文字讀取器中的不安全處理</span><span class="sxs-lookup"><span data-stu-id="628ce-226">CA3077: Insecure Processing in API Design, XML Document and XML Text Reader</span></span>](ca3077.md)|<span data-ttu-id="628ce-227">針對衍生自 XMLDocument 和 XMLTextReader 的 API 進行設計時，請留意 DtdProcessing。</span><span class="sxs-lookup"><span data-stu-id="628ce-227">When designing an API derived from XMLDocument and XMLTextReader, be mindful of DtdProcessing.</span></span> <span data-ttu-id="628ce-228">若在參考或解析外部實體來源時使用不安全的 DTDProcessing 執行個體，或在 XML 中設定不安全的值，都可能會導致資訊洩漏。</span><span class="sxs-lookup"><span data-stu-id="628ce-228">Using insecure DTDProcessing instances when referencing or resolving external entity sources or setting insecure values in the XML may lead to information disclosure.</span></span>|
|[<span data-ttu-id="628ce-229">CA3147:使用 ValidateAntiForgeryToken 標示動詞處理常式</span><span class="sxs-lookup"><span data-stu-id="628ce-229">CA3147: Mark verb handlers with ValidateAntiForgeryToken</span></span>](ca3147.md)|<span data-ttu-id="628ce-230">設計 ASP.NET MVC 控制器時，請留意跨網站偽造要求的攻擊。</span><span class="sxs-lookup"><span data-stu-id="628ce-230">When designing an ASP.NET MVC controller, be mindful of cross-site request forgery attacks.</span></span> <span data-ttu-id="628ce-231">跨網站偽造要求攻擊可以將來自已驗證使用者的惡意要求傳送到您的 ASP.NET MVC 控制器。</span><span class="sxs-lookup"><span data-stu-id="628ce-231">A cross-site request forgery attack can send malicious requests from an authenticated user to your ASP.NET MVC controller.</span></span>|
|[<span data-ttu-id="628ce-232">CA5350：請勿使用弱式密碼編譯演算法</span><span class="sxs-lookup"><span data-stu-id="628ce-232">CA5350: Do Not Use Weak Cryptographic Algorithms</span></span>](ca5350.md)|<span data-ttu-id="628ce-233">現今，弱式加密演算法和雜湊函式用於多種原因，但它們不應該用來保證所保護資料的機密性或完整性。</span><span class="sxs-lookup"><span data-stu-id="628ce-233">Weak encryption algorithms and hashing functions are used today for a number of reasons, but they should not be used to guarantee the confidentiality or integrity of the data they protect.</span></span> <span data-ttu-id="628ce-234">此規則會在它在程式碼中發現 TripleDES、SHA1 或 RIPEMD160 演算法時觸發。</span><span class="sxs-lookup"><span data-stu-id="628ce-234">This rule triggers when it finds TripleDES, SHA1, or RIPEMD160 algorithms in the code.</span></span>|
|[<span data-ttu-id="628ce-235">CA5351：不使用中斷的密碼編譯演算法</span><span class="sxs-lookup"><span data-stu-id="628ce-235">CA5351: Do Not Use Broken Cryptographic Algorithms</span></span>](ca5351.md)|<span data-ttu-id="628ce-236">中斷的密碼編譯演算法較不安全，強烈建議您不要使用它們。</span><span class="sxs-lookup"><span data-stu-id="628ce-236">Broken cryptographic algorithms are not considered secure and their use should be strongly discouraged.</span></span> <span data-ttu-id="628ce-237">此規則會在它在程式碼中發現 MD5 雜湊演算法或 DES 或 RC2 加密演算法時觸發。</span><span class="sxs-lookup"><span data-stu-id="628ce-237">This rule triggers when it finds the MD5 hash algorithm or either the DES or RC2 encryption algorithms in code.</span></span>|
|[<span data-ttu-id="628ce-238">CA5358:不要使用不安全的 Cipher 模式</span><span class="sxs-lookup"><span data-stu-id="628ce-238">CA5358: Do Not Use Unsafe Cipher Modes</span></span>](ca5358.md)|<span data-ttu-id="628ce-239">不要使用不安全的 Cipher 模式</span><span class="sxs-lookup"><span data-stu-id="628ce-239">Do Not Use Unsafe Cipher Modes</span></span>|
|[<span data-ttu-id="628ce-240">CA5359：請勿停用憑證驗證</span><span class="sxs-lookup"><span data-stu-id="628ce-240">CA5359: Do not disable certificate validation</span></span>](ca5359.md)|<span data-ttu-id="628ce-241">憑證可協助驗證服務器的身分識別。</span><span class="sxs-lookup"><span data-stu-id="628ce-241">A certificate can help authenticate the identity of the server.</span></span> <span data-ttu-id="628ce-242">用戶端應該驗證伺服器憑證，以確保會將要求傳送給預定的伺服器。</span><span class="sxs-lookup"><span data-stu-id="628ce-242">Clients should validate the server certificate to ensure requests are sent to the intended server.</span></span> <span data-ttu-id="628ce-243">如果 ServerCertificateValidationCallback 一律 `true` 會傳回，任何憑證都會通過驗證。</span><span class="sxs-lookup"><span data-stu-id="628ce-243">If the ServerCertificateValidationCallback always returns `true`, any certificate will pass validation.</span></span>|
|[<span data-ttu-id="628ce-244">CA5360：請勿在還原序列化時呼叫危險的方法</span><span class="sxs-lookup"><span data-stu-id="628ce-244">CA5360: Do not call dangerous methods in deserialization</span></span>](ca5360.md)|<span data-ttu-id="628ce-245">不安全的還原序列化是在未受信任的資料用來濫用應用程式邏輯、對拒絕服務 (DoS) 攻擊，或甚至在還原序列化時執行任意程式碼時所發生的弱點。</span><span class="sxs-lookup"><span data-stu-id="628ce-245">Insecure deserialization is a vulnerability that occurs when untrusted data is used to abuse the logic of an application, inflict a Denial-of-Service (DoS) attack, or even execute arbitrary code upon it being deserialized.</span></span> <span data-ttu-id="628ce-246">當應用程式還原序列化受信任的資料時，惡意使用者通常可能會濫用這些還原序列化功能。</span><span class="sxs-lookup"><span data-stu-id="628ce-246">It's frequently possible for malicious users to abuse these deserialization features when the application is deserializing untrusted data that is under their control.</span></span> <span data-ttu-id="628ce-247">具體而言，在還原序列化的過程中叫用危險的方法。</span><span class="sxs-lookup"><span data-stu-id="628ce-247">Specifically, invoke dangerous methods in the process of deserialization.</span></span> <span data-ttu-id="628ce-248">成功的不安全還原序列化攻擊可能會讓攻擊者執行攻擊，例如 DoS 攻擊、驗證略過，以及遠端程式碼執行。</span><span class="sxs-lookup"><span data-stu-id="628ce-248">Successful insecure deserialization attacks could allow an attacker to carry out attacks such as DoS attacks, authentication bypasses, and remote code execution.</span></span>|
|[<span data-ttu-id="628ce-249">CA5361：不要停用安全加密的安全通道使用</span><span class="sxs-lookup"><span data-stu-id="628ce-249">CA5361: Do not disable SChannel use of strong crypto</span></span>](ca5361.md)|<span data-ttu-id="628ce-250">設定 `Switch.System.Net.DontEnableSchUseStrongCrypto` 以 `true` 削弱輸出傳輸層安全性中使用的密碼編譯 (TLS) 連接。</span><span class="sxs-lookup"><span data-stu-id="628ce-250">Setting `Switch.System.Net.DontEnableSchUseStrongCrypto` to `true` weakens the cryptography used in outgoing Transport Layer Security (TLS) connections.</span></span> <span data-ttu-id="628ce-251">較弱的密碼編譯可能會危及應用程式與伺服器之間通訊的機密性，讓攻擊者更容易竊聽敏感性資料。</span><span class="sxs-lookup"><span data-stu-id="628ce-251">Weaker cryptography can compromise the confidentiality of communication between your application and the server, making it easier for attackers to eavesdrop sensitive data.</span></span>|
|[<span data-ttu-id="628ce-252">CA5362：還原序列化物件圖中的可能參考循環</span><span class="sxs-lookup"><span data-stu-id="628ce-252">CA5362: Potential reference cycle in deserialized object graph</span></span>](ca5362.md)|<span data-ttu-id="628ce-253">如果還原序列化不受信任的資料，則任何處理已還原序列化之物件圖形的程式碼都必須處理參考迴圈，而不會進入無限迴圈。</span><span class="sxs-lookup"><span data-stu-id="628ce-253">If deserializing untrusted data, then any code processing the deserialized object graph needs to handle reference cycles without going into infinite loops.</span></span> <span data-ttu-id="628ce-254">這包括屬於還原序列化回呼一部分的程式碼，以及完成還原序列化之後處理物件圖形的程式碼。</span><span class="sxs-lookup"><span data-stu-id="628ce-254">This includes both code that's part of a deserialization callback and code that processes the object graph after deserialization completed.</span></span> <span data-ttu-id="628ce-255">否則，攻擊者可能會使用包含參考週期的惡意資料來執行阻斷服務攻擊。</span><span class="sxs-lookup"><span data-stu-id="628ce-255">Otherwise, an attacker could perform a Denial-of-Service attack with malicious data containing a reference cycle.</span></span>|
|[<span data-ttu-id="628ce-256">CA5363：請勿停用要求驗證</span><span class="sxs-lookup"><span data-stu-id="628ce-256">CA5363: Do not disable request validation</span></span>](ca5363.md)|<span data-ttu-id="628ce-257">要求驗證是 ASP.NET 中的一項功能，可檢查 HTTP 要求，並判斷它們是否包含可能會導致插入式攻擊的潛在危險內容，包括跨網站腳本。</span><span class="sxs-lookup"><span data-stu-id="628ce-257">Request validation is a feature in ASP.NET that examines HTTP requests and determines whether they contain potentially dangerous content that can lead to injection attacks, including cross-site-scripting.</span></span>|
|[<span data-ttu-id="628ce-258">CA5364:請勿使用已取代的安全性通訊協定</span><span class="sxs-lookup"><span data-stu-id="628ce-258">CA5364: Do not use deprecated security protocols</span></span>](ca5364.md)|<span data-ttu-id="628ce-259">傳輸層安全性 (TLS) 保護電腦之間的通訊安全，最常見的方式是使用超文字傳輸通訊協定安全 (HTTPS) 。</span><span class="sxs-lookup"><span data-stu-id="628ce-259">Transport Layer Security (TLS) secures communication between computers, most commonly with Hypertext Transfer Protocol Secure (HTTPS).</span></span> <span data-ttu-id="628ce-260">舊版的 TLS 通訊協定版本比 TLS 1.2 和 TLS 1.3 更不安全，而且可能會有新的弱點。</span><span class="sxs-lookup"><span data-stu-id="628ce-260">Older protocol versions of TLS are less secure than TLS 1.2 and TLS 1.3 and are more likely to have new vulnerabilities.</span></span> <span data-ttu-id="628ce-261">避免較舊的通訊協定版本，以將風險降至最低。</span><span class="sxs-lookup"><span data-stu-id="628ce-261">Avoid older protocol versions to minimize risk.</span></span>|
|[<span data-ttu-id="628ce-262">CA5365：請勿停用 HTTP 標頭檢查</span><span class="sxs-lookup"><span data-stu-id="628ce-262">CA5365: Do Not Disable HTTP Header Checking</span></span>](ca5365.md)|<span data-ttu-id="628ce-263">HTTP 標頭檢查可針對在回應標頭中找到的換行字元和分行符號（\r 和 \n）進行編碼。</span><span class="sxs-lookup"><span data-stu-id="628ce-263">HTTP header checking enables encoding of the carriage return and newline characters, \r and \n, that are found in response headers.</span></span> <span data-ttu-id="628ce-264">這種編碼方式有助於避免利用應用程式回應標頭所含之不受信任資料的插入式攻擊。</span><span class="sxs-lookup"><span data-stu-id="628ce-264">This encoding can help to avoid injection attacks that exploit an application that echoes untrusted data contained by the header.</span></span>|
|[<span data-ttu-id="628ce-265">CA5366：請使用 XmlReader 為 DataSet 讀取 XML</span><span class="sxs-lookup"><span data-stu-id="628ce-265">CA5366: Use XmlReader For DataSet Read XML</span></span>](ca5366.md)|<span data-ttu-id="628ce-266">使用 <xref:System.Data.DataSet> 來讀取具有不受信任資料的 XML 可能會載入危險的外部參考，而這些參考應透過使用 <xref:System.Xml.XmlReader> 安全解析程式或停用 DTD 處理來限制。</span><span class="sxs-lookup"><span data-stu-id="628ce-266">Using a <xref:System.Data.DataSet> to read XML with untrusted data may load dangerous external references, which should be restricted by using an <xref:System.Xml.XmlReader> with a secure resolver or with DTD processing disabled.</span></span>|
|[<span data-ttu-id="628ce-267">CA5367：請勿將具有指標欄位的類型序列化</span><span class="sxs-lookup"><span data-stu-id="628ce-267">CA5367: Do Not Serialize Types With Pointer Fields</span></span>](ca5367.md)|<span data-ttu-id="628ce-268">此規則會檢查是否有具有指標欄位或屬性的可序列化類別。</span><span class="sxs-lookup"><span data-stu-id="628ce-268">This rule checks whether there's a serializable class with a pointer field or property.</span></span> <span data-ttu-id="628ce-269">無法序列化的成員可以是指標，例如以標記的靜態成員或欄位 <xref:System.NonSerializedAttribute> 。</span><span class="sxs-lookup"><span data-stu-id="628ce-269">Members that can't be serialized can be a pointer, such as static members or fields marked with <xref:System.NonSerializedAttribute>.</span></span>|
|[<span data-ttu-id="628ce-270">CA5368：為衍生自頁面的類別設定 ViewStateUserKey</span><span class="sxs-lookup"><span data-stu-id="628ce-270">CA5368: Set ViewStateUserKey For Classes Derived From Page</span></span>](ca5368.md)|<span data-ttu-id="628ce-271">設定此 <xref:System.Web.UI.Page.ViewStateUserKey> 屬性可讓您將識別碼指派給個別使用者的 view state 變數，讓攻擊者無法使用變數來產生攻擊，藉此協助您防止應用程式的攻擊。</span><span class="sxs-lookup"><span data-stu-id="628ce-271">Setting the <xref:System.Web.UI.Page.ViewStateUserKey> property can help you prevent attacks on your application by allowing you to assign an identifier to the view-state variable for individual users so that attackers cannot use the variable to generate an attack.</span></span> <span data-ttu-id="628ce-272">否則，將會有跨網站要求偽造的弱點。</span><span class="sxs-lookup"><span data-stu-id="628ce-272">Otherwise, there will be vulnerabilities to cross-site request forgery.</span></span>|
|[<span data-ttu-id="628ce-273">CA5369：請使用 XmlReader 進行還原序列化</span><span class="sxs-lookup"><span data-stu-id="628ce-273">CA5369: Use XmlReader for Deserialize</span></span>](ca5369.md)|<span data-ttu-id="628ce-274">處理不受信任的 DTD 和 XML 架構可能會啟用載入危險的外部參考，應使用具有安全解析程式的 XmlReader，或停用 DTD 和 XML 內嵌架構處理來限制。</span><span class="sxs-lookup"><span data-stu-id="628ce-274">Processing untrusted DTD and XML schemas may enable loading dangerous external references, which should be restricted by using an XmlReader with a secure resolver or with DTD and XML inline schema processing disabled.</span></span>|
|[<span data-ttu-id="628ce-275">CA5370：請使用 XmlReader 驗證讀取器</span><span class="sxs-lookup"><span data-stu-id="628ce-275">CA5370: Use XmlReader for validating reader</span></span>](ca5370.md)|<span data-ttu-id="628ce-276">處理不受信任的 DTD 和 XML 架構可能會啟用載入危險的外部參考。</span><span class="sxs-lookup"><span data-stu-id="628ce-276">Processing untrusted DTD and XML schemas may enable loading dangerous external references.</span></span> <span data-ttu-id="628ce-277">您可以使用具有安全解析程式的 XmlReader，或是停用 DTD 和 XML 內嵌架構處理，來限制這個危險的載入。</span><span class="sxs-lookup"><span data-stu-id="628ce-277">This dangerous loading can be restricted by using an XmlReader with a secure resolver or with DTD and XML inline schema processing disabled.</span></span>|
|[<span data-ttu-id="628ce-278">CA5371：請使用 XmlReader 讀取結構描述</span><span class="sxs-lookup"><span data-stu-id="628ce-278">CA5371: Use XmlReader for schema read</span></span>](ca5371.md)|<span data-ttu-id="628ce-279">處理不受信任的 DTD 和 XML 架構可能會啟用載入危險的外部參考。</span><span class="sxs-lookup"><span data-stu-id="628ce-279">Processing untrusted DTD and XML schemas may enable loading dangerous external references.</span></span> <span data-ttu-id="628ce-280">使用具有安全解析程式的 XmlReader，或已停用 DTD 和 XML 內嵌架構處理的 XmlReader 會限制這一點。</span><span class="sxs-lookup"><span data-stu-id="628ce-280">Using an XmlReader with a secure resolver or with DTD and XML inline schema processing disabled restricts this.</span></span>|
|[<span data-ttu-id="628ce-281">CA5372：請為 XPathDocument 使用 XmlReader</span><span class="sxs-lookup"><span data-stu-id="628ce-281">CA5372: Use XmlReader for XPathDocument</span></span>](ca5372.md)|<span data-ttu-id="628ce-282">處理來自不受信任資料的 XML 可能會載入危險的外部參考，可以使用具有安全解析程式或停用 DTD 處理的 XmlReader 來限制。</span><span class="sxs-lookup"><span data-stu-id="628ce-282">Processing XML from untrusted data may load dangerous external references, which can be restricted by using an XmlReader with a secure resolver or with DTD processing disabled.</span></span>|
|[<span data-ttu-id="628ce-283">CA5373：不使用已過時的金鑰衍生函式</span><span class="sxs-lookup"><span data-stu-id="628ce-283">CA5373: Do not use obsolete key derivation function</span></span>](ca5373.md)|<span data-ttu-id="628ce-284">此規則會偵測弱式金鑰衍生方法和的調用 <xref:System.Security.Cryptography.PasswordDeriveBytes?displayProperty=fullName> `Rfc2898DeriveBytes.CryptDeriveKey` 。</span><span class="sxs-lookup"><span data-stu-id="628ce-284">This rule detects the invocation of weak key derivation methods <xref:System.Security.Cryptography.PasswordDeriveBytes?displayProperty=fullName> and `Rfc2898DeriveBytes.CryptDeriveKey`.</span></span> <span data-ttu-id="628ce-285"><xref:System.Security.Cryptography.PasswordDeriveBytes?displayProperty=fullName> 使用弱式演算法 PBKDF1。</span><span class="sxs-lookup"><span data-stu-id="628ce-285"><xref:System.Security.Cryptography.PasswordDeriveBytes?displayProperty=fullName> used a weak algorithm PBKDF1.</span></span>|
|[<span data-ttu-id="628ce-286">CA5374：請勿使用 XslTransform</span><span class="sxs-lookup"><span data-stu-id="628ce-286">CA5374: Do Not Use XslTransform</span></span>](ca5374.md)|<span data-ttu-id="628ce-287">這 <xref:System.Xml.Xsl.XslTransform?displayProperty=nameWithType> 項規則會檢查程式碼中是否具現化。</span><span class="sxs-lookup"><span data-stu-id="628ce-287">This rule checks if <xref:System.Xml.Xsl.XslTransform?displayProperty=nameWithType> is instantiated in the code.</span></span> <span data-ttu-id="628ce-288"><xref:System.Xml.Xsl.XslTransform?displayProperty=nameWithType> 現在已過時，不應該使用。</span><span class="sxs-lookup"><span data-stu-id="628ce-288"><xref:System.Xml.Xsl.XslTransform?displayProperty=nameWithType> is now obsolete and shouldn't be used.</span></span>|
|[<span data-ttu-id="628ce-289">CA5375：請勿使用帳戶共用存取簽章</span><span class="sxs-lookup"><span data-stu-id="628ce-289">CA5375: Do not use account shared access signature</span></span>](ca5375.md)|<span data-ttu-id="628ce-290">帳戶 SAS 可將存取權委派給服務 SAS 不允許的 blob 容器、資料表、佇列和檔案共用的讀取、寫入和刪除作業。</span><span class="sxs-lookup"><span data-stu-id="628ce-290">An account SAS can delegate access to read, write, and delete operations on blob containers, tables, queues, and file shares that are not permitted with a service SAS.</span></span> <span data-ttu-id="628ce-291">不過，它不支援容器層級的原則，而且對授與的許可權不會有更大的彈性和控制權。</span><span class="sxs-lookup"><span data-stu-id="628ce-291">However, it doesn't support container-level policies and has less flexibility and control over the permissions that are granted.</span></span> <span data-ttu-id="628ce-292">惡意使用者取得之後，您的儲存體帳戶將會很容易遭到入侵。</span><span class="sxs-lookup"><span data-stu-id="628ce-292">Once malicious users get it, your storage account will be compromised easily.</span></span>|
|[<span data-ttu-id="628ce-293">CA5376：請使用 SharedAccessProtocol HttpsOnly</span><span class="sxs-lookup"><span data-stu-id="628ce-293">CA5376: Use SharedAccessProtocol HttpsOnly</span></span>](ca5376.md)|<span data-ttu-id="628ce-294">SAS 是無法在 HTTP 上以純文字傳輸的機密資料。</span><span class="sxs-lookup"><span data-stu-id="628ce-294">SAS is sensitive data that can't be transported in plain text on HTTP.</span></span>|
|[<span data-ttu-id="628ce-295">CA5377：請使用容器層級存取原則</span><span class="sxs-lookup"><span data-stu-id="628ce-295">CA5377: Use container level access policy</span></span>](ca5377.md)|<span data-ttu-id="628ce-296">您可以隨時修改或撤銷容器層級的存取原則。</span><span class="sxs-lookup"><span data-stu-id="628ce-296">A container-level access policy can be modified or revoked at any time.</span></span> <span data-ttu-id="628ce-297">它對授與的許可權提供更大的彈性和控制權。</span><span class="sxs-lookup"><span data-stu-id="628ce-297">It provides greater flexibility and control over the permissions that are granted.</span></span>|
|[<span data-ttu-id="628ce-298">CA5378:請勿停用 ServicePointManagerSecurityProtocols</span><span class="sxs-lookup"><span data-stu-id="628ce-298">CA5378: Do not disable ServicePointManagerSecurityProtocols</span></span>](ca5378.md)|<span data-ttu-id="628ce-299">將設定 `Switch.System.ServiceModel.DisableUsingServicePointManagerSecurityProtocols` 為 `true` 限制 Windows Communication Framework 的 (WCF) 傳輸層安全性 (tls) 使用 tls 1.0 的連接。</span><span class="sxs-lookup"><span data-stu-id="628ce-299">Setting `Switch.System.ServiceModel.DisableUsingServicePointManagerSecurityProtocols` to `true` limits Windows Communication Framework's (WCF) Transport Layer Security (TLS) connections to using TLS 1.0.</span></span> <span data-ttu-id="628ce-300">該版本的 TLS 將會被取代。</span><span class="sxs-lookup"><span data-stu-id="628ce-300">That version of TLS will be deprecated.</span></span>|
|[<span data-ttu-id="628ce-301">CA5379：確定金鑰衍生函式演算法的功能夠強</span><span class="sxs-lookup"><span data-stu-id="628ce-301">CA5379: Ensure key derivation function algorithm is sufficiently strong</span></span>](ca5379.md)|<span data-ttu-id="628ce-302"><xref:System.Security.Cryptography.Rfc2898DeriveBytes>類別預設會使用此 <xref:System.Security.Cryptography.HashAlgorithmName.SHA1> 演算法。</span><span class="sxs-lookup"><span data-stu-id="628ce-302">The <xref:System.Security.Cryptography.Rfc2898DeriveBytes> class defaults to using the <xref:System.Security.Cryptography.HashAlgorithmName.SHA1> algorithm.</span></span> <span data-ttu-id="628ce-303">您應該在具有 <xref:System.Security.Cryptography.HashAlgorithmName.SHA256> 或更高版本的函式的某些多載中，指定要使用的雜湊演算法。</span><span class="sxs-lookup"><span data-stu-id="628ce-303">You should specify the hash algorithm to use in some overloads of the constructor with <xref:System.Security.Cryptography.HashAlgorithmName.SHA256> or higher.</span></span> <span data-ttu-id="628ce-304">請注意， <xref:System.Security.Cryptography.Rfc2898DeriveBytes.HashAlgorithm> 屬性只有一個 `get` 存取子，而且沒有 `overriden` 修飾詞。</span><span class="sxs-lookup"><span data-stu-id="628ce-304">Note, <xref:System.Security.Cryptography.Rfc2898DeriveBytes.HashAlgorithm> property only has a `get` accessor and doesn't have a `overriden` modifier.</span></span>|
|[<span data-ttu-id="628ce-305">CA5380：不新增憑證至根存放區</span><span class="sxs-lookup"><span data-stu-id="628ce-305">CA5380: Do not add certificates to root store</span></span>](ca5380.md)|<span data-ttu-id="628ce-306">此規則會偵測將憑證新增至「信任的根憑證授權單位」憑證存放區中的程式碼。</span><span class="sxs-lookup"><span data-stu-id="628ce-306">This rule detects code that adds a certificate into the Trusted Root Certification Authorities certificate store.</span></span> <span data-ttu-id="628ce-307">根據預設，「受信任的根憑證授權單位」憑證存放區會使用符合「Microsoft 根憑證計畫」需求的一組公用 Ca 進行設定。</span><span class="sxs-lookup"><span data-stu-id="628ce-307">By default, the Trusted Root Certification Authorities certificate store is configured with a set of public CAs that has met the requirements of the Microsoft Root Certificate Program.</span></span>|
|[<span data-ttu-id="628ce-308">CA5381：確保憑證不新增至根存放區</span><span class="sxs-lookup"><span data-stu-id="628ce-308">CA5381: Ensure certificates are not added to root store</span></span>](ca5381.md)|<span data-ttu-id="628ce-309">此規則會偵測可能將憑證新增至「信任的根憑證授權單位」憑證存放區中的程式碼。</span><span class="sxs-lookup"><span data-stu-id="628ce-309">This rule detects code that potentially adds a certificate into the Trusted Root Certification Authorities certificate store.</span></span> <span data-ttu-id="628ce-310">根據預設，「受信任的根憑證授權單位」憑證存放區會設定一組公開憑證授權單位單位， (CAs) 符合「Microsoft 根憑證計畫」的需求。</span><span class="sxs-lookup"><span data-stu-id="628ce-310">By default, the Trusted Root Certification Authorities certificate store is configured with a set of public certification authorities (CAs) that has met the requirements of the Microsoft Root Certificate Program.</span></span>|
|[<span data-ttu-id="628ce-311">CA5382：在 ASP.Net Core 中使用安全的 Cookie</span><span class="sxs-lookup"><span data-stu-id="628ce-311">CA5382: Use secure cookies in ASP.NET Core</span></span>](ca5382.md)|<span data-ttu-id="628ce-312">透過 HTTPS 提供的應用程式必須使用安全 cookie，這會向瀏覽器指出 cookie 只應使用傳輸層安全性 (TLS) 來傳輸。</span><span class="sxs-lookup"><span data-stu-id="628ce-312">Applications available over HTTPS must use secure cookies, which indicate to the browser that the cookie should only be transmitted using Transport Layer Security (TLS).</span></span>|
|[<span data-ttu-id="628ce-313">CA5383：請確認在 ASP.Net Core 中使用安全的 Cookie</span><span class="sxs-lookup"><span data-stu-id="628ce-313">CA5383: Ensure use secure cookies in ASP.NET Core</span></span>](ca5383.md)|<span data-ttu-id="628ce-314">透過 HTTPS 提供的應用程式必須使用安全 cookie，這會向瀏覽器指出 cookie 只應使用傳輸層安全性 (TLS) 來傳輸。</span><span class="sxs-lookup"><span data-stu-id="628ce-314">Applications available over HTTPS must use secure cookies, which indicate to the browser that the cookie should only be transmitted using Transport Layer Security (TLS).</span></span>|
|[<span data-ttu-id="628ce-315">CA5384：請勿使用數位簽章演算法 (DSA)</span><span class="sxs-lookup"><span data-stu-id="628ce-315">CA5384: Do not use digital signature algorithm (DSA)</span></span>](ca5384.md)|<span data-ttu-id="628ce-316">DSA 是弱式非對稱式加密演算法。</span><span class="sxs-lookup"><span data-stu-id="628ce-316">DSA is a weak asymmetric encryption algorithm.</span></span>|
|[<span data-ttu-id="628ce-317">CA5385：使用有足夠金鑰大小的 Rivest–Shamir–Adleman (RSA) 加密演算法</span><span class="sxs-lookup"><span data-stu-id="628ce-317">CA5385: Use Rivest–Shamir–Adleman (RSA) algorithm with sufficient key size</span></span>](ca5385.md)|<span data-ttu-id="628ce-318">小於2048位的 RSA 金鑰更容易遭受暴力密碼破解攻擊。</span><span class="sxs-lookup"><span data-stu-id="628ce-318">An RSA key smaller than 2048 bits is more vulnerable to brute force attacks.</span></span>|
|[<span data-ttu-id="628ce-319">CA5386:避免將 SecurityProtocolType 值寫入程式碼</span><span class="sxs-lookup"><span data-stu-id="628ce-319">CA5386: Avoid hardcoding SecurityProtocolType value</span></span>](ca5386.md)|<span data-ttu-id="628ce-320">傳輸層安全性 (TLS) 保護電腦之間的通訊安全，最常見的方式是使用超文字傳輸通訊協定安全 (HTTPS) 。</span><span class="sxs-lookup"><span data-stu-id="628ce-320">Transport Layer Security (TLS) secures communication between computers, most commonly with Hypertext Transfer Protocol Secure (HTTPS).</span></span> <span data-ttu-id="628ce-321">通訊協定版本 TLS 1.0 和 TLS 1.1 已被取代，而 TLS 1.2 和 TLS 1.3 是最新的。</span><span class="sxs-lookup"><span data-stu-id="628ce-321">Protocol versions TLS 1.0 and TLS 1.1 are deprecated, while TLS 1.2 and TLS 1.3 are current.</span></span> <span data-ttu-id="628ce-322">未來，TLS 1.2 和 TLS 1.3 可能已被取代。</span><span class="sxs-lookup"><span data-stu-id="628ce-322">In the future, TLS 1.2 and TLS 1.3 may be deprecated.</span></span> <span data-ttu-id="628ce-323">為了確保您的應用程式保持安全，請避免硬式編碼通訊協定版本，並以至少 .NET Framework v 4.7.1 為目標。</span><span class="sxs-lookup"><span data-stu-id="628ce-323">To ensure that your application remains secure, avoid hardcoding a protocol version and target at least .NET Framework v4.7.1.</span></span>|
|[<span data-ttu-id="628ce-324">CA5387：請勿使用反覆項目數不足的弱式金鑰衍生函數 (Key Derivation Function)</span><span class="sxs-lookup"><span data-stu-id="628ce-324">CA5387: Do not use weak key derivation function with insufficient iteration count</span></span>](ca5387.md)|<span data-ttu-id="628ce-325">這項規則會檢查密碼編譯金鑰是否 <xref:System.Security.Cryptography.Rfc2898DeriveBytes> 以小於100000的反復專案計數產生。</span><span class="sxs-lookup"><span data-stu-id="628ce-325">This rule checks if a cryptographic key was generated by <xref:System.Security.Cryptography.Rfc2898DeriveBytes> with an iteration count of less than 100,000.</span></span> <span data-ttu-id="628ce-326">較高的反復專案計數有助於減輕嘗試猜測產生的密碼編譯金鑰的字典攻擊。</span><span class="sxs-lookup"><span data-stu-id="628ce-326">A higher iteration count can help mitigate against dictionary attacks that try to guess the generated cryptographic key.</span></span>|
|[<span data-ttu-id="628ce-327">CA5388：使用弱式金鑰衍生函數 (Key Derivation Function) 時，請確保反覆項目數足夠</span><span class="sxs-lookup"><span data-stu-id="628ce-327">CA5388: Ensure sufficient iteration count when using weak key derivation function</span></span>](ca5388.md)|<span data-ttu-id="628ce-328">這項規則會檢查是否有產生密碼編譯金鑰 <xref:System.Security.Cryptography.Rfc2898DeriveBytes> ，且反覆運算計數可能小於100000。</span><span class="sxs-lookup"><span data-stu-id="628ce-328">This rule checks if a cryptographic key was generated by <xref:System.Security.Cryptography.Rfc2898DeriveBytes> with an iteration count that may be less than 100,000.</span></span> <span data-ttu-id="628ce-329">較高的反復專案計數有助於減輕嘗試猜測產生的密碼編譯金鑰的字典攻擊。</span><span class="sxs-lookup"><span data-stu-id="628ce-329">A higher iteration count can help mitigate against dictionary attacks that try to guess the generated cryptographic key.</span></span>|
|[<span data-ttu-id="628ce-330">CA5389：不將封存項目路徑新增至目標檔案系統路徑</span><span class="sxs-lookup"><span data-stu-id="628ce-330">CA5389: Do not add archive item's path to the target file system path</span></span>](ca5389.md)|<span data-ttu-id="628ce-331">檔案路徑可以是相對路徑，而且可能會導致檔案系統在預期的檔案系統目標路徑以外存取，進而導致惡意的設定變更，以及透過配置和等候技術執行遠端程式碼。</span><span class="sxs-lookup"><span data-stu-id="628ce-331">File path can be relative and can lead to file system access outside of the expected file system target path, leading to malicious config changes and remote code execution via lay-and-wait technique.</span></span>|
|[<span data-ttu-id="628ce-332">CA5390：請勿使用硬式編碼加密金鑰</span><span class="sxs-lookup"><span data-stu-id="628ce-332">CA5390: Do not hard-code encryption key</span></span>](ca5390.md)|<span data-ttu-id="628ce-333">若要讓對稱演算法成功，秘密金鑰必須只有傳送者和接收者才知道。</span><span class="sxs-lookup"><span data-stu-id="628ce-333">For a symmetric algorithm to be successful, the secret key must be known only to the sender and the receiver.</span></span> <span data-ttu-id="628ce-334">當金鑰硬式編碼時，很容易就能找到。</span><span class="sxs-lookup"><span data-stu-id="628ce-334">When a key is hard-coded, it is easily discovered.</span></span> <span data-ttu-id="628ce-335">即使是已編譯的二進位檔，惡意使用者也很容易將其解壓縮。</span><span class="sxs-lookup"><span data-stu-id="628ce-335">Even with compiled binaries, it is easy for malicious users to extract it.</span></span> <span data-ttu-id="628ce-336">一旦私密金鑰遭到入侵，就可以直接解密加密文字，而不會再受到保護。</span><span class="sxs-lookup"><span data-stu-id="628ce-336">Once the private key is compromised, the cipher text can be decrypted directly and is not protected anymore.</span></span>|
|[<span data-ttu-id="628ce-337">CA5391：請在 ASP.NET Core MVC 控制器中使用防偽權杖</span><span class="sxs-lookup"><span data-stu-id="628ce-337">CA5391: Use antiforgery tokens in ASP.NET Core MVC controllers</span></span>](ca5391.md)|<span data-ttu-id="628ce-338">處理 `POST` 、 `PUT` 、 `PATCH` 或 `DELETE` 要求而不驗證 antiforgery token，可能很容易受到跨網站偽造要求攻擊。</span><span class="sxs-lookup"><span data-stu-id="628ce-338">Handling a `POST`, `PUT`, `PATCH`, or `DELETE` request without validating an antiforgery token may be vulnerable to cross-site request forgery attacks.</span></span> <span data-ttu-id="628ce-339">跨網站偽造要求攻擊可以將來自已驗證使用者的惡意要求傳送到您的 ASP.NET Core MVC 控制器。</span><span class="sxs-lookup"><span data-stu-id="628ce-339">A cross-site request forgery attack can send malicious requests from an authenticated user to your ASP.NET Core MVC controller.</span></span>|
|[<span data-ttu-id="628ce-340">CA5392：請對 P/Invokes 使用 DefaultDllImportSearchPaths 屬性</span><span class="sxs-lookup"><span data-stu-id="628ce-340">CA5392: Use DefaultDllImportSearchPaths attribute for P/Invokes</span></span>](ca5392.md)|<span data-ttu-id="628ce-341">根據預設，P/Invoke 函式使用 <xref:System.Runtime.InteropServices.DllImportAttribute> 探查許多目錄，包括要載入之程式庫的目前工作目錄。</span><span class="sxs-lookup"><span data-stu-id="628ce-341">By default, P/Invoke functions using <xref:System.Runtime.InteropServices.DllImportAttribute> probe a number of directories, including the current working directory for the library to load.</span></span> <span data-ttu-id="628ce-342">這可能是某些應用程式的安全性問題，因而導致 DLL 劫持。</span><span class="sxs-lookup"><span data-stu-id="628ce-342">This can be a security issue for certain applications, leading to DLL hijacking.</span></span>|
|[<span data-ttu-id="628ce-343">CA5393：請勿使用不安全的 DllImportSearchPath 值</span><span class="sxs-lookup"><span data-stu-id="628ce-343">CA5393: Do not use unsafe DllImportSearchPath value</span></span>](ca5393.md)|<span data-ttu-id="628ce-344">預設 DLL 搜尋目錄和元件目錄中可能有惡意的 DLL。</span><span class="sxs-lookup"><span data-stu-id="628ce-344">There could be a malicious DLL in the default DLL search directories and assembly directories.</span></span> <span data-ttu-id="628ce-345">或者，根據執行應用程式的位置而定，應用程式的目錄中可能會有惡意的 DLL。</span><span class="sxs-lookup"><span data-stu-id="628ce-345">Or, depending on where your application is run from, there could be a malicious DLL in the application's directory.</span></span>|
|[<span data-ttu-id="628ce-346">CA5394：請勿使用不安全的隨機性</span><span class="sxs-lookup"><span data-stu-id="628ce-346">CA5394: Do not use insecure randomness</span></span>](ca5394.md)|<span data-ttu-id="628ce-347">使用密碼編譯弱式虛擬亂數產生器可能會讓攻擊者預測將產生的安全性敏感性值。</span><span class="sxs-lookup"><span data-stu-id="628ce-347">Using a cryptographically weak pseudo-random number generator may allow an attacker to predict what security-sensitive value will be generated.</span></span>|
|[<span data-ttu-id="628ce-348">CA5395：遺漏動作方法的 HttpVerb 屬性</span><span class="sxs-lookup"><span data-stu-id="628ce-348">CA5395: Miss HttpVerb attribute for action methods</span></span>](ca5395.md)|<span data-ttu-id="628ce-349">建立、編輯、刪除或以其他方式修改資料的所有動作方法，都必須使用 antiforgery 屬性來保護，以防止跨網站偽造要求攻擊。</span><span class="sxs-lookup"><span data-stu-id="628ce-349">All the action methods that create, edit, delete, or otherwise modify data needs to be protected with the antiforgery attribute from cross-site request forgery attacks.</span></span> <span data-ttu-id="628ce-350">執行 GET 作業應該是安全的作業，不會有副作用，也不會修改您的保存資料。</span><span class="sxs-lookup"><span data-stu-id="628ce-350">Performing a GET operation should be a safe operation that has no side effects and doesn't modify your persisted data.</span></span>|
|[<span data-ttu-id="628ce-351">CA5396：將 HttpCookie 的 HttpOnly 設為 true</span><span class="sxs-lookup"><span data-stu-id="628ce-351">CA5396: Set HttpOnly to true for HttpCookie</span></span>](ca5396.md)|<span data-ttu-id="628ce-352">作為深度防禦措施，請確定安全性敏感的 HTTP cookie 已標示為 HttpOnly。</span><span class="sxs-lookup"><span data-stu-id="628ce-352">As a defense in depth measure, ensure security sensitive HTTP cookies are marked as HttpOnly.</span></span> <span data-ttu-id="628ce-353">這表示網頁瀏覽器不允許腳本存取 cookie。</span><span class="sxs-lookup"><span data-stu-id="628ce-353">This indicates web browsers should disallow scripts from accessing the cookies.</span></span> <span data-ttu-id="628ce-354">插入的惡意腳本是竊取 cookie 的常見方式。</span><span class="sxs-lookup"><span data-stu-id="628ce-354">Injected malicious scripts are a common way of stealing cookies.</span></span>|
|[<span data-ttu-id="628ce-355">CA5397：請勿使用已過時的 SslProtocols 通訊協定</span><span class="sxs-lookup"><span data-stu-id="628ce-355">CA5397: Do not use deprecated SslProtocols values</span></span>](ca5397.md)|<span data-ttu-id="628ce-356">傳輸層安全性 (TLS) 保護電腦之間的通訊安全，最常見的方式是使用超文字傳輸通訊協定安全 (HTTPS) 。</span><span class="sxs-lookup"><span data-stu-id="628ce-356">Transport Layer Security (TLS) secures communication between computers, most commonly with Hypertext Transfer Protocol Secure (HTTPS).</span></span> <span data-ttu-id="628ce-357">舊版的 TLS 通訊協定版本比 TLS 1.2 和 TLS 1.3 更不安全，而且可能會有新的弱點。</span><span class="sxs-lookup"><span data-stu-id="628ce-357">Older protocol versions of TLS are less secure than TLS 1.2 and TLS 1.3 and are more likely to have new vulnerabilities.</span></span> <span data-ttu-id="628ce-358">避免較舊的通訊協定版本，以將風險降至最低。</span><span class="sxs-lookup"><span data-stu-id="628ce-358">Avoid older protocol versions to minimize risk.</span></span>|
|[<span data-ttu-id="628ce-359">CA5398：避免以硬式編碼方式寫入 SslProtocols 值</span><span class="sxs-lookup"><span data-stu-id="628ce-359">CA5398: Avoid hardcoded SslProtocols values</span></span>](ca5398.md)|<span data-ttu-id="628ce-360">傳輸層安全性 (TLS) 保護電腦之間的通訊安全，最常見的方式是使用超文字傳輸通訊協定安全 (HTTPS) 。</span><span class="sxs-lookup"><span data-stu-id="628ce-360">Transport Layer Security (TLS) secures communication between computers, most commonly with Hypertext Transfer Protocol Secure (HTTPS).</span></span> <span data-ttu-id="628ce-361">通訊協定版本 TLS 1.0 和 TLS 1.1 已被取代，而 TLS 1.2 和 TLS 1.3 是最新的。</span><span class="sxs-lookup"><span data-stu-id="628ce-361">Protocol versions TLS 1.0 and TLS 1.1 are deprecated, while TLS 1.2 and TLS 1.3 are current.</span></span> <span data-ttu-id="628ce-362">未來，TLS 1.2 和 TLS 1.3 可能已被取代。</span><span class="sxs-lookup"><span data-stu-id="628ce-362">In the future, TLS 1.2 and TLS 1.3 may be deprecated.</span></span> <span data-ttu-id="628ce-363">為了確保您的應用程式保持安全，請避免硬式編碼通訊協定版本。</span><span class="sxs-lookup"><span data-stu-id="628ce-363">To ensure that your application remains secure, avoid hardcoding a protocol version.</span></span>|
|[<span data-ttu-id="628ce-364">CA5399：確認停用 HttpClient 憑證撤銷清單檢查</span><span class="sxs-lookup"><span data-stu-id="628ce-364">CA5399: Definitely disable HttpClient certificate revocation list check</span></span>](ca5399.md)|<span data-ttu-id="628ce-365">撤銷的憑證不再受到信任。</span><span class="sxs-lookup"><span data-stu-id="628ce-365">A revoked certificate isn't trusted anymore.</span></span> <span data-ttu-id="628ce-366">攻擊者可以使用它來傳遞某些惡意資料，或竊取 HTTPS 通訊中的敏感性資料。</span><span class="sxs-lookup"><span data-stu-id="628ce-366">It could be used by attackers passing some malicious data or stealing sensitive data in HTTPS communication.</span></span>|
|[<span data-ttu-id="628ce-367">CA5400：確認未停用 HttpClient 憑證撤銷清單檢查</span><span class="sxs-lookup"><span data-stu-id="628ce-367">CA5400: Ensure HttpClient certificate revocation list check is not disabled</span></span>](ca5400.md)|<span data-ttu-id="628ce-368">撤銷的憑證不再受到信任。</span><span class="sxs-lookup"><span data-stu-id="628ce-368">A revoked certificate isn't trusted anymore.</span></span> <span data-ttu-id="628ce-369">攻擊者可以使用它來傳遞某些惡意資料，或竊取 HTTPS 通訊中的敏感性資料。</span><span class="sxs-lookup"><span data-stu-id="628ce-369">It could be used by attackers passing some malicious data or stealing sensitive data in HTTPS communication.</span></span>|
|[<span data-ttu-id="628ce-370">CA5401：請勿使用具有非預設 IV 的 CreateEncryptor</span><span class="sxs-lookup"><span data-stu-id="628ce-370">CA5401: Do not use CreateEncryptor with non-default IV</span></span>](ca5401.md)|<span data-ttu-id="628ce-371">對稱式加密應該一律使用不可重複的初始化向量來防止字典攻擊。</span><span class="sxs-lookup"><span data-stu-id="628ce-371">Symmetric encryption should always use a non-repeatable initialization vector to prevent dictionary attacks.</span></span>|
|[<span data-ttu-id="628ce-372">CA5402：使用具有預設 IV 的 CreateEncryptor</span><span class="sxs-lookup"><span data-stu-id="628ce-372">CA5402: Use CreateEncryptor with the default IV</span></span>](ca5402.md)|<span data-ttu-id="628ce-373">對稱式加密應該一律使用不可重複的初始化向量來防止字典攻擊。</span><span class="sxs-lookup"><span data-stu-id="628ce-373">Symmetric encryption should always use a non-repeatable initialization vector to prevent dictionary attacks.</span></span>|
|[<span data-ttu-id="628ce-374">CA5403:不要硬式編碼憑證</span><span class="sxs-lookup"><span data-stu-id="628ce-374">CA5403: Do not hard-code certificate</span></span>](ca5403.md)|<span data-ttu-id="628ce-375">`data`或函式的或 `rawData` 參數 <xref:System.Security.Cryptography.X509Certificates.X509Certificate> <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> 是硬式編碼。</span><span class="sxs-lookup"><span data-stu-id="628ce-375">The `data` or `rawData` parameter of a <xref:System.Security.Cryptography.X509Certificates.X509Certificate> or <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> constructor is hard-coded.</span></span>|
