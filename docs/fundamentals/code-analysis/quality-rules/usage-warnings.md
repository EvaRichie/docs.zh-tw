---
title: '使用規則 (程式碼分析) '
description: 瞭解程式碼分析使用規則。
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- vs.codeanalysis.usagerules
helpviewer_keywords:
- rules, usage
- managed code analysis rules, usage rules
- usage rules
author: gewarren
ms.author: gewarren
ms.openlocfilehash: c8b14d2f92502d5a82e41a322e599745bdcf8b85
ms.sourcegitcommit: a6bd4cad438fe479cbd112eae10f2cd449f06e40
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 10/08/2020
ms.locfileid: "96586463"
---
# <a name="usage-rules"></a><span data-ttu-id="ca834-103">使用規則</span><span class="sxs-lookup"><span data-stu-id="ca834-103">Usage rules</span></span>

<span data-ttu-id="ca834-104">使用規則支援適當使用 .NET。</span><span class="sxs-lookup"><span data-stu-id="ca834-104">Usage rules support proper usage of .NET.</span></span>

## <a name="in-this-section"></a><span data-ttu-id="ca834-105">本節內容</span><span class="sxs-lookup"><span data-stu-id="ca834-105">In this section</span></span>

|<span data-ttu-id="ca834-106">規則</span><span class="sxs-lookup"><span data-stu-id="ca834-106">Rule</span></span>|<span data-ttu-id="ca834-107">描述</span><span class="sxs-lookup"><span data-stu-id="ca834-107">Description</span></span>|
|----------|-----------------|
|[<span data-ttu-id="ca834-108">CA1801:必須檢閱未使用的參數</span><span class="sxs-lookup"><span data-stu-id="ca834-108">CA1801: Review unused parameters</span></span>](ca1801.md)|<span data-ttu-id="ca834-109">方法簽章包括不用於方法主體中的參數；</span><span class="sxs-lookup"><span data-stu-id="ca834-109">A method signature includes a parameter that is not used in the method body.</span></span>|
|[<span data-ttu-id="ca834-110">CA1816:正確呼叫 GC.SuppressFinalize</span><span class="sxs-lookup"><span data-stu-id="ca834-110">CA1816: Call GC.SuppressFinalize correctly</span></span>](ca1816.md)|<span data-ttu-id="ca834-111">實值處置的方法不會呼叫，或不是執行 `GC.SuppressFinalize` 呼叫的方法 `Dispose` `GC.SuppressFinalize` ; 或方法呼叫 `GC.SuppressFinalize` ，並 `this` `Me` 在 Visual Basic) 中傳遞非 (的其他內容。</span><span class="sxs-lookup"><span data-stu-id="ca834-111">A method that is an implementation of Dispose does not call `GC.SuppressFinalize`; or a method that is not an implementation of `Dispose` calls `GC.SuppressFinalize`; or a method calls `GC.SuppressFinalize` and passes something other than `this` (`Me` in Visual Basic).</span></span>|
|[<span data-ttu-id="ca834-112">CA2200:必須重新擲回以保存堆疊詳細資料</span><span class="sxs-lookup"><span data-stu-id="ca834-112">CA2200: Rethrow to preserve stack details</span></span>](ca2200.md)|<span data-ttu-id="ca834-113">例外狀況遭到重新擲回，而且已在 throw 陳述式中明確指定此例外狀況。</span><span class="sxs-lookup"><span data-stu-id="ca834-113">An exception is rethrown and the exception is explicitly specified in the throw statement.</span></span> <span data-ttu-id="ca834-114">如果例外狀況是透過在陳述式中指定例外狀況而重新擲回，則會遺失在擲回例外狀況之原始方法和目前方法之間呼叫的方法清單。</span><span class="sxs-lookup"><span data-stu-id="ca834-114">If an exception is rethrown by specifying the exception in the throw statement, the list of method calls between the original method that threw the exception and the current method is lost.</span></span>|
|[<span data-ttu-id="ca834-115">CA2201:不要引發保留的例外狀況類型</span><span class="sxs-lookup"><span data-stu-id="ca834-115">CA2201: Do not raise reserved exception types</span></span>](ca2201.md)|<span data-ttu-id="ca834-116">這會讓原始錯誤難以偵測和偵測。</span><span class="sxs-lookup"><span data-stu-id="ca834-116">This makes the original error hard to detect and debug.</span></span>|
|[<span data-ttu-id="ca834-117">CA2207:必須將實值類型的靜態欄位內嵌初始化</span><span class="sxs-lookup"><span data-stu-id="ca834-117">CA2207: Initialize value type static fields inline</span></span>](ca2207.md)|<span data-ttu-id="ca834-118">實值類型會宣告明確的靜態建構函式。</span><span class="sxs-lookup"><span data-stu-id="ca834-118">A value type declares an explicit static constructor.</span></span> <span data-ttu-id="ca834-119">若要修正此規則的違規情形，請在宣告所有靜態資料時將靜態資料初始化，並移除靜態建構函式。</span><span class="sxs-lookup"><span data-stu-id="ca834-119">To fix a violation of this rule, initialize all static data when it is declared and remove the static constructor.</span></span>|
|[<span data-ttu-id="ca834-120">CA2208:必須正確執行個體化引數例外狀況</span><span class="sxs-lookup"><span data-stu-id="ca834-120">CA2208: Instantiate argument exceptions correctly</span></span>](ca2208.md)|<span data-ttu-id="ca834-121">對例外狀況類型為 (或衍生自) ArgumentException 的預設 (無參數) 建構函式進行呼叫，或將錯誤的字串引數傳遞至例外狀況類型為 (或衍生自) ArgumentException 的參數化建構函式。</span><span class="sxs-lookup"><span data-stu-id="ca834-121">A call is made to the default (parameterless) constructor of an exception type that is or derives from ArgumentException, or an incorrect string argument is passed to a parameterized constructor of an exception type that is or derives from ArgumentException.</span></span>|
|[<span data-ttu-id="ca834-122">CA2211:非常數欄位不應該為可見的</span><span class="sxs-lookup"><span data-stu-id="ca834-122">CA2211: Non-constant fields should not be visible</span></span>](ca2211.md)|<span data-ttu-id="ca834-123">非常數或唯讀的靜態欄位不是安全線程。</span><span class="sxs-lookup"><span data-stu-id="ca834-123">Static fields that are not constants or read-only are not thread-safe.</span></span> <span data-ttu-id="ca834-124">對這類欄位的存取權必須謹慎控制，且需要先進的程式設計技巧來同步處理對類別物件的存取。</span><span class="sxs-lookup"><span data-stu-id="ca834-124">Access to such a field must be carefully controlled and requires advanced programming techniques for synchronizing access to the class object.</span></span>|
|[<span data-ttu-id="ca834-125">CA2213:可處置的欄位應該受到處置</span><span class="sxs-lookup"><span data-stu-id="ca834-125">CA2213: Disposable fields should be disposed</span></span>](ca2213.md)|<span data-ttu-id="ca834-126">型別，這個型別 <xref:System.IDisposable?displayProperty=fullName> 會針對也會實作為型別的宣告欄位 `IDisposable` 。</span><span class="sxs-lookup"><span data-stu-id="ca834-126">A type that implements <xref:System.IDisposable?displayProperty=fullName> declares fields that are of types that also implement `IDisposable`.</span></span> <span data-ttu-id="ca834-127">宣告 `Dispose` 類型的方法不會呼叫欄位的方法 `Dispose` 。</span><span class="sxs-lookup"><span data-stu-id="ca834-127">The `Dispose` method of the field is not called by the `Dispose` method of the declaring type.</span></span>|
|[<span data-ttu-id="ca834-128">CA2214:不要呼叫建構函式中的可覆寫方法</span><span class="sxs-lookup"><span data-stu-id="ca834-128">CA2214: Do not call overridable methods in constructors</span></span>](ca2214.md)|<span data-ttu-id="ca834-129">當函式呼叫虛擬方法時，叫用方法之實例的函式可能尚未執行。</span><span class="sxs-lookup"><span data-stu-id="ca834-129">When a constructor calls a virtual method, it is possible that the constructor for the instance that invokes the method has not executed.</span></span>|
|[<span data-ttu-id="ca834-130">CA2215:Dispose 方法應該呼叫基底類別處置</span><span class="sxs-lookup"><span data-stu-id="ca834-130">CA2215: Dispose methods should call base class dispose</span></span>](ca2215.md)|<span data-ttu-id="ca834-131">如果型別繼承自可處置的型別，則必須 `Dispose` 從它自己的方法呼叫基底型別的方法 `Dispose` 。</span><span class="sxs-lookup"><span data-stu-id="ca834-131">If a type inherits from a disposable type, it must call the `Dispose` method of the base type from its own `Dispose` method.</span></span>|
|[<span data-ttu-id="ca834-132">CA2216:可處置的類型應該宣告完成項</span><span class="sxs-lookup"><span data-stu-id="ca834-132">CA2216: Disposable types should declare finalizer</span></span>](ca2216.md)|<span data-ttu-id="ca834-133">實作為的型別 <xref:System.IDisposable?displayProperty=fullName> ，而且有一些欄位建議使用非受控資源，並不會依照所述的方式來執行完成項 `Object.Finalize` 。</span><span class="sxs-lookup"><span data-stu-id="ca834-133">A type that implements <xref:System.IDisposable?displayProperty=fullName>, and has fields that suggest the use of unmanaged resources, does not implement a finalizer as described by `Object.Finalize`.</span></span>|
|[<span data-ttu-id="ca834-134">CA2217:不要以 FlagsAttribute 標記列舉</span><span class="sxs-lookup"><span data-stu-id="ca834-134">CA2217: Do not mark enums with FlagsAttribute</span></span>](ca2217.md)|<span data-ttu-id="ca834-135">外部可見的列舉會標示為 `FlagsAttribute` ，而且有一或多個值不是兩個或列舉上其他已定義值的組合。</span><span class="sxs-lookup"><span data-stu-id="ca834-135">An externally visible enumeration is marked with `FlagsAttribute`, and it has one or more values that are not powers of two or a combination of the other defined values on the enumeration.</span></span>|
|[<span data-ttu-id="ca834-136">CA2218:覆寫 Equals 時必須一併覆寫 GetHashCode</span><span class="sxs-lookup"><span data-stu-id="ca834-136">CA2218: Override GetHashCode on overriding Equals</span></span>](ca2218.md)|<span data-ttu-id="ca834-137">Public 類型會覆寫 <xref:System.Object.Equals%2A?displayProperty=fullName> ，但不會覆寫 <xref:System.Object.GetHashCode%2A?displayProperty=fullName> 。</span><span class="sxs-lookup"><span data-stu-id="ca834-137">A public type overrides <xref:System.Object.Equals%2A?displayProperty=fullName> but does not override <xref:System.Object.GetHashCode%2A?displayProperty=fullName>.</span></span>|
|[<span data-ttu-id="ca834-138">CA2219:不要在 exception 子句中引發例外狀況</span><span class="sxs-lookup"><span data-stu-id="ca834-138">CA2219: Do not raise exceptions in exception clauses</span></span>](ca2219.md)|<span data-ttu-id="ca834-139">在 finally 或 fault 子句中引發例外狀況時，新的例外狀況會隱藏作用中的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="ca834-139">When an exception is raised in a finally or fault clause, the new exception hides the active exception.</span></span> <span data-ttu-id="ca834-140">在 filter 子句中引發例外狀況時，執行階段會以無訊息模式攔截例外狀況。</span><span class="sxs-lookup"><span data-stu-id="ca834-140">When an exception is raised in a filter clause, the run time silently catches the exception.</span></span> <span data-ttu-id="ca834-141">這會讓原始錯誤難以偵測和偵測。</span><span class="sxs-lookup"><span data-stu-id="ca834-141">This makes the original error hard to detect and debug.</span></span>|
|[<span data-ttu-id="ca834-142">CA2224:多載等號比較運算子時必須一併覆寫 Equals</span><span class="sxs-lookup"><span data-stu-id="ca834-142">CA2224: Override equals on overloading operator equals</span></span>](ca2224.md)|<span data-ttu-id="ca834-143">Public 型別會執行等號比較運算子，但不會覆寫 <xref:System.Object.Equals%2A?displayProperty=fullName> 。</span><span class="sxs-lookup"><span data-stu-id="ca834-143">A public type implements the equality operator but doesn't override <xref:System.Object.Equals%2A?displayProperty=fullName>.</span></span>|
|[<span data-ttu-id="ca834-144">CA2225:運算子多載必須有具名的替代方法</span><span class="sxs-lookup"><span data-stu-id="ca834-144">CA2225: Operator overloads have named alternates</span></span>](ca2225.md)|<span data-ttu-id="ca834-145">偵測到運算子多載，且找不到預期的具名替代方法。</span><span class="sxs-lookup"><span data-stu-id="ca834-145">An operator overload was detected, and the expected named alternative method was not found.</span></span> <span data-ttu-id="ca834-146">已命名的替代成員提供與運算子相同功能的存取權，並提供給以不支援多載運算子的語言撰寫程式的開發人員使用。</span><span class="sxs-lookup"><span data-stu-id="ca834-146">The named alternative member provides access to the same functionality as the operator, and is provided for developers who program in languages that do not support overloaded operators.</span></span>|
|[<span data-ttu-id="ca834-147">CA2226:運算子應該有對稱的多載</span><span class="sxs-lookup"><span data-stu-id="ca834-147">CA2226: Operators should have symmetrical overloads</span></span>](ca2226.md)|<span data-ttu-id="ca834-148">型別會執行相等或不等比較運算子，且不會執行相反的運算子。</span><span class="sxs-lookup"><span data-stu-id="ca834-148">A type implements the equality or inequality operator, and does not implement the opposite operator.</span></span>|
|[<span data-ttu-id="ca834-149">CA2227:集合屬性應該為唯讀</span><span class="sxs-lookup"><span data-stu-id="ca834-149">CA2227: Collection properties should be read only</span></span>](ca2227.md)|<span data-ttu-id="ca834-150">可寫入的集合屬性允許使用者以不同的集合來取代該集合。</span><span class="sxs-lookup"><span data-stu-id="ca834-150">A writable collection property allows a user to replace the collection with a different collection.</span></span> <span data-ttu-id="ca834-151">唯讀屬性會從取代過程中停止集合，但是仍然允許設定個別成員。</span><span class="sxs-lookup"><span data-stu-id="ca834-151">A read-only property stops the collection from being replaced but still allows the individual members to be set.</span></span>|
|[<span data-ttu-id="ca834-152">CA2229:必須實作序列化建構函式</span><span class="sxs-lookup"><span data-stu-id="ca834-152">CA2229: Implement serialization constructors</span></span>](ca2229.md)|<span data-ttu-id="ca834-153">若要修正此規則的違規情形，請實作序列化建構函式。</span><span class="sxs-lookup"><span data-stu-id="ca834-153">To fix a violation of this rule, implement the serialization constructor.</span></span> <span data-ttu-id="ca834-154">針對密封類別，讓建構函式成為 private，否則為 protected。</span><span class="sxs-lookup"><span data-stu-id="ca834-154">For a sealed class, make the constructor private; otherwise, make it protected.</span></span>|
|[<span data-ttu-id="ca834-155">CA2231:在覆寫 ValueType.Equals 上多載等號運算子</span><span class="sxs-lookup"><span data-stu-id="ca834-155">CA2231: Overload operator equals on overriding ValueType.Equals</span></span>](ca2231.md)|<span data-ttu-id="ca834-156">實值型別 `Object.Equals` 會覆寫，但不會執行等號比較運算子。</span><span class="sxs-lookup"><span data-stu-id="ca834-156">A value type overrides `Object.Equals` but does not implement the equality operator.</span></span>|
|[<span data-ttu-id="ca834-157">CA2234:必須傳遞 System.Uri 物件而非字串</span><span class="sxs-lookup"><span data-stu-id="ca834-157">CA2234: Pass System.Uri objects instead of strings</span></span>](ca2234.md)|<span data-ttu-id="ca834-158">呼叫字串參數名稱包含 "uri"、"URI"、"urn"、"URN"、"url" 或 "URL"，</span><span class="sxs-lookup"><span data-stu-id="ca834-158">A call is made to a method that has a string parameter whose name contains "uri", "URI", "urn", "URN", "url", or "URL".</span></span>  <span data-ttu-id="ca834-159">方法的宣告類型包含具有參數的對應方法多載 <xref:System.Uri?displayProperty=fullName> 。</span><span class="sxs-lookup"><span data-stu-id="ca834-159">The declaring type of the method contains a corresponding method overload that has a <xref:System.Uri?displayProperty=fullName> parameter.</span></span>|
|[<span data-ttu-id="ca834-160">CA2235:必須標記所有不可序列化的欄位</span><span class="sxs-lookup"><span data-stu-id="ca834-160">CA2235: Mark all non-serializable fields</span></span>](ca2235.md)|<span data-ttu-id="ca834-161">可序列化之類型中所宣告之類型的執行個體 (Instance) 欄位是不可序列化的。</span><span class="sxs-lookup"><span data-stu-id="ca834-161">An instance field of a type that is not serializable is declared in a type that is serializable.</span></span>|
|[<span data-ttu-id="ca834-162">CA2237:ISerializable 類型必須標記 SerializableAttribute</span><span class="sxs-lookup"><span data-stu-id="ca834-162">CA2237: Mark ISerializable types with SerializableAttribute</span></span>](ca2237.md)|<span data-ttu-id="ca834-163">若要以可序列化的 common language runtime 辨識，型別必須以 SerializableAttribute 屬性標記，即使型別使用自訂序列化常式，也是透過介面的實 `ISerializable` 。</span><span class="sxs-lookup"><span data-stu-id="ca834-163">To be recognized by the common language runtime as serializable, types must be marked with the SerializableAttribute attribute even if the type uses a custom serialization routine through implementation of the `ISerializable` interface.</span></span>|
|[<span data-ttu-id="ca834-164">CA2241:必須提供格式化方法的正確引數</span><span class="sxs-lookup"><span data-stu-id="ca834-164">CA2241: Provide correct arguments to formatting methods</span></span>](ca2241.md)|<span data-ttu-id="ca834-165">傳遞給的格式引數 <xref:System.String.Format%2A?displayProperty=nameWithType> 不包含對應至每個物件引數的格式專案，反之亦然。</span><span class="sxs-lookup"><span data-stu-id="ca834-165">The format argument passed to <xref:System.String.Format%2A?displayProperty=nameWithType> does not contain a format item that corresponds to each object argument, or vice versa.</span></span>|
|[<span data-ttu-id="ca834-166">CA2242:必須正確測試 NaN</span><span class="sxs-lookup"><span data-stu-id="ca834-166">CA2242: Test for NaN correctly</span></span>](ca2242.md)|<span data-ttu-id="ca834-167">此運算式會針對或測試 `Single.Nan` 值 `Double.Nan` 。</span><span class="sxs-lookup"><span data-stu-id="ca834-167">This expression tests a value against `Single.Nan` or `Double.Nan`.</span></span> <span data-ttu-id="ca834-168">使用 `Single.IsNan(Single)` 或 `Double.IsNan(Double)` 來測試值。</span><span class="sxs-lookup"><span data-stu-id="ca834-168">Use `Single.IsNan(Single)` or `Double.IsNan(Double)` to test the value.</span></span>|
|[<span data-ttu-id="ca834-169">CA2243:屬性字串常值必須正確剖析</span><span class="sxs-lookup"><span data-stu-id="ca834-169">CA2243: Attribute string literals should parse correctly</span></span>](ca2243.md)|<span data-ttu-id="ca834-170">屬性的字串常值參數未正確剖析 URL、GUID 或版本。</span><span class="sxs-lookup"><span data-stu-id="ca834-170">An attribute's string literal parameter does not parse correctly for a URL, a GUID, or a version.</span></span>|
|[<span data-ttu-id="ca834-171">CA2244：請勿複製索引元素初始化</span><span class="sxs-lookup"><span data-stu-id="ca834-171">CA2244: Do not duplicate indexed element initializations</span></span>](ca2244.md)|<span data-ttu-id="ca834-172">物件初始化運算式有一個以上的索引元素初始化運算式具有相同的常數索引。</span><span class="sxs-lookup"><span data-stu-id="ca834-172">An object initializer has more than one indexed element initializer with the same constant index.</span></span> <span data-ttu-id="ca834-173">但最後一個初始化運算式是多餘的。</span><span class="sxs-lookup"><span data-stu-id="ca834-173">All but the last initializer are redundant.</span></span>|
|[<span data-ttu-id="ca834-174">CA2245：請勿將屬性指派給屬性自身</span><span class="sxs-lookup"><span data-stu-id="ca834-174">CA2245: Do not assign a property to itself</span></span>](ca2245.md)|<span data-ttu-id="ca834-175">屬性意外指派給本身。</span><span class="sxs-lookup"><span data-stu-id="ca834-175">A property was accidentally assigned to itself.</span></span>|
|[<span data-ttu-id="ca834-176">CA2246：請勿在相同的陳述式中指派符號及其成員</span><span class="sxs-lookup"><span data-stu-id="ca834-176">CA2246: Do not assign a symbol and its member in the same statement</span></span>](ca2246.md)|<span data-ttu-id="ca834-177">不建議在相同的語句中指派符號及其成員，也就是欄位或屬性。</span><span class="sxs-lookup"><span data-stu-id="ca834-177">Assigning a symbol and its member, that is, a field or a property, in the same statement is not recommended.</span></span> <span data-ttu-id="ca834-178">如果成員存取的目的是要在指派之前使用符號的舊值，或是在此語句中指派新值，則不會很清楚。</span><span class="sxs-lookup"><span data-stu-id="ca834-178">It is not clear if the member access was intended to use the symbol's old value prior to the assignment or the new value from the assignment in this statement.</span></span>|
|[<span data-ttu-id="ca834-179">CA2247：傳遞到 TaskCompletionSource 建構函式的引數應為 TaskCreationOptions 列舉，而非 TaskContinuationOptions 列舉</span><span class="sxs-lookup"><span data-stu-id="ca834-179">CA2247: Argument passed to TaskCompletionSource constructor should be TaskCreationOptions enum instead of TaskContinuationOptions enum</span></span>](ca2246.md)|<span data-ttu-id="ca834-180">>taskcompletionsource 具有可使用 TaskCreationOptions 來控制基礎工作的函式，以及採用儲存在工作中之物件狀態的函式。</span><span class="sxs-lookup"><span data-stu-id="ca834-180">TaskCompletionSource has constructors that take TaskCreationOptions that control the underlying Task, and constructors that take object state that's stored in the task.</span></span>  <span data-ttu-id="ca834-181">不小心傳遞 System.threading.tasks.taskcontinuationoptions> 而非 TaskCreationOptions，會導致呼叫將選項視為狀態。</span><span class="sxs-lookup"><span data-stu-id="ca834-181">Accidentally passing a TaskContinuationOptions instead of a TaskCreationOptions will result in the call treating the options as state.</span></span>|
|[<span data-ttu-id="ca834-182">CA2248：提供正確的 ' enum ' 引數給 ' Enum. HasFlag '</span><span class="sxs-lookup"><span data-stu-id="ca834-182">CA2248: Provide correct 'enum' argument to 'Enum.HasFlag'</span></span>](ca2248.md)|<span data-ttu-id="ca834-183">作為引數傳遞至方法呼叫的列舉類型 `HasFlag` ，與呼叫列舉型別不同。</span><span class="sxs-lookup"><span data-stu-id="ca834-183">The enum type passed as an argument to the `HasFlag` method call is different from the calling enum type.</span></span>|
|[<span data-ttu-id="ca834-184">CA2249：請考慮使用 String.Contains 而非 String.IndexOf</span><span class="sxs-lookup"><span data-stu-id="ca834-184">CA2249: Consider using String.Contains instead of String.IndexOf</span></span>](ca2249.md)|<span data-ttu-id="ca834-185">呼叫 `string.IndexOf` 結果的位置來檢查是否有子字串存在，可由取代 `string.Contains` 。</span><span class="sxs-lookup"><span data-stu-id="ca834-185">Calls to `string.IndexOf` where the result is used to check for the presence or absence of a substring can be replaced by `string.Contains`.</span></span>|
