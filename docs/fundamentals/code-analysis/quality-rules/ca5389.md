---
title: 'CA5389：請勿將封存專案的路徑新增至目的檔案系統路徑 (程式碼分析) '
description: 提供程式碼分析規則 CA5389 的相關資訊，包括原因、如何修正違規，以及何時將其隱藏。
ms.date: 08/14/2019
ms.topic: reference
author: filipsebesta
ms.author: filipse
dev_langs:
- CSharp
f1_keywords:
- CA5389
- DoNotAddArchiveItemPathToTheTargetFileSystemPath
ms.openlocfilehash: 35732af3032a5754999f98423b204d5ed44cbf47
ms.sourcegitcommit: e301979e3049ce412d19b094c60ed95b316a8f8c
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 12/16/2020
ms.locfileid: "97593600"
---
# <a name="ca5389-do-not-add-archive-items-path-to-the-target-file-system-path"></a><span data-ttu-id="c1c33-103">CA5389：不將封存項目路徑新增至目標檔案系統路徑</span><span class="sxs-lookup"><span data-stu-id="c1c33-103">CA5389: Do not add archive item's path to the target file system path</span></span>

| | <span data-ttu-id="c1c33-104">值</span><span class="sxs-lookup"><span data-stu-id="c1c33-104">Value</span></span> |
|-|-|
| <span data-ttu-id="c1c33-105">**規則識別碼**</span><span class="sxs-lookup"><span data-stu-id="c1c33-105">**Rule ID**</span></span> |<span data-ttu-id="c1c33-106">CA5389</span><span class="sxs-lookup"><span data-stu-id="c1c33-106">CA5389</span></span>|
| <span data-ttu-id="c1c33-107">**類別**</span><span class="sxs-lookup"><span data-stu-id="c1c33-107">**Category**</span></span> |<span data-ttu-id="c1c33-108">Microsoft.Security</span><span class="sxs-lookup"><span data-stu-id="c1c33-108">Microsoft.Security</span></span>|
| <span data-ttu-id="c1c33-109">**修正程式中斷或未中斷**</span><span class="sxs-lookup"><span data-stu-id="c1c33-109">**Fix is breaking or non-breaking**</span></span> |<span data-ttu-id="c1c33-110">非中斷</span><span class="sxs-lookup"><span data-stu-id="c1c33-110">Non-breaking</span></span>|

## <a name="cause"></a><span data-ttu-id="c1c33-111">原因</span><span class="sxs-lookup"><span data-stu-id="c1c33-111">Cause</span></span>

<span data-ttu-id="c1c33-112">未清理的原始程式檔路徑會當做其中一個參數的目標檔案路徑使用：</span><span class="sxs-lookup"><span data-stu-id="c1c33-112">A non-sanitized source file path is used as the target file path in one of these parameters:</span></span>

- <span data-ttu-id="c1c33-113">`destinationFileName`方法的參數<xref:System.IO.Compression.ZipFileExtensions.ExtractToFile%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="c1c33-113">parameter `destinationFileName` of method <xref:System.IO.Compression.ZipFileExtensions.ExtractToFile%2A?displayProperty=nameWithType></span></span>
- <span data-ttu-id="c1c33-114">`path`方法的參數<xref:System.IO.File.Open%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="c1c33-114">parameter `path` of method <xref:System.IO.File.Open%2A?displayProperty=nameWithType></span></span>
- <span data-ttu-id="c1c33-115">`path`方法的參數<xref:System.IO.File.OpenWrite%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="c1c33-115">parameter `path` of method <xref:System.IO.File.OpenWrite%2A?displayProperty=nameWithType></span></span>
- <span data-ttu-id="c1c33-116">`path`方法的參數<xref:System.IO.File.Create%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="c1c33-116">parameter `path` of method <xref:System.IO.File.Create%2A?displayProperty=nameWithType></span></span>
- <span data-ttu-id="c1c33-117">的函式參數 `path`<xref:System.IO.FileStream></span><span class="sxs-lookup"><span data-stu-id="c1c33-117">parameter `path` of constructor for <xref:System.IO.FileStream></span></span>
- <span data-ttu-id="c1c33-118">的函式參數 `fileName`<xref:System.IO.FileInfo></span><span class="sxs-lookup"><span data-stu-id="c1c33-118">parameter `fileName` of constructor for <xref:System.IO.FileInfo></span></span>

<span data-ttu-id="c1c33-119">根據預設，此規則會分析整個程式碼基底，但這是 [可](#configure-code-to-analyze)設定的。</span><span class="sxs-lookup"><span data-stu-id="c1c33-119">By default, this rule analyzes the entire codebase, but this is [configurable](#configure-code-to-analyze).</span></span>

## <a name="rule-description"></a><span data-ttu-id="c1c33-120">規則描述</span><span class="sxs-lookup"><span data-stu-id="c1c33-120">Rule description</span></span>

<span data-ttu-id="c1c33-121">檔案路徑可以是相對路徑，而且可能會導致檔案系統在預期的檔案系統目標路徑以外存取，進而導致惡意的設定變更，以及透過配置和等候技術執行遠端程式碼。</span><span class="sxs-lookup"><span data-stu-id="c1c33-121">File path can be relative and can lead to file system access outside of the expected file system target path, leading to malicious config changes and remote code execution via lay-and-wait technique.</span></span>

## <a name="how-to-fix-violations"></a><span data-ttu-id="c1c33-122">如何修正違規</span><span class="sxs-lookup"><span data-stu-id="c1c33-122">How to fix violations</span></span>

<span data-ttu-id="c1c33-123">請勿使用來源檔案路徑來建立目標檔案路徑，或確定解壓縮路徑上的最後一個字元是目錄分隔字元。</span><span class="sxs-lookup"><span data-stu-id="c1c33-123">Do not use the source file path to construct the target file path, or make sure that the last character on the extraction path is the directory separator character.</span></span>

## <a name="when-to-suppress-warnings"></a><span data-ttu-id="c1c33-124">隱藏警告的時機</span><span class="sxs-lookup"><span data-stu-id="c1c33-124">When to suppress warnings</span></span>

<span data-ttu-id="c1c33-125">如果來源路徑永遠來自受信任的來源，您可以隱藏此警告。</span><span class="sxs-lookup"><span data-stu-id="c1c33-125">You can suppress this warning if the source path always comes from a trusted source.</span></span>

## <a name="configure-code-to-analyze"></a><span data-ttu-id="c1c33-126">設定要分析的程式碼</span><span class="sxs-lookup"><span data-stu-id="c1c33-126">Configure code to analyze</span></span>

<span data-ttu-id="c1c33-127">使用下列選項來設定您的程式碼基底要執行此規則的部分。</span><span class="sxs-lookup"><span data-stu-id="c1c33-127">Use the following options to configure which parts of your codebase to run this rule on.</span></span>

- [<span data-ttu-id="c1c33-128">排除特定符號</span><span class="sxs-lookup"><span data-stu-id="c1c33-128">Exclude specific symbols</span></span>](#exclude-specific-symbols)
- [<span data-ttu-id="c1c33-129">排除特定類型及其衍生類型</span><span class="sxs-lookup"><span data-stu-id="c1c33-129">Exclude specific types and their derived types</span></span>](#exclude-specific-types-and-their-derived-types)

<span data-ttu-id="c1c33-130">您可以只針對此規則、所有規則或此類別中的所有規則設定這些選項， (安全性) 。</span><span class="sxs-lookup"><span data-stu-id="c1c33-130">You can configure these options for just this rule, for all rules, or for all rules in this category (Security).</span></span> <span data-ttu-id="c1c33-131">如需詳細資訊，請參閱程式 [代碼品質規則配置選項](../code-quality-rule-options.md)。</span><span class="sxs-lookup"><span data-stu-id="c1c33-131">For more information, see [Code quality rule configuration options](../code-quality-rule-options.md).</span></span>

[!INCLUDE[excluded-symbol-names](~/includes/code-analysis/excluded-symbol-names.md)]

[!INCLUDE[excluded-type-names-with-derived-types](~/includes/code-analysis/excluded-type-names-with-derived-types.md)]

## <a name="example"></a><span data-ttu-id="c1c33-132">範例</span><span class="sxs-lookup"><span data-stu-id="c1c33-132">Example</span></span>

<span data-ttu-id="c1c33-133">下列程式碼片段說明這個規則偵測到的模式。</span><span class="sxs-lookup"><span data-stu-id="c1c33-133">The following code snippet illustrates the pattern detected by this rule.</span></span>

<span data-ttu-id="c1c33-134">違反：</span><span class="sxs-lookup"><span data-stu-id="c1c33-134">Violation:</span></span>

```csharp
using System.IO.Compression;

class TestClass
{
    public void TestMethod(ZipArchiveEntry zipArchiveEntry)
    {
        zipArchiveEntry.ExtractToFile(zipArchiveEntry.FullName);
    }
}
```

<span data-ttu-id="c1c33-135">解決方案：</span><span class="sxs-lookup"><span data-stu-id="c1c33-135">Solution:</span></span>

```csharp
using System;
using System.IO;
using System.IO.Compression;

class Program
{
    static void Main(string[] args)
    {
        string zipPath = @".\result.zip";

        Console.WriteLine("Provide path where to extract the zip file:");
        string extractPath = Console.ReadLine();

        // Normalizes the path.
        extractPath = Path.GetFullPath(extractPath);

        // Ensures that the last character on the extraction path
        // is the directory separator char.
        // Without this, a malicious zip file could try to traverse outside of the expected
        // extraction path.
        if (!extractPath.EndsWith(Path.DirectorySeparatorChar.ToString(), StringComparison.Ordinal))
            extractPath += Path.DirectorySeparatorChar;

        using (ZipArchive archive = ZipFile.OpenRead(zipPath))
        {
            foreach (ZipArchiveEntry entry in archive.Entries)
            {
                if (entry.FullName.EndsWith(".txt", StringComparison.OrdinalIgnoreCase))
                {
                    // Gets the full path to ensure that relative segments are removed.
                    string destinationPath = Path.GetFullPath(Path.Combine(extractPath, entry.FullName));

                    // Ordinal match is safest, case-sensitive volumes can be mounted within volumes that
                    // are case-insensitive.
                    if (destinationPath.StartsWith(extractPath, StringComparison.Ordinal))
                        entry.ExtractToFile(destinationPath);
                }
            }
        }
    }
}
```
