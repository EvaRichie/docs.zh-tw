---
title: '效能規則 (程式碼分析) '
description: 瞭解程式碼分析效能規則。
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- vs.codeanalysis.performancerules
helpviewer_keywords:
- rules, performance
- performance rules
- performance, rules
- managed code analysis rules, performance rules
author: gewarren
ms.author: gewarren
ms.openlocfilehash: 4409cc46eb73f13f8e59d7a51899da27035bb6af
ms.sourcegitcommit: 2e4adc490c1d2a705a0592b295d606b10b9f51f1
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 09/25/2020
ms.locfileid: "96585234"
---
# <a name="performance-rules"></a><span data-ttu-id="d7e95-103">效能規則</span><span class="sxs-lookup"><span data-stu-id="d7e95-103">Performance rules</span></span>

<span data-ttu-id="d7e95-104">效能規則支援高效能程式庫和應用程式。</span><span class="sxs-lookup"><span data-stu-id="d7e95-104">Performance rules support high-performance libraries and applications.</span></span>

## <a name="in-this-section"></a><span data-ttu-id="d7e95-105">本節內容</span><span class="sxs-lookup"><span data-stu-id="d7e95-105">In this section</span></span>

| <span data-ttu-id="d7e95-106">規則</span><span class="sxs-lookup"><span data-stu-id="d7e95-106">Rule</span></span> | <span data-ttu-id="d7e95-107">描述</span><span class="sxs-lookup"><span data-stu-id="d7e95-107">Description</span></span> |
| - | - |
| [<span data-ttu-id="d7e95-108">CA1802:建議在適當時使用常值</span><span class="sxs-lookup"><span data-stu-id="d7e95-108">CA1802: Use Literals Where Appropriate</span></span>](ca1802.md) | <span data-ttu-id="d7e95-109">欄位在 Visual Basic) 中宣告為靜態和唯讀 (共用和唯讀，並且以編譯時期可計算的值進行初始化。</span><span class="sxs-lookup"><span data-stu-id="d7e95-109">A field is declared static and read-only (Shared and ReadOnly in Visual Basic), and is initialized with a value that is computable at compile time.</span></span> <span data-ttu-id="d7e95-110">因為指派給目標欄位的值會在編譯時期可計算，所以請將宣告變更為 Visual Basic) 欄位中 const (Const，以便在編譯時間而非執行時間計算該值。</span><span class="sxs-lookup"><span data-stu-id="d7e95-110">Because the value that is assigned to the targeted field is computable at compile time, change the declaration to a const (Const in Visual Basic) field so that the value is computed at compile time instead of at run time.</span></span> |
| [<span data-ttu-id="d7e95-111">CA1805：請勿進行非必要的初始化</span><span class="sxs-lookup"><span data-stu-id="d7e95-111">CA1805: Do not initialize unnecessarily</span></span>](ca1805.md) | <span data-ttu-id="d7e95-112">.NET 執行時間會在執行此函式之前，先將參考型別的所有欄位初始化為其預設值。</span><span class="sxs-lookup"><span data-stu-id="d7e95-112">The .NET runtime initializes all fields of reference types to their default values before running the constructor.</span></span> <span data-ttu-id="d7e95-113">在大多數情況下，將欄位明確初始化為其預設值是多餘的，這會增加維護成本，而且可能會降低效能 (例如，元件大小) 增加。</span><span class="sxs-lookup"><span data-stu-id="d7e95-113">In most cases, explicitly initializing a field to its default value is redundant, which adds to maintenance costs and may degrade performance (such as with increased assembly size).</span></span> |
| [<span data-ttu-id="d7e95-114">CA1806:不要忽略方法的結果</span><span class="sxs-lookup"><span data-stu-id="d7e95-114">CA1806: Do not ignore method results</span></span>](ca1806.md) | <span data-ttu-id="d7e95-115">系統會建立但從未使用的新物件，或會呼叫建立並傳回新字串的方法，且永遠不會使用新的字串，或元件物件模型 (COM) 或 P/Invoke 方法會傳回從未使用的 HRESULT 或錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="d7e95-115">A new object is created but never used, or a method that creates and returns a new string is called and the new string is never used, or a Component Object Model (COM) or P/Invoke method returns an HRESULT or error code that is never used.</span></span> |
| [<span data-ttu-id="d7e95-116">CA1810:必須將參考類型內部的靜態欄位初始化</span><span class="sxs-lookup"><span data-stu-id="d7e95-116">CA1810: Initialize reference type static fields inline</span></span>](ca1810.md) | <span data-ttu-id="d7e95-117">當類型宣告明確的靜態建構函式時，Just-In-Time (JIT) 編譯器會將檢查加入至類型的每個靜態方法和執行個體建構函式，確保之前已呼叫該靜態建構函式。</span><span class="sxs-lookup"><span data-stu-id="d7e95-117">When a type declares an explicit static constructor, the just-in-time (JIT) compiler adds a check to each static method and instance constructor of the type to make sure that the static constructor was previously called.</span></span> <span data-ttu-id="d7e95-118">靜態建構函式檢查會降低效能。</span><span class="sxs-lookup"><span data-stu-id="d7e95-118">Static constructor checks can decrease performance.</span></span> |
| [<span data-ttu-id="d7e95-119">CA1812:避免使用未執行個體化的內部類別</span><span class="sxs-lookup"><span data-stu-id="d7e95-119">CA1812: Avoid uninstantiated internal classes</span></span>](ca1812.md) | <span data-ttu-id="d7e95-120">組件層級類型的執行個體不是由組件中的程式碼所建立。</span><span class="sxs-lookup"><span data-stu-id="d7e95-120">An instance of an assembly-level type is not created by code in the assembly.</span></span> |
| [<span data-ttu-id="d7e95-121">CA1813:避免使用非密封屬性</span><span class="sxs-lookup"><span data-stu-id="d7e95-121">CA1813: Avoid unsealed attributes</span></span>](ca1813.md) | <span data-ttu-id="d7e95-122">.NET 提供了用來取得自訂屬性的方法。</span><span class="sxs-lookup"><span data-stu-id="d7e95-122">.NET provides methods for retrieving custom attributes.</span></span> <span data-ttu-id="d7e95-123">根據預設，這些方法會搜尋屬性繼承階層架構。</span><span class="sxs-lookup"><span data-stu-id="d7e95-123">By default, these methods search the attribute inheritance hierarchy.</span></span> <span data-ttu-id="d7e95-124">密封屬性會減少對整個繼承階層架構的搜尋，並且可以改進效能。</span><span class="sxs-lookup"><span data-stu-id="d7e95-124">Sealing the attribute eliminates the search through the inheritance hierarchy and can improve performance.</span></span> |
| [<span data-ttu-id="d7e95-125">CA1814:建議使用不規則陣列取代多維陣列</span><span class="sxs-lookup"><span data-stu-id="d7e95-125">CA1814: Prefer jagged arrays over multidimensional</span></span>](ca1814.md) | <span data-ttu-id="d7e95-126">不規則陣列是一種陣列，其元素也是陣列。</span><span class="sxs-lookup"><span data-stu-id="d7e95-126">A jagged array is an array whose elements are arrays.</span></span> <span data-ttu-id="d7e95-127">組成元素的陣列可以是不同的大小，這可能會導致某些資料集的空間減少。</span><span class="sxs-lookup"><span data-stu-id="d7e95-127">The arrays that make up the elements can be of different sizes, which can result in less wasted space for some sets of data.</span></span> |
| [<span data-ttu-id="d7e95-128">CA1815:必須覆寫實值類型上的 Equals 方法和等號比較運算子</span><span class="sxs-lookup"><span data-stu-id="d7e95-128">CA1815: Override equals and operator equals on value types</span></span>](ca1815.md) | <span data-ttu-id="d7e95-129">對於實值類型而言，Equals 的繼承實作會使用 Reflection 程式庫，並比較所有欄位的內容。</span><span class="sxs-lookup"><span data-stu-id="d7e95-129">For value types, the inherited implementation of Equals uses the Reflection library and compares the contents of all fields.</span></span> <span data-ttu-id="d7e95-130">但是 Reflection 相當耗費運算資源，而且可能不需要比較每個欄位是否相等。</span><span class="sxs-lookup"><span data-stu-id="d7e95-130">Reflection is computationally expensive, and comparing every field for equality might be unnecessary.</span></span> <span data-ttu-id="d7e95-131">如果希望使用者比較或排序執行個體，或是使用執行個體做為雜湊資料表索引鍵，則您的實值類型應實作 Equals。</span><span class="sxs-lookup"><span data-stu-id="d7e95-131">If you expect users to compare or sort instances, or to use instances as hash table keys, your value type should implement Equals.</span></span> |
| [<span data-ttu-id="d7e95-132">CA1819:屬性不應該傳回陣列</span><span class="sxs-lookup"><span data-stu-id="d7e95-132">CA1819: Properties should not return arrays</span></span>](ca1819.md) | <span data-ttu-id="d7e95-133">屬性傳回的陣列不會被寫入保護，即使屬性是唯讀的。</span><span class="sxs-lookup"><span data-stu-id="d7e95-133">Arrays that are returned by properties are not write-protected, even if the property is read-only.</span></span> <span data-ttu-id="d7e95-134">若要保持陣列為防止遭他人修改，屬性必須傳回陣列複本。</span><span class="sxs-lookup"><span data-stu-id="d7e95-134">To keep the array tamper-proof, the property must return a copy of the array.</span></span> <span data-ttu-id="d7e95-135">一般而言，使用者不了解呼叫這類屬性所造成的不良效能影響。</span><span class="sxs-lookup"><span data-stu-id="d7e95-135">Typically, users will not understand the adverse performance implications of calling such a property.</span></span> |
| [<span data-ttu-id="d7e95-136">CA1820:應該使用字串長度測試空白字串</span><span class="sxs-lookup"><span data-stu-id="d7e95-136">CA1820: Test for empty strings using string length</span></span>](ca1820.md) | <span data-ttu-id="d7e95-137">使用 String.Length 屬性或 String.IsNullOrEmpty 方法比較字串，明顯地會比使用 Equals 還快。</span><span class="sxs-lookup"><span data-stu-id="d7e95-137">Comparing strings by using the String.Length property or the String.IsNullOrEmpty method is significantly faster than using Equals.</span></span> |
| [<span data-ttu-id="d7e95-138">CA1821:必須移除空的完成項</span><span class="sxs-lookup"><span data-stu-id="d7e95-138">CA1821: Remove empty finalizers</span></span>](ca1821.md) | <span data-ttu-id="d7e95-139">請盡可能避免使用完成項，因為追蹤物件存留期 (Lifetime) 時將會產生額外的效能負荷。</span><span class="sxs-lookup"><span data-stu-id="d7e95-139">Whenever you can, avoid finalizers because of the additional performance overhead that is involved in tracking object lifetime.</span></span> <span data-ttu-id="d7e95-140">空的完成項會產生額外的負擔，而不會有任何好處。</span><span class="sxs-lookup"><span data-stu-id="d7e95-140">An empty finalizer incurs added overhead without any benefit.</span></span> |
| [<span data-ttu-id="d7e95-141">CA1822:將成員標記為 static</span><span class="sxs-lookup"><span data-stu-id="d7e95-141">CA1822: Mark members as static</span></span>](ca1822.md) | <span data-ttu-id="d7e95-142">不會存取實例資料或呼叫實例方法的成員，可以在 Visual Basic) 中標示為靜態 (共用。</span><span class="sxs-lookup"><span data-stu-id="d7e95-142">Members that do not access instance data or call instance methods can be marked as static (Shared in Visual Basic).</span></span> <span data-ttu-id="d7e95-143">將方法標記為 static 之後，編譯器將對這些成員發出非虛擬呼叫位置。</span><span class="sxs-lookup"><span data-stu-id="d7e95-143">After you mark the methods as static, the compiler will emit nonvirtual call sites to these members.</span></span> <span data-ttu-id="d7e95-144">這麼做可以讓重視效能的程式碼獲得可觀的效能。</span><span class="sxs-lookup"><span data-stu-id="d7e95-144">This can give you a measurable performance gain for performance-sensitive code.</span></span> |
| [<span data-ttu-id="d7e95-145">CA1823:避免包含未使用的私用欄位</span><span class="sxs-lookup"><span data-stu-id="d7e95-145">CA1823: Avoid unused private fields</span></span>](ca1823.md) | <span data-ttu-id="d7e95-146">偵測到似乎不能在組件內存取的私用欄位。</span><span class="sxs-lookup"><span data-stu-id="d7e95-146">Private fields were detected that do not appear to be accessed in the assembly.</span></span> |
| [<span data-ttu-id="d7e95-147">CA1824:組件必須標記 NeutralResourcesLanguageAttribute</span><span class="sxs-lookup"><span data-stu-id="d7e95-147">CA1824: Mark assemblies with NeutralResourcesLanguageAttribute</span></span>](ca1824.md) | <span data-ttu-id="d7e95-148">NeutralResourcesLanguage 屬性會通知用來顯示元件之中性文化特性資源的語言 Resource Manager。</span><span class="sxs-lookup"><span data-stu-id="d7e95-148">The NeutralResourcesLanguage attribute informs the Resource Manager of the language that was used to display the resources of a neutral culture for an assembly.</span></span> <span data-ttu-id="d7e95-149">這可改善載入第一個資源的查詢效能，而且可以減少您的工作集。</span><span class="sxs-lookup"><span data-stu-id="d7e95-149">This improves lookup performance for the first resource that you load and can reduce your working set.</span></span> |
| [<span data-ttu-id="d7e95-150">CA1825：請避免長度為零的陣列配置</span><span class="sxs-lookup"><span data-stu-id="d7e95-150">CA1825: Avoid zero-length array allocations</span></span>](ca1825.md) | <span data-ttu-id="d7e95-151">初始化零長度的陣列會導致不必要的記憶體配置。</span><span class="sxs-lookup"><span data-stu-id="d7e95-151">Initializing a zero-length array leads to unnecessary memory allocation.</span></span> <span data-ttu-id="d7e95-152">請改為呼叫，以使用靜態配置的空陣列實例 <xref:System.Array.Empty%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="d7e95-152">Instead, use the statically allocated empty array instance by calling <xref:System.Array.Empty%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d7e95-153">記憶體配置會在此方法的所有調用之間共用。</span><span class="sxs-lookup"><span data-stu-id="d7e95-153">The memory allocation is shared across all invocations of this method.</span></span> |
| [<span data-ttu-id="d7e95-154">CA1826：請使用屬性，不要使用 Linq Enumerable 方法</span><span class="sxs-lookup"><span data-stu-id="d7e95-154">CA1826: Use property instead of Linq Enumerable method</span></span>](ca1826.md) | <span data-ttu-id="d7e95-155"><xref:System.Linq.Enumerable> LINQ 方法用於支援相等、更有效率之屬性的類型。</span><span class="sxs-lookup"><span data-stu-id="d7e95-155"><xref:System.Linq.Enumerable> LINQ method was used on a type that supports an equivalent, more efficient property.</span></span> |
| [<span data-ttu-id="d7e95-156">CA1827：不要在可使用 Any 時使用 Count/LongCount</span><span class="sxs-lookup"><span data-stu-id="d7e95-156">CA1827: Do not use Count/LongCount when Any can be used</span></span>](ca1827.md) | <span data-ttu-id="d7e95-157"><xref:System.Linq.Enumerable.Count%2A> 或 <xref:System.Linq.Enumerable.LongCount%2A> 方法的使用方式 <xref:System.Linq.Enumerable.Any%2A> 較有效率。</span><span class="sxs-lookup"><span data-stu-id="d7e95-157"><xref:System.Linq.Enumerable.Count%2A> or <xref:System.Linq.Enumerable.LongCount%2A> method was used where <xref:System.Linq.Enumerable.Any%2A> method would be more efficient.</span></span> |
| [<span data-ttu-id="d7e95-158">CA1828：不要在可使用 AnyAsync 時使用 CountAsync/LongCountAsync</span><span class="sxs-lookup"><span data-stu-id="d7e95-158">CA1828: Do not use CountAsync/LongCountAsync when AnyAsync can be used</span></span>](ca1828.md) | <span data-ttu-id="d7e95-159"><xref:Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.CountAsync%2A> 或 <xref:Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.LongCountAsync%2A> 方法的使用方式 <xref:Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.AnyAsync%2A> 較有效率。</span><span class="sxs-lookup"><span data-stu-id="d7e95-159"><xref:Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.CountAsync%2A> or <xref:Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.LongCountAsync%2A> method was used where <xref:Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.AnyAsync%2A> method would be more efficient.</span></span> |
| [<span data-ttu-id="d7e95-160">CA1829：請使用 Length/Count 屬性，不要使用 Enumerable.Count 方法</span><span class="sxs-lookup"><span data-stu-id="d7e95-160">CA1829: Use Length/Count property instead of Enumerable.Count method</span></span>](ca1829.md) | <span data-ttu-id="d7e95-161"><xref:System.Linq.Enumerable.Count%2A> LINQ 方法用於支援相等、更有效率 `Length` 或屬性的類型 `Count` 。</span><span class="sxs-lookup"><span data-stu-id="d7e95-161"><xref:System.Linq.Enumerable.Count%2A> LINQ method was used on a type that supports an equivalent, more efficient `Length` or `Count` property.</span></span> |
| [<span data-ttu-id="d7e95-162">CA1830：建議在 StringBuilder 上使用強型別 Append 及 Insert 方法多載</span><span class="sxs-lookup"><span data-stu-id="d7e95-162">CA1830: Prefer strongly-typed Append and Insert method overloads on StringBuilder</span></span>](ca1830.md) | <span data-ttu-id="d7e95-163"><xref:System.Text.StringBuilder.Append%2A> 並 <xref:System.Text.StringBuilder.Insert%2A> 提供多個類型的多載，但不超過 system.string。</span><span class="sxs-lookup"><span data-stu-id="d7e95-163"><xref:System.Text.StringBuilder.Append%2A> and <xref:System.Text.StringBuilder.Insert%2A> provide overloads for multiple types beyond System.String.</span></span>  <span data-ttu-id="d7e95-164">可能的話，最好使用 ToString 的強型別多載 ( # A1 和以字串為基礎的多載。</span><span class="sxs-lookup"><span data-stu-id="d7e95-164">When possible, prefer the strongly-typed overloads over using ToString() and the string-based overload.</span></span> |
| [<span data-ttu-id="d7e95-165">CA1831：在適用情況下，請使用 AsSpan 做為字串，不要使用範圍型的索引子</span><span class="sxs-lookup"><span data-stu-id="d7e95-165">CA1831: Use AsSpan instead of Range-based indexers for string when appropriate</span></span>](ca1831.md) | <span data-ttu-id="d7e95-166">在字串上使用範圍索引子，並將值隱含指派給 ReadOnlySpan &lt; char 類型時 &gt; ， <xref:System.String.Substring%2A?#System_String_Substring_System_Int32_System_Int32_> 將會使用方法，而不是 <xref:System.Span%601.Slice%2A?#System_Span_1_Slice_System_Int32_System_Int32_> ，這會產生字串的要求部分複本。</span><span class="sxs-lookup"><span data-stu-id="d7e95-166">When using a range-indexer on a string and implicitly assigning the value to a ReadOnlySpan&lt;char&gt; type, the method <xref:System.String.Substring%2A?#System_String_Substring_System_Int32_System_Int32_> will be used instead of <xref:System.Span%601.Slice%2A?#System_Span_1_Slice_System_Int32_System_Int32_>, which produces a copy of requested portion of the string.</span></span> |
| [<span data-ttu-id="d7e95-167">CA1832：請使用 AsSpan 或 AsMemory 來取得陣列的 ReadOnlySpan 或 ReadOnlyMemory 部分，不要使用範圍型的索引子</span><span class="sxs-lookup"><span data-stu-id="d7e95-167">CA1832: Use AsSpan or AsMemory instead of Range-based indexers for getting ReadOnlySpan or ReadOnlyMemory portion of an array</span></span>](ca1832.md) | <span data-ttu-id="d7e95-168">在陣列上使用範圍索引子，並將值隱含地指派給 <xref:System.ReadOnlySpan%601> 或 <xref:System.ReadOnlyMemory%601> 類型時，將會 <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetSubArray%2A> 使用方法，而不是 <xref:System.Span%601.Slice%2A?#System_Span_1_Slice_System_Int32_System_Int32_> ，這會產生陣列所要求部分的複本。</span><span class="sxs-lookup"><span data-stu-id="d7e95-168">When using a range-indexer on an array and implicitly assigning the value to a <xref:System.ReadOnlySpan%601> or <xref:System.ReadOnlyMemory%601> type, the method <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetSubArray%2A> will be used instead of <xref:System.Span%601.Slice%2A?#System_Span_1_Slice_System_Int32_System_Int32_>, which produces a copy of requested portion of the array.</span></span> |
| [<span data-ttu-id="d7e95-169">CA1833：請使用 AsSpan 或 AsMemory 取得陣列的 Span 或 Memory 部分，不要使用範圍型的索引子</span><span class="sxs-lookup"><span data-stu-id="d7e95-169">CA1833: Use AsSpan or AsMemory instead of Range-based indexers for getting Span or Memory portion of an array</span></span>](ca1833.md) | <span data-ttu-id="d7e95-170">在陣列上使用範圍索引子，並將值隱含地指派給 <xref:System.Span%601> 或 <xref:System.Memory%601> 類型時，將會 <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetSubArray%2A> 使用方法，而不是 <xref:System.Span%601.Slice%2A?#System_Span_1_Slice_System_Int32_System_Int32_> ，這會產生陣列所要求部分的複本。</span><span class="sxs-lookup"><span data-stu-id="d7e95-170">When using a range-indexer on an array and implicitly assigning the value to a <xref:System.Span%601> or <xref:System.Memory%601> type, the method <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetSubArray%2A> will be used instead of <xref:System.Span%601.Slice%2A?#System_Span_1_Slice_System_Int32_System_Int32_>, which produces a copy of requested portion of the array.</span></span> |
| [<span data-ttu-id="d7e95-171">CA1834：針對單一字元字串使用 StringBuilder.Append(char)</span><span class="sxs-lookup"><span data-stu-id="d7e95-171">CA1834: Use StringBuilder.Append(char) for single character strings</span></span>](ca1834.md) | <span data-ttu-id="d7e95-172"><xref:System.Text.StringBuilder> 具有 `Append` 接受 `char` 作為其引數的多載。</span><span class="sxs-lookup"><span data-stu-id="d7e95-172"><xref:System.Text.StringBuilder> has an `Append` overload that takes a `char` as its argument.</span></span> <span data-ttu-id="d7e95-173">偏好呼叫多載 `char` 以改善效能。</span><span class="sxs-lookup"><span data-stu-id="d7e95-173">Prefer calling the `char` overload to improve performance.</span></span> |
| [<span data-ttu-id="d7e95-174">CA1835：偏好 ' System.io.stream.readasync ' 和 ' System.io.stream.writeasync ' 以 Memory' 為基礎的多載</span><span class="sxs-lookup"><span data-stu-id="d7e95-174">CA1835: Prefer the 'Memory'-based overloads for 'ReadAsync' and 'WriteAsync'</span></span>](ca1835.md) | <span data-ttu-id="d7e95-175">' Stream ' 有一個 ' System.io.stream.readasync ' 多載，它會接受 ' Memory &lt; byte &gt; ' 做為第一個引數，並使用 ' system.io.stream.writeasync ' 多載（接受 ' ReadOnlyMemory &lt; Byte &gt; ' 做為第一個引數）。</span><span class="sxs-lookup"><span data-stu-id="d7e95-175">'Stream' has a 'ReadAsync' overload that takes a 'Memory&lt;Byte&gt;' as the first argument, and a 'WriteAsync' overload that takes a 'ReadOnlyMemory&lt;Byte&gt;' as the first argument.</span></span> <span data-ttu-id="d7e95-176">偏好呼叫以記憶體為基礎的多載，這些多載較有效率。</span><span class="sxs-lookup"><span data-stu-id="d7e95-176">Prefer calling the memory based overloads, which are more efficient.</span></span> |
| [<span data-ttu-id="d7e95-177">CA1836：優先 `IsEmpty` `Count` 使用</span><span class="sxs-lookup"><span data-stu-id="d7e95-177">CA1836: Prefer `IsEmpty` over `Count` when available</span></span>](ca1836.md) | <span data-ttu-id="d7e95-178">偏好 `IsEmpty` 比、或更有效率的屬性， `Count` `Length` <xref:System.Linq.Enumerable.Count%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> <xref:System.Linq.Enumerable.LongCount%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> 以判斷物件是否包含任何專案。</span><span class="sxs-lookup"><span data-stu-id="d7e95-178">Prefer `IsEmpty` property that is more efficient than `Count`, `Length`, <xref:System.Linq.Enumerable.Count%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> or <xref:System.Linq.Enumerable.LongCount%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> to determine whether the object contains or not any items.</span></span> |
| [<span data-ttu-id="d7e95-179">CA1837：使用 `Environment.ProcessId` 而非 `Process.GetCurrentProcess().Id`</span><span class="sxs-lookup"><span data-stu-id="d7e95-179">CA1837: Use `Environment.ProcessId` instead of `Process.GetCurrentProcess().Id`</span></span>](ca1837.md) | <span data-ttu-id="d7e95-180">`Environment.ProcessId` 比更簡單且更快速 `Process.GetCurrentProcess().Id` 。</span><span class="sxs-lookup"><span data-stu-id="d7e95-180">`Environment.ProcessId` is simpler and faster than `Process.GetCurrentProcess().Id`.</span></span> |
| [<span data-ttu-id="d7e95-181">CA1838：避免 `StringBuilder` P/invoke 的參數</span><span class="sxs-lookup"><span data-stu-id="d7e95-181">CA1838: Avoid `StringBuilder` parameters for P/Invokes</span></span>](ca1838.md) | <span data-ttu-id="d7e95-182">封送處理 `StringBuilder` 一律會建立原生緩衝區複本，導致一個封送處理作業有多個配置。</span><span class="sxs-lookup"><span data-stu-id="d7e95-182">Marshaling of `StringBuilder` always creates a native buffer copy, resulting in multiple allocations for one marshaling operation.</span></span> |
