---
title: '可靠性規則 (程式碼分析) '
description: 瞭解程式碼分析可靠性規則。
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- vs.codeanalysis.reliabilityrules
helpviewer_keywords:
- rules, reliability
- reliability rules
- managed code analysis rules, reliability rules
author: gewarren
ms.author: gewarren
ms.openlocfilehash: a747dd4dcda351a1ddb0f3d069bb7bac895c32f8
ms.sourcegitcommit: 636af37170ae75a11c4f7d1ecd770820e7dfe7bd
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 10/07/2020
ms.locfileid: "96586327"
---
# <a name="reliability-rules"></a><span data-ttu-id="121e0-103">可靠性規則</span><span class="sxs-lookup"><span data-stu-id="121e0-103">Reliability rules</span></span>

<span data-ttu-id="121e0-104">可靠性規則支援程式庫和應用程式的可靠性，例如正確的記憶體和執行緒的使用。</span><span class="sxs-lookup"><span data-stu-id="121e0-104">Reliability rules support library and application reliability, such as correct memory and thread usage.</span></span> <span data-ttu-id="121e0-105">可靠性規則包括：</span><span class="sxs-lookup"><span data-stu-id="121e0-105">The reliability rules include:</span></span>

|<span data-ttu-id="121e0-106">規則</span><span class="sxs-lookup"><span data-stu-id="121e0-106">Rule</span></span>|<span data-ttu-id="121e0-107">描述</span><span class="sxs-lookup"><span data-stu-id="121e0-107">Description</span></span>|
|----------|-----------------|
|[<span data-ttu-id="121e0-108">CA2000:必須在超出範圍前處置物件</span><span class="sxs-lookup"><span data-stu-id="121e0-108">CA2000: Dispose objects before losing scope</span></span>](ca2000.md)|<span data-ttu-id="121e0-109">因為可能會發生例外事件以防止執行物件的完成項，所以應在物件的所有參考都超出範圍之前，明確處置物件。</span><span class="sxs-lookup"><span data-stu-id="121e0-109">Because an exceptional event might occur that will prevent the finalizer of an object from running, the object should be explicitly disposed before all references to it are out of scope.</span></span>|
|[<span data-ttu-id="121e0-110">CA2002:不要鎖定具有弱式識別的物件</span><span class="sxs-lookup"><span data-stu-id="121e0-110">CA2002: Do not lock on objects with weak identity</span></span>](ca2002.md)|<span data-ttu-id="121e0-111">可以跨應用程式定義域範圍直接存取的物件，即所謂具有弱式識別的物件。</span><span class="sxs-lookup"><span data-stu-id="121e0-111">An object is said to have a weak identity when it can be directly accessed across application domain boundaries.</span></span> <span data-ttu-id="121e0-112">嘗試取得具有弱式識別之物件鎖定的執行緒，可以被不同應用程式定義域中具有相同物件鎖定的第二個執行緒所封鎖。</span><span class="sxs-lookup"><span data-stu-id="121e0-112">A thread that tries to acquire a lock on an object that has a weak identity can be blocked by a second thread in a different application domain that has a lock on the same object.</span></span>|
|[<span data-ttu-id="121e0-113">CA2007:不直接等候工作</span><span class="sxs-lookup"><span data-stu-id="121e0-113">CA2007: Do not directly await a Task</span></span>](ca2007.md)|<span data-ttu-id="121e0-114">非同步方法會[awaits](../../../csharp/language-reference/operators/await.md)直接等候 <xref:System.Threading.Tasks.Task> 。</span><span class="sxs-lookup"><span data-stu-id="121e0-114">An asynchronous method [awaits](../../../csharp/language-reference/operators/await.md) a <xref:System.Threading.Tasks.Task> directly.</span></span>|
|[<span data-ttu-id="121e0-115">CA2008：建立工作時請務必傳遞 TaskScheduler</span><span class="sxs-lookup"><span data-stu-id="121e0-115">CA2008: Do not create tasks without passing a TaskScheduler</span></span>](ca2008.md)|<span data-ttu-id="121e0-116">工作建立或接續運算使用未指定參數的方法多載 <xref:System.Threading.Tasks.TaskScheduler> 。</span><span class="sxs-lookup"><span data-stu-id="121e0-116">A task creation or continuation operation uses a method overload that does not specify a <xref:System.Threading.Tasks.TaskScheduler> parameter.</span></span>|
|[<span data-ttu-id="121e0-117">CA2009：請勿對 ImmutableCollection 值呼叫 TolmmutableCollection</span><span class="sxs-lookup"><span data-stu-id="121e0-117">CA2009: Do not call ToImmutableCollection on an ImmutableCollection value</span></span>](ca2009.md)|<span data-ttu-id="121e0-118">`ToImmutable` 方法在命名空間的不可變集合上不必要地呼叫 <xref:System.Collections.Immutable> 。</span><span class="sxs-lookup"><span data-stu-id="121e0-118">`ToImmutable` method was unnecessarily called on an immutable collection from <xref:System.Collections.Immutable> namespace.</span></span>|
|[<span data-ttu-id="121e0-119">CA2011：請勿在屬性 setter 中指派屬性</span><span class="sxs-lookup"><span data-stu-id="121e0-119">CA2011: Do not assign property within its setter</span></span>](ca2011.md) | <span data-ttu-id="121e0-120">屬性在其本身的 [set 存取](../../../csharp/programming-guide/classes-and-structs/using-properties.md#the-set-accessor)子中不小心指派了值。</span><span class="sxs-lookup"><span data-stu-id="121e0-120">A property was accidentally assigned a value within its own [set accessor](../../../csharp/programming-guide/classes-and-structs/using-properties.md#the-set-accessor).</span></span> |
|[<span data-ttu-id="121e0-121">CA2012：必須正確使用 ValueTasks</span><span class="sxs-lookup"><span data-stu-id="121e0-121">CA2012: Use ValueTasks correctly</span></span>](ca2012.md) | <span data-ttu-id="121e0-122">從成員調用傳回的 ValueTasks 是要直接等待。</span><span class="sxs-lookup"><span data-stu-id="121e0-122">ValueTasks returned from member invocations are intended to be directly awaited.</span></span>  <span data-ttu-id="121e0-123">嘗試多次使用 ValueTask 或在已知完成之前直接存取一個結果可能會導致例外狀況或損毀。</span><span class="sxs-lookup"><span data-stu-id="121e0-123">Attempts to consume a ValueTask multiple times or to directly access one's result before it's known to be completed may result in an exception or corruption.</span></span>  <span data-ttu-id="121e0-124">忽略這類 ValueTask 可能表示功能錯誤，而且可能會降低效能。</span><span class="sxs-lookup"><span data-stu-id="121e0-124">Ignoring such a ValueTask is likely an indication of a functional bug and may degrade performance.</span></span> |
|[<span data-ttu-id="121e0-125">CA2013：請勿使用具有值類型的 ReferenceEquals</span><span class="sxs-lookup"><span data-stu-id="121e0-125">CA2013: Do not use ReferenceEquals with value types</span></span>](ca2013.md) | <span data-ttu-id="121e0-126">使用比較值時 <xref:System.Object.ReferenceEquals%2A?displayProperty=fullName> ，如果 objA 和 objB 是實值型別，則會在傳遞至方法之前先將它們裝箱 <xref:System.Object.ReferenceEquals%2A> 。</span><span class="sxs-lookup"><span data-stu-id="121e0-126">When comparing values using <xref:System.Object.ReferenceEquals%2A?displayProperty=fullName>, if objA and objB are value types, they are boxed before they are passed to the <xref:System.Object.ReferenceEquals%2A> method.</span></span> <span data-ttu-id="121e0-127">這表示即使 objA 和 objB 都代表實值型別的實例，方法仍會傳回 <xref:System.Object.ReferenceEquals%2A> false。</span><span class="sxs-lookup"><span data-stu-id="121e0-127">This means that even if both objA and objB represent the same instance of a value type, the <xref:System.Object.ReferenceEquals%2A> method nevertheless returns false.</span></span> |
|[<span data-ttu-id="121e0-128">CA2014：不要在迴圈中使用 stackalloc。</span><span class="sxs-lookup"><span data-stu-id="121e0-128">CA2014: Do not use stackalloc in loops.</span></span>](ca2014.md) | <span data-ttu-id="121e0-129">Stackalloc 配置的堆疊空間只會在目前方法的調用結束時釋出。</span><span class="sxs-lookup"><span data-stu-id="121e0-129">Stack space allocated by a stackalloc is only released at the end of the current method's invocation.</span></span>  <span data-ttu-id="121e0-130">在迴圈中使用它，可能會導致未系結的堆疊成長和最終的堆疊溢位狀況。</span><span class="sxs-lookup"><span data-stu-id="121e0-130">Using it in a loop can result in unbounded stack growth and eventual stack overflow conditions.</span></span> |
|[<span data-ttu-id="121e0-131">CA2015：請勿定義衍生自 MemoryManager T 之類型的完成項 &lt;&gt;</span><span class="sxs-lookup"><span data-stu-id="121e0-131">CA2015: Do not define finalizers for types derived from MemoryManager&lt;T&gt;</span></span>](ca2015.md) | <span data-ttu-id="121e0-132">將完成項加入至衍生自的型別 <xref:System.Buffers.MemoryManager%601> 時，可能會允許在記憶體仍在使用時釋放記憶體 <xref:System.Span%601> 。</span><span class="sxs-lookup"><span data-stu-id="121e0-132">Adding a finalizer to a type derived from <xref:System.Buffers.MemoryManager%601> may permit memory to be freed while it is still in use by a <xref:System.Span%601>.</span></span> |
|[<span data-ttu-id="121e0-133">CA2016：將 CancellationToken 參數傳遞給使用該參數的方法</span><span class="sxs-lookup"><span data-stu-id="121e0-133">CA2016: Forward the CancellationToken parameter to methods that take one</span></span>](ca2016.md) | <span data-ttu-id="121e0-134">將 `CancellationToken` 參數轉寄至採用其中一個的方法，以確保作業取消通知會正確傳播，或明確地傳入 `CancellationToken.None` 以表示刻意不傳播權杖。</span><span class="sxs-lookup"><span data-stu-id="121e0-134">Forward the `CancellationToken` parameter to methods that take one to ensure the operation cancellation notifications gets properly propagated, or pass in `CancellationToken.None` explicitly to indicate intentionally not propagating the token.</span></span> |
