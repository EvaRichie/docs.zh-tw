---
title: '設計規則 (程式碼分析) '
description: 瞭解程式碼分析設計規則。
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- vs.codeanalysis.designrules
helpviewer_keywords:
- design rules
- managed code analysis rules, design rules
- rules, design
author: gewarren
ms.author: gewarren
ms.openlocfilehash: c8c7d46b9271e33ab7ce3f989fae95bd57394ccd
ms.sourcegitcommit: 636af37170ae75a11c4f7d1ecd770820e7dfe7bd
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 10/07/2020
ms.locfileid: "96586324"
---
# <a name="design-rules"></a><span data-ttu-id="8aa9e-103">設計規則</span><span class="sxs-lookup"><span data-stu-id="8aa9e-103">Design rules</span></span>

<span data-ttu-id="8aa9e-104">設計規則支援遵循 .NET Framework 的 [設計指導方針](../../../standard/design-guidelines/index.md)。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-104">Design rules support adherence to the [.NET Framework Design Guidelines](../../../standard/design-guidelines/index.md).</span></span>

## <a name="in-this-section"></a><span data-ttu-id="8aa9e-105">本節內容</span><span class="sxs-lookup"><span data-stu-id="8aa9e-105">In this section</span></span>

| <span data-ttu-id="8aa9e-106">規則</span><span class="sxs-lookup"><span data-stu-id="8aa9e-106">Rule</span></span> | <span data-ttu-id="8aa9e-107">描述</span><span class="sxs-lookup"><span data-stu-id="8aa9e-107">Description</span></span> |
| - | - |
| [<span data-ttu-id="8aa9e-108">CA1000：不要在泛型類型上宣告靜態成員</span><span class="sxs-lookup"><span data-stu-id="8aa9e-108">CA1000: Do not declare static members on generic types</span></span>](ca1000.md) | <span data-ttu-id="8aa9e-109">呼叫泛型類型的靜態成員時，必須為類型指定類型引數。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-109">When a static member of a generic type is called, the type argument must be specified for the type.</span></span> <span data-ttu-id="8aa9e-110">呼叫不支援介面的泛型執行個體 (Instance) 成員時，必須為成員指定類型引數。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-110">When a generic instance member that does not support inference is called, the type argument must be specified for the member.</span></span> <span data-ttu-id="8aa9e-111">在上述兩種情況下，指定型別引數的語法不同且容易混淆。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-111">In these two cases, the syntax for specifying the type argument is different and easily confused.</span></span> |
| [<span data-ttu-id="8aa9e-112">CA1001：具有可處置欄位的類型應該為可處置</span><span class="sxs-lookup"><span data-stu-id="8aa9e-112">CA1001: Types that own disposable fields should be disposable</span></span>](ca1001.md) | <span data-ttu-id="8aa9e-113">類別會宣告並實作為 IDisposable 類型的實例欄位，而且類別不會執行 IDisposable。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-113">A class declares and implements an instance field that is a System.IDisposable type and the class does not implement IDisposable.</span></span> <span data-ttu-id="8aa9e-114">宣告 IDisposable 欄位的類別會間接擁有 Unmanaged 資源，且應實作 IDisposable 介面。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-114">A class that declares an IDisposable field indirectly owns an unmanaged resource and should implement the IDisposable interface.</span></span> |
| [<span data-ttu-id="8aa9e-115">CA1002：不要公開泛型清單</span><span class="sxs-lookup"><span data-stu-id="8aa9e-115">CA1002: Do not expose generic lists</span></span>](ca1002.md) | <span data-ttu-id="8aa9e-116">\<(T>) # A1) 的< (，是針對效能而非繼承所設計的泛型集合。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-116">System.Collections.Generic.List<(Of \<(T>)>) is a generic collection that is designed for performance, not inheritance.</span></span> <span data-ttu-id="8aa9e-117">因此，List 不包含任何虛擬成員。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-117">Therefore, List does not contain any virtual members.</span></span> <span data-ttu-id="8aa9e-118">應該改為公開專為繼承所設計的泛型集合。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-118">The generic collections that are designed for inheritance should be exposed instead.</span></span> |
| [<span data-ttu-id="8aa9e-119">CA1003：使用一般事件處理常式執行個體</span><span class="sxs-lookup"><span data-stu-id="8aa9e-119">CA1003: Use generic event handler instances</span></span>](ca1003.md) | <span data-ttu-id="8aa9e-120">型別包含傳回 void 的委派，其簽章包含兩個參數 (第一個物件，第二個則是可指派給 EventArgs) 的型別，而包含元件的目標則是 .NET Framework 2.0。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-120">A type contains a delegate that returns void, whose signature contains two parameters (the first an object and the second a type that is assignable to EventArgs), and the containing assembly targets .NET Framework 2.0.</span></span> |
| [<span data-ttu-id="8aa9e-121">CA1005：避免在泛型類型上包含過多參數</span><span class="sxs-lookup"><span data-stu-id="8aa9e-121">CA1005: Avoid excessive parameters on generic types</span></span>](ca1005.md) | <span data-ttu-id="8aa9e-122">泛型類型所包含的類型參數越多，就越難了解並記住每個類型參數所代表的含意。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-122">The more type parameters a generic type contains, the more difficult it is to know and remember what each type parameter represents.</span></span> <span data-ttu-id="8aa9e-123">它通常會使用一個型別參數（如清單 \<T> ），以及在具有兩個型別參數的特定情況下很明顯，如同在字典中一樣 \<TKey, TValue> 。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-123">It is usually obvious with one type parameter, as in List\<T>, and in certain cases with two type parameters, as in Dictionary\<TKey, TValue>.</span></span> <span data-ttu-id="8aa9e-124">不過，如果存在兩個以上的類型參數，則對大多數使用者而言都會變得難以理解。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-124">However, if more than two type parameters exist, the difficulty becomes too great for most users.</span></span> |
| [<span data-ttu-id="8aa9e-125">CA1008:列舉值中應該要有值為零的成員</span><span class="sxs-lookup"><span data-stu-id="8aa9e-125">CA1008: Enums should have zero value</span></span>](ca1008.md) | <span data-ttu-id="8aa9e-126">如同其他實值類型一般，未初始化的列舉其預設值為零。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-126">The default value of an uninitialized enumeration, just as other value types, is zero.</span></span> <span data-ttu-id="8aa9e-127">有效值屬性化列舉應該使用值零來定義成員，如此一來，預設值就是列舉的有效值。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-127">A nonflags attributed enumeration should define a member by using the value of zero so that the default value is a valid value of the enumeration.</span></span> <span data-ttu-id="8aa9e-128">如果已套用 FlagsAttribute 屬性的列舉定義零值成員，則其名稱應該是 "None"，以表示列舉中未設定任何值。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-128">If an enumeration that has the FlagsAttribute attribute applied defines a zero-valued member, its name should be "None" to indicate that no values have been set in the enumeration.</span></span> |
| [<span data-ttu-id="8aa9e-129">CA1010:集合應該實作泛型介面</span><span class="sxs-lookup"><span data-stu-id="8aa9e-129">CA1010: Collections should implement generic interface</span></span>](ca1010.md) | <span data-ttu-id="8aa9e-130">若要放寬集合的可用性，請實作其中一個泛型集合介面。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-130">To broaden the usability of a collection, implement one of the generic collection interfaces.</span></span> <span data-ttu-id="8aa9e-131">接著，使用該集合填入泛型集合類型。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-131">Then the collection can be used to populate generic collection types.</span></span> |
| [<span data-ttu-id="8aa9e-132">CA1012:抽象類型不應該有建構函式</span><span class="sxs-lookup"><span data-stu-id="8aa9e-132">CA1012: Abstract types should not have constructors</span></span>](ca1012.md) | <span data-ttu-id="8aa9e-133">只有衍生類型 (Derived Type) 可以呼叫抽象類型上的建構函式。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-133">Constructors on abstract types can be called only by derived types.</span></span> <span data-ttu-id="8aa9e-134">因為公用建構函式會建立類型的執行個體，而且您無法建立抽象類型的執行個體，因此具有公用建構函式的抽象類型設計不正確。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-134">Because public constructors create instances of a type, and you cannot create instances of an abstract type, an abstract type that has a public constructor is incorrectly designed.</span></span> |
| [<span data-ttu-id="8aa9e-135">CA1014:組件必須標記 CLSCompliantAttribute</span><span class="sxs-lookup"><span data-stu-id="8aa9e-135">CA1014: Mark assemblies with CLSCompliantAttribute</span></span>](ca1014.md) | <span data-ttu-id="8aa9e-136">Common Language Specification (CLS) 會定義命名限制、資料類型及組件必須遵守的規則 (如果組件會使用於跨程式設計語言時)。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-136">The Common Language Specification (CLS) defines naming restrictions, data types, and rules to which assemblies must conform if they will be used across programming languages.</span></span> <span data-ttu-id="8aa9e-137">良好的設計規定所有的元件都使用 >clscompliantattribute 明確指出符合 CLS 標準。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-137">Good design dictates that all assemblies explicitly indicate CLS compliance by using CLSCompliantAttribute.</span></span> <span data-ttu-id="8aa9e-138">如果這個屬性未出現於組件中，則表示組件不符合標準。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-138">If this attribute is not present on an assembly, the assembly is not compliant.</span></span> |
| [<span data-ttu-id="8aa9e-139">CA1016:組件必須標記 AssemblyVersionAttribute</span><span class="sxs-lookup"><span data-stu-id="8aa9e-139">CA1016: Mark assemblies with AssemblyVersionAttribute</span></span>](ca1016.md) | <span data-ttu-id="8aa9e-140">.NET 會使用版本號碼來唯一識別元件，並系結至強式名稱元件中的類型。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-140">.NET uses the version number to uniquely identify an assembly, and to bind to types in strongly named assemblies.</span></span> <span data-ttu-id="8aa9e-141">版本號碼會與版本和發行者 (Publisher) 原則一起使用。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-141">The version number is used together with version and publisher policy.</span></span> <span data-ttu-id="8aa9e-142">應用程式預設只會與建置它們的組件版本一起執行。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-142">By default, applications run only with the assembly version with which they were built.</span></span> |
| [<span data-ttu-id="8aa9e-143">CA1017:組件必須標記 ComVisibleAttribute</span><span class="sxs-lookup"><span data-stu-id="8aa9e-143">CA1017: Mark assemblies with ComVisibleAttribute</span></span>](ca1017.md) | <span data-ttu-id="8aa9e-144">ComVisibleAttribute 會判斷 COM 用戶端如何存取 Managed 程式碼。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-144">ComVisibleAttribute determines how COM clients access managed code.</span></span> <span data-ttu-id="8aa9e-145">良好的設計會要求組件明確表示 COM 的可視性。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-145">Good design dictates that assemblies explicitly indicate COM visibility.</span></span> <span data-ttu-id="8aa9e-146">COM 的可視性可以針對整個組件進行設定，然後針對個別類型及類型成員進行覆寫。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-146">COM visibility can be set for the whole assembly and then overridden for individual types and type members.</span></span> <span data-ttu-id="8aa9e-147">如果這個屬性不存在，則 COM 用戶端可以看到組件的內容。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-147">If this attribute is not present, the contents of the assembly are visible to COM clients.</span></span> |
| [<span data-ttu-id="8aa9e-148">CA1018:必須以 AttributeUsageAttribute 標記屬性</span><span class="sxs-lookup"><span data-stu-id="8aa9e-148">CA1018: Mark attributes with AttributeUsageAttribute</span></span>](ca1018.md) | <span data-ttu-id="8aa9e-149">當您定義自訂屬性時，請使用 AttributeUsageAttribute 標記它，以指出可以在原始程式碼的哪個位置套用自訂屬性。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-149">When you define a custom attribute, mark it by using AttributeUsageAttribute to indicate where in the source code the custom attribute can be applied.</span></span> <span data-ttu-id="8aa9e-150">屬性的意義和預期的用法將決定它在程式碼中的有效位置。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-150">The meaning and intended usage of an attribute will determine its valid locations in code.</span></span> |
| [<span data-ttu-id="8aa9e-151">CA1019:定義屬性引數的存取子</span><span class="sxs-lookup"><span data-stu-id="8aa9e-151">CA1019: Define accessors for attribute arguments</span></span>](ca1019.md) | <span data-ttu-id="8aa9e-152">屬性可以定義必須在將屬性套用至目標時指定的強制引數。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-152">Attributes can define mandatory arguments that must be specified when you apply the attribute to a target.</span></span> <span data-ttu-id="8aa9e-153">這些引數也稱為位置引數，因為它們會當做位置參數提供給屬性建構函式。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-153">These are also known as positional arguments because they are supplied to attribute constructors as positional parameters.</span></span> <span data-ttu-id="8aa9e-154">對於每個強制引數而言，屬性 (Attribute) 還須提供對應的唯讀屬性 (Property)，才可以在執行時期擷取引數值。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-154">For every mandatory argument, the attribute should also provide a corresponding read-only property so that the value of the argument can be retrieved at execution time.</span></span> <span data-ttu-id="8aa9e-155">屬性也可以定義選擇性引數，也稱為具名引數。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-155">Attributes can also define optional arguments, which are also known as named arguments.</span></span> <span data-ttu-id="8aa9e-156">這些引數會依照名稱提供給屬性 (Attribute) 建構函式，且必須有對應的讀取/寫入屬性 (Property)。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-156">These arguments are supplied to attribute constructors by name and should have a corresponding read/write property.</span></span> |
| [<span data-ttu-id="8aa9e-157">CA1021:避免使用 out 參數</span><span class="sxs-lookup"><span data-stu-id="8aa9e-157">CA1021: Avoid out parameters</span></span>](ca1021.md) | <span data-ttu-id="8aa9e-158">以傳址方式傳遞類型時 (使用 out 或 ref)，您需要擁有使用指標的經驗、了解實值類型和參考類型之間的差異，並處理具有多個傳回值的方法。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-158">Passing types by reference (using out or ref) requires experience with pointers, understanding how value types and reference types differ, and handling methods with multiple return values.</span></span> <span data-ttu-id="8aa9e-159">此外，out 和 ref 參數之間的差異一般人不甚了解。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-159">Also, the difference between out and ref parameters is not widely understood.</span></span> |
| [<span data-ttu-id="8aa9e-160">CA1024:建議在適當時使用屬性</span><span class="sxs-lookup"><span data-stu-id="8aa9e-160">CA1024: Use properties where appropriate</span></span>](ca1024.md) | <span data-ttu-id="8aa9e-161">公用或保護的方法具有以 "Get" 開頭的名稱，該名稱不採用任何參數並且會傳回不是陣列的值。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-161">A public or protected method has a name that starts with "Get", takes no parameters, and returns a value that is not an array.</span></span> <span data-ttu-id="8aa9e-162">此方法可能是成為屬性的不錯候選者。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-162">The method might be a good candidate to become a property.</span></span> |
| [<span data-ttu-id="8aa9e-163">CA1027:必須以 FlagsAttribute 標記列舉</span><span class="sxs-lookup"><span data-stu-id="8aa9e-163">CA1027: Mark enums with FlagsAttribute</span></span>](ca1027.md) | <span data-ttu-id="8aa9e-164">列舉類型是一種實值類型 (Value Type)，用以定義一組相關的具名常數。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-164">An enumeration is a value type that defines a set of related named constants.</span></span> <span data-ttu-id="8aa9e-165">當列舉的具名常數可以有意義地加以結合時，會將 FlagsAttribute 套用至此列舉。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-165">Apply FlagsAttribute to an enumeration when its named constants can be meaningfully combined.</span></span> |
| [<span data-ttu-id="8aa9e-166">CA1028:列舉儲存區應該是 Int32</span><span class="sxs-lookup"><span data-stu-id="8aa9e-166">CA1028: Enum storage should be Int32</span></span>](ca1028.md) | <span data-ttu-id="8aa9e-167">列舉類型是一種實值類型 (Value Type)，用以定義一組相關的具名常數。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-167">An enumeration is a value type that defines a set of related named constants.</span></span> <span data-ttu-id="8aa9e-168">根據預設，System.Int32 資料類型會用於儲存常數值。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-168">By default, the System.Int32 data type is used to store the constant value.</span></span> <span data-ttu-id="8aa9e-169">雖然您可以變更此基礎類型，但在大部分的情況下都不需要或建議您這樣做。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-169">Even though you can change this underlying type, it is not required or recommended for most scenarios.</span></span> |
| [<span data-ttu-id="8aa9e-170">CA1030:建議在適當時使用事件</span><span class="sxs-lookup"><span data-stu-id="8aa9e-170">CA1030: Use events where appropriate</span></span>](ca1030.md) | <span data-ttu-id="8aa9e-171">此規則會偵測具有事件常用名稱的方法。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-171">This rule detects methods that have names that ordinarily would be used for events.</span></span> <span data-ttu-id="8aa9e-172">如果方法因回應清楚定義的狀態變更而被呼叫，應該由事件處理常式叫用該方法。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-172">If a method is called in response to a clearly defined state change, the method should be invoked by an event handler.</span></span> <span data-ttu-id="8aa9e-173">呼叫方法的物件應該要引發事件，而不是直接呼叫方法。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-173">Objects that call the method should raise events instead of calling the method directly.</span></span> |
| [<span data-ttu-id="8aa9e-174">CA1031:不要攔截一般例外狀況類型</span><span class="sxs-lookup"><span data-stu-id="8aa9e-174">CA1031: Do not catch general exception types</span></span>](ca1031.md) | <span data-ttu-id="8aa9e-175">不應該攔截一般例外狀況。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-175">General exceptions should not be caught.</span></span> <span data-ttu-id="8aa9e-176">攔截更明確的例外狀況，或重新擲回一般例外狀況做為 catch 區塊中的最後一個語句。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-176">Catch a more-specific exception, or rethrow the general exception as the last statement in the catch block.</span></span> |
| [<span data-ttu-id="8aa9e-177">CA1032:必須實作標準例外狀況建構函式</span><span class="sxs-lookup"><span data-stu-id="8aa9e-177">CA1032: Implement standard exception constructors</span></span>](ca1032.md) | <span data-ttu-id="8aa9e-178">無法提供整組的建構函式會導致難以正確地處理例外狀況。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-178">Failure to provide the full set of constructors can make it difficult to correctly handle exceptions.</span></span> |
| [<span data-ttu-id="8aa9e-179">CA1033:介面方法應該要可以由子類型呼叫</span><span class="sxs-lookup"><span data-stu-id="8aa9e-179">CA1033: Interface methods should be callable by child types</span></span>](ca1033.md) | <span data-ttu-id="8aa9e-180">非密封外部可見的類型會提供公用介面的明確方法實作，但未提供同名的替代外部可見方法。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-180">An unsealed externally visible type provides an explicit method implementation of a public interface and does not provide an alternative externally visible method that has the same name.</span></span> |
| [<span data-ttu-id="8aa9e-181">CA1034:巢狀類型不應該為可見的</span><span class="sxs-lookup"><span data-stu-id="8aa9e-181">CA1034: Nested types should not be visible</span></span>](ca1034.md) | <span data-ttu-id="8aa9e-182">巢狀類型是在其他類型範圍內宣告的類型。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-182">A nested type is a type that is declared in the scope of another type.</span></span> <span data-ttu-id="8aa9e-183">巢狀類型可用來封裝包含類型 (Containing Type) 私用的 (Private) 實作細節。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-183">Nested types are useful to encapsulate private implementation details of the containing type.</span></span> <span data-ttu-id="8aa9e-184">因為有這樣的用途，所以巢狀類型不應為外部可見的。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-184">Used for this purpose, nested types should not be externally visible.</span></span> |
| [<span data-ttu-id="8aa9e-185">CA1036:必須在 Comparable 類型中覆寫方法</span><span class="sxs-lookup"><span data-stu-id="8aa9e-185">CA1036: Override methods on comparable types</span></span>](ca1036.md) | <span data-ttu-id="8aa9e-186">公用或受保護的類型實作 System.IComparable 介面。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-186">A public or protected type implements the System.IComparable interface.</span></span> <span data-ttu-id="8aa9e-187">它不會覆寫 Object.Equals，也不會多載等號、不等、小於或大於的語言特定比較運算子。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-187">It does not override Object.Equals nor does it overload the language-specific operator for equality, inequality, less than, or greater than.</span></span> |
| [<span data-ttu-id="8aa9e-188">CA1040:避免使用空的介面</span><span class="sxs-lookup"><span data-stu-id="8aa9e-188">CA1040: Avoid empty interfaces</span></span>](ca1040.md) | <span data-ttu-id="8aa9e-189">介面是用來定義一組可提供行為或程式使用合約的成員。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-189">Interfaces define members that provide a behavior or usage contract.</span></span> <span data-ttu-id="8aa9e-190">不論類型出現在繼承階層架構 (Inheritance Hierarchy) 中的何處，任何類型都可以採用介面所描述的功能。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-190">The functionality that is described by the interface can be adopted by any type, regardless of where the type appears in the inheritance hierarchy.</span></span> <span data-ttu-id="8aa9e-191">類型會實作介面，方法是提供介面成員的實作。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-191">A type implements an interface by providing implementations for the members of the interface.</span></span> <span data-ttu-id="8aa9e-192">空白介面不會定義任何成員，因此也不會定義能夠實作的合約。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-192">An empty interface does not define any members; therefore, it does not define a contract that can be implemented.</span></span> |
| [<span data-ttu-id="8aa9e-193">CA1041:必須提供 ObsoleteAttribute 訊息</span><span class="sxs-lookup"><span data-stu-id="8aa9e-193">CA1041: Provide ObsoleteAttribute message</span></span>](ca1041.md) | <span data-ttu-id="8aa9e-194">類型或成員是使用並未指定其 ObsoleteAttribute.Message 屬性 (Property) 的 System.ObsoleteAttribute 屬性 (Attribute) 來標記。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-194">A type or member is marked by using a System.ObsoleteAttribute attribute that does not have its ObsoleteAttribute.Message property specified.</span></span> <span data-ttu-id="8aa9e-195">當編譯使用 ObsoleteAttribute 標示的類型或成員時，會顯示內容的訊息屬性，以提供有關過時類型或成員的使用者資訊。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-195">When a type or member that is marked by using ObsoleteAttribute is compiled, the Message property of the attribute is displayed, which gives the user information about the obsolete type or member.</span></span> |
| [<span data-ttu-id="8aa9e-196">CA1043:必須針對索引子使用整數或字串引數</span><span class="sxs-lookup"><span data-stu-id="8aa9e-196">CA1043: Use integral or string argument for indexers</span></span>](ca1043.md) | <span data-ttu-id="8aa9e-197">索引子 (也就是索引的屬性) 應該使用整數類型或字串類型的索引。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-197">Indexers (that is, indexed properties) should use integral or string types for the index.</span></span> <span data-ttu-id="8aa9e-198">這些類型通常會用於資料結構的索引，可以提升程式庫的可用性。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-198">These types are typically used for indexing data structures and they increase the usability of the library.</span></span> <span data-ttu-id="8aa9e-199">Object 類型的使用應限制於無法在設計階段指定特定整數類型或字串類型的情況。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-199">Use of the Object type should be restricted to those cases where the specific integral or string type cannot be specified at design time.</span></span> |
| [<span data-ttu-id="8aa9e-200">CA1044:屬性不應該為唯寫的</span><span class="sxs-lookup"><span data-stu-id="8aa9e-200">CA1044: Properties should not be write only</span></span>](ca1044.md) | <span data-ttu-id="8aa9e-201">雖然它是可接受並經常需要具有唯讀屬性，設計方針會禁止使用唯寫屬性的屬性。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-201">Although it is acceptable and often necessary to have a read-only property, the design guidelines prohibit the use of write-only properties.</span></span> <span data-ttu-id="8aa9e-202">這是因為讓使用者，設定一個值，然後防止使用者檢視值並不會提供任何安全性。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-202">This is because letting a user set a value, and then preventing the user from viewing that value, does not provide any security.</span></span> <span data-ttu-id="8aa9e-203">同時，如果沒有讀取權限，則無法檢視共用物件的狀態，進而限制這些物件的使用性。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-203">Also, without read access, the state of shared objects cannot be viewed, which limits their usefulness.</span></span> |
| [<span data-ttu-id="8aa9e-204">CA1045:不要以傳址方式傳遞類型</span><span class="sxs-lookup"><span data-stu-id="8aa9e-204">CA1045: Do not pass types by reference</span></span>](ca1045.md) | <span data-ttu-id="8aa9e-205">以傳址方式傳遞類型時 (使用 out 或 ref)，您需要擁有使用指標的經驗、了解實值類型和參考類型之間的差異，並處理具有多個傳回值的方法。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-205">Passing types by reference (using out or ref) requires experience with pointers, understanding how value types and reference types differ, and handling methods with multiple return values.</span></span> <span data-ttu-id="8aa9e-206">目標為一般使用者的程式庫架構設計人員不應預期使用者會熟練地運用 out 或 ref 參數。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-206">Library architects who design for a general audience should not expect users to master working with out or ref parameters.</span></span> |
| [<span data-ttu-id="8aa9e-207">CA1046:不要多載參考類型上的等號比較運算子</span><span class="sxs-lookup"><span data-stu-id="8aa9e-207">CA1046: Do not overload operator equals on reference types</span></span>](ca1046.md) | <span data-ttu-id="8aa9e-208">對參考類型而言，等號比較運算子的預設實作 (Implementation) 永遠都是正確的。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-208">For reference types, the default implementation of the equality operator is almost always correct.</span></span> <span data-ttu-id="8aa9e-209">根據預設，只有當兩項參考都指向相同物件時才會相等。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-209">By default, two references are equal only if they point to the same object.</span></span> |
| [<span data-ttu-id="8aa9e-210">CA1047:不要在密封類型中宣告 protected 成員</span><span class="sxs-lookup"><span data-stu-id="8aa9e-210">CA1047: Do not declare protected members in sealed types</span></span>](ca1047.md) | <span data-ttu-id="8aa9e-211">類型會宣告 protected 成員，如此繼承的類型即可存取或覆寫成員。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-211">Types declare protected members so that inheriting types can access or override the member.</span></span> <span data-ttu-id="8aa9e-212">根據定義，密封類型無法被繼承，這表示無法呼叫密封類型上的受保護方法。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-212">By definition, sealed types cannot be inherited, which means that protected methods on sealed types cannot be called.</span></span> |
| [<span data-ttu-id="8aa9e-213">CA1050:類型必須在命名空間中宣告</span><span class="sxs-lookup"><span data-stu-id="8aa9e-213">CA1050: Declare types in namespaces</span></span>](ca1050.md) | <span data-ttu-id="8aa9e-214">類型會在命名空間之內宣告以防止名稱衝突，而且可當做組織物件階層架構中相關類型的一種方法。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-214">Types are declared in namespaces to prevent name collisions and as a way to organize related types in an object hierarchy.</span></span> |
| [<span data-ttu-id="8aa9e-215">CA1051:不要宣告可見的執行個體欄位</span><span class="sxs-lookup"><span data-stu-id="8aa9e-215">CA1051: Do not declare visible instance fields</span></span>](ca1051.md) | <span data-ttu-id="8aa9e-216">欄位的主要用法應該是當做實作詳細資料。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-216">The primary use of a field should be as an implementation detail.</span></span> <span data-ttu-id="8aa9e-217">欄位應該是私用或內部的，而且應使用屬性公開。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-217">Fields should be private or internal and should be exposed by using properties.</span></span> |
| [<span data-ttu-id="8aa9e-218">CA1052:靜態預留位置類型應該為密封的</span><span class="sxs-lookup"><span data-stu-id="8aa9e-218">CA1052: Static holder types should be sealed</span></span>](ca1052.md) | <span data-ttu-id="8aa9e-219">公用或受保護的型別只包含靜態成員，而不是使用 sealed (c # ) 或 NotInheritable (Visual Basic) 修飾詞來宣告。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-219">A public or protected type contains only static members and is not declared by using the sealed (C#) or NotInheritable (Visual Basic) modifier.</span></span> <span data-ttu-id="8aa9e-220">預定不會繼承的類型應該使用 sealed 修飾詞來標記，以禁止使用它做為基底類型。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-220">A type that is not meant to be inherited should be marked by using the sealed modifier to prevent its use as a base type.</span></span> |
| [<span data-ttu-id="8aa9e-221">CA1053:靜態預留位置類型不應該包含建構函式</span><span class="sxs-lookup"><span data-stu-id="8aa9e-221">CA1053: Static holder types should not have constructors</span></span>](ca1053.md) | <span data-ttu-id="8aa9e-222">公用或巢狀公用類型只宣告靜態成員，而且具有公用或保護的預設建構函式。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-222">A public or nested public type declares only static members and has a public or protected default constructor.</span></span> <span data-ttu-id="8aa9e-223">建構函式不是必要的，因為呼叫靜態成員不需類型的執行個體。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-223">The constructor is unnecessary because calling static members does not require an instance of the type.</span></span> <span data-ttu-id="8aa9e-224">為了安全，字串多載應該使用字串引數來呼叫統一資源識別項 (URI) 多載。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-224">The string overload should call the uniform resource identifier (URI) overload by using the string argument for safety and security.</span></span> |
| [<span data-ttu-id="8aa9e-225">CA1054:URI 參數不應該為字串</span><span class="sxs-lookup"><span data-stu-id="8aa9e-225">CA1054: URI parameters should not be strings</span></span>](ca1054.md) | <span data-ttu-id="8aa9e-226">如果方法使用 URI 字串表示，應該提供採用 URI 類別的對應多載，這樣就可以透過安全的方式提供這些服務。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-226">If a method takes a string representation of a URI, a corresponding overload should be provided that takes an instance of the URI class, which provides these services in a safe and secure manner.</span></span> |
| [<span data-ttu-id="8aa9e-227">CA1055:URI 傳回值不應該為字串</span><span class="sxs-lookup"><span data-stu-id="8aa9e-227">CA1055: URI return values should not be strings</span></span>](ca1055.md) | <span data-ttu-id="8aa9e-228">這項規則假設方法會傳回 URI。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-228">This rule assumes that the method returns a URI.</span></span> <span data-ttu-id="8aa9e-229">URI 的字串表示方式容易發生剖析和編碼錯誤，並且可能因此產生安全性弱點。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-229">A string representation of a URI is prone to parsing and encoding errors, and can lead to security vulnerabilities.</span></span> <span data-ttu-id="8aa9e-230">System.Uri 類別以安全的方式提供這些服務。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-230">The System.Uri class provides these services in a safe and secure manner.</span></span> |
| [<span data-ttu-id="8aa9e-231">CA1056:URI 屬性不應該為字串</span><span class="sxs-lookup"><span data-stu-id="8aa9e-231">CA1056: URI properties should not be strings</span></span>](ca1056.md) | <span data-ttu-id="8aa9e-232">此規則假設屬性代表 URI。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-232">This rule assumes that the property represents a URI.</span></span> <span data-ttu-id="8aa9e-233">URI 的字串表示方式容易發生剖析和編碼錯誤，並且可能因此產生安全性弱點。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-233">A string representation of a URI is prone to parsing and encoding errors, and can lead to security vulnerabilities.</span></span> <span data-ttu-id="8aa9e-234">System.Uri 類別以安全的方式提供這些服務。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-234">The System.Uri class provides these services in a safe and secure manner.</span></span> |
| [<span data-ttu-id="8aa9e-235">CA1058:類型不應該擴充特定基底類型</span><span class="sxs-lookup"><span data-stu-id="8aa9e-235">CA1058: Types should not extend certain base types</span></span>](ca1058.md) | <span data-ttu-id="8aa9e-236">外部可見的類型會延伸某些基底類型 (Base Type)。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-236">An externally visible type extends certain base types.</span></span> <span data-ttu-id="8aa9e-237">請使用其他作法。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-237">Use one of the alternatives.</span></span> |
| [<span data-ttu-id="8aa9e-238">CA1060：將 P/Invoke 移至 NativeMethods 類別</span><span class="sxs-lookup"><span data-stu-id="8aa9e-238">CA1060: Move P/Invokes to NativeMethods class</span></span>](ca1060.md) | <span data-ttu-id="8aa9e-239">平台叫用方法，例如 <xref:System.Runtime.InteropServices.DllImportAttribute?displayProperty=fullName> 使用 Visual Basic 中的 Declare 關鍵字所定義的或方法，存取非受控碼。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-239">Platform Invocation methods, such as those marked with the <xref:System.Runtime.InteropServices.DllImportAttribute?displayProperty=fullName> or methods defined by using the Declare keyword in Visual Basic, access unmanaged code.</span></span> <span data-ttu-id="8aa9e-240">這些方法應該是 NativeMethods、SafeNativeMethods 或 UnsafeNativeMethods 類別。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-240">These methods should be of the NativeMethods, SafeNativeMethods, or UnsafeNativeMethods class.</span></span> |
| [<span data-ttu-id="8aa9e-241">CA1061:不要隱藏基底類別方法</span><span class="sxs-lookup"><span data-stu-id="8aa9e-241">CA1061: Do not hide base class methods</span></span>](ca1061.md) | <span data-ttu-id="8aa9e-242">只有在衍生方法的參數簽章因類型衍生時比基底方法參數簽章中的類型還要弱時，基底類型中的方法才會被衍生類型中的相同具名方法所隱藏。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-242">A method in a base type is hidden by an identically named method in a derived type, when the parameter signature of the derived method differs only by types that are more weakly derived than the corresponding types in the parameter signature of the base method.</span></span> |
| [<span data-ttu-id="8aa9e-243">CA1062:必須驗證公用方法的引數</span><span class="sxs-lookup"><span data-stu-id="8aa9e-243">CA1062: Validate arguments of public methods</span></span>](ca1062.md) | <span data-ttu-id="8aa9e-244">所有傳遞至外部可見方法的參考引數都應經過 null 檢查。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-244">All reference arguments that are passed to externally visible methods should be checked against null.</span></span> |
| [<span data-ttu-id="8aa9e-245">CA1063:必須正確實作 IDisposable</span><span class="sxs-lookup"><span data-stu-id="8aa9e-245">CA1063: Implement IDisposable correctly</span></span>](ca1063.md) | <span data-ttu-id="8aa9e-246">所有的 IDisposable 類型都需正確地實作 Dispose 模式。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-246">All IDisposable types should implement the Dispose pattern correctly.</span></span> |
| [<span data-ttu-id="8aa9e-247">CA1064:例外狀況必須是公用</span><span class="sxs-lookup"><span data-stu-id="8aa9e-247">CA1064: Exceptions should be public</span></span>](ca1064.md) | <span data-ttu-id="8aa9e-248">內部例外狀況只會在自己的內部範圍內顯示。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-248">An internal exception is visible only inside its own internal scope.</span></span> <span data-ttu-id="8aa9e-249">當例外狀況超出內部範圍後，只能使用基本例外狀況來攔截例外狀況。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-249">After the exception falls outside the internal scope, only the base exception can be used to catch the exception.</span></span> <span data-ttu-id="8aa9e-250">如果內部例外狀況繼承自 <xref:System.Exception?displayProperty=fullName> 、 <xref:System.SystemException?displayProperty=fullName> 或 <xref:System.ApplicationException?displayProperty=fullName> ，則外部程式碼將不會有足夠的資訊來知道該如何處理例外狀況。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-250">If the internal exception is inherited from <xref:System.Exception?displayProperty=fullName>, <xref:System.SystemException?displayProperty=fullName>, or <xref:System.ApplicationException?displayProperty=fullName>, the external code will not have sufficient information to know what to do with the exception.</span></span> |
| [<span data-ttu-id="8aa9e-251">CA1065:不要在非預期的位置中引發例外狀況</span><span class="sxs-lookup"><span data-stu-id="8aa9e-251">CA1065: Do not raise exceptions in unexpected locations</span></span>](ca1065.md) | <span data-ttu-id="8aa9e-252">不可擲回例外狀況 (Exception) 的方法卻擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-252">A method that is not expected to throw exceptions throws an exception.</span></span> |
| [<span data-ttu-id="8aa9e-253">CA1066：覆寫 Equals 時實作 IEquatable</span><span class="sxs-lookup"><span data-stu-id="8aa9e-253">CA1066: Implement IEquatable when overriding Equals</span></span>](ca1066.md) | <span data-ttu-id="8aa9e-254">實值型別 <xref:System.Object.Equals%2A> 會覆寫方法，但不會執行 <xref:System.IEquatable%601> 。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-254">A value type overrides <xref:System.Object.Equals%2A> method, but does not implement <xref:System.IEquatable%601>.</span></span> |
| [<span data-ttu-id="8aa9e-255">CA1067：實作 IEquatable 時覆寫 Equals</span><span class="sxs-lookup"><span data-stu-id="8aa9e-255">CA1067: Override Equals when implementing IEquatable</span></span>](ca1067.md) | <span data-ttu-id="8aa9e-256">型別 <xref:System.IEquatable%601> 會執行，但不會覆寫 <xref:System.Object.Equals%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-256">A type implements <xref:System.IEquatable%601>, but does not override <xref:System.Object.Equals%2A> method.</span></span> |
| [<span data-ttu-id="8aa9e-257">CA1068：CancellationToken 參數必須位於最後</span><span class="sxs-lookup"><span data-stu-id="8aa9e-257">CA1068: CancellationToken parameters must come last</span></span>](ca1068.md) | <span data-ttu-id="8aa9e-258">方法的 CancellationToken 參數不是最後一個參數。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-258">A method has a CancellationToken parameter that is not the last parameter.</span></span> |
| [<span data-ttu-id="8aa9e-259">CA1069：列舉不能有重複的值</span><span class="sxs-lookup"><span data-stu-id="8aa9e-259">CA1069: Enums should not have duplicate values</span></span>](ca1069.md) | <span data-ttu-id="8aa9e-260">列舉具有多個明確指派相同常數值的成員。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-260">An enumeration has multiple members which are explicitly assigned the same constant value.</span></span> |
| [<span data-ttu-id="8aa9e-261">CA1070：請勿將事件欄位宣告為 virtual</span><span class="sxs-lookup"><span data-stu-id="8aa9e-261">CA1070: Do not declare event fields as virtual</span></span>](ca1070.md) | <span data-ttu-id="8aa9e-262">[類似欄位的事件](../../../csharp/event-pattern.md#defining-and-raising-field-like-events)已宣告為 virtual。</span><span class="sxs-lookup"><span data-stu-id="8aa9e-262">A [field-like event](../../../csharp/event-pattern.md#defining-and-raising-field-like-events) was declared as virtual.</span></span> |
