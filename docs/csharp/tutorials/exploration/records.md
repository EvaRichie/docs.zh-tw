---
title: '使用記錄類型-c # 教學課程'
description: 瞭解如何使用記錄類型、建立記錄的階層，以及選擇要在類別上選擇記錄的時機。
ms.date: 11/12/2020
ms.openlocfilehash: 8a2cb6966ab4f93432723fd6f82618efa86b26aa
ms.sourcegitcommit: 34968a61e9bac0f6be23ed6ffb837f52d2390c85
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 11/17/2020
ms.locfileid: "94688582"
---
# <a name="create-record-types"></a><span data-ttu-id="b2a98-103">建立記錄類型</span><span class="sxs-lookup"><span data-stu-id="b2a98-103">Create record types</span></span>

<span data-ttu-id="b2a98-104">C # 9 引進了 *記錄*，這是您可以建立的新參考型別，而不是類別或結構。</span><span class="sxs-lookup"><span data-stu-id="b2a98-104">C# 9 introduces *records*, a new reference type that you can create instead of classes or structs.</span></span> <span data-ttu-id="b2a98-105">記錄與類別的不同之處是，記錄類型使用以 *值為基礎的相等*。</span><span class="sxs-lookup"><span data-stu-id="b2a98-105">Records are distinct from classes in that record types use *value-based equality*.</span></span> <span data-ttu-id="b2a98-106">如果記錄類型定義相同，記錄類型的兩個變數會相等，而且如果是針對每個欄位，則兩筆記錄中的值都相等。</span><span class="sxs-lookup"><span data-stu-id="b2a98-106">Two variables of a record type are equal if the record type definitions are identical, and if for every field, the values in both records are equal.</span></span> <span data-ttu-id="b2a98-107">如果參考的物件是相同的類別類型，而且變數參考相同的物件，則類別型別的兩個變數會相等。</span><span class="sxs-lookup"><span data-stu-id="b2a98-107">Two variables of a class type are equal if the objects referred to are the same class type and the variables refer to the same object.</span></span> <span data-ttu-id="b2a98-108">以值為基礎的相等表示您可能會想要在記錄類型中的其他功能。</span><span class="sxs-lookup"><span data-stu-id="b2a98-108">Value-based equality implies other capabilities you'll probably want in record types.</span></span> <span data-ttu-id="b2a98-109">當您宣告而不是時，編譯器會產生許多這些成員 `record` `class` 。</span><span class="sxs-lookup"><span data-stu-id="b2a98-109">The compiler generates many of those members when you declare a `record` instead of a `class`.</span></span>

<span data-ttu-id="b2a98-110">在本教學課程中，您將了解如何：</span><span class="sxs-lookup"><span data-stu-id="b2a98-110">In this tutorial, you'll learn how to:</span></span>

> [!div class="checklist"]
>
> - <span data-ttu-id="b2a98-111">決定您是否要宣告 `class` 或 `record` 。</span><span class="sxs-lookup"><span data-stu-id="b2a98-111">Decide if you should declare a `class` or a `record`.</span></span>
> - <span data-ttu-id="b2a98-112">宣告記錄類型和位置記錄類型。</span><span class="sxs-lookup"><span data-stu-id="b2a98-112">Declare record types and positional record types.</span></span>
> - <span data-ttu-id="b2a98-113">以您的方法取代記錄中編譯器產生的方法。</span><span class="sxs-lookup"><span data-stu-id="b2a98-113">Substitute your methods for compiler generated methods in records.</span></span>

## <a name="prerequisites"></a><span data-ttu-id="b2a98-114">先決條件</span><span class="sxs-lookup"><span data-stu-id="b2a98-114">Prerequisites</span></span>

<span data-ttu-id="b2a98-115">您必須設定電腦以執行 .NET 5 或更新版本，包括 c # 9.0 或更新版本的編譯器。</span><span class="sxs-lookup"><span data-stu-id="b2a98-115">You’ll need to set up your machine to run .NET 5 or later, including the C# 9.0 or later compiler.</span></span> <span data-ttu-id="b2a98-116">從 [Visual Studio 2019 16.8 版](https://visualstudio.microsoft.com/vs) 或 [.net 5.0 SDK](https://dotnet.microsoft.com/download)開始，可以使用 c # 9.0 編譯器。</span><span class="sxs-lookup"><span data-stu-id="b2a98-116">The C# 9.0 compiler is available starting with [Visual Studio 2019 version 16.8](https://visualstudio.microsoft.com/vs) or the [.NET 5.0 SDK](https://dotnet.microsoft.com/download).</span></span>

## <a name="characteristics-of-records"></a><span data-ttu-id="b2a98-117">記錄的特性</span><span class="sxs-lookup"><span data-stu-id="b2a98-117">Characteristics of records</span></span>

<span data-ttu-id="b2a98-118">您可以使用 *record* 關鍵字來宣告型別 `record` ，而不是使用 `class` 或關鍵字來定義記錄 `struct` 。</span><span class="sxs-lookup"><span data-stu-id="b2a98-118">You define a *record* by declaring a type with the `record` keyword, instead of the `class` or `struct` keyword.</span></span> <span data-ttu-id="b2a98-119">記錄是參考型別，並遵循以值為基礎的相等語義。</span><span class="sxs-lookup"><span data-stu-id="b2a98-119">A record is a reference type and follows value-based equality semantics.</span></span> <span data-ttu-id="b2a98-120">為了強制執行值語義，編譯器會為您的記錄類型產生數個方法：</span><span class="sxs-lookup"><span data-stu-id="b2a98-120">To enforce value semantics, the compiler generates several methods for your record type:</span></span>

- <span data-ttu-id="b2a98-121">的覆寫 <xref:System.Object.Equals(System.Object)?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="b2a98-121">An override of <xref:System.Object.Equals(System.Object)?displayProperty=nameWithType>.</span></span>
- <span data-ttu-id="b2a98-122">`Equals`其參數為記錄類型的虛擬方法。</span><span class="sxs-lookup"><span data-stu-id="b2a98-122">A virtual `Equals` method whose parameter is the record type.</span></span>
- <span data-ttu-id="b2a98-123">的覆寫 <xref:System.Object.GetHashCode?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="b2a98-123">An override of <xref:System.Object.GetHashCode?displayProperty=nameWithType>.</span></span>
- <span data-ttu-id="b2a98-124">和的 `operator ==` 方法 `operator !=` 。</span><span class="sxs-lookup"><span data-stu-id="b2a98-124">Methods for `operator ==` and `operator !=`.</span></span>
- <span data-ttu-id="b2a98-125">執行記錄類型 <xref:System.IEquatable%601?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="b2a98-125">Record types implement <xref:System.IEquatable%601?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="b2a98-126">此外，記錄會提供的覆寫 <xref:System.Object.ToString?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="b2a98-126">In addition, records provide an override of <xref:System.Object.ToString?displayProperty=nameWithType>.</span></span> <span data-ttu-id="b2a98-127">編譯器會會合成使用來顯示記錄的方法 <xref:System.Object.ToString?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="b2a98-127">The compiler synthesizes methods for displaying records using <xref:System.Object.ToString?displayProperty=nameWithType>.</span></span> <span data-ttu-id="b2a98-128">當您撰寫本教學課程的程式碼時，將會探索這些成員。</span><span class="sxs-lookup"><span data-stu-id="b2a98-128">You'll explore those members as you write the code for this tutorial.</span></span> <span data-ttu-id="b2a98-129">記錄支援 `with` 運算式，以啟用記錄的非破壞性變化。</span><span class="sxs-lookup"><span data-stu-id="b2a98-129">Records support `with` expressions to enable non-destructive mutation of records.</span></span>

<span data-ttu-id="b2a98-130">您也可以使用更簡潔的語法來宣告 *位置記錄* 。</span><span class="sxs-lookup"><span data-stu-id="b2a98-130">You can also declare *positional records* using a more concise syntax.</span></span> <span data-ttu-id="b2a98-131">當您宣告位置記錄時，編譯器會會合成更多的方法：</span><span class="sxs-lookup"><span data-stu-id="b2a98-131">The compiler synthesizes more methods for you when you declare positional records:</span></span>

- <span data-ttu-id="b2a98-132">主要的函式，其參數符合記錄宣告上的位置參數。</span><span class="sxs-lookup"><span data-stu-id="b2a98-132">A primary constructor whose parameters match the positional parameters on the record declaration.</span></span>
- <span data-ttu-id="b2a98-133">主要函式之每個參數的公用初始化屬性。</span><span class="sxs-lookup"><span data-stu-id="b2a98-133">Public init-only properties for each parameter of a primary constructor.</span></span>
- <span data-ttu-id="b2a98-134">`Deconstruct`從記錄中解壓縮屬性的方法。</span><span class="sxs-lookup"><span data-stu-id="b2a98-134">A `Deconstruct` method to extract properties from the record.</span></span>

## <a name="build-temperature-data"></a><span data-ttu-id="b2a98-135">建立溫度資料</span><span class="sxs-lookup"><span data-stu-id="b2a98-135">Build temperature data</span></span>

<span data-ttu-id="b2a98-136">資料和統計資料是您想要使用記錄的案例中。</span><span class="sxs-lookup"><span data-stu-id="b2a98-136">Data and statistics are among the scenarios where you'll want to use records.</span></span> <span data-ttu-id="b2a98-137">在本教學課程中，您將會建立應用程式，以計算不同用途的 *程度* 。</span><span class="sxs-lookup"><span data-stu-id="b2a98-137">For this tutorial, you'll build an application that computes *degree days* for different uses.</span></span> <span data-ttu-id="b2a98-138">「*程度*」是一種熱度 (的量值，或在一段時間、幾周或幾個月內缺少熱度) 。</span><span class="sxs-lookup"><span data-stu-id="b2a98-138">*Degree days* are a measure of heat (or lack of heat) over a period of days, weeks, or months.</span></span> <span data-ttu-id="b2a98-139">學位天的追蹤和預測能源使用量。</span><span class="sxs-lookup"><span data-stu-id="b2a98-139">Degree days track and predict energy usage.</span></span> <span data-ttu-id="b2a98-140">更高的日子表示更多的空調，低天則表示更 furnace 的使用量。</span><span class="sxs-lookup"><span data-stu-id="b2a98-140">More hotter days means more air conditioning, and more colder days means more furnace usage.</span></span> <span data-ttu-id="b2a98-141">學位天有助於管理工廠人口。</span><span class="sxs-lookup"><span data-stu-id="b2a98-141">Degree days help manage plant populations.</span></span> <span data-ttu-id="b2a98-142">隨著季節的變化，與廠成長的程度會產生關聯。</span><span class="sxs-lookup"><span data-stu-id="b2a98-142">Degree days correlate to plant growth as the seasons change.</span></span> <span data-ttu-id="b2a98-143">學位天有助於追蹤物種的動物旅程，以符合氣候。</span><span class="sxs-lookup"><span data-stu-id="b2a98-143">Degree days help track animal migrations for species that travel to match climate.</span></span>

<span data-ttu-id="b2a98-144">此公式是以指定日期的平均溫度和基準溫度為基礎。</span><span class="sxs-lookup"><span data-stu-id="b2a98-144">The formula is based on the mean temperature on a given day and a baseline temperature.</span></span> <span data-ttu-id="b2a98-145">若要在一段時間內計算一段時間，您每天都需要最高和最低溫度。</span><span class="sxs-lookup"><span data-stu-id="b2a98-145">To compute degree days over time, you'll need the high and low temperature each day for a period of time.</span></span> <span data-ttu-id="b2a98-146">讓我們從建立新的應用程式開始。</span><span class="sxs-lookup"><span data-stu-id="b2a98-146">Let's start by creating a new application.</span></span> <span data-ttu-id="b2a98-147">建立新的主控台應用程式。</span><span class="sxs-lookup"><span data-stu-id="b2a98-147">Make a new console application.</span></span> <span data-ttu-id="b2a98-148">在名為 "DailyTemperature.cs" 的新檔案中建立新的記錄類型：</span><span class="sxs-lookup"><span data-stu-id="b2a98-148">Create a new record type in a new file named "DailyTemperature.cs":</span></span>

:::code language="csharp" source="snippets/record-types/InterimSteps.cs" ID="DailyRecord":::

<span data-ttu-id="b2a98-149">上述程式碼會定義 *位置記錄*。</span><span class="sxs-lookup"><span data-stu-id="b2a98-149">The preceding code defines a *positional record*.</span></span> <span data-ttu-id="b2a98-150">您已建立包含兩個屬性的參考型別： `HighTemp` 、和 `LowTemp` 。</span><span class="sxs-lookup"><span data-stu-id="b2a98-150">You've created a reference type that contains two properties: `HighTemp`, and `LowTemp`.</span></span> <span data-ttu-id="b2a98-151">這些屬性是 *僅初始化的屬性*，表示可以在函式中設定或使用屬性初始化運算式。</span><span class="sxs-lookup"><span data-stu-id="b2a98-151">Those properties are *init only properties*, meaning they can be set in the constructor or using a property initializer.</span></span> <span data-ttu-id="b2a98-152">此 `DailyTemperature` 類型也有 *主要* 的函式，其具有兩個符合兩個屬性的參數。</span><span class="sxs-lookup"><span data-stu-id="b2a98-152">The `DailyTemperature` type also has a *primary constructor* that has two parameters that match the two properties.</span></span> <span data-ttu-id="b2a98-153">您可以使用主要的函式來初始化 `DailyTemperature` 記錄：</span><span class="sxs-lookup"><span data-stu-id="b2a98-153">You use the primary constructor to initialize a `DailyTemperature` record:</span></span>

:::code language="csharp" source="snippets/record-types/Program.cs" ID="DeclareData":::

<span data-ttu-id="b2a98-154">您可以將自己的屬性或方法新增至記錄，包括位置記錄。</span><span class="sxs-lookup"><span data-stu-id="b2a98-154">You can add your own properties or methods to records, including positional records.</span></span> <span data-ttu-id="b2a98-155">您必須計算每日的平均溫度。</span><span class="sxs-lookup"><span data-stu-id="b2a98-155">You'll need to compute the mean temperature for each day.</span></span> <span data-ttu-id="b2a98-156">您可以將該屬性加入至 `DailyTemperature` 記錄：</span><span class="sxs-lookup"><span data-stu-id="b2a98-156">You can add that property to the `DailyTemperature` record:</span></span>

:::code language="csharp" source="snippets/record-types/DailyTemperature.cs" ID="TemperatureRecord":::

<span data-ttu-id="b2a98-157">讓我們確認您可以使用此資料。</span><span class="sxs-lookup"><span data-stu-id="b2a98-157">Let's make sure you can use this data.</span></span> <span data-ttu-id="b2a98-158">將下列程式碼新增至 `Main` 方法：</span><span class="sxs-lookup"><span data-stu-id="b2a98-158">Add the following code to your `Main` method:</span></span>

```csharp
foreach (var item in data)
    Console.WriteLine(item);
```

<span data-ttu-id="b2a98-159">執行您的應用程式，您會看到類似下列顯示的輸出 (針對空間) 移除數個數據列：</span><span class="sxs-lookup"><span data-stu-id="b2a98-159">Run your application, and you'll see output that looks similar to the following display (several rows removed for space):</span></span>

```dotnetcli
DailyTemperature { HighTemp = 57, LowTemp = 30, Mean = 43.5 }
DailyTemperature { HighTemp = 60, LowTemp = 35, Mean = 47.5 }


DailyTemperature { HighTemp = 80, LowTemp = 60, Mean = 70 }
DailyTemperature { HighTemp = 85, LowTemp = 66, Mean = 75.5 }
```

<span data-ttu-id="b2a98-160">上述程式碼顯示編譯器合成的覆寫輸出 `ToString` 。</span><span class="sxs-lookup"><span data-stu-id="b2a98-160">The preceding code shows the output from the override of `ToString` synthesized by the compiler.</span></span> <span data-ttu-id="b2a98-161">如果您偏好使用不同的文字，您可以撰寫自己的版本 `ToString` 。</span><span class="sxs-lookup"><span data-stu-id="b2a98-161">If you prefer different text, you can write your own version of `ToString`.</span></span> <span data-ttu-id="b2a98-162">這可防止編譯器為您合成版本。</span><span class="sxs-lookup"><span data-stu-id="b2a98-162">That prevents the compiler from synthesizing a version for you.</span></span>

## <a name="compute-degree-days"></a><span data-ttu-id="b2a98-163">計算度的單位</span><span class="sxs-lookup"><span data-stu-id="b2a98-163">Compute degree days</span></span>

<span data-ttu-id="b2a98-164">若要計算的時間點，您可以從基準溫度和指定一天的平均溫度來算起差異。</span><span class="sxs-lookup"><span data-stu-id="b2a98-164">To compute degree days, you take the difference from a baseline temperature and the mean temperature on a given day.</span></span> <span data-ttu-id="b2a98-165">若要測量一段時間的熱度，您會捨棄平均溫度低於基準的任何天數。</span><span class="sxs-lookup"><span data-stu-id="b2a98-165">To measure heat over time, you discard any days where the mean temperature is below the baseline.</span></span> <span data-ttu-id="b2a98-166">若要在一段時間內測量冷，您會捨棄平均溫度高於基準的任何天數。</span><span class="sxs-lookup"><span data-stu-id="b2a98-166">To measure cold over time, you discard any days where the mean temperature is above the baseline.</span></span> <span data-ttu-id="b2a98-167">例如，美國使用65F 作為加熱和冷卻學位的基礎。</span><span class="sxs-lookup"><span data-stu-id="b2a98-167">For example, the U.S. uses 65F as the base for both heating  and cooling degree days.</span></span> <span data-ttu-id="b2a98-168">這就是不需要加熱或冷卻的溫度。</span><span class="sxs-lookup"><span data-stu-id="b2a98-168">That's the temperature where no heating or cooling is needed.</span></span> <span data-ttu-id="b2a98-169">如果某一天的平均溫度為70F，那一天會是5冷卻學位和0加熱度。</span><span class="sxs-lookup"><span data-stu-id="b2a98-169">If a day has a mean temperature of 70F, that day is 5 cooling degree days and 0 heating degree days.</span></span> <span data-ttu-id="b2a98-170">相反地，如果平均溫度是55F，那一天就是10個加熱度，而0冷卻度的單位。</span><span class="sxs-lookup"><span data-stu-id="b2a98-170">Conversely, if the mean temperature is 55F, that day is 10 heating degree days and 0 cooling degree days.</span></span>

<span data-ttu-id="b2a98-171">您可以將這些公式表示為一小部分的記錄類型：抽象度的日型別，以及兩個代表加熱度和冷卻度的具體類型。</span><span class="sxs-lookup"><span data-stu-id="b2a98-171">You can express these formulas as a small hierarchy of record types: an abstract degree day type and two concrete types for heating degree days and cooling degree days.</span></span> <span data-ttu-id="b2a98-172">這些類型也可以是位置記錄。</span><span class="sxs-lookup"><span data-stu-id="b2a98-172">These types can also be positional records.</span></span> <span data-ttu-id="b2a98-173">它們採用基準溫度和一連串的每日溫度記錄作為主要函式的引數：</span><span class="sxs-lookup"><span data-stu-id="b2a98-173">They take a baseline temperature and a sequence of daily temperature records as arguments to the primary constructor:</span></span>

:::code language="csharp" source="snippets/record-types/InterimSteps.cs" ID="DegreeDaysRecords":::

<span data-ttu-id="b2a98-174">抽象 `DegreeDays` 記錄是和記錄的共用基類 `HeatingDegreeDays` `CoolingDegreeDays` 。</span><span class="sxs-lookup"><span data-stu-id="b2a98-174">The abstract `DegreeDays` record is the shared base class for both the `HeatingDegreeDays` and `CoolingDegreeDays` records.</span></span> <span data-ttu-id="b2a98-175">衍生記錄上的主要函式宣告會顯示如何管理基底記錄初始化。</span><span class="sxs-lookup"><span data-stu-id="b2a98-175">The primary constructor declarations on the derived records show how to manage base record initialization.</span></span> <span data-ttu-id="b2a98-176">您的衍生記錄會宣告基底記錄主要函式中所有參數的參數。</span><span class="sxs-lookup"><span data-stu-id="b2a98-176">Your derived record declares parameters for all the parameters in the base record primary constructor.</span></span> <span data-ttu-id="b2a98-177">基底記錄會宣告並初始化這些屬性。</span><span class="sxs-lookup"><span data-stu-id="b2a98-177">The base record declares and initializes those properties.</span></span> <span data-ttu-id="b2a98-178">衍生的記錄不會隱藏它們，但只會針對其基底記錄中未宣告的參數建立和初始化屬性。</span><span class="sxs-lookup"><span data-stu-id="b2a98-178">The derived record doesn't hide them, but only creates and initializes properties for parameters that aren't declared in its base record.</span></span> <span data-ttu-id="b2a98-179">在此範例中，衍生記錄不會加入新的主要函式參數。</span><span class="sxs-lookup"><span data-stu-id="b2a98-179">In this example, the derived records don't add new primary constructor parameters.</span></span> <span data-ttu-id="b2a98-180">將下列程式碼新增至您的方法，以測試您的程式碼 `Main` ：</span><span class="sxs-lookup"><span data-stu-id="b2a98-180">Test your code by adding the following code to your `Main` method:</span></span>

:::code language="csharp" source="snippets/record-types/Program.cs" ID="HeatingAndCooling":::

<span data-ttu-id="b2a98-181">您將會得到類似下列顯示的輸出：</span><span class="sxs-lookup"><span data-stu-id="b2a98-181">You'll get output like the following display:</span></span>

```dotnetcli
HeatingDegreeDays { BaseTemperature = 65, TempRecords = record_types.DailyTemperature[], DegreeDays = 85 }
CoolingDegreeDays { BaseTemperature = 65, TempRecords = record_types.DailyTemperature[], DegreeDays = 71.5 }
```

## <a name="define-compiler-synthesized-methods"></a><span data-ttu-id="b2a98-182">定義編譯器合成的方法</span><span class="sxs-lookup"><span data-stu-id="b2a98-182">Define compiler-synthesized methods</span></span>

<span data-ttu-id="b2a98-183">您的程式碼會在一段時間內計算出正確的加熱和冷卻角度。</span><span class="sxs-lookup"><span data-stu-id="b2a98-183">Your code calculates the correct number of heating and cooling degree days over that period of time.</span></span> <span data-ttu-id="b2a98-184">但是，這個範例會示範為何您可能想要取代某些記錄的合成方法。</span><span class="sxs-lookup"><span data-stu-id="b2a98-184">But this example shows why you may want to replace some of the synthesized methods for records.</span></span> <span data-ttu-id="b2a98-185">您可以在記錄類型中宣告您自己的任何編譯器合成方法版本（複製方法除外）。</span><span class="sxs-lookup"><span data-stu-id="b2a98-185">You can declare your own version of any of the compiler-synthesized methods in a record type except the clone method.</span></span> <span data-ttu-id="b2a98-186">Clone 方法具有編譯器產生的名稱，而且您無法提供不同的執行方式。</span><span class="sxs-lookup"><span data-stu-id="b2a98-186">The clone method has a compiler generated name and you cannot provide a different implementation.</span></span> <span data-ttu-id="b2a98-187">這些合成方法包括複製的函式、介面的成員 <xref:System.IEquatable%601?displayProperty=nameWithType> 、相等和不等測試，以及 <xref:System.Object.GetHashCode> 。</span><span class="sxs-lookup"><span data-stu-id="b2a98-187">These synthesized methods include a copy constructor, the members of the <xref:System.IEquatable%601?displayProperty=nameWithType> interface, equality and inequality tests, and <xref:System.Object.GetHashCode>.</span></span> <span data-ttu-id="b2a98-188">基於這個目的，您將會合成 `PrintMembers` 。</span><span class="sxs-lookup"><span data-stu-id="b2a98-188">For this purpose, you'll synthesize `PrintMembers`.</span></span> <span data-ttu-id="b2a98-189">您也可以宣告自己的 `ToString` ，但 `PrintMembers` 為繼承案例提供更好的選項。</span><span class="sxs-lookup"><span data-stu-id="b2a98-189">You could also declare your own `ToString`, but `PrintMembers` provides a better option for inheritance scenarios.</span></span> <span data-ttu-id="b2a98-190">若要提供您自己的合成方法版本，簽章必須符合合成方法。</span><span class="sxs-lookup"><span data-stu-id="b2a98-190">To provide your own version of a synthesized method, the signature must match the synthesized method.</span></span>

<span data-ttu-id="b2a98-191">`TempRecords`主控台輸出中的元素不實用。</span><span class="sxs-lookup"><span data-stu-id="b2a98-191">The `TempRecords` element in the console output isn't useful.</span></span> <span data-ttu-id="b2a98-192">它會顯示類型，但不會顯示任何其他專案。</span><span class="sxs-lookup"><span data-stu-id="b2a98-192">It displays the type, but nothing else.</span></span> <span data-ttu-id="b2a98-193">您可以藉由提供合成方法的執行方式來變更此行為 `PrintMembers` 。</span><span class="sxs-lookup"><span data-stu-id="b2a98-193">You can change this behavior by providing your own implementation of the synthesized `PrintMembers` method.</span></span> <span data-ttu-id="b2a98-194">簽章取決於套用至宣告的修飾詞 `record` ：</span><span class="sxs-lookup"><span data-stu-id="b2a98-194">The signature depends on modifiers applied to the `record` declaration:</span></span>

- <span data-ttu-id="b2a98-195">如果記錄類型為 `sealed` ，則簽章為 `private bool PrintMembers(StringBuilder builder);`</span><span class="sxs-lookup"><span data-stu-id="b2a98-195">If a record type is `sealed`, the signature is `private bool PrintMembers(StringBuilder builder);`</span></span>
- <span data-ttu-id="b2a98-196">如果記錄類型不是 `sealed` 衍生自 (也不會宣告 `object` 基底記錄) ，則簽章為 `protected virtual bool PrintMembers(StringBuilder builder);`</span><span class="sxs-lookup"><span data-stu-id="b2a98-196">If a record type isn't `sealed` and derives from `object` (that is, it doesn't declare a base record), the signature is `protected virtual bool PrintMembers(StringBuilder builder);`</span></span>
- <span data-ttu-id="b2a98-197">如果記錄類型不是 `sealed` 衍生自另一筆記錄，則簽章為 `protected override bool PrintMembers(StringBuilder builder);`</span><span class="sxs-lookup"><span data-stu-id="b2a98-197">If a record type isn't `sealed` and derives from another record, the signature is `protected override bool PrintMembers(StringBuilder builder);`</span></span>

<span data-ttu-id="b2a98-198">這些規則最容易透過瞭解的目的來理解 `PrintMembers` 。</span><span class="sxs-lookup"><span data-stu-id="b2a98-198">These rules are easiest to comprehend through understanding the purpose of `PrintMembers`.</span></span> <span data-ttu-id="b2a98-199">`PrintMembers` 將記錄類型中每個屬性的相關資訊加入至字串。</span><span class="sxs-lookup"><span data-stu-id="b2a98-199">`PrintMembers` adds information about each property in a record type to a string.</span></span> <span data-ttu-id="b2a98-200">合約需要基底記錄，以將其成員新增到顯示中，並假設衍生成員將會加入其成員。</span><span class="sxs-lookup"><span data-stu-id="b2a98-200">The contract requires base records to add their members to the display and assumes derived members will add their members.</span></span> <span data-ttu-id="b2a98-201">每一筆記錄類型 `ToString` 都會會合成類似下列範例的覆寫 `HeatingDegreeDays` ：</span><span class="sxs-lookup"><span data-stu-id="b2a98-201">Each record type synthesizes a `ToString` override that looks similar to the following example for `HeatingDegreeDays`:</span></span>

```csharp
public override string ToString()
{
    StringBuilder stringBuilder = new StringBuilder();
    stringBuilder.Append("HeatingDegreeDays");
    stringBuilder.Append(" { ");
    if (PrintMembers(stringBuilder))
    {
        stringBuilder.Append(" ");
    }
    stringBuilder.Append("}");
    return stringBuilder.ToString();
}
```

<span data-ttu-id="b2a98-202">您 `PrintMembers` 在記錄中宣告的方法 `DegreeDays` 不會列印集合的類型：</span><span class="sxs-lookup"><span data-stu-id="b2a98-202">You declare a `PrintMembers` method in the `DegreeDays` record that doesn't print the type of the collection:</span></span>

:::code language="csharp" source="snippets/record-types/DegreeDays.cs" ID="AddPrintMembers":::

<span data-ttu-id="b2a98-203">簽章會宣告 `virtual protected` 符合編譯器版本的方法。</span><span class="sxs-lookup"><span data-stu-id="b2a98-203">The signature declares a `virtual protected` method to match the compiler's version.</span></span> <span data-ttu-id="b2a98-204">如果您遇到存取子的錯誤，別擔心，語言會強制執行正確的簽章。</span><span class="sxs-lookup"><span data-stu-id="b2a98-204">Don't worry if you get the accessors wrong; the language enforces the correct signature.</span></span> <span data-ttu-id="b2a98-205">如果您忘記任何合成方法的正確修飾詞，編譯器會發出警告或錯誤，以協助您取得正確的簽章。</span><span class="sxs-lookup"><span data-stu-id="b2a98-205">If you forget the correct modifiers for any synthesized method, the compiler issues warnings or errors that help you get the right signature.</span></span>

## <a name="non-destructive-mutation"></a><span data-ttu-id="b2a98-206">非破壞性變化</span><span class="sxs-lookup"><span data-stu-id="b2a98-206">Non-destructive mutation</span></span>

<span data-ttu-id="b2a98-207">位置記錄中的合成成員不會修改記錄的狀態。</span><span class="sxs-lookup"><span data-stu-id="b2a98-207">The synthesized members in a positional record don't modify the state of the record.</span></span> <span data-ttu-id="b2a98-208">目標是您可以更輕鬆地建立不可變的記錄。</span><span class="sxs-lookup"><span data-stu-id="b2a98-208">The goal is that you can more easily create immutable records.</span></span> <span data-ttu-id="b2a98-209">再次查看和先前的宣告 `HeatingDegreeDays` `CoolingDegreeDays` 。</span><span class="sxs-lookup"><span data-stu-id="b2a98-209">Look again at the preceding declarations for `HeatingDegreeDays` and `CoolingDegreeDays`.</span></span> <span data-ttu-id="b2a98-210">新增的成員會對記錄的值執行計算，但不會變動狀態。</span><span class="sxs-lookup"><span data-stu-id="b2a98-210">The members added perform computations on the values for the record, but don't mutate state.</span></span> <span data-ttu-id="b2a98-211">位置記錄可讓您更輕鬆地建立不可變的參考型別。</span><span class="sxs-lookup"><span data-stu-id="b2a98-211">Positional records make it easier for you to create immutable reference types.</span></span>

<span data-ttu-id="b2a98-212">建立不可變的參考型別表示您會想要使用非破壞性的變化。</span><span class="sxs-lookup"><span data-stu-id="b2a98-212">Creating immutable reference types means you'll want to use non-destructive mutation.</span></span> <span data-ttu-id="b2a98-213">您可以使用[ `with` 運算式](../../language-reference/operators/with-expression.md)，建立與現有記錄實例類似的新記錄實例。</span><span class="sxs-lookup"><span data-stu-id="b2a98-213">You  create new record instances that are similar to existing record instances using [`with` expressions](../../language-reference/operators/with-expression.md).</span></span> <span data-ttu-id="b2a98-214">這些運算式是具有可修改複製之其他指派的複製結構。</span><span class="sxs-lookup"><span data-stu-id="b2a98-214">These expressions are a copy construction with additional assignments that modify the copy.</span></span> <span data-ttu-id="b2a98-215">結果是新的記錄實例，其中每個屬性都已從現有記錄複製並選擇性地修改。</span><span class="sxs-lookup"><span data-stu-id="b2a98-215">The result is a new record instance where each property has been copied from the existing record and optionally modified.</span></span> <span data-ttu-id="b2a98-216">原始記錄不變。</span><span class="sxs-lookup"><span data-stu-id="b2a98-216">The original record is unchanged.</span></span>

<span data-ttu-id="b2a98-217">讓我們將一些功能新增至示範運算式的程式 `with` 。</span><span class="sxs-lookup"><span data-stu-id="b2a98-217">Let's add a couple features to your program that demonstrate `with` expressions.</span></span> <span data-ttu-id="b2a98-218">首先，讓我們使用相同的資料來建立新的記錄，以計算成長的程度。</span><span class="sxs-lookup"><span data-stu-id="b2a98-218">First, let's create a new record to compute growing degree days using the same data.</span></span> <span data-ttu-id="b2a98-219">*成長的程度* 通常會使用41F 做為基準，並測量高於基準的溫度。</span><span class="sxs-lookup"><span data-stu-id="b2a98-219">*Growing degree days* typically uses 41F as the baseline and measures temperatures above the baseline.</span></span> <span data-ttu-id="b2a98-220">若要使用相同的資料，您可以建立類似的新記錄 `coolingDegreeDays` ，但使用不同的基本溫度：</span><span class="sxs-lookup"><span data-stu-id="b2a98-220">To use the same data, you can create a new record that is similar to the `coolingDegreeDays`, but with a different base temperature:</span></span>

:::code language="csharp" source="snippets/record-types/Program.cs" ID="GrowingDegreeDays":::

<span data-ttu-id="b2a98-221">您可以比較計算的單位數與以較高基準溫度產生的數位。</span><span class="sxs-lookup"><span data-stu-id="b2a98-221">You can compare the number of degrees computed to the numbers generated with a higher baseline temperature.</span></span> <span data-ttu-id="b2a98-222">請記住，記錄是 *參考* 型別，而這些複本是淺層複製。</span><span class="sxs-lookup"><span data-stu-id="b2a98-222">Remember that records are *reference types* and these copies are shallow copies.</span></span> <span data-ttu-id="b2a98-223">不會複製資料的陣列，但是這兩筆記錄都會參考相同的資料。</span><span class="sxs-lookup"><span data-stu-id="b2a98-223">The array for the data isn't copied, but both records refer to the same data.</span></span> <span data-ttu-id="b2a98-224">這是另一個案例的優點。</span><span class="sxs-lookup"><span data-stu-id="b2a98-224">That fact is an advantage in one other scenario.</span></span> <span data-ttu-id="b2a98-225">針對不斷成長的程度，追蹤前5天的總計會很有用。</span><span class="sxs-lookup"><span data-stu-id="b2a98-225">For growing degree days, it's useful to keep track of the total for the previous 5 days.</span></span> <span data-ttu-id="b2a98-226">您可以使用運算式來建立具有不同來源資料的新記錄 `with` 。</span><span class="sxs-lookup"><span data-stu-id="b2a98-226">You can create new records with different source data using `with` expressions.</span></span> <span data-ttu-id="b2a98-227">下列程式碼會建立這些 accumulations 的集合，然後顯示這些值：</span><span class="sxs-lookup"><span data-stu-id="b2a98-227">The following code builds a collection of these accumulations, then displays the values:</span></span>

:::code language="csharp" source="snippets/record-types/Program.cs" ID="RunningFiveDayTotal":::

<span data-ttu-id="b2a98-228">您也可以使用 `with` 運算式來建立記錄的副本。</span><span class="sxs-lookup"><span data-stu-id="b2a98-228">You can also use `with` expressions to create copies of records.</span></span> <span data-ttu-id="b2a98-229">請勿在運算式的大括弧之間指定任何屬性 `with` 。</span><span class="sxs-lookup"><span data-stu-id="b2a98-229">Don't specify any properties between the braces for the `with` expression.</span></span> <span data-ttu-id="b2a98-230">這表示建立複本，而且不要變更任何屬性：</span><span class="sxs-lookup"><span data-stu-id="b2a98-230">That means create a copy, and don't change any properties:</span></span>

```csharp
var growingDegreeDaysCopy = growingDegreeDays with { };
```

<span data-ttu-id="b2a98-231">執行完成的應用程式以查看結果。</span><span class="sxs-lookup"><span data-stu-id="b2a98-231">Run the finished application to see the results.</span></span>

## <a name="summary"></a><span data-ttu-id="b2a98-232">摘要</span><span class="sxs-lookup"><span data-stu-id="b2a98-232">Summary</span></span>

<span data-ttu-id="b2a98-233">本教學課程說明記錄的幾個層面。</span><span class="sxs-lookup"><span data-stu-id="b2a98-233">This tutorial showed several aspects of records.</span></span> <span data-ttu-id="b2a98-234">記錄可針對基本用途是儲存資料的參考型別，提供簡潔的語法。</span><span class="sxs-lookup"><span data-stu-id="b2a98-234">Records provide concise syntax for reference types where the fundamental use is storing data.</span></span> <span data-ttu-id="b2a98-235">針對面向物件類別，基本用途是定義責任。</span><span class="sxs-lookup"><span data-stu-id="b2a98-235">For object-oriented classes, the fundamental use is defining responsibilities.</span></span> <span data-ttu-id="b2a98-236">本教學課程著重于 *位置記錄*，您可以在其中使用精簡的語法來宣告記錄的僅限初始屬性。</span><span class="sxs-lookup"><span data-stu-id="b2a98-236">This tutorial focused on *positional records*, where you can use a concise syntax to declare the init-only properties for a record.</span></span> <span data-ttu-id="b2a98-237">編譯器會會合成記錄的數個成員，以複製和比較記錄。</span><span class="sxs-lookup"><span data-stu-id="b2a98-237">The compiler synthesizes several members of the record for copying and comparing records.</span></span> <span data-ttu-id="b2a98-238">您可以為記錄類型新增所需的任何其他成員。</span><span class="sxs-lookup"><span data-stu-id="b2a98-238">You can add any other members you need for your record types.</span></span> <span data-ttu-id="b2a98-239">您可以建立不可變的記錄類型，知道任何編譯器產生的成員都不會變動狀態。</span><span class="sxs-lookup"><span data-stu-id="b2a98-239">You can create immutable record types knowing that none of the compiler-generated members would mutate state.</span></span> <span data-ttu-id="b2a98-240">針對位置記錄， `with` 運算式可讓您輕鬆地支援非破壞性的變化。</span><span class="sxs-lookup"><span data-stu-id="b2a98-240">For positional records, `with` expressions make it easy to support non-destructive mutation.</span></span>

<span data-ttu-id="b2a98-241">記錄會新增另一個定義類型的方式。</span><span class="sxs-lookup"><span data-stu-id="b2a98-241">Records add another way to define types.</span></span> <span data-ttu-id="b2a98-242">您可以使用 `class` 定義來建立物件導向階層，以專注于物件的責任和行為。</span><span class="sxs-lookup"><span data-stu-id="b2a98-242">You use `class` definitions to create object-oriented hierarchies that focus on the responsibilities and behavior of objects.</span></span> <span data-ttu-id="b2a98-243">您可以建立 `struct` 資料結構的類型來儲存資料，而且小到足以有效率地複製。</span><span class="sxs-lookup"><span data-stu-id="b2a98-243">You create `struct` types for data structures that store data and are small enough to copy efficiently.</span></span> <span data-ttu-id="b2a98-244">當您想要以值為基礎的相等和比較、不想複製值，而且想要使用參考變數時，會建立記錄。</span><span class="sxs-lookup"><span data-stu-id="b2a98-244">You create records when you want value-based equality and comparison, don't want to copy values, and want to use reference variables.</span></span>

<span data-ttu-id="b2a98-245">您可以藉由閱讀 [建議的記錄類型規格](~/_csharplang/proposals/csharp-9.0/records.md)來學習記錄的完整描述。</span><span class="sxs-lookup"><span data-stu-id="b2a98-245">You can learn the complete description of records by reading the [proposed record type specification](~/_csharplang/proposals/csharp-9.0/records.md).</span></span>
