---
title: '使用物件中的模式-c # 教學課程'
description: 本教學課程會教您如何在類別成員中使用模式比對來為物件行為建立更好的模型
ms.date: 11/05/2020
ms.openlocfilehash: 072f6f57696504c2d691473e3a43c1cda53f227f
ms.sourcegitcommit: 6bef8abde346c59771a35f4f76bf037ff61c5ba3
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 11/06/2020
ms.locfileid: "94332186"
---
# <a name="use-pattern-matching-to-build-your-class-behavior-for-better-code"></a><span data-ttu-id="8938c-103">使用模式比對來建立您的類別行為，以取得更好的程式碼</span><span class="sxs-lookup"><span data-stu-id="8938c-103">Use pattern matching to build your class behavior for better code</span></span>

<span data-ttu-id="8938c-104">C # 中的模式比對功能提供表達演算法的語法。</span><span class="sxs-lookup"><span data-stu-id="8938c-104">The pattern matching features in C# provide syntax to express your algorithms.</span></span> <span data-ttu-id="8938c-105">您可以使用這些技術來執行類別中的行為。</span><span class="sxs-lookup"><span data-stu-id="8938c-105">You can use these techniques to implement the behavior in your classes.</span></span> <span data-ttu-id="8938c-106">您可以將物件導向的類別設計與資料導向的實作為結合，以提供簡潔的程式碼，同時為真實世界的物件建立模型。</span><span class="sxs-lookup"><span data-stu-id="8938c-106">You can combine object-oriented class design with a data-oriented implementation to provide concise code while modeling real-world objects.</span></span>

<span data-ttu-id="8938c-107">在本教學課程中，您將了解如何：</span><span class="sxs-lookup"><span data-stu-id="8938c-107">In this tutorial, you'll learn how to:</span></span>

> [!div class="checklist"]
>
> - <span data-ttu-id="8938c-108">使用資料模式表達您的面向物件類別。</span><span class="sxs-lookup"><span data-stu-id="8938c-108">Express your object oriented classes using data patterns.</span></span>
> - <span data-ttu-id="8938c-109">使用 c # 的模式比對功能來執行這些模式。</span><span class="sxs-lookup"><span data-stu-id="8938c-109">Implement those patterns using C#'s pattern matching features.</span></span>
> - <span data-ttu-id="8938c-110">利用編譯器診斷來驗證您的執行。</span><span class="sxs-lookup"><span data-stu-id="8938c-110">Leverage compiler diagnostics to validate your implementation.</span></span>

## <a name="prerequisites"></a><span data-ttu-id="8938c-111">必要條件</span><span class="sxs-lookup"><span data-stu-id="8938c-111">Prerequisites</span></span>

<span data-ttu-id="8938c-112">您必須設定電腦以執行 .NET 5，包括 c # 9.0 編譯器。</span><span class="sxs-lookup"><span data-stu-id="8938c-112">You’ll need to set up your machine to run .NET 5, including the C# 9.0 compiler.</span></span> <span data-ttu-id="8938c-113">從 [Visual Studio 2019 16.8 版 preview](https://visualstudio.microsoft.com/vs/preview/) 或 [.net 5.0 SDK preview](https://dotnet.microsoft.com/download/dotnet/5.0)開始，可以使用 c # 9.0 編譯器。</span><span class="sxs-lookup"><span data-stu-id="8938c-113">The C# 9.0 compiler is available starting with [Visual Studio 2019 version 16.8 preview](https://visualstudio.microsoft.com/vs/preview/) or the [.NET 5.0 SDK preview](https://dotnet.microsoft.com/download/dotnet/5.0).</span></span>

## <a name="build-a-simulation-of-a-canal-lock"></a><span data-ttu-id="8938c-114">建立 canal 鎖定的模擬</span><span class="sxs-lookup"><span data-stu-id="8938c-114">Build a simulation of a canal lock</span></span>

<span data-ttu-id="8938c-115">在本教學課程中，您將建立模擬 [canal 鎖定](https://en.wikipedia.org/wiki/Lock_(water_navigation))的 c # 類別。</span><span class="sxs-lookup"><span data-stu-id="8938c-115">In this tutorial, you'll build a C# class that simulates a [canal lock](https://en.wikipedia.org/wiki/Lock_(water_navigation)).</span></span> <span data-ttu-id="8938c-116">簡單來說，canal 鎖定是一種裝置，可在兩個不同層級的兩個水伸展之間移動時，引發並降低 boats。</span><span class="sxs-lookup"><span data-stu-id="8938c-116">Briefly, a canal lock is a device that raises and lowers boats as they travel between two stretches of water at different levels.</span></span> <span data-ttu-id="8938c-117">鎖定有兩個閘道和一些機制來變更水等級。</span><span class="sxs-lookup"><span data-stu-id="8938c-117">A lock has two gates and some mechanism to change the water level.</span></span>

<span data-ttu-id="8938c-118">在其正常作業中，船會進入其中一個閘道，而鎖定中的水層級則會與船輸入的一端上的水等級相符。</span><span class="sxs-lookup"><span data-stu-id="8938c-118">In its normal operation, a boat enters one of the gates while the water level in the lock matches the water level on the side the boat enters.</span></span> <span data-ttu-id="8938c-119">一旦進入鎖定，就會變更水位線，使其符合當船會離開鎖定的水。</span><span class="sxs-lookup"><span data-stu-id="8938c-119">Once in the lock, the water level is changed to match the water level where the boat will leave the lock.</span></span> <span data-ttu-id="8938c-120">當水等級符合該端時，就會開啟結束端的閘道。</span><span class="sxs-lookup"><span data-stu-id="8938c-120">Once the water level matches that side, the gate on the exit side opens.</span></span> <span data-ttu-id="8938c-121">安全措施可確保操作員無法在 canal 中建立危險的情況。</span><span class="sxs-lookup"><span data-stu-id="8938c-121">Safety measures make sure an operator can't create a dangerous situation in the canal.</span></span> <span data-ttu-id="8938c-122">只有當兩個閘道都關閉時，才可以變更水源層級。</span><span class="sxs-lookup"><span data-stu-id="8938c-122">The water level can be changed only when both gates are closed.</span></span> <span data-ttu-id="8938c-123">最多可以開啟一個閘道。</span><span class="sxs-lookup"><span data-stu-id="8938c-123">At most one gate can be open.</span></span> <span data-ttu-id="8938c-124">若要開啟閘道，鎖定中的水等級必須符合開啟閘道以外的水。</span><span class="sxs-lookup"><span data-stu-id="8938c-124">To open a gate, the water level in the lock must match the water level outside the gate being opened.</span></span>

<span data-ttu-id="8938c-125">您可以建立 c # 類別來建立此行為的模型。</span><span class="sxs-lookup"><span data-stu-id="8938c-125">You can build a C# class to model this behavior.</span></span> <span data-ttu-id="8938c-126">`CanalLock`類別會支援開啟或關閉任一個閘道的命令。</span><span class="sxs-lookup"><span data-stu-id="8938c-126">A `CanalLock` class would support commands to open or close either gate.</span></span> <span data-ttu-id="8938c-127">它會有其他命令來提高或降低水位線。</span><span class="sxs-lookup"><span data-stu-id="8938c-127">It would have other commands to raise or lower the water.</span></span> <span data-ttu-id="8938c-128">類別也應支援屬性，以讀取閘道和水等級的目前狀態。</span><span class="sxs-lookup"><span data-stu-id="8938c-128">The class should also support properties to read the current state of both gates and the water level.</span></span> <span data-ttu-id="8938c-129">您的方法會執行安全措施。</span><span class="sxs-lookup"><span data-stu-id="8938c-129">Your methods implement the safety measures.</span></span>

## <a name="define-a-class"></a><span data-ttu-id="8938c-130">定義類別</span><span class="sxs-lookup"><span data-stu-id="8938c-130">Define a class</span></span>

<span data-ttu-id="8938c-131">您將建立主控台應用程式來測試您的 `CanalLock` 類別。</span><span class="sxs-lookup"><span data-stu-id="8938c-131">You'll build a console application to test your `CanalLock` class.</span></span> <span data-ttu-id="8938c-132">使用 Visual Studio 或 .NET CLI 建立適用于 .NET 5 的新主控台專案。</span><span class="sxs-lookup"><span data-stu-id="8938c-132">Create a new console project for .NET 5 using either Visual Studio or the .NET CLI.</span></span> <span data-ttu-id="8938c-133">然後，新增類別並將其命名為 `CanalLock` 。</span><span class="sxs-lookup"><span data-stu-id="8938c-133">Then, add a new class and name it `CanalLock`.</span></span> <span data-ttu-id="8938c-134">接下來，請設計您的公用 API，但不要執行這些方法：</span><span class="sxs-lookup"><span data-stu-id="8938c-134">Next, design your public API, but leave the methods not implemented:</span></span>

:::code language="csharp" source="snippets/pattern-objects/InterimSteps.cs" ID="APIDesign":::

<span data-ttu-id="8938c-135">上述程式碼會初始化物件，因此會關閉這兩個閘道，而水層級則是低。</span><span class="sxs-lookup"><span data-stu-id="8938c-135">The preceding code initializes the object so both gates are closed, and the water level is low.</span></span> <span data-ttu-id="8938c-136">接下來，在您的方法中撰寫下列測試程式碼， `Main` 以引導您建立類別的第一個實作為：</span><span class="sxs-lookup"><span data-stu-id="8938c-136">Next, write the following test code in your `Main` method to guide you as you create a first implementation of the class:</span></span>

:::code language="csharp" source="snippets/pattern-objects/Program.cs" ID="HappyTests":::

<span data-ttu-id="8938c-137">接下來，在類別中新增每個方法的第一個實作為 `CanalLock` 。</span><span class="sxs-lookup"><span data-stu-id="8938c-137">Next, add a first implementation of each method in the `CanalLock` class.</span></span> <span data-ttu-id="8938c-138">下列程式碼會執行類別的方法，而不會考慮安全性規則。</span><span class="sxs-lookup"><span data-stu-id="8938c-138">The following code implements the methods of the class without concern to the safety rules.</span></span> <span data-ttu-id="8938c-139">您稍後將會新增安全性測試：</span><span class="sxs-lookup"><span data-stu-id="8938c-139">You'll add safety tests later:</span></span>

:::code language="csharp" source="snippets/pattern-objects/InterimSteps.cs" ID="FirstImplementation":::

<span data-ttu-id="8938c-140">您到目前為止所撰寫的測試已通過。</span><span class="sxs-lookup"><span data-stu-id="8938c-140">The tests you've written so far pass.</span></span> <span data-ttu-id="8938c-141">您已實現基本概念。</span><span class="sxs-lookup"><span data-stu-id="8938c-141">You've implemented the basics.</span></span> <span data-ttu-id="8938c-142">現在，撰寫第一個失敗狀況的測試。</span><span class="sxs-lookup"><span data-stu-id="8938c-142">Now, write a test for the first failure condition.</span></span> <span data-ttu-id="8938c-143">在先前的測試結束時，這兩個閘道都已關閉，而水層級設定為 [低]。</span><span class="sxs-lookup"><span data-stu-id="8938c-143">At the end of the previous tests, both gates are closed, and the water level is set to low.</span></span> <span data-ttu-id="8938c-144">新增測試以嘗試開啟上層閘道：</span><span class="sxs-lookup"><span data-stu-id="8938c-144">Add a test to try opening the upper gate:</span></span>

:::code language="csharp" source="snippets/pattern-objects/Program.cs" ID="HighGateSafetyTest":::

<span data-ttu-id="8938c-145">此測試失敗，因為閘道開啟。</span><span class="sxs-lookup"><span data-stu-id="8938c-145">This test fails because the gate opens.</span></span> <span data-ttu-id="8938c-146">在第一次執行時，您可以使用下列程式碼來修正此問題：</span><span class="sxs-lookup"><span data-stu-id="8938c-146">As a first implementation, you could fix it with the following code:</span></span>

:::code language="csharp" source="snippets/pattern-objects/InterimSteps.cs" ID="SecondImplementation":::

<span data-ttu-id="8938c-147">您的測試通過。</span><span class="sxs-lookup"><span data-stu-id="8938c-147">Your tests pass.</span></span> <span data-ttu-id="8938c-148">但是，當您新增更多測試時，將會新增更多和更多的 `if` 子句，並測試不同的屬性。</span><span class="sxs-lookup"><span data-stu-id="8938c-148">But, as you add more tests, you'll add more and more `if` clauses and test different properties.</span></span> <span data-ttu-id="8938c-149">當您新增更多條件時，這些方法很快就會變得太複雜。</span><span class="sxs-lookup"><span data-stu-id="8938c-149">Soon, these methods will get too complicated as you add more conditionals.</span></span>

## <a name="implement-the-commands-with-patterns"></a><span data-ttu-id="8938c-150">使用模式來執行命令</span><span class="sxs-lookup"><span data-stu-id="8938c-150">Implement the commands with patterns</span></span>

<span data-ttu-id="8938c-151">更好的方法是使用 *模式* 來判斷物件是否處於有效的狀態，以執行命令。</span><span class="sxs-lookup"><span data-stu-id="8938c-151">A better way is to use *patterns* to determine if the object is in a valid state to execute a command.</span></span> <span data-ttu-id="8938c-152">您可以表達是否允許命令為三個變數的函式：閘道的狀態、水的等級，以及新的設定：</span><span class="sxs-lookup"><span data-stu-id="8938c-152">You can express if a command is allowed as a function of three variables: the state of the gate, the level of the water, and the new setting:</span></span>

| <span data-ttu-id="8938c-153">新增設定</span><span class="sxs-lookup"><span data-stu-id="8938c-153">New setting</span></span> | <span data-ttu-id="8938c-154">閘道狀態</span><span class="sxs-lookup"><span data-stu-id="8938c-154">Gate state</span></span> | <span data-ttu-id="8938c-155">水等級</span><span class="sxs-lookup"><span data-stu-id="8938c-155">Water Level</span></span> | <span data-ttu-id="8938c-156">結果</span><span class="sxs-lookup"><span data-stu-id="8938c-156">Result</span></span>             |
| ----------- | ---------- | ----------- | ------------------ |
| <span data-ttu-id="8938c-157">關閉</span><span class="sxs-lookup"><span data-stu-id="8938c-157">Closed</span></span>      | <span data-ttu-id="8938c-158">關閉</span><span class="sxs-lookup"><span data-stu-id="8938c-158">Closed</span></span>     | <span data-ttu-id="8938c-159">高</span><span class="sxs-lookup"><span data-stu-id="8938c-159">High</span></span>        | <span data-ttu-id="8938c-160">關閉</span><span class="sxs-lookup"><span data-stu-id="8938c-160">Closed</span></span>             |
| <span data-ttu-id="8938c-161">關閉</span><span class="sxs-lookup"><span data-stu-id="8938c-161">Closed</span></span>      | <span data-ttu-id="8938c-162">關閉</span><span class="sxs-lookup"><span data-stu-id="8938c-162">Closed</span></span>     | <span data-ttu-id="8938c-163">低</span><span class="sxs-lookup"><span data-stu-id="8938c-163">Low</span></span>         | <span data-ttu-id="8938c-164">關閉</span><span class="sxs-lookup"><span data-stu-id="8938c-164">Closed</span></span>             |
| <span data-ttu-id="8938c-165">關閉</span><span class="sxs-lookup"><span data-stu-id="8938c-165">Closed</span></span>      | <span data-ttu-id="8938c-166">開啟</span><span class="sxs-lookup"><span data-stu-id="8938c-166">Open</span></span>       | <span data-ttu-id="8938c-167">高</span><span class="sxs-lookup"><span data-stu-id="8938c-167">High</span></span>        | <span data-ttu-id="8938c-168">開啟</span><span class="sxs-lookup"><span data-stu-id="8938c-168">Open</span></span>               |
| <span data-ttu-id="8938c-169">~~已關閉~~</span><span class="sxs-lookup"><span data-stu-id="8938c-169">~~Closed~~</span></span>  | <span data-ttu-id="8938c-170">~~開啟~~</span><span class="sxs-lookup"><span data-stu-id="8938c-170">~~Open~~</span></span>   | <span data-ttu-id="8938c-171">~~低~~</span><span class="sxs-lookup"><span data-stu-id="8938c-171">~~Low~~</span></span>     | <span data-ttu-id="8938c-172">~~已關閉~~</span><span class="sxs-lookup"><span data-stu-id="8938c-172">~~Closed~~</span></span>         |
| <span data-ttu-id="8938c-173">開啟</span><span class="sxs-lookup"><span data-stu-id="8938c-173">Open</span></span>        | <span data-ttu-id="8938c-174">已關閉</span><span class="sxs-lookup"><span data-stu-id="8938c-174">Closed</span></span>     | <span data-ttu-id="8938c-175">高</span><span class="sxs-lookup"><span data-stu-id="8938c-175">High</span></span>        | <span data-ttu-id="8938c-176">開啟</span><span class="sxs-lookup"><span data-stu-id="8938c-176">Open</span></span>               |
| <span data-ttu-id="8938c-177">開啟</span><span class="sxs-lookup"><span data-stu-id="8938c-177">Open</span></span>        | <span data-ttu-id="8938c-178">已關閉</span><span class="sxs-lookup"><span data-stu-id="8938c-178">Closed</span></span>     | <span data-ttu-id="8938c-179">低</span><span class="sxs-lookup"><span data-stu-id="8938c-179">Low</span></span>         | <span data-ttu-id="8938c-180">關閉 (錯誤) </span><span class="sxs-lookup"><span data-stu-id="8938c-180">Closed (Error)</span></span>     |
| <span data-ttu-id="8938c-181">開啟</span><span class="sxs-lookup"><span data-stu-id="8938c-181">Open</span></span>        | <span data-ttu-id="8938c-182">開啟</span><span class="sxs-lookup"><span data-stu-id="8938c-182">Open</span></span>       | <span data-ttu-id="8938c-183">高</span><span class="sxs-lookup"><span data-stu-id="8938c-183">High</span></span>        | <span data-ttu-id="8938c-184">開啟</span><span class="sxs-lookup"><span data-stu-id="8938c-184">Open</span></span>               |
| <span data-ttu-id="8938c-185">~~開啟~~</span><span class="sxs-lookup"><span data-stu-id="8938c-185">~~Open~~</span></span>    | <span data-ttu-id="8938c-186">~~開啟~~</span><span class="sxs-lookup"><span data-stu-id="8938c-186">~~Open~~</span></span>   | <span data-ttu-id="8938c-187">~~低~~</span><span class="sxs-lookup"><span data-stu-id="8938c-187">~~Low~~</span></span>     | <span data-ttu-id="8938c-188">~~關閉 (錯誤) ~~</span><span class="sxs-lookup"><span data-stu-id="8938c-188">~~Closed (Error)~~</span></span> |

<span data-ttu-id="8938c-189">資料表中的第四個數據列和最後一個資料列的文字是不正確。</span><span class="sxs-lookup"><span data-stu-id="8938c-189">The fourth and last rows in the table have strike through text because they're invalid.</span></span> <span data-ttu-id="8938c-190">現在您要加入的程式碼應該要確定當水偏低時，不會開啟高水位閘道。</span><span class="sxs-lookup"><span data-stu-id="8938c-190">The code you're adding now should make sure the high water gate is never opened when the water is low.</span></span>  <span data-ttu-id="8938c-191">您可以將這些狀態編碼為單一 switch 運算式 (記得表示「 `false` 已關閉」 ) ：</span><span class="sxs-lookup"><span data-stu-id="8938c-191">Those states can be coded as a single switch expression (remember that `false` indicates "Closed"):</span></span>

:::code language="csharp" source="snippets/pattern-objects/InterimSteps.cs" ID="ThirdImplementation":::

<span data-ttu-id="8938c-192">請嘗試此版本。</span><span class="sxs-lookup"><span data-stu-id="8938c-192">Try this version.</span></span> <span data-ttu-id="8938c-193">您的測試會通過，並驗證程式代碼。</span><span class="sxs-lookup"><span data-stu-id="8938c-193">Your tests pass, validating the code.</span></span> <span data-ttu-id="8938c-194">完整的表格會顯示輸入和結果的可能組合。</span><span class="sxs-lookup"><span data-stu-id="8938c-194">The full table shows the possible combinations of inputs and results.</span></span> <span data-ttu-id="8938c-195">這表示您和其他開發人員可以快速查看表格，並看到您已涵蓋所有可能的輸入。</span><span class="sxs-lookup"><span data-stu-id="8938c-195">That means you and other developers can quickly look at the table and see that you've covered all the possible inputs.</span></span> <span data-ttu-id="8938c-196">更簡單的一點是，編譯器也可以提供協助。</span><span class="sxs-lookup"><span data-stu-id="8938c-196">Even easier, the compiler can help as well.</span></span> <span data-ttu-id="8938c-197">加入先前的程式碼之後，您可以看到編譯器產生警告： *CS8524* 指出 switch 運算式未涵蓋所有可能的輸入。</span><span class="sxs-lookup"><span data-stu-id="8938c-197">After you add the previous code, you can see that the compiler generates a warning: *CS8524* indicates the switch expression doesn't cover all possible inputs.</span></span> <span data-ttu-id="8938c-198">警告的原因是其中一個輸入是 `enum` 類型。</span><span class="sxs-lookup"><span data-stu-id="8938c-198">The reason for that warning is that one of the inputs is an `enum` type.</span></span> <span data-ttu-id="8938c-199">編譯器會將「所有可能的輸入」解讀為基礎類型的所有輸入，通常是 `int` 。</span><span class="sxs-lookup"><span data-stu-id="8938c-199">The compiler interprets "all possible inputs" as all inputs from the underlying type, typically an `int`.</span></span> <span data-ttu-id="8938c-200">此 `switch` 運算式只會檢查中宣告的值 `enum` 。</span><span class="sxs-lookup"><span data-stu-id="8938c-200">This `switch` expression only checks the values declared in the `enum`.</span></span> <span data-ttu-id="8938c-201">若要移除警告，您可以為運算式的最後一個 arm 加入 catch 全部捨棄模式。</span><span class="sxs-lookup"><span data-stu-id="8938c-201">To remove the warning, you can add a catch-all discard pattern for the last arm of the expression.</span></span> <span data-ttu-id="8938c-202">此條件會擲回例外狀況，因為它指出不正確輸入：</span><span class="sxs-lookup"><span data-stu-id="8938c-202">This condition throws an exception, because it indicates invalid input:</span></span>

```csharp
_  => throw new InvalidOperationException("Invalid internal state"),
```

<span data-ttu-id="8938c-203">先前的 switch arm 必須是運算式中的最後一個參數， `switch` 因為它符合所有輸入。</span><span class="sxs-lookup"><span data-stu-id="8938c-203">The preceding switch arm must be last in your `switch` expression because it matches all inputs.</span></span> <span data-ttu-id="8938c-204">依序移至先前的順序來進行實驗。</span><span class="sxs-lookup"><span data-stu-id="8938c-204">Experiment by moving it earlier in the order.</span></span> <span data-ttu-id="8938c-205">這會導致編譯器錯誤 *CS8510* 模式中無法連接的程式碼。</span><span class="sxs-lookup"><span data-stu-id="8938c-205">That causes a compiler error *CS8510* for unreachable code in a pattern.</span></span>  <span data-ttu-id="8938c-206">Switch 運算式的自然結構可讓編譯器針對可能的錯誤產生錯誤和警告。</span><span class="sxs-lookup"><span data-stu-id="8938c-206">The natural structure of switch expressions enables the compiler to generate errors and warnings for possible mistakes.</span></span> <span data-ttu-id="8938c-207">編譯器「安全網路」可讓您更輕鬆地以較少的反復專案建立正確的程式碼，並可自由地結合 switch 臂與萬用字元。</span><span class="sxs-lookup"><span data-stu-id="8938c-207">The compiler "safety net" makes it easier for you to create correct code in fewer iterations, and the freedom to combine switch arms with wildcards.</span></span> <span data-ttu-id="8938c-208">如果您的組合導致您未預期的無法連線，則編譯器會發出錯誤，如果您移除需要的 arm，則會發出警告。</span><span class="sxs-lookup"><span data-stu-id="8938c-208">The compiler will issue errors if your combination results in unreachable arms you didn't expect, and warnings if you remove an arm that's needed.</span></span>

<span data-ttu-id="8938c-209">第一項變更是合併命令要關閉閘道的所有 arm;一律允許。</span><span class="sxs-lookup"><span data-stu-id="8938c-209">The first change is to combine all the arms where the command is to close the gate; that's always allowed.</span></span> <span data-ttu-id="8938c-210">將下列程式碼新增為 switch 運算式中的第一個 arm：</span><span class="sxs-lookup"><span data-stu-id="8938c-210">Add the following code as the first arm in your switch expression:</span></span>

```csharp
(false, _, _) => false,
```

<span data-ttu-id="8938c-211">在您新增先前的交換器 arm 之後，您將會收到四個編譯器錯誤，命令的每個 arm 各有一個錯誤 `false` 。</span><span class="sxs-lookup"><span data-stu-id="8938c-211">After you add the previous switch arm, you'll get four compiler errors, one on each of the arms where the command is `false`.</span></span> <span data-ttu-id="8938c-212">剛新增的 arm 已涵蓋這些 arm。</span><span class="sxs-lookup"><span data-stu-id="8938c-212">Those arms are already covered by the newly added arm.</span></span> <span data-ttu-id="8938c-213">您可以安全地移除這四行。</span><span class="sxs-lookup"><span data-stu-id="8938c-213">You can safely remove those four lines.</span></span> <span data-ttu-id="8938c-214">您打算這個新的交換器 arm 來取代這些條件。</span><span class="sxs-lookup"><span data-stu-id="8938c-214">You intended this new switch arm to replace those conditions.</span></span>

<span data-ttu-id="8938c-215">接下來，您可以簡化這四個 arm，命令是用來開啟閘道。</span><span class="sxs-lookup"><span data-stu-id="8938c-215">Next, you can simplify the four arms where the command is to open the gate.</span></span> <span data-ttu-id="8938c-216">在這兩種情況下，您可以開啟閘道。</span><span class="sxs-lookup"><span data-stu-id="8938c-216">In both cases where the water level is high, the gate can be opened.</span></span> <span data-ttu-id="8938c-217"> (其中一個已開啟 ) 。當水等級為低的情況下，會擲回例外狀況，而另一種情況則不應發生。</span><span class="sxs-lookup"><span data-stu-id="8938c-217">(In one, it's already open.) One case where the water level is low throws an exception, and the other shouldn't happen.</span></span> <span data-ttu-id="8938c-218">如果水位鎖已處於無效狀態，則應該安全地擲回相同的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="8938c-218">It should be safe to throw the same exception if the water lock is already in an invalid state.</span></span> <span data-ttu-id="8938c-219">您可以針對這些 arm 進行下列簡化：</span><span class="sxs-lookup"><span data-stu-id="8938c-219">You can make the following simplifications for those arms:</span></span>

```csharp
(true, _, WaterLevel.High) => true,
(true, false, WaterLevel.Low) => throw new InvalidOperationException("Cannot open high gate when the water is low"),
_ => throw new InvalidOperationException("Invalid internal state"),
```

<span data-ttu-id="8938c-220">再次執行您的測試，並通過測試。</span><span class="sxs-lookup"><span data-stu-id="8938c-220">Run your tests again, and they pass.</span></span> <span data-ttu-id="8938c-221">以下是方法的最終版本 `SetHighGate` ：</span><span class="sxs-lookup"><span data-stu-id="8938c-221">Here's the final version of the `SetHighGate` method:</span></span>

:::code language="csharp" source="snippets/pattern-objects/CanalLock.cs" ID="FinalImplementaton":::

## <a name="implement-patterns-yourself"></a><span data-ttu-id="8938c-222">自行執行模式</span><span class="sxs-lookup"><span data-stu-id="8938c-222">Implement patterns yourself</span></span>

<span data-ttu-id="8938c-223">現在您已瞭解此技巧，請 `SetLowGate` 自行填入和 `SetWaterLevel` 方法。</span><span class="sxs-lookup"><span data-stu-id="8938c-223">Now that you've seen the technique, fill in the `SetLowGate` and `SetWaterLevel` methods yourself.</span></span>  <span data-ttu-id="8938c-224">首先，新增下列程式碼來測試這些方法的無效作業：</span><span class="sxs-lookup"><span data-stu-id="8938c-224">Start by adding the following code to test invalid operations on those methods:</span></span>

:::code language="csharp" source="snippets/pattern-objects/Program.cs" ID="FinalTestCode":::

<span data-ttu-id="8938c-225">重新執行您的應用程式。</span><span class="sxs-lookup"><span data-stu-id="8938c-225">Run your application again.</span></span> <span data-ttu-id="8938c-226">您可以看到新的測試失敗，而且 canal 鎖定會進入不正確狀態。</span><span class="sxs-lookup"><span data-stu-id="8938c-226">You can see the new tests fail, and the canal lock gets into an invalid state.</span></span> <span data-ttu-id="8938c-227">嘗試自行執行其餘的方法。</span><span class="sxs-lookup"><span data-stu-id="8938c-227">Try to implement the remaining methods yourself.</span></span> <span data-ttu-id="8938c-228">設定下層閘道的方法應該類似于設定上層閘道的方法。</span><span class="sxs-lookup"><span data-stu-id="8938c-228">The method to set the lower gate should be similar to the method to set the upper gate.</span></span> <span data-ttu-id="8938c-229">變更水層級的方法具有不同的檢查，但應遵循類似的結構。</span><span class="sxs-lookup"><span data-stu-id="8938c-229">The method that changes the water level has different checks, but should follow a similar structure.</span></span> <span data-ttu-id="8938c-230">您可能會發現對設定水層級的方法使用相同的程式很有用。</span><span class="sxs-lookup"><span data-stu-id="8938c-230">You may find it helpful to use the same process for the method that sets the water level.</span></span> <span data-ttu-id="8938c-231">從四個輸入開始：兩個閘道的狀態、水線層級的目前狀態，以及要求的新水等級。</span><span class="sxs-lookup"><span data-stu-id="8938c-231">Start with all four inputs: The state of both gates, the current state of the water level, and the requested new water level.</span></span> <span data-ttu-id="8938c-232">Switch 運算式的開頭應該是：</span><span class="sxs-lookup"><span data-stu-id="8938c-232">The switch expression should start with:</span></span>

```csharp
CanalLockWaterLevel = (newLevel, CanalLockWaterLevel, LowWaterGateOpen, HighWaterGateOpen) switch
{
    // elided
};
```

<span data-ttu-id="8938c-233">您將有16個切換 arm 來填寫。</span><span class="sxs-lookup"><span data-stu-id="8938c-233">You'll have 16 total switch arms to fill in.</span></span> <span data-ttu-id="8938c-234">然後，測試並簡化。</span><span class="sxs-lookup"><span data-stu-id="8938c-234">Then, test and simplify.</span></span>

<span data-ttu-id="8938c-235">您是否有像這樣的方法？</span><span class="sxs-lookup"><span data-stu-id="8938c-235">Did you make methods something like this?</span></span>

:::code language="csharp" source="snippets/pattern-objects/CanalLock.cs" ID="FinalExercise":::

<span data-ttu-id="8938c-236">您的測試應該會通過，而且 canal 鎖定應該安全地運作。</span><span class="sxs-lookup"><span data-stu-id="8938c-236">Your tests should pass, and the canal lock should operate safely.</span></span>

## <a name="summary"></a><span data-ttu-id="8938c-237">摘要</span><span class="sxs-lookup"><span data-stu-id="8938c-237">Summary</span></span>

<span data-ttu-id="8938c-238">在本教學課程中，您已瞭解如何使用模式比對來檢查物件的內部狀態，然後再將任何變更套用至該狀態。</span><span class="sxs-lookup"><span data-stu-id="8938c-238">In this tutorial, you learned to use pattern matching to check the internal state of an object before applying any changes to that state.</span></span> <span data-ttu-id="8938c-239">您可以檢查屬性的組合。</span><span class="sxs-lookup"><span data-stu-id="8938c-239">You can check combinations of properties.</span></span> <span data-ttu-id="8938c-240">一旦為這些轉換建立資料表之後，您就可以測試程式碼，然後簡化可讀性和維護性。</span><span class="sxs-lookup"><span data-stu-id="8938c-240">Once you've built tables for any of those transitions, you test your code, then simplify for readability and maintainability.</span></span> <span data-ttu-id="8938c-241">這些初始重構可能會建議進一步的重構，以驗證內部狀態或管理其他 API 變更。</span><span class="sxs-lookup"><span data-stu-id="8938c-241">These initial refactorings may suggest further refactorings that validate internal state or manage other API changes.</span></span> <span data-ttu-id="8938c-242">本教學課程結合了類別和物件與以資料為導向，以模式為基礎的方法來執行這些類別。</span><span class="sxs-lookup"><span data-stu-id="8938c-242">This tutorial combined classes and objects with a more data-oriented, pattern-based approach to implement those classes.</span></span>
