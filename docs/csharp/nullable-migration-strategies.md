---
title: 更新您的程式碼基底以使用可為 null 的參考型別
description: 選擇升級程式碼基底的最佳策略，以使用可為 null 的參考型別。
ms.technology: csharp-null-safety
ms.date: 07/31/2019
ms.openlocfilehash: ab0970247c7e3f3c20d7fdb40ef035c4ba1d8b01
ms.sourcegitcommit: 30e9e11dfd90112b8eec6406186ba3533f21eba1
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 11/21/2020
ms.locfileid: "95099323"
---
# <a name="update-libraries-to-use-nullable-reference-types-and-communicate-nullable-rules-to-callers"></a>更新程式庫以使用可為 null 的參考型別，並將可為 null 的規則傳達給

加入 [可為 null 的參考](nullable-references.md) 型別，表示您可以宣告 `null` 每個變數的值是允許或預期的。 此外，您可以套用數個屬性： `AllowNull` 、 `DisallowNull` 、 `MaybeNull` 、、、 `NotNull` `NotNullWhen` 和， `MaybeNullWhen` `NotNullIfNotNull` 以完整描述引數和傳回值的 null 狀態。 這可在您撰寫程式碼時提供絕佳的體驗。 如果不可為 null 的變數可能設定為，就會收到警告 `null` 。 如果可為 null 的變數在進行取值之前，不是以 null 檢查，您會收到警告。 更新您的程式庫可能需要一些時間，但回報值得一提。 您提供給編譯器的詳細資訊是在 *when* `null` 允許或禁止某個值時，您的 API 使用者將會得到更好的警告。 讓我們從熟悉的範例開始。 假設您的程式庫有下列 API 可取得資源字串：

```csharp
bool TryGetMessage(string key, out string message)
```

上述範例會遵循 `Try*` .net 中熟悉的模式。 此 API 有兩個參考引數： `key` 和 `message` 參數。 此 API 具有下列與這些引數 null f.23 相關的規則：

- 呼叫端不應該傳遞 `null` 做為的引數 `key` 。
- 呼叫端可以傳遞變數，其值為 `null` 的引數 `message` 。
- 如果 `TryGetMessage` 方法傳回 `true` ，的值 `message` 不是 null。 如果傳回值是 `false,` (的值 `message` ，且其 null 狀態) 為 null。

的規則 `key` 可以完全以變數類型表示： `key` 應為不可為 null 的參考型別。 `message`參數較為複雜。 它可 `null` 做為引數，但保證在成功時，該 `out` 引數不是 null。 在這些情況下，您需要更豐富的詞彙來描述期望。

針對可為 null 的參考更新您的程式庫， `?` 在某些變數和類型名稱上需要隨處揮灑 threadpool.queueuserworkitem 以上的部分。 上述範例顯示您需要檢查您的 Api，並考慮每個輸入引數的預期。 請考慮傳回值的保證，以及方法傳回 `out` 時的任何或 `ref` 引數。 然後，將這些規則傳達給編譯器，而當呼叫端不遵守這些規則時，編譯器將會提供警告。

此工作需要一些時間。 讓我們從策略開始，讓您的程式庫或應用程式成為可為 null 感知，同時平衡其他需求。 您將瞭解如何平衡進行中的開發啟用可為 null 的參考型別。 您將瞭解泛型型別定義的挑戰。 您將瞭解如何套用屬性來描述個別 Api 的前置和後置條件。

## <a name="choose-a-strategy-for-nullable-reference-types"></a>選擇可為 null 的參考型別策略

第一個選擇是可為 null 的參考型別預設為開啟或關閉。 您有兩個策略：

- 針對整個專案啟用可為 null 的參考型別，並在尚未就緒的程式碼中加以停用。
- 針對已針對可為 null 的參考型別進行批註的程式碼，只啟用可為 null 的參考型別。

當您針對可為 null 的參考型別更新時，第一種策略的效果最好是將其他功能新增至程式庫。 所有新的開發都可為 null 感知。 當您更新現有的程式碼時，會在這些類別中啟用可為 null 的參考型別。

遵循第一個策略之後，您可以執行下列步驟：

1. 將專案新增至 .csproj 檔案，以啟用整個專案的可為 null 參考型別 `<Nullable>enable</Nullable>` 。 *csproj*
1. 將 `#nullable disable` pragma 新增至專案中的每個原始程式檔。
1. 當您處理每個檔案時，請移除 pragma 並解決任何警告。

第一個策略是將 pragma 新增到每個檔案的前幾個工作。 優點是每個新增至專案的新程式碼檔案都可為 null 啟用。 任何新工作都可為 null 感知;只有現有的程式碼必須更新。

如果程式庫是穩定的，第二個策略的運作效果最好，而開發的主要重點是採用可為 null 的參考型別。 當您標注 Api 時，會開啟可為 null 的參考型別。 當您完成時，您會為整個專案啟用可為 null 的參考型別。

遵循第二個策略，您可以執行下列步驟：

1. 將 `#nullable enable` pragma 新增至您想要成為可為 null 感知的檔案。
1. 解決任何警告。
1. 繼續執行前兩個步驟，直到整個程式庫都可供 null 感知。
1. 將專案新增至 .csproj 檔案，以啟用整個專案的可為 null 類型 `<Nullable>enable</Nullable>` 。 *csproj*
1. 移除 `#nullable enable` pragma，因為它們已經不再需要。

第二個策略的工作量較低。 缺點是，當您建立新檔案時，第一個工作是新增 pragma 並讓它成為可為 null 的感知。 如果您的小組有任何開發人員忘記，則新的程式碼現在會在工作待處理專案中，讓所有程式碼都可為 null 感知。

您選擇哪一種策略，取決於您的專案中正在進行的開發中活動量。 更成熟且穩定的專案，第二個策略愈好。 開發的功能愈多，第一種策略就越好。

> [!IMPORTANT]
> 全域可為 null 的內容不適用於產生的程式碼檔案。 在任一策略下，任何標示為已產生的原始程式檔都會 *停用* 可為 null 的內容。 這表示產生的檔案中的任何 Api 都不會加上批註。 有四種方式可將檔案標示為已產生：
>
> 1. 在 editorconfig 中，指定 `generated_code = true` 套用至該檔案的區段。
> 1. 在 `<auto-generated>` 檔案 `<auto-generated/>` 頂端的批註中放入或。 它可以位於批註中的任何一行，但批註區塊必須是檔案中的第一個元素。
> 1. 使用 *TemporaryGeneratedFile_* 開始檔案名
> 1. 以 *. designer.cs*、 *. generated.cs*、 *. g.cs* 或 *g.i.cs* 的檔案名結尾。
>
> 產生器可以使用預處理器指示詞來加入宣告 [`#nullable`](language-reference/preprocessor-directives/preprocessor-nullable.md) 。

## <a name="should-nullable-warnings-introduce-breaking-changes"></a>是否應該有可為 null 的警告會導致中斷性變更？

在您啟用可為 null 的參考型別之前，變數會被視為 *可為 null 的無警示*。 一旦您啟用可為 null 的參考型別，這些變數都不能 *為 null*。 如果這些變數未初始化為非 null 值，則編譯器會發出警告。

另一個可能的警告來源是值未初始化時的傳回值。

解決編譯器警告的第一步，是在參數和傳回型別 `?` 上使用注釋，指出引數或傳回值可能是 null。 當參考變數不可以是 null 時，原始宣告是正確的。 當您進行這項工作時，您的目標並不只是為了修正警告。 更重要的目標是讓編譯器瞭解潛在 null 值的意圖。 當您檢查警告時，就會到達您的程式庫的下一個主要決策。 您是否要考慮修改 API 簽章，以更清楚地傳達您的設計意圖？ 稍早檢查過的方法的 API 簽章 `TryGetMessage` 可能是：

```csharp
string? TryGetMessage(string key);
```

傳回值表示成功或失敗，如果找到值，則會攜帶值。 在許多情況下，變更 API 簽章可以改善它們傳達 null 值的方式。

不過，對於公用程式庫或具有大型使用者群的程式庫，您可能不會想要引入任何 API 簽章變更。 針對這些案例和其他常見的模式，您可以套用屬性，以便在引數或傳回值可能時更清楚地定義 `null` 。 無論您是否考慮變更您的 API 介面，您可能會發現單獨的型別批註無法用來描述 `null` 引數或傳回值的值。 在這些情況下，您可以套用屬性來更清楚地描述 API。

## <a name="attributes-extend-type-annotations"></a>屬性延伸類型注釋

已加入數個屬性，以表達變數 null 狀態的其他相關資訊。 您在 c # 8 之前撰寫的所有程式碼都是 null 的參考型別 *無警示*。 這表示任何參考型別變數可能是 null，但不需要 null 檢查。 當您的程式碼 *可為 null 感知* 時，這些規則就會變更。 參考型別絕對不應該是 `null` 值，而且必須先檢查可為 null 的參考型別， `null` 再進行取值。

您的 Api 規則可能更複雜，如您在 API 案例中所見 `TryGetValue` 。 許多 Api 都有更複雜的規則，可供變數或無法使用 `null` 。 在這些情況下，您將使用屬性來表示這些規則。 描述 API 語義的屬性可在文章中找到 [影響可為 null 分析的屬性](./language-reference/attributes/nullable-analysis.md)。

## <a name="generic-definitions-and-nullability"></a>泛型定義和 null 屬性

正確地傳達泛型型別和泛型方法的 null 狀態，需要特別注意。 從可為 null 的實值型別與可為 null 的參考型別，到本質上是不同的。 `int?`是的同義字 `Nullable<int>` ，而 `string?` 是 `string` 由編譯器所加入的屬性。 結果是，編譯器無法產生正確的程式碼， `T?` 而不知道是否 `T` 為 `class` 或 `struct` 。

這種事實並不表示您無法使用可為 null 的型別 (實值型別或參考型別) 做為封閉式泛型型別的型別引數。 `List<string?>`和 `List<int?>` 都是的有效具現化 `List<T>` 。

它的意思是，您不能 `T?` 在沒有條件約束的泛型類別或方法宣告中使用。 例如， <xref:System.Linq.Enumerable.FirstOrDefault%60%601(System.Collections.Generic.IEnumerable%7B%60%600%7D)?displayProperty=nameWithType> 不會變更為 return `T?` 。 您可以藉由新增 `struct` 或條件約束來克服這項限制 `class` 。 使用上述任一條件約束時，編譯器就知道如何為和產生程式 `T` 代碼 `T?` 。

您可能會想要將用於泛型型別引數的類型限制為不可為 null 的類型。 您可以藉由在 `notnull` 該型別引數加入條件約束來這麼做。 套用該條件約束時，型別引數不能是可為 null 的型別。

## <a name="late-initialized-properties-data-transfer-objects-and-nullability"></a>延遲初始化的屬性、資料傳輸物件和 null 屬性

指出已延遲初始化之屬性的可 null 性（表示在結構化之後設定），可能需要特別考慮，以確保您的類別會繼續正確表達原始設計意圖。

包含晚期初始化屬性的類型（例如 (Dto) 的資料傳輸物件）通常是由外部程式庫具現化，例如資料庫 ORM (物件關聯式對應程式) 、還原序列化程式，或從另一個來源自動填入屬性的其他元件。

在啟用可為 null 的參考型別之前，請先考慮下列 DTO 類別，以代表學生：

```csharp
class Student
{
    [Required]
    public string FirstName { get; set; }

    [Required]
    public string LastName { get; set; }

    public string VehicleRegistration { get; set; }
}
```

設計意圖 (在此案例中以屬性工作表示 `Required`) 建議在此系統中， `FirstName` 和 `LastName` 屬性是 **強制性** 的，因此不是 null。

`VehicleRegistration`屬性不是 **強制性** 的，因此可能是 null。

當您啟用可為 null 的參考型別時，您想要指出您的 DTO 上的哪些屬性可以是可為 null，與原始意圖一致：

```csharp
class Student
{
    [Required]
    public string FirstName { get; set; }

    [Required]
    public string LastName { get; set; }

    public string? VehicleRegistration { get; set; }
}
```

針對此 DTO，唯一可為 null 的屬性為 ``VehicleRegistration`` 。

不過，編譯器 `CS8618` 會針對和引發警告 `FirstName` `LastName` ，指出不可為 null 的屬性未初始化。

有三個選項可供您解決編譯器警告，方法是維護原始意圖。 任何這些選項都是有效的;您應該選擇最適合您的程式碼樣式和設計需求的應用程式。

### <a name="initialize-in-the-constructor"></a>在函式中初始化

解決未初始化之警告的理想方式，就是初始化函式中的屬性：

```csharp
class Student
{
    public Student(string firstName, string lastName)
    {
        FirstName = firstName;
        LastName = lastName;
    }

    [Required]
    public string FirstName { get; set; }

    [Required]
    public string LastName { get; set; }

    public string? VehicleRegistration { get; set; }
}
```

只有當您用來具現化類別的程式庫支援在函式中傳遞參數時，此方法才適用。

程式庫可能支援在函式中傳遞 *某些* 屬性，但並非全部。 例如，EF Core 支援一般資料行屬性的 [函數](/ef/core/modeling/constructors) 系結，但不支援導覽屬性。

請查看可具現化類別之程式庫的檔，以瞭解它支援的函式系結範圍。

### <a name="property-with-nullable-backing-field"></a>具有可為 null 之支援欄位的屬性

如果您無法使用函式系結，則處理此問題的其中一種方式是讓不可為 null 的屬性具有可為 null 的支援欄位：

```csharp
private string? _firstName;

[Required]
public string FirstName
{
    set => _firstName = value;
    get => _firstName
           ?? throw new InvalidOperationException("Uninitialized " + nameof(FirstName))
}
```

在此案例中，如果在 `FirstName` 初始化之前存取屬性，則程式碼會擲回 `InvalidOperationException` ，因為 API 合約的使用方式不正確。

請考慮在使用支援欄位時，某些程式庫可能會有特殊的考慮。 例如，可能需要將 EF Core 設定為正確使用 [支援欄位](/ef/core/modeling/backing-field) 。

### <a name="initialize-the-property-to-null"></a>將屬性初始化為 null

作為使用可為 null 之支援欄位的 terser 替代方案，或者如果具現化類別的程式庫與該方法不相容，您可以 `null` 使用容許運算子的說明 () 來直接初始化屬性 `!` ：

```csharp
[Required]
public string FirstName { get; set; } = null!;

[Required]
public string LastName { get; set; } = null!;

public string? VehicleRegistration { get; set; }
```

您永遠不會在執行時間觀察到實際的 null 值，因為程式設計錯誤的結果是在正確初始化之前存取屬性。

## <a name="see-also"></a>另請參閱

- [將現有的程式碼基底遷移至可為 Null 參考](tutorials/upgrade-to-nullable-references.md)
- [在 EF Core 中使用可為 Null 的參考型別](/ef/core/miscellaneous/nullable-reference-types)
