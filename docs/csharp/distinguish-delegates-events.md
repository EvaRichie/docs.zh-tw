---
title: 委派與事件的比較
description: 了解委派和事件的差異，以及何時使用 .NET Core 的各項功能。
ms.date: 06/20/2016
ms.technology: csharp-fundamentals
ms.assetid: 0fdc8629-2fdb-4a7c-a433-5b9d04eaf911
ms.openlocfilehash: 193a9b0fe0e0c36deb6552449c92135057412225
ms.sourcegitcommit: b1f4756120deaecb8b554477bb040620f69a4209
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 09/03/2020
ms.locfileid: "89414665"
---
# <a name="distinguishing-delegates-and-events"></a><span data-ttu-id="09b62-103">區別委派和事件</span><span class="sxs-lookup"><span data-stu-id="09b62-103">Distinguishing Delegates and Events</span></span>

<span data-ttu-id="09b62-104">[[上一步]](modern-events.md)</span><span class="sxs-lookup"><span data-stu-id="09b62-104">[Previous](modern-events.md)</span></span>

<span data-ttu-id="09b62-105">決定以 `delegates` 為基礎的設計與以 `events` 為基礎的設計時，不熟悉 .NET Core 平台的開發人員通常十分糾結。</span><span class="sxs-lookup"><span data-stu-id="09b62-105">Developers that are new to the .NET Core platform often struggle when deciding between a design based on `delegates` and a design based on `events`.</span></span> <span data-ttu-id="09b62-106">選擇委派或事件通常很難，因為這兩種語言功能很類似。</span><span class="sxs-lookup"><span data-stu-id="09b62-106">The choice of delegates or events is often difficult, because the two language features are similar.</span></span> <span data-ttu-id="09b62-107">事件甚至是使用委派的語言支援所建置。</span><span class="sxs-lookup"><span data-stu-id="09b62-107">Events are even built using the language support for delegates.</span></span>

<span data-ttu-id="09b62-108">它們都提供晚期繫結案例︰元件透過呼叫只在執行階段才知道的方法來進行通訊。</span><span class="sxs-lookup"><span data-stu-id="09b62-108">They both offer a late binding scenario: they enable scenarios where a component communicates by calling a method that is only known at runtime.</span></span> <span data-ttu-id="09b62-109">兩者都支援單一和多個訂閱者方法。</span><span class="sxs-lookup"><span data-stu-id="09b62-109">They both support single and multiple subscriber methods.</span></span> <span data-ttu-id="09b62-110">您可能會發現這稱為單點傳送和多點傳送支援。</span><span class="sxs-lookup"><span data-stu-id="09b62-110">You may find this referred to as singlecast and multicast support.</span></span> <span data-ttu-id="09b62-111">它們同時支援使用類似的語法來新增和移除處理常式。</span><span class="sxs-lookup"><span data-stu-id="09b62-111">They both support similar syntax for adding and removing handlers.</span></span> <span data-ttu-id="09b62-112">最後，引發事件與呼叫委派會使用完全相同的方法呼叫語法。</span><span class="sxs-lookup"><span data-stu-id="09b62-112">Finally, raising an event and calling a delegate use exactly the same method call syntax.</span></span> <span data-ttu-id="09b62-113">兩者甚至都支援相同的 `Invoke()` 方法語法，以與 `?.` 運算子搭配使用。</span><span class="sxs-lookup"><span data-stu-id="09b62-113">They even both support the same `Invoke()` method syntax for use with the `?.` operator.</span></span>

<span data-ttu-id="09b62-114">具有所有這些相似性時，會很難決定其使用時機。</span><span class="sxs-lookup"><span data-stu-id="09b62-114">With all those similarities, it is easy to have trouble determining when to use which.</span></span>

## <a name="listening-to-events-is-optional"></a><span data-ttu-id="09b62-115">接聽事件為選擇性</span><span class="sxs-lookup"><span data-stu-id="09b62-115">Listening to Events is Optional</span></span>

<span data-ttu-id="09b62-116">決定要使用之語言功能的最重要考量為是否都必須要有附加的訂閱者。</span><span class="sxs-lookup"><span data-stu-id="09b62-116">The most important consideration in determining which language feature to use is whether or not there must be an attached subscriber.</span></span> <span data-ttu-id="09b62-117">如果您的程式碼必須呼叫訂閱者所提供的程式碼，您應該在需要執行回呼時，根據委派使用設計。</span><span class="sxs-lookup"><span data-stu-id="09b62-117">If your code must call the code supplied by the subscriber, you should use a design based on delegates when you need to implement callback.</span></span> <span data-ttu-id="09b62-118">如果您的程式碼可以完成其所有工作，而不需要呼叫任何訂閱者，則應該使用以事件為基礎的設計。</span><span class="sxs-lookup"><span data-stu-id="09b62-118">If your code can complete all its work without calling any subscribers, you should use a design based on events.</span></span>

<span data-ttu-id="09b62-119">請考慮本節期間所建置的範例。</span><span class="sxs-lookup"><span data-stu-id="09b62-119">Consider the examples built during this section.</span></span> <span data-ttu-id="09b62-120">必須將電腦函式提供給您使用 `List.Sort()` 所建置的程式碼，才能適當地排序項目。</span><span class="sxs-lookup"><span data-stu-id="09b62-120">The code you built using `List.Sort()` must be given a comparer function in order to properly sort the elements.</span></span> <span data-ttu-id="09b62-121">必須提供具有委派的 LINQ 查詢，才能判斷要傳回的項目。</span><span class="sxs-lookup"><span data-stu-id="09b62-121">LINQ queries must be supplied with delegates in order to determine what elements to return.</span></span> <span data-ttu-id="09b62-122">兩者都是使用委派所建置的設計。</span><span class="sxs-lookup"><span data-stu-id="09b62-122">Both used a design built with delegates.</span></span>

<span data-ttu-id="09b62-123">請考量 `Progress` 事件。</span><span class="sxs-lookup"><span data-stu-id="09b62-123">Consider the `Progress` event.</span></span> <span data-ttu-id="09b62-124">它會報告工作的進度。</span><span class="sxs-lookup"><span data-stu-id="09b62-124">It reports progress on a task.</span></span>
<span data-ttu-id="09b62-125">不論是否有任何接聽程式，工作都會繼續進行。</span><span class="sxs-lookup"><span data-stu-id="09b62-125">The task continues to proceed whether or not there are any listeners.</span></span>
<span data-ttu-id="09b62-126">`FileSearcher` 是另一個範例。</span><span class="sxs-lookup"><span data-stu-id="09b62-126">The `FileSearcher` is another example.</span></span> <span data-ttu-id="09b62-127">它仍然會搜尋並尋找所有看到的檔案，即使未附加任何事件訂閱者也是一樣。</span><span class="sxs-lookup"><span data-stu-id="09b62-127">It would still search and find all the files that were sought, even with no event subscribers attached.</span></span>
<span data-ttu-id="09b62-128">UX 控制項仍然會正常運作，即使沒有任何訂閱者接聽事件也是一樣。</span><span class="sxs-lookup"><span data-stu-id="09b62-128">UX controls still work correctly, even when there are no subscribers listening to the events.</span></span> <span data-ttu-id="09b62-129">它們都會使用以事件為基礎的設計。</span><span class="sxs-lookup"><span data-stu-id="09b62-129">They both use designs based on events.</span></span>

## <a name="return-values-require-delegates"></a><span data-ttu-id="09b62-130">傳回值需要委派</span><span class="sxs-lookup"><span data-stu-id="09b62-130">Return Values Require Delegates</span></span>

<span data-ttu-id="09b62-131">另一個考量是您要用於委派方法的方法原型。</span><span class="sxs-lookup"><span data-stu-id="09b62-131">Another consideration is the method prototype you would want for your delegate method.</span></span> <span data-ttu-id="09b62-132">如您所見，用於事件的委派都會有 void 傳回型別。</span><span class="sxs-lookup"><span data-stu-id="09b62-132">As you've seen, the delegates used for events all have a void return type.</span></span> <span data-ttu-id="09b62-133">您也已看到有慣用語可建立事件處理常式，以透過修改事件引數物件的屬性，將資訊傳回給事件來源。</span><span class="sxs-lookup"><span data-stu-id="09b62-133">You've also seen that there are idioms to create event handlers that do pass information back to event sources through modifying properties of the event argument object.</span></span> <span data-ttu-id="09b62-134">雖然這些慣用語確實可以運作，但不像從方法傳回值一樣自然。</span><span class="sxs-lookup"><span data-stu-id="09b62-134">While these idioms do work, they are not as natural as returning a value from a method.</span></span>

<span data-ttu-id="09b62-135">請注意，這兩種啟發學習法可能通常都存在︰如果委派方法傳回值，則在某個方面可能會影響演算法。</span><span class="sxs-lookup"><span data-stu-id="09b62-135">Notice that these two heuristics may often both be present: If your delegate method returns a value, it will likely impact the algorithm in some way.</span></span>

## <a name="events-have-private-invocation"></a><span data-ttu-id="09b62-136">事件有私用調用</span><span class="sxs-lookup"><span data-stu-id="09b62-136">Events Have Private Invocation</span></span>

<span data-ttu-id="09b62-137">包含事件的類別不能加入和移除事件接聽項，只有包含事件的類別可以叫用事件。</span><span class="sxs-lookup"><span data-stu-id="09b62-137">Classes other than the one in which an event is contained can only add and remove event listeners; only the class containing the event can invoke the event.</span></span> <span data-ttu-id="09b62-138">事件通常是公用類別成員。</span><span class="sxs-lookup"><span data-stu-id="09b62-138">Events are typically public class members.</span></span>
<span data-ttu-id="09b62-139">相較之下，委派通常會做為參數傳遞，並儲存為私用類別成員（如果全部儲存）。</span><span class="sxs-lookup"><span data-stu-id="09b62-139">By comparison, delegates are often passed as parameters and stored as private class members, if they are stored at all.</span></span>

## <a name="event-listeners-often-have-longer-lifetimes"></a><span data-ttu-id="09b62-140">事件接聽程式通常會有較長的存留期</span><span class="sxs-lookup"><span data-stu-id="09b62-140">Event Listeners Often Have Longer Lifetimes</span></span>

<span data-ttu-id="09b62-141">事件接聽程式的存留期較差。</span><span class="sxs-lookup"><span data-stu-id="09b62-141">That event listeners have longer lifetimes is a slightly weaker justification.</span></span> <span data-ttu-id="09b62-142">不過，事件來源在一段長時間後引發事件時，您可能會發現事件設計更為自然。</span><span class="sxs-lookup"><span data-stu-id="09b62-142">However, you may find that event-based designs are more natural when the event source will be raising events over a long period of time.</span></span> <span data-ttu-id="09b62-143">您可以在許多系統上查看 UX 控制項的事件型設計範例。</span><span class="sxs-lookup"><span data-stu-id="09b62-143">You can see examples of event-based design for UX controls on many systems.</span></span> <span data-ttu-id="09b62-144">訂閱事件之後，事件來源可能會在整個程式存留期引發事件。</span><span class="sxs-lookup"><span data-stu-id="09b62-144">Once you subscribe to an event, the event source may raise events throughout the lifetime of the program.</span></span>
<span data-ttu-id="09b62-145">(不再需要事件時，即可取消與事件的訂閱)。</span><span class="sxs-lookup"><span data-stu-id="09b62-145">(You can unsubscribe from events when you no longer need them.)</span></span>

<span data-ttu-id="09b62-146">與許多委派設計相反，其中使用委派作為方法的引數，而且在該方法傳回之後不會使用委派。</span><span class="sxs-lookup"><span data-stu-id="09b62-146">Contrast that with many delegate-based designs, where a delegate is used as an argument to a method, and the delegate is not used after that method returns.</span></span>

## <a name="evaluate-carefully"></a><span data-ttu-id="09b62-147">仔細評估</span><span class="sxs-lookup"><span data-stu-id="09b62-147">Evaluate Carefully</span></span>

<span data-ttu-id="09b62-148">上述考量不是很難和快速的規則。</span><span class="sxs-lookup"><span data-stu-id="09b62-148">The above considerations are not hard and fast rules.</span></span> <span data-ttu-id="09b62-149">相反地，它們所代表的指引可協助您決定最適合您特定使用方式的選項。</span><span class="sxs-lookup"><span data-stu-id="09b62-149">Instead, they represent guidance that can help you decide which choice is best for your particular usage.</span></span> <span data-ttu-id="09b62-150">因為它們十分類似，所以您甚至可以建立原型，並考慮哪個使用起來更自然。</span><span class="sxs-lookup"><span data-stu-id="09b62-150">Because they are similar, you can even prototype both, and consider which would be more natural to work with.</span></span> <span data-ttu-id="09b62-151">它們也都會處理晚期繫結案例。</span><span class="sxs-lookup"><span data-stu-id="09b62-151">They both handle late binding scenarios well.</span></span> <span data-ttu-id="09b62-152">請使用用來溝通最佳設計的案例。</span><span class="sxs-lookup"><span data-stu-id="09b62-152">Use the one that communicates your design the best.</span></span>
