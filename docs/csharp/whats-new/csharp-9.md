---
title: 'C # 9.0 的新功能-c # 指南'
description: '深入瞭解 c # 9.0 中可用的新功能。'
ms.date: 09/04/2020
ms.openlocfilehash: a863e544c0fcc8682994f49a464acccafc5ce92f
ms.sourcegitcommit: cbacb5d2cebbf044547f6af6e74a9de866800985
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 09/05/2020
ms.locfileid: "89495821"
---
# <a name="whats-new-in-c-90"></a><span data-ttu-id="a675e-103">C # 9.0 的新功能</span><span class="sxs-lookup"><span data-stu-id="a675e-103">What's new in C# 9.0</span></span>

<span data-ttu-id="a675e-104">C # 9.0 將下列功能和增強功能新增至 c # 語言：</span><span class="sxs-lookup"><span data-stu-id="a675e-104">C# 9.0 adds the following features and enhancements to the C# language:</span></span>

- <span data-ttu-id="a675e-105">記錄</span><span class="sxs-lookup"><span data-stu-id="a675e-105">Records</span></span>
- <span data-ttu-id="a675e-106">僅供初始化的 Setter</span><span class="sxs-lookup"><span data-stu-id="a675e-106">Init only setters</span></span>
- <span data-ttu-id="a675e-107">最上層陳述式</span><span class="sxs-lookup"><span data-stu-id="a675e-107">Top-level statements</span></span>
- <span data-ttu-id="a675e-108">模式比對增強功能</span><span class="sxs-lookup"><span data-stu-id="a675e-108">Pattern matching enhancements</span></span>
- <span data-ttu-id="a675e-109">原生大小的整數</span><span class="sxs-lookup"><span data-stu-id="a675e-109">Native sized integers</span></span>
- <span data-ttu-id="a675e-110">函式指標</span><span class="sxs-lookup"><span data-stu-id="a675e-110">Function pointers</span></span>
- <span data-ttu-id="a675e-111">隱藏發出 localsinit 旗標</span><span class="sxs-lookup"><span data-stu-id="a675e-111">Suppress emitting localsinit flag</span></span>
- <span data-ttu-id="a675e-112">目標型別新運算式</span><span class="sxs-lookup"><span data-stu-id="a675e-112">Target-typed new expressions</span></span>
- <span data-ttu-id="a675e-113">靜態匿名函數</span><span class="sxs-lookup"><span data-stu-id="a675e-113">static anonymous functions</span></span>
- <span data-ttu-id="a675e-114">目標型別條件運算式</span><span class="sxs-lookup"><span data-stu-id="a675e-114">Target-typed conditional expressions</span></span>
- <span data-ttu-id="a675e-115">Covariant 傳回類型</span><span class="sxs-lookup"><span data-stu-id="a675e-115">Covariant return types</span></span>
- <span data-ttu-id="a675e-116">Lambda 捨棄參數</span><span class="sxs-lookup"><span data-stu-id="a675e-116">Lambda discard parameters</span></span>
- <span data-ttu-id="a675e-117">區域函式上的屬性</span><span class="sxs-lookup"><span data-stu-id="a675e-117">Attributes on local functions</span></span>
- <span data-ttu-id="a675e-118">模組初始設定式</span><span class="sxs-lookup"><span data-stu-id="a675e-118">Module initializers</span></span>
- <span data-ttu-id="a675e-119">部分方法的新功能</span><span class="sxs-lookup"><span data-stu-id="a675e-119">New features for partial methods</span></span>

<span data-ttu-id="a675e-120">**.Net 5**支援 c # 9.0。</span><span class="sxs-lookup"><span data-stu-id="a675e-120">C# 9.0 is supported on **.NET 5**.</span></span> <span data-ttu-id="a675e-121">如需詳細資訊，請參閱 [c # 語言版本控制](../language-reference/configure-language-version.md)。</span><span class="sxs-lookup"><span data-stu-id="a675e-121">For more information, see [C# language versioning](../language-reference/configure-language-version.md).</span></span>

## <a name="record-types"></a><span data-ttu-id="a675e-122">記錄類型</span><span class="sxs-lookup"><span data-stu-id="a675e-122">Record types</span></span>

<span data-ttu-id="a675e-123">C # 9.0 引進了 ***記錄類型***，這是一種參考型別，可提供合成方法來提供相等的值語義。</span><span class="sxs-lookup"><span data-stu-id="a675e-123">C# 9.0 introduces ***record types***, which are a reference type that provides synthesized methods to provide value semantics for equality.</span></span> <span data-ttu-id="a675e-124">依預設，記錄是不可變的。</span><span class="sxs-lookup"><span data-stu-id="a675e-124">Records are immutable by default.</span></span>

<span data-ttu-id="a675e-125">記錄類型可讓您輕鬆地在 .NET 中建立不可變的參考型別。</span><span class="sxs-lookup"><span data-stu-id="a675e-125">Record types make it easy to create immutable reference types in .NET.</span></span> <span data-ttu-id="a675e-126">在過去，.NET 型別大多分類為參考型別 (包括類別和匿名型別) 和實值型別 (包括結構和元組) 。</span><span class="sxs-lookup"><span data-stu-id="a675e-126">Historically, .NET types are largely classified as reference types (including classes and anonymous types) and value types (including structs and tuples).</span></span> <span data-ttu-id="a675e-127">雖然建議使用可變的實數值型別，但可變動的實值型別通常不會造成錯誤。</span><span class="sxs-lookup"><span data-stu-id="a675e-127">While immutable value types are recommended, mutable value types don’t often introduce errors.</span></span> <span data-ttu-id="a675e-128">實值型別變數會保存值，以便在將實數值型別傳遞給方法時，對原始資料的複本進行變更。</span><span class="sxs-lookup"><span data-stu-id="a675e-128">Value type variables hold the values so changes are made to a copy of the original data when value types are passed to methods.</span></span>

<span data-ttu-id="a675e-129">不可變的參考型別也有許多優點。</span><span class="sxs-lookup"><span data-stu-id="a675e-129">There are many advantages to immutable reference types as well.</span></span> <span data-ttu-id="a675e-130">這些優點在具有共用資料的並行程式中更加明顯。</span><span class="sxs-lookup"><span data-stu-id="a675e-130">These advantages are more pronounced in concurrent programs with shared data.</span></span> <span data-ttu-id="a675e-131">可惜的是，c # 強制您撰寫相當多的額外程式碼來建立不可變的參考型別。</span><span class="sxs-lookup"><span data-stu-id="a675e-131">Unfortunately, C# forced you to write quite a bit of extra code to create immutable reference types.</span></span> <span data-ttu-id="a675e-132">記錄提供使用值語義相等的不可變參考型別的類型宣告。</span><span class="sxs-lookup"><span data-stu-id="a675e-132">Records provide a type declaration for an immutable reference type that uses value semantics for equality.</span></span> <span data-ttu-id="a675e-133">相等和雜湊碼的合成方法會將兩筆記錄視為相等，如果其屬性相等。</span><span class="sxs-lookup"><span data-stu-id="a675e-133">The synthesized methods for equality and hash codes consider two records equal if their properties are all equal.</span></span> <span data-ttu-id="a675e-134">請考慮下列定義：</span><span class="sxs-lookup"><span data-stu-id="a675e-134">Consider this definition:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/RecordsExamples.cs" ID="RecordDefinition":::

<span data-ttu-id="a675e-135">記錄定義 `Person` 會建立包含兩個 readonly 屬性的型別： `FirstName` 和 `LastName` 。</span><span class="sxs-lookup"><span data-stu-id="a675e-135">The record definition creates a `Person` type that contains two readonly properties: `FirstName` and `LastName`.</span></span> <span data-ttu-id="a675e-136">`Person`類型是參考型別。</span><span class="sxs-lookup"><span data-stu-id="a675e-136">The `Person` type is a reference type.</span></span> <span data-ttu-id="a675e-137">如果您看過 IL，它就是一種類別。</span><span class="sxs-lookup"><span data-stu-id="a675e-137">If you looked at the IL, it’s a class.</span></span> <span data-ttu-id="a675e-138">這是不可變的，因為在建立之後，就無法修改任何屬性。</span><span class="sxs-lookup"><span data-stu-id="a675e-138">It’s immutable in that none of the properties can be modified once it's been created.</span></span> <span data-ttu-id="a675e-139">當您定義記錄類型時，編譯器會為您會合成數個其他方法：</span><span class="sxs-lookup"><span data-stu-id="a675e-139">When you define a record type, the compiler synthesizes several other methods for you:</span></span>

- <span data-ttu-id="a675e-140">以值為基礎之相等比較的方法</span><span class="sxs-lookup"><span data-stu-id="a675e-140">Methods for value-based equality comparisons</span></span>
- <span data-ttu-id="a675e-141">覆寫 <xref:System.Object.GetHashCode></span><span class="sxs-lookup"><span data-stu-id="a675e-141">Override for <xref:System.Object.GetHashCode></span></span>
- <span data-ttu-id="a675e-142">複製和複製成員</span><span class="sxs-lookup"><span data-stu-id="a675e-142">Copy and Clone members</span></span>
- <span data-ttu-id="a675e-143">`PrintMembers` 和 <xref:System.Object.ToString></span><span class="sxs-lookup"><span data-stu-id="a675e-143">`PrintMembers` and <xref:System.Object.ToString></span></span>
- <span data-ttu-id="a675e-144">`Deconstruct` 方法</span><span class="sxs-lookup"><span data-stu-id="a675e-144">`Deconstruct` method</span></span>

<span data-ttu-id="a675e-145">記錄支援繼承。</span><span class="sxs-lookup"><span data-stu-id="a675e-145">Records support inheritance.</span></span> <span data-ttu-id="a675e-146">您可以宣告衍生自的新記錄 `Person` ，如下所示：</span><span class="sxs-lookup"><span data-stu-id="a675e-146">You can declare a new record derived from `Person` as follows:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/RecordsExamples.cs" ID="InheritedRecord":::

<span data-ttu-id="a675e-147">您也可以密封記錄以防止進一步的衍生：</span><span class="sxs-lookup"><span data-stu-id="a675e-147">You can also seal records to prevent further derivation:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/RecordsExamples.cs" ID="SealedRecord":::

<span data-ttu-id="a675e-148">編譯器會會合成上述方法的不同版本。</span><span class="sxs-lookup"><span data-stu-id="a675e-148">The compiler synthesizes different versions of the methods above.</span></span> <span data-ttu-id="a675e-149">如果記錄類型是密封的，且直接基類為 object，則方法簽章相依于。</span><span class="sxs-lookup"><span data-stu-id="a675e-149">The method signatures depend on if the record type is sealed and if the direct base class is object.</span></span> <span data-ttu-id="a675e-150">記錄應該具有下列功能：</span><span class="sxs-lookup"><span data-stu-id="a675e-150">Records should have the following capabilities:</span></span>

- <span data-ttu-id="a675e-151">相等是以值為基礎，並且包含類型相符的檢查。</span><span class="sxs-lookup"><span data-stu-id="a675e-151">Equality is value-based, and includes a check that the types match.</span></span> <span data-ttu-id="a675e-152">例如， `Student` `Person` 即使兩筆記錄共用相同的名稱，a 也不能相等。</span><span class="sxs-lookup"><span data-stu-id="a675e-152">For example, a `Student` can't be equal to a `Person`, even if the two records share the same name.</span></span>
- <span data-ttu-id="a675e-153">記錄會為您產生一致的字串表示。</span><span class="sxs-lookup"><span data-stu-id="a675e-153">Records have a consistent string representation generated for you.</span></span>
- <span data-ttu-id="a675e-154">記錄支援複製結構。</span><span class="sxs-lookup"><span data-stu-id="a675e-154">Records support copy construction.</span></span> <span data-ttu-id="a675e-155">正確的複製結構必須包含繼承階層，以及開發人員新增的屬性。</span><span class="sxs-lookup"><span data-stu-id="a675e-155">Correct copy construction must include inheritance hierarchies, and properties added by developers.</span></span>
- <span data-ttu-id="a675e-156">您可以修改記錄以進行複製。</span><span class="sxs-lookup"><span data-stu-id="a675e-156">Records can be copied with modification.</span></span> <span data-ttu-id="a675e-157">這些複製和修改作業支援非破壞性的變化。</span><span class="sxs-lookup"><span data-stu-id="a675e-157">These copy and modify operations supports non-destructive mutation.</span></span>
- <span data-ttu-id="a675e-158">所有記錄都支援解構。</span><span class="sxs-lookup"><span data-stu-id="a675e-158">All records support deconstruction.</span></span>

<span data-ttu-id="a675e-159">除了熟悉的多載 `Equals` 、 `operator ==` 和以外 `operator !=` ，編譯器也會會合成新的 `EqualityContract` 屬性。</span><span class="sxs-lookup"><span data-stu-id="a675e-159">In addition to the familiar `Equals` overloads, `operator ==`, and `operator !=`, the compiler synthesizes a new `EqualityContract` property.</span></span> <span data-ttu-id="a675e-160">屬性 `Type` 會傳回符合記錄類型的物件。</span><span class="sxs-lookup"><span data-stu-id="a675e-160">The property returns a `Type` object that matches the type of the record.</span></span> <span data-ttu-id="a675e-161">如果基底類型為 `object` ，則屬性為 `virtual` 。</span><span class="sxs-lookup"><span data-stu-id="a675e-161">If the base type is `object`, the property is `virtual`.</span></span> <span data-ttu-id="a675e-162">如果基底類型是另一種記錄類型，則此屬性為 `override` 。</span><span class="sxs-lookup"><span data-stu-id="a675e-162">If the base type is another record type, the property is an `override`.</span></span> <span data-ttu-id="a675e-163">如果記錄類型為 `sealed` ，則屬性為 `sealed` 。</span><span class="sxs-lookup"><span data-stu-id="a675e-163">If the record type is `sealed`, the property is `sealed`.</span></span> <span data-ttu-id="a675e-164">合成會 `GetHashCode` 使用 `GetHashCode` 基底類型中宣告的所有屬性和欄位，以及記錄類型。</span><span class="sxs-lookup"><span data-stu-id="a675e-164">The synthesized `GetHashCode` uses the `GetHashCode` from all properties and fields declared in the base type and the record type.</span></span> <span data-ttu-id="a675e-165">這些合成方法會在整個繼承階層架構中強制執行以值為基礎的相等。</span><span class="sxs-lookup"><span data-stu-id="a675e-165">These synthesized methods enforce value-based equality throughout an inheritance hierarchy.</span></span> <span data-ttu-id="a675e-166">這表示 `Student` 永遠不會將永遠視為 `Person` 相同名稱的。</span><span class="sxs-lookup"><span data-stu-id="a675e-166">That means a `Student` will never be considered equal to a `Person` with the same name.</span></span> <span data-ttu-id="a675e-167">這兩筆記錄的類型必須相符，以及在記錄類型中共用的所有屬性都相等。</span><span class="sxs-lookup"><span data-stu-id="a675e-167">The types of the two records must match as well as all properties shared among the record types being equal.</span></span>

<span data-ttu-id="a675e-168">記錄也有合成的函式，以及用來建立複本的「複製」方法。</span><span class="sxs-lookup"><span data-stu-id="a675e-168">Records also have a synthesized constructor and a "clone" method for creating copies.</span></span> <span data-ttu-id="a675e-169">合成的函式有一種記錄類型的引數。</span><span class="sxs-lookup"><span data-stu-id="a675e-169">The synthesized constructor has one argument of the record type.</span></span> <span data-ttu-id="a675e-170">它會針對記錄的所有屬性產生具有相同值的新記錄。</span><span class="sxs-lookup"><span data-stu-id="a675e-170">It produces a new record with the same values for all properties of the record.</span></span> <span data-ttu-id="a675e-171">如果記錄是密封的，則這個函式是私用的，否則會受到保護。</span><span class="sxs-lookup"><span data-stu-id="a675e-171">This constructor is private if the record is sealed, otherwise it's protected.</span></span> <span data-ttu-id="a675e-172">合成的 "clone" 方法支援記錄階層的複製結構。</span><span class="sxs-lookup"><span data-stu-id="a675e-172">The synthesized "clone" method supports copy construction for record hierarchies.</span></span> <span data-ttu-id="a675e-173">「Clone」一詞是以引號括住，因為實際名稱是編譯器產生的。</span><span class="sxs-lookup"><span data-stu-id="a675e-173">The term "clone" is in quotes because the actual name is compiler generated.</span></span> <span data-ttu-id="a675e-174">您無法 `Clone` 在記錄類型中建立名為的方法。</span><span class="sxs-lookup"><span data-stu-id="a675e-174">You can't create a method named `Clone` in a record type.</span></span> <span data-ttu-id="a675e-175">合成的 "clone" 方法會傳回使用虛擬分派複製的記錄類型。</span><span class="sxs-lookup"><span data-stu-id="a675e-175">The synthesized "clone" method returns the type of record being copied using virtual dispatch.</span></span> <span data-ttu-id="a675e-176">編譯器會根據上的存取修飾詞，為 "clone" 方法新增不同的修飾詞 `record` ：</span><span class="sxs-lookup"><span data-stu-id="a675e-176">The compiler adds different modifiers for the "clone" method depending on the access modifiers on the `record`:</span></span>

- <span data-ttu-id="a675e-177">如果記錄類型為，則「 `abstract` 複製」方法也是 `abstract` 。</span><span class="sxs-lookup"><span data-stu-id="a675e-177">If the record type is `abstract`, the "clone" method is also `abstract`.</span></span> <span data-ttu-id="a675e-178">如果基底類型不 `object` 是，則方法也是 `override` 。</span><span class="sxs-lookup"><span data-stu-id="a675e-178">If the base type isn't `object`, the method is also `override`.</span></span>
- <span data-ttu-id="a675e-179">針對不是 `abstract` 基底類型為下列情況的記錄類型 `object` ：</span><span class="sxs-lookup"><span data-stu-id="a675e-179">For record types that aren't `abstract` when the base type is `object`:</span></span>
  - <span data-ttu-id="a675e-180">如果記錄是，則不會 `sealed` 將其他修飾詞新增至「複製」方法 (這表示不會 `virtual`) 。</span><span class="sxs-lookup"><span data-stu-id="a675e-180">If the record is `sealed`, no additional modifiers are added to the "clone" method (meaning it is not `virtual`).</span></span>
  - <span data-ttu-id="a675e-181">如果記錄不是 `sealed` ，則「複製」方法是 `virtual` 。</span><span class="sxs-lookup"><span data-stu-id="a675e-181">If the record isn't `sealed`, the "clone" method is `virtual`.</span></span>
- <span data-ttu-id="a675e-182">針對 `abstract` 不是基底類型不是的記錄類型 `object` ：</span><span class="sxs-lookup"><span data-stu-id="a675e-182">For record types that aren't `abstract` when the base type is not `object`:</span></span>
  - <span data-ttu-id="a675e-183">如果記錄為，則「 `sealed` 複製」方法也是 `sealed` 。</span><span class="sxs-lookup"><span data-stu-id="a675e-183">If the record is `sealed`, the "clone" method is also `sealed`.</span></span>
  - <span data-ttu-id="a675e-184">如果記錄不是 `sealed` ，則「複製」方法是 `override` 。</span><span class="sxs-lookup"><span data-stu-id="a675e-184">If the record isn't `sealed`, the "clone" method is `override`.</span></span>

<span data-ttu-id="a675e-185">所有這些規則的結果都是一致地跨任何記錄類型階層來實行相等的結果。</span><span class="sxs-lookup"><span data-stu-id="a675e-185">The result of all these rules is the equality is implemented consistently across any hierarchy of record types.</span></span> <span data-ttu-id="a675e-186">如果兩筆記錄的屬性相等且其類型相同，就會彼此相等，如下列範例所示：</span><span class="sxs-lookup"><span data-stu-id="a675e-186">Two records are equal to each other if their properties are equal and their types are the same, as shown in the following example:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/RecordsExamples.cs" ID="RecordsEquality":::

<span data-ttu-id="a675e-187">編譯器會會合成兩種支援列印輸出的方法：覆 <xref:System.Object.ToString> 寫、和 `PrintMembers` 。</span><span class="sxs-lookup"><span data-stu-id="a675e-187">The compiler synthesizes two methods that support printed output: a <xref:System.Object.ToString> override, and `PrintMembers`.</span></span> <span data-ttu-id="a675e-188">`PrintMembers`會接受 <xref:System.Text.StringBuilder?displayProperty=nameWithType> 做為其引數。</span><span class="sxs-lookup"><span data-stu-id="a675e-188">The `PrintMembers` takes a <xref:System.Text.StringBuilder?displayProperty=nameWithType> as its argument.</span></span> <span data-ttu-id="a675e-189">它會針對記錄類型中的所有屬性，附加以逗號分隔的屬性名稱和值清單。</span><span class="sxs-lookup"><span data-stu-id="a675e-189">It appends a comma-separated list of property names and values for all properties in the record type.</span></span> <span data-ttu-id="a675e-190">`PrintMembers` 針對衍生自其他記錄的任何記錄，呼叫基底實作為。</span><span class="sxs-lookup"><span data-stu-id="a675e-190">`PrintMembers` calls the base implementation for any records derived from other records.</span></span> <span data-ttu-id="a675e-191">覆 <xref:System.Object.ToString> 寫會傳回所產生的字串 `PrintMembers` ，並以和括住 `{` `}` 。</span><span class="sxs-lookup"><span data-stu-id="a675e-191">The <xref:System.Object.ToString> override returns the string produced by `PrintMembers`, surrounded by `{` and `}`.</span></span> <span data-ttu-id="a675e-192">例如，的方法會傳回， <xref:System.Object.ToString> `Student` `string` 如下列程式碼所示：</span><span class="sxs-lookup"><span data-stu-id="a675e-192">For example, the <xref:System.Object.ToString> method for `Student` returns a `string` like the following code:</span></span>

```csharp
"Student { LastName = Wagner, FirstName = Bill, Level = 11 }"
```

<span data-ttu-id="a675e-193">到目前為止所顯示的範例會使用傳統語法來宣告屬性。</span><span class="sxs-lookup"><span data-stu-id="a675e-193">The examples shown so far use traditional syntax to declare properties.</span></span> <span data-ttu-id="a675e-194">有更精確的形式稱為「 ***位置記錄***」。</span><span class="sxs-lookup"><span data-stu-id="a675e-194">There's a more concise form called ***positional records***.</span></span>  <span data-ttu-id="a675e-195">以下是稍早定義為位置記錄的三種記錄類型：</span><span class="sxs-lookup"><span data-stu-id="a675e-195">Here are the three record types defined earlier as positional records:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/PositionalRecords.cs" ID="PositionalRecords":::

<span data-ttu-id="a675e-196">這些宣告會建立與舊版 (的相同功能，但有幾個額外的功能) 在下一節中討論。</span><span class="sxs-lookup"><span data-stu-id="a675e-196">These declarations create the same functionality as the earlier version (with a couple extra features covered in the following section).</span></span> <span data-ttu-id="a675e-197">這些宣告的結尾都是分號而不是方括弧，因為這些記錄不會加入額外的方法。</span><span class="sxs-lookup"><span data-stu-id="a675e-197">These declarations end with a semicolon instead of brackets because these records don't add additional methods.</span></span> <span data-ttu-id="a675e-198">您可以新增內文，也可以包含任何其他方法：</span><span class="sxs-lookup"><span data-stu-id="a675e-198">You can add a body, and include any additional methods as well:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/PositionalRecords.cs" ID="RecordsWithMethods":::

<span data-ttu-id="a675e-199">編譯器會產生 `Deconstruct` 位置記錄的方法。</span><span class="sxs-lookup"><span data-stu-id="a675e-199">The compiler produces a `Deconstruct` method for positional records.</span></span> <span data-ttu-id="a675e-200">`Deconstruct`方法的參數與記錄類型中所有公用屬性的名稱相符。</span><span class="sxs-lookup"><span data-stu-id="a675e-200">The `Deconstruct` method has parameters that match the names of all public properties in the record type.</span></span> <span data-ttu-id="a675e-201">`Deconstruct`方法可以用來將記錄解構到其元件屬性中：</span><span class="sxs-lookup"><span data-stu-id="a675e-201">The `Deconstruct` method can be used to deconstruct the record into its component properties:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/PositionalRecords.cs" ID="DeconstructRecord":::

<span data-ttu-id="a675e-202">最後，記錄支援 ***與-運算式***。</span><span class="sxs-lookup"><span data-stu-id="a675e-202">Finally, records support ***with-expressions***.</span></span> <span data-ttu-id="a675e-203">***With-expression***會指示編譯器建立記錄的複本 *，但已修改指定的屬性*：</span><span class="sxs-lookup"><span data-stu-id="a675e-203">A ***with-expression*** instructs the compiler to create a copy of a record, but *with* specified properties modified:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/PositionalRecords.cs" ID="Wither":::

<span data-ttu-id="a675e-204">上述程式程式碼會建立新的 `Person` 記錄 `LastName` ，其中屬性是的複本 `person` ，而 `FirstName` 是 "Paul"。</span><span class="sxs-lookup"><span data-stu-id="a675e-204">The above line creates a new `Person` record where the `LastName` property is a copy of `person`, and the `FirstName` is "Paul".</span></span> <span data-ttu-id="a675e-205">您可以使用運算式來設定任何數目的屬性。</span><span class="sxs-lookup"><span data-stu-id="a675e-205">You can set any number of properties in a with-expression.</span></span>  <span data-ttu-id="a675e-206">任何合成成員（「複製」方法除外）都可以由您撰寫。</span><span class="sxs-lookup"><span data-stu-id="a675e-206">Any of the synthesized members except the "clone" method may be written by you.</span></span> <span data-ttu-id="a675e-207">如果記錄類型的方法符合任何合成方法的簽章，則編譯器不會合成該方法。</span><span class="sxs-lookup"><span data-stu-id="a675e-207">If a record type has a method that matches the signature of any synthesized method, the compiler doesn't synthesize that method.</span></span> <span data-ttu-id="a675e-208">先前的 `Dog` 記錄範例包含手動編碼的 <xref:System.String.ToString> 方法做為範例。</span><span class="sxs-lookup"><span data-stu-id="a675e-208">The earlier `Dog` record example contains a hand coded <xref:System.String.ToString> method as an example.</span></span>

## <a name="init-only-setters"></a><span data-ttu-id="a675e-209">僅供初始化的 Setter</span><span class="sxs-lookup"><span data-stu-id="a675e-209">Init only setters</span></span>

<span data-ttu-id="a675e-210">***Init only setter*** 提供一致的語法來初始化物件的成員。</span><span class="sxs-lookup"><span data-stu-id="a675e-210">***Init only setters*** provide consistent syntax to initialize members of an object.</span></span> <span data-ttu-id="a675e-211">屬性初始化運算式可讓它清除哪個值正在設定哪個屬性。</span><span class="sxs-lookup"><span data-stu-id="a675e-211">Property initializers provide make it clear which value is setting which property.</span></span> <span data-ttu-id="a675e-212">缺點是這些屬性必須是可設定的。</span><span class="sxs-lookup"><span data-stu-id="a675e-212">The downside is that those properties must be settable.</span></span> <span data-ttu-id="a675e-213">從 c # 9.0 開始，您可以建立存取子， `init` 而不是 `set` 屬性和索引子的存取子。</span><span class="sxs-lookup"><span data-stu-id="a675e-213">Starting with C# 9.0, you can create `init` accessors instead of `set` accessors for properties and indexers.</span></span> <span data-ttu-id="a675e-214">呼叫端可以使用屬性初始化運算式語法來設定建立運算式中的這些值，但在結構完成之後，這些屬性是唯讀的。</span><span class="sxs-lookup"><span data-stu-id="a675e-214">Callers can use property initializer syntax to set these values in creation expressions, but those properties are readonly once construction has completed.</span></span> <span data-ttu-id="a675e-215">僅限 Init 的 setter 提供視窗來變更狀態。</span><span class="sxs-lookup"><span data-stu-id="a675e-215">Init only setters provide a window to change state.</span></span> <span data-ttu-id="a675e-216">當建築階段結束時，該視窗就會關閉。</span><span class="sxs-lookup"><span data-stu-id="a675e-216">That window closes when the construction phase ends.</span></span> <span data-ttu-id="a675e-217">在所有初始化後（包括屬性初始化運算式和 with-expression），都能有效地結束結構階段。</span><span class="sxs-lookup"><span data-stu-id="a675e-217">The construction phase effectively ends after all initialization, including property initializers and with-expressions have completed.</span></span>

<span data-ttu-id="a675e-218">上述的位置記錄範例示範如何使用初始化 setter，以使用 with 運算式來設定屬性。</span><span class="sxs-lookup"><span data-stu-id="a675e-218">The preceding example for positional records demonstrates using an init-only setter to set a property using a with expression.</span></span> <span data-ttu-id="a675e-219">您可以在任何您撰寫的型別中宣告 init only setter。</span><span class="sxs-lookup"><span data-stu-id="a675e-219">You can declare init only setters in any type you write.</span></span> <span data-ttu-id="a675e-220">例如，下列結構會定義氣象觀察結構：</span><span class="sxs-lookup"><span data-stu-id="a675e-220">For example, the following struct defines a weather observation structure:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/WeatherObservation.cs" ID="DeclareWeatherObservation":::

<span data-ttu-id="a675e-221">呼叫端可以使用屬性初始化運算式語法來設定值，同時仍然保留永久性：</span><span class="sxs-lookup"><span data-stu-id="a675e-221">Callers can use property initializer syntax to set the values, while still preserving the immutability:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/WeatherObservation.cs" ID="UseWeatherObservation":::

<span data-ttu-id="a675e-222">但是，在初始化之後變更觀察是一項錯誤，方法是在初始化之外指派給僅限初始化的屬性：</span><span class="sxs-lookup"><span data-stu-id="a675e-222">But, changing an observation after initialization is an error by assigning to an init-only property outside of initialization:</span></span>

```csharp
// Error! CS8852.
now.TempetureInCelsius = 18;
```

<span data-ttu-id="a675e-223">僅初始化 setter 有助於從衍生類別設定基類屬性。</span><span class="sxs-lookup"><span data-stu-id="a675e-223">Init only setters can be useful to set base class properties from derived classes.</span></span> <span data-ttu-id="a675e-224">它們也可以透過基類中的協助程式來設定衍生屬性。</span><span class="sxs-lookup"><span data-stu-id="a675e-224">They can also set derived properties through helpers in a base class.</span></span> <span data-ttu-id="a675e-225">位置記錄會使用僅初始化 setter 來宣告屬性。</span><span class="sxs-lookup"><span data-stu-id="a675e-225">Positional records declare properties using init only setters.</span></span> <span data-ttu-id="a675e-226">這些 setter 會在 with 運算式中使用。</span><span class="sxs-lookup"><span data-stu-id="a675e-226">Those setters are used in with-expressions.</span></span> <span data-ttu-id="a675e-227">您可以針對任何或定義，宣告 init only 的 setter `class` `struct` 。</span><span class="sxs-lookup"><span data-stu-id="a675e-227">You can declare init only setters for any `class` or `struct` you define.</span></span>

## <a name="top-level-statements"></a><span data-ttu-id="a675e-228">最上層陳述式</span><span class="sxs-lookup"><span data-stu-id="a675e-228">Top-level statements</span></span>

<span data-ttu-id="a675e-229">***最上層的語句*** 會從許多應用程式中移除不必要的繁瑣。</span><span class="sxs-lookup"><span data-stu-id="a675e-229">***Top-level statements*** remove unnecessary ceremony from many applications.</span></span> <span data-ttu-id="a675e-230">請考慮標準 "Hello World！"</span><span class="sxs-lookup"><span data-stu-id="a675e-230">Consider the canonical "Hello World!"</span></span> <span data-ttu-id="a675e-231">程式：</span><span class="sxs-lookup"><span data-stu-id="a675e-231">program:</span></span>

```csharp
using System;

namespace HelloWorld
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Hello World!");
        }
    }
}
```

<span data-ttu-id="a675e-232">只有一行程式碼會執行任何作業。</span><span class="sxs-lookup"><span data-stu-id="a675e-232">There’s only one line of code that does anything.</span></span> <span data-ttu-id="a675e-233">使用最上層的語句，您可以使用 `using` 語句和執行工作的單行來取代所有重複使用的語句：</span><span class="sxs-lookup"><span data-stu-id="a675e-233">With top-level statements, you can replace all that boilerplate with the `using` statement and the single line that does the work:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/Program.cs" ID="TopLevelStatements":::

<span data-ttu-id="a675e-234">如果您需要單行程式，您可以移除指示詞， `using` 並使用完整類型名稱：</span><span class="sxs-lookup"><span data-stu-id="a675e-234">If you wanted a one-line program, you could remove the `using` directive and use the fully qualified type name:</span></span>

```csharp
System.Console.WriteLine("Hello World!");
```

<span data-ttu-id="a675e-235">您的應用程式中只有一個檔案可以使用最上層的語句。</span><span class="sxs-lookup"><span data-stu-id="a675e-235">Only one file in your application may use top-level statements.</span></span> <span data-ttu-id="a675e-236">如果編譯器在多個原始程式檔中尋找最上層的語句，則會產生錯誤。</span><span class="sxs-lookup"><span data-stu-id="a675e-236">If the compiler finds top-level statements in multiple source files, it’s an error.</span></span> <span data-ttu-id="a675e-237">如果您將最上層語句與宣告的程式進入點方法（通常是方法）結合，也會發生錯誤 `Main` 。</span><span class="sxs-lookup"><span data-stu-id="a675e-237">It’s also an error if you combine top-level statements with a declared program entry point method, typically a `Main` method.</span></span> <span data-ttu-id="a675e-238">您可以認為一個檔案包含的語句通常會在 `Main` 類別的方法中 `Program` 。</span><span class="sxs-lookup"><span data-stu-id="a675e-238">In a sense, you can think that one file contains the statements that would normally be in the `Main` method of a `Program` class.</span></span>  

<span data-ttu-id="a675e-239">這項功能最常見的用途之一就是建立教學教材。</span><span class="sxs-lookup"><span data-stu-id="a675e-239">One of the most common uses for this feature is creating teaching materials.</span></span> <span data-ttu-id="a675e-240">初學者 c # 開發人員可以撰寫標準 "Hello World！"</span><span class="sxs-lookup"><span data-stu-id="a675e-240">Beginner C# developers can write the canonical “Hello World!”</span></span> <span data-ttu-id="a675e-241">在一或兩行程式碼中。</span><span class="sxs-lookup"><span data-stu-id="a675e-241">in one or two lines of code.</span></span> <span data-ttu-id="a675e-242">不需要額外的額外儀式。</span><span class="sxs-lookup"><span data-stu-id="a675e-242">None of the extra ceremony is needed.</span></span> <span data-ttu-id="a675e-243">不過，經驗豐富的開發人員也會發現這項功能有許多用途。</span><span class="sxs-lookup"><span data-stu-id="a675e-243">However, seasoned developers will find many uses for this feature as well.</span></span> <span data-ttu-id="a675e-244">最上層的語句可啟用類似腳本的實驗體驗，類似于 Jupyter 筆記本所提供的功能。</span><span class="sxs-lookup"><span data-stu-id="a675e-244">Top-level statements enable a script-like experience for experimentation similar to what Jupyter notebooks provide.</span></span> <span data-ttu-id="a675e-245">最上層的語句非常適合小型主控台程式和公用程式。</span><span class="sxs-lookup"><span data-stu-id="a675e-245">Top-level statements are great for small console programs and utilities.</span></span> <span data-ttu-id="a675e-246">Azure 函式是最適合最上層語句的使用案例。</span><span class="sxs-lookup"><span data-stu-id="a675e-246">Azure functions are an ideal use case for top-level statements.</span></span>

<span data-ttu-id="a675e-247">最重要的是，最重要的語句不會限制應用程式的範圍或複雜度。</span><span class="sxs-lookup"><span data-stu-id="a675e-247">Most importantly, top-level statements don't limit your application’s scope or complexity.</span></span> <span data-ttu-id="a675e-248">這些語句可以存取或使用任何 .NET 類別。</span><span class="sxs-lookup"><span data-stu-id="a675e-248">Those statements can access or use any .NET class.</span></span> <span data-ttu-id="a675e-249">它們也不會限制您使用命令列引數或傳回值。</span><span class="sxs-lookup"><span data-stu-id="a675e-249">They also don’t limit your use of command-line arguments or return values.</span></span> <span data-ttu-id="a675e-250">最上層語句可以存取名為 args 的字串陣列。</span><span class="sxs-lookup"><span data-stu-id="a675e-250">Top-level statements can access an array of strings named args.</span></span> <span data-ttu-id="a675e-251">如果最上層的語句傳回整數值，該值就會變成合成方法的整數傳回碼 `Main` 。</span><span class="sxs-lookup"><span data-stu-id="a675e-251">If the top-level statements return an integer value, that value becomes the integer return code from a synthesized `Main` method.</span></span> <span data-ttu-id="a675e-252">最上層語句可能包含非同步運算式。</span><span class="sxs-lookup"><span data-stu-id="a675e-252">The top-level statements may contain async expressions.</span></span> <span data-ttu-id="a675e-253">在此情況下，合成的進入點會傳回 `Task` 或 `Task<int>` 。</span><span class="sxs-lookup"><span data-stu-id="a675e-253">In that case, the synthesized entry point returns a `Task`, or `Task<int>`.</span></span>

## <a name="pattern-matching-enhancements"></a><span data-ttu-id="a675e-254">模式比對增強功能</span><span class="sxs-lookup"><span data-stu-id="a675e-254">Pattern matching enhancements</span></span>

<span data-ttu-id="a675e-255">C # 9 包含新的模式比對改良功能：</span><span class="sxs-lookup"><span data-stu-id="a675e-255">C# 9 includes new pattern matching improvements:</span></span>

- <span data-ttu-id="a675e-256">***類型模式*** 符合變數是類型</span><span class="sxs-lookup"><span data-stu-id="a675e-256">***Type patterns*** match a variable is a type</span></span>
- <span data-ttu-id="a675e-257">***括弧模式*** 會強制執行或強調模式組合的優先順序</span><span class="sxs-lookup"><span data-stu-id="a675e-257">***Parenthesized patterns*** enforce or emphasize the precedence of pattern combinations</span></span>
- <span data-ttu-id="a675e-258">***組成 `and` 模式*** 需要這兩個模式相符</span><span class="sxs-lookup"><span data-stu-id="a675e-258">***Conjunctive `and` patterns*** require both patterns to match</span></span>
- <span data-ttu-id="a675e-259">***Disjunctive `or` 模式*** 需要有兩種模式相符</span><span class="sxs-lookup"><span data-stu-id="a675e-259">***Disjunctive `or` patterns*** require either pattern to match</span></span>
- <span data-ttu-id="a675e-260">***否定 `not` 模式*** 要求模式不相符</span><span class="sxs-lookup"><span data-stu-id="a675e-260">***Negated `not` patterns*** require that a pattern doesn’t match</span></span>
- <span data-ttu-id="a675e-261">***關聯式模式*** 要求輸入小於、大於、小於或等於或大於或等於指定的常數。</span><span class="sxs-lookup"><span data-stu-id="a675e-261">***Relational patterns*** require the input be less than, greater than, less than or equal, or greater than or equal to a given constant.</span></span>

<span data-ttu-id="a675e-262">這些模式會擴充模式的語法。</span><span class="sxs-lookup"><span data-stu-id="a675e-262">These patterns enrich the syntax for patterns.</span></span> <span data-ttu-id="a675e-263">請考慮下列範例：</span><span class="sxs-lookup"><span data-stu-id="a675e-263">Consider these examples:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/PatternUtilities.cs" ID="IsLetterPattern":::

<span data-ttu-id="a675e-264">或者，使用選擇性的括弧讓它清楚的 `and` 優先順序高於 `or` ：</span><span class="sxs-lookup"><span data-stu-id="a675e-264">Alternatively, with optional parentheses to make it clear that `and` has higher precedence than `or`:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/PatternUtilities.cs" ID="IsLetterOrSeparatorPattern":::

<span data-ttu-id="a675e-265">其中一個最常見的用法是 null 檢查的新語法：</span><span class="sxs-lookup"><span data-stu-id="a675e-265">One of the most common uses is a new syntax for a null check:</span></span>

```csharp
if (e is not null)
{
    // ...
}
```

<span data-ttu-id="a675e-266">這些模式中的任何一種都可以在允許模式的任何內容中使用： `is` 模式運算式、 `switch` 運算式、嵌套模式，以及 `switch` 語句 `case` 標籤的模式。</span><span class="sxs-lookup"><span data-stu-id="a675e-266">Any of these patterns can be used in any context where patterns are allowed: `is` pattern expressions, `switch` expressions, nested patterns, and the pattern of a `switch` statement’s `case` label.</span></span>

## <a name="performance-and-interop"></a><span data-ttu-id="a675e-267">效能和互通性</span><span class="sxs-lookup"><span data-stu-id="a675e-267">Performance and interop</span></span>

<span data-ttu-id="a675e-268">有三項新功能可改善需要高效能的原生 interop 和低層級程式庫的支援：原生大小的整數、函式指標，以及省略 `localsinit` 旗標。</span><span class="sxs-lookup"><span data-stu-id="a675e-268">Three new features improve support for native interop and low-level libraries that require high performance: native sized integers, function pointers, and omitting the `localsinit` flag.</span></span>

<span data-ttu-id="a675e-269">原生大小的整數 `nint` 和 `nuint` 是整數類型。</span><span class="sxs-lookup"><span data-stu-id="a675e-269">Native sized integers, `nint` and `nuint`, are integer types.</span></span> <span data-ttu-id="a675e-270">它們是以基礎類型和來 <xref:System.IntPtr?displayProperty=nameWithType> 表示 <xref:System.UIntPtr?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="a675e-270">They're expressed by the underlying types <xref:System.IntPtr?displayProperty=nameWithType> and <xref:System.UIntPtr?displayProperty=nameWithType>.</span></span> <span data-ttu-id="a675e-271">編譯器會以原生 int 的形式呈現這些類型的其他轉換和作業。</span><span class="sxs-lookup"><span data-stu-id="a675e-271">The compiler surfaces additional conversions and operations for these types as native ints.</span></span> <span data-ttu-id="a675e-272">原生大小的整數沒有或的常數 `MaxValue` `MinValue` ，但 `nuint.MinValue` 具有 `MinValue` 的是 `0` 。</span><span class="sxs-lookup"><span data-stu-id="a675e-272">Native sized ints don't have constants for `MaxValue` or `MinValue`, except for `nuint.MinValue`, which has a `MinValue` of `0`.</span></span> <span data-ttu-id="a675e-273">其他值無法表示為常數，因為它相依于目的電腦上的整數原生大小。</span><span class="sxs-lookup"><span data-stu-id="a675e-273">Other values can't be expressed as constants because it depends on the native size of an integer on the target machine.</span></span> <span data-ttu-id="a675e-274">您可以 `nint` 在 [.] 範圍中使用的常數值 `int.MinValue` 。</span><span class="sxs-lookup"><span data-stu-id="a675e-274">You can use constant values for `nint` in the range [`int.MinValue` ..</span></span> <span data-ttu-id="a675e-275">`int.MaxValue`].</span><span class="sxs-lookup"><span data-stu-id="a675e-275">`int.MaxValue`].</span></span> <span data-ttu-id="a675e-276">您可以 `nuint` 在 [.] 範圍中使用的常數值 `uint.MinValue` 。</span><span class="sxs-lookup"><span data-stu-id="a675e-276">You can use constant values for `nuint` in the range [`uint.MinValue` ..</span></span> <span data-ttu-id="a675e-277">`uint.MaxValue`].</span><span class="sxs-lookup"><span data-stu-id="a675e-277">`uint.MaxValue`].</span></span> <span data-ttu-id="a675e-278">編譯器會使用和類型來執行所有一元和二元運算子的常數折迭 <xref:System.Int32?displayProperty=nameWithType> <xref:System.UInt32?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="a675e-278">The compiler performs constant folding for all unary and binary operators using the <xref:System.Int32?displayProperty=nameWithType> and <xref:System.UInt32?displayProperty=nameWithType> types.</span></span> <span data-ttu-id="a675e-279">如果結果不符合32位，則作業會在執行時間執行，且不會被視為常數。</span><span class="sxs-lookup"><span data-stu-id="a675e-279">If the result doesn't fit in 32 bits, the operation is executed at runtime and isn't considered a constant.</span></span> <span data-ttu-id="a675e-280">原生大小的整數可提高使用整數數學的案例中的效能，而且需要盡可能最快的效能。</span><span class="sxs-lookup"><span data-stu-id="a675e-280">Native sized integers can increase performance in scenarios where integer math is used extensively and needs to have the fastest performance possible.</span></span>

<span data-ttu-id="a675e-281">函式指標提供簡單的語法來存取 IL 操作碼 `ldftn` 和 `calli` 。</span><span class="sxs-lookup"><span data-stu-id="a675e-281">Function pointers provide an easy syntax to access the IL opcodes `ldftn` and `calli`.</span></span> <span data-ttu-id="a675e-282">您可以使用新的語法來宣告函式指標 `delegate*` 。</span><span class="sxs-lookup"><span data-stu-id="a675e-282">You can declare function pointers using new `delegate*` syntax.</span></span> <span data-ttu-id="a675e-283">`delegate*`類型是指標類型。</span><span class="sxs-lookup"><span data-stu-id="a675e-283">A `delegate*` type is a pointer type.</span></span> <span data-ttu-id="a675e-284">`delegate*` `calli` 相對於在方法上使用的委派，叫用型別會使用 `callvirt` `Invoke()` 。</span><span class="sxs-lookup"><span data-stu-id="a675e-284">Invoking the `delegate*` type uses `calli`, in contrast to a delegate that uses `callvirt` on the `Invoke()` method.</span></span> <span data-ttu-id="a675e-285">在語法上，叫用相同。</span><span class="sxs-lookup"><span data-stu-id="a675e-285">Syntactically, the invocations are identical.</span></span> <span data-ttu-id="a675e-286">函數指標調用會使用 `managed` 呼叫慣例。</span><span class="sxs-lookup"><span data-stu-id="a675e-286">Function pointer invocation uses the `managed` calling convention.</span></span> <span data-ttu-id="a675e-287">您可以在 `unmanaged` 語法之後加入關鍵字， `delegate*` 以宣告您想要 `unmanaged` 呼叫慣例。</span><span class="sxs-lookup"><span data-stu-id="a675e-287">You add the `unmanaged` keyword after the `delegate*` syntax to declare that you want the `unmanaged` calling convention.</span></span> <span data-ttu-id="a675e-288">您可以使用宣告上的屬性來指定其他呼叫慣例 `delegate*` 。</span><span class="sxs-lookup"><span data-stu-id="a675e-288">Other calling conventions can be specified using attributes on the `delegate*` declaration.</span></span>

<span data-ttu-id="a675e-289">最後，您可以加入， <xref:System.Runtime.CompilerServices.SkipLocalsInitAttribute?displayProperty=nameWithType> 以指示編譯器不要發出 `localsinit` 旗標。</span><span class="sxs-lookup"><span data-stu-id="a675e-289">Finally, you can add the <xref:System.Runtime.CompilerServices.SkipLocalsInitAttribute?displayProperty=nameWithType> to instruct the compiler not to emit the `localsinit` flag.</span></span> <span data-ttu-id="a675e-290">此旗標會指示 CLR 將所有區域變數初始化為零。</span><span class="sxs-lookup"><span data-stu-id="a675e-290">This flag instructs the CLR to zero-initialize all local variables.</span></span> <span data-ttu-id="a675e-291">`localsinit`自1.0 起，旗標已是 c # 的預設行為。</span><span class="sxs-lookup"><span data-stu-id="a675e-291">The `localsinit` flag has been the default behavior for C# since 1.0.</span></span> <span data-ttu-id="a675e-292">不過，在某些情況下，額外的零初始化可能會有顯著的效能影響。</span><span class="sxs-lookup"><span data-stu-id="a675e-292">However, the extra zero-initialization may have measurable performance impact in some scenarios.</span></span> <span data-ttu-id="a675e-293">尤其是在使用時 `stackalloc` 。</span><span class="sxs-lookup"><span data-stu-id="a675e-293">In particular, when you use `stackalloc`.</span></span> <span data-ttu-id="a675e-294">在這些情況下，您可以新增 <xref:System.Runtime.CompilerServices.SkipLocalsInitAttribute> 。</span><span class="sxs-lookup"><span data-stu-id="a675e-294">In those cases, you can add the <xref:System.Runtime.CompilerServices.SkipLocalsInitAttribute>.</span></span> <span data-ttu-id="a675e-295">您可以將它加入至單一方法或屬性，或加入至 `class` 、 `struct` 、 `interface` 或甚至是模組。</span><span class="sxs-lookup"><span data-stu-id="a675e-295">You may add it to a single method or property, or to a `class`, `struct`, `interface`, or even a module.</span></span> <span data-ttu-id="a675e-296">這個屬性不會影響 `abstract` 方法，它會影響針對實作為產生的程式碼。</span><span class="sxs-lookup"><span data-stu-id="a675e-296">This attribute doesn't affect `abstract` methods; it affects the code generated for the implementation.</span></span>

<span data-ttu-id="a675e-297">在某些情況下，這些功能可以改善效能。</span><span class="sxs-lookup"><span data-stu-id="a675e-297">These features can improve performance in some scenarios.</span></span> <span data-ttu-id="a675e-298">在採用之前和之後，請務必謹慎使用它們。</span><span class="sxs-lookup"><span data-stu-id="a675e-298">They should be used only after careful benchmarking both before and after adoption.</span></span> <span data-ttu-id="a675e-299">牽涉到原生大小整數的程式碼必須在具有不同整數大小的多個目標平臺上進行測試。</span><span class="sxs-lookup"><span data-stu-id="a675e-299">Code involving native sized integers must be tested on multiple target platforms with different integer sizes.</span></span> <span data-ttu-id="a675e-300">其他功能則需要 unsafe 程式碼。</span><span class="sxs-lookup"><span data-stu-id="a675e-300">The other features require unsafe code.</span></span>

## <a name="fit-and-finish-features"></a><span data-ttu-id="a675e-301">符合和完成功能</span><span class="sxs-lookup"><span data-stu-id="a675e-301">Fit and finish features</span></span>

<span data-ttu-id="a675e-302">許多其他功能可協助您更有效率地撰寫程式碼。</span><span class="sxs-lookup"><span data-stu-id="a675e-302">Many of the other features help you write code more efficiently.</span></span> <span data-ttu-id="a675e-303">在 c # 9.0 中，當已建立的物件類型為已知時，您可以在新的運算式中省略該型別。</span><span class="sxs-lookup"><span data-stu-id="a675e-303">In C# 9.0, you can omit the type in a new expression when the created object's type is already known.</span></span> <span data-ttu-id="a675e-304">最常見的用法是在欄位宣告中：</span><span class="sxs-lookup"><span data-stu-id="a675e-304">The most common use is in field declarations:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/FitAndFinish.cs" ID="WeatherStationField":::

<span data-ttu-id="a675e-305">當您需要建立新的物件以做為參數傳遞至方法時，也可以使用目標型別 new。</span><span class="sxs-lookup"><span data-stu-id="a675e-305">Target type new can also be used when you need to create a new object to pass as a parameter to a method.</span></span> <span data-ttu-id="a675e-306">請考慮 `ForecastFor()` 具有下列簽章的方法：</span><span class="sxs-lookup"><span data-stu-id="a675e-306">Consider a `ForecastFor()` method with the following signature:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/FitAndFinish.cs" ID="ForecastSignature":::

<span data-ttu-id="a675e-307">您可以呼叫它，如下所示：</span><span class="sxs-lookup"><span data-stu-id="a675e-307">You could call it as follows:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/FitAndFinish.cs" ID="TargetTypeNewArgument":::

<span data-ttu-id="a675e-308">這項功能的另一個不錯用途是將它與 init only 屬性結合，以初始化新的物件。</span><span class="sxs-lookup"><span data-stu-id="a675e-308">Another nice use for this feature is to combine it with init only properties to initialize a new object.</span></span> <span data-ttu-id="a675e-309">上的括弧 `new` 是選擇性的：</span><span class="sxs-lookup"><span data-stu-id="a675e-309">The parentheses on `new` are optional:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/FitAndFinish.cs" ID="InitWeatherStation":::

<span data-ttu-id="a675e-310">您可以使用運算式傳回預設的函式所建立的實例 `return new();` 。</span><span class="sxs-lookup"><span data-stu-id="a675e-310">You can return an instance created by the default constructor using a `return new();` expression.</span></span>

<span data-ttu-id="a675e-311">類似的功能可改善條件運算式的目標型別解析。</span><span class="sxs-lookup"><span data-stu-id="a675e-311">A similar feature improves the target type resolution of conditional expressions.</span></span> <span data-ttu-id="a675e-312">進行這項變更時，這兩個運算式不需要從一個運算式隱含轉換成另一個運算式，但兩者都可能隱含轉換成一般類型。</span><span class="sxs-lookup"><span data-stu-id="a675e-312">With this change, the two expressions need not have an implicit conversion from one to the other, but may both have implicit conversions to a common type.</span></span> <span data-ttu-id="a675e-313">您可能不會注意到這種變更。</span><span class="sxs-lookup"><span data-stu-id="a675e-313">You likely won’t notice this change.</span></span> <span data-ttu-id="a675e-314">您將會注意到，某些條件運算式先前需要轉換或根本無法編譯。</span><span class="sxs-lookup"><span data-stu-id="a675e-314">What you will notice is that some conditional expressions that previously required casts or wouldn’t compile now just work.</span></span>

<span data-ttu-id="a675e-315">從 c # 9.0 開始，您可以將 `static` 修飾詞加入至 lambda 運算式或匿名方法。</span><span class="sxs-lookup"><span data-stu-id="a675e-315">Starting in C# 9.0, you can add the `static` modifier to lambda expressions or anonymous methods.</span></span> <span data-ttu-id="a675e-316">靜態 lambda 運算式類似于 `static` 區域函數：靜態 lambda 或匿名函式無法捕捉區域變數或實例狀態。</span><span class="sxs-lookup"><span data-stu-id="a675e-316">Static lambda expressions are analogous to the `static` local functions: a static lambda or anonymous function can't capture local variables or instance state.</span></span> <span data-ttu-id="a675e-317">`static`修飾詞可避免意外地捕捉其他變數。</span><span class="sxs-lookup"><span data-stu-id="a675e-317">The `static` modifier prevents accidentally capturing other variables.</span></span>

<span data-ttu-id="a675e-318">協變數傳回型別提供覆寫函式之傳回類型的彈性。</span><span class="sxs-lookup"><span data-stu-id="a675e-318">Covariant return types provide flexibility for the return types of overridden functions.</span></span> <span data-ttu-id="a675e-319">覆寫的虛擬函式可以傳回衍生自基類方法中宣告之傳回型別的型別。</span><span class="sxs-lookup"><span data-stu-id="a675e-319">An overridden virtual function can return a type derived from the return type declared in the base class method.</span></span> <span data-ttu-id="a675e-320">這有助於記錄，以及支援虛擬複製品或 factory 方法的其他類型。</span><span class="sxs-lookup"><span data-stu-id="a675e-320">This can be useful for Records, and for other types that support virtual clone or factory methods.</span></span>

<span data-ttu-id="a675e-321">接下來，您可以使用捨棄作為 lambda 運算式的參數。</span><span class="sxs-lookup"><span data-stu-id="a675e-321">Next, you can use discards as parameters to lambda expressions.</span></span> <span data-ttu-id="a675e-322">這種便利性可讓您避免將引數命名，而編譯器可能會避免使用它。</span><span class="sxs-lookup"><span data-stu-id="a675e-322">This convenience enables you to avoid naming the argument, and the compiler may avoid using it.</span></span> <span data-ttu-id="a675e-323">您可以使用 `_` 做為任何引數。</span><span class="sxs-lookup"><span data-stu-id="a675e-323">You use the `_` for any argument.</span></span>

<span data-ttu-id="a675e-324">最後，您現在可以將屬性套用至區域函數。</span><span class="sxs-lookup"><span data-stu-id="a675e-324">Finally, you can now apply attributes to local functions.</span></span> <span data-ttu-id="a675e-325">例如，您可以將可為 null 的屬性批註套用至區域函數。</span><span class="sxs-lookup"><span data-stu-id="a675e-325">For example, you can apply nullable attribute annotations to local functions.</span></span>

## <a name="support-for-code-generators"></a><span data-ttu-id="a675e-326">程式碼產生器的支援</span><span class="sxs-lookup"><span data-stu-id="a675e-326">Support for code generators</span></span>

<span data-ttu-id="a675e-327">有兩個最終功能支援 c # 程式碼產生器。</span><span class="sxs-lookup"><span data-stu-id="a675e-327">Two final features support C# code generators.</span></span> <span data-ttu-id="a675e-328">C # 程式碼產生器是您可以撰寫的元件，類似于 roslyn 分析器或程式碼修正。</span><span class="sxs-lookup"><span data-stu-id="a675e-328">C# code generators are a component you can write that is similar to a roslyn analyzer or code fix.</span></span> <span data-ttu-id="a675e-329">差別在於程式碼產生器會分析程式碼，並在編譯過程中撰寫新的原始程式碼檔。</span><span class="sxs-lookup"><span data-stu-id="a675e-329">The difference is that code generators analyze code and write new source code files as part of the compilation process.</span></span> <span data-ttu-id="a675e-330">一般的程式碼產生器會搜尋程式碼中的屬性或其他慣例。</span><span class="sxs-lookup"><span data-stu-id="a675e-330">A typical code generator searches code for attributes or other conventions.</span></span>

<span data-ttu-id="a675e-331">程式碼產生器會使用 Roslyn 分析 Api 來讀取屬性或其他程式碼元素。</span><span class="sxs-lookup"><span data-stu-id="a675e-331">A code generator read attributes or other code elements using the Roslyn analysis APIs.</span></span> <span data-ttu-id="a675e-332">在該資訊中，它會將新的程式碼加入至編譯中。</span><span class="sxs-lookup"><span data-stu-id="a675e-332">From that information, it adds new code to the compilation.</span></span> <span data-ttu-id="a675e-333">來源產生器只能新增程式碼;不允許它們修改編譯中的任何現有程式碼。</span><span class="sxs-lookup"><span data-stu-id="a675e-333">Source generators can only add code; they aren't allowed to modify any existing code in the compilation.</span></span>

<span data-ttu-id="a675e-334">針對程式碼產生器新增的兩項功能是 ***部分方法語法***的延伸模組，以及 ***模組初始化運算式***。</span><span class="sxs-lookup"><span data-stu-id="a675e-334">The two features added for code generators are extensions to ***partial method syntax***, and ***module initializers***.</span></span> <span data-ttu-id="a675e-335">首先是部分方法的變更。</span><span class="sxs-lookup"><span data-stu-id="a675e-335">First, the changes to partial methods.</span></span> <span data-ttu-id="a675e-336">在 c # 9.0 之前，部分方法是 `private` 但無法指定存取修飾詞、傳回 `void` ，而且不能有 `out` 參數。</span><span class="sxs-lookup"><span data-stu-id="a675e-336">Before C# 9.0, partial methods are `private` but can't specify an access modifier, have a `void` return, and can't have `out` parameters.</span></span> <span data-ttu-id="a675e-337">這些限制表示如果未提供任何方法執行，則編譯器會移除對部分方法的所有呼叫。</span><span class="sxs-lookup"><span data-stu-id="a675e-337">These restrictions meant that if no method implementation is provided, the compiler removes all calls to the partial method.</span></span> <span data-ttu-id="a675e-338">C # 9.0 會移除這些限制，但需要部分方法宣告才能執行。</span><span class="sxs-lookup"><span data-stu-id="a675e-338">C# 9.0 removes these restrictions, but requires that partial method declarations have an implementation.</span></span> <span data-ttu-id="a675e-339">程式碼產生器可以提供該執行。</span><span class="sxs-lookup"><span data-stu-id="a675e-339">Code generators can provide that implementation.</span></span> <span data-ttu-id="a675e-340">為了避免引進重大變更，編譯器會考慮任何部分方法，而不使用存取修飾詞來遵循舊規則。</span><span class="sxs-lookup"><span data-stu-id="a675e-340">To avoid introducing a breaking change, the compiler considers any partial method without an access modifier to follow the old rules.</span></span> <span data-ttu-id="a675e-341">如果部分方法包含 `private` 存取修飾詞，則新的規則會管理該部分方法。</span><span class="sxs-lookup"><span data-stu-id="a675e-341">If the partial method includes the `private` access modifier, the new rules govern that partial method.</span></span>

<span data-ttu-id="a675e-342">程式碼產生器的第二項新功能是 ***模組初始化運算式***。</span><span class="sxs-lookup"><span data-stu-id="a675e-342">The second new feature for code generators is ***module initializers***.</span></span> <span data-ttu-id="a675e-343">模組初始化運算式是已 <xref:System.Runtime.CompilerServices.ModuleInitializerAttribute> 附加屬性的方法。</span><span class="sxs-lookup"><span data-stu-id="a675e-343">Module initializers are methods that have the <xref:System.Runtime.CompilerServices.ModuleInitializerAttribute> attribute attached to them.</span></span> <span data-ttu-id="a675e-344">載入元件時，執行時間會呼叫這些方法。</span><span class="sxs-lookup"><span data-stu-id="a675e-344">These methods will be called by the runtime when the assembly loads.</span></span> <span data-ttu-id="a675e-345">模組初始化運算式方法：</span><span class="sxs-lookup"><span data-stu-id="a675e-345">A module initializer method:</span></span>

- <span data-ttu-id="a675e-346">必須是靜態</span><span class="sxs-lookup"><span data-stu-id="a675e-346">Must be static</span></span>
- <span data-ttu-id="a675e-347">必須是無參數</span><span class="sxs-lookup"><span data-stu-id="a675e-347">Must be parameterless</span></span>
- <span data-ttu-id="a675e-348">必須傳回 void</span><span class="sxs-lookup"><span data-stu-id="a675e-348">Must return void</span></span>
- <span data-ttu-id="a675e-349">不得為泛型方法</span><span class="sxs-lookup"><span data-stu-id="a675e-349">Must not be a generic method</span></span>
- <span data-ttu-id="a675e-350">不得包含在泛型類別中</span><span class="sxs-lookup"><span data-stu-id="a675e-350">Must not be contained in a generic class</span></span>
- <span data-ttu-id="a675e-351">必須可從包含的模組存取</span><span class="sxs-lookup"><span data-stu-id="a675e-351">Must be accessible from the containing module</span></span>

<span data-ttu-id="a675e-352">最後一個專案符號點實際上表示方法及其包含的類別必須為內部或公用。</span><span class="sxs-lookup"><span data-stu-id="a675e-352">That last bullet point effectively means the method and its containing class must be internal or public.</span></span> <span data-ttu-id="a675e-353">方法不能是區域函數。</span><span class="sxs-lookup"><span data-stu-id="a675e-353">The method can't be a local function.</span></span>
