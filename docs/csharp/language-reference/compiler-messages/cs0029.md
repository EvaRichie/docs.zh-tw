---
description: 編譯器錯誤 CS0029
title: 編譯器錯誤 CS0029
ms.date: 07/20/2015
f1_keywords:
- CS0029
helpviewer_keywords:
- CS0029
ms.assetid: 63c3e574-1868-4a9e-923e-dcd9f38bce88
ms.openlocfilehash: 4f6a1f9bfc16ebaaecf38645de377b9b29bbbf8e
ms.sourcegitcommit: e7acba36517134238065e4d50bb4a1cfe47ebd06
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 09/04/2020
ms.locfileid: "89465022"
---
# <a name="compiler-error-cs0029"></a><span data-ttu-id="aa06d-103">編譯器錯誤 CS0029</span><span class="sxs-lookup"><span data-stu-id="aa06d-103">Compiler Error CS0029</span></span>

<span data-ttu-id="aa06d-104">無法將類型 'type' 隱含轉換成 'type'</span><span class="sxs-lookup"><span data-stu-id="aa06d-104">Cannot implicitly convert type 'type' to 'type'</span></span>

 <span data-ttu-id="aa06d-105">編譯器需要明確轉換。</span><span class="sxs-lookup"><span data-stu-id="aa06d-105">The compiler requires an explicit conversion.</span></span> <span data-ttu-id="aa06d-106">例如，您可能需要將右值轉換成與左值相同的類型。</span><span class="sxs-lookup"><span data-stu-id="aa06d-106">For example, you may need to cast an r-value to be the same type as an l-value.</span></span> <span data-ttu-id="aa06d-107">否則，您必須提供轉換常式，以支援特定運算子多載。</span><span class="sxs-lookup"><span data-stu-id="aa06d-107">Or, you must provide conversion routines to support certain operator overloads.</span></span>

 <span data-ttu-id="aa06d-108">將某種類型的變數指派給不同類型的變數時，一定會發生轉換。</span><span class="sxs-lookup"><span data-stu-id="aa06d-108">Conversions must occur when assigning a variable of one type to a variable of a different type.</span></span> <span data-ttu-id="aa06d-109">在不同類型的變數之間進行指派時，編譯器必須將指派運算子右邊的類型，轉換成指派運算子左邊的類型。</span><span class="sxs-lookup"><span data-stu-id="aa06d-109">When making an assignment between variables of different types, the compiler must convert the type on the right-hand side of the assignment operator to the type on the left-hand side of the assignment operator.</span></span> <span data-ttu-id="aa06d-110">以下面這段程式碼來說：</span><span class="sxs-lookup"><span data-stu-id="aa06d-110">Take the following the code:</span></span>

```csharp
int i = 50;
long lng = 100;
i = lng;
```

 <span data-ttu-id="aa06d-111">`i = lng;` 會進行指派，但指派運算子左邊和右邊變數的資料類型不符。</span><span class="sxs-lookup"><span data-stu-id="aa06d-111">`i = lng;` makes an assignment, but the data types of the variables on the left and right-hand side of the assignment operator don't match.</span></span> <span data-ttu-id="aa06d-112">進行指派之前，編譯器會將類型為 long 的變數隱含轉換成 `lng` int。這是隱含的，因為沒有程式碼明確指示編譯器執行這項轉換。</span><span class="sxs-lookup"><span data-stu-id="aa06d-112">Before making the assignment the compiler is implicitly converting the variable `lng`, which is of type long, to an int. This is implicit because no code explicitly instructed the compiler to perform this conversion.</span></span> <span data-ttu-id="aa06d-113">此程式碼的問題在於這會視為縮小轉換，而編譯器不允許隱含的縮小轉換，因為這可能會遺失資料。</span><span class="sxs-lookup"><span data-stu-id="aa06d-113">The problem with this code is that this is considered a narrowing conversion, and the compiler does not allow implicit narrowing conversions because there could be a potential loss of data.</span></span>

 <span data-ttu-id="aa06d-114">當轉換的目標資料類型比轉換的來源資料類型佔用更少的記憶體儲存空間時，就是縮小轉換。</span><span class="sxs-lookup"><span data-stu-id="aa06d-114">A narrowing conversion exists when converting to a data type that occupies less storage space in memory than the data type we are converting from.</span></span> <span data-ttu-id="aa06d-115">例如，將 long 轉換成 int 會視為縮小轉換。</span><span class="sxs-lookup"><span data-stu-id="aa06d-115">For example, converting a long to an int would be considered a narrowing conversion.</span></span> <span data-ttu-id="aa06d-116">long 佔用 8 個位元組的記憶體，而 int 佔用 4 個位元組。</span><span class="sxs-lookup"><span data-stu-id="aa06d-116">A long occupies 8 bytes of memory while an int occupies 4 bytes.</span></span> <span data-ttu-id="aa06d-117">若要了解資料遺失可能發生的情況，請考慮下列範例：</span><span class="sxs-lookup"><span data-stu-id="aa06d-117">To see how data loss can occur, consider the following sample:</span></span>

```csharp
int i = 50;
long lng = 3147483647;
i = lng;
```

 <span data-ttu-id="aa06d-118">變數 `lng` 現在包含一個值，由於太大而無法儲存在變數 `i` 中。</span><span class="sxs-lookup"><span data-stu-id="aa06d-118">The variable `lng` now contains a value that cannot be stored in the variable `i` because it is too large.</span></span> <span data-ttu-id="aa06d-119">如果我們將此值轉換成 int 類型，則會遺失部分資料，而且轉換後的值與轉換前的值不同。</span><span class="sxs-lookup"><span data-stu-id="aa06d-119">If we were to convert this value to an int type we would be losing some of our data and the converted value would not be the same as the value before the conversion.</span></span>

 <span data-ttu-id="aa06d-120">擴展轉換與縮小轉換相反。</span><span class="sxs-lookup"><span data-stu-id="aa06d-120">A widening conversion would be the opposite of a narrowing conversion.</span></span> <span data-ttu-id="aa06d-121">使用擴展轉換時，轉換的目標資料類型比轉換的來源資料類型佔用更多的記憶體儲存空間。</span><span class="sxs-lookup"><span data-stu-id="aa06d-121">With widening conversions, we are converting to a data type that occupies more storage space in memory than the data type we are converting from.</span></span> <span data-ttu-id="aa06d-122">擴展轉換的範例如下：</span><span class="sxs-lookup"><span data-stu-id="aa06d-122">Here is an example of a widening conversion:</span></span>

```csharp
int i = 50;
long lng = 100;
lng = i;
```

 <span data-ttu-id="aa06d-123">注意此程式碼範例與第一個程式碼範例之間的差異。</span><span class="sxs-lookup"><span data-stu-id="aa06d-123">Notice the difference between this code sample and the first.</span></span> <span data-ttu-id="aa06d-124">此時，變數 `lng` 是在指派運算子的左邊，因此是我們的指派目標。</span><span class="sxs-lookup"><span data-stu-id="aa06d-124">This time the variable `lng` is on the left-hand side of the assignment operator, so it is the target of our assignment.</span></span> <span data-ttu-id="aa06d-125">編譯器必須將 int 類型的變數 `i` 隱含轉換成 long 類型，才能進行指派。</span><span class="sxs-lookup"><span data-stu-id="aa06d-125">Before the assignment can be made, the compiler must implicitly convert the variable `i`, which is of type int, to type long.</span></span> <span data-ttu-id="aa06d-126">這是擴展轉換，因為我們是將佔用 4 個位元組記憶體的類型 (int)，轉換成佔用 8 個位元組記憶體的類型 (long)。</span><span class="sxs-lookup"><span data-stu-id="aa06d-126">This is a widening conversion since we are converting from a type that occupies 4 bytes of memory (an int) to a type that occupies 8 bytes of memory (a long).</span></span> <span data-ttu-id="aa06d-127">因為不可能遺失資料，所以允許隱含的擴展轉換。</span><span class="sxs-lookup"><span data-stu-id="aa06d-127">Implicit widening conversions are allowed because there is no potential loss of data.</span></span> <span data-ttu-id="aa06d-128">任何可以儲存在 int 中的值，也可以儲存在 long 中。</span><span class="sxs-lookup"><span data-stu-id="aa06d-128">Any value that can be stored in an int can also be stored in a long.</span></span>

 <span data-ttu-id="aa06d-129">我們知道不允許隱含的縮小轉換，因此若要編譯此程式碼，我們需要明確轉換資料類型。</span><span class="sxs-lookup"><span data-stu-id="aa06d-129">We know that implicit narrowing conversions are not allowed, so to be able to compile this code we need to explicitly convert the data type.</span></span> <span data-ttu-id="aa06d-130">明確轉換是透過轉型來進行。</span><span class="sxs-lookup"><span data-stu-id="aa06d-130">Explicit conversions are done using casting.</span></span> <span data-ttu-id="aa06d-131">「轉型」是 C# 中用來描述將某種資料類型轉換成另一種的字詞。</span><span class="sxs-lookup"><span data-stu-id="aa06d-131">Casting is the term used in C# to describe converting one data type to another.</span></span> <span data-ttu-id="aa06d-132">若要讓程式碼進行編譯，我們需要使用下列語法：</span><span class="sxs-lookup"><span data-stu-id="aa06d-132">To get the code to compile we would need to use the following syntax:</span></span>

```csharp
int i = 50;
long lng = 100;
i = (int) lng;   // Cast to int.
```

 <span data-ttu-id="aa06d-133">程式碼的第三行會指示編譯器將 long 類型的變數 `lng` 隱含轉換成 int，再進行指派。</span><span class="sxs-lookup"><span data-stu-id="aa06d-133">The third line of code tells the compiler to explicitly convert the variable `lng`, which is of type long, to an int before making the assignment.</span></span> <span data-ttu-id="aa06d-134">請記住，若使用縮小轉換，則有可能會遺失資料。</span><span class="sxs-lookup"><span data-stu-id="aa06d-134">Remember that with a narrowing conversion, there is a potential loss of data.</span></span> <span data-ttu-id="aa06d-135">請謹慎使用縮小轉換，即使程式碼會編譯，您還是可能會在執行階段收到非預期的結果。</span><span class="sxs-lookup"><span data-stu-id="aa06d-135">Narrowing conversions should be used with caution and even though the code will compile you may get unexpected results at run-time.</span></span>

 <span data-ttu-id="aa06d-136">此討論僅適用於實值型別。</span><span class="sxs-lookup"><span data-stu-id="aa06d-136">This discussion has only been for value types.</span></span> <span data-ttu-id="aa06d-137">使用實值型別時，您是直接處理儲存在變數中的資料。</span><span class="sxs-lookup"><span data-stu-id="aa06d-137">When working with value types you work directly with the data stored in the variable.</span></span> <span data-ttu-id="aa06d-138">不過，.NET 也有參考型別。</span><span class="sxs-lookup"><span data-stu-id="aa06d-138">However, .NET also has reference types.</span></span> <span data-ttu-id="aa06d-139">使用參考型別時，您是處理變數的參考，而不是實際資料。</span><span class="sxs-lookup"><span data-stu-id="aa06d-139">When working with reference types you are working with a reference to a variable, not the actual data.</span></span> <span data-ttu-id="aa06d-140">類別、介面和陣列都是參考型別的例子。</span><span class="sxs-lookup"><span data-stu-id="aa06d-140">Examples of reference types would be classes, interfaces and arrays.</span></span> <span data-ttu-id="aa06d-141">除非編譯器允許特定轉換，或實作適當的轉換運算子，否則您無法將某種參考型別隱含或明確轉換成另一種。</span><span class="sxs-lookup"><span data-stu-id="aa06d-141">You cannot implicitly or explicitly convert one reference type to another unless the compiler allows the specific conversion or the appropriate conversion operators are implemented.</span></span>

 <span data-ttu-id="aa06d-142">下列範例會產生 CS0029：</span><span class="sxs-lookup"><span data-stu-id="aa06d-142">The following sample generates CS0029:</span></span>

```csharp
// CS0029.cs
public class MyInt
{
    private int x = 0;

    // Uncomment this conversion routine to resolve CS0029.
    /*
    public static implicit operator int(MyInt i)
    {
        return i.x;
    }
    */

    public static void Main()
    {
        var myInt = new MyInt();
        int i = myInt; // CS0029
    }
}
```

## <a name="see-also"></a><span data-ttu-id="aa06d-143">另請參閱</span><span class="sxs-lookup"><span data-stu-id="aa06d-143">See also</span></span>

- [<span data-ttu-id="aa06d-144">使用者定義轉換運算子</span><span class="sxs-lookup"><span data-stu-id="aa06d-144">User-defined conversion operators</span></span>](../operators/user-defined-conversion-operators.md)
