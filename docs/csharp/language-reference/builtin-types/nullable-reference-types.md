---
title: '可為 null 的參考型別-c # 參考'
description: '深入瞭解 c # 可為 null 的參考型別，以及如何使用它們'
ms.date: 04/06/2020
ms.openlocfilehash: 274a613a8381a2b7718c9025f51aadb2eb32af36
ms.sourcegitcommit: 870bc4b4087510f6fba3c7b1c0d391f02bcc1f3e
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 10/23/2020
ms.locfileid: "92471859"
---
# <a name="nullable-reference-types-c-reference"></a><span data-ttu-id="3511d-103">可為 null 的參考型別 (c # 參考) </span><span class="sxs-lookup"><span data-stu-id="3511d-103">Nullable reference types (C# reference)</span></span>

> [!NOTE]
> <span data-ttu-id="3511d-104">本文涵蓋可為 null 的參考型別。</span><span class="sxs-lookup"><span data-stu-id="3511d-104">This article covers nullable reference types.</span></span> <span data-ttu-id="3511d-105">您也可以宣告 [可為 null 的實數值型別](nullable-value-types.md)。</span><span class="sxs-lookup"><span data-stu-id="3511d-105">You can also declare [nullable value types](nullable-value-types.md).</span></span>

<span data-ttu-id="3511d-106">從 c # 8.0 開始，可為 null 的參考型別（在已加入 *可為 null 感知內容*的程式碼中）。</span><span class="sxs-lookup"><span data-stu-id="3511d-106">Nullable reference types are available beginning with C# 8.0, in code that has opted in to a *nullable aware context*.</span></span> <span data-ttu-id="3511d-107">可為 null 的參考型別、null 靜態分析警告和 [null 容許運算子](../operators/null-forgiving.md) 是選擇性的語言功能。</span><span class="sxs-lookup"><span data-stu-id="3511d-107">Nullable reference types, the null static analysis warnings, and the [null-forgiving operator](../operators/null-forgiving.md) are optional language features.</span></span> <span data-ttu-id="3511d-108">預設會關閉所有。</span><span class="sxs-lookup"><span data-stu-id="3511d-108">All are turned off by default.</span></span> <span data-ttu-id="3511d-109">*可為 null 的內容*可在專案層級使用組建設定或使用 pragma 的程式碼來控制。</span><span class="sxs-lookup"><span data-stu-id="3511d-109">A *nullable context* is controlled at the project level using build settings, or in code using pragmas.</span></span>

 <span data-ttu-id="3511d-110">在可為 null 的感知內容中：</span><span class="sxs-lookup"><span data-stu-id="3511d-110">In a nullable aware context:</span></span>

- <span data-ttu-id="3511d-111">參考型別的變數 `T` 必須使用非 null 來初始化，而且可能永遠不會指派可能的值 `null` 。</span><span class="sxs-lookup"><span data-stu-id="3511d-111">A variable of a reference type `T` must be initialized with non-null, and may never be assigned a value that may be `null`.</span></span>
- <span data-ttu-id="3511d-112">參考型別的變數 `T?` 可能會使用 `null` 或指派 `null` ，但在取消參考之前必須先進行檢查 `null` 。</span><span class="sxs-lookup"><span data-stu-id="3511d-112">A variable of a reference type `T?` may be initialized with `null` or assigned `null`, but is required to be checked against `null` before de-referencing.</span></span>
- <span data-ttu-id="3511d-113">`m` `T?` 當您套用 null 容許運算子時，型別的變數會被視為非 null，如下所示 `m!` 。</span><span class="sxs-lookup"><span data-stu-id="3511d-113">A variable `m` of type `T?` is considered to be non-null when you apply the null-forgiving operator, as in `m!`.</span></span>

<span data-ttu-id="3511d-114">不可為 null 的參考型別 `T` 與可為 null 的參考型別之間的差異， `T?` 是由編譯器對上述規則的解讀來強制執行。</span><span class="sxs-lookup"><span data-stu-id="3511d-114">The distinctions between a non-nullable reference type `T` and a nullable reference type `T?` are enforced by the compiler's interpretation of the preceding rules.</span></span> <span data-ttu-id="3511d-115">型別的變數 `T` 和型別的變數， `T?` 是以相同的 .net 型別表示。</span><span class="sxs-lookup"><span data-stu-id="3511d-115">A variable of type `T` and a variable of type `T?` are represented by the same .NET type.</span></span> <span data-ttu-id="3511d-116">下列範例會宣告不可為 null 的字串與可為 null 的字串，然後使用 null 容許運算子將值指派給不可為 null 的字串：</span><span class="sxs-lookup"><span data-stu-id="3511d-116">The following example declares a non-nullable string and a nullable string, and then uses the null-forgiving operator to assign a value to a non-nullable string:</span></span>

:::code language="csharp" source="snippets/shared/NullableReferenceTypes.cs" id="SnippetCoreSyntax":::

<span data-ttu-id="3511d-117">變數 `notNull` 和 `nullable` 都是由型別表示 <xref:System.String> 。</span><span class="sxs-lookup"><span data-stu-id="3511d-117">The variables `notNull` and `nullable` are both represented by the <xref:System.String> type.</span></span> <span data-ttu-id="3511d-118">因為不可為 null 且可為 null 的型別同時儲存為相同類型，所以不允許使用可為 null 的參考型別的數個位置。</span><span class="sxs-lookup"><span data-stu-id="3511d-118">Because the non-nullable and nullable types are both stored as the same type, there are several locations where using a nullable reference type isn't allowed.</span></span> <span data-ttu-id="3511d-119">一般而言，可為 null 的參考型別不能當做基類或實介面使用。</span><span class="sxs-lookup"><span data-stu-id="3511d-119">In general, a nullable reference type can't be used as a base class or implemented interface.</span></span> <span data-ttu-id="3511d-120">可為 null 的參考型別不能用在任何物件建立或型別測試運算式中。</span><span class="sxs-lookup"><span data-stu-id="3511d-120">A nullable reference type can't be used in any object creation or type testing expression.</span></span> <span data-ttu-id="3511d-121">可為 null 的參考型別不能是成員存取運算式的類型。</span><span class="sxs-lookup"><span data-stu-id="3511d-121">A nullable reference type can't be the type of a member access expression.</span></span> <span data-ttu-id="3511d-122">下列範例會顯示這些結構：</span><span class="sxs-lookup"><span data-stu-id="3511d-122">The following examples show these constructs:</span></span>

```csharp
public MyClass : System.Object? // not allowed
{
}

var nullEmpty = System.String?.Empty; // Not allowed
var maybeObject = new object?(); // Not allowed
try
{
    if (thing is string? nullableString) // not allowed
        Console.WriteLine(nullableString);
} catch (Exception? e) // Not Allowed
{
    Console.WriteLine("error");
}
```

## <a name="nullable-references-and-static-analysis"></a><span data-ttu-id="3511d-123">可為 null 的參考和靜態分析</span><span class="sxs-lookup"><span data-stu-id="3511d-123">Nullable references and static analysis</span></span>

<span data-ttu-id="3511d-124">上一節中的範例說明可為 null 的參考型別的本質。</span><span class="sxs-lookup"><span data-stu-id="3511d-124">The examples in the previous section illustrate the nature of nullable reference types.</span></span> <span data-ttu-id="3511d-125">可為 null 的參考型別不是新的類別型別，而是現有參考型別的批註。</span><span class="sxs-lookup"><span data-stu-id="3511d-125">Nullable reference types aren't new class types, but rather annotations on existing reference types.</span></span> <span data-ttu-id="3511d-126">編譯器會使用這些注釋來協助您在程式碼中找出潛在的 null 參考錯誤。</span><span class="sxs-lookup"><span data-stu-id="3511d-126">The compiler uses those annotations to help you find potential null reference errors in your code.</span></span> <span data-ttu-id="3511d-127">不可為 null 的參考型別與可為 null 的參考型別之間沒有任何執行時間差異。</span><span class="sxs-lookup"><span data-stu-id="3511d-127">There's no runtime difference between a non-nullable reference type and a nullable reference type.</span></span> <span data-ttu-id="3511d-128">編譯器不會為不可為 null 的參考型別新增任何執行時間檢查。</span><span class="sxs-lookup"><span data-stu-id="3511d-128">The compiler doesn't add any runtime checking for non-nullable reference types.</span></span> <span data-ttu-id="3511d-129">這些優點是在編譯時期分析中。</span><span class="sxs-lookup"><span data-stu-id="3511d-129">The benefits are in the compile-time analysis.</span></span> <span data-ttu-id="3511d-130">編譯器會產生警告，協助您找出並修正程式碼中的潛在 null 錯誤。</span><span class="sxs-lookup"><span data-stu-id="3511d-130">The compiler generates warnings that help you find and fix potential null errors in your code.</span></span> <span data-ttu-id="3511d-131">您可以宣告您的意圖，而編譯器會在您的程式碼違反該意圖時警告您。</span><span class="sxs-lookup"><span data-stu-id="3511d-131">You declare your intent, and the compiler warns you when your code violates that intent.</span></span>

<span data-ttu-id="3511d-132">在可為 null 的啟用內容中，編譯器會在任何參考型別的變數上執行靜態分析，可為 null 且不可為 null。</span><span class="sxs-lookup"><span data-stu-id="3511d-132">In a nullable enabled context, the compiler performs static analysis on variables of any reference type, both nullable and non-nullable.</span></span> <span data-ttu-id="3511d-133">編譯器會將每個參考變數的 null 狀態追蹤為 *非 null* 或 *可能是 null*。</span><span class="sxs-lookup"><span data-stu-id="3511d-133">The compiler tracks the null state of each reference variable as either *not null* or *maybe null*.</span></span> <span data-ttu-id="3511d-134">不可為 null 參考的預設狀態 *不是 null*。</span><span class="sxs-lookup"><span data-stu-id="3511d-134">The default state of a non-nullable reference is *not null*.</span></span> <span data-ttu-id="3511d-135">可為 null 參考的預設狀態 *可能是 null*。</span><span class="sxs-lookup"><span data-stu-id="3511d-135">The default state of a nullable reference is *maybe null*.</span></span>

<span data-ttu-id="3511d-136">不可為 null 的參考型別應該一律安全地進行取值，因為它們的 null 狀態 *不是 null*。</span><span class="sxs-lookup"><span data-stu-id="3511d-136">Non-nullable reference types should always be safe to dereference because their null state is *not null*.</span></span> <span data-ttu-id="3511d-137">若要強制執行該規則，如果不可為 null 的參考型別未初始化為非 null 值，則編譯器會發出警告。</span><span class="sxs-lookup"><span data-stu-id="3511d-137">To enforce that rule, the compiler issues warnings if a non-nullable reference type isn't initialized to a non-null value.</span></span> <span data-ttu-id="3511d-138">區域變數必須在宣告時指派。</span><span class="sxs-lookup"><span data-stu-id="3511d-138">Local variables must be assigned where they're declared.</span></span> <span data-ttu-id="3511d-139">每個函式都必須在其主體、呼叫的函式或使用欄位初始化運算式中，指派每個欄位。</span><span class="sxs-lookup"><span data-stu-id="3511d-139">Every constructor must assign every field, either in its body, a called constructor, or using a field initializer.</span></span> <span data-ttu-id="3511d-140">如果不可為 null 的參考指派給其狀態 *可能是 null*的參考，則編譯器會發出警告。</span><span class="sxs-lookup"><span data-stu-id="3511d-140">The compiler issues warnings if a non-nullable reference is assigned to a reference whose state is *maybe null*.</span></span> <span data-ttu-id="3511d-141">不過，因為不可為 null 的參考不是 *null*，所以當這些變數被解除參考時，不會發出任何警告。</span><span class="sxs-lookup"><span data-stu-id="3511d-141">However, because a non-nullable reference is *not null*, no warnings are issued when those variables are de-referenced.</span></span>

<span data-ttu-id="3511d-142">可為 null 的參考型別可以初始化或指派給 `null` 。</span><span class="sxs-lookup"><span data-stu-id="3511d-142">Nullable reference types may be initialized or assigned to `null`.</span></span> <span data-ttu-id="3511d-143">因此，靜態分析必須在取值之前判斷變數 *不是 null* 。</span><span class="sxs-lookup"><span data-stu-id="3511d-143">Therefore, static analysis must determine that a variable is *not null* before it's dereferenced.</span></span> <span data-ttu-id="3511d-144">如果可為 null 的參考判斷為 *null*，則無法將它指派給不可為 null 的參考變數。</span><span class="sxs-lookup"><span data-stu-id="3511d-144">If a nullable reference is determined to be *maybe null*, it can't be assigned to a non-nullable reference variable.</span></span> <span data-ttu-id="3511d-145">下列類別會顯示這些警告的範例：</span><span class="sxs-lookup"><span data-stu-id="3511d-145">The following class shows examples of these warnings:</span></span>

:::code language="csharp" source="snippets/shared/NullableReferenceTypes.cs" id="SnippetClassWithNullable":::

<span data-ttu-id="3511d-146">下列程式碼片段顯示使用這個類別時，編譯器發出警告的位置：</span><span class="sxs-lookup"><span data-stu-id="3511d-146">The following snippet shows where the compiler emits warnings when using this class:</span></span>

:::code language="csharp" source="snippets/shared/NullableReferenceTypes.cs" id="SnippetLocalWarnings":::

<span data-ttu-id="3511d-147">上述範例示範編譯器的靜態分析，以判斷參考變數的 null 狀態。</span><span class="sxs-lookup"><span data-stu-id="3511d-147">The preceding examples demonstrate the compiler's static analysis to determine the null state of reference variables.</span></span> <span data-ttu-id="3511d-148">編譯器會針對 null 檢查和指派套用語言規則，以通知其分析。</span><span class="sxs-lookup"><span data-stu-id="3511d-148">The compiler applies language rules for null checks and assignments to inform its analysis.</span></span>  <span data-ttu-id="3511d-149">編譯器無法對方法或屬性的語義進行假設。</span><span class="sxs-lookup"><span data-stu-id="3511d-149">The compiler can't make assumptions about the semantics of methods or properties.</span></span> <span data-ttu-id="3511d-150">如果您呼叫的方法會執行 null 檢查，則編譯器無法得知這些方法會影響變數的 null 狀態。</span><span class="sxs-lookup"><span data-stu-id="3511d-150">If you call methods that perform null checks, the compiler can't know those methods affect a variable's null state.</span></span> <span data-ttu-id="3511d-151">您可以新增多個屬性給 Api，以通知編譯器有關引數和傳回值的語法。</span><span class="sxs-lookup"><span data-stu-id="3511d-151">There are a number of attributes you can add to your APIs to inform the compiler about the semantics of arguments and return values.</span></span> <span data-ttu-id="3511d-152">這些屬性已套用至 .NET Core 程式庫中的許多常見 Api。</span><span class="sxs-lookup"><span data-stu-id="3511d-152">These attributes have been applied to many common APIs in the .NET Core libraries.</span></span> <span data-ttu-id="3511d-153">例如，已 <xref:System.String.IsNullOrEmpty%2A> 更新，且編譯器會將該方法正確地解讀為 null 檢查。</span><span class="sxs-lookup"><span data-stu-id="3511d-153">For example, <xref:System.String.IsNullOrEmpty%2A> has been updated, and the compiler correctly interprets that method as a null check.</span></span> <span data-ttu-id="3511d-154">如需適用于 null 狀態靜態分析之屬性的詳細資訊，請參閱 [可為 null 屬性](../attributes/nullable-analysis.md)的相關文章。</span><span class="sxs-lookup"><span data-stu-id="3511d-154">For more information about the attributes that apply to null state static analysis, see the article on [Nullable attributes](../attributes/nullable-analysis.md).</span></span>

## <a name="setting-the-nullable-context"></a><span data-ttu-id="3511d-155">設定可為 null 的內容</span><span class="sxs-lookup"><span data-stu-id="3511d-155">Setting the nullable context</span></span>

<span data-ttu-id="3511d-156">有兩種方式可控制可為 null 的內容。</span><span class="sxs-lookup"><span data-stu-id="3511d-156">There are two ways to control the nullable context.</span></span> <span data-ttu-id="3511d-157">在專案層級，您可以加入 `<Nullable>enable</Nullable>` 專案設定。</span><span class="sxs-lookup"><span data-stu-id="3511d-157">At the project level, you can add the `<Nullable>enable</Nullable>` project setting.</span></span> <span data-ttu-id="3511d-158">在單一 c # 原始檔中，您可以加入 `#nullable enable` pragma 來啟用可為 null 的內容。</span><span class="sxs-lookup"><span data-stu-id="3511d-158">In a single C# source file, you can add the `#nullable enable` pragma to enable the nullable context.</span></span> <span data-ttu-id="3511d-159">請參閱 [設定可為 null 策略](../../nullable-migration-strategies.md)的文章。</span><span class="sxs-lookup"><span data-stu-id="3511d-159">See the article on [setting a nullable strategy](../../nullable-migration-strategies.md).</span></span>

## <a name="c-language-specification"></a><span data-ttu-id="3511d-160">C# 語言規格</span><span class="sxs-lookup"><span data-stu-id="3511d-160">C# language specification</span></span>

<span data-ttu-id="3511d-161">如需詳細資訊，請參閱下列 [c # 語言規格](~/_csharplang/spec/introduction.md)提案：</span><span class="sxs-lookup"><span data-stu-id="3511d-161">For more information, see the following proposals for the [C# language specification](~/_csharplang/spec/introduction.md):</span></span>

- [<span data-ttu-id="3511d-162">可為 Null 的參考型別</span><span class="sxs-lookup"><span data-stu-id="3511d-162">Nullable reference types</span></span>](~/_csharplang/proposals/csharp-8.0/nullable-reference-types.md)
- [<span data-ttu-id="3511d-163">草稿可為 null 的參考型別規格</span><span class="sxs-lookup"><span data-stu-id="3511d-163">Draft nullable reference types specification</span></span>](~/_csharplang/proposals/csharp-8.0/nullable-reference-types-specification.md)

## <a name="see-also"></a><span data-ttu-id="3511d-164">另請參閱</span><span class="sxs-lookup"><span data-stu-id="3511d-164">See also</span></span>

- [<span data-ttu-id="3511d-165">C# 參考資料</span><span class="sxs-lookup"><span data-stu-id="3511d-165">C# reference</span></span>](../index.md)
- [<span data-ttu-id="3511d-166">可為 null 的實數值型別</span><span class="sxs-lookup"><span data-stu-id="3511d-166">Nullable value types</span></span>](nullable-value-types.md)
