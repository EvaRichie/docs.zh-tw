---
title: C# 的教學課程 - C# 指南
description: 第一次接觸 C#？ 了解該語言的基本概念。
ms.date: 08/06/2020
ms.openlocfilehash: 84775a436deb0958d3c05ec7d0207e76be28f27c
ms.sourcegitcommit: e7acba36517134238065e4d50bb4a1cfe47ebd06
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 09/04/2020
ms.locfileid: "89464996"
---
# <a name="a-tour-of-the-c-language"></a><span data-ttu-id="1b3f0-104">C # 語言教學課程</span><span class="sxs-lookup"><span data-stu-id="1b3f0-104">A tour of the C# language</span></span>

<span data-ttu-id="1b3f0-105">C # (發音為「看清晰的」 ) 是新式、物件導向且型別安全的程式設計語言。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-105">C# (pronounced "See Sharp") is a modern, object-oriented, and type-safe programming language.</span></span> <span data-ttu-id="1b3f0-106">C# 源自於是 C 系列語言，使用 C、C++、Java 和 JavaScript 的程式設計人員會立即感到熟悉。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-106">C# has its roots in the C family of languages and will be immediately familiar to C, C++, Java, and JavaScript programmers.</span></span> <span data-ttu-id="1b3f0-107">本教學課程概要說明 c # 8 和更早版本中語言的主要元件。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-107">This tour provides an overview of the major components of the language in C# 8 and earlier.</span></span> <span data-ttu-id="1b3f0-108">如果您想要透過互動式範例探索語言，請嘗試 [c #](../tutorials/intro-to-csharp/index.md) 教學課程簡介。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-108">If you want to explore the language through interactive examples, try the [introduction to C#](../tutorials/intro-to-csharp/index.md) tutorials.</span></span>

<span data-ttu-id="1b3f0-109">C # 是物件導向、 ***元件導向*** 的程式設計語言。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-109">C# is an object-oriented, ***component-oriented*** programming language.</span></span> <span data-ttu-id="1b3f0-110">C # 提供語言結構來直接支援這些概念，讓 c # 成為用來建立和使用軟體元件的自然語言。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-110">C# provides language constructs to directly support these concepts, making C# a natural language in which to create and use software components.</span></span> <span data-ttu-id="1b3f0-111">自其來源起，c # 已新增功能，以支援新的工作負載和新興的軟體設計作法。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-111">Since its origin, C# has added features to support new workloads and emerging software design practices.</span></span>

<span data-ttu-id="1b3f0-112">有數種 c # 功能有助於穩固且持久的應用程式的結構。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-112">Several C# features aid in the construction of robust and durable applications.</span></span> <span data-ttu-id="1b3f0-113">[***垃圾收集***](../../standard/garbage-collection/index.md) 會自動回收無法存取未使用的物件所佔用的記憶體。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-113">[***Garbage collection***](../../standard/garbage-collection/index.md) automatically reclaims memory occupied by unreachable unused objects.</span></span> <span data-ttu-id="1b3f0-114">[***例外狀況處理***](../programming-guide/exceptions/index.md) 可提供結構化且可擴充的方法來偵測和復原錯誤。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-114">[***Exception handling***](../programming-guide/exceptions/index.md) provides a structured and extensible approach to error detection and recovery.</span></span> <span data-ttu-id="1b3f0-115">[***Lambda 運算式***](../language-reference/operators/lambda-expressions.md) 支援功能性程式設計技術。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-115">[***Lambda expressions***](../language-reference/operators/lambda-expressions.md) support functional programming techniques.</span></span> <span data-ttu-id="1b3f0-116">[***查詢語法***](../linq/index.md) 會建立一般模式，以處理來自任何來源的資料。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-116">[***Query syntax***](../linq/index.md) creates a common pattern for working with data from any source.</span></span> <span data-ttu-id="1b3f0-117">[***非同步作業***](../programming-guide/concepts/async/index.md)的語言支援提供建立分散式系統的語法。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-117">Language support for [***asynchronous operations***](../programming-guide/concepts/async/index.md) provides syntax for building distributed systems.</span></span> <span data-ttu-id="1b3f0-118">[***模式***](..//pattern-matching.md) 比對會提供語法，讓您輕鬆地將資料與新式分散式系統中的演算法分隔開來。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-118">[***Pattern matching***](..//pattern-matching.md) provides syntax to easily separate data from algorithms in modern distributed systems.</span></span> <span data-ttu-id="1b3f0-119">C # 具有 [***統一的類型系統***](../programming-guide/types/index.md)。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-119">C# has a [***unified type system***](../programming-guide/types/index.md).</span></span> <span data-ttu-id="1b3f0-120">所有的 C# 型別 (包括 `int` 和 `double` 等基本型別) 都繼承自單一的 `object` 根型別。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-120">All C# types, including primitive types such as `int` and `double`, inherit from a single root `object` type.</span></span> <span data-ttu-id="1b3f0-121">所有類型都共用一組常見的作業。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-121">All types share a set of common operations.</span></span> <span data-ttu-id="1b3f0-122">任何型別的值都可以透過一致的方式來儲存、傳輸和操作。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-122">Values of any type can be stored, transported, and operated upon in a consistent manner.</span></span> <span data-ttu-id="1b3f0-123">此外，c # 也支援使用者定義的參考型別和實數值型別。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-123">Furthermore, C# supports both user-defined reference types and value types.</span></span> <span data-ttu-id="1b3f0-124">C # 允許動態設定物件和輕量結構的內嵌儲存體。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-124">C# allows dynamic allocation of objects and in-line storage of lightweight structures.</span></span>

<span data-ttu-id="1b3f0-125">C # 強調 ***版本控制*** ，以確保程式和程式庫能夠以相容的方式在一段時間內演進。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-125">C# emphasizes ***versioning*** to ensure programs and libraries can evolve over time in a compatible manner.</span></span> <span data-ttu-id="1b3f0-126">C # 的設計方面，直接受到版本控制考慮的影響包括個別 `virtual` 和修飾詞 `override` 、方法多載解析的規則，以及對明確介面成員宣告的支援。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-126">Aspects of C#'s design that were directly influenced by versioning considerations include the separate `virtual` and `override` modifiers, the rules for method overload resolution, and support for explicit interface member declarations.</span></span>

## <a name="hello-world"></a><span data-ttu-id="1b3f0-127">Hello World</span><span class="sxs-lookup"><span data-stu-id="1b3f0-127">Hello world</span></span>

<span data-ttu-id="1b3f0-128">“Hello, World” 程式通常用來介紹程式設計語言。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-128">The "Hello, World" program is traditionally used to introduce a programming language.</span></span> <span data-ttu-id="1b3f0-129">以下是以 C# 撰寫的：</span><span class="sxs-lookup"><span data-stu-id="1b3f0-129">Here it is in C#:</span></span>

:::code language="csharp" interactive="try-dotnet" source="./snippets/shared/HelloWorld.cs":::

<span data-ttu-id="1b3f0-130">“Hello, World” 程式的開頭為 `using` 指示詞，會參考 `System` 命名空間。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-130">The "Hello, World" program starts with a `using` directive that references the `System` namespace.</span></span> <span data-ttu-id="1b3f0-131">命名空間提供組織 C# 程式和程式庫的階層式方法。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-131">Namespaces provide a hierarchical means of organizing C# programs and libraries.</span></span> <span data-ttu-id="1b3f0-132">命名空間包含型別和其他命名空間，例如 `System` 命名空間包含數個型別 (如程式中參考的 `Console` 類別)，和數個其他命名空間 (如 `IO` 和 `Collections`)。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-132">Namespaces contain types and other namespaces—for example, the `System` namespace contains a number of types, such as the `Console` class referenced in the program, and a number of other namespaces, such as `IO` and `Collections`.</span></span> <span data-ttu-id="1b3f0-133">使用 `using` 指示詞參考指定的命名空間，就能以非限定的方式使用屬於該命名空間成員的型別。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-133">A `using` directive that references a given namespace enables unqualified use of the types that are members of that namespace.</span></span> <span data-ttu-id="1b3f0-134">因為 `using` 指示詞的緣故，該程式可以使用 `Console.WriteLine` 當作 `System.Console.WriteLine` 的縮寫。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-134">Because of the `using` directive, the program can use `Console.WriteLine` as shorthand for `System.Console.WriteLine`.</span></span>

<span data-ttu-id="1b3f0-135">“Hello, World” 程式宣告的 `Hello` 類別包含單一成員，即名為 `Main` 的方法。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-135">The `Hello` class declared by the "Hello, World" program has a single member, the method named `Main`.</span></span> <span data-ttu-id="1b3f0-136">`Main`使用修飾詞宣告方法 `static` 。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-136">The `Main` method is declared with the `static` modifier.</span></span> <span data-ttu-id="1b3f0-137">執行個體方法可以使用關鍵字 `this` 參考特定的封入物件執行個體，但靜態方法卻不需要參考特定物件即可運作。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-137">While instance methods can reference a particular enclosing object instance using the keyword `this`, static methods operate without reference to a particular object.</span></span> <span data-ttu-id="1b3f0-138">依照慣例，名為的靜態方法可 `Main` 作為 c # 程式的進入點。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-138">By convention, a static method named `Main` serves as the entry point of a C# program.</span></span>

<span data-ttu-id="1b3f0-139">程式的輸出是由 `System` 命名空間中 `Console` 類別的 `WriteLine` 方法產生。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-139">The output of the program is produced by the `WriteLine` method of the `Console` class in the `System` namespace.</span></span> <span data-ttu-id="1b3f0-140">此類別是由標準類別程式庫提供，根據預設，編譯器會自動參考此程式庫。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-140">This class is provided by the standard class libraries, which, by default, are automatically referenced by the compiler.</span></span>

## <a name="types-and-variables"></a><span data-ttu-id="1b3f0-141">型別與變數</span><span class="sxs-lookup"><span data-stu-id="1b3f0-141">Types and variables</span></span>

<span data-ttu-id="1b3f0-142">C# 中有兩種型別：*實值型別*和*參考型別*。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-142">There are two kinds of types in C#: *value types* and *reference types*.</span></span> <span data-ttu-id="1b3f0-143">實值型別的變數直接包含其資料，而參考型別的變數則將參考儲存到其資料，後者即是物件。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-143">Variables of value types directly contain their data whereas variables of reference types store references to their data, the latter being known as objects.</span></span> <span data-ttu-id="1b3f0-144">使用參考型別時，可能會有兩個變數參考相同的物件，而且對某個變數進行的作業可能會影響另一個變數所參考的物件。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-144">With reference types, it's possible for two variables to reference the same object and possible for operations on one variable to affect the object referenced by the other variable.</span></span> <span data-ttu-id="1b3f0-145">使用實值型別時，每個變數都有自己的資料複本，而且在一個上進行的作業不可能會影響其他 (`ref` 但 `out`) 的和參數變數。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-145">With value types, the variables each have their own copy of the data, and it isn't possible for operations on one to affect the other (except for `ref` and `out` parameter variables).</span></span>

<span data-ttu-id="1b3f0-146">***識別碼***是變數名稱。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-146">An ***identifier*** is a variable name.</span></span> <span data-ttu-id="1b3f0-147">識別碼是 unicode 字元序列，不含任何空白。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-147">An identifier is a sequence of unicode characters without any whitespace.</span></span> <span data-ttu-id="1b3f0-148">如果識別碼前面加上，則識別碼可以是 c # 保留字 `@` 。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-148">An identifier may be a C# reserved word, if it is prefixed by `@`.</span></span> <span data-ttu-id="1b3f0-149">當與其他語言互動時，這會很有用。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-149">That can be useful when interacting with other languages.</span></span>

<span data-ttu-id="1b3f0-150">C # 的實值型別會進一步分成 *簡單類型*、 *列舉類型*、 *結構類型*、 *可為 null* 的實值型別和 *元組實值*型別。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-150">C#'s value types are further divided into *simple types*, *enum types*, *struct types*, *nullable value types* and *tuple value types*.</span></span> <span data-ttu-id="1b3f0-151">C # 的參考型別會進一步分割成 *類別類型*、 *介面類別型*、 *陣列類型*和 *委派類型*。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-151">C#'s reference types are further divided into *class types*, *interface types*, *array types*, and *delegate types*.</span></span>

<span data-ttu-id="1b3f0-152">下列大綱概要說明 c # 的型別系統。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-152">The following outline provides an overview of C#'s type system.</span></span>

- [<span data-ttu-id="1b3f0-153">值類型</span><span class="sxs-lookup"><span data-stu-id="1b3f0-153">Value types</span></span>](../language-reference/builtin-types/value-types.md)
  - [<span data-ttu-id="1b3f0-154">簡單型別</span><span class="sxs-lookup"><span data-stu-id="1b3f0-154">Simple types</span></span>](../language-reference/builtin-types/value-types.md#built-in-value-types)
    - <span data-ttu-id="1b3f0-155">[帶正負](../language-reference/builtin-types/integral-numeric-types.md)號的整數： `sbyte` 、 `short` 、 `int` 、 `long`</span><span class="sxs-lookup"><span data-stu-id="1b3f0-155">[Signed integral](../language-reference/builtin-types/integral-numeric-types.md): `sbyte`, `short`, `int`, `long`</span></span>
    - <span data-ttu-id="1b3f0-156">[不帶正負號的整數](../language-reference/builtin-types/integral-numeric-types.md)： `byte` 、 `ushort` 、 `uint` 、 `ulong`</span><span class="sxs-lookup"><span data-stu-id="1b3f0-156">[Unsigned integral](../language-reference/builtin-types/integral-numeric-types.md): `byte`, `ushort`, `uint`, `ulong`</span></span>
    - <span data-ttu-id="1b3f0-157">[Unicode 字元](../../standard/base-types/character-encoding-introduction.md)： `char` ，代表 utf-16 程式碼單位</span><span class="sxs-lookup"><span data-stu-id="1b3f0-157">[Unicode characters](../../standard/base-types/character-encoding-introduction.md): `char`, which represents a UTF-16 code unit</span></span>
    - <span data-ttu-id="1b3f0-158">[IEEE 二進位浮點數](../language-reference/builtin-types/floating-point-numeric-types.md)： `float` 、 `double`</span><span class="sxs-lookup"><span data-stu-id="1b3f0-158">[IEEE binary floating-point](../language-reference/builtin-types/floating-point-numeric-types.md): `float`, `double`</span></span>
    - <span data-ttu-id="1b3f0-159">[高精確度十進位浮點數](../language-reference/builtin-types/floating-point-numeric-types.md)： `decimal`</span><span class="sxs-lookup"><span data-stu-id="1b3f0-159">[High-precision decimal floating-point](../language-reference/builtin-types/floating-point-numeric-types.md): `decimal`</span></span>
    - <span data-ttu-id="1b3f0-160">`bool`代表布林值的布林值：-或的值。 `true``false`</span><span class="sxs-lookup"><span data-stu-id="1b3f0-160">Boolean: `bool`, which represents Boolean values—values that are either `true` or `false`</span></span>
  - [<span data-ttu-id="1b3f0-161">列舉類型</span><span class="sxs-lookup"><span data-stu-id="1b3f0-161">Enum types</span></span>](../language-reference/builtin-types/enum.md)
    - <span data-ttu-id="1b3f0-162">表單的使用者定義類型 `enum E {...}` 。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-162">User-defined types of the form `enum E {...}`.</span></span> <span data-ttu-id="1b3f0-163">`enum` 型別是包含具名常數的不同型別。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-163">An `enum` type is a distinct type with named constants.</span></span> <span data-ttu-id="1b3f0-164">每個 `enum` 型別都具有一個基礎型別，其必須是八種整數型別之一。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-164">Every `enum` type has an underlying type, which must be one of the eight integral types.</span></span> <span data-ttu-id="1b3f0-165">`enum` 型別的值組與基礎型別的值組相同。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-165">The set of values of an `enum` type is the same as the set of values of the underlying type.</span></span>
  - [<span data-ttu-id="1b3f0-166">結構型別</span><span class="sxs-lookup"><span data-stu-id="1b3f0-166">Struct types</span></span>](../language-reference/builtin-types/struct.md)
    - <span data-ttu-id="1b3f0-167">使用者定義型別，格式為 `struct S {...}`</span><span class="sxs-lookup"><span data-stu-id="1b3f0-167">User-defined types of the form `struct S {...}`</span></span>
  - [<span data-ttu-id="1b3f0-168">可為 Null 的實值型別</span><span class="sxs-lookup"><span data-stu-id="1b3f0-168">Nullable value types</span></span>](../language-reference/builtin-types/nullable-value-types.md)
    - <span data-ttu-id="1b3f0-169">含有 `null` 值的所有其他數值型別的擴充</span><span class="sxs-lookup"><span data-stu-id="1b3f0-169">Extensions of all other value types with a `null` value</span></span>
  - [<span data-ttu-id="1b3f0-170">元組實數值型別</span><span class="sxs-lookup"><span data-stu-id="1b3f0-170">Tuple value types</span></span>](../language-reference/builtin-types/value-tuples.md)
    - <span data-ttu-id="1b3f0-171">使用者定義型別，格式為 `(T1, T2, ...)`</span><span class="sxs-lookup"><span data-stu-id="1b3f0-171">User-defined types of the form `(T1, T2, ...)`</span></span>
- [<span data-ttu-id="1b3f0-172">參考型別</span><span class="sxs-lookup"><span data-stu-id="1b3f0-172">Reference types</span></span>](../language-reference/keywords/reference-types.md)
  - [<span data-ttu-id="1b3f0-173">類別類型</span><span class="sxs-lookup"><span data-stu-id="1b3f0-173">Class types</span></span>](../language-reference/keywords/class.md)
    - <span data-ttu-id="1b3f0-174">所有其他型別的基底類別︰`object`</span><span class="sxs-lookup"><span data-stu-id="1b3f0-174">Ultimate base class of all other types: `object`</span></span>
    - <span data-ttu-id="1b3f0-175">[Unicode 字串](../../standard/base-types/character-encoding-introduction.md)： `string` ，代表一系列的 utf-16 程式碼單位</span><span class="sxs-lookup"><span data-stu-id="1b3f0-175">[Unicode strings](../../standard/base-types/character-encoding-introduction.md): `string`, which represents a sequence of UTF-16 code units</span></span>
    - <span data-ttu-id="1b3f0-176">使用者定義型別，格式為 `class C {...}`</span><span class="sxs-lookup"><span data-stu-id="1b3f0-176">User-defined types of the form `class C {...}`</span></span>
  - [<span data-ttu-id="1b3f0-177">介面類型</span><span class="sxs-lookup"><span data-stu-id="1b3f0-177">Interface types</span></span>](../language-reference/keywords/interface.md)
    - <span data-ttu-id="1b3f0-178">使用者定義型別，格式為 `interface I {...}`</span><span class="sxs-lookup"><span data-stu-id="1b3f0-178">User-defined types of the form `interface I {...}`</span></span>
  - [<span data-ttu-id="1b3f0-179">陣列類型</span><span class="sxs-lookup"><span data-stu-id="1b3f0-179">Array types</span></span>](../programming-guide/arrays/index.md)
    - <span data-ttu-id="1b3f0-180">一維、多維度和不規則。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-180">Single-dimensional, multi-dimensional and jagged.</span></span> <span data-ttu-id="1b3f0-181">例如： `int[]` 、 `int[,]` 和 `int[][]`</span><span class="sxs-lookup"><span data-stu-id="1b3f0-181">For example: `int[]`, `int[,]`, and `int[][]`</span></span>
  - [<span data-ttu-id="1b3f0-182">委派型別</span><span class="sxs-lookup"><span data-stu-id="1b3f0-182">Delegate types</span></span>](../language-reference/builtin-types/reference-types.md#the-delegate-type)
    - <span data-ttu-id="1b3f0-183">使用者定義型別，格式為 `delegate int D(...)`</span><span class="sxs-lookup"><span data-stu-id="1b3f0-183">User-defined types of the form `delegate int D(...)`</span></span>

<span data-ttu-id="1b3f0-184">C# 程式使用*型別宣告*來建立新型別。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-184">C# programs use *type declarations* to create new types.</span></span> <span data-ttu-id="1b3f0-185">型別宣告指定新型別的名稱成員。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-185">A type declaration specifies the name and the members of the new type.</span></span> <span data-ttu-id="1b3f0-186">C # 的型別有六種：類別類型、結構類型、介面類別型、列舉類型、委派類型和元組實數值型別。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-186">Six of C#'s categories of types are user-definable: class types, struct types, interface types, enum types, delegate types and tuple value types.</span></span>

- <span data-ttu-id="1b3f0-187">`class` 型別定義資料結構，其中包含資料成員 (欄位) 和函式成員 (方法、屬性及其他)。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-187">A `class` type defines a data structure that contains data members (fields) and function members (methods, properties, and others).</span></span> <span data-ttu-id="1b3f0-188">類別型別支援單一繼承和多型，這些是可供衍生類別將基底類別延伸及特製化的機制。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-188">Class types support single inheritance and polymorphism, mechanisms whereby derived classes can extend and specialize base classes.</span></span>
- <span data-ttu-id="1b3f0-189">`struct` 型別與類別型別相似，它代表具有資料成員和函式成員的結構。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-189">A `struct` type is similar to a class type in that it represents a structure with data members and function members.</span></span> <span data-ttu-id="1b3f0-190">不過，不同于類別，結構是實數值型別，通常不需要堆積配置。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-190">However, unlike classes, structs are value types and don't typically require heap allocation.</span></span> <span data-ttu-id="1b3f0-191">結構類型不支援使用者指定的繼承，且所有結構類型都隱含地繼承自型別 `object` 。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-191">Struct types don't support user-specified inheritance, and all struct types implicitly inherit from type `object`.</span></span>
- <span data-ttu-id="1b3f0-192">類型會將 `interface` 合約定義為一組命名的公用成員。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-192">An `interface` type defines a contract as a named set of public members.</span></span> <span data-ttu-id="1b3f0-193">執行的 `class` 或 `struct` `interface` 必須提供介面成員的實作為。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-193">A `class` or `struct` that implements an `interface` must provide implementations of the interface's members.</span></span> <span data-ttu-id="1b3f0-194">`interface` 可以繼承自多個基底介面，`class` 或 `struct`可實作多個介面。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-194">An `interface` may inherit from multiple base interfaces, and a `class` or `struct` may implement multiple interfaces.</span></span>
- <span data-ttu-id="1b3f0-195">`delegate` 型別代表對方法的參考，其中含有特定參數清單與傳回型別。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-195">A `delegate` type represents references to methods with a particular parameter list and return type.</span></span> <span data-ttu-id="1b3f0-196">委派讓您可將方法視為實體，而實體能指派給變數或當作參數來傳遞。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-196">Delegates make it possible to treat methods as entities that can be assigned to variables and passed as parameters.</span></span> <span data-ttu-id="1b3f0-197">委派類似函式語言提供的函式型別。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-197">Delegates are analogous to function types provided by functional languages.</span></span> <span data-ttu-id="1b3f0-198">它們也與某些其他語言中的函式指標概念類似。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-198">They're also similar to the concept of function pointers found in some other languages.</span></span> <span data-ttu-id="1b3f0-199">與函式指標不同的是，委派是物件導向且型別安全的。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-199">Unlike function pointers, delegates are object-oriented and type-safe.</span></span>

<span data-ttu-id="1b3f0-200">`class`、、 `struct` `interface` 和 `delegate` 類型全都支援泛型，因此可以使用其他類型進行參數化。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-200">The `class`, `struct`, `interface`, and `delegate` types all support generics, whereby they can be parameterized with other types.</span></span>

<span data-ttu-id="1b3f0-201">C # 支援任何類型的單一維度和多維度陣列。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-201">C# supports single-dimensional and multi-dimensional arrays of any type.</span></span> <span data-ttu-id="1b3f0-202">不同于上面所列的類型，不需要先宣告陣列類型就可以使用它們。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-202">Unlike the types listed above, array types don't have to be declared before they can be used.</span></span> <span data-ttu-id="1b3f0-203">而陣列型別的建構方法，是在型別名稱之後加上方括弧。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-203">Instead, array types are constructed by following a type name with square brackets.</span></span> <span data-ttu-id="1b3f0-204">例如，是的一維陣列，是的二維陣列，且是一維陣列的一 `int[]` `int` `int[,]` `int` `int[][]` 維陣列，或的「不規則」陣列 `int` 。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-204">For example, `int[]` is a single-dimensional array of `int`, `int[,]` is a two-dimensional array of `int`, and `int[][]` is a single-dimensional array of single-dimensional arrays, or a "jagged" array, of `int`.</span></span>

<span data-ttu-id="1b3f0-205">可為 null 的類型不需要個別的定義。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-205">Nullable types don't require a separate definition.</span></span> <span data-ttu-id="1b3f0-206">針對每一個不可為 null 的型 `T` 別，都有一個對應的可為 null 型 `T?` 別，可以保留額外的值 `null` 。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-206">For each non-nullable type `T`, there's a corresponding nullable type `T?`, which can hold an additional value, `null`.</span></span> <span data-ttu-id="1b3f0-207">比方說， `int?` 是可以保存任何32位整數或值的型別 `null` ，而且 `string?` 是可保存任何或值的型別 `string` `null` 。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-207">For instance, `int?` is a type that can hold any 32-bit integer or the value `null`, and `string?` is a type that can hold any `string` or the value `null`.</span></span>

<span data-ttu-id="1b3f0-208">C # 的型別系統是統一的，因此任何型別的值都可以視為 `object` 。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-208">C#'s type system is unified such that a value of any type can be treated as an `object`.</span></span> <span data-ttu-id="1b3f0-209">C# 中的每個型別都直接或間接衍生自 `object` 類別型別，而 `object` 是所有型別的基底類別。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-209">Every type in C# directly or indirectly derives from the `object` class type, and `object` is the ultimate base class of all types.</span></span> <span data-ttu-id="1b3f0-210">參考型別的值之所以會視為物件，只是將這些值當作 `object` 型別來檢視。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-210">Values of reference types are treated as objects simply by viewing the values as type `object`.</span></span> <span data-ttu-id="1b3f0-211">數值型別的值之所以會視為物件，只是透過執行 *boxing* 和 *unboxing* 作業。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-211">Values of value types are treated as objects by performing *boxing* and *unboxing operations*.</span></span> <span data-ttu-id="1b3f0-212">在下列範例中，`int` 值會轉換成 `object`，並再次轉換回 `int`。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-212">In the following example, an `int` value is converted to `object` and back again to `int`.</span></span>

:::code language="csharp" source="./snippets/shared/Program.cs" ID="boxing" :::

<span data-ttu-id="1b3f0-213">當實值型別的值指派給 `object` 參考時，會配置 "box" 來保存該值。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-213">When a value of a value type is assigned to an `object` reference, a "box" is allocated to hold the value.</span></span> <span data-ttu-id="1b3f0-214">該方塊是參考型別的實例，而值會複製到該方塊中。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-214">That box is an instance of a reference type, and the value is copied into that box.</span></span> <span data-ttu-id="1b3f0-215">相反地，當 `object` 參考轉換成實值型別時，就會檢查參考的 `object` 是正確值型別的方塊。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-215">Conversely, when an `object` reference is cast to a value type, a check is made that the referenced `object` is a box of the correct value type.</span></span> <span data-ttu-id="1b3f0-216">如果檢查成功，則會將方塊中的值複製到數值型別。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-216">If the check succeeds, the value in the box is copied to the value type.</span></span>

<span data-ttu-id="1b3f0-217">C # 的統一型別系統實際上表示實值型別被視為 `object` 參考「視需要」。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-217">C#'s unified type system effectively means that value types are treated as `object` references "on demand."</span></span> <span data-ttu-id="1b3f0-218">由於統一的一般用途程式庫 `object` 可以與衍生自的所有型別搭配使用 `object` ，包括參考型別和實值型別。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-218">Because of the unification, general-purpose libraries that use type `object` can be used with all types that derive from `object`, including both reference types and value types.</span></span>

<span data-ttu-id="1b3f0-219">C# 中有數種*變數*，包括欄位、陣列元素、區域變數和參數。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-219">There are several kinds of *variables* in C#, including fields, array elements, local variables, and parameters.</span></span> <span data-ttu-id="1b3f0-220">變數代表儲存位置。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-220">Variables represent storage locations.</span></span> <span data-ttu-id="1b3f0-221">每個變數都有一種類型，可判斷哪些值可以儲存在變數中，如下所示。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-221">Every variable has a type that determines what values can be stored in the variable, as shown below.</span></span>

- <span data-ttu-id="1b3f0-222">不可為 Null 的實值型別</span><span class="sxs-lookup"><span data-stu-id="1b3f0-222">Non-nullable value type</span></span>
  - <span data-ttu-id="1b3f0-223">該型別的值</span><span class="sxs-lookup"><span data-stu-id="1b3f0-223">A value of that exact type</span></span>
- <span data-ttu-id="1b3f0-224">可為 Null 的實值型別</span><span class="sxs-lookup"><span data-stu-id="1b3f0-224">Nullable value type</span></span>
  - <span data-ttu-id="1b3f0-225">`null` 值或該型別的值</span><span class="sxs-lookup"><span data-stu-id="1b3f0-225">A `null` value or a value of that exact type</span></span>
- <span data-ttu-id="1b3f0-226">物件 (object)</span><span class="sxs-lookup"><span data-stu-id="1b3f0-226">object</span></span>
  - <span data-ttu-id="1b3f0-227">`null` 參考、任一參考型別之物件的參考，或是任一實值型別的 Boxed 值的參考</span><span class="sxs-lookup"><span data-stu-id="1b3f0-227">A `null` reference, a reference to an object of any reference type, or a reference to a boxed value of any value type</span></span>
- <span data-ttu-id="1b3f0-228">類別型別</span><span class="sxs-lookup"><span data-stu-id="1b3f0-228">Class type</span></span>
  - <span data-ttu-id="1b3f0-229">`null` 參考、該類別型別之執行個體的參考，或衍生自該類別型別之類別執行個體的參考</span><span class="sxs-lookup"><span data-stu-id="1b3f0-229">A `null` reference, a reference to an instance of that class type, or a reference to an instance of a class derived from that class type</span></span>
- <span data-ttu-id="1b3f0-230">介面類型</span><span class="sxs-lookup"><span data-stu-id="1b3f0-230">Interface type</span></span>
  - <span data-ttu-id="1b3f0-231">`null` 參考、實作該介面型別之類別型別的執行個體的參考，或實作該介面型別之實值型別的 Boxed 值的參考</span><span class="sxs-lookup"><span data-stu-id="1b3f0-231">A `null` reference, a reference to an instance of a class type that implements that interface type, or a reference to a boxed value of a value type that implements that interface type</span></span>
- <span data-ttu-id="1b3f0-232">陣列型別</span><span class="sxs-lookup"><span data-stu-id="1b3f0-232">Array type</span></span>
  - <span data-ttu-id="1b3f0-233">`null` 參考、該陣列型別之執行個體的參考，或相容的陣列型別之執行個體的參考</span><span class="sxs-lookup"><span data-stu-id="1b3f0-233">A `null` reference, a reference to an instance of that array type, or a reference to an instance of a compatible array type</span></span>
- <span data-ttu-id="1b3f0-234">委派類型</span><span class="sxs-lookup"><span data-stu-id="1b3f0-234">Delegate type</span></span>
  - <span data-ttu-id="1b3f0-235">`null` 參考或相容的委派類型之執行個體的參考</span><span class="sxs-lookup"><span data-stu-id="1b3f0-235">A `null` reference or a reference to an instance of a compatible delegate type</span></span>

## <a name="program-structure"></a><span data-ttu-id="1b3f0-236">程式結構</span><span class="sxs-lookup"><span data-stu-id="1b3f0-236">Program structure</span></span>

<span data-ttu-id="1b3f0-237">C # 中的重要組織概念是 [***程式***](../programming-guide/inside-a-program/index.md)、 [***命名空間***](../programming-guide/namespaces/index.md)、 [***類型***](../programming-guide/types/index.md)、 [***成員***](../programming-guide/classes-and-structs/members.md)和 [***元件***](../../standard/assembly/index.md)。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-237">The key organizational concepts in C# are [***programs***](../programming-guide/inside-a-program/index.md), [***namespaces***](../programming-guide/namespaces/index.md), [***types***](../programming-guide/types/index.md), [***members***](../programming-guide/classes-and-structs/members.md), and [***assemblies***](../../standard/assembly/index.md).</span></span> <span data-ttu-id="1b3f0-238">程式宣告型別，其中包含成員並可以依據命名空間分組。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-238">Programs declare types, which contain members and can be organized into namespaces.</span></span> <span data-ttu-id="1b3f0-239">類別、結構和介面是類型的範例。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-239">Classes, structs, and interfaces are examples of types.</span></span> <span data-ttu-id="1b3f0-240">欄位、方法、屬性及事件都是成員的範例。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-240">Fields, methods, properties, and events are examples of members.</span></span> <span data-ttu-id="1b3f0-241">編譯 c # 程式時，它們實際上會封裝成元件。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-241">When C# programs are compiled, they're physically packaged into assemblies.</span></span> <span data-ttu-id="1b3f0-242">組件通常具有副檔名 `.exe` 或 `.dll`，其分別在於實作「應用程式」\*\*\*\*\*\* 或「程式庫」\*\*\*\*\*\*。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-242">Assemblies typically have the file extension `.exe` or `.dll`, depending on whether they implement ***applications*** or ***libraries***, respectively.</span></span>

<span data-ttu-id="1b3f0-243">舉例來說，請考慮包含下列程式碼的元件：</span><span class="sxs-lookup"><span data-stu-id="1b3f0-243">As a small example, consider an assembly that contains the following code:</span></span>

:::code language="csharp" source="./snippets/shared/AcmeStack.cs":::

<span data-ttu-id="1b3f0-244">此類別的完整名稱是 `Acme.Collections.Stack`。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-244">The fully qualified name of this class is `Acme.Collections.Stack`.</span></span> <span data-ttu-id="1b3f0-245">該類別包含數個成員︰一個名為 `top` 的欄位、兩個名為 `Push` 和 `Pop` 的方法以及名為 `Entry` 的巢狀類別。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-245">The class contains several members: a field named `top`, two methods named `Push` and `Pop`, and a nested class named `Entry`.</span></span> <span data-ttu-id="1b3f0-246">`Entry` 類別更包含三個成員︰一個名為 `next` 的欄位、一個名為 `data` 的欄位以及建構函式。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-246">The `Entry` class further contains three members: a field named `next`, a field named `data`, and a constructor.</span></span> <span data-ttu-id="1b3f0-247">`Stack`是*泛型*類別。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-247">The `Stack` is a *generic* class.</span></span> <span data-ttu-id="1b3f0-248">它有一個型別參數， `T` 會在使用時以具象型別取代。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-248">It has one type parameter, `T` that is replaced with a concrete type when it's used.</span></span>

> [!NOTE]
> <span data-ttu-id="1b3f0-249">*堆疊*是「first in last out」 (FILO) 收集。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-249">A *stack* is a "first in - last out" (FILO) collection.</span></span> <span data-ttu-id="1b3f0-250">新的元素會新增至堆疊的頂端。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-250">New elements are added to the top of the stack.</span></span> <span data-ttu-id="1b3f0-251">移除專案時，它會從堆疊的最上方移除。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-251">When an element is removed, it is removed from the top of the stack.</span></span>

<span data-ttu-id="1b3f0-252">組件包含的可執行程式碼採用中繼語言 (IL) 指令形式，而符號資訊採用中繼資料形式。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-252">Assemblies contain executable code in the form of Intermediate Language (IL) instructions, and symbolic information in the form of metadata.</span></span> <span data-ttu-id="1b3f0-253">在執行之前，即時 (JIT) 編譯器的 .NET Common Language Runtime 會將元件中的 IL 程式碼轉換成處理器特定的程式碼。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-253">Before it's executed, the Just-In-Time (JIT) compiler of .NET Common Language Runtime converts the IL code in an assembly to processor-specific code.</span></span>

<span data-ttu-id="1b3f0-254">由於元件是包含程式碼和中繼資料的自我描述功能單位，因此 c # 中不需要指示詞 `#include` 和標頭檔。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-254">Because an assembly is a self-describing unit of functionality containing both code and metadata, there's no need for `#include` directives and header files in C#.</span></span> <span data-ttu-id="1b3f0-255">特定組件中所包含的公用型別和成員只能在編譯程式時，使用 C# 程式來參考該組件。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-255">The public types and members contained in a particular assembly are made available in a C# program simply by referencing that assembly when compiling the program.</span></span> <span data-ttu-id="1b3f0-256">例如，此程式使用來自 `acme.dll` 組件的 `Acme.Collections.Stack` 類別︰</span><span class="sxs-lookup"><span data-stu-id="1b3f0-256">For example, this program uses the `Acme.Collections.Stack` class from the `acme.dll` assembly:</span></span>

:::code language="csharp" source="./snippets/shared/StackUsage.cs":::

<span data-ttu-id="1b3f0-257">若要編譯此程式，您必須 *參考* 包含先前範例中所定義之堆疊類別的元件。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-257">To compile this program, you would need to *reference* the assembly containing the stack class defined in the earlier example.</span></span>

<span data-ttu-id="1b3f0-258">C # 程式可以儲存在數個原始程式檔中。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-258">C# programs can be stored in several source files.</span></span> <span data-ttu-id="1b3f0-259">編譯 c # 程式時，所有的原始程式檔都會一起處理，而原始程式檔可以自由地互相參考。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-259">When a C# program is compiled, all of the source files are processed together, and the source files can freely reference each other.</span></span> <span data-ttu-id="1b3f0-260">就概念而言，在處理之前，所有的原始程式檔都會串連成一個大型檔案。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-260">Conceptually, it's as if all the source files were concatenated into one large file before being processed.</span></span> <span data-ttu-id="1b3f0-261">C # 中永遠不需要向前宣告，因為有一些例外狀況，宣告順序並不重要。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-261">Forward declarations are never needed in C# because, with few exceptions, declaration order is insignificant.</span></span> <span data-ttu-id="1b3f0-262">C # 不會限制原始程式檔僅宣告一個公用類型，也不會要求來源檔案的名稱符合原始程式檔中宣告的類型。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-262">C# doesn't limit a source file to declaring only one public type nor does it require the name of the source file to match a type declared in the source file.</span></span>

<span data-ttu-id="1b3f0-263">本教學課程中的後續文章將說明這些組織區塊。</span><span class="sxs-lookup"><span data-stu-id="1b3f0-263">Further articles in this tour explain these organizational blocks.</span></span>

>[!div class="step-by-step"]
>[<span data-ttu-id="1b3f0-264">下一個</span><span class="sxs-lookup"><span data-stu-id="1b3f0-264">Next</span></span>](types.md)
