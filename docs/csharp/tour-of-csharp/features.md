---
title: 'C #-主要語言領域教學課程'
description: 第一次接觸 C#？ 了解該語言的基本概念。
ms.date: 08/06/2020
ms.openlocfilehash: f0e9bff144cc3c853a82f2ee6b400049df60683d
ms.sourcegitcommit: 7476c20d2f911a834a00b8a7f5e8926bae6804d9
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/11/2020
ms.locfileid: "88068510"
---
# <a name="major-language-areas"></a><span data-ttu-id="13077-104">主要語言區域</span><span class="sxs-lookup"><span data-stu-id="13077-104">Major language areas</span></span>

## <a name="arrays-collections-and-linq"></a><span data-ttu-id="13077-105">陣列、集合和 LINQ</span><span class="sxs-lookup"><span data-stu-id="13077-105">Arrays, collections, and LINQ</span></span>

<span data-ttu-id="13077-106">C # 和 .NET 提供許多不同的集合類型。</span><span class="sxs-lookup"><span data-stu-id="13077-106">C# and .NET provide many different collection types.</span></span> <span data-ttu-id="13077-107">陣列具有語言所定義的語法。</span><span class="sxs-lookup"><span data-stu-id="13077-107">Arrays have syntax defined by the language.</span></span> <span data-ttu-id="13077-108">泛型集合類型會列在 <xref:System.Collections.Generic?displayProperty=fullName> 命名空間中。</span><span class="sxs-lookup"><span data-stu-id="13077-108">Generic collection types are listed in the <xref:System.Collections.Generic?displayProperty=fullName> namespace.</span></span> <span data-ttu-id="13077-109">專門的集合包含 <xref:System.Span%601?displayProperty=nameWithType> 存取堆疊框架上的連續記憶體，以及 <xref:System.Memory%601?displayProperty=nameWithType> 存取受控堆積上的連續記憶體。</span><span class="sxs-lookup"><span data-stu-id="13077-109">Specialized collections include <xref:System.Span%601?displayProperty=nameWithType> for accessing continuous memory on the stack frame, and <xref:System.Memory%601?displayProperty=nameWithType> for accessing continuous memory on the managed heap.</span></span> <span data-ttu-id="13077-110">所有集合（包括陣列、 <xref:System.Span%601> 和） <xref:System.Memory%601> 共用反復專案的統一原則。</span><span class="sxs-lookup"><span data-stu-id="13077-110">All collections, including arrays, <xref:System.Span%601>, and <xref:System.Memory%601> share a unifying principle for iteration.</span></span> <span data-ttu-id="13077-111">您會使用 <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> 介面。</span><span class="sxs-lookup"><span data-stu-id="13077-111">You use the <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> interface.</span></span> <span data-ttu-id="13077-112">這個統一的原則表示任何集合類型都可以搭配 LINQ 查詢或其他演算法使用。</span><span class="sxs-lookup"><span data-stu-id="13077-112">This unifying principle means that any of the collection types can be used with LINQ queries or other algorithms.</span></span> <span data-ttu-id="13077-113">您使用撰寫方法 <xref:System.Collections.Generic.IEnumerable%601> ，而這些演算法適用于任何集合。</span><span class="sxs-lookup"><span data-stu-id="13077-113">You write methods using <xref:System.Collections.Generic.IEnumerable%601> and those algorithms work with any collection.</span></span>

### <a name="arrays"></a><span data-ttu-id="13077-114">陣列</span><span class="sxs-lookup"><span data-stu-id="13077-114">Arrays</span></span>

<span data-ttu-id="13077-115">[***陣列***](../programming-guide/arrays/index.md)是一種資料結構，其中包含一些可透過計算索引存取的變數。</span><span class="sxs-lookup"><span data-stu-id="13077-115">An [***array***](../programming-guide/arrays/index.md) is a data structure that contains a number of variables that are accessed through computed indices.</span></span> <span data-ttu-id="13077-116">陣列中包含的變數（也稱為陣列的***元素***）都是相同的類型。</span><span class="sxs-lookup"><span data-stu-id="13077-116">The variables contained in an array, also called the ***elements*** of the array, are all of the same type.</span></span> <span data-ttu-id="13077-117">這個型別稱為數組的***元素型***別。</span><span class="sxs-lookup"><span data-stu-id="13077-117">This type is called the ***element type*** of the array.</span></span>

<span data-ttu-id="13077-118">陣列型別是參考型別，而陣列變數的宣告只是預留空間給陣列執行個體的參考。</span><span class="sxs-lookup"><span data-stu-id="13077-118">Array types are reference types, and the declaration of an array variable simply sets aside space for a reference to an array instance.</span></span> <span data-ttu-id="13077-119">實際的陣列實例會使用運算子，在執行時間動態建立 `new` 。</span><span class="sxs-lookup"><span data-stu-id="13077-119">Actual array instances are created dynamically at runtime using the `new` operator.</span></span> <span data-ttu-id="13077-120">作業 `new` 會指定新陣列實例的***長度***，然後在實例的存留期內修正此問題。</span><span class="sxs-lookup"><span data-stu-id="13077-120">The `new` operation specifies the ***length*** of the new array instance, which is then fixed for the lifetime of the instance.</span></span> <span data-ttu-id="13077-121">陣列元素的索引範圍在 `0` 到 `Length - 1` 之間。</span><span class="sxs-lookup"><span data-stu-id="13077-121">The indices of the elements of an array range from `0` to `Length - 1`.</span></span> <span data-ttu-id="13077-122">`new` 運算子會自動將陣列的元素初始化為其預設值，例如，針對所有數值型別，此值為零，而針對所有參考型別，此值為 `null`。</span><span class="sxs-lookup"><span data-stu-id="13077-122">The `new` operator automatically initializes the elements of an array to their default value, which, for example, is zero for all numeric types and `null` for all reference types.</span></span>

<span data-ttu-id="13077-123">下列範例會建立 `int` 元素的陣列、初始化陣列，並印出陣列的內容。</span><span class="sxs-lookup"><span data-stu-id="13077-123">The following example creates an array of `int` elements, initializes the array, and prints out the contents of the array.</span></span>

:::code language="csharp" source="./snippets/shared/Features.cs" ID="ArraysSample":::

<span data-ttu-id="13077-124">這個範例會建立並操作***一維陣列***。</span><span class="sxs-lookup"><span data-stu-id="13077-124">This example creates and operates on a ***single-dimensional array***.</span></span> <span data-ttu-id="13077-125">C# 也支援***多維陣列***。</span><span class="sxs-lookup"><span data-stu-id="13077-125">C# also supports ***multi-dimensional arrays***.</span></span> <span data-ttu-id="13077-126">一個陣列型別的維度數目 (亦稱為陣列型別的***順位***)，是寫入陣列型別的方括弧之間的逗號數目加一。</span><span class="sxs-lookup"><span data-stu-id="13077-126">The number of dimensions of an array type, also known as the ***rank*** of the array type, is one plus the number of commas written between the square brackets of the array type.</span></span> <span data-ttu-id="13077-127">下列範例會分別配置一個單維、一個二維和一個三維陣列。</span><span class="sxs-lookup"><span data-stu-id="13077-127">The following example allocates a single-dimensional, a two-dimensional, and a three-dimensional array, respectively.</span></span>

:::code language="csharp" source="./snippets/shared/Features.cs" ID="DeclareArrays":::

<span data-ttu-id="13077-128">`a1` 陣列包含 10 個元素、`a2`陣列包含 50 (10 × 5) 個元素，`a3` 陣列包含 100 (10 × 5 × 2) 個元素。</span><span class="sxs-lookup"><span data-stu-id="13077-128">The `a1` array contains 10 elements, the `a2` array contains 50 (10 × 5) elements, and the `a3` array contains 100 (10 × 5 × 2) elements.</span></span>
<span data-ttu-id="13077-129">陣列的元素型別可以是任一型別，包括陣列型別。</span><span class="sxs-lookup"><span data-stu-id="13077-129">The element type of an array can be any type, including an array type.</span></span> <span data-ttu-id="13077-130">具有陣列類型之元素的陣列有時稱為***不規則陣列***，因為元素陣列的長度不一定是相同的。</span><span class="sxs-lookup"><span data-stu-id="13077-130">An array with elements of an array type is sometimes called a ***jagged array*** because the lengths of the element arrays don't all have to be the same.</span></span> <span data-ttu-id="13077-131">下列範例會配置一個 `int` 型別的陣列：</span><span class="sxs-lookup"><span data-stu-id="13077-131">The following example allocates an array of arrays of `int`:</span></span>

:::code language="csharp" source="./snippets/shared/Features.cs" ID="ArrayOfArrays":::

<span data-ttu-id="13077-132">第一行建立包含三個元素的陣列，每個元素的型別均為 `int[]`，每個元素的初始值均為 `null`。</span><span class="sxs-lookup"><span data-stu-id="13077-132">The first line creates an array with three elements, each of type `int[]` and each with an initial value of `null`.</span></span> <span data-ttu-id="13077-133">接下來的幾行會初始化具有不同長度之個別陣列實例參考的三個元素。</span><span class="sxs-lookup"><span data-stu-id="13077-133">The next lines then initialize the three elements with references to individual array instances of varying lengths.</span></span>

<span data-ttu-id="13077-134">`new`運算子允許使用***陣列初始化***運算式來指定陣列元素的初始值，這是在分隔符號和之間寫入的運算式清單 `{` `}` 。</span><span class="sxs-lookup"><span data-stu-id="13077-134">The `new` operator permits the initial values of the array elements to be specified using an ***array initializer***, which is a list of expressions written between the delimiters `{` and `}`.</span></span> <span data-ttu-id="13077-135">下列範例使用三個元素配置並初始化 `int[]`。</span><span class="sxs-lookup"><span data-stu-id="13077-135">The following example allocates and initializes an `int[]` with three elements.</span></span>

:::code language="csharp" source="./snippets/shared/Features.cs" ID="InitializeArray":::

<span data-ttu-id="13077-136">陣列的長度是從和之間的運算式數目推斷而來 `{` `}` 。</span><span class="sxs-lookup"><span data-stu-id="13077-136">The length of the array is inferred from the number of expressions between `{` and `}`.</span></span> <span data-ttu-id="13077-137">區域變數和欄位宣告可以進一步縮短，這樣就不需要先重新開機陣列類型。</span><span class="sxs-lookup"><span data-stu-id="13077-137">Local variable and field declarations can be shortened further such that the array type doesn't have to be restated.</span></span>

:::code language="csharp" source="./snippets/shared/Features.cs" ID="InitializeShortened":::

<span data-ttu-id="13077-138">上述兩個範例都相當於下列程式碼：</span><span class="sxs-lookup"><span data-stu-id="13077-138">Both of the previous examples are equivalent to the following code:</span></span>

:::code language="csharp" source="./snippets/shared/Features.cs" ID="InitializeGenerated":::

<span data-ttu-id="13077-139">`foreach`語句可以用來列舉任何集合的元素。</span><span class="sxs-lookup"><span data-stu-id="13077-139">The `foreach` statement can be used to enumerate the elements of any collection.</span></span> <span data-ttu-id="13077-140">下列程式碼會列舉前述範例中的陣列：</span><span class="sxs-lookup"><span data-stu-id="13077-140">The following code enumerates the array from the preceding example:</span></span>

:::code language="csharp" source="./snippets/shared/Features.cs" ID="EnumerateArray":::

<span data-ttu-id="13077-141">`foreach`語句使用 <xref:System.Collections.Generic.IEnumerable%601> 介面，因此可以與任何集合搭配使用。</span><span class="sxs-lookup"><span data-stu-id="13077-141">The `foreach` statement uses the <xref:System.Collections.Generic.IEnumerable%601> interface, so can work with any collection.</span></span>

## <a name="string-interpolation"></a><span data-ttu-id="13077-142">字串插補</span><span class="sxs-lookup"><span data-stu-id="13077-142">String interpolation</span></span>

<span data-ttu-id="13077-143">C #[***字串插補***](../language-reference/tokens/interpolated.md)可讓您藉由定義會將其結果放在格式字串中的運算式來格式化字串。</span><span class="sxs-lookup"><span data-stu-id="13077-143">C# [***string interpolation***](../language-reference/tokens/interpolated.md) enables you to format strings by defining expressions whose results are placed in a format string.</span></span> <span data-ttu-id="13077-144">例如，下列範例會從一組天氣資料列印指定一天的溫度：</span><span class="sxs-lookup"><span data-stu-id="13077-144">For example, the following example prints the temperature on a given day from a set of weather data:</span></span>

:::code language="csharp" source="./snippets/shared/Features.cs" ID="StringInterpolation":::

<span data-ttu-id="13077-145">插補字串是使用 token 宣告的 `$` 。</span><span class="sxs-lookup"><span data-stu-id="13077-145">An interpolated string is declared using the `$` token.</span></span> <span data-ttu-id="13077-146">字串插補會評估和之間的運算式 `{` `}` ，然後將結果轉換為 `string` ，並將括弧之間的文字取代為運算式的字串結果。</span><span class="sxs-lookup"><span data-stu-id="13077-146">String interpolation evaluates the expressions between `{` and `}`, then converts the result to a `string`, and replaces the text between the brackets with the string result of the expression.</span></span> <span data-ttu-id="13077-147">`:`第一個運算式中的會 `{weatherData.Data:MM-DD-YYYY}` 指定*格式字串*。</span><span class="sxs-lookup"><span data-stu-id="13077-147">The `:` in the first expression, `{weatherData.Data:MM-DD-YYYY}` specifies the *format string*.</span></span> <span data-ttu-id="13077-148">在上述範例中，它會指定應以「MM-DD-YYYY」格式列印日期。</span><span class="sxs-lookup"><span data-stu-id="13077-148">In the preceding example, it specifies that the date should be printed in "MM-DD-YYYY" format.</span></span>

## <a name="pattern-matching"></a><span data-ttu-id="13077-149">模式比對</span><span class="sxs-lookup"><span data-stu-id="13077-149">Pattern matching</span></span>

<span data-ttu-id="13077-150">C # 語言提供[***模式***](../pattern-matching.md)比對運算式來查詢物件的狀態，並根據該狀態來執行程式碼。</span><span class="sxs-lookup"><span data-stu-id="13077-150">The C# language provides [***pattern matching***](../pattern-matching.md) expressions to query the state of an object and execute code based on that state.</span></span> <span data-ttu-id="13077-151">您可以檢查類型和屬性和欄位的值，以決定要採取的動作。</span><span class="sxs-lookup"><span data-stu-id="13077-151">You can inspect types and the values of properties and fields to determine which action to take.</span></span> <span data-ttu-id="13077-152">`switch`運算式是模式比對的主要運算式。</span><span class="sxs-lookup"><span data-stu-id="13077-152">The `switch` expression is the primary expression for pattern matching.</span></span>

## <a name="delegates-and-lambda-expressions"></a><span data-ttu-id="13077-153">委派和 lambda 運算式</span><span class="sxs-lookup"><span data-stu-id="13077-153">Delegates and lambda expressions</span></span>

<span data-ttu-id="13077-154">[***委派類型***](../delegates-overview.md)代表具有特定參數清單和傳回類型之方法的參考。</span><span class="sxs-lookup"><span data-stu-id="13077-154">A [***delegate type***](../delegates-overview.md) represents references to methods with a particular parameter list and return type.</span></span> <span data-ttu-id="13077-155">委派讓您可將方法視為實體，而實體能指派給變數或當作參數來傳遞。</span><span class="sxs-lookup"><span data-stu-id="13077-155">Delegates make it possible to treat methods as entities that can be assigned to variables and passed as parameters.</span></span> <span data-ttu-id="13077-156">委派類似于在某些其他語言中找到的函式指標概念。</span><span class="sxs-lookup"><span data-stu-id="13077-156">Delegates are similar to the concept of function pointers found in some other languages.</span></span> <span data-ttu-id="13077-157">不同于函式指標，委派是物件導向且為型別安全。</span><span class="sxs-lookup"><span data-stu-id="13077-157">Unlike function pointers, delegates are object-oriented and type-safe.</span></span>

<span data-ttu-id="13077-158">下列範例會宣告並使用名為 `Function` 的委派型別。</span><span class="sxs-lookup"><span data-stu-id="13077-158">The following example declares and uses a delegate type named `Function`.</span></span>

:::code language="csharp" source="./snippets/shared/Features.cs" ID="DelegateExample":::

<span data-ttu-id="13077-159">`Function` 委派型別的執行個體可以參考任何採用 `double` 引數並傳回 `double` 值的方法。</span><span class="sxs-lookup"><span data-stu-id="13077-159">An instance of the `Function` delegate type can reference any method that takes a `double` argument and returns a `double` value.</span></span> <span data-ttu-id="13077-160">`Apply`方法會將指定的套用 `Function` 至的專案 `double[]` ，並傳回 `double[]` 包含結果的。</span><span class="sxs-lookup"><span data-stu-id="13077-160">The `Apply` method applies a given `Function` to the elements of a `double[]`, returning a `double[]` with the results.</span></span> <span data-ttu-id="13077-161">在 `Main` 方法中，是使用 `Apply` 將三個不同的函式套用到 `double[]`。</span><span class="sxs-lookup"><span data-stu-id="13077-161">In the `Main` method, `Apply` is used to apply three different functions to a `double[]`.</span></span>

<span data-ttu-id="13077-162">委派可以參考靜態方法 (例如上一個範例中的 `Square` 或 `Math.Sin`)，或是參考執行個體方法 (例如上一個範例中的 `m.Multiply`)。</span><span class="sxs-lookup"><span data-stu-id="13077-162">A delegate can reference either a static method (such as `Square` or `Math.Sin` in the previous example) or an instance method (such as `m.Multiply` in the previous example).</span></span> <span data-ttu-id="13077-163">參考執行個體方法的委派也會參考特定的物件，而且透過委派來叫用執行個體方法時，該物件就會變成叫用中的 `this`。</span><span class="sxs-lookup"><span data-stu-id="13077-163">A delegate that references an instance method also references a particular object, and when the instance method is invoked through the delegate, that object becomes `this` in the invocation.</span></span>

<span data-ttu-id="13077-164">您也可以使用匿名函式來建立委派，這些函式是宣告時所建立的「內嵌方法」。</span><span class="sxs-lookup"><span data-stu-id="13077-164">Delegates can also be created using anonymous functions, which are "inline methods" that are created when declared.</span></span> <span data-ttu-id="13077-165">匿名函式可以看見周圍方法的區域變數。</span><span class="sxs-lookup"><span data-stu-id="13077-165">Anonymous functions can see the local variables of the surrounding methods.</span></span> <span data-ttu-id="13077-166">下列範例不會建立類別：</span><span class="sxs-lookup"><span data-stu-id="13077-166">The following example doesn't create a class:</span></span>

:::code language="csharp" source="./snippets/shared/Features.cs" ID="UseDelegate":::

<span data-ttu-id="13077-167">委派不知道或在意它所參考之方法的類別。</span><span class="sxs-lookup"><span data-stu-id="13077-167">A delegate doesn't know or care about the class of the method it references.</span></span> <span data-ttu-id="13077-168">重點在於，參考的方法具有與委派相同的參數和傳回型別。</span><span class="sxs-lookup"><span data-stu-id="13077-168">All that matters is that the referenced method has the same parameters and return type as the delegate.</span></span>

## <a name="async--await"></a><span data-ttu-id="13077-169">async/await</span><span class="sxs-lookup"><span data-stu-id="13077-169">async / await</span></span>

<span data-ttu-id="13077-170">C # 支援具有兩個關鍵字的非同步程式： `async` 和 `await` 。</span><span class="sxs-lookup"><span data-stu-id="13077-170">C# supports asynchronous programs with two keywords: `async` and `await`.</span></span> <span data-ttu-id="13077-171">您將修飾詞新增 `async` 至方法宣告，以宣告方法是非同步。</span><span class="sxs-lookup"><span data-stu-id="13077-171">You add the `async` modifier to a method declaration to declare the method is asynchronous.</span></span> <span data-ttu-id="13077-172">`await`運算子會指示編譯器以非同步方式等待結果完成。</span><span class="sxs-lookup"><span data-stu-id="13077-172">The `await` operator tells the compiler to asynchronously await for a result to finish.</span></span> <span data-ttu-id="13077-173">控制權會傳回給呼叫者，而方法會傳回管理非同步工作狀態的結構。</span><span class="sxs-lookup"><span data-stu-id="13077-173">Control is returned to the caller, and the method returns a structure that manages the state of the asynchronous work.</span></span> <span data-ttu-id="13077-174">結構通常是 <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> ，但可以是支援 awaiter 模式的任何類型。</span><span class="sxs-lookup"><span data-stu-id="13077-174">The structure is typically a <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType>, but can be any type that supports the awaiter pattern.</span></span> <span data-ttu-id="13077-175">這些功能可讓您撰寫程式碼，以讀取作為其同步的對應項，但以非同步方式執行。</span><span class="sxs-lookup"><span data-stu-id="13077-175">These features enable you to write code that reads as its synchronous counterpart, but executes asynchronously.</span></span> <span data-ttu-id="13077-176">例如，下列程式碼會下載[Microsoft](https://docs.microsoft.com)檔的首頁：</span><span class="sxs-lookup"><span data-stu-id="13077-176">For example, the following code downloads the home page for [Microsoft docs](https://docs.microsoft.com):</span></span>

:::code language="csharp" source="./snippets/shared/Features.cs" ID="AsyncExample":::

<span data-ttu-id="13077-177">這個小範例顯示非同步程式設計的主要功能：</span><span class="sxs-lookup"><span data-stu-id="13077-177">This small sample shows the major features for asynchronous programming:</span></span>

- <span data-ttu-id="13077-178">方法宣告包含修飾詞 `async` 。</span><span class="sxs-lookup"><span data-stu-id="13077-178">The method declaration includes the `async` modifier.</span></span>
- <span data-ttu-id="13077-179">方法的主體，這是方法的傳回 `await` `GetByteArrayAsync` 。</span><span class="sxs-lookup"><span data-stu-id="13077-179">The body of the method `await`s the return of the `GetByteArrayAsync` method.</span></span>
- <span data-ttu-id="13077-180">語句中指定的類型 `return` 與方法的宣告中的類型引數相符 `Task<T>` 。</span><span class="sxs-lookup"><span data-stu-id="13077-180">The type specified in the `return` statement matches the type argument in the `Task<T>` declaration for the method.</span></span> <span data-ttu-id="13077-181"> (傳回的方法 `Task` 會使用 `return` 不含任何引數的語句) 。</span><span class="sxs-lookup"><span data-stu-id="13077-181">(A method that returns a `Task` would use `return` statements without any argument).</span></span>

## <a name="attributes"></a><span data-ttu-id="13077-182">屬性</span><span class="sxs-lookup"><span data-stu-id="13077-182">Attributes</span></span>

<span data-ttu-id="13077-183">C# 程式中的型別、成員和其他實體支援控制其某方面行為的修飾詞。</span><span class="sxs-lookup"><span data-stu-id="13077-183">Types, members, and other entities in a C# program support modifiers that control certain aspects of their behavior.</span></span> <span data-ttu-id="13077-184">例如，方法的協助工具是使用 `public`、`protected`、`internal` 和 `private` 修飾詞控制。</span><span class="sxs-lookup"><span data-stu-id="13077-184">For example, the accessibility of a method is controlled using the `public`, `protected`, `internal`, and `private` modifiers.</span></span> <span data-ttu-id="13077-185">C# 將此能力一般化，宣告式資訊的使用者定義型別才能附加至程式實體，並在執行階段擷取。</span><span class="sxs-lookup"><span data-stu-id="13077-185">C# generalizes this capability such that user-defined types of declarative information can be attached to program entities and retrieved at run-time.</span></span> <span data-ttu-id="13077-186">程式會藉由定義和使用[***屬性***](../programming-guide/concepts/attributes/index.md)來指定這個額外的宣告式資訊。</span><span class="sxs-lookup"><span data-stu-id="13077-186">Programs specify this additional declarative information by defining and using [***attributes***](../programming-guide/concepts/attributes/index.md).</span></span>

<span data-ttu-id="13077-187">下列範例宣告的 `HelpAttribute` 屬性可置於程式實體，以提供其相關文件的連結。</span><span class="sxs-lookup"><span data-stu-id="13077-187">The following example declares a `HelpAttribute` attribute that can be placed on program entities to provide links to their associated documentation.</span></span>

:::code language="csharp" source="./snippets/shared/Features.cs" ID="DefineAttribute":::

<span data-ttu-id="13077-188">所有屬性類別均衍生自 <xref:System.Attribute> .net 程式庫所提供的基類。</span><span class="sxs-lookup"><span data-stu-id="13077-188">All attribute classes derive from the <xref:System.Attribute> base class provided by the .NET library.</span></span> <span data-ttu-id="13077-189">在相關聯的宣告之前，於方括弧中提供屬性的名稱 (及任何引數) 即可套用屬性。</span><span class="sxs-lookup"><span data-stu-id="13077-189">Attributes can be applied by giving their name, along with any arguments, inside square brackets just before the associated declaration.</span></span> <span data-ttu-id="13077-190">如果屬性名稱的結尾是 `Attribute`，則參考該屬性時可以省略該部分名稱。</span><span class="sxs-lookup"><span data-stu-id="13077-190">If an attribute’s name ends in `Attribute`, that part of the name can be omitted when the attribute is referenced.</span></span> <span data-ttu-id="13077-191">例如，`HelpAttribute` 可以下列方式使用。</span><span class="sxs-lookup"><span data-stu-id="13077-191">For example, the `HelpAttribute` can be used as follows.</span></span>

:::code language="csharp" source="./snippets/shared/Features.cs" ID="UseAttributes":::

<span data-ttu-id="13077-192">這個範例會將 `HelpAttribute` 附加至 `Widget` 類別。</span><span class="sxs-lookup"><span data-stu-id="13077-192">This example attaches a `HelpAttribute` to the `Widget` class.</span></span> <span data-ttu-id="13077-193">它會在類別的 `Display` 方法中加入另一個 `HelpAttribute`。</span><span class="sxs-lookup"><span data-stu-id="13077-193">It adds another `HelpAttribute` to the `Display` method in the class.</span></span> <span data-ttu-id="13077-194">屬性類別的公用建構函式控制將屬性附加至程式實體時必須提供的資訊。</span><span class="sxs-lookup"><span data-stu-id="13077-194">The public constructors of an attribute class control the information that must be provided when the attribute is attached to a program entity.</span></span> <span data-ttu-id="13077-195">透過參考屬性類別的公用讀寫屬性可提供其他資訊 (例如先前對 `Topic` 的參考 )。</span><span class="sxs-lookup"><span data-stu-id="13077-195">Additional information can be provided by referencing public read-write properties of the attribute class (such as the reference to the `Topic` property previously).</span></span>

<span data-ttu-id="13077-196">由屬性定義的中繼資料可在執行階段使用反射來讀取及操控。</span><span class="sxs-lookup"><span data-stu-id="13077-196">The metadata defined by attributes can be read and manipulated at runtime using reflection.</span></span> <span data-ttu-id="13077-197">使用此技巧要求特定的屬性時，會以程式來源中提供的資訊叫用屬性類別的建構函式，並傳回產生的屬性執行個體。</span><span class="sxs-lookup"><span data-stu-id="13077-197">When a particular attribute is requested using this technique, the constructor for the attribute class is invoked with the information provided in the program source, and the resulting attribute instance is returned.</span></span> <span data-ttu-id="13077-198">如果是透過屬性提供其他資訊，傳回屬性執行個體之前，這些屬性會設為指定的值。</span><span class="sxs-lookup"><span data-stu-id="13077-198">If additional information was provided through properties, those properties are set to the given values before the attribute instance is returned.</span></span>

<span data-ttu-id="13077-199">下列程式碼範例示範如何取得與 `Widget` 類別關聯的 `HelpAttribute` 執行個體與其 `Display` 方法。</span><span class="sxs-lookup"><span data-stu-id="13077-199">The following code sample demonstrates how to get the `HelpAttribute` instances associated to the `Widget` class and its `Display` method.</span></span>

:::code language="csharp" source="./snippets/shared/Features.cs" ID="ReadAttributes":::

## <a name="learn-more"></a><span data-ttu-id="13077-200">深入了解</span><span class="sxs-lookup"><span data-stu-id="13077-200">Learn more</span></span>

<span data-ttu-id="13077-201">您可以嘗試我們的其中一個[教學](../tutorials/index.md)課程，以深入瞭解 c #。</span><span class="sxs-lookup"><span data-stu-id="13077-201">You can explore more about C# by trying one of our [tutorials](../tutorials/index.md).</span></span>

>[!div class="step-by-step"]
>[<span data-ttu-id="13077-202">上一步</span><span class="sxs-lookup"><span data-stu-id="13077-202">Previous</span></span>](program-building-blocks.md)
