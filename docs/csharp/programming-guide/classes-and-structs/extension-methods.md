---
title: 擴充方法 - C# 程式設計手冊
ms.date: 03/19/2020
helpviewer_keywords:
- methods [C#], adding to existing types
- extension methods [C#]
- methods [C#], extension
ms.assetid: 175ce3ff-9bbf-4e64-8421-faeb81a0bb51
ms.openlocfilehash: 0f9c0f053e531a44640084a35dc5d8e844ee0b46
ms.sourcegitcommit: 1eae045421d9ea2bfc82aaccfa5b1ff1b8c9e0e4
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 06/16/2020
ms.locfileid: "84803180"
---
# <a name="extension-methods-c-programming-guide"></a><span data-ttu-id="832a1-102">擴充方法 (C# 程式設計手冊)</span><span class="sxs-lookup"><span data-stu-id="832a1-102">Extension Methods (C# Programming Guide)</span></span>

<span data-ttu-id="832a1-103">擴充方法可讓您在現有類型中「加入」方法，而不需要建立新的衍生類型、重新編譯，或是修改原始類型。</span><span class="sxs-lookup"><span data-stu-id="832a1-103">Extension methods enable you to "add" methods to existing types without creating a new derived type, recompiling, or otherwise modifying the original type.</span></span> <span data-ttu-id="832a1-104">擴充方法是靜態方法，但它們的呼叫方式就如同擴充類型上的實例方法一樣。</span><span class="sxs-lookup"><span data-stu-id="832a1-104">Extension methods are static methods, but they're called as if they were instance methods on the extended type.</span></span> <span data-ttu-id="832a1-105">對於以 c #、F # 和 Visual Basic 撰寫的用戶端程式代碼，呼叫擴充方法與在類型中定義的方法之間沒有明顯的差異。</span><span class="sxs-lookup"><span data-stu-id="832a1-105">For client code written in C#, F# and Visual Basic, there's no apparent difference between calling an extension method and the methods defined in a type.</span></span>

<span data-ttu-id="832a1-106">最常見的擴充方法是 LINQ 標準查詢運算子，可將查詢功能加入至現有的 <xref:System.Collections.IEnumerable?displayProperty=nameWithType> 和 <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> 類型。</span><span class="sxs-lookup"><span data-stu-id="832a1-106">The most common extension methods are the LINQ standard query operators that add query functionality to the existing <xref:System.Collections.IEnumerable?displayProperty=nameWithType> and <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> types.</span></span> <span data-ttu-id="832a1-107">若要使用標準查詢運算子，請先使用 `using System.Linq` 指示詞將它們帶入範圍內。</span><span class="sxs-lookup"><span data-stu-id="832a1-107">To use the standard query operators, first bring them into scope with a `using System.Linq` directive.</span></span> <span data-ttu-id="832a1-108">接著，任何實作 <xref:System.Collections.Generic.IEnumerable%601> 的類型都會具有執行個體方法，如 <xref:System.Linq.Enumerable.GroupBy%2A>、<xref:System.Linq.Enumerable.OrderBy%2A>、<xref:System.Linq.Enumerable.Average%2A> 等。</span><span class="sxs-lookup"><span data-stu-id="832a1-108">Then any type that implements <xref:System.Collections.Generic.IEnumerable%601> appears to have instance methods such as <xref:System.Linq.Enumerable.GroupBy%2A>, <xref:System.Linq.Enumerable.OrderBy%2A>, <xref:System.Linq.Enumerable.Average%2A>, and so on.</span></span> <span data-ttu-id="832a1-109">如果在 <xref:System.Collections.Generic.IEnumerable%601> 類型 (如 <xref:System.Collections.Generic.List%601> 或 <xref:System.Array>) 的執行個體後面輸入「點」，就可以在 IntelliSense 陳述式完成時看到這些額外的方法。</span><span class="sxs-lookup"><span data-stu-id="832a1-109">You can see these additional methods in IntelliSense statement completion when you type "dot" after an instance of an <xref:System.Collections.Generic.IEnumerable%601> type such as <xref:System.Collections.Generic.List%601> or <xref:System.Array>.</span></span>

### <a name="orderby-example"></a><span data-ttu-id="832a1-110">OrderBy 範例</span><span class="sxs-lookup"><span data-stu-id="832a1-110">OrderBy Example</span></span>

<span data-ttu-id="832a1-111">下列範例將示範如何在整數陣列上呼叫標準查詢運算子 `OrderBy` 方法。</span><span class="sxs-lookup"><span data-stu-id="832a1-111">The following example shows how to call the standard query operator `OrderBy` method on an array of integers.</span></span> <span data-ttu-id="832a1-112">括號括住的運算式就是 Lambda 運算式。</span><span class="sxs-lookup"><span data-stu-id="832a1-112">The expression in parentheses is a lambda expression.</span></span> <span data-ttu-id="832a1-113">許多標準查詢運算子會採用 lambda 運算式做為參數，但這不是擴充方法的需求。</span><span class="sxs-lookup"><span data-stu-id="832a1-113">Many standard query operators take lambda expressions as parameters, but this isn't a requirement for extension methods.</span></span> <span data-ttu-id="832a1-114">如需詳細資訊，請參閱[Lambda 運算式](../statements-expressions-operators/lambda-expressions.md)。</span><span class="sxs-lookup"><span data-stu-id="832a1-114">For more information, see [Lambda Expressions](../statements-expressions-operators/lambda-expressions.md).</span></span>

[!code-csharp[csProgGuideExtensionMethods#3](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideExtensionMethods/cs/extensionmethods.cs#3)]

<span data-ttu-id="832a1-115">擴充方法會定義為靜態方法，但透過執行個體方法語法呼叫。</span><span class="sxs-lookup"><span data-stu-id="832a1-115">Extension methods are defined as static methods but are called by using instance method syntax.</span></span> <span data-ttu-id="832a1-116">其第一個參數會指定方法操作的類型。</span><span class="sxs-lookup"><span data-stu-id="832a1-116">Their first parameter specifies which type the method operates on.</span></span> <span data-ttu-id="832a1-117">參數的前面會加上[this](../../language-reference/keywords/this.md)修飾詞。</span><span class="sxs-lookup"><span data-stu-id="832a1-117">The parameter is preceded by the [this](../../language-reference/keywords/this.md) modifier.</span></span> <span data-ttu-id="832a1-118">您必須使用 `using` 指示詞將命名空間明確匯入至原始程式碼，擴充方法才會進入範圍中。</span><span class="sxs-lookup"><span data-stu-id="832a1-118">Extension methods are only in scope when you explicitly import the namespace into your source code with a `using` directive.</span></span>

<span data-ttu-id="832a1-119">下列範例將示範針對 <xref:System.String?displayProperty=nameWithType> 類別定義的擴充方法。</span><span class="sxs-lookup"><span data-stu-id="832a1-119">The following example shows an extension method defined for the <xref:System.String?displayProperty=nameWithType> class.</span></span> <span data-ttu-id="832a1-120">它是在非嵌套的非泛型靜態類別中定義的：</span><span class="sxs-lookup"><span data-stu-id="832a1-120">It's defined inside a non-nested, non-generic static class:</span></span>

[!code-csharp[csProgGuideExtensionMethods#4](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideExtensionMethods/cs/extensionmethods.cs#4)]

<span data-ttu-id="832a1-121">使用這個 `WordCount` 指示詞就可以將 `using` 擴充方法帶入範圍中：</span><span class="sxs-lookup"><span data-stu-id="832a1-121">The `WordCount` extension method can be brought into scope with this `using` directive:</span></span>

```csharp
using ExtensionMethods;
```

<span data-ttu-id="832a1-122">而使用下列語法，就可以從應用程式中呼叫它：</span><span class="sxs-lookup"><span data-stu-id="832a1-122">And it can be called from an application by using this syntax:</span></span>

```csharp
string s = "Hello Extension Methods";
int i = s.WordCount();
```

<span data-ttu-id="832a1-123">您可以使用實例方法語法，在程式碼中叫用擴充方法。</span><span class="sxs-lookup"><span data-stu-id="832a1-123">You invoke the extension method in your code with instance method syntax.</span></span> <span data-ttu-id="832a1-124">編譯器所產生的中繼語言（IL）會將您的程式碼轉譯為靜態方法的呼叫。</span><span class="sxs-lookup"><span data-stu-id="832a1-124">The intermediate language (IL) generated by the compiler translates your code into a call on the static method.</span></span> <span data-ttu-id="832a1-125">封裝的原則並不是真的違反了。</span><span class="sxs-lookup"><span data-stu-id="832a1-125">The principle of encapsulation is not really being violated.</span></span> <span data-ttu-id="832a1-126">擴充方法無法存取所擴充之類型中的私用變數。</span><span class="sxs-lookup"><span data-stu-id="832a1-126">Extension methods cannot access private variables in the type they are extending.</span></span>

<span data-ttu-id="832a1-127">如需詳細資訊，請參閱[如何執行和呼叫自訂擴充方法](./how-to-implement-and-call-a-custom-extension-method.md)。</span><span class="sxs-lookup"><span data-stu-id="832a1-127">For more information, see [How to implement and call a custom  extension method](./how-to-implement-and-call-a-custom-extension-method.md).</span></span>

<span data-ttu-id="832a1-128">一般來說，您可能會呼叫擴充方法，而不是執行自己的程式。</span><span class="sxs-lookup"><span data-stu-id="832a1-128">In general, you'll probably be calling extension methods far more often than implementing your own.</span></span> <span data-ttu-id="832a1-129">因為擴充方法是使用執行個體方法語法進行呼叫，所以不需要任何特殊知識就可以從用戶端程式碼使用它們。</span><span class="sxs-lookup"><span data-stu-id="832a1-129">Because extension methods are called by using instance method syntax, no special knowledge is required to use them from client code.</span></span> <span data-ttu-id="832a1-130">若要啟用特定類型的擴充方法，只要針對定義這些方法所在的命名空間加入 `using` 指示詞即可。</span><span class="sxs-lookup"><span data-stu-id="832a1-130">To enable extension methods for a particular type, just add a `using` directive for the namespace in which the methods are defined.</span></span> <span data-ttu-id="832a1-131">例如，若要使用標準查詢運算子，請將下面這個 `using` 指示詞加入至程式碼：</span><span class="sxs-lookup"><span data-stu-id="832a1-131">For example, to use the standard query operators, add this `using` directive to your code:</span></span>

```csharp
using System.Linq;
```

<span data-ttu-id="832a1-132">（您可能也必須加入 System.Core.dll 的參考）。您會注意到，標準查詢運算子現在會出現在 IntelliSense 中，做為大部分類型可用的其他方法 <xref:System.Collections.Generic.IEnumerable%601> 。</span><span class="sxs-lookup"><span data-stu-id="832a1-132">(You may also have to add a reference to System.Core.dll.) You'll notice that the standard query operators now appear in IntelliSense as additional methods available for most <xref:System.Collections.Generic.IEnumerable%601> types.</span></span>

## <a name="binding-extension-methods-at-compile-time"></a><span data-ttu-id="832a1-133">在編譯時期繫結擴充方法</span><span class="sxs-lookup"><span data-stu-id="832a1-133">Binding Extension Methods at Compile Time</span></span>

<span data-ttu-id="832a1-134">您可以使用擴充方法來擴充類別或介面，但無法覆寫它們。</span><span class="sxs-lookup"><span data-stu-id="832a1-134">You can use extension methods to extend a class or interface, but not to override them.</span></span> <span data-ttu-id="832a1-135">而且永遠不會呼叫擁有與介面或類別方法相同名稱和簽章的擴充方法。</span><span class="sxs-lookup"><span data-stu-id="832a1-135">An extension method with the same name and signature as an interface or class method will never be called.</span></span> <span data-ttu-id="832a1-136">在編譯時期，擴充方法的優先順序一律低於類型本身中定義的執行個體方法。</span><span class="sxs-lookup"><span data-stu-id="832a1-136">At compile time, extension methods always have lower priority than instance methods defined in the type itself.</span></span> <span data-ttu-id="832a1-137">換句話說，如果類型具有名為 `Process(int i)` 的方法，而您的擴充方法也具有相同的簽章，則編譯器一律會繫結至執行個體方法。</span><span class="sxs-lookup"><span data-stu-id="832a1-137">In other words, if a type has a method named `Process(int i)`, and you have an extension method with the same signature, the compiler will always bind to the instance method.</span></span> <span data-ttu-id="832a1-138">編譯器遇到方法引動過程時，會先在類型的執行個體方法中尋找相符項目。</span><span class="sxs-lookup"><span data-stu-id="832a1-138">When the compiler encounters a method invocation, it first looks for a match in the type's instance methods.</span></span> <span data-ttu-id="832a1-139">如果找不到相符項目，則會搜尋任何針對該類型定義的擴充方法，並繫結至找到的第一個擴充方法。</span><span class="sxs-lookup"><span data-stu-id="832a1-139">If no match is found, it will search for any extension methods that are defined for the type, and bind to the first extension method that it finds.</span></span> <span data-ttu-id="832a1-140">下列範例將示範編譯器如何判斷要繫結的擴充方法或執行個體方法。</span><span class="sxs-lookup"><span data-stu-id="832a1-140">The following example demonstrates how the compiler determines which extension method or instance method to bind to.</span></span>

## <a name="example"></a><span data-ttu-id="832a1-141">範例</span><span class="sxs-lookup"><span data-stu-id="832a1-141">Example</span></span>

<span data-ttu-id="832a1-142">下列範例將示範 C# 編譯器遵循的規則，用以判斷要將方法呼叫繫結至類型上的執行個體方法，還是繫結至擴充方法。</span><span class="sxs-lookup"><span data-stu-id="832a1-142">The following example demonstrates the rules that the C# compiler follows in determining whether to bind a method call to an instance method on the type, or to an extension method.</span></span> <span data-ttu-id="832a1-143">靜態類別 `Extensions` 包含針對任何實作 `IMyInterface` 之類型定義的擴充方法。</span><span class="sxs-lookup"><span data-stu-id="832a1-143">The static class `Extensions` contains extension methods defined for any type that implements `IMyInterface`.</span></span> <span data-ttu-id="832a1-144">類別 `A`、`B` 和 `C` 都會實作這個介面。</span><span class="sxs-lookup"><span data-stu-id="832a1-144">Classes `A`, `B`, and `C` all implement the interface.</span></span>

<span data-ttu-id="832a1-145">因為 `MethodB` 擴充方法的名稱和簽章與這些類別已實作的方法完全相同，所以絕不會呼叫該方法。</span><span class="sxs-lookup"><span data-stu-id="832a1-145">The `MethodB` extension method is never called because its name and signature exactly match methods already implemented by the classes.</span></span>

<span data-ttu-id="832a1-146">當編譯器找不到具有相符簽章的實例方法時，它會系結至相符的擴充方法（如果有的話）。</span><span class="sxs-lookup"><span data-stu-id="832a1-146">When the compiler can't find an instance method with a matching signature, it will bind to a matching extension method if one exists.</span></span>

[!code-csharp[csProgGuideExtensionMethods#5](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideExtensionMethods/cs/extensionmethods.cs#5)]

## <a name="common-usage-patterns"></a><span data-ttu-id="832a1-147">常見使用模式</span><span class="sxs-lookup"><span data-stu-id="832a1-147">Common Usage Patterns</span></span>

### <a name="collection-functionality"></a><span data-ttu-id="832a1-148">集合功能</span><span class="sxs-lookup"><span data-stu-id="832a1-148">Collection Functionality</span></span>

<span data-ttu-id="832a1-149">在過去，通常會建立「集合類別」，為指定的型別實作為 <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> 介面，並針對該型別的集合採取動作。</span><span class="sxs-lookup"><span data-stu-id="832a1-149">In the past, it was common to create "Collection Classes" that implemented the <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> interface for a given type and contained functionality that acted on collections of that type.</span></span> <span data-ttu-id="832a1-150">雖然建立這種類型的集合物件沒有任何問題，但使用上的延伸模組也可以達到相同的功能 <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="832a1-150">While there's nothing wrong with creating this type of collection object, the same functionality can be achieved by using an extension on the <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType>.</span></span> <span data-ttu-id="832a1-151">延伸模組的優點是允許從任何集合（例如 <xref:System.Array?displayProperty=nameWithType> <xref:System.Collections.Generic.List%601?displayProperty=nameWithType> <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> 在該類型上執行的或）呼叫功能。</span><span class="sxs-lookup"><span data-stu-id="832a1-151">Extensions have the advantage of allowing the functionality to be called from any collection such as an <xref:System.Array?displayProperty=nameWithType> or <xref:System.Collections.Generic.List%601?displayProperty=nameWithType> that implements <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> on that type.</span></span> <span data-ttu-id="832a1-152">如需使用 Int32 陣列的範例，請參閱本文稍[早](#orderby-example)的。</span><span class="sxs-lookup"><span data-stu-id="832a1-152">An example of this using an Array of Int32 can be found [earlier in this article](#orderby-example).</span></span>

### <a name="layer-specific-functionality"></a><span data-ttu-id="832a1-153">圖層特有的功能</span><span class="sxs-lookup"><span data-stu-id="832a1-153">Layer-Specific Functionality</span></span>

<span data-ttu-id="832a1-154">使用繪圖紙架構或其他分層應用程式設計時，通常會有一組可用於跨應用程式界限進行通訊的領域實體或資料傳輸物件。</span><span class="sxs-lookup"><span data-stu-id="832a1-154">When using an Onion Architecture or other layered application design, it's common to have a set of Domain Entities or Data Transfer Objects that can be used to communicate across application boundaries.</span></span> <span data-ttu-id="832a1-155">這些物件通常不包含任何功能，或僅適用于應用程式所有層級的最低功能。</span><span class="sxs-lookup"><span data-stu-id="832a1-155">These objects generally contain no functionality, or only minimal functionality that applies to all layers of the application.</span></span> <span data-ttu-id="832a1-156">擴充方法可用來新增每個應用層特有的功能，而不需使用不需要或不想要在其他圖層中的方法將物件載入。</span><span class="sxs-lookup"><span data-stu-id="832a1-156">Extension methods can be used to add functionality that is specific to each application layer without loading the object down with methods not needed or wanted in other layers.</span></span>

```csharp
public class DomainEntity
{
    public int Id { get; set; }
    public string FirstName { get; set; }
    public string LastName { get; set; }
}

static class DomainEntityExtensions
{
    static string FullName(this DomainEntity value)
        => $"{value.FirstName} {value.LastName}";
}
```

### <a name="extending-predefined-types"></a><span data-ttu-id="832a1-157">擴充預先定義的類型</span><span class="sxs-lookup"><span data-stu-id="832a1-157">Extending Predefined Types</span></span>

<span data-ttu-id="832a1-158">我們通常可以擴充現有的類型，例如 .NET 或 CLR 類型，而不是在需要建立可重複使用的功能時建立新的物件。</span><span class="sxs-lookup"><span data-stu-id="832a1-158">Rather than creating new objects when reusable functionality needs to be created, we can often extend an existing type, such as a .NET or CLR type.</span></span> <span data-ttu-id="832a1-159">例如，如果我們不使用擴充方法，我們可能會建立 `Engine` 或 `Query` 類別來執行在程式碼中多個位置呼叫的 SQL Server 上執行查詢的工作。</span><span class="sxs-lookup"><span data-stu-id="832a1-159">As an example, if we don't use extension methods, we might create an `Engine` or `Query` class to do the work of executing a query on a SQL Server that may be called from multiple places in our code.</span></span> <span data-ttu-id="832a1-160">不過，我們可以改為 <xref:System.Data.SqlClient.SqlConnection?displayProperty=nameWithType> 使用擴充方法來擴充類別，以從已連接到 SQL Server 的任何地方執行該查詢。</span><span class="sxs-lookup"><span data-stu-id="832a1-160">However we can instead extend the <xref:System.Data.SqlClient.SqlConnection?displayProperty=nameWithType> class using extension methods to perform that query from anywhere we have a connection to a SQL Server.</span></span> <span data-ttu-id="832a1-161">其他範例可能是在類別中加入一般功能 <xref:System.String?displayProperty=nameWithType> 、擴充和物件的資料處理功能， <xref:System.IO.File?displayProperty=nameWithType> <xref:System.IO.Stream?displayProperty=nameWithType> 以及 <xref:System.Exception?displayProperty=nameWithType> 特定錯誤處理功能的物件。</span><span class="sxs-lookup"><span data-stu-id="832a1-161">Other examples might be to add common functionality to the <xref:System.String?displayProperty=nameWithType> class, extend the data processing capabilities of the <xref:System.IO.File?displayProperty=nameWithType> and <xref:System.IO.Stream?displayProperty=nameWithType> objects, and <xref:System.Exception?displayProperty=nameWithType> objects for specific error handling functionality.</span></span> <span data-ttu-id="832a1-162">這些類型的使用案例只受到您的想像和良好的限制。</span><span class="sxs-lookup"><span data-stu-id="832a1-162">These types of use-cases are limited only by your imagination and good sense.</span></span>

<span data-ttu-id="832a1-163">延伸預先定義的類型可能會很棘手， `struct` 因為它們是以傳值方式傳遞至方法。</span><span class="sxs-lookup"><span data-stu-id="832a1-163">Extending predefined types can be difficult with `struct` types because they're passed by value to methods.</span></span> <span data-ttu-id="832a1-164">這表示結構的任何變更都會對結構的複本進行。</span><span class="sxs-lookup"><span data-stu-id="832a1-164">That means any changes to the struct are made to a copy of the struct.</span></span> <span data-ttu-id="832a1-165">延伸方法結束後，就不會顯示這些變更。</span><span class="sxs-lookup"><span data-stu-id="832a1-165">Those changes aren't visible once the extension method exits.</span></span> <span data-ttu-id="832a1-166">從 c # 7.2 開始，您可以將 `ref` 修飾詞加入至擴充方法的第一個引數。</span><span class="sxs-lookup"><span data-stu-id="832a1-166">Beginning with C# 7.2, you can add the `ref` modifier to the first argument of an extension method.</span></span> <span data-ttu-id="832a1-167">新增 `ref` 修飾詞表示第一個引數是以傳址方式傳遞。</span><span class="sxs-lookup"><span data-stu-id="832a1-167">Adding the `ref` modifier means the first argument is passed by reference.</span></span> <span data-ttu-id="832a1-168">這可讓您撰寫擴充方法，以變更所擴充之結構的狀態。</span><span class="sxs-lookup"><span data-stu-id="832a1-168">This enables you to write extension methods that change the state of the struct being extended.</span></span>

## <a name="general-guidelines"></a><span data-ttu-id="832a1-169">一般準則</span><span class="sxs-lookup"><span data-stu-id="832a1-169">General Guidelines</span></span>

<span data-ttu-id="832a1-170">雖然它仍然被視為偏好藉由修改物件的程式碼來加入功能，或在合理的情況下衍生新的型別，但擴充方法已成為在整個 .NET 生態系統中建立可重複使用之功能的重要選項。</span><span class="sxs-lookup"><span data-stu-id="832a1-170">While it's still considered preferable to add functionality by modifying an object's code or deriving a new type whenever it's reasonable and possible to do so, extension methods have become a crucial option for creating reusable functionality throughout the .NET ecosystem.</span></span> <span data-ttu-id="832a1-171">當原始來源不在您的控制之下、衍生物件不適當或不可能時，或不應在其適用範圍外公開功能時，您可以選擇擴充方法。</span><span class="sxs-lookup"><span data-stu-id="832a1-171">For those occasions when the original source isn't under your control, when a derived object is inappropriate or impossible, or when the functionality shouldn't be exposed beyond its applicable scope, Extension methods are an excellent choice.</span></span>

<span data-ttu-id="832a1-172">如需衍生類型的詳細資訊，請參閱[繼承](./inheritance.md)。</span><span class="sxs-lookup"><span data-stu-id="832a1-172">For more information on derived types, see [Inheritance](./inheritance.md).</span></span>

<span data-ttu-id="832a1-173">當使用擴充方法來擴充無法控制其原始程式碼的型別時，您會執行風險，讓型別的執行變更會導致擴充方法中斷。</span><span class="sxs-lookup"><span data-stu-id="832a1-173">When using an extension method to extend a type whose source code you aren't in control of, you run the risk that a change in the implementation of the type will cause your extension method to break.</span></span>

<span data-ttu-id="832a1-174">如果您要實作所指定類型的擴充方法，請記住下列幾點：</span><span class="sxs-lookup"><span data-stu-id="832a1-174">If you do implement extension methods for a given type, remember the following points:</span></span>

- <span data-ttu-id="832a1-175">如果擴充方法的簽章與類型中定義的方法相同，則絕不會呼叫擴充方法。</span><span class="sxs-lookup"><span data-stu-id="832a1-175">An extension method will never be called if it has the same signature as a method defined in the type.</span></span>
- <span data-ttu-id="832a1-176">擴充方法是帶入命名空間層級的範圍。</span><span class="sxs-lookup"><span data-stu-id="832a1-176">Extension methods are brought into scope at the namespace level.</span></span> <span data-ttu-id="832a1-177">例如，如果您在名為的單一命名空間中有多個包含擴充方法的靜態類別，則指示詞會將 `Extensions` 它們全部納入範圍中 `using Extensions;` 。</span><span class="sxs-lookup"><span data-stu-id="832a1-177">For example, if you have multiple static classes that contain extension methods in a single namespace named `Extensions`, they'll all be brought into scope by the `using Extensions;` directive.</span></span>

<span data-ttu-id="832a1-178">針對實作的類別庫，您不應該使用擴充方法阻止組件的版本號碼遞增。</span><span class="sxs-lookup"><span data-stu-id="832a1-178">For a class library that you implemented, you shouldn't use extension methods to avoid incrementing the version number of an assembly.</span></span> <span data-ttu-id="832a1-179">如果您想要在您擁有原始程式碼的程式庫中新增重要功能，請遵循元件版本控制的 .NET 指導方針。</span><span class="sxs-lookup"><span data-stu-id="832a1-179">If you want to add significant functionality to a library for which you own the source code, follow the .NET guidelines for assembly versioning.</span></span> <span data-ttu-id="832a1-180">如需詳細資訊，請參閱[組件版本控制](../../../standard/assembly/versioning.md)。</span><span class="sxs-lookup"><span data-stu-id="832a1-180">For more information, see [Assembly Versioning](../../../standard/assembly/versioning.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="832a1-181">另請參閱</span><span class="sxs-lookup"><span data-stu-id="832a1-181">See also</span></span>

- [<span data-ttu-id="832a1-182">C # 程式設計指南</span><span class="sxs-lookup"><span data-stu-id="832a1-182">C# Programming Guide</span></span>](../index.md)
- [<span data-ttu-id="832a1-183">平行程式設計範例 (包括許多範例擴充方法)</span><span class="sxs-lookup"><span data-stu-id="832a1-183">Parallel Programming Samples (these include many example extension methods)</span></span>](/samples/browse/?products=dotnet-core%2Cdotnet-standard&term=parallel)
- [<span data-ttu-id="832a1-184">Lambda 運算式</span><span class="sxs-lookup"><span data-stu-id="832a1-184">Lambda Expressions</span></span>](../statements-expressions-operators/lambda-expressions.md)
- [<span data-ttu-id="832a1-185">標準查詢運算子概觀</span><span class="sxs-lookup"><span data-stu-id="832a1-185">Standard Query Operators Overview</span></span>](../concepts/linq/standard-query-operators-overview.md)
- <span data-ttu-id="832a1-186">[Conversion rules for Instance parameters and their impact](https://docs.microsoft.com/archive/blogs/sreekarc/conversion-rules-for-instance-parameters-and-their-impact) (執行個體參數的轉換規則與其影響)</span><span class="sxs-lookup"><span data-stu-id="832a1-186">[Conversion rules for Instance parameters and their impact](https://docs.microsoft.com/archive/blogs/sreekarc/conversion-rules-for-instance-parameters-and-their-impact)</span></span>
- <span data-ttu-id="832a1-187">[Extension methods Interoperability between languages](https://docs.microsoft.com/archive/blogs/sreekarc/extension-methods-interoperability-between-languages) (語言之間擴充方法的互通性)</span><span class="sxs-lookup"><span data-stu-id="832a1-187">[Extension methods Interoperability between languages](https://docs.microsoft.com/archive/blogs/sreekarc/extension-methods-interoperability-between-languages)</span></span>
- <span data-ttu-id="832a1-188">[Extension methods and Curried Delegates](https://docs.microsoft.com/archive/blogs/sreekarc/extension-methods-and-curried-delegates) (擴充方法和局部調用委派)</span><span class="sxs-lookup"><span data-stu-id="832a1-188">[Extension methods and Curried Delegates](https://docs.microsoft.com/archive/blogs/sreekarc/extension-methods-and-curried-delegates)</span></span>
- <span data-ttu-id="832a1-189">[Extension method Binding and Error reporting](https://docs.microsoft.com/archive/blogs/sreekarc/extension-method-binding-and-error-reporting) (擴充方法繫結和錯誤報告)</span><span class="sxs-lookup"><span data-stu-id="832a1-189">[Extension method Binding and Error reporting](https://docs.microsoft.com/archive/blogs/sreekarc/extension-method-binding-and-error-reporting)</span></span>
