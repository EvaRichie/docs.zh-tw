---
title: 字串 - C# 程式設計手冊
description: '深入瞭解 c # 程式設計中的字串。 請參閱宣告和初始化字串、字串物件的非可變性，以及字串 escape 序列的資訊。'
ms.date: 06/27/2019
helpviewer_keywords:
- C# language, strings
- strings [C#]
ms.assetid: 21580405-cb25-4541-89d5-037846a38b07
ms.openlocfilehash: ba2bd6c90fa28624d52e7ef2e341b43da7ea19a2
ms.sourcegitcommit: 5b475c1855b32cf78d2d1bbb4295e4c236f39464
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 09/24/2020
ms.locfileid: "91176210"
---
# <a name="strings-c-programming-guide"></a><span data-ttu-id="d8945-104">字串 (C# 程式設計手冊)</span><span class="sxs-lookup"><span data-stu-id="d8945-104">Strings (C# Programming Guide)</span></span>

<span data-ttu-id="d8945-105">字串是 <xref:System.String> 類型的物件，其值為文字。</span><span class="sxs-lookup"><span data-stu-id="d8945-105">A string is an object of type <xref:System.String> whose value is text.</span></span> <span data-ttu-id="d8945-106">就內部而言，文字會儲存為 <xref:System.Char> 物件的循序唯讀集合。</span><span class="sxs-lookup"><span data-stu-id="d8945-106">Internally, the text is stored as a sequential read-only collection of <xref:System.Char> objects.</span></span> <span data-ttu-id="d8945-107">C# 字串的結尾沒有終止的 Null 字元，因此 C# 字串可以包含任何數目的內嵌 Null 字元 ('\0')。</span><span class="sxs-lookup"><span data-stu-id="d8945-107">There is no null-terminating character at the end of a C# string; therefore a C# string can contain any number of embedded null characters ('\0').</span></span> <span data-ttu-id="d8945-108">字串的 <xref:System.String.Length%2A> 屬性代表它包含的 `Char` 物件數目，而非 Unicode 字元的數目。</span><span class="sxs-lookup"><span data-stu-id="d8945-108">The <xref:System.String.Length%2A> property of a string represents the number of `Char` objects it contains, not the number of Unicode characters.</span></span> <span data-ttu-id="d8945-109">若要存取字串中的個別 Unicode 字碼指標，請使用 <xref:System.Globalization.StringInfo> 物件。</span><span class="sxs-lookup"><span data-stu-id="d8945-109">To access the individual Unicode code points in a string, use the <xref:System.Globalization.StringInfo> object.</span></span>  
  
## <a name="string-vs-systemstring"></a><span data-ttu-id="d8945-110">字串與 system.string 的比較</span><span class="sxs-lookup"><span data-stu-id="d8945-110">string vs. System.String</span></span>  

 <span data-ttu-id="d8945-111">在 C# 中，`string` 關鍵字是 <xref:System.String> 的別名。</span><span class="sxs-lookup"><span data-stu-id="d8945-111">In C#, the `string` keyword is an alias for <xref:System.String>.</span></span> <span data-ttu-id="d8945-112">因此 `String` 和 `string` 為相等，而您可以使用您偏好的命名慣例。</span><span class="sxs-lookup"><span data-stu-id="d8945-112">Therefore, `String` and `string` are equivalent, and you can use whichever naming convention you prefer.</span></span> <span data-ttu-id="d8945-113">`String` 類別提供許多方法來安全地建立、操作和比較字串。</span><span class="sxs-lookup"><span data-stu-id="d8945-113">The `String` class provides many methods for safely creating, manipulating, and comparing strings.</span></span> <span data-ttu-id="d8945-114">此外，C# 語言會多載一些運算子，以簡化常見的字串作業。</span><span class="sxs-lookup"><span data-stu-id="d8945-114">In addition, the C# language overloads some operators to simplify common string operations.</span></span> <span data-ttu-id="d8945-115">如需關鍵字的詳細資訊，請參閱[字串](../../language-reference/builtin-types/reference-types.md)。</span><span class="sxs-lookup"><span data-stu-id="d8945-115">For more information about the keyword, see [string](../../language-reference/builtin-types/reference-types.md).</span></span> <span data-ttu-id="d8945-116">如需類型和其方法的詳細資訊，請參閱 <xref:System.String>。</span><span class="sxs-lookup"><span data-stu-id="d8945-116">For more information about the type and its methods, see <xref:System.String>.</span></span>  
  
## <a name="declaring-and-initializing-strings"></a><span data-ttu-id="d8945-117">宣告並初始化字串</span><span class="sxs-lookup"><span data-stu-id="d8945-117">Declaring and Initializing Strings</span></span>  

 <span data-ttu-id="d8945-118">您可以透過多種方式宣告並初始化字串，如下列範例所示：</span><span class="sxs-lookup"><span data-stu-id="d8945-118">You can declare and initialize strings in various ways, as shown in the following example:</span></span>  
  
 [!code-csharp[csProgGuideStrings#1](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideStrings/CS/Strings.cs#1)]  
  
 <span data-ttu-id="d8945-119">請注意，除了使用字元陣列初始化字串以外，您不能使用 [new](../../language-reference/operators/new-operator.md) 運算子建立字串物件。</span><span class="sxs-lookup"><span data-stu-id="d8945-119">Note that you do not use the [new](../../language-reference/operators/new-operator.md) operator to create a string object except when initializing the string with an array of chars.</span></span>  
  
 <span data-ttu-id="d8945-120">使用 <xref:System.String.Empty> 常數值初始化字串，以建立字串長度為零的新 <xref:System.String> 物件。</span><span class="sxs-lookup"><span data-stu-id="d8945-120">Initialize a string with the <xref:System.String.Empty> constant value to create a new <xref:System.String> object whose string is of zero length.</span></span> <span data-ttu-id="d8945-121">零長度字串的字串常值表示法是 ""。</span><span class="sxs-lookup"><span data-stu-id="d8945-121">The string literal representation of a zero-length string is "".</span></span> <span data-ttu-id="d8945-122">使用 <xref:System.String.Empty> 值初始化字串，而非 [null](../../language-reference/keywords/null.md)，即可降低發生 <xref:System.NullReferenceException> 的機會。</span><span class="sxs-lookup"><span data-stu-id="d8945-122">By initializing strings with the <xref:System.String.Empty> value instead of [null](../../language-reference/keywords/null.md), you can reduce the chances of a <xref:System.NullReferenceException> occurring.</span></span> <span data-ttu-id="d8945-123">使用靜態 <xref:System.String.IsNullOrEmpty%28System.String%29> 方法，先驗證字串的值，再嘗試進行存取。</span><span class="sxs-lookup"><span data-stu-id="d8945-123">Use the static <xref:System.String.IsNullOrEmpty%28System.String%29> method to verify the value of a string before you try to access it.</span></span>  
  
## <a name="immutability-of-string-objects"></a><span data-ttu-id="d8945-124">字串物件的不變性</span><span class="sxs-lookup"><span data-stu-id="d8945-124">Immutability of String Objects</span></span>  

 <span data-ttu-id="d8945-125">字串物件為「不可變」\*\*：它們在建立之後將無法變更。</span><span class="sxs-lookup"><span data-stu-id="d8945-125">String objects are *immutable*: they cannot be changed after they have been created.</span></span> <span data-ttu-id="d8945-126">所有看似會修改字串的 <xref:System.String> 方法和 C# 運算子，實際上會以新的字串物件傳回結果。</span><span class="sxs-lookup"><span data-stu-id="d8945-126">All of the <xref:System.String> methods and C# operators that appear to modify a string actually return the results in a new string object.</span></span> <span data-ttu-id="d8945-127">在下列範例中，當 `s1` 和 `s2` 的內容串連以組成單一字串時，兩個原始字串將不會被修改。</span><span class="sxs-lookup"><span data-stu-id="d8945-127">In the following example, when the contents of `s1` and `s2` are concatenated to form a single string, the two original strings are unmodified.</span></span> <span data-ttu-id="d8945-128">`+=` 運算子會建立新的字串，其中包含結合的內容。</span><span class="sxs-lookup"><span data-stu-id="d8945-128">The `+=` operator creates a new string that contains the combined contents.</span></span> <span data-ttu-id="d8945-129">新的物件會指派給變數 `s1`，而先前指派給 `s1` 的原始物件將會被釋放以進行記憶體回收，因為已經沒有其他具有其參考的變數。</span><span class="sxs-lookup"><span data-stu-id="d8945-129">That new object is assigned to the variable `s1`, and the original object that was assigned to `s1` is released for garbage collection because no other variable holds a reference to it.</span></span>  
  
 [!code-csharp[csProgGuideStrings#2](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideStrings/CS/Strings.cs#2)]  
  
 <span data-ttu-id="d8945-130">因為對字串的「修改」實際上是建立新的字串，當您建立對字串的參考時，必須特別謹慎。</span><span class="sxs-lookup"><span data-stu-id="d8945-130">Because a string "modification" is actually a new string creation, you must use caution when you create references to strings.</span></span> <span data-ttu-id="d8945-131">如果您建立對字串的參考，然後「修改」原始字串，該參考將會繼續指向原始物件，而非修改字串時所建立的新物件。</span><span class="sxs-lookup"><span data-stu-id="d8945-131">If you create a reference to a string, and then "modify" the original string, the reference will continue to point to the original object instead of the new object that was created when the string was modified.</span></span> <span data-ttu-id="d8945-132">下列程式碼說明這個行為：</span><span class="sxs-lookup"><span data-stu-id="d8945-132">The following code illustrates this behavior:</span></span>  
  
 [!code-csharp[csProgGuideStrings#25](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideStrings/CS/Strings.cs#25)]  
  
 <span data-ttu-id="d8945-133">如需有關如何建立以修改為基礎之新字串（例如原始字串上的搜尋和取代作業）的詳細資訊，請參閱 [如何修改字串內容](../../how-to/modify-string-contents.md)。</span><span class="sxs-lookup"><span data-stu-id="d8945-133">For more information about how to create new strings that are based on modifications such as search and replace operations on the original string, see [How to modify string contents](../../how-to/modify-string-contents.md).</span></span>  
  
## <a name="regular-and-verbatim-string-literals"></a><span data-ttu-id="d8945-134">一般和逐字字串常值</span><span class="sxs-lookup"><span data-stu-id="d8945-134">Regular and Verbatim String Literals</span></span>  

 <span data-ttu-id="d8945-135">當您必須內嵌由 C# 所提供的逸出字元時，請使用一般字串常值，如下列範例所示︰</span><span class="sxs-lookup"><span data-stu-id="d8945-135">Use regular string literals when you must embed escape characters provided by C#, as shown in the following example:</span></span>  
  
 [!code-csharp[csProgGuideStrings#3](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideStrings/CS/Strings.cs#3)]  
  
 <span data-ttu-id="d8945-136">當字串文字包含反斜線字元時 (例如檔案路徑)，基於方便性和可讀性，請使用逐字字串。</span><span class="sxs-lookup"><span data-stu-id="d8945-136">Use verbatim strings for convenience and better readability when the string text contains backslash characters, for example in file paths.</span></span> <span data-ttu-id="d8945-137">因為逐字字串會將新行字元保留為字串文字的一部分，因此可以將它們用來初始化多行字串。</span><span class="sxs-lookup"><span data-stu-id="d8945-137">Because verbatim strings preserve new line characters as part of the string text, they can be used to initialize multiline strings.</span></span> <span data-ttu-id="d8945-138">使用雙引號在逐字字串中內嵌引號。</span><span class="sxs-lookup"><span data-stu-id="d8945-138">Use double quotation marks to embed a quotation mark inside a verbatim string.</span></span> <span data-ttu-id="d8945-139">下列範例示範一些逐字字串的常見用法︰</span><span class="sxs-lookup"><span data-stu-id="d8945-139">The following example shows some common uses for verbatim strings:</span></span>  
  
 [!code-csharp[csProgGuideStrings#4](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideStrings/CS/Strings.cs#4)]  
  
## <a name="string-escape-sequences"></a><span data-ttu-id="d8945-140">字串逸出序列</span><span class="sxs-lookup"><span data-stu-id="d8945-140">String Escape Sequences</span></span>  
  
|<span data-ttu-id="d8945-141">逸出序列</span><span class="sxs-lookup"><span data-stu-id="d8945-141">Escape sequence</span></span>|<span data-ttu-id="d8945-142">字元名稱</span><span class="sxs-lookup"><span data-stu-id="d8945-142">Character name</span></span>|<span data-ttu-id="d8945-143">Unicode 編碼</span><span class="sxs-lookup"><span data-stu-id="d8945-143">Unicode encoding</span></span>|  
|---------------------|--------------------|----------------------|  
|<span data-ttu-id="d8945-144">\\'</span><span class="sxs-lookup"><span data-stu-id="d8945-144">\\'</span></span>|<span data-ttu-id="d8945-145">單引號</span><span class="sxs-lookup"><span data-stu-id="d8945-145">Single quote</span></span>|<span data-ttu-id="d8945-146">0x0027</span><span class="sxs-lookup"><span data-stu-id="d8945-146">0x0027</span></span>|  
|<span data-ttu-id="d8945-147">\\"</span><span class="sxs-lookup"><span data-stu-id="d8945-147">\\"</span></span>|<span data-ttu-id="d8945-148">雙引號</span><span class="sxs-lookup"><span data-stu-id="d8945-148">Double quote</span></span>|<span data-ttu-id="d8945-149">0x0022</span><span class="sxs-lookup"><span data-stu-id="d8945-149">0x0022</span></span>|  
|\\\\ |<span data-ttu-id="d8945-150">反斜線</span><span class="sxs-lookup"><span data-stu-id="d8945-150">Backslash</span></span>|<span data-ttu-id="d8945-151">0x005C</span><span class="sxs-lookup"><span data-stu-id="d8945-151">0x005C</span></span>|  
|<span data-ttu-id="d8945-152">\0</span><span class="sxs-lookup"><span data-stu-id="d8945-152">\0</span></span>|<span data-ttu-id="d8945-153">Null</span><span class="sxs-lookup"><span data-stu-id="d8945-153">Null</span></span>|<span data-ttu-id="d8945-154">0x0000</span><span class="sxs-lookup"><span data-stu-id="d8945-154">0x0000</span></span>|  
|<span data-ttu-id="d8945-155">\a</span><span class="sxs-lookup"><span data-stu-id="d8945-155">\a</span></span>|<span data-ttu-id="d8945-156">警示</span><span class="sxs-lookup"><span data-stu-id="d8945-156">Alert</span></span>|<span data-ttu-id="d8945-157">0x0007</span><span class="sxs-lookup"><span data-stu-id="d8945-157">0x0007</span></span>|  
|<span data-ttu-id="d8945-158">\b</span><span class="sxs-lookup"><span data-stu-id="d8945-158">\b</span></span>|<span data-ttu-id="d8945-159">退格鍵</span><span class="sxs-lookup"><span data-stu-id="d8945-159">Backspace</span></span>|<span data-ttu-id="d8945-160">0x0008</span><span class="sxs-lookup"><span data-stu-id="d8945-160">0x0008</span></span>|  
|<span data-ttu-id="d8945-161">\f</span><span class="sxs-lookup"><span data-stu-id="d8945-161">\f</span></span>|<span data-ttu-id="d8945-162">換頁字元</span><span class="sxs-lookup"><span data-stu-id="d8945-162">Form feed</span></span>|<span data-ttu-id="d8945-163">0x000C</span><span class="sxs-lookup"><span data-stu-id="d8945-163">0x000C</span></span>|  
|<span data-ttu-id="d8945-164">\n</span><span class="sxs-lookup"><span data-stu-id="d8945-164">\n</span></span>|<span data-ttu-id="d8945-165">新行</span><span class="sxs-lookup"><span data-stu-id="d8945-165">New line</span></span>|<span data-ttu-id="d8945-166">0x000A</span><span class="sxs-lookup"><span data-stu-id="d8945-166">0x000A</span></span>|  
|<span data-ttu-id="d8945-167">\r</span><span class="sxs-lookup"><span data-stu-id="d8945-167">\r</span></span>|<span data-ttu-id="d8945-168">歸位字元</span><span class="sxs-lookup"><span data-stu-id="d8945-168">Carriage return</span></span>|<span data-ttu-id="d8945-169">0x000D</span><span class="sxs-lookup"><span data-stu-id="d8945-169">0x000D</span></span>|  
|<span data-ttu-id="d8945-170">\t</span><span class="sxs-lookup"><span data-stu-id="d8945-170">\t</span></span>|<span data-ttu-id="d8945-171">水平 Tab 鍵</span><span class="sxs-lookup"><span data-stu-id="d8945-171">Horizontal tab</span></span>|<span data-ttu-id="d8945-172">0x0009</span><span class="sxs-lookup"><span data-stu-id="d8945-172">0x0009</span></span>|  
|<span data-ttu-id="d8945-173">\v</span><span class="sxs-lookup"><span data-stu-id="d8945-173">\v</span></span>|<span data-ttu-id="d8945-174">垂直 Tab 鍵</span><span class="sxs-lookup"><span data-stu-id="d8945-174">Vertical tab</span></span>|<span data-ttu-id="d8945-175">0x000B</span><span class="sxs-lookup"><span data-stu-id="d8945-175">0x000B</span></span>|  
|<span data-ttu-id="d8945-176">\u</span><span class="sxs-lookup"><span data-stu-id="d8945-176">\u</span></span>|<span data-ttu-id="d8945-177">Unicode 逸出序列 (UTF-16)</span><span class="sxs-lookup"><span data-stu-id="d8945-177">Unicode escape sequence (UTF-16)</span></span>|<span data-ttu-id="d8945-178">`\uHHHH` (範圍： 0000-FFFF;範例： `\u00E7` = "ç" ) </span><span class="sxs-lookup"><span data-stu-id="d8945-178">`\uHHHH` (range: 0000 - FFFF; example: `\u00E7` = "ç")</span></span>|  
|<span data-ttu-id="d8945-179">\U</span><span class="sxs-lookup"><span data-stu-id="d8945-179">\U</span></span>|<span data-ttu-id="d8945-180">Unicode 逸出序列 (UTF-32)</span><span class="sxs-lookup"><span data-stu-id="d8945-180">Unicode escape sequence (UTF-32)</span></span>|<span data-ttu-id="d8945-181">`\U00HHHHHH` (範圍： 000000-10FFFF;範例： `\U0001F47D` = "& # x1F47D;") </span><span class="sxs-lookup"><span data-stu-id="d8945-181">`\U00HHHHHH` (range: 000000 - 10FFFF; example: `\U0001F47D` = "&#x1F47D;")</span></span>|  
|<span data-ttu-id="d8945-182">\x</span><span class="sxs-lookup"><span data-stu-id="d8945-182">\x</span></span>|<span data-ttu-id="d8945-183">類似 "\u" (除了變數長度之外) 的 Unicode 逸出序列</span><span class="sxs-lookup"><span data-stu-id="d8945-183">Unicode escape sequence similar to "\u" except with variable length</span></span>|<span data-ttu-id="d8945-184">`\xH[H][H][H]` (範圍： 0-FFFF;範例： `\x00E7` or `\x0E7` 或 `\xE7` = "ç" ) </span><span class="sxs-lookup"><span data-stu-id="d8945-184">`\xH[H][H][H]` (range: 0 - FFFF; example: `\x00E7` or `\x0E7` or `\xE7` = "ç")</span></span>|  
  
> [!WARNING]
> <span data-ttu-id="d8945-185">當使用 `\x` 逸出序列且指定的十六進位數字少於 4 個時，若尾隨在逸出序列之後的字元是有效的十六進位數字 (亦即 0-9、A-F 及 a-f)，這些數字將會被解譯為逸出序列的一部分。</span><span class="sxs-lookup"><span data-stu-id="d8945-185">When using the `\x` escape sequence and specifying less than 4 hex digits, if the characters that immediately follow the escape sequence are valid hex digits (i.e. 0-9, A-F, and a-f), they will be interpreted as being part of the escape sequence.</span></span> <span data-ttu-id="d8945-186">例如 `\xA1` 會產生 "&#161;"，亦即字碼元素 U+00A1。</span><span class="sxs-lookup"><span data-stu-id="d8945-186">For example, `\xA1` produces "&#161;", which is code point U+00A1.</span></span> <span data-ttu-id="d8945-187">倘若下一個字元為 "A" 或 "a"，則逸出序列將會被解譯為 `\xA1A`，進而產生 "&#x0A1A;"，亦即字碼元素 U+0A1A。</span><span class="sxs-lookup"><span data-stu-id="d8945-187">However, if the next character is "A" or "a", then the escape sequence will instead be interpreted as being `\xA1A` and produce "&#x0A1A;", which is code point U+0A1A.</span></span> <span data-ttu-id="d8945-188">由此可知，將 4 個數字全數指定為十六進位數字 (例如 `\x00A1`)，將可避免可能的錯譯。</span><span class="sxs-lookup"><span data-stu-id="d8945-188">In such cases, specifying all 4 hex digits (e.g. `\x00A1` ) will prevent any possible misinterpretation.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="d8945-189">在編譯時期，逐字字串會轉換為具有所有相同逸出序列的一般字串。</span><span class="sxs-lookup"><span data-stu-id="d8945-189">At compile time, verbatim strings are converted to ordinary strings with all the same escape sequences.</span></span> <span data-ttu-id="d8945-190">因此，如果您在偵錯工具監看式視窗中檢視逐字字串，您會看到由編譯器新增的逸出字元，而非來自於您原始程式碼的逐字版本。</span><span class="sxs-lookup"><span data-stu-id="d8945-190">Therefore, if you view a verbatim string in the debugger watch window, you will see the escape characters that were added by the compiler, not the verbatim version from your source code.</span></span> <span data-ttu-id="d8945-191">例如，逐字字串 `@"C:\files.txt"` 會在監看式視窗中顯示為 "C:\\\files.txt"。</span><span class="sxs-lookup"><span data-stu-id="d8945-191">For example, the verbatim string `@"C:\files.txt"` will appear in the watch window as "C:\\\files.txt".</span></span>  
  
## <a name="format-strings"></a><span data-ttu-id="d8945-192">格式字串</span><span class="sxs-lookup"><span data-stu-id="d8945-192">Format Strings</span></span>  

 <span data-ttu-id="d8945-193">格式字串是可在執行階段動態決定其內容的字串。</span><span class="sxs-lookup"><span data-stu-id="d8945-193">A format string is a string whose contents are determined dynamically at runtime.</span></span> <span data-ttu-id="d8945-194">格式字串是透過內嵌「插入的運算式」\*\* 或字串內大括弧內的預留位置來建立的。</span><span class="sxs-lookup"><span data-stu-id="d8945-194">Format strings are created by embedding *interpolated expressions* or placeholders inside of braces within a string.</span></span> <span data-ttu-id="d8945-195">大括弧 (`{...}`) 內的所有內容都會被解析為一個值並在執行階段以格式化字串形式輸出。</span><span class="sxs-lookup"><span data-stu-id="d8945-195">Everything inside the braces (`{...}`) will be resolved to a value and output as a formatted string at runtime.</span></span> <span data-ttu-id="d8945-196">有兩種方式可用來建立格式字串：字串插補與複合格式設定。</span><span class="sxs-lookup"><span data-stu-id="d8945-196">There are two methods to create format strings: string interpolation and composite formatting.</span></span>

### <a name="string-interpolation"></a><span data-ttu-id="d8945-197">字串插值</span><span class="sxs-lookup"><span data-stu-id="d8945-197">String Interpolation</span></span>

<span data-ttu-id="d8945-198">C# 6.0 與更新版本中提供的[*插補字串*](../../language-reference/tokens/interpolated.md)可透過 `$` 特殊字元識別，而且在大括弧中包括插補運算式。</span><span class="sxs-lookup"><span data-stu-id="d8945-198">Available in C# 6.0 and later, [*interpolated strings*](../../language-reference/tokens/interpolated.md) are identified by the `$` special character and include interpolated expressions in braces.</span></span> <span data-ttu-id="d8945-199">如果您是字串插補的新手，請參閱[字串插補 - C# 互動式教學課程](../../tutorials/exploration/interpolated-strings.yml)以取得快速概觀。</span><span class="sxs-lookup"><span data-stu-id="d8945-199">If you are new to string interpolation, see the [String interpolation - C# interactive tutorial](../../tutorials/exploration/interpolated-strings.yml) for a quick overview.</span></span>

<span data-ttu-id="d8945-200">使用字串插補來改進您程式碼的可讀性與可維護性。</span><span class="sxs-lookup"><span data-stu-id="d8945-200">Use string interpolation to improve the readability and maintainability of your code.</span></span> <span data-ttu-id="d8945-201">字串插補可達成與 `String.Format` 方法相同的結果，但可改進使用方便性與內嵌簡潔度。</span><span class="sxs-lookup"><span data-stu-id="d8945-201">String interpolation achieves the same results as the `String.Format` method, but improves ease of use and inline clarity.</span></span>

[!code-csharp[csProgGuideFormatStrings](~/samples/snippets/csharp/programming-guide/strings/Strings_1.cs#StringInterpolation)]

### <a name="composite-formatting"></a><span data-ttu-id="d8945-202">複合格式</span><span class="sxs-lookup"><span data-stu-id="d8945-202">Composite Formatting</span></span>

<span data-ttu-id="d8945-203"><xref:System.String.Format%2A?displayProperty=nameWithType> 利用大括弧內的預留位置來建立格式字串。</span><span class="sxs-lookup"><span data-stu-id="d8945-203">The <xref:System.String.Format%2A?displayProperty=nameWithType> utilizes placeholders in braces to create a format string.</span></span> <span data-ttu-id="d8945-204">此範例可產生與上面使用之字串插補方法類似的輸出。</span><span class="sxs-lookup"><span data-stu-id="d8945-204">This example results in similar output to the string interpolation method used above.</span></span>
  
[!code-csharp[csProgGuideFormatStrings](~/samples/snippets/csharp/programming-guide/strings/Strings_1.cs#StringFormat)]

<span data-ttu-id="d8945-205">如需設定 .NET 類型格式的詳細資訊，請參閱 [.NET 中的格式設定類型](../../../standard/base-types/formatting-types.md)。</span><span class="sxs-lookup"><span data-stu-id="d8945-205">For more information on formatting .NET types see [Formatting Types in .NET](../../../standard/base-types/formatting-types.md).</span></span>
  
## <a name="substrings"></a><span data-ttu-id="d8945-206">子字串</span><span class="sxs-lookup"><span data-stu-id="d8945-206">Substrings</span></span>  

 <span data-ttu-id="d8945-207">子字串是包含在字串中的任何字元序列。</span><span class="sxs-lookup"><span data-stu-id="d8945-207">A substring is any sequence of characters that is contained in a string.</span></span> <span data-ttu-id="d8945-208">使用 <xref:System.String.Substring%2A> 方法，來從原始字串的一部分建立新的字串。</span><span class="sxs-lookup"><span data-stu-id="d8945-208">Use the <xref:System.String.Substring%2A> method to create a new string from a part of the original string.</span></span> <span data-ttu-id="d8945-209">您可以使用 <xref:System.String.IndexOf%2A> 方法，來搜尋子字串的一或多個出現位置。</span><span class="sxs-lookup"><span data-stu-id="d8945-209">You can search for one or more occurrences of a substring by using the <xref:System.String.IndexOf%2A> method.</span></span> <span data-ttu-id="d8945-210">使用 <xref:System.String.Replace%2A> 方法，以新字串取代所有指定的子字串。</span><span class="sxs-lookup"><span data-stu-id="d8945-210">Use the <xref:System.String.Replace%2A> method to replace all occurrences of a specified substring with a new string.</span></span> <span data-ttu-id="d8945-211">與 <xref:System.String.Substring%2A> 方法類似，<xref:System.String.Replace%2A> 實際上會傳回新字串，並不會修改原始字串。</span><span class="sxs-lookup"><span data-stu-id="d8945-211">Like the <xref:System.String.Substring%2A> method, <xref:System.String.Replace%2A> actually returns a new string and does not modify the original string.</span></span> <span data-ttu-id="d8945-212">如需詳細資訊，請參閱 [如何搜尋字串](../../how-to/search-strings.md) 及 [如何修改字串內容](../../how-to/modify-string-contents.md)。</span><span class="sxs-lookup"><span data-stu-id="d8945-212">For more information, see [How to search strings](../../how-to/search-strings.md) and [How to modify string contents](../../how-to/modify-string-contents.md).</span></span>
  
 [!code-csharp[csProgGuideStrings#9](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideStrings/CS/Strings.cs#7)]  
  
## <a name="accessing-individual-characters"></a><span data-ttu-id="d8945-213">存取個別字元</span><span class="sxs-lookup"><span data-stu-id="d8945-213">Accessing Individual Characters</span></span>  

 <span data-ttu-id="d8945-214">您可以搭配索引值使用陣列標記法來取得個別字元的唯讀存取權，如下列範例所示：</span><span class="sxs-lookup"><span data-stu-id="d8945-214">You can use array notation with an index value to acquire read-only access to individual characters, as in the following example:</span></span>  
  
 [!code-csharp[csProgGuideStrings#8](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideStrings/CS/Strings.cs#8)]  
  
 <span data-ttu-id="d8945-215">如果 <xref:System.String> 方法不提供修改字串中個別字元的必要功能，您可以使用 <xref:System.Text.StringBuilder> 物件「就地」修改個別字元，然後使用 <xref:System.Text.StringBuilder> 方法建立新的字串來儲存結果。</span><span class="sxs-lookup"><span data-stu-id="d8945-215">If the <xref:System.String> methods do not provide the functionality that you must have to modify individual characters in a string, you can use a <xref:System.Text.StringBuilder> object to modify the individual chars "in-place", and then create a new string to store the results by using the <xref:System.Text.StringBuilder> methods.</span></span> <span data-ttu-id="d8945-216">在下列範例中，假設您必須以特定方式修改原始字串，並儲存結果以供日後使用︰</span><span class="sxs-lookup"><span data-stu-id="d8945-216">In the following example, assume that you must modify the original string in a particular way and then store the results for future use:</span></span>  
  
 [!code-csharp[csProgGuideStrings#27](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideStrings/CS/Strings.cs#27)]  
  
## <a name="null-strings-and-empty-strings"></a><span data-ttu-id="d8945-217">Null 字串和空字串</span><span class="sxs-lookup"><span data-stu-id="d8945-217">Null Strings and Empty Strings</span></span>  

 <span data-ttu-id="d8945-218">空字串是 <xref:System.String?displayProperty=nameWithType> 物件的執行個體，其中包含零個字元。</span><span class="sxs-lookup"><span data-stu-id="d8945-218">An empty string is an instance of a <xref:System.String?displayProperty=nameWithType> object that contains zero characters.</span></span> <span data-ttu-id="d8945-219">空字串經常用於各種程式設計案例中，來表示空白的文字欄位。</span><span class="sxs-lookup"><span data-stu-id="d8945-219">Empty strings are used often in various programming scenarios to represent a blank text field.</span></span> <span data-ttu-id="d8945-220">您可以對空字串呼叫方法，因為它們是有效的 <xref:System.String?displayProperty=nameWithType> 物件。</span><span class="sxs-lookup"><span data-stu-id="d8945-220">You can call methods on empty strings because they are valid <xref:System.String?displayProperty=nameWithType> objects.</span></span> <span data-ttu-id="d8945-221">空字串會以下列方式初始化︰</span><span class="sxs-lookup"><span data-stu-id="d8945-221">Empty strings are initialized as follows:</span></span>  
  
```csharp  
string s = String.Empty;  
```  
  
 <span data-ttu-id="d8945-222">相較之下，Null 字串指的不是 <xref:System.String?displayProperty=nameWithType> 物件執行個體，而且對 Null 字串呼叫方法的任何嘗試都會導致 <xref:System.NullReferenceException>。</span><span class="sxs-lookup"><span data-stu-id="d8945-222">By contrast, a null string does not refer to an instance of a <xref:System.String?displayProperty=nameWithType> object and any attempt to call a method on a null string causes a <xref:System.NullReferenceException>.</span></span> <span data-ttu-id="d8945-223">不過，您可以在搭配其他字串的串連和比較作業中使用 Null 字串。</span><span class="sxs-lookup"><span data-stu-id="d8945-223">However, you can use null strings in concatenation and comparison operations with other strings.</span></span> <span data-ttu-id="d8945-224">下列範例說明對 Null 字串的參考會造成 (以及不會造成) 擲回例外狀況的一些情況︰</span><span class="sxs-lookup"><span data-stu-id="d8945-224">The following examples illustrate some cases in which a reference to a null string does and does not cause an exception to be thrown:</span></span>  
  
 [!code-csharp[csProgGuideStrings#20](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideStrings/CS/Strings.cs#20)]  
  
## <a name="using-stringbuilder-for-fast-string-creation"></a><span data-ttu-id="d8945-225">使用 StringBuilder 進行快速字串建立</span><span class="sxs-lookup"><span data-stu-id="d8945-225">Using StringBuilder for Fast String Creation</span></span>  

 <span data-ttu-id="d8945-226">.NET 中的字串作業已高度最佳化，在大部分的情況下不會大幅影響效能。</span><span class="sxs-lookup"><span data-stu-id="d8945-226">String operations in .NET are highly optimized and in most cases do not significantly impact performance.</span></span> <span data-ttu-id="d8945-227">不過，在部分案例中 (例如執行數百或數千次的緊密迴圈)，字串作業可能會影響效能。</span><span class="sxs-lookup"><span data-stu-id="d8945-227">However, in some scenarios such as tight loops that are executing many hundreds or thousands of times, string operations can affect performance.</span></span> <span data-ttu-id="d8945-228"><xref:System.Text.StringBuilder> 類別會建立一個字串緩衝區，能在您的程式執行許多字串操作的情況下提供較佳的效能。</span><span class="sxs-lookup"><span data-stu-id="d8945-228">The <xref:System.Text.StringBuilder> class creates a string buffer that offers better performance if your program performs many string manipulations.</span></span> <span data-ttu-id="d8945-229"><xref:System.Text.StringBuilder> 字串也可讓您重新指派內建字串資料類型所不支援的個別字元。</span><span class="sxs-lookup"><span data-stu-id="d8945-229">The <xref:System.Text.StringBuilder> string also enables you to reassign individual characters, something the built-in string data type does not support.</span></span> <span data-ttu-id="d8945-230">例如，下列程式碼能在不建立新字串的情況下變更字串內容：</span><span class="sxs-lookup"><span data-stu-id="d8945-230">This code, for example, changes the content of a string without creating a new string:</span></span>  
  
 [!code-csharp[csProgGuideStrings#15](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideStrings/CS/Strings.cs#15)]  
  
 <span data-ttu-id="d8945-231">在下列範例中，將使用 <xref:System.Text.StringBuilder> 物件從一組數字類型建立字串：</span><span class="sxs-lookup"><span data-stu-id="d8945-231">In this example, a <xref:System.Text.StringBuilder> object is used to create a string from a set of numeric types:</span></span>  
  
 [!code-csharp[TestStringBuilder#1](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideStrings/CS/TestStringBuilder.cs)]
  
## <a name="strings-extension-methods-and-linq"></a><span data-ttu-id="d8945-232">字串、擴充方法和 LINQ</span><span class="sxs-lookup"><span data-stu-id="d8945-232">Strings, Extension Methods and LINQ</span></span>  

 <span data-ttu-id="d8945-233">因為 <xref:System.String> 類型會實作 <xref:System.Collections.Generic.IEnumerable%601>，所以您可以對字串使用 <xref:System.Linq.Enumerable> 類別中所定義的擴充方法。</span><span class="sxs-lookup"><span data-stu-id="d8945-233">Because the <xref:System.String> type implements <xref:System.Collections.Generic.IEnumerable%601>, you can use the extension methods defined in the <xref:System.Linq.Enumerable> class on strings.</span></span> <span data-ttu-id="d8945-234">為了避免視覺雜亂，這些方法會從 <xref:System.String> 類型的 IntelliSense 中排除，不過您還是可以使用它們。</span><span class="sxs-lookup"><span data-stu-id="d8945-234">To avoid visual clutter, these methods are excluded from IntelliSense for the <xref:System.String> type, but they are available nevertheless.</span></span> <span data-ttu-id="d8945-235">您也可以在字串上使用 LINQ 查詢運算式。</span><span class="sxs-lookup"><span data-stu-id="d8945-235">You can also use LINQ query expressions on strings.</span></span> <span data-ttu-id="d8945-236">如需詳細資訊，請參閱 [LINQ 和字串](../concepts/linq/linq-and-strings.md)。</span><span class="sxs-lookup"><span data-stu-id="d8945-236">For more information, see [LINQ and Strings](../concepts/linq/linq-and-strings.md).</span></span>  
  
## <a name="related-topics"></a><span data-ttu-id="d8945-237">[相關主題]</span><span class="sxs-lookup"><span data-stu-id="d8945-237">Related Topics</span></span>  
  
|<span data-ttu-id="d8945-238">主題</span><span class="sxs-lookup"><span data-stu-id="d8945-238">Topic</span></span>|<span data-ttu-id="d8945-239">描述</span><span class="sxs-lookup"><span data-stu-id="d8945-239">Description</span></span>|  
|-----------|-----------------|  
|[<span data-ttu-id="d8945-240">如何修改字串內容</span><span class="sxs-lookup"><span data-stu-id="d8945-240">How to modify string contents</span></span>](../../how-to/modify-string-contents.md)|<span data-ttu-id="d8945-241">說明轉換字串及修改字串內容的技術。</span><span class="sxs-lookup"><span data-stu-id="d8945-241">Illustrates techniques to transform strings and modify the contents of strings.</span></span>|  
|[<span data-ttu-id="d8945-242">如何比較字串</span><span class="sxs-lookup"><span data-stu-id="d8945-242">How to compare strings</span></span>](../../how-to/compare-strings.md)|<span data-ttu-id="d8945-243">示範如何執行字串的序數與文化特定比較。</span><span class="sxs-lookup"><span data-stu-id="d8945-243">Shows how to perform ordinal and culture specific comparisons of strings.</span></span>|  
|[<span data-ttu-id="d8945-244">如何串連多個字串</span><span class="sxs-lookup"><span data-stu-id="d8945-244">How to concatenate multiple strings</span></span>](../../how-to/concatenate-multiple-strings.md)|<span data-ttu-id="d8945-245">示範如何將多個字串聯結成一個的各種方式。</span><span class="sxs-lookup"><span data-stu-id="d8945-245">Demonstrates various ways to join multiple strings into one.</span></span>|
|[<span data-ttu-id="d8945-246">如何使用字串分割來剖析字串</span><span class="sxs-lookup"><span data-stu-id="d8945-246">How to parse strings using String.Split</span></span>](../../how-to/parse-strings-using-split.md)|<span data-ttu-id="d8945-247">包含說明如何使用 `String.Split` 方法剖析字串的程式碼範例。</span><span class="sxs-lookup"><span data-stu-id="d8945-247">Contains code examples that illustrate how to use the `String.Split` method to parse strings.</span></span>|  
|[<span data-ttu-id="d8945-248">如何搜尋字串</span><span class="sxs-lookup"><span data-stu-id="d8945-248">How to search strings</span></span>](../../how-to/search-strings.md)|<span data-ttu-id="d8945-249">說明如何對字串中的特定文字或模式使用搜尋。</span><span class="sxs-lookup"><span data-stu-id="d8945-249">Explains how to use search for specific text or patterns in strings.</span></span>|  
|[<span data-ttu-id="d8945-250">如何判斷字串是否表示數值</span><span class="sxs-lookup"><span data-stu-id="d8945-250">How to determine whether a string represents a numeric value</span></span>](./how-to-determine-whether-a-string-represents-a-numeric-value.md)|<span data-ttu-id="d8945-251">示範如何安全地剖析字串，以查看它是否有有效的數值。</span><span class="sxs-lookup"><span data-stu-id="d8945-251">Shows how to safely parse a string to see whether it has a valid numeric value.</span></span>|  
|[<span data-ttu-id="d8945-252">字串插補</span><span class="sxs-lookup"><span data-stu-id="d8945-252">String interpolation</span></span>](../../language-reference/tokens/interpolated.md)|<span data-ttu-id="d8945-253">描述可提供方便語法以設定格式字串的字串內插補點功能。</span><span class="sxs-lookup"><span data-stu-id="d8945-253">Describes the string interpolation feature that provides a convenient syntax to format strings.</span></span>|
|[<span data-ttu-id="d8945-254">基底字元串作業</span><span class="sxs-lookup"><span data-stu-id="d8945-254">Basic String Operations</span></span>](../../../standard/base-types/basic-string-operations.md)|<span data-ttu-id="d8945-255">提供使用 <xref:System.String?displayProperty=nameWithType> 和 <xref:System.Text.StringBuilder?displayProperty=nameWithType> 方法執行基本字串作業之主題的連結。</span><span class="sxs-lookup"><span data-stu-id="d8945-255">Provides links to topics that use <xref:System.String?displayProperty=nameWithType> and <xref:System.Text.StringBuilder?displayProperty=nameWithType> methods to perform basic string operations.</span></span>|  
|[<span data-ttu-id="d8945-256">剖析字串</span><span class="sxs-lookup"><span data-stu-id="d8945-256">Parsing Strings</span></span>](../../../standard/base-types/parsing-strings.md)|<span data-ttu-id="d8945-257">描述如何將.NET 基底類型的字串表示轉換成對應類型的執行個體。</span><span class="sxs-lookup"><span data-stu-id="d8945-257">Describes how to convert string representations of .NET base types to instances of the corresponding types.</span></span>|  
|[<span data-ttu-id="d8945-258">在 .NET 中剖析日期和時間字串</span><span class="sxs-lookup"><span data-stu-id="d8945-258">Parsing Date and Time Strings in .NET</span></span>](../../../standard/base-types/parsing-datetime.md)|<span data-ttu-id="d8945-259">示範如何將 "01/24/2008" 這類字串轉換為 <xref:System.DateTime?displayProperty=nameWithType> 物件。</span><span class="sxs-lookup"><span data-stu-id="d8945-259">Shows how to convert a string such as "01/24/2008" to a <xref:System.DateTime?displayProperty=nameWithType> object.</span></span>|  
|[<span data-ttu-id="d8945-260">比較字串</span><span class="sxs-lookup"><span data-stu-id="d8945-260">Comparing Strings</span></span>](../../../standard/base-types/comparing.md)|<span data-ttu-id="d8945-261">包含如何比較字串的相關資訊，並提供以 C# 和 Visual Basic 撰寫的範例。</span><span class="sxs-lookup"><span data-stu-id="d8945-261">Includes information about how to compare strings and provides examples in C# and Visual Basic.</span></span>|  
|[<span data-ttu-id="d8945-262">使用 StringBuilder 類別</span><span class="sxs-lookup"><span data-stu-id="d8945-262">Using the StringBuilder Class</span></span>](../../../standard/base-types/stringbuilder.md)|<span data-ttu-id="d8945-263">描述如何使用 <xref:System.Text.StringBuilder> 類別來建立及修改動態字串物件。</span><span class="sxs-lookup"><span data-stu-id="d8945-263">Describes how to create and modify dynamic string objects by using the <xref:System.Text.StringBuilder> class.</span></span>|  
|[<span data-ttu-id="d8945-264">LINQ 和字串</span><span class="sxs-lookup"><span data-stu-id="d8945-264">LINQ and Strings</span></span>](../concepts/linq/linq-and-strings.md)|<span data-ttu-id="d8945-265">提供如何使用 LINQ 查詢來執行各種字串作業的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="d8945-265">Provides information about how to perform various string operations by using LINQ queries.</span></span>|  
|[<span data-ttu-id="d8945-266">C # 程式設計指南</span><span class="sxs-lookup"><span data-stu-id="d8945-266">C# Programming Guide</span></span>](../index.md)|<span data-ttu-id="d8945-267">提供說明 C# 中程式設計建構的主題連結。</span><span class="sxs-lookup"><span data-stu-id="d8945-267">Provides links to topics that explain programming constructs in C#.</span></span>|  
