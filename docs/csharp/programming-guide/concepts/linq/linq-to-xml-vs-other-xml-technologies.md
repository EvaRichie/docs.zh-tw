---
title: LINQ to XML 與其他 XML Technologies3 的比較
description: 本文會比較多個 XML 技術的 LINQ to XML，包括 XmlReader、XSLT、MSXML 和 XmlLite，以協助您決定要使用的技術。
ms.date: 07/20/2015
ms.assetid: 01b8e746-12d3-471d-b811-7539e4547784
ms.openlocfilehash: 0abe6021dae83df0db0d4116eb3c2919d024a62d
ms.sourcegitcommit: 87cfeb69226fef01acb17c56c86f978f4f4a13db
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 07/24/2020
ms.locfileid: "87165333"
---
# <a name="linq-to-xml-vs-other-xml-technologies"></a><span data-ttu-id="9e90e-103">LINQ to XML 比較其他 XML 技術之比較</span><span class="sxs-lookup"><span data-stu-id="9e90e-103">LINQ to XML vs. Other XML Technologies</span></span>
<span data-ttu-id="9e90e-104">這個主題會比較 [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] 與下列 XML 技術：<xref:System.Xml.XmlReader>、XSLT、MSXML 和 XmlLite。</span><span class="sxs-lookup"><span data-stu-id="9e90e-104">This topic compares [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] to the following XML technologies: <xref:System.Xml.XmlReader>, XSLT, MSXML, and XmlLite.</span></span> <span data-ttu-id="9e90e-105">這個資訊可以協助您決定要使用的技術。</span><span class="sxs-lookup"><span data-stu-id="9e90e-105">This information can help you decide which technology to use.</span></span>  
  
 <span data-ttu-id="9e90e-106">如需 [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] 與檔物件模型（DOM）的比較，請參閱[LINQ TO XML 與 Dom （c #）](./linq-to-xml-vs-dom.md)。</span><span class="sxs-lookup"><span data-stu-id="9e90e-106">For a comparison of [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] to the Document Object Model (DOM), see [LINQ to XML vs. DOM (C#)](./linq-to-xml-vs-dom.md).</span></span>  
  
## <a name="linq-to-xml-vs-xmlreader"></a><span data-ttu-id="9e90e-107">LINQ to XML 與 XmlReader 之比較</span><span class="sxs-lookup"><span data-stu-id="9e90e-107">LINQ to XML vs. XmlReader</span></span>  
 <span data-ttu-id="9e90e-108"><xref:System.Xml.XmlReader> 是一個快速、順向、非快取的剖析器。</span><span class="sxs-lookup"><span data-stu-id="9e90e-108"><xref:System.Xml.XmlReader> is a fast, forward-only, non-caching parser.</span></span>  
  
 [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] <span data-ttu-id="9e90e-109">會在 <xref:System.Xml.XmlReader> 頂端實作，而且它們會緊密整合。</span><span class="sxs-lookup"><span data-stu-id="9e90e-109">is implemented on top of <xref:System.Xml.XmlReader>, and they are tightly integrated.</span></span> <span data-ttu-id="9e90e-110">不過，您也可以單獨使用 <xref:System.Xml.XmlReader>。</span><span class="sxs-lookup"><span data-stu-id="9e90e-110">However, you can also use <xref:System.Xml.XmlReader> by itself.</span></span>  
  
 <span data-ttu-id="9e90e-111">例如，假設您要建置每秒將會剖析數百個 XML 文件的 Web 服務，而且這些文件的結構相同，表示您只需要撰寫一個程式碼實作，就可以剖析 XML。</span><span class="sxs-lookup"><span data-stu-id="9e90e-111">For example, suppose you are building a Web service that will parse hundreds of XML documents per second, and the documents have the same structure, meaning that you only have to write one implementation of the code to parse the XML.</span></span> <span data-ttu-id="9e90e-112">在這個情況下，您可能想要單獨使用 <xref:System.Xml.XmlReader>。</span><span class="sxs-lookup"><span data-stu-id="9e90e-112">In this case, you would probably want to use <xref:System.Xml.XmlReader> by itself.</span></span>  
  
 <span data-ttu-id="9e90e-113">相較之下，如果您要建置剖析許多較小 XML 文件的系統，而且每個文件都不同，您可能就會想要利用 [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] 所提供的生產力提升功能。</span><span class="sxs-lookup"><span data-stu-id="9e90e-113">In contrast, if you are building a system that parses many smaller XML documents, and each one is different, you would want to take advantage of the productivity improvements that [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] provides.</span></span>  
  
## <a name="linq-to-xml-vs-xslt"></a><span data-ttu-id="9e90e-114">LINQ to XML 與 XSLT 之比較</span><span class="sxs-lookup"><span data-stu-id="9e90e-114">LINQ to XML vs. XSLT</span></span>  
 <span data-ttu-id="9e90e-115">[!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] 和 XSLT 都提供大量的 XML 文件轉換功能。</span><span class="sxs-lookup"><span data-stu-id="9e90e-115">Both [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] and XSLT provide extensive XML document transformation capabilities.</span></span> <span data-ttu-id="9e90e-116">XSLT 是一種以規則為基礎的宣告式方法。</span><span class="sxs-lookup"><span data-stu-id="9e90e-116">XSLT is a rule-based, declarative approach.</span></span> <span data-ttu-id="9e90e-117">高級的 XSLT 程式設計人員會以功能性程式設計方式，撰寫強調沒有狀態 (Stateless) 方法的 XSLT。</span><span class="sxs-lookup"><span data-stu-id="9e90e-117">Advanced XSLT programmers write XSLT in a functional programming style that emphasizes a stateless approach.</span></span> <span data-ttu-id="9e90e-118">您可以使用實作時沒有副作用的純虛擬函式來撰寫轉換。</span><span class="sxs-lookup"><span data-stu-id="9e90e-118">Transformations can be written using pure functions that are implemented without side effects.</span></span> <span data-ttu-id="9e90e-119">許多開發人員不熟悉這個以規則為基礎或功能性方法，而且學習起來可能既困難又耗時。</span><span class="sxs-lookup"><span data-stu-id="9e90e-119">This rule-based or functional approach is unfamiliar to many developers, and can be difficult and time-consuming to learn.</span></span>  
  
 <span data-ttu-id="9e90e-120">XSLT 可以是非常有產能的系統，可產生高效能的應用程式。</span><span class="sxs-lookup"><span data-stu-id="9e90e-120">XSLT can be a very productive system that yields high-performance applications.</span></span> <span data-ttu-id="9e90e-121">例如，有些大型的網路公司會使用 XSLT，根據已經從各種資料存放區提取的 XML 產生 HTML。</span><span class="sxs-lookup"><span data-stu-id="9e90e-121">For example, some big Web companies use XSLT as a way to generate HTML from XML that has been pulled from a variety of data stores.</span></span> <span data-ttu-id="9e90e-122">Managed XSLT 引擎會將 XSLT 編譯為 CLR 程式碼，而且在某些案例中的效能，甚至比原始 XSLT 引擎更好。</span><span class="sxs-lookup"><span data-stu-id="9e90e-122">The managed XSLT engine compiles XSLT to CLR code, and performs even better in some scenarios than the native XSLT engine.</span></span>  
  
 <span data-ttu-id="9e90e-123">不過，XSLT 不會使用許多開發人員已經具備的 C# 和 Visual Basic 知識。</span><span class="sxs-lookup"><span data-stu-id="9e90e-123">However, XSLT does not take advantage of the C# and Visual Basic knowledge that many developers have.</span></span> <span data-ttu-id="9e90e-124">它需要開發人員以不同而且複雜的程式設計語言撰寫程式碼。</span><span class="sxs-lookup"><span data-stu-id="9e90e-124">It requires developers to write code in a different and complex programming language.</span></span> <span data-ttu-id="9e90e-125">使用兩個非整合式開發系統 (例如，C# (或 Visual Basic) 和 XSLT) 會使軟體系統難以開發與維護。</span><span class="sxs-lookup"><span data-stu-id="9e90e-125">Using two non-integrated development systems such as C# (or Visual Basic) and XSLT results in software systems that are more difficult to develop and maintain.</span></span>  
  
 <span data-ttu-id="9e90e-126">在您熟練 [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] 查詢運算式後，[!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] 轉換即可成為功能強大且易於使用的技術。</span><span class="sxs-lookup"><span data-stu-id="9e90e-126">After you have mastered [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] query expressions, [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] transformations are a powerful technology that is easy to use.</span></span> <span data-ttu-id="9e90e-127">基本上，您可以形成自己的 XML 文件，方法是，使用功能結構、從各種來源納入資料、動態建構 <xref:System.Xml.Linq.XElement> 物件，然後將全部組合成一個新的 XML 樹狀結構。</span><span class="sxs-lookup"><span data-stu-id="9e90e-127">Basically, you form your XML document by using functional construction, pulling in data from various sources, constructing <xref:System.Xml.Linq.XElement> objects dynamically, and assembling the whole into a new XML tree.</span></span> <span data-ttu-id="9e90e-128">轉換可以產生全新的文件。</span><span class="sxs-lookup"><span data-stu-id="9e90e-128">The transformation can generate a completely new document.</span></span> <span data-ttu-id="9e90e-129">在 [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] 中進行建構轉換是相當容易與直覺化的作業，並會產生可讀的程式碼。</span><span class="sxs-lookup"><span data-stu-id="9e90e-129">Constructing transformations in [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] is relatively easy and intuitive, and the resulting code is readable.</span></span> <span data-ttu-id="9e90e-130">這會降低開發與維護的成本。</span><span class="sxs-lookup"><span data-stu-id="9e90e-130">This reduces development and maintenance costs.</span></span>  
  
 [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] <span data-ttu-id="9e90e-131">並不是要取代 XSLT。</span><span class="sxs-lookup"><span data-stu-id="9e90e-131">is not intended to replace XSLT.</span></span> <span data-ttu-id="9e90e-132">XSLT 仍然是複雜的文件中心 XML 轉換的最佳工具選擇，特別是在沒有正確定義文件結構時。</span><span class="sxs-lookup"><span data-stu-id="9e90e-132">XSLT is still the tool of choice for complicated and document-centric XML transformations, especially if the structure of the document is not well defined.</span></span>  
  
 <span data-ttu-id="9e90e-133">XSLT 具有做為全球資訊網協會 (W3C) 標準的優點。</span><span class="sxs-lookup"><span data-stu-id="9e90e-133">XSLT has the advantage of being a World Wide Web Consortium (W3C) standard.</span></span> <span data-ttu-id="9e90e-134">如果您的需求為只使用標準的技術，XSLT 可能更合適。</span><span class="sxs-lookup"><span data-stu-id="9e90e-134">If you have a requirement that you use only technologies that are standards, XSLT might be more appropriate.</span></span>  
  
 <span data-ttu-id="9e90e-135">XSLT 是 XML，因此可以用程式設計方式操作。</span><span class="sxs-lookup"><span data-stu-id="9e90e-135">XSLT is XML, and therefore can be programmatically manipulated.</span></span>  
  
## <a name="linq-to-xml-vs-msxml"></a><span data-ttu-id="9e90e-136">LINQ to XML 與 MSXML 之比較</span><span class="sxs-lookup"><span data-stu-id="9e90e-136">LINQ to XML vs. MSXML</span></span>  
 <span data-ttu-id="9e90e-137">MSXML 是 COM 架構的技術，用於處理 Microsoft Windows 隨附的 XML。</span><span class="sxs-lookup"><span data-stu-id="9e90e-137">MSXML is the COM-based technology for processing XML that is included with Microsoft Windows.</span></span> <span data-ttu-id="9e90e-138">MSXML 會提供 DOM 的原始實作 (包含對於 XPath 和 XSLT 的支援)，</span><span class="sxs-lookup"><span data-stu-id="9e90e-138">MSXML provides a native implementation of the DOM with support for XPath and XSLT.</span></span> <span data-ttu-id="9e90e-139">同時也包含 SAX2 非快取的事件型剖析器。</span><span class="sxs-lookup"><span data-stu-id="9e90e-139">It also contains the SAX2 non-caching, event-based parser.</span></span>  
  
 <span data-ttu-id="9e90e-140">MSXML 運作良好、在大部分的案例中預設是安全的，而且可以在 Internet Explorer 中存取，以便在 AJAX 型的應用程式中執行用戶端的 XML 處理。</span><span class="sxs-lookup"><span data-stu-id="9e90e-140">MSXML performs well, is secure by default in most scenarios, and can be accessed in Internet Explorer for performing client-side XML processing in AJAX-style applications.</span></span> <span data-ttu-id="9e90e-141">從支援 COM (包括 C++、JavaScript 和 Visual Basic 6.0) 的任何程式設計語言都可以使用 MSXML。</span><span class="sxs-lookup"><span data-stu-id="9e90e-141">MSXML can be used from any programming language that supports COM, including C++, JavaScript, and Visual Basic 6.0.</span></span>  
  
 <span data-ttu-id="9e90e-142">根據 Common Language Runtime (CLR)，不建議將 MSXML 用於 Managed 程式碼中。</span><span class="sxs-lookup"><span data-stu-id="9e90e-142">MSXML is not recommended for use in managed code based on the common language runtime (CLR).</span></span>  
  
## <a name="linq-to-xml-vs-xmllite"></a><span data-ttu-id="9e90e-143">LINQ to XML 與 XmlLite 之比較</span><span class="sxs-lookup"><span data-stu-id="9e90e-143">LINQ to XML vs. XmlLite</span></span>  
 <span data-ttu-id="9e90e-144">XmlLite 是一個非快取、順向、提取的剖析器。</span><span class="sxs-lookup"><span data-stu-id="9e90e-144">XmlLite is a non-caching, forward only, pull parser.</span></span> <span data-ttu-id="9e90e-145">開發人員主要會使用 XmlLite 搭配 C++。</span><span class="sxs-lookup"><span data-stu-id="9e90e-145">Developers primarily use XmlLite with C++.</span></span> <span data-ttu-id="9e90e-146">不建議開發人員使用 XmlLite 搭配 Managed 程式碼。</span><span class="sxs-lookup"><span data-stu-id="9e90e-146">It is not recommended for developers to use XmlLite with managed code.</span></span>  
  
 <span data-ttu-id="9e90e-147">XmlLite 的主要優點在於它是一個快速的輕量型 XML 剖析器，在大部分的案例中是安全的。</span><span class="sxs-lookup"><span data-stu-id="9e90e-147">The main advantage of XmlLite is that it is a lightweight, fast XML parser that is secure in most scenarios.</span></span> <span data-ttu-id="9e90e-148">其威脅表面區域非常小。</span><span class="sxs-lookup"><span data-stu-id="9e90e-148">Its threat surface area is very small.</span></span> <span data-ttu-id="9e90e-149">如果您必須剖析不受信任的文件，而且您想要防止諸如阻絕服務或洩漏資料等攻擊，XmlLite 可能是一個相當好的選擇。</span><span class="sxs-lookup"><span data-stu-id="9e90e-149">If you have to parse untrusted documents and you want to protect against attacks such as denial of service or exposure of data, XmlLite might be a good option.</span></span>  
  
 <span data-ttu-id="9e90e-150">XmlLite 未與語言整合式查詢（LINQ）整合。</span><span class="sxs-lookup"><span data-stu-id="9e90e-150">XmlLite is not integrated with Language-Integrated Query (LINQ).</span></span> <span data-ttu-id="9e90e-151">它不會產生程式設計人員產能改進，這是 LINQ 背後的動機。</span><span class="sxs-lookup"><span data-stu-id="9e90e-151">It does not yield the programmer productivity improvements that are the motivating force behind LINQ.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="9e90e-152">另請參閱</span><span class="sxs-lookup"><span data-stu-id="9e90e-152">See also</span></span>

- [<span data-ttu-id="9e90e-153">使用者入門 (LINQ to XML)</span><span class="sxs-lookup"><span data-stu-id="9e90e-153">Getting Started (LINQ to XML)</span></span>](./linq-to-xml-overview.md)
