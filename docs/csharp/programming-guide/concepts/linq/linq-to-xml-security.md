---
title: LINQ to XML 安全性 (C#)
description: 瞭解與 LINQ to XML 相關聯的安全性問題，包括減輕安全性風險的一些指引。
ms.date: 07/20/2015
ms.assetid: ef2c0dc9-ecf9-4c17-b24e-144184ab725f
ms.openlocfilehash: dc9fd13f19dcf6d9cbbb2b0b7608009cc4da1108
ms.sourcegitcommit: 87cfeb69226fef01acb17c56c86f978f4f4a13db
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 07/24/2020
ms.locfileid: "87165313"
---
# <a name="linq-to-xml-security-c"></a><span data-ttu-id="32e63-103">LINQ to XML 安全性 (C#)</span><span class="sxs-lookup"><span data-stu-id="32e63-103">LINQ to XML Security (C#)</span></span>
<span data-ttu-id="32e63-104">這個主題描述與 LINQ to XML 相關聯的安全性問題。</span><span class="sxs-lookup"><span data-stu-id="32e63-104">This topic describes security issues associated with LINQ to XML.</span></span> <span data-ttu-id="32e63-105">此外，還提供減少暴露安全性的部分指引。</span><span class="sxs-lookup"><span data-stu-id="32e63-105">In addition, it provides some guidance for mitigating security exposure.</span></span>  
  
## <a name="linq-to-xml-security-overview"></a><span data-ttu-id="32e63-106">LINQ to XML 安全性概觀</span><span class="sxs-lookup"><span data-stu-id="32e63-106">LINQ to XML Security Overview</span></span>  
 <span data-ttu-id="32e63-107">與伺服器端應用程式嚴苛的安全性需求相較，LINQ to XML 的設計偏重於程式設計的便利性。</span><span class="sxs-lookup"><span data-stu-id="32e63-107">LINQ to XML is designed more for programming convenience than for server-side applications with stringent security requirements.</span></span> <span data-ttu-id="32e63-108">大部分 XML 案例包含處理受信任的 XML 文件，而不包含處理已上載至伺服器之不受信任的 XML 文件。</span><span class="sxs-lookup"><span data-stu-id="32e63-108">Most XML scenarios consist of processing trusted XML documents, rather than processing untrusted XML documents that are uploaded to a server.</span></span> <span data-ttu-id="32e63-109">LINQ to XML 最適合這些案例。</span><span class="sxs-lookup"><span data-stu-id="32e63-109">LINQ to XML is optimized for these scenarios.</span></span>  
  
 <span data-ttu-id="32e63-110">如果您必須從未知的來源處理不受信任的資料，Microsoft 建議您使用 <xref:System.Xml.XmlReader> 類別的執行個體，該類別已設定為篩選掉已知的 XML 阻絕服務 (DoS) 攻擊。</span><span class="sxs-lookup"><span data-stu-id="32e63-110">If you must process untrusted data from unknown sources, Microsoft recommends that you use an instance of the <xref:System.Xml.XmlReader> class that has been configured to filter out known XML denial of service (DoS) attacks.</span></span>  
  
 <span data-ttu-id="32e63-111">如果您已經將 <xref:System.Xml.XmlReader> 設定為減少阻絕服務攻擊，您可以使用該讀取器填入 LINQ to XML 樹狀結構，而且仍然可以享受 LINQ to XML 的程式設計師產能加強功能。</span><span class="sxs-lookup"><span data-stu-id="32e63-111">If you have configured an <xref:System.Xml.XmlReader> to mitigate denial of service attacks, you can use that reader to populate a LINQ to XML tree and still benefit from the programmer productivity enhancements of LINQ to XML.</span></span> <span data-ttu-id="32e63-112">多數防護技術包括建立設定為減少安全性問題的讀取器，然後透過已設定的讀取器具現化 XML 樹狀結構。</span><span class="sxs-lookup"><span data-stu-id="32e63-112">Many mitigation techniques involve creating readers that are configured to mitigate the security issue, and then instantiating an XML tree through the configured reader.</span></span>  
  
 <span data-ttu-id="32e63-113">XML 在本質上容易遭到阻絕服務攻擊，因為文件的大小、深度、項目名稱大小等等沒有受到限制。</span><span class="sxs-lookup"><span data-stu-id="32e63-113">XML is intrinsically vulnerable to denial of service attacks because documents are unbounded in size, depth, element name size, and more.</span></span> <span data-ttu-id="32e63-114">不論您使用什麼元件處理 XML，如果該元件使用過多的資源，您務必要做好循環使用應用程式網域的準備。</span><span class="sxs-lookup"><span data-stu-id="32e63-114">Regardless of the component that you use to process XML, you should always be prepared to recycle the application domain if it uses excessive resources.</span></span>  
  
## <a name="mitigation-of-xml-xsd-xpath-and-xslt-attacks"></a><span data-ttu-id="32e63-115">減少 XML、XSD、XPath 和 XSLT 攻擊</span><span class="sxs-lookup"><span data-stu-id="32e63-115">Mitigation of XML, XSD, XPath, and XSLT Attacks</span></span>  
 <span data-ttu-id="32e63-116">LINQ to XML 是根據 <xref:System.Xml.XmlReader> 和 <xref:System.Xml.XmlWriter> 建置。</span><span class="sxs-lookup"><span data-stu-id="32e63-116">LINQ to XML is built upon <xref:System.Xml.XmlReader> and <xref:System.Xml.XmlWriter>.</span></span> <span data-ttu-id="32e63-117">LINQ to XML 透過 <xref:System.Xml.Schema?displayProperty=nameWithType> 和 <xref:System.Xml.XPath?displayProperty=nameWithType> 命名空間中的擴充方法，支援 XSD 和 XPath。</span><span class="sxs-lookup"><span data-stu-id="32e63-117">LINQ to XML supports XSD and XPath through extension methods in the <xref:System.Xml.Schema?displayProperty=nameWithType> and <xref:System.Xml.XPath?displayProperty=nameWithType> namespaces.</span></span> <span data-ttu-id="32e63-118">使用 <xref:System.Xml.XmlReader>、<xref:System.Xml.XPath.XPathNavigator> 和 <xref:System.Xml.XmlWriter> 類別搭配 LINQ to XML 時，您可以叫用 XSLT 來轉換 XML 樹狀結構。</span><span class="sxs-lookup"><span data-stu-id="32e63-118">Using the <xref:System.Xml.XmlReader>, <xref:System.Xml.XPath.XPathNavigator>, and <xref:System.Xml.XmlWriter> classes in conjunction with LINQ to XML, you can invoke XSLT to transform XML trees.</span></span>  
  
 <span data-ttu-id="32e63-119">如果您要在較不安全的環境下操作，則會有一些與 XML 相關聯的安全性問題，以及在 <xref:System.Xml?displayProperty=nameWithType>、<xref:System.Xml.Schema?displayProperty=nameWithType>、<xref:System.Xml.XPath?displayProperty=nameWithType> 和 <xref:System.Xml.Xsl?displayProperty=nameWithType> 中使用類別的安全性問題。</span><span class="sxs-lookup"><span data-stu-id="32e63-119">If you are operating in a less secure environment, there are a number of security issues that are associated with XML and the use of the classes in <xref:System.Xml?displayProperty=nameWithType>, <xref:System.Xml.Schema?displayProperty=nameWithType>, <xref:System.Xml.XPath?displayProperty=nameWithType>, and <xref:System.Xml.Xsl?displayProperty=nameWithType>.</span></span> <span data-ttu-id="32e63-120">這些包括 (但不限於) 下列問題：</span><span class="sxs-lookup"><span data-stu-id="32e63-120">These issues include, but are not limited to, the following:</span></span>  
  
- <span data-ttu-id="32e63-121">XSD、XPath 和 XSLT 是以字串為基礎的語言，您在其中指定的作業可能會耗用大量的時間與金錢。</span><span class="sxs-lookup"><span data-stu-id="32e63-121">XSD, XPath, and XSLT are string-based languages in which you can specify operations that consume a lot of time or memory.</span></span> <span data-ttu-id="32e63-122">從不受信任的來源取出 XSD、XPath 或 XSLT 字串的應用程式設計人員要負責驗證這些不是惡意的字串，或監視與降低評估這些字串將導致過度耗用系統資源的可能性。</span><span class="sxs-lookup"><span data-stu-id="32e63-122">It is the responsibility of application programmers who take XSD, XPath, or XSLT strings from untrusted sources to validate that the strings are not malicious, or to monitor and mitigate the possibility that evaluating these strings will lead to excessive system resource consumption.</span></span>  
  
- <span data-ttu-id="32e63-123">XSD 結構描述 (包括內嵌結構描述) 在本質上容易遭到阻絕服務攻擊；您不應接受來自不受支援之來源的結構描述。</span><span class="sxs-lookup"><span data-stu-id="32e63-123">XSD schemas (including inline schemas) are inherently vulnerable to denial of service attacks; you should not accept schemas from untrusted sources.</span></span>  
  
- <span data-ttu-id="32e63-124">XSD 和 XSLT 可能包含其他檔案的參考，而且這類的參考可能會導致跨區域和跨網域的攻擊。</span><span class="sxs-lookup"><span data-stu-id="32e63-124">XSD and XSLT can include references to other files, and such references can result in cross-zone and cross-domain attacks.</span></span>  
  
- <span data-ttu-id="32e63-125">DTD 中的外部實體可能導致跨區域和跨網域的攻擊。</span><span class="sxs-lookup"><span data-stu-id="32e63-125">External entities in DTDs can result in cross-zone and cross-domain attacks.</span></span>  
  
- <span data-ttu-id="32e63-126">DTD 容易遭到阻絕服務攻擊。</span><span class="sxs-lookup"><span data-stu-id="32e63-126">DTDs are vulnerable to denial of service attacks.</span></span>  
  
- <span data-ttu-id="32e63-127">特別深的 XML 文件可能會提出阻絕服務問題；您可能想要限制 XML 文件的深度。</span><span class="sxs-lookup"><span data-stu-id="32e63-127">Exceptionally deep XML documents can pose denial of service issues; you might want to limit the depth of XML documents.</span></span>  
  
- <span data-ttu-id="32e63-128">請勿接受來自不受信任組件的支援元件，例如，<xref:System.Xml.NameTable>、<xref:System.Xml.XmlNamespaceManager> 和 <xref:System.Xml.XmlResolver> 物件。</span><span class="sxs-lookup"><span data-stu-id="32e63-128">Do not accept supporting components, such as <xref:System.Xml.NameTable>, <xref:System.Xml.XmlNamespaceManager>, and <xref:System.Xml.XmlResolver> objects, from untrusted assemblies.</span></span>  
  
- <span data-ttu-id="32e63-129">讀取區塊中的資料以減少大型文件的攻擊。</span><span class="sxs-lookup"><span data-stu-id="32e63-129">Read data in chunks to mitigate large document attacks.</span></span>  
  
- <span data-ttu-id="32e63-130">XSLT 樣式表中的指令碼區塊可能會暴露多個攻擊。</span><span class="sxs-lookup"><span data-stu-id="32e63-130">Script blocks in XSLT style sheets can expose a number of attacks.</span></span>  
  
- <span data-ttu-id="32e63-131">建構動態 XPath 運算式前，請仔細驗證。</span><span class="sxs-lookup"><span data-stu-id="32e63-131">Validate carefully before constructing dynamic XPath expressions.</span></span>  
  
## <a name="linq-to-xml-security-issues"></a><span data-ttu-id="32e63-132">LINQ to XML 安全性問題</span><span class="sxs-lookup"><span data-stu-id="32e63-132">LINQ to XML Security Issues</span></span>  
 <span data-ttu-id="32e63-133">本主題中的安全性問題不會以特定的順序呈現。</span><span class="sxs-lookup"><span data-stu-id="32e63-133">The security issues in this topic are not presented in any particular order.</span></span> <span data-ttu-id="32e63-134">所有問題都同等重要，而且應該妥善處理。</span><span class="sxs-lookup"><span data-stu-id="32e63-134">All issues are important and should be addressed as appropriate.</span></span>  
  
 <span data-ttu-id="32e63-135">成功的權限提高攻擊可讓惡意組件更能掌控其環境。</span><span class="sxs-lookup"><span data-stu-id="32e63-135">A successful elevation of privilege attack gives a malicious assembly more control over its environment.</span></span> <span data-ttu-id="32e63-136">成功的權限提高攻擊可能會導致資料洩漏、阻絕服務等等。</span><span class="sxs-lookup"><span data-stu-id="32e63-136">A successful elevation of privilege attack can result in disclosure of data, denial of service, and more.</span></span>  
  
 <span data-ttu-id="32e63-137">應用程式不應將資料洩漏給沒有查看該資料之權限的使用者。</span><span class="sxs-lookup"><span data-stu-id="32e63-137">Applications should not disclose data to users who are not authorized to see that data.</span></span>  
  
 <span data-ttu-id="32e63-138">阻絕服務攻擊會使 XML 剖析器 (Parser) 或 LINQ to XML 消耗過多的記憶體或 CPU 時間。</span><span class="sxs-lookup"><span data-stu-id="32e63-138">Denial of service attacks cause the XML parser or LINQ to XML to consume excessive amounts of memory or CPU time.</span></span> <span data-ttu-id="32e63-139">相較於權限提高攻擊或洩漏資料攻擊，阻絕服務攻擊被視為較不嚴重。</span><span class="sxs-lookup"><span data-stu-id="32e63-139">Denial of service attacks are considered to be less severe than elevation of privilege attacks or disclosure of data attacks.</span></span> <span data-ttu-id="32e63-140">不過，如果是在伺服器需要處理來自不受信任來源之 XML 文件的情況下，阻絕服務攻擊就很重要。</span><span class="sxs-lookup"><span data-stu-id="32e63-140">However, they are important in a scenario where a server needs to process XML documents from untrusted sources.</span></span>  
  
### <a name="exceptions-and-error-messages-might-reveal-data"></a><span data-ttu-id="32e63-141">例外情形與錯誤訊息可能會顯示資料</span><span class="sxs-lookup"><span data-stu-id="32e63-141">Exceptions and Error Messages Might Reveal Data</span></span>  
 <span data-ttu-id="32e63-142">錯誤的描述可能會顯示資料，例如，要轉換的資料、檔案名稱或實作詳細資料。</span><span class="sxs-lookup"><span data-stu-id="32e63-142">The description of an error might reveal data, such as the data being transformed, file names, or implementation details.</span></span> <span data-ttu-id="32e63-143">錯誤訊息不得公開給不受信任的呼叫端。</span><span class="sxs-lookup"><span data-stu-id="32e63-143">Error messages should not be exposed to callers that are not trusted.</span></span> <span data-ttu-id="32e63-144">您應該取得所有錯誤，並利用您自己自訂的錯誤訊息報告錯誤。</span><span class="sxs-lookup"><span data-stu-id="32e63-144">You should catch all errors and report errors with your own custom error messages.</span></span>  
  
### <a name="do-not-call-codeaccesspermissionsassert-in-an-event-handler"></a><span data-ttu-id="32e63-145">請勿在事件處理常式中呼叫 CodeAccessPermissions.Assert</span><span class="sxs-lookup"><span data-stu-id="32e63-145">Do Not Call CodeAccessPermissions.Assert in an Event Handler</span></span>  
 <span data-ttu-id="32e63-146">組件的權限可大可小。</span><span class="sxs-lookup"><span data-stu-id="32e63-146">An assembly can have lesser or greater permissions.</span></span> <span data-ttu-id="32e63-147">權限較大的組件對電腦及其環境有較大的掌控能力。</span><span class="sxs-lookup"><span data-stu-id="32e63-147">An assembly that has greater permissions has greater control over the computer and its environments.</span></span>  
  
 <span data-ttu-id="32e63-148">如果權限較大之組件中的程式碼在事件處理常式中呼叫 <xref:System.Security.CodeAccessPermission.Assert%2A?displayProperty=nameWithType>，然後將 XML 樹狀結構傳遞到具有限制權限的惡意組件，惡意組件可能會引發事件。</span><span class="sxs-lookup"><span data-stu-id="32e63-148">If code in an assembly with greater permissions calls <xref:System.Security.CodeAccessPermission.Assert%2A?displayProperty=nameWithType> in an event handler, and then the XML tree is passed to a malicious assembly that has restricted permissions, the malicious assembly can cause an event to be raised.</span></span> <span data-ttu-id="32e63-149">由於事件會在權限較大的組件中執行程式碼，因此惡意組件會以更高的權限操作。</span><span class="sxs-lookup"><span data-stu-id="32e63-149">Because the event runs code that is in the assembly with greater permissions, the malicious assembly would then be operating with elevated privileges.</span></span>  
  
 <span data-ttu-id="32e63-150">Microsoft 建議您絕對不要在事件處理常式中呼叫 <xref:System.Security.CodeAccessPermission.Assert%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="32e63-150">Microsoft recommends that you never call <xref:System.Security.CodeAccessPermission.Assert%2A?displayProperty=nameWithType> in an event handler.</span></span>  
  
### <a name="dtds-are-not-secure"></a><span data-ttu-id="32e63-151">DTD 不安全</span><span class="sxs-lookup"><span data-stu-id="32e63-151">DTDs are Not Secure</span></span>  
 <span data-ttu-id="32e63-152">DTD 中的實體本質上就不安全。</span><span class="sxs-lookup"><span data-stu-id="32e63-152">Entities in DTDs are inherently not secure.</span></span> <span data-ttu-id="32e63-153">包含 DTD 的惡意 XML 文件可能會讓剖析器用掉所有記憶體和 CPU 時間，造成阻絕服務攻擊。</span><span class="sxs-lookup"><span data-stu-id="32e63-153">It is possible for a malicious XML document that contains a DTD to cause the parser to use all memory and CPU time, causing a denial of service attack.</span></span> <span data-ttu-id="32e63-154">因此，在 LINQ to XML 中，預設會關閉 DTD 處理。</span><span class="sxs-lookup"><span data-stu-id="32e63-154">Therefore, in LINQ to XML, DTD processing is turned off by default.</span></span> <span data-ttu-id="32e63-155">您不應該接受來自不受信任來源的 DTD。</span><span class="sxs-lookup"><span data-stu-id="32e63-155">You should not accept DTDs from untrusted sources.</span></span>  
  
 <span data-ttu-id="32e63-156">從不受信任來源接受 DTD 的其中一個範例為 Web 應用程式，它可讓 Web 使用者上載參考 DTD 和 DTD 檔案的 XML 檔案。</span><span class="sxs-lookup"><span data-stu-id="32e63-156">One example of accepting DTDs from untrusted sources is a Web application that allows Web users to upload an XML file that references a DTD and a DTD file.</span></span> <span data-ttu-id="32e63-157">檔案經過驗證後，惡意的 DTD 就可以在您的伺服器上執行阻絕服務攻擊。</span><span class="sxs-lookup"><span data-stu-id="32e63-157">Upon validation of the file, a malicious DTD could execute a denial of service attack on your server.</span></span> <span data-ttu-id="32e63-158">從不受信任來源接受 FTP 的另一個範例為參考網路共用上也允許匿名 FTP 存取的 DTD。</span><span class="sxs-lookup"><span data-stu-id="32e63-158">Another example of accepting DTDs from untrusted sources is to reference a DTD on a network share that also allows anonymous FTP access.</span></span>  
  
### <a name="avoid-excessive-buffer-allocation"></a><span data-ttu-id="32e63-159">避免配置過度的緩衝區</span><span class="sxs-lookup"><span data-stu-id="32e63-159">Avoid Excessive Buffer Allocation</span></span>  
 <span data-ttu-id="32e63-160">應用程式開發人員應該知道，過大的資料來源可能會導致資源耗盡與阻絕服務攻擊。</span><span class="sxs-lookup"><span data-stu-id="32e63-160">Application developers should be aware that extremely large data sources can lead to resource exhaustion and denial of service attacks.</span></span>  
  
 <span data-ttu-id="32e63-161">如果惡意使用者提交或上載非常大的 XML 文件，可能會使 LINQ to XML 消耗過度的系統資源。</span><span class="sxs-lookup"><span data-stu-id="32e63-161">If a malicious user submits or uploads a very large XML document, it could cause LINQ to XML to consume excessive system resources.</span></span> <span data-ttu-id="32e63-162">這可能會造成阻絕服務攻擊。</span><span class="sxs-lookup"><span data-stu-id="32e63-162">This can constitute a denial of service attack.</span></span> <span data-ttu-id="32e63-163">為防止這個情況，您可以設定 <xref:System.Xml.XmlReaderSettings.MaxCharactersInDocument%2A?displayProperty=nameWithType> 屬性，並建立限制載入文件之大小的讀取器。</span><span class="sxs-lookup"><span data-stu-id="32e63-163">To prevent this, you can set the <xref:System.Xml.XmlReaderSettings.MaxCharactersInDocument%2A?displayProperty=nameWithType> property, and create a reader that is then limited in the size of document that it can load.</span></span> <span data-ttu-id="32e63-164">然後，您可以使用讀取器建立 XML 樹狀結構。</span><span class="sxs-lookup"><span data-stu-id="32e63-164">You then use the reader to create the XML tree.</span></span>  
  
 <span data-ttu-id="32e63-165">例如，如果您知道來自不受信任來源的 XML 文件預期大小上限將小於 50K 位元組，將 <xref:System.Xml.XmlReaderSettings.MaxCharactersInDocument%2A?displayProperty=nameWithType> 設定為 100,000。</span><span class="sxs-lookup"><span data-stu-id="32e63-165">For example, if you know that the maximum expected size of your XML documents coming from an untrusted source will be less than 50K bytes, set <xref:System.Xml.XmlReaderSettings.MaxCharactersInDocument%2A?displayProperty=nameWithType> to 100,000.</span></span> <span data-ttu-id="32e63-166">這將不會妨礙您處理 XML 文件，同時，這會降低文件上載時，消耗大量記憶體的阻絕服務威脅。</span><span class="sxs-lookup"><span data-stu-id="32e63-166">This will not encumber your processing of XML documents, and at the same time it will mitigate denial of service threats where documents might be uploaded that would consume large amounts of memory.</span></span>  
  
### <a name="avoid-excess-entity-expansion"></a><span data-ttu-id="32e63-167">避免過度擴充實體</span><span class="sxs-lookup"><span data-stu-id="32e63-167">Avoid Excess Entity Expansion</span></span>  
 <span data-ttu-id="32e63-168">使用 DTD 時，其中一個已知的阻絕服務攻擊為造成實體過度擴充的文件。</span><span class="sxs-lookup"><span data-stu-id="32e63-168">One of the known denial of service attacks when using a DTD is a document that causes excessive entity expansion.</span></span> <span data-ttu-id="32e63-169">為防止這個情況，您可以設定 <xref:System.Xml.XmlReaderSettings.MaxCharactersFromEntities%2A?displayProperty=nameWithType> 屬性，並建立限制實體擴充產生之字元數的讀取器。</span><span class="sxs-lookup"><span data-stu-id="32e63-169">To prevent this, you can set the <xref:System.Xml.XmlReaderSettings.MaxCharactersFromEntities%2A?displayProperty=nameWithType> property, and create a reader that is then limited in the number of characters that result from entity expansion.</span></span> <span data-ttu-id="32e63-170">然後，您可以使用讀取器建立 XML 樹狀結構。</span><span class="sxs-lookup"><span data-stu-id="32e63-170">You then use the reader to create the XML tree.</span></span>  
  
### <a name="limit-the-depth-of-the-xml-hierarchy"></a><span data-ttu-id="32e63-171">限制 XML 階層的深度</span><span class="sxs-lookup"><span data-stu-id="32e63-171">Limit the Depth of the XML Hierarchy</span></span>  
 <span data-ttu-id="32e63-172">其中一個可能的阻絕服務攻擊會發生在提交階層過深的文件時。</span><span class="sxs-lookup"><span data-stu-id="32e63-172">One possible denial of service attack is when a document is submitted that has excessive depth of hierarchy.</span></span> <span data-ttu-id="32e63-173">為防止這個情況，您可以利用自己的類別，包裝計算項目深度的 <xref:System.Xml.XmlReader>。</span><span class="sxs-lookup"><span data-stu-id="32e63-173">To prevent this, you can wrap a <xref:System.Xml.XmlReader> in your own class that counts the depth of elements.</span></span> <span data-ttu-id="32e63-174">如果深度超過預先決定的合理層級，您可以中止惡意文件的處理。</span><span class="sxs-lookup"><span data-stu-id="32e63-174">If the depth exceeds a predetermined reasonable level, you can terminate the processing of the malicious document.</span></span>  
  
### <a name="protect-against-untrusted-xmlreader-or-xmlwriter-implementations"></a><span data-ttu-id="32e63-175">防止不受信任的 XmlReader 或 XmlWriter 實作</span><span class="sxs-lookup"><span data-stu-id="32e63-175">Protect Against Untrusted XmlReader or XmlWriter Implementations</span></span>  
 <span data-ttu-id="32e63-176">管理員應該確認外部提供的任何 <xref:System.Xml.XmlReader> 或 <xref:System.Xml.XmlWriter> 實作具有強式名稱，而且已經在電腦組態中註冊。</span><span class="sxs-lookup"><span data-stu-id="32e63-176">Administrators should verify that any externally supplied <xref:System.Xml.XmlReader> or <xref:System.Xml.XmlWriter> implementations have strong names and have been registered in the machine configuration.</span></span> <span data-ttu-id="32e63-177">這樣可以防止惡意程式碼偽裝成讀取器或寫入器進行載入。</span><span class="sxs-lookup"><span data-stu-id="32e63-177">This prevents malicious code masquerading as a reader or writer from being loaded.</span></span>  
  
### <a name="periodically-free-objects-that-reference-xname"></a><span data-ttu-id="32e63-178">定期釋放參考 Xname 的物件</span><span class="sxs-lookup"><span data-stu-id="32e63-178">Periodically Free Objects that Reference XName</span></span>  
 <span data-ttu-id="32e63-179">為防止特定種類的攻擊，應用程式設計人員應該在應用程式網域中，定期釋放參考 <xref:System.Xml.Linq.XName> 物件的所有物件。</span><span class="sxs-lookup"><span data-stu-id="32e63-179">To protect against certain kinds of attacks, application programmers should free all objects that reference an <xref:System.Xml.Linq.XName> object in the application domain on a regular basis.</span></span>  
  
### <a name="protect-against-random-xml-names"></a><span data-ttu-id="32e63-180">防止 XML 隨機名稱</span><span class="sxs-lookup"><span data-stu-id="32e63-180">Protect Against Random XML Names</span></span>  
 <span data-ttu-id="32e63-181">從未受信任來源取出資料的應用程式應該考慮使用以自訂程式碼包裝的 <xref:System.Xml.XmlReader> 來檢查 XML 隨機名稱與命名空間的可能性。</span><span class="sxs-lookup"><span data-stu-id="32e63-181">Applications that take data from untrusted sources should consider using an <xref:System.Xml.XmlReader> that is wrapped in custom code to inspect for the possibility of random XML names and namespaces.</span></span> <span data-ttu-id="32e63-182">如果偵測到這類的 XML 隨機名稱與命名空間，應用程式可以中止惡意文件的處理。</span><span class="sxs-lookup"><span data-stu-id="32e63-182">If such random XML names and namespaces are detected, the application can then terminate the processing of the malicious document.</span></span>  
  
 <span data-ttu-id="32e63-183">您可能想要在任何指定的命名空間 (包括沒有命名空間中的名稱) 中，將名稱數限制為合理的限制。</span><span class="sxs-lookup"><span data-stu-id="32e63-183">You might want to limit the number of names in any given namespace (including names in no namespace) to a reasonable limit.</span></span>  
  
### <a name="annotations-are-accessible-by-software-components-that-share-a-linq-to-xml-tree"></a><span data-ttu-id="32e63-184">附註可由共用 LINQ to XML 樹狀結構的軟體元件存取</span><span class="sxs-lookup"><span data-stu-id="32e63-184">Annotations Are Accessible by Software Components that Share a LINQ to XML Tree</span></span>  
 <span data-ttu-id="32e63-185">LINQ to XML 可用於建置處理管線，其中的不同應用程式元件可以載入、驗證、查詢、轉換、更新與儲存在元件之間當做 XML 樹狀結構傳遞的 XML 資料。</span><span class="sxs-lookup"><span data-stu-id="32e63-185">LINQ to XML could be used to build processing pipelines in which different application components load, validate, query, transform, update, and save XML data that is passed between components as XML trees.</span></span> <span data-ttu-id="32e63-186">由於將物件載入並序列化為 XML 文字的負荷僅能在管線尾端完成，因此這可能有助於將效能最佳化。</span><span class="sxs-lookup"><span data-stu-id="32e63-186">This can help optimize performance, because the overhead of loading and serializing objects to XML text is done only at the ends of the pipeline.</span></span> <span data-ttu-id="32e63-187">不過，開發人員必須知道透過一個元件所建立的所有附註和事件處理常式都可以存取其他元件。</span><span class="sxs-lookup"><span data-stu-id="32e63-187">Developers must be aware, however, that all annotations and event handlers created by one component are accessible to other components.</span></span> <span data-ttu-id="32e63-188">如果這些元件有不同程度的信任，這可能會產生數個弱點。</span><span class="sxs-lookup"><span data-stu-id="32e63-188">This can create a number of vulnerabilities if the components have different levels of trust.</span></span> <span data-ttu-id="32e63-189">若要透過較不受信任的元件建置安全的管線，您必須先將 LINQ to XML 物件序列化為 XML 文字，然後再將資料傳遞到不受信任的元件。</span><span class="sxs-lookup"><span data-stu-id="32e63-189">To build secure pipelines across less trusted components, you must serialize LINQ to XML objects to XML text before passing the data to an untrusted component.</span></span>  
  
 <span data-ttu-id="32e63-190">有些安全性是由 Common Language Runtime (CLR) 提供。</span><span class="sxs-lookup"><span data-stu-id="32e63-190">Some security is provided by the common language runtime (CLR).</span></span> <span data-ttu-id="32e63-191">例如，不包含私用類別的元件無法存取透過該類別輸入的附註。</span><span class="sxs-lookup"><span data-stu-id="32e63-191">For example, a component that does not include a private class cannot access annotations keyed by that class.</span></span> <span data-ttu-id="32e63-192">不過，無法讀取附註的元件可以刪除這些附註。</span><span class="sxs-lookup"><span data-stu-id="32e63-192">However, annotations can be deleted by components that cannot read them.</span></span> <span data-ttu-id="32e63-193">這可以當做竄改攻擊使用。</span><span class="sxs-lookup"><span data-stu-id="32e63-193">This could be used as a tampering attack.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="32e63-194">另請參閱</span><span class="sxs-lookup"><span data-stu-id="32e63-194">See also</span></span>

- [<span data-ttu-id="32e63-195">程式設計手冊 (LINQ to XML) (C#)</span><span class="sxs-lookup"><span data-stu-id="32e63-195">Programming Guide (LINQ to XML) (C#)</span></span>](linq-to-xml-overview.md)
