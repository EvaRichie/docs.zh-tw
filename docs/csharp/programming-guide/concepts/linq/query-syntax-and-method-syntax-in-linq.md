---
title: LINQ 中的查詢語法及方法語法 (C#)
description: 瞭解 LINQ 中的查詢語法和方法語法。 這包括標準查詢運算子擴充方法和 lambda 運算式。
ms.date: 07/20/2015
helpviewer_keywords:
- LINQ [C#], query syntax vs. method syntax
- queries [LINQ in C#], syntax comparisons
ms.assetid: eedd6dd9-fec2-428c-9581-5b8783810ded
ms.openlocfilehash: 14319c7ec17c3186bfbd11875ee0d4480de7e3ff
ms.sourcegitcommit: 5b475c1855b32cf78d2d1bbb4295e4c236f39464
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 09/24/2020
ms.locfileid: "91157560"
---
# <a name="query-syntax-and-method-syntax-in-linq-c"></a><span data-ttu-id="115b1-104">LINQ 中的查詢語法及方法語法 (C#)</span><span class="sxs-lookup"><span data-stu-id="115b1-104">Query Syntax and Method Syntax in LINQ (C#)</span></span>

<span data-ttu-id="115b1-105">簡介語言整合查詢中的大部分查詢 (LINQ) 檔是使用 LINQ 宣告式查詢語法所撰寫。</span><span class="sxs-lookup"><span data-stu-id="115b1-105">Most queries in the introductory Language Integrated Query (LINQ) documentation are written by using the LINQ declarative query syntax.</span></span> <span data-ttu-id="115b1-106">不過，編譯程式碼時，必須將查詢語法轉譯成 .NET Common Language Runtime (CLR) 的方法呼叫。</span><span class="sxs-lookup"><span data-stu-id="115b1-106">However, the query syntax must be translated into method calls for the .NET common language runtime (CLR) when the code is compiled.</span></span> <span data-ttu-id="115b1-107">這些方法呼叫會叫用標準查詢運算子，而其具有 `Where`、`Select`、`GroupBy`、`Join`、`Max` 和 `Average` 這類名稱。</span><span class="sxs-lookup"><span data-stu-id="115b1-107">These method calls invoke the standard query operators, which have names such as `Where`, `Select`, `GroupBy`, `Join`, `Max`, and `Average`.</span></span> <span data-ttu-id="115b1-108">您可以使用方法語法來直接呼叫它們，而不是使用查詢語法。</span><span class="sxs-lookup"><span data-stu-id="115b1-108">You can call them directly by using method syntax instead of query syntax.</span></span>  
  
 <span data-ttu-id="115b1-109">查詢語法和方法語法的語意相同，但許多人都發現查詢語法較為簡單且更容易閱讀。</span><span class="sxs-lookup"><span data-stu-id="115b1-109">Query syntax and method syntax are semantically identical, but many people find query syntax simpler and easier to read.</span></span> <span data-ttu-id="115b1-110">某些查詢必須以方法呼叫形式表示。</span><span class="sxs-lookup"><span data-stu-id="115b1-110">Some queries must be expressed as method calls.</span></span> <span data-ttu-id="115b1-111">例如，您必須使用方法呼叫，來表示可擷取符合所指定條件的項目數的查詢。</span><span class="sxs-lookup"><span data-stu-id="115b1-111">For example, you must use a method call to express a query that retrieves the number of elements that match a specified condition.</span></span> <span data-ttu-id="115b1-112">您也必須針對擷取來源序列中具有最大值的項目的查詢，使用方法呼叫。</span><span class="sxs-lookup"><span data-stu-id="115b1-112">You also must use a method call for a query that retrieves the element that has the maximum value in a source sequence.</span></span> <span data-ttu-id="115b1-113"><xref:System.Linq> 命名空間中標準查詢運算子的參考文件一般會使用方法語法。</span><span class="sxs-lookup"><span data-stu-id="115b1-113">The reference documentation for the standard query operators in the <xref:System.Linq> namespace generally uses method syntax.</span></span> <span data-ttu-id="115b1-114">因此，即使在開始撰寫 LINQ 查詢時，熟悉如何在查詢和查詢運算式本身中使用方法語法會很有用。</span><span class="sxs-lookup"><span data-stu-id="115b1-114">Therefore, even when getting started writing LINQ queries, it is useful to be familiar with how to use method syntax in queries and in query expressions themselves.</span></span>  
  
## <a name="standard-query-operator-extension-methods"></a><span data-ttu-id="115b1-115">標準查詢運算子擴充方法</span><span class="sxs-lookup"><span data-stu-id="115b1-115">Standard Query Operator Extension Methods</span></span>  

 <span data-ttu-id="115b1-116">下列範例示範簡單「查詢運算式」\*\* 以及撰寫為「方法查詢」\*\* 的語意對等查詢。</span><span class="sxs-lookup"><span data-stu-id="115b1-116">The following example shows a simple *query expression* and the semantically equivalent query written as a *method-based query*.</span></span>  
  
 [!code-csharp[csLINQGettingStarted#22](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQGettingStarted/CS/Class1.cs#22)]  
  
 <span data-ttu-id="115b1-117">這兩個範例的輸出完全相同。</span><span class="sxs-lookup"><span data-stu-id="115b1-117">The output from the two examples is identical.</span></span> <span data-ttu-id="115b1-118">您可以看到查詢變數的類型在兩種形式中都相同：<xref:System.Collections.Generic.IEnumerable%601>。</span><span class="sxs-lookup"><span data-stu-id="115b1-118">You can see that the type of the query variable is the same in both forms: <xref:System.Collections.Generic.IEnumerable%601>.</span></span>  
  
 <span data-ttu-id="115b1-119">若要了解方法查詢，讓我們更深入進行探討。</span><span class="sxs-lookup"><span data-stu-id="115b1-119">To understand the method-based query, let's examine it more closely.</span></span> <span data-ttu-id="115b1-120">在運算式右側，請注意，`where` 子句會立即表示為 `numbers` 物件上的執行個體方法，您應該記得有一種 `IEnumerable<int>` 的類型。</span><span class="sxs-lookup"><span data-stu-id="115b1-120">On the right side of the expression, notice that the `where` clause is now expressed as an instance method on the `numbers` object, which as you will recall has a type of `IEnumerable<int>`.</span></span> <span data-ttu-id="115b1-121">如果您熟悉泛型 <xref:System.Collections.Generic.IEnumerable%601> 介面，則會知道它沒有 `Where` 方法。</span><span class="sxs-lookup"><span data-stu-id="115b1-121">If you are familiar with the generic <xref:System.Collections.Generic.IEnumerable%601> interface, you know that it does not have a `Where` method.</span></span> <span data-ttu-id="115b1-122">不過，如果您在 Visual Studio IDE 中叫用 IntelliSense 完成清單，則不只會看到 `Where` 方法，還會看到許多其他方法，例如 `Select`、`SelectMany`、`Join` 和 `Orderby`。</span><span class="sxs-lookup"><span data-stu-id="115b1-122">However, if you invoke the IntelliSense completion list in the Visual Studio IDE, you will see not only a `Where` method, but many other methods such as `Select`, `SelectMany`, `Join`, and `Orderby`.</span></span> <span data-ttu-id="115b1-123">這些都是標準查詢運算子。</span><span class="sxs-lookup"><span data-stu-id="115b1-123">These are all the standard query operators.</span></span>  
  
 ![顯示 Intellisense 中所有標準查詢運算子的螢幕擷取畫面。](./media/query-syntax-and-method-syntax-in-linq/standard-query-operators.png)  
  
 <span data-ttu-id="115b1-125">雖然看起來就像已重新定義 <xref:System.Collections.Generic.IEnumerable%601> 來包含這些額外方法，但是實際上卻不是。</span><span class="sxs-lookup"><span data-stu-id="115b1-125">Although it looks as if <xref:System.Collections.Generic.IEnumerable%601> has been redefined to include these additional methods, in fact this is not the case.</span></span> <span data-ttu-id="115b1-126">標準查詢運算子會實作為一種稱為「擴充方法」\*\* 的新方法。</span><span class="sxs-lookup"><span data-stu-id="115b1-126">The standard query operators are implemented as a new kind of method called *extension methods*.</span></span> <span data-ttu-id="115b1-127">擴充方法會「擴充」現有類型，其呼叫方式就像它們是類型上的執行個體方法一樣。</span><span class="sxs-lookup"><span data-stu-id="115b1-127">Extensions methods "extend" an existing type; they can be called as if they were instance methods on the type.</span></span> <span data-ttu-id="115b1-128">標準查詢運算子可擴充 <xref:System.Collections.Generic.IEnumerable%601>，而且這是您可以撰寫 `numbers.Where(...)` 的原因。</span><span class="sxs-lookup"><span data-stu-id="115b1-128">The standard query operators extend <xref:System.Collections.Generic.IEnumerable%601> and that is why you can write `numbers.Where(...)`.</span></span>  
  
 <span data-ttu-id="115b1-129">若要開始使用 LINQ，您真正必須知道的擴充方法，就是如何使用正確的指示詞將它們帶入應用程式範圍中 `using` 。</span><span class="sxs-lookup"><span data-stu-id="115b1-129">To get started using LINQ, all that you really have to know about extension methods is how to bring them into scope in your application by using the correct `using` directives.</span></span> <span data-ttu-id="115b1-130">從您應用程式的觀點來看，擴充方法和一般執行個體方法都相同。</span><span class="sxs-lookup"><span data-stu-id="115b1-130">From your application's point of view, an extension method and a regular instance method are the same.</span></span>  
  
 <span data-ttu-id="115b1-131">如需擴充方法的詳細資訊，請參閱[擴充方法](../../classes-and-structs/extension-methods.md)。</span><span class="sxs-lookup"><span data-stu-id="115b1-131">For more information about extension methods, see [Extension Methods](../../classes-and-structs/extension-methods.md).</span></span> <span data-ttu-id="115b1-132">如需標準查詢運算子的詳細資訊，請參閱[標準查詢運算子概觀 (C#)](./standard-query-operators-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="115b1-132">For more information about standard query operators, see [Standard Query Operators Overview (C#)](./standard-query-operators-overview.md).</span></span> <span data-ttu-id="115b1-133">某些 LINQ 提供者（例如 [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] 和 [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] ）會針對其他類型，執行自己的標準查詢運算子和其他擴充方法 <xref:System.Collections.Generic.IEnumerable%601> 。</span><span class="sxs-lookup"><span data-stu-id="115b1-133">Some LINQ providers, such as [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] and [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)], implement their own standard query operators and additional extension methods for other types besides <xref:System.Collections.Generic.IEnumerable%601>.</span></span>  
  
## <a name="lambda-expressions"></a><span data-ttu-id="115b1-134">Lambda 運算式</span><span class="sxs-lookup"><span data-stu-id="115b1-134">Lambda Expressions</span></span>  

 <span data-ttu-id="115b1-135">在上述範例中，請注意，條件運算式 (`num % 2 == 0`) 會傳遞為 `Where` 方法的內嵌引數︰`Where(num => num % 2 == 0).` 這個內嵌運算式稱為 Lambda 運算式。</span><span class="sxs-lookup"><span data-stu-id="115b1-135">In the previous example, notice that the conditional expression (`num % 2 == 0`) is passed as an in-line argument to the `Where` method: `Where(num => num % 2 == 0).` This inline expression is called a lambda expression.</span></span> <span data-ttu-id="115b1-136">它方便您撰寫程式碼，而這些程式碼之前必須以更難處理的形式撰寫為匿名方法、泛型委派或運算式樹狀結構。</span><span class="sxs-lookup"><span data-stu-id="115b1-136">It is a convenient way to write code that would otherwise have to be written in more cumbersome form as an anonymous method or a generic delegate or an expression tree.</span></span> <span data-ttu-id="115b1-137">在 C# 中，`=>` 是 Lambda 運算子，視為「到」。</span><span class="sxs-lookup"><span data-stu-id="115b1-137">In C# `=>` is the lambda operator, which is read as "goes to".</span></span> <span data-ttu-id="115b1-138">運算子左側的 `num` 是對應到查詢運算式中 `num` 的輸入變數。</span><span class="sxs-lookup"><span data-stu-id="115b1-138">The `num` on the left of the operator is the input variable which corresponds to `num` in the query expression.</span></span> <span data-ttu-id="115b1-139">編譯器可以推斷 `num` 類型，因為它知道 `numbers` 是泛型 <xref:System.Collections.Generic.IEnumerable%601> 類型。</span><span class="sxs-lookup"><span data-stu-id="115b1-139">The compiler can infer the type of `num` because it knows that `numbers` is a generic <xref:System.Collections.Generic.IEnumerable%601> type.</span></span> <span data-ttu-id="115b1-140">Lambda 的主體就與查詢語法或任何 C# 運算式或陳述式中的運算式相同，它可以包含方法呼叫和其他複雜邏輯。</span><span class="sxs-lookup"><span data-stu-id="115b1-140">The body of the lambda is just the same as the expression in query syntax or in any other C# expression or statement; it can include method calls and other complex logic.</span></span> <span data-ttu-id="115b1-141">「傳回值」就是運算式結果。</span><span class="sxs-lookup"><span data-stu-id="115b1-141">The "return value" is just the expression result.</span></span>  
  
 <span data-ttu-id="115b1-142">若要開始使用 LINQ，您不需要廣泛地使用 lambda。</span><span class="sxs-lookup"><span data-stu-id="115b1-142">To get started using LINQ, you do not have to use lambdas extensively.</span></span> <span data-ttu-id="115b1-143">不過，只能在方法語法中表示特定查詢，而其中有一部分需要 Lambda 運算式。</span><span class="sxs-lookup"><span data-stu-id="115b1-143">However, certain queries can only be expressed in method syntax and some of those require lambda expressions.</span></span> <span data-ttu-id="115b1-144">當您更熟悉 lambda 之後，您會發現它們在您的 LINQ 工具箱中是一項功能強大且有彈性的工具。</span><span class="sxs-lookup"><span data-stu-id="115b1-144">After you become more familiar with lambdas, you will find that they are a powerful and flexible tool in your LINQ toolbox.</span></span> <span data-ttu-id="115b1-145">如需詳細資訊，請參閱 [Lambda 運算式](../../../language-reference/operators/lambda-expressions.md)。</span><span class="sxs-lookup"><span data-stu-id="115b1-145">For more information, see [Lambda Expressions](../../../language-reference/operators/lambda-expressions.md).</span></span>  
  
## <a name="composability-of-queries"></a><span data-ttu-id="115b1-146">查詢的編寫性</span><span class="sxs-lookup"><span data-stu-id="115b1-146">Composability of Queries</span></span>  

 <span data-ttu-id="115b1-147">在上述程式碼範例，請注意，在 `Where` 呼叫上使用點運算子來叫用 `OrderBy` 方法。</span><span class="sxs-lookup"><span data-stu-id="115b1-147">In the previous code example, note that the `OrderBy` method is invoked by using the dot operator on the call to `Where`.</span></span> <span data-ttu-id="115b1-148">`Where` 會產生已篩選的序列，而 `Orderby` 接著會透過排序來運作於該序列。</span><span class="sxs-lookup"><span data-stu-id="115b1-148">`Where` produces a filtered sequence, and then `Orderby` operates on that sequence by sorting it.</span></span> <span data-ttu-id="115b1-149">因為查詢會傳回 `IEnumerable`，所以您可以將方法呼叫鏈結在一起，以在方法語法中撰寫它們。</span><span class="sxs-lookup"><span data-stu-id="115b1-149">Because queries return an `IEnumerable`, you compose them in method syntax by chaining the method calls together.</span></span> <span data-ttu-id="115b1-150">當您使用查詢語法來撰寫查詢時，這是編譯器在幕後執行的作業。</span><span class="sxs-lookup"><span data-stu-id="115b1-150">This is what the compiler does behind the scenes when you write queries by using query syntax.</span></span> <span data-ttu-id="115b1-151">因為查詢變數不會儲存查詢的結果，所以您隨時都可以修改它，或使用它作為新查詢的基礎，即使已經執行之後也是一樣。</span><span class="sxs-lookup"><span data-stu-id="115b1-151">And because a query variable does not store the results of the query, you can modify it or use it as the basis for a new query at any time, even after it has been executed.</span></span>  
