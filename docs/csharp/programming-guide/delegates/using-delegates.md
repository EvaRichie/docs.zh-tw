---
title: 使用委派 - C# 程式設計手冊
ms.date: 07/20/2015
helpviewer_keywords:
- delegates [C#], how to use
ms.assetid: 99a2fc27-a32e-4a34-921c-e65497520eec
ms.openlocfilehash: 9a81ee5ccdc2697ca435d40be27568b651977f96
ms.sourcegitcommit: a241301495a84cc8c64fe972330d16edd619868b
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 06/01/2020
ms.locfileid: "84241587"
---
# <a name="using-delegates-c-programming-guide"></a><span data-ttu-id="93fe6-102">使用委派 (C# 程式設計手冊)</span><span class="sxs-lookup"><span data-stu-id="93fe6-102">Using Delegates (C# Programming Guide)</span></span>

<span data-ttu-id="93fe6-103">[委派](../../language-reference/builtin-types/reference-types.md)是可以安全封裝方法的類型，類似於 C 和 C++ 中的函式指標。</span><span class="sxs-lookup"><span data-stu-id="93fe6-103">A [delegate](../../language-reference/builtin-types/reference-types.md) is a type that safely encapsulates a method, similar to a function pointer in C and C++.</span></span> <span data-ttu-id="93fe6-104">與 C 函式指標不同之處在於，委派為物件導向且類型安全，同時安全性較佳。</span><span class="sxs-lookup"><span data-stu-id="93fe6-104">Unlike C function pointers, delegates are object-oriented, type safe, and secure.</span></span> <span data-ttu-id="93fe6-105">委派的類型由委派的名稱所定義。</span><span class="sxs-lookup"><span data-stu-id="93fe6-105">The type of a delegate is defined by the name of the delegate.</span></span> <span data-ttu-id="93fe6-106">下列範例宣告名為 `Del` 的委派，其可封裝採用[字串](../../language-reference/builtin-types/reference-types.md)作為引數並傳回 [void](../../language-reference/builtin-types/void.md) 的方法：</span><span class="sxs-lookup"><span data-stu-id="93fe6-106">The following example declares a delegate named `Del` that can encapsulate a method that takes a [string](../../language-reference/builtin-types/reference-types.md) as an argument and returns [void](../../language-reference/builtin-types/void.md):</span></span>

[!code-csharp[csProgGuideDelegates#21](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideDelegates/CS/Delegates.cs#21)]

<span data-ttu-id="93fe6-107">通常會透過提供委派將包裝的方法名稱，或使用[匿名函式](../statements-expressions-operators/anonymous-functions.md)，來建構委派物件。</span><span class="sxs-lookup"><span data-stu-id="93fe6-107">A delegate object is normally constructed by providing the name of the method the delegate will wrap, or with an [anonymous function](../statements-expressions-operators/anonymous-functions.md).</span></span> <span data-ttu-id="93fe6-108">一旦對委派執行個體化之後，該委派即會將該委派的方法呼叫，傳遞至該方法。</span><span class="sxs-lookup"><span data-stu-id="93fe6-108">Once a delegate is instantiated, a method call made to the delegate will be passed by the delegate to that method.</span></span> <span data-ttu-id="93fe6-109">由呼叫端傳遞至委派的參數，會傳遞至該方法，而從該方法傳回的值（如果有的話）會由該委派傳回至呼叫端。</span><span class="sxs-lookup"><span data-stu-id="93fe6-109">The parameters passed to the delegate by the caller are passed to the method, and the return value, if any, from the method is returned to the caller by the delegate.</span></span> <span data-ttu-id="93fe6-110">這稱為叫用委派。</span><span class="sxs-lookup"><span data-stu-id="93fe6-110">This is known as invoking the delegate.</span></span> <span data-ttu-id="93fe6-111">執行個體化的委派的叫用方法，就像其自身為包裝的方法一樣。</span><span class="sxs-lookup"><span data-stu-id="93fe6-111">An instantiated delegate can be invoked as if it were the wrapped method itself.</span></span> <span data-ttu-id="93fe6-112">例如：</span><span class="sxs-lookup"><span data-stu-id="93fe6-112">For example:</span></span>

[!code-csharp[csProgGuideDelegates#22](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideDelegates/CS/Delegates.cs#22)]  

[!code-csharp[csProgGuideDelegates#23](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideDelegates/CS/Delegates.cs#23)]

<span data-ttu-id="93fe6-113">委派類型衍生自 <xref:System.Delegate> .net 中的類別。</span><span class="sxs-lookup"><span data-stu-id="93fe6-113">Delegate types are derived from the <xref:System.Delegate> class in .NET.</span></span> <span data-ttu-id="93fe6-114">委派類型是[密封](../../language-reference/keywords/sealed.md)的，不能作為其他類型的衍生來源，且不可能從 <xref:System.Delegate> 衍生自訂類別。</span><span class="sxs-lookup"><span data-stu-id="93fe6-114">Delegate types are [sealed](../../language-reference/keywords/sealed.md)—they cannot be derived from— and it is not possible to derive custom classes from <xref:System.Delegate>.</span></span> <span data-ttu-id="93fe6-115">因為執行個體化的委派是物件，所以它可以做為參數傳遞或指派給屬性。</span><span class="sxs-lookup"><span data-stu-id="93fe6-115">Because the instantiated delegate is an object, it can be passed as a parameter, or assigned to a property.</span></span> <span data-ttu-id="93fe6-116">這可讓方法以參數方式接受委派，並於稍後呼叫委派。</span><span class="sxs-lookup"><span data-stu-id="93fe6-116">This allows a method to accept a delegate as a parameter, and call the delegate at some later time.</span></span> <span data-ttu-id="93fe6-117">這稱為非同步回呼，是較長處理序完成時通知呼叫端的常用方法。</span><span class="sxs-lookup"><span data-stu-id="93fe6-117">This is known as an asynchronous callback, and is a common method of notifying a caller when a long process has completed.</span></span> <span data-ttu-id="93fe6-118">以這種方式使用委派時，使用委派的程式碼不需要了解如何實作所用的方法。</span><span class="sxs-lookup"><span data-stu-id="93fe6-118">When a delegate is used in this fashion, the code using the delegate does not need any knowledge of the implementation of the method being used.</span></span> <span data-ttu-id="93fe6-119">該功能類似於介面提供的封裝。</span><span class="sxs-lookup"><span data-stu-id="93fe6-119">The functionality is similar to the encapsulation interfaces provide.</span></span>

<span data-ttu-id="93fe6-120">回呼的另一種常見用法是定義自訂比較方法，並將該委派傳遞至排序方法。</span><span class="sxs-lookup"><span data-stu-id="93fe6-120">Another common use of callbacks is defining a custom comparison method and passing that delegate to a sort method.</span></span> <span data-ttu-id="93fe6-121">它可讓呼叫端程式碼成為排序演算法的一部分。</span><span class="sxs-lookup"><span data-stu-id="93fe6-121">It allows the caller's code to become part of the sort algorithm.</span></span> <span data-ttu-id="93fe6-122">下列的範例方法使用 `Del` 類型做為參數：</span><span class="sxs-lookup"><span data-stu-id="93fe6-122">The following example method uses the `Del` type as a parameter:</span></span>

[!code-csharp[csProgGuideDelegates#24](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideDelegates/CS/Delegates.cs#24)]

<span data-ttu-id="93fe6-123">然後，您可以將上述所建立的委派傳遞至該方法：</span><span class="sxs-lookup"><span data-stu-id="93fe6-123">You can then pass the delegate created above to that method:</span></span>

[!code-csharp[csProgGuideDelegates#25](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideDelegates/CS/Delegates.cs#25)]

<span data-ttu-id="93fe6-124">並且會在主控台中收到下列輸出：</span><span class="sxs-lookup"><span data-stu-id="93fe6-124">and receive the following output to the console:</span></span>

```console
The number is: 3
```

<span data-ttu-id="93fe6-125">使用委派做為抽象概念，`MethodWithCallback` 不需要直接呼叫主控台 — 設計時不需要一直考慮主控台。</span><span class="sxs-lookup"><span data-stu-id="93fe6-125">Using the delegate as an abstraction, `MethodWithCallback` does not need to call the console directly—it does not have to be designed with a console in mind.</span></span> <span data-ttu-id="93fe6-126">`MethodWithCallback` 所做的只是準備一個字串，然後將該字串傳遞給另一個方法。</span><span class="sxs-lookup"><span data-stu-id="93fe6-126">What `MethodWithCallback` does is simply prepare a string and pass the string to another method.</span></span> <span data-ttu-id="93fe6-127">這項功能十分強大，因為委派的方法可以使用任何數目的參數。</span><span class="sxs-lookup"><span data-stu-id="93fe6-127">This is especially powerful since a delegated method can use any number of parameters.</span></span>

<span data-ttu-id="93fe6-128">當委派建構為要包裝執行個體方法時，該委派會參考執行個體與方法。</span><span class="sxs-lookup"><span data-stu-id="93fe6-128">When a delegate is constructed to wrap an instance method, the delegate references both the instance and the method.</span></span> <span data-ttu-id="93fe6-129">除了委派所包裝的方法之外，委派也不會知道執行個體的類型，因此委派可參考任何類型的物件，只要該物件上存在符合委派簽章的方法即可。</span><span class="sxs-lookup"><span data-stu-id="93fe6-129">A delegate has no knowledge of the instance type aside from the method it wraps, so a delegate can refer to any type of object as long as there is a method on that object that matches the delegate signature.</span></span> <span data-ttu-id="93fe6-130">當委派建構為會包裝靜態方法時，它只會參考該方法。</span><span class="sxs-lookup"><span data-stu-id="93fe6-130">When a delegate is constructed to wrap a static method, it only references the method.</span></span> <span data-ttu-id="93fe6-131">請考慮下列宣告：</span><span class="sxs-lookup"><span data-stu-id="93fe6-131">Consider the following declarations:</span></span>

[!code-csharp[csProgGuideDelegates#26](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideDelegates/CS/Delegates.cs#26)]

<span data-ttu-id="93fe6-132">連同先前所示的靜態 `DelegateMethod`，我們現在有三種方法，可以由 `Del` 執行個體進行包裝。</span><span class="sxs-lookup"><span data-stu-id="93fe6-132">Along with the static `DelegateMethod` shown previously, we now have three methods that can be wrapped by a `Del` instance.</span></span>

<span data-ttu-id="93fe6-133">叫用委派時，可以呼叫一個以上的方法。</span><span class="sxs-lookup"><span data-stu-id="93fe6-133">A delegate can call more than one method when invoked.</span></span> <span data-ttu-id="93fe6-134">這稱為多點傳送。</span><span class="sxs-lookup"><span data-stu-id="93fe6-134">This is referred to as multicasting.</span></span> <span data-ttu-id="93fe6-135">若要將一個額外的方法加入委派的方法清單 (引動過程清單)，只需使用加法或加法指派運算子 ('+' 或 '+ =')，相加兩個委派即可。</span><span class="sxs-lookup"><span data-stu-id="93fe6-135">To add an extra method to the delegate's list of methods—the invocation list—simply requires adding two delegates using the addition or addition assignment operators ('+' or '+=').</span></span> <span data-ttu-id="93fe6-136">例如：</span><span class="sxs-lookup"><span data-stu-id="93fe6-136">For example:</span></span>

[!code-csharp[csProgGuideDelegates#27](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideDelegates/CS/Delegates.cs#27)]

<span data-ttu-id="93fe6-137">此時，`allMethodsDelegate` 在其引動過程清單中包含三種方法：`Method1`、`Method2` 和 `DelegateMethod`。</span><span class="sxs-lookup"><span data-stu-id="93fe6-137">At this point `allMethodsDelegate` contains three methods in its invocation list—`Method1`, `Method2`, and `DelegateMethod`.</span></span> <span data-ttu-id="93fe6-138">原始的三個委派 `d1`、`d2` 和 `d3` 維持不變。</span><span class="sxs-lookup"><span data-stu-id="93fe6-138">The original three delegates, `d1`, `d2`, and `d3`, remain unchanged.</span></span> <span data-ttu-id="93fe6-139">當叫用 `allMethodsDelegate` 時，會依序呼叫所有三個方法。</span><span class="sxs-lookup"><span data-stu-id="93fe6-139">When `allMethodsDelegate` is invoked, all three methods are called in order.</span></span> <span data-ttu-id="93fe6-140">如果委派使用參考參數，則參考會依序傳入這三個方法中的每一個，而且任一方法所做的任何變更，下一個方法都看得到。</span><span class="sxs-lookup"><span data-stu-id="93fe6-140">If the delegate uses reference parameters, the reference is passed sequentially to each of the three methods in turn, and any changes by one method are visible to the next method.</span></span> <span data-ttu-id="93fe6-141">當任一方法擲回未在該方法內攔截到例外狀況時，該例外狀況會傳遞至委派的呼叫端，且不會呼叫引動過程清單中的任何後續方法。</span><span class="sxs-lookup"><span data-stu-id="93fe6-141">When any of the methods throws an exception that is not caught within the method, that exception is passed to the caller of the delegate and no subsequent methods in the invocation list are called.</span></span> <span data-ttu-id="93fe6-142">如果委派具有傳回值和 (或) 輸出參數，則它會傳回所叫用之最後一個方法的傳回值與參數。</span><span class="sxs-lookup"><span data-stu-id="93fe6-142">If the delegate has a return value and/or out parameters, it returns the return value and parameters of the last method invoked.</span></span> <span data-ttu-id="93fe6-143">若要從調用清單中移除方法，請使用[減法或減法指派運算子](../../language-reference/operators/subtraction-operator.md)（ `-` 或 `-=` ）。</span><span class="sxs-lookup"><span data-stu-id="93fe6-143">To remove a method from the invocation list, use the [subtraction or subtraction assignment operators](../../language-reference/operators/subtraction-operator.md) (`-` or `-=`).</span></span> <span data-ttu-id="93fe6-144">例如：</span><span class="sxs-lookup"><span data-stu-id="93fe6-144">For example:</span></span>

[!code-csharp[csProgGuideDelegates#28](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideDelegates/CS/Delegates.cs#28)]

<span data-ttu-id="93fe6-145">因為委派類型衍生自 `System.Delegate`，所以可以在委派上呼叫該類別所定義的方法和屬性。</span><span class="sxs-lookup"><span data-stu-id="93fe6-145">Because delegate types are derived from `System.Delegate`, the methods and properties defined by that class can be called on the delegate.</span></span> <span data-ttu-id="93fe6-146">例如，若要求解委派引動過程清單中方法的數目，可以撰寫如下：</span><span class="sxs-lookup"><span data-stu-id="93fe6-146">For example, to find the number of methods in a delegate's invocation list, you may write:</span></span>

[!code-csharp[csProgGuideDelegates#29](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideDelegates/CS/Delegates.cs#29)]

<span data-ttu-id="93fe6-147">其委派引動過程清單中有一個以上方法的委派，衍生自 <xref:System.MulticastDelegate>，即 `System.Delegate` 的子類別。</span><span class="sxs-lookup"><span data-stu-id="93fe6-147">Delegates with more than one method in their invocation list derive from <xref:System.MulticastDelegate>, which is a subclass of `System.Delegate`.</span></span> <span data-ttu-id="93fe6-148">上述程式碼可以在任一情況下運作，因為這兩個類別都支援 `GetInvocationList`。</span><span class="sxs-lookup"><span data-stu-id="93fe6-148">The above code works in either case because both classes support `GetInvocationList`.</span></span>

<span data-ttu-id="93fe6-149">多點傳送委派常用於事件處理。</span><span class="sxs-lookup"><span data-stu-id="93fe6-149">Multicast delegates are used extensively in event handling.</span></span> <span data-ttu-id="93fe6-150">事件來源物件會將事件通知傳送給已註冊希望收到該事件的收件者物件。</span><span class="sxs-lookup"><span data-stu-id="93fe6-150">Event source objects send event notifications to recipient objects that have registered to receive that event.</span></span> <span data-ttu-id="93fe6-151">若要註冊接收事件，收件者會建立旨在處理事件的方法，然後建立該方法的委派，並將該委派傳遞至事件來源。</span><span class="sxs-lookup"><span data-stu-id="93fe6-151">To register for an event, the recipient creates a method designed to handle the event, then creates a delegate for that method and passes the delegate to the event source.</span></span> <span data-ttu-id="93fe6-152">在發生事件時，來源會呼叫委派。</span><span class="sxs-lookup"><span data-stu-id="93fe6-152">The source calls the delegate when the event occurs.</span></span> <span data-ttu-id="93fe6-153">接著，委派會呼叫收件者的事件處理方法，傳遞事件資料。</span><span class="sxs-lookup"><span data-stu-id="93fe6-153">The delegate then calls the event handling method on the recipient, delivering the event data.</span></span> <span data-ttu-id="93fe6-154">指定的事件之委派類型，由事件來源定義。</span><span class="sxs-lookup"><span data-stu-id="93fe6-154">The delegate type for a given event is defined by the event source.</span></span> <span data-ttu-id="93fe6-155">如需詳細資訊，請參閱[事件](../events/index.md)。</span><span class="sxs-lookup"><span data-stu-id="93fe6-155">For more, see [Events](../events/index.md).</span></span>

<span data-ttu-id="93fe6-156">比較兩個在編譯時間所指定的不同類型之委派，會導致編譯錯誤。</span><span class="sxs-lookup"><span data-stu-id="93fe6-156">Comparing delegates of two different types assigned at compile-time will result in a compilation error.</span></span> <span data-ttu-id="93fe6-157">如果委派執行個體是靜態類型的 `System.Delegate`，則允許比較，但會在執行階段傳回 false。</span><span class="sxs-lookup"><span data-stu-id="93fe6-157">If the delegate instances are statically of the type `System.Delegate`, then the comparison is allowed, but will return false at run time.</span></span> <span data-ttu-id="93fe6-158">例如：</span><span class="sxs-lookup"><span data-stu-id="93fe6-158">For example:</span></span>

[!code-csharp[csProgGuideDelegates#30](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideDelegates/CS/Delegates.cs#30)]

## <a name="see-also"></a><span data-ttu-id="93fe6-159">另請參閱</span><span class="sxs-lookup"><span data-stu-id="93fe6-159">See also</span></span>

- [<span data-ttu-id="93fe6-160">C # 程式設計指南</span><span class="sxs-lookup"><span data-stu-id="93fe6-160">C# Programming Guide</span></span>](../index.md)
- [<span data-ttu-id="93fe6-161">委派</span><span class="sxs-lookup"><span data-stu-id="93fe6-161">Delegates</span></span>](./index.md)
- [<span data-ttu-id="93fe6-162">在委派中使用變異數</span><span class="sxs-lookup"><span data-stu-id="93fe6-162">Using Variance in Delegates</span></span>](../concepts/covariance-contravariance/using-variance-in-delegates.md)
- [<span data-ttu-id="93fe6-163">委派中的變異數</span><span class="sxs-lookup"><span data-stu-id="93fe6-163">Variance in Delegates</span></span>](../concepts/covariance-contravariance/variance-in-delegates.md)
- [<span data-ttu-id="93fe6-164">針對 Func 與 Action 泛型委派使用變異數</span><span class="sxs-lookup"><span data-stu-id="93fe6-164">Using Variance for Func and Action Generic Delegates</span></span>](../concepts/covariance-contravariance/using-variance-for-func-and-action-generic-delegates.md)
- [<span data-ttu-id="93fe6-165">事件</span><span class="sxs-lookup"><span data-stu-id="93fe6-165">Events</span></span>](../events/index.md)
